{"path":"sem2/PProg/VRL/extra/benji/PProg-w06-benji.pdf","text":"Parallel Programming Exercise Session 6 Spring 2024 Today Post-Discussion Ex. 5 50’ + more Theory Break Pre-Discussion Ex. 6 10’ Quiz 8’ Exam Preparation Session Monday, April 6, 10:15 – 12:00 HG F 7 Hosted by Julianne Orel and Finn Heckman Post-Discussion Exercise 5 4 Recall: Amdahl's vs Gustafson's Law The key goal is to: ➔ Understand the main difference and implications (i.e., when to use which formula) ➔ Know how to derive formula based on the understanding, Not because you memorized them for the exam Recall: Amdahl's vs Gustafson's Law The key goal is to: ➔ Understand the main difference and implications (i.e., when to use which formula) ➔ Know how to derive formula based on the understanding, Not because you memorized them for the exam Recall: Amdahl's vs Gustafson's Law p=1 p=4 Amdahl's Law Gustafson's Law Less Time for the parallel part More work in the same Time Time p=1 p1 p2 p3 p4p1 p2 p3 p4 p=4 p1p1 essentials Recall: Amdahl's vs Gustafson's Law The key is goal to: ➔ Understand the main difference and implications (i.e., when to use which formula) ➔ Know how to derive formula based on the understanding, Not because you memorized them for the exam Amdahl's Law Derivation T1 - sequential time f - sequential fraction Tp - parallel time on p processors Tp = T1f + T1(1-f)/p Sp - speedup Sp = T1/Tp Sp = 1/(f + (1-f)/p) p=1 Amdahl's Law p=4 Less Time for the parallel part T1 T1f T1(1-f)/p T1f essentials Gustafson's Law Derivation Gustafson's Law T - sequential time of original work T1 - sequential time with work*p f - sequential fraction T1 = ? Tp - parallel time on p processors Tp = ? Sp - speedup Sp = T1/Tp Sp = ? More work in the same Time p=4 essentials Gustafson's Law Derivation Gustafson's Law T - sequential time of original work T1 - sequential time with work*p f - sequential fraction T1 = Tf + T(1-f)p Tp - parallel time on p processors Tp = ? Sp - speedup Sp = T1/Tp Sp = ? More work in the same Time T p=4 essentials Gustafson's Law Derivation Gustafson's Law T - sequential time of original work T1 - sequential time with work*p f - sequential fraction T1 = Tf + T(1-f)p Tp - parallel time on p processors Tp = Tf + T(1-f)p/p = T Sp - speedup Sp = T1/Tp Sp = ? More work in the same Time p=4 essentials Gustafson's Law Derivation Gustafson's Law T - sequential time of original work T1 - sequential time with work*p f - sequential fraction T1 = Tf + T(1-f)p Tp - parallel time on p processors Tp = Tf + T(1-f)p/p = T Sp - speedup Sp = T1/Tp Sp = f + (1-f)p More work in the same Time p=4 essentials fib(4) task graph public class Fibonacci { public static long fib(int n) { if (n < 2) { return n; } spawn task for fib(n-1); spawn task for fib(n-2); wait for tasks to complete return addition of task results } } fib(4) task graph public class Fibonacci { public static long fib(int n) { if (n < 2) { return n; } spawn task for fib(n-1); spawn task for fib(n-2); wait for tasks to complete return addition of task results } } fib(4) fib(3) fib(2) fib(1) fib(0) fib(2) What is a task? spawn base case wait What is an edge? spawn same procedure wait fib(0) fib(1) fib(1) essentials fib(4) task graph public class Fibonacci { public static long fib(int n) { if (n < 2) { return n; } spawn task for fib(n-1); spawn task for fib(n-2); wait for tasks to complete return addition of task results } } What is a task? spawn base case wait fib(4) fib(3) fib(2) fib(1) fib(0)fib(1) fib(1) fib(0) fib(2) What is an edge? spawn same procedure waitcritical path length is 8 tasks essentials fib(4) simplified task graph public class Fibonacci { public static long fib(int n) { if (n < 2) { return n; } spawn task for fib(n-1); spawn task for fib(n-2); wait for tasks to complete return addition of task results } } What is a task? Call to Fibonacci What is an edge? spawn (no dependency within same procedure) 4 2 1 1 0 3 2 1 0 Simpler at the expense of not modelling joins and inter-process dependencies essentials fib(4) simplified task graph public class Fibonacci { public static long fib(int n) { if (n < 2) { return n; } spawn task for fib(n-1); spawn task for fib(n-2); wait for tasks to complete return addition of task results } } What is a task? Call to Fibonacci What is an edge? spawn (no dependency within same procedure) 4 2 1 1 0 3 2 1 0 Simpler at the expense of not modelling joins and inter-process dependencies Caching results can speed-up computation essentials Task Graphs Critical path: path from start to end that takes the longest (for some metric) Example: #nodes essentials Critical path: path from start to end that takes the longest (for some metric) Example: #nodes Task Graphs essentials Task Graphs Adding eight numbers: Task Graphs Adding eight numbers: What is the corresponding task graph? Task Graphs Adding eight numbers: What is the corresponding task graph? +1 +3 +4 +5 +6 +7 +8 +2 Task Graphs Adding eight numbers: What is the corresponding task graph? +1 +3 +4 +5 +6 +7 +8 +2 Critical path n essentials Task Graphs Adding eight numbers: Task Graphs Adding eight numbers: What is the corresponding task graph? Task Graphs Adding eight numbers: What is the corresponding task graph? Task Graphs Adding eight numbers: What is the corresponding task graph? Critical path log(n) essentials Search And Count Search an array of integers for a certain feature and count integers that have this feature: ●Light workload: count number of non-zero values. ●Heavy workload: count how many integers are prime numbers. We will study single threaded and multi-threaded implementation of the problem. Search And Count - Sequential public class SearchAndCountSingle { private int[] input; private Workload.Type type; private SearchAndCountSingle(int[] input, Workload.Type wt) { this.input = input; this.type = wt; } private int count() { int count = 0; for (int i = 0; i < input.length; i++) { if (Workload.doWork(input[i], type)) count++; } return count; } } Straightforward implementation. Simply iterate through the input array and count how many times given event occurs. Divide and Conquer Basic structure of a divide-and-conquer algorithm: 1. If problem is small enough, solve it directly 2. Otherwise a. Break problem into subproblems b. Solve subproblems recursively c. Assemble solutions of subproblems into overall solution essentials ++++++++ ++++ ++ + Divide and Conquer ++++++++ ++++ ++ + base case no further split Divide and Conquer essentials ++++++++ ++++ ++ + Tasks at different levels of granularity What determines a task? i) input array ii) start index iii) length/end index These are fields we want to store in the task Divide and Conquer essentials Feedback: Tasks B-D 35 ExecutorServiceDivide and Conquer Parallelization ++++++++ ++++ ++ + thread 1 thread 2 thread 3 thread 4 thread 5 thread 6 thread 7 thread 8 ... essentials Divide and Conquer Parallelization Performance optimization Same thread is reused instead of creating a new one ++++++++ ++++ ++ + thread 1 thread 2 thread 3 thread 4 thread 5 thread 6 thread 7 thread 8 ... essentials Divide and Conquer Parallelization Performance optimization Same thread is reused instead of creating a new one ++++++++ ++++ ++ + thread 1 thread 2 thread 3 thread 4 thread 5 thread 6 thread 7 thread 8 ... Task B: Extend your implementation such that it creates only a fixed number of threads. Make sure that your solution is properly synchronized when checking whether to create a new thread How to achieve this? essentials Divide and Conquer Parallelization ++++++++ ++++ ++ + Option 1: Shared counter with synchronized/atomic access essentials Divide and Conquer Parallelization ++++++++ ++++ ++ + Option 1: Shared counter with synchronized/atomic access Option 2: Assign unique sequential id to each task. Spawn threads for first N tasks. 0 1 2 3 4 5 6 essentials Divide and Conquer Parallelization ++++++++ ++++ ++ + Option 1: Shared counter with synchronized/atomic access Option 2: Assign unique sequential id to each task. Spawn threads for first N tasks. 0 1 2 3 4 5 6 n 2n + 1 2n + 2 essentials Divide and Conquer Parallelization ++++++++ ++++ ++ + Option 1: Shared counter with synchronized/atomic access Option 2: Assign unique sequential id to each task. Spawn threads for first N tasks. 0 1 2 3 4 5 6 n 2n + 1 2n + 2 + no synchronization required - imbalanced amount of work essentials Divide and Conquer vs Fork/Join Divide And Conquer Fundamental design pattern based on recursively breaking down a problem into smaller problems that can be combined to give a solution to the original problem Fork/Join A framework that supports Divide and Conquer style parallelism essentials Divide and Conquer vs Fork/Join Divide And Conquer ++++++++ ++++ ++ + recursively breaking down a problem into smaller problems problems are solved sequentially + thread 1 essentials Divide and Conquer vs Fork/Join Fork/Join ++++++++ ++++ ++ + a framework that supports Divide and Conquer style parallelism problems are solved in parallel thread 1 thread 2 thread 3 thread 4 thread 5 thread 6 thread 7 ... essentials Divide and Conquer vs Fork/Join Fork/Join ++++++++ ++++ ++ + a framework that supports Divide and Conquer style parallelism problems are solved in parallel thread 1 thread 2 thread 3 thread 4 thread 5 thread 6 thread 7 ... Performance optimization Same thread is reused instead of creating a new one essentials Search And Count - Task Parallel public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type workloadType; } Define the task structure: essentials Search And Count protected Integer compute() { } Recall the template for divide and conquer task parallelism essentials Search And Count protected Integer compute() { if (// work is small) { // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } Recall the template for divide and conquer task parallelism essentials Search And Count protected Integer compute() { if (// work is small) { // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } Recall the template for divide and conquer task parallelism Let’s fill in the template for the search and count task essentials Search And Count protected Integer compute() { if (// work is small) { // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (// work is small) { // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } essentials Search And Count protected Integer compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (length <= cutOff) { // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } essentials Search And Count protected Integer compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (length <= cutOff) { // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } essentials Search And Count protected Integer compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (length <= cutOff) { int count = 0; for (int i = start; i < start + length; i++) { if (Workload.doWork(input[i], type)) count++; } return count; else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } Same as sequential implementation public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } essentials Search And Count protected Integer compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (length <= cutOff) { int count = 0; for (int i = start; i < start + length; i++) { if (Workload.doWork(input[i], type)) count++; } return count; else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } essentials Search And Count protected Integer compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (length <= cutOff) { int count = 0; for (int i = start; i < start + length; i++) { if (Workload.doWork(input[i], type)) count++; } return count; else { int half = (length) / 2; SearchAndCountMultiple sc1 = new SearchAndCountMultiple(input, start, half, cutOff, type); SearchAndCountMultiple sc2 = new SearchAndCountMultiple(input, start + half, length - half, cutOff, type); // invoke the pieces and wait for the results // combine the results } } public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } essentials Search And Count protected Integer compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (length <= cutOff) { int count = 0; for (int i = start; i < start + length; i++) { if (Workload.doWork(input[i], type)) count++; } return count; else { int half = (length) / 2; SearchAndCountMultiple sc1 = new SearchAndCountMultiple(input, start, half, cutOff, type); SearchAndCountMultiple sc2 = new SearchAndCountMultiple(input, start + half, length - half, cutOff, type); // invoke the pieces and wait for the results // combine the results } } public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } essentials Search And Count protected Integer compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (length <= cutOff) { int count = 0; for (int i = start; i < start + length; i++) { if (Workload.doWork(input[i], type)) count++; } return count; else { int half = (length) / 2; SearchAndCountMultiple sc1 = new SearchAndCountMultiple(input, start, half, cutOff, type); SearchAndCountMultiple sc2 = new SearchAndCountMultiple(input, start + half, length - half, cutOff, type); sc1.fork(); sc2.fork(); int count1 = sc1.join(); int count2 = sc2.join(); // combine the results } } public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } essentials Search And Count protected Integer compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (length <= cutOff) { int count = 0; for (int i = start; i < start + length; i++) { if (Workload.doWork(input[i], type)) count++; } return count; else { int half = (length) / 2; SearchAndCountMultiple sc1 = new SearchAndCountMultiple(input, start, half, cutOff, type); SearchAndCountMultiple sc2 = new SearchAndCountMultiple(input, start + half, length - half, cutOff, type); sc1.fork(); sc2.fork(); int count1 = sc1.join(); int count2 = sc2.join(); // combine the results } } public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } essentials Search And Count protected Integer compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (length <= cutOff) { int count = 0; for (int i = start; i < start + length; i++) { if (Workload.doWork(input[i], type)) count++; } return count; else { int half = (length) / 2; SearchAndCountMultiple sc1 = new SearchAndCountMultiple(input, start, half, cutOff, type); SearchAndCountMultiple sc2 = new SearchAndCountMultiple(input, start + half, length - half, cutOff, type); sc1.fork(); sc2.fork(); int count1 = sc1.join(); int count2 = sc2.join(); return count1 + count2; } } public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } essentials Search And Count public class SearchAndCountMultiple extends RecursiveTask<Integer> { private int[] input; private int start; private int length; private int cutOff; private Workload.Type type; } protected Integer compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // combine the results } } protected Integer compute() { if (length <= cutOff) { int count = 0; for (int i = start; i < start + length; i++) { if (Workload.doWork(input[i], type)) count++; } return count; else { int half = (length) / 2; SearchAndCountMultiple sc1 = new SearchAndCountMultiple(input, start, half, cutOff, type); SearchAndCountMultiple sc2 = new SearchAndCountMultiple(input, start + half, length - half, cutOff, type); sc1.fork(); sc2.fork(); int count1 = sc1.join(); int count2 = sc2.join(); return count1 + count2; } } essentials Pre-Discussion Exercise 6 Assignment 6 Task Parallelism: ●Merge Sort ●Longest Sequence Merge sort algorithm In this exercise you will implement the merge sort algorithm using task parallelism. The merge sort algorithm partitions the array into smaller arrays, sorts each one separately and then merges the sorted arrays. • By default, the partitioning of the array continues recursively until the array size is 1 or 2, which then is sorted trivially. • Try larger cutoff values (e.g partition arrays down to minimum size 4 instead of 2) and see how this affects the algorithm performance. • Discuss the asymptotic running time of the algorithm and the obtained speedup. essentials Longest Sequence Given a sequence of numbers: [1, 9, 4, 3, 3, 8, 7, 7, 7, 0] find the longest sequence of the same consecutive number Longest Sequence Given a sequence of numbers: [1, 9, 4, 3, 3, 8, 7, 7, 7, 0] find the longest sequence of the same consecutive number Longest Sequence Given a sequence of numbers: [1, 9, 4, 3, 3, 8, 7, 7, 7, 0] find the longest sequence of the same consecutive number. If multiple sequences have the same length, return the first one (the one with lowest starting index) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [1, 1, 0, 0] Longest Sequence Task: Implement task parallel version that finds the longest sequence of the same consecutive number. Challenge: The input array cannot be divided arbitrarily. For example: [1, 2, 3, 3, 4, 1] [1, 2, 3] [3, 4, 1] essentials Longest Sequence Task: Implement task parallel version that finds the longest sequence of the same consecutive number. Challenge: The input array cannot be divided arbitrarily. For example: [1, 2, 3, 3, 4, 1] [1, 2, 3] [3, 4, 1] Combining results of subtasks does not give the correct answer! essentials Old Exam Task (FS23)Old Exam Task (FS23) https://quizizz.com/admin/quiz/622660d2679f87001de7eb18","libVersion":"0.3.1","langs":""}