{"path":"sem2/PProg/VRL/slides/PProg-L08-L09-div&conq-cilk.pdf","text":"Pa r a l l e l P r o g r a m m i n g D i v i d e a n d C o n q u e r , Ci l k - st y l e b o u n d s Bi g P i c t u r e (P a rt I ) 2 CPU OS JV M (P r o c e s s A ) Co r e Co r e Co r e Co r e OS t h r ea d OS t h r ea d OS t h r ea d OS t h r ea d OS s c h ed u l er JV M s c h e d u l e r JV M th r e a d Pr o ce s s B Me m o r y S pa c e A Me m o r y S pa c e B Ph y s i c a l M em o r y JV M th r e a d JV M th r e a d JV M th r e a d L0 3 - 05 L0 6 L0 7 L0 8 - 09 L1 0 - L1 1 L1 3 ‚Ä¶ ‚Ä¶ St a c k Re g i s t e r s PC St a c k Re g i s t e r s PC St a c k Re g i s t e r s PC St a c k Re g i s t e r s PC Pa r a l l e l per f o r m a nc e & alg o r it h m s L1 2 Vi r tu a l th r e a d s Le t s l o o k a t a c o d e e x a mp l e: s u m t h e el emen t s o f a l i s t 3 Se q u e n t i a l V e r s i o n Th e f ir s t s t e p o f w r itin g a pa r a l l e l pr o g r a m i s w r i t i ng a se q u e n t i a l ve r s i o n : ‚Ä¢ He l p s v a l i da t e o ur e v e n t ua l pa r a l l e l pr o gr a m i s c o r r e c t ‚Ä¢ b y c o m p a r i n g r e s u l t s w i t h t h e s i m p l e r , s e q u e n t i a l v e r s i o n ‚Ä¢ Ev a l u a t e t h e p e r f o r m a n c e o f o u r p a r a l l e l p r o g r a m ‚Ä¢ we w r i t e p a r a l l e l p r o g r a m s t o i m p r o v e p e r f o r m a n c e ! 4 Addi ng N um be r s - Se q u e n t i a l l y public static int sum( int [] input ){ int sum = 0; for ( int i =0; i < input . length ; i ++){ sum += input [ i ]; } return sum ; } 5 Pa r a l l e l i s m i d e a Ide a: H a v e 4 t hr e ads s im ult ane o us ly s um 1 / 4 o f t he arr a y ‚Ä¢ W a r ni ng : T hi s i s a n i n f e r i o r f i r s t a ppr o a c h ‚Ä¢ Cr e a t e 4 th r e a d o b j e cts , e a c h g i v e n a po r t i o n o f t he w o r k ‚Ä¢ Ca l l start() o n e a c h t hr e a d o bj e c t t o a c t ua l l y ru n i t i n pa r a l l e l ‚Ä¢ Wa i t f o r t hr e a ds t o f i ni s h us i ng join() ‚Ä¢ A dd t o g e t he r t he i r 4 a ns w e r s f o r t he fi n a l r e s u l t + ans ans0 ans1 ans2 ans3 67 Co d e e x a m p l e: P P - L0 9 - 01A r r a y S u m Fir s t a t t em p t, par t 1 8 class SumThread extends java.lang.Thread { int lo ; // arguments int hi ; int [] arr ; int ans = 0; // result SumThread ( int [] a , int l , int h ) { lo=l; hi=h; arr =a; } public void run () { //override must have this type for ( int i =lo; i < hi; i ++) ans += arr [ i ]; } } B e c a us e w e m us t o v e r r i de a no - a r g um e n t s / no - r e s ul t run , w e us e f i e l ds t o c o m m uni c a t e a c r o s s t hr e a ds Fir s t a t t em p t, c o n tinued (w r o n g) 9 class SumThread extends java.lang.Thread { int lo , int hi , int [] arr ; // arguments int ans = 0; // result SumThread ( int [] a , int l , int h ) { ‚Ä¶ } public void run (){ ‚Ä¶ } // override } int sum ( int [] arr ) { // can be a static method int len = arr.length ; int ans = 0; SumThread [] ts = new SumThread [4]; for ( int i =0; i < 4; i ++) // do parallel computations ts [ i ] = new SumThread ( arr,i * len /4,(i+1)* len /4); for ( int i =0; i < 4; i ++) // combine results ans += ts [ i ]. ans ; return ans ; } Se c o n d a t t e mp t (s t i l l w r o n g) 10 int sum ( int [] arr ) { // can be a static method int len = arr.length ; int ans = 0; SumThread [] ts = new SumThread [4]; for ( int i =0; i < 4; i ++){ // do parallel computations ts [ i ] = new SumThread ( arr,i * len /4,(i+1)* len /4); ts [ i ].start(); // start actually runs the thread in parallel } for ( int i =0; i < 4; i ++) // combine results ans += ts [ i ]. ans ; return ans ; } class SumThread extends java.lang.Thread { int lo , int hi , int [] arr ; // arguments int ans = 0; // result SumThread ( int [] a , int l , int h ) { ‚Ä¶ } public void run (){ ‚Ä¶ } // override } Th i r d a t t e m p t ( c o r r e c t i n s p i r i t ) 11 int sum ( int [] arr ) { // can be a static method int len = arr.length ; int ans = 0; SumThread [] ts = new SumThread [4]; for ( int i =0; i < 4; i ++){ // do parallel computations ts [ i ] = new SumThread ( arr,i * len /4,(i+1)* len /4); ts [ i ].start(); } for ( int i =0; i < 4; i ++) { // combine results ts [ i ].join(); // wait for helper to finish! ans += ts [ i ]. ans ; } return ans ; } class SumThread extends java.lang.Thread { int lo , int hi , int [] arr ; // arguments int ans = 0; // result SumThread ( int [] a , int l , int h ) { ‚Ä¶ } public void run (){ ‚Ä¶ } // override } Dis cu s s io n T he Thread c l a s s de f i ne s v a r i o us m e t ho ds y o u c o ul d no t i m pl e m e n t o n y o ur o w n ‚Ä¢ F o r e x a m p l e : start , w h i c h c a l l s run i n a n e w t h r e a d T he join m e t ho d i s v a l ua bl e f o r c o o r di na t i ng t hi s k i nd o f c o m put a t i o n ‚Ä¢ C a l l e r b l o c k s u n t i l / u n l e s s t h e r e c e i v e r i s d o n e e x e c u t i n g ( m e a n i n g t h e c a l l t o run fi n i s h e s ) ‚Ä¢ E l s e w e w o u l d h a v e a r a c e c o n d i t i o n on ts [ i ]. ans Th i s s tyl e o f p a r a l l e l p r o g r a mmi n g i s c a l l e d fo r k / j o i n Ja v a d e t ail: c od e h as 1 c om p ile e r r or b e c au s e join ma y thr o w java.lang.InterruptedException ‚Ä¢ I n b a s i c p a r a l l e l c o d e , s h o u l d b e f i n e t o c a t c h - an d - ex i t 1214 Sh a r e d me mo r y ? Fo r k - jo i n p r o g r a m s ( t h a n k fu l l y ) d o n o t r e q u i r e m u ch f o cu s o n sh a r i n g m e m o r y a m o n g t h r e a d s B u t i n l a n g u a g e s l i k e J a v a , t h e r e i s m e m o r y b e i n g s h a r e d . In o ur e x ample : ‚Ä¢ lo , hi , arr f i e l d s w r i t t e n b y ‚Äú m a i n ‚Äù t h r e a d , r e a d b y h e l p e r t h r e a d ‚Ä¢ ans f i e l d w r i t t e n b y h e l p e r t h r e a d , r e a d b y ‚Äú m a i n ‚Äù t h r e a d W h e n u s i n g s h a r e d m e m o r y , y o u m u s t a v o i d r a c e c o n d i t i o n s ( w e w i l l s e e a m o r e f o r m a l d e f i n i t i o n o f d a t a r a c e s , l a t e r ) 15 I s s u e s w i t h t h i s a p p r o a ch ( a n d s o m e w o r k a r o u n d s ) S e v e r a l r e a s o n s w h y t h i s i s a p o o r p a r a l l e l a l g o ri t h m R e a s o n 1 : w a n t c o d e t o b e r e u s a b l e a n d e f f i c i e n t a c r o s s p l a t f o r m s 16 int sum ( int [] arr ) { // can be a static method int len = arr.length ; int ans = 0; SumThread [] ts = new SumThread [4]; for ( int i =0; i < 4; i ++){ // do parallel computations ts [ i ] = new SumThread ( arr,i * len /4,(i+1)* len /4); ts [ i ].start(); } for ( int i =0; i < 4; i ++) { // combine results ts [ i ].join(); // wait for helper to finish ans += ts [ i ]. ans ; } return ans ; } 17 Co d e e x a m p l e: P P - L0 9 - 02P ar ame t e r iz e d T h r e ad s I s s u e s w i t h t h i s a p p r o a ch ( a n d s o m e w o r k a r o u n d s ) S e v e r a l r e a s o n s w h y t h i s i s a p o o r p a r a l l e l a l g o ri t h m R e a s o n 1 : w a n t c o d e t o b e r e u s a b l e a n d e f f i c i e n t a c r o s s p l a t f o r m s ‚Ä¢ ‚ÄúF o r w a r d - po r t a bl e ‚Äù a s c o r e c o un t g r o w s ‚Ä¢ S o a t t he ve r y l e a s t , pa r a m e t e r i z e b y t he num be r o f t hr e a ds 18 int sum ( int [] arr , int numTs ) { int ans = 0; SumThread [] ts = new SumThread [ numTs ]; for ( int i =0; i < numTs ; i ++){ ts [ i ] = new SumThread ( arr , ( i * arr.length )/ numTs , ((i+1)* arr.length )/ numTs ); ts [ i ].start(); } for ( int i =0; i < numTs ; i ++) { ts [ i ].join(); ans += ts [ i ]. ans ; } return ans ; } I s s u e s w i t h t h i s a p p r o a ch ( a n d s o m e w o r k a r o u n d s ) Re a s o n 2 : wa n t t o u s e ( o n l y ) p r o c e s s o r s ‚Äú a v a i l a b l e t o y o u no w ‚Äù ‚Ä¢ N o t u s e d b y o t h e r p r o g r a m s o r t h r e a d s i n y o u r p r o g r a m ‚Ä¢ M a y be c a l l e r i s a l s o us i ng pa r a l l e l i s m ‚Ä¢ A v a i l a bl e c o r e s c a n c ha ng e e v e n w hi l e y o ur t hr e a ds r un 19 // numThreads == numProcessors is bad // if some are needed for other things int sum ( int [] arr , int numTs ) { ‚Ä¶ } I s s u e s w i t h t h i s a p p r o a ch ( a n d s o m e w o r k a r o u n d s ) Re a s o n 3 : Th o u gh u n lik e ly f o r sum , i n g e n e r a l su b p r o b l e m s ma y ta k e s i g n i f i c a n t l y d i f f e r e n t a m o u n t s o f t i m e Ex am p le : A p p ly m e t h o d f t o e v e r y a r r a y e l e m e n t , b u t m a y b e f is m u c h s l o w e r f o r s o m e d a t a i t e m s , e . g . : i s a l a r g e i n t e g e r p r i m e ? I f w e c r e a t e 4 t h r e a d s a n d a l l s l o w d a t a i s p r o c e s s e d b y 1 o f t h e m , w e w o n ‚Äôt g e t n e a r l y a 4 x s p e e d u p ‚Ä¢ Ex a mpl e o f a lo ad im b alan c e 2021 A Be t t e r Appr o a c h T h e c o u n t e r i n t u i t i v e ( ? ) s o l u t i o n t o a l l t h e s e p r o b l e m s i s t o u s e l o t s o f t h r e a d s , fa r m o r e t h a n t h e n u m b e r o f p r o c e s s o r s ‚Ä¢ B u t t h i s w i l l r e q u i r e c h a n g i n g o u r a l g o ri t h m ‚Ä¢ A n d f o r c o n s t a n t - f a c t o r r e a s o n s , a b a n d o n i n g J a v a ‚Äô s t h r e a d s 1. Fo r w a r d - po r t a bl e : L o t s o f he l pe r s e a c h do i ng a s m a l l pi e c e 2. P r o c e s s o r s a v a i l a bl e : H a nd o ut ‚Äú w o r k c hunk s ‚Äù a s y o u g o 3. L o a d i m ba l a nc e : N o pr o bl e m i f s l o w t hr e a d s c he dul e d e a r l y e no ug h ‚Ä¢ V a r i a t i o n pr o ba bl y s m a l l a ny w a y i f pi e c e s o f w o r k a r e s m a l l ans0 ans1 ansN ans ‚Ä¶ 22 Div id e an d C o n q u e r t o t h e R e s cu e ! Th is is s tr aigh tf o r w ar d t o im p le m e n t u s in g d ivid e - an d - co n q u e r ‚Ä¢ Pa r a l l e l i s m f o r t h e r e c u r s i v e c a l l s 23 + + + + + + + + + + + + + + + Div id e an d C o n q u e r F u n d a m e n t a l p a t t e r n i n p a r a l l e l p r o g r a m m i n g , a l s o c a l l e d r e cu r s i v e s p l i t t i n g Divide and Conquer: if cannot divide: return unitary solution (stop recursion) divide problem in two solve first (recursively) solve second (recursively) combine solutions return result 24 Se q u e n t i a l V e r s i o n : R e c u r s i v e Su m public static int do_sum_rec ( int [] xs , int l, int h) { int size = h - l; if (size == 1) /*check for termination criteria*/ return xs [l]; /* split array in half and call self recursively*/ int mid = size / 2; int sum1 = do_sum_rec(xs, l , l + mid); int sum2 = do_sum_rec(xs, l + mid, h ); return sum1 + sum2; } 252627 Co d e e x a m p l e: P P - L0 9 - 03P ar alle lR e c u r s iv e S u m 2829 P a r a l l e l R e c u r s i v e S u m ( w i t h Th r e a d s ) public class SumThread extends Thread { int [] xs ; int h , l ; int result ; public SumThread ( int [] xs , int l, int h){ super (); this . xs = xs ; this . h = h; this . l =l; } public void run(){ /*Do computation and write to result*/ return ; } 30 P a r a l l e l R e c u r s i v e S u m ( w i t h Th r e a d s ) public void run(){ int size = h - l ; if (size == 1) { result = xs [l]; return ; } int mid = size / 2; SumThread t1 = new SumThread ( xs , l , l + mid); SumThread t2 = new SumThread ( xs , l + mid, h ); t1.start(); t1.join(); t2.start(); t2.join(); result = t1. result + t2. result ; return ; } 31 Is th i s OK ? P a r a l l e l R e c u r s i v e S u m ( w i t h Th r e a d s ) public void run(){ int size = h - l ; if (size == 1) { result = xs [l]; return ; } int mid = size / 2; SumThread t1 = new SumThread ( xs , l , l + mid); SumThread t2 = new SumThread ( xs , l + mid, h ); t1.start(); t2.start(); t1.join(); t2.join(); result = t1. result + t2. result ; return ; } 32 R e m a r k : T h i s d o e s n ‚Äôt c o m p i l e b e c a u s e jo i n ( ) c a n t h r ow e x c e p t i o n s . I n r e a l i t y we n e e d a t r y - ca t c h b l o c k h e r e . Re s u l t 33 Ja v a. l an g . O u t O f M e m o r y E r r o r : u n a b l e t o cr e a t e n e w n a ti v e th r e a d On e t h r e a d p e r p a r a l l e l t a sk m o d e l Ja v a th r e ad s ar e ac tu ally q u it e h e a v y w e igh t Ja v a th r e ad s ar e m ap p e d t o O S th r e ad s (in th e O r ac le an d m o s t r e al - wo r l d i m p l e m e n t a t i o n s ) In g e ne r al: us i ng o ne t hr e a d pe r ( s ma l l t a s k s ) i s hi g hl y i ne f f i c i e n t 34 Di v i d e - an d - Co n q u er w o r k s ‚Äì (r e ally , w e ‚Äô ll g e t t h e r e ) I n t h e o r y , y o u c a n d i v i d e d o w n t o s i n g l e e l e m e n t s , d o a l l y o u r r e s u l t - co m b i n i n g i n p a r a l l e l a n d g e t o p t i m a l s p e e d u p I n p r a c t i c e , c r e a t i n g a l l t h o s e t h r e a d s a n d c o m m u n i c a t i n g s w a m p s t h e s a v i n g s , s o : ‚Ä¢ Us e a se que n t ial cut o f f , t y p i c a l l y a r o u n d 5 0 0 - 1000 ‚Ä¢ El i m i n a t es al m o s t al l th e r e c u r s i v e th r e a d c r e a ti o n ( b o t t o m l e v e l s o f tr e e ) ‚Ä¢ Do no t c r e a t e t w o r e c ur s i v e t hr e a ds ; c r e a t e o ne a nd do t he o t he r ‚Äúy o u r s e l f ‚Äù ‚Ä¢ C u t s t h e n u m b e r o f t h r e a d s c r e a t e d b y a n o t h e r 2 x 35 Div id e - an d - co n q u e r ‚Äì wi t h m a nua l f i x es ( P t . I) public void run(){ int size = h - l ; if (size < SEQ_CUTOFF ) for ( int i= l ; i< h ; i++) result += xs [ i ]; else { int mid = size / 2; SumThread t1 = new SumThread ( xs , l , l + mid); SumThread t2 = new SumThread ( xs , l + mid, h ); t1.start(); t2.start(); t1.join(); t2.join(); result = t1. result + t2. result ; } } 36 Half the thr eads If a la n g u a g e had bui l t - in s u p p o r t f o r f o r k - j o i n p a r a l l e l i s m , w e w o u l d e x p e c t t h i s hand - op t i m i z a t i on t o b e u n n e c e s s a r y But t he lib r a r y we a r e u s i n g e x p e c t s yo u t o d o i t yo u r s e l f ( a n d t h e d i f f e r e n c e i s surpri si ng l y sub s t an ti al ) A g a i n , n o d i f f e r e n c e i n t h e o r y 37 // wasteful: don‚Äôt SumThread t1 = ‚Ä¶ SumThread t2 = ‚Ä¶ t1.start(); t2.start(); t1.join(); t2.join(); result=t1.result+t2.result; // better: do // order of next 4 lines // essential ‚Äì why? t1.start(); t2.run(); t1.join(); result=t1.result+t2.result; 3839 Co d e e x a m p l e: P P - L0 9 - 04R e c u r s iv e S u mO p t Di v i d e - an d - co n q u e r r e a l l y w o r ks ‚Äì (b u t it ‚Äô s h ar d w or k ) Th e k e y i s d i v i d e - an d - c o n q u e r p a r a l l e l i z e s t h e r e s u l t - co m b i n i n g ‚Ä¢ If y o u ha v e e no ug h pr o c e s s o r s , t o t a l t i m e i s he i g h t o f t he t r e e : O ( log n ) ( o p t i m a l , e x po ne n t i a l l y f a s t e r t ha n s e que n t i a l O ( n )) ‚Ä¢ O f t e n r e l i e s o n o pe r a t i o ns be i ng a s s o c i a t i v e ( l i k e + ) W i l l w ri t e a l l o u r p a r a l l e l a l g o ri t h m s i n t h i s s t y l e ‚Ä¢ B ut us i ng s pe c i a l l i br a r i e s e ng i ne e r e d f o r t hi s s t y l e ‚Ä¢ Ta k e s c a r e o f s c h e d u l i n g t h e c o m p u t a t i o n w e l l 41 + + + + + + + + + + + + + + + Re c a p : O n e t h r e a d p e r t a s k m o d e l Ja v a th r e ad s ar e ac tu ally q u it e h e a v y w e igh t Ja v a th r e ad s ar e m ap p e d t o O S th r e ad s In g e ne r al: us i ng o ne t hr e a d pe r ( s ma l l t a s k s ) i s hi g hl y i ne f f i c i e n t 4243 Al t e r na t i v e a ppr o a c h: sc h e d u l e t a sk s o n t h r e a d s Thr e ads H o w m a n y t h r e a d s w o u ld y o u u s e ? Ta s k s (T h r e a d p o o l ) 44 J a v a ' s e x e cu t o r s e r v i ce : m a n a g i n g a s y n ch r o n o u s t a s k s Ta s k s Ex e c ut or Se r v ic e In t e r f a c e Im p l e m e n t a t i o n e. g. : Thr eadP ool Ex ecut or (T h r e a d p o o l ) J a v a ' s e x e c ut o r s e r v i c e : m a na g i ng a s y nc hr o no us t a s k s 46 Ex ecu t or Ser vi ce Us e r s u b m i t s t a s k s ge t s b a c k a Futur e .s u b m i t ( C a l l a b l e < T > t a s k ) ‚Üí F u t u r e < T > .s u b m i t ( R u n n a b l e t a s k ) ‚Üí F u t u r e < ? > 47 No t e: C a l l a b l e v s R u n n a b l e In t e r f a c e R u n n a b l e : ‚Üí v o i d r u n ( ) In t e r f a c e C a l l a b l e < T > : ‚Üí T ca l l ( ) Do e s no t r e t ur n r e s ul t Re t u r n s r e s u l t E x e c ut o r S e r v i c e c a n ha ndl e ‚Äú R unna bl e ‚Äù o r ‚Äú C a l l a bl e ‚Äù t a s k s : 48 Co d e e x a m p l e: P P - L1 0 - 01E x e c u t o r H e llo T as k U s i ng e x e c ut o r s e r v i c e : H e l l o W o r l d ( c r e a t i ng e x e c ut o r , s ubm i t t i ng ) int ntasks = 1000 ; ExecutorService exs = Executors. newFixedThreadPool ( 4 ); for ( int i = 0 ; i < ntasks ; i ++) { HelloTask t = new HelloTask ( \"Hello from task \" + i ); exs. submit (t); } exs. shutdown (); // initiate shutdown, does not wait, but can‚Äôt submit more tasks 49 Us i n g e x e c u t o r s e r v i c e : H e l l o W o r l d ( t a s k ) static class HelloTask implements Runnable { String msg ; public HelloTask (String msg ) { this .msg = msg ; } public void run () { long id = Thread. currentThread (). getId (); System.out. println ( msg + \" from thread:\" + id); } } 50 Us i n g e x e c u t o r s e r v i c e : H e l l o W o r l d ( o u t p u t ) ‚Ä¶ Hello from task 803 from thread:8 Hello from task 802 from thread:10 Hello from task 807 from thread:8 Hello from task 806 from thread:9 Hello from task 805 from thread:11 Hello from task 810 from thread:9 Hello from task 809 from thread:8 Hello from task 808 from thread:10 Hello from task 813 from thread:8 Hello from task 812 from thread:9 Hello from task 811 from thread:11 ... 5152 Co d e e x a m p l e: P P - L1 0 - 02R e c u r s iv e S u mE x e c u t o r Re c u r s i v e S u m w i t h Ex e c ut o r S e r v i c e public Integer call () throws Exception { int size = h ‚Äì l; if (size == 1 ) return xs [l]; int mid = size / 2 ; sumRecCall c1 = new sumRecCall (ex, xs , l, l + mid); sumRecCall c2 = new sumRecCall (ex, xs , l + mid, h ); Future<Integer> f1 = ex. submit (c1); Future<Integer> f2 = ex. submit (c2); return f1. get () + f2. get (); } 53 Si mp l e ! ‚Äì Bu t d o e s t h i s w o rk? If y o u e x e c u t e t h e c o d e , y o u w i l l o b s e r v e t h a t i t n e v e r r e t u r n s ( i . e . , t h e co m p u t a t i o n i s n o t co m p l e t e d ) 54 Wh y do e s t hi s ha ppe n? ta s ks w i l l e n d u p wa i t i n g ev e nt u a l l y w e w i l l ru n o u t o f t h r e a d s 55 sum(0,100): t1 = spawn sum(0,50) t2 = spawn sum(50,100) t1.wait(); t2.wait() sum(0,50): t1 = spawn sum(0,25) t2 = spawn sum(25,50) t1.wait(); t2.wait() sum(50,100): t1 = spawn sum(50,75) t2 = spawn sum(75,100) t1.wait(); t2.wait() sum(0,25): t1 = spawn sum(0,12) t2 = spawn sum(12,25) t1.wait(); t2.wait() Ad d i n g Nu mb er s E x e cu t o r S e r v i ce : a n o t h e r a p p r o a ch P r o bl e m wi th the di v i de a nd c o nque r a ppr o a c h i s tha t t a s k s c r e a t e o the r t a s k s a nd w o r k pa r ti ti o ni ng ( s pl i t ti ng up w o r k) i s pa r t o f the t a s k. A po s s i bl e a ppr o a c h i s t o de c o upl e w o r k pa r ti ti o ni ng fr o m s o l v i ng the pr o bl e m . T ha t i s w e s pl i t the a r r a y i n t o c hunk s ( ho w m a n y ? ) a nd c r e a t e a t a s k pe r c hunk. T he n, w e s ubm i t t a s k s i n t o E x e c ut o r S e r v i c e a nd c o m bi ne r e s ul ts ( e . g . , s um ) . I t c a n be tr i c ky t o do the i ni ti a l pa r ti ti o ni ng o f w o r k a nd fi na l s um m i ng i n pa r a l l e l . 57 ans0 ans1 ansN ans ‚Ä¶ Ta s k P a r a l l e l P r o g r a m m i n g [ Ci l k - st y l e ] Ta s k s : ‚Äì ex e c u t e c o d e ‚Äì spa w n o t he r t a sk s ‚Äì wa i t f o r r e s u l t s f r o m o t h e r ta s k s A g r a p h i s f o rm e d b a s e d o n s p a w n i n g t a s k s B A C 58 T h e e d g e s m e a n t h a t T a s k B w a s c r e a t e d b y T a s k A a n d t h a t T a s k C w a s c r e a t e d b y T a s k A fi b () F u n c t i o n public class Fibonacci { public static long fib( int n){ if (n < 2) return n; long x1 = fib(n - 1); long x2 = fib(n - 2); return x1 + x2; } } 59 public class Fibonacci { public static long fib( int n) { if (n < 2) return n; spawn task for fib(n - 1); spawn task for fib(n - 2); wait for tasks to complete return addition of task results }}} Seq u en t i a l V er s i on Pa ra l l e l V e r s i o n fib(4) ta s k g r a p h sp a w n jo i n 60 st e p i n s a m e p r o c e d u r e T he t a s k g r a ph i s a di r e c t e d a c y c l i c g r a ph ( D A G ) Ta s k p a r a l l e l i s m d i s c u s s i o n ‚óè Ta s k s c a n e x e c u t e i n p a r a l l e l ‚Äì but t he y do n' t ha v e t o ‚Äì as s ig n m e n t o f t as k s t o C P U s / c o r e s is u p t o t h e s c h e d u le r ‚óè Ta s k g r a p h i s dy nam i c ‚Äì un f o l ds a s e x e c ut i o n pr o c e e ds ‚óè In t uit io n: w ide t as k gr aph ‚Üí mo r e par alle lis m 62 Ta s k p a r a l l e l i s m : p e r f o r m a n c e m o d e l 64 ‚óè T a s k g r a ph: t a s k s be c o m e a v a i l a bl e a s c o m put a t i o n pr o g r e s s e s ‚óè W e c a n e x e c ut e t he g r a ph o n p pr o c e s s o r s S c he dul e r a s s i g n t a s k s t o pr o c e s s o r s ‚óè T p : e x e c ut i o n t i m e o n p pr o c e s s o r s T a s k p a r a l l e l i s m : p e r f o r m a n ce m o d e l [s o me r emi n d er s ] 65 ‚óè T p : e x e c ut i o n t i m e o n p pr o c e s s o r s ‚óè T 1 : w o rk ( t o t a l a m o un t o f w o r k ) ‚Äì t he s um o f t he t i m e c o s t o f a l l no de s i n g r a ph ‚Äì a s i f w e e x e c ut e d g r a ph s e que n t i a l l y ( p= 1 ) ‚óè T 1 / T p ‚Üí sp eed u p Ta s k p a r a l l e l i s m : p e r f o r m a n c e m o d e l ( B o u n d s ) ‚óè T ‚àû : s p a n , cr i ti c a l p a th ‚Äì T i m e i t t a k e s o n i n f i ni t e pr o c e s s o r s ‚Äì l o ng e s t pa t h f r o m r o o t t o s i nk ‚óè T 1 / T ‚àû √† pa r a l l e l i s m ‚Äì ‚Äú w i de r ‚Äù i s be t t e r ‚óè L o w e r B o unds : ‚Äì T p ‚â• T 1 / P ‚Äì T p ‚â• T ‚àû 66 O n t h i s gr a p h , T ‚àû is 9 Sc h e d u l i n g o f t a s k g r a p h s S c he dul e r i s a n a l g o r i t hm f o r a s s i g ni ng ta s k s to pr o c e s s o r s N o t e t ha t : T p de pe nds o n sc he dul e r T 1 / P an d T ‚àû ar e fix e d 68 W ha t i s T 2 f o r t hi s g r a ph? T ha t i s , w e ha v e 2 pr o ce s s o r s . T 2 w i l l be 5 w i t h t hi s s c he dul i ng (w e ha v e 5 t im e s t e p s ) 1 2 3 4 5 T 2 w i l l be 4 w i t h t hi s s c he dul i ng (w e ha v e 4 t im e s t e p s ) 1 2 3 4 13 Wo r k s t e a l i n g s c h e d u l e r Fir s t us e d in M IT ‚Äô s Ci l k , n o w a s t a n d a r d m e t h o d Pr o v a b l y : T p = T 1 / P + O ( T ‚àû ) E mp ir ic ally : T p ‚âà T 1 / P + T ‚àû Gu id e lin e f o r p a r a lle l p r o g r a ms = > ‚Äù Sc he duling M ult it hr e ade d C o m p u t a t i o n s b y W o r k S t e a l i n g ‚Äù , Bl u m f o e & Le is e r s o n , M I T 70 a b o u n d o n h o w f as t y o u c an g e t o n p p r o c e s s o r s w i t h a g r e e d y s c h e d u l e r: ùêì ùê© ‚â§ ùêìùüè / ùêè + ùêì ‚àû Th e o r e m [G r ah am ‚Äò 6 8 ] Su mma r y Di v i de a nd c o nque r f o r pa r a l l e l pr o g r a mmi ng Ci l k - s t y l e t a s k g r a p h s , s c h e d u l i n g a n d b o u n d s 71","libVersion":"0.3.1","langs":""}