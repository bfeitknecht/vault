{"path":"sem1/AuD/PV/kenji/AuD-w12-kenji.pdf","text":"Graph Cheatsheet f¨ur Algorithmen und Datenstrukturen Kenji Nakano, HS23, Stand 17.12.2023 Keine Garantie f¨ur Vollst¨andigkeit oder Korrektheit Deﬁnition Graph Ein Graph ist ein Tupel G =(V, E) wobei • V := Knotenmenge (vertices) • E := Kantenmenge (edges) jede Kante ist ein ungeordnetes Paar zweier Knoten u 6= v, e = {u, v} 2 E (Kurzform: uv) Weg, Pfad, Zyklus • Weg: Folge von benachbarten Knoten (engl. walk) • Pfad: Weg ohne wiederholte Knoten • Zyklus: Weg mit v0 = vl,l \u0000 2 (engl. closed walk) Die L¨ange eines Wegs bzw. Pfads ist die Anzahl an Kanten, nicht die Anzahl an Knoten Begri↵e • u, v adjazent/benachbart , e = {u, v} 2 E • e 2 E inzident/anliegend zu v ,9u 2 V , so dass e = {u, v} • deg(u) = Knotengrad von u (Anzahl Nachbarn) • u erreicht v ,9 Weg zwischen u und v (engl. reachable) ¨Aquivalenzrelation (symmetrisch, reﬂexiv, transitiv) • Zusammenhangskomponente (ZHK): ¨Aquivalenzklasse der ”erreichbar”-relation (engl. connected component) • Graph ist zusammenh¨angend , es gibt gibt genau eine ZHK Handschlag Lemma: X v2V deg(v)= 2 ·|E| Eulerweg, Hamiltonpfad, Eulerzyklus • Eulerweg: Weg welcher jede Kante genau einmal enth¨alt (engl. Eulerian walk) • Hamiltonpfad: Pfad der jeden Knoten genau einmal enth¨alt • Eulerzyklus: Zyklus welcher jede Kante genau einmal enth¨alt 9 Eulerzyklus , alle Knotengrade gerade und alle Kanten in einer ZHK 1 Algorithmus Eulertour / Eulerwalk Euler(G): • Input: Graph G =(V, E) • Output: Liste Z mit Eulerzyklus, falls existiert. • Laufzeit: O(m) EulerWalk(u): • Input: Knoten u 2 V • Output: Keiner • Laufzeit: O(m) Algorithm 1 Euler(G) Require: Alle Kanten unmarkiert 1: Z Leere Liste 2: EulerWalk(u0) . f¨ur u0 2 V beliebig 3: return Z Algorithm 2 EulerWalk(u) 1: for uv 2 E, nicht markiert do 2: markiere Kante uv 3: EulerWalk(v) 4: Z Z [ {u} 2 Begri↵e gerichtete Graphen Der Graph G =(V, E) ist deﬁniert wie beim ungerichteten ausser Kanten sind geordnete Paare e =(u, v) 2 E • v ist Nachfolger von u • u ist Vorg¨anger von v • degin(u) = Eingangsgrad • degout(u) = Ausgangsgrad • Quelle u: degin(u)=0 • Senke v: degout(v)=0 DFS (Depth-First-Search) DFS(G)(und Visit(u): • Input: Graph G =(V, E) • Output: Implementationsabh¨angig (kann f¨ur sehr viel verwendet werden) • Laufzeit: O(n + m) (f¨ur Adjazenzlisten) Algorithm 3 Visit(u) 1: pre[u] T ; T T +1 2: markiere u 3: for Nachvolger v von u, unmarkiert do 4: Visit(v) 5: post[u] T ; T T +1 Algorithm 4 DFS(G) 1: T 1 2: alle Knoten unmarkiert 3: for u0 2 V , unmarkiert do 4: Visit(u0) 3 BFS (Breadth-First-Search) BFS(s): • Input: Knoten s 2 V • Output: Implementationsabh¨angig (kann f¨ur sehr viel verwendet werden, ¨ahnlich wie DFS) • Laufzeit: O(n + m) Algorithm 5 BFS(s) 1: Q {s} . Q ist eine Queue 2: enter[s] 0; T 1 3: while Q 6= ? do 4: u dequeue(Q) 5: leave[u] T ; T T +1 6: for (u, v) 2 E,enter[v] nicht zugewiesen do 7: enqueue(Q, v) 8: enter[v] T ; T T +1 4 Shortest-Path Algorithmen Dijkstra(s): • Input: Knoten s 2 V – Graph darf nur nicht-negative Kantenkosten haben • Output: dist(s, v) f¨ur alle v 2 V • Laufzeit: O((m + n) · log(n)) Algorithm 6 Dijkstra(s) 1: d[s] 0; d[v] 1 8v 2 V \\{s} 2: S ? 3: H make-heap(V ); decrease-key(H, s, 0) 4: while S 6= V do 5: v⇤ extract-min(H) 6: S S [ {v⇤} 7: for (v⇤,v) 2 E, v /2 S do 8: d[v] min{d[v], d[v⇤]+ c(v⇤,v)} 9: decrease-key(H, v, d[v]) Bellman-Ford(s): • Input: Knoten s 2 V – Graph darf auch negative Kanten (und negative Zyklen) enthalten. • Output: dist(s, v) f¨ur alle v 2 V • Laufzeit: O(m · n) • Wenn man nach der (n \u0000 1)-ten Iteration nochmals eine weitere Iteration durchf¨uhrt und die Werte sich nochmals ver¨andern existiert ein gerichteter Zyklus mit negativem Totalgewicht Algorithm 7 Bellman-Ford(s) 1: d[s] 0; d[v] 18v 2 V \\{s} . 0-gute Schranken 2: for i 2 {1,. ..n \u0000 1} do . Verbessere Schranken (n \u0000 1)-mal 3: for (u, v) 2 E do 4: d[v] min{d[v], d[u]+ c(u, v)} 5 MST Algorithmen Boruvka(G): • Input: Graph G =(V, E) • Output: Minimaler Spannbaum F • Laufzeit: O((m + n) · log(n)) (wie Dijkstra) Algorithm 8 Boruvka(G) 1: F ? . sichere Kanten 2: while F nicht Spannbaum do .  log(n) Iterationen, O(m + n) pro Iteration 3: (S1,. .., Sk) ZHKs von F 4: (e1,. .., ek) minimale Kanten an S1,. .., Sk 5: F F [ {e1,. .., ek} Idee: Konzentrieren uns auf eine ZHK Prim(G, s): • Input: Graph G =(V, E)und s 2 V • Output: Minimaler Spannbaum F • Laufzeit: O((m + n) · log(n)) (wie Dijkstra und Boruvka) Algorithm 9 Prim(G, s) (allgemeine Form) 1: F ? 2: S {s} . ZHK von s in F 3: while F nicht Spannbaum do 4: u⇤v⇤ minimale Kante an S (u⇤ 2 S, v⇤ /2 S) 5: F F [ {u⇤v⇤} 6: S S [ {v⇤} Algorithm 10 Prim(G, s) (mit min-heap) 1: H make-heap(V, 1), S ? 2: d[s] 0; d[v] 1 8v 2 V \\{s} 3: decrease-key(H, s, 0) 4: while H 6= ? do 5: v⇤ extract-min(H) 6: S S [ {v⇤} 7: for v⇤v 2 E, v /2 S do 8: d[v] min{d[v],c(v⇤,v)} . Unterschied zu Dijkstra 9: decrease-key(H, v, d[v]) 6 Union-Find Datenstruktur Idee: verwalte alle Knoten einer ZHK als Liste Algorithm 11 Union-Find(G) 1: Implementierung: 2: make(V): rep[v] v 8v 2 V . O(n) 3: 4: same(u,v): teste ob rep[u]=rep[v] . O(1) 5: 6: union(u,v): . O(|ZHK(u)|) 7: for x 2 members[rep[u]] do 8: rep[x] rep[v] 9: members[rep[v]] members[rep[v]] [ {x} Idee: sichere Kanten sortiert nach Gewicht Kruskal(G): • Input: Graph G =(V, E)und s 2 V • Output: Minimaler Spannbaum F • Brauchen eine Union-Find Datenstruktur f¨ur e\u0000ziente Laufzeit • Laufzeit: O(m · log(m) | {z } Sortieren + n · log(n) | {z } Union-Find ) Algorithm 12 Kruskal(G) (mit UF-Datenstruktur) 1: F ? 2: UF make(V ) . UF-Datenstruktur initialisieren 3: sort(E) . Sortiere Kanten nach Gewicht 4: for uv 2 E, aufsteigend sortiert do 5: if same(u,v) = false then . u, v in verschiedenen ZHKs von F 6: F F [ {uv} 7: union(u,v) 7 All pairs Shortest Path Floyd-Warshall(G): • Input: Graph G =(V, E) • Output: L¨ange von beliebigem k¨urzestem Pfad. • Laufzeit: O(n3) • Teilproblem: di uv = L¨ange von k¨urzestem u \u0000 v-Weg, der nur Zwischenknoten aus {1,. .., i} benutzen darf Algorithm 13 Floyd-Warshall(G) 1: for u 2 V do 2: d0 uu 0 . falls keine negativen Schleifen 3: for v 2 V \\{u} do 4: if (u, v) 2 E then 5: d0 uv c(u, v) 6: else 7: d0 uv 1 8: for i =1 .. .n do 9: for u =1 .. .n do 10: for v =1 .. .n do 11: di uv min{di\u00001 uv ,di\u00001 ui + di\u00001 iv } return dn . n ⇥ n Resulatmatrix 8","libVersion":"0.3.1","langs":""}