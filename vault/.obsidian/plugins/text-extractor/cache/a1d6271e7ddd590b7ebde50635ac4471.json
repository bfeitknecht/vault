{"path":"sem1/EProg/UE/e/EProg-u09-e.pdf","text":"252-0027-00: Einführung in die Programmierung Übungsblatt 9 Abgabe: 28. November 2023, 23:59 Checken Sie mit Eclipse wie bisher die neue Übungsvorlage aus. Importieren Sie beide Eclipse- Projekte (das Projekt für den Bonus und das Projekt für die restlichen Aufgaben). Aufgabe 1: Square Grid (Bonus!) Achtung: Diese Aufgabe gibt Bonuspunkte (siehe “Leistungskontrolle” im www.vvz.ethz.ch). Die Aufgabe muss eigenhändig und alleine gelöst werden. Die Abgabe erfolgt wie gewohnt per Push in Ihr Git-Repository auf dem ETH-Server. Verbindlich ist der letzte Push vor dem Abgabetermin. Auch wenn Sie vor der Deadline committen, aber nach der Deadline pushen, gilt dies als eine zu späte Abgabe. Bitte lesen Sie zusätzlich die allgemeinen Regeln. In dieser Aufgabe betrachten wir gerichtete Graphen, wobei es für jeden Knoten g höchstens zwei gerichtete Kanten von g zu anderen Knoten f , h geben kann (f , g, h können gleich sein). Wir unterscheiden dabei zwischen der rechten und der unteren Kante (und damit dem rechten und dem unteren Knoten). Die Klasse Node repräsentiert einen Knoten in einem solchen Graphen. Die Methode Node.getRight() (bzw. Node.getDown()) gibt den rechten Knoten (bzw. unteren Knoten) zurück (als Node-Objekt). Wenn der rechte Knoten von n0 nicht existiert, dann gibt Node.getRight() null zurück (analog für den unteren Knoten). Die Methode Node.setRight(Node r) (bzw. Node.setDown(Node d)) setzt den rechten (bzw. unteren) Knoten. Das Ziel der Aufgabe ist, einen von einem Node-Objekt definierten Graphen zu analysieren. Konkret geht es darum, die Grösse des grössten quadratischen Gitters in dem Graphen zu bestimmen, der mit dem übergebenen Node-Objekt beschrieben wird, welches den gleichen Ursprungsknoten wie der Graph hat. Abbildung 1 zeigt ein Beispiel für einen Graphen mit Ursprungsknoten n(0,0) und Koordinaten {(0, 0), (0, 1), (1, 0), (1, 1)}, wobei jeweils R der rechten Kante und D der unteren Kante eines Knotens entspricht. Abbildung 2 zeigt zwei andere Graphen. 1 n ( 0 , 0 ) n ( 0 , 1 ) n ( 1 , 0 ) n ( 1 , 1 ) R D D R Abbildung 1: Graph als perfektes quadratisches Gitter D n ( 0 , 0 ) n ( 0 , 1 ) n ( 1 , 0 ) R R k m D (a) m D n ( 0 , 0 ) n ( 0 , 1 ) n ( 1 , 0 ) n ( 1 , 1 ) R D R n ( 0 , 2 ) R n ( 1 , 2 ) R D (b) Abbildung 2: Graphen mit quadratischen Gittern als Teilgraphen Ein Teilgraph G von einem Graphen G′ (wie oben definiert) mit Ursprungsknoten u definiert ein quadratisches Gitter mit Ursprungsknoten u und Koordinaten K (wobei K ⊆ N≥0 × N≥0; das heisst, Koordinaten haben keine negativen Komponenten), so dass folgende Bedingungen gelten: • Jeder Knoten in G ist auch in G′ und jede Kante in G ist auch in G′. • Jeder Knoten in G ist über die gerichteten Kanten vom Ursprungsknoten u erreichbar. • Es gibt gleich viele Knoten in G wie Koordinaten in K. Ausserdem wird jede Koordinate (i, j) ∈ K durch genau einen einzigartigen Knoten n(i,j) in G repräsentiert. Das heisst, wenn {(i, j), (i′, j′)} ⊆ K und (i, j) ̸= (i′, j′), dann gilt n(i,j) ̸= n(i′,j′). • Sei (i, j) ∈ K. Wenn der untere Knoten von n(i,j) existiert, dann gilt (i + 1, j) ∈ K und der untere Knoten von n(i,j) ist gegeben durch n(i+1,j). Wenn der rechte Knoten von n(i,j) existiert, dann gilt (i, j + 1) ∈ K und der rechte Knoten von n(i,j) ist gegeben durch n(i,j+1). • Sei n die Grösse des Quadrats (n ≥ 1). Dann ist K gegeben durch K = {(i, j) | 0 ≤ i < n, 0 ≤ j < n}. Implementieren Sie die Methode SquareGrid.analyzeSquareGrid(Node origin), welche die Grösse des grössten quadratischen Gitters in dem Graphen mit Ursprungsknoten origin (welches 2 origin als Ursprungsknoten hat) zurückgibt. Sie können davon ausgehen, dass origin nicht null ist (das bedeutet im Umkehrschluss, dass das kleinste Quadrat immer Grösse 1 hat). In Abbildung 1 hat für den Ursprungsknoten n(0,0) das grösste Quadrat Grösse 2. In Abbil- dung 2a hat für den Ursprungsknoten n(0,0) das grösste Quadrat Grösse 1, und in Abbildung 2b hat für den Ursprungsknoten n(0,0) das grösste Quadrat ebenfalls Grösse 2 (das grösste Quadrat für den Ursprungsknoten n(0,1) hat hier ebenfalls Grösse 2; für alle anderen Urpsrungsknoten in dem Graphen hat das grösste Quadrat Grösse 1). In der Klasse Main finden Sie eine main-Methode, welche Sie verwenden können, um Ihre Implementierung zu testen. In der Datei “SquareGridTest.java” finden Sie ausserdem einige Tests. Aufgabe 2: Umkehrung In einem vorherigen Übungsblatt haben Sie eine Linked List für Integers implementiert. In dieser Aufgabe fügen Sie dieser LinkedIntList eine weitere Methode hinzu, welche die Liste umkehrt. Eine Liste gilt als umgekehrt, wenn für jedes Paar von Nodes a und b, für welche zuvor a == b.next gegolten hat, in der neuen (umgekehrten) Liste b == a.next gilt. Zusätzlich entspricht nach der Umkehrung der erste Node der neuen Liste dem letzten Node der ursprünglichen Liste (und umgekehrt). Vervollständigen Sie die Methode reverse() in der Klasse LinkedIntList. Die Methode soll, wie oben definiert, die Liste umkehren. Achten Sie darauf, dass Sie wirklich die Reihenfolge der Nodes selbst umkehren. Es reicht nicht aus, die Reihenfolge der enthaltenen int-Werte umzukehren. Es müssen auch in der umgekehrten Liste dieselben Instanzen von IntNodes wie in der ursprünglichen Liste verwendet werden. Erstellen Sie also keine neuen IntNodes mit new IntNode(). In der Datei “UmkehrungTest.java” finden Sie einen einfachen Test. Aufgabe 3: Künstliche Intelligenz für das Ratespiel In Übung 5 implementierten Sie ein Spiel, in welchem der Computer ein Wort auswählt und der Spieler dieses erraten muss. Dort war der Spieler der Benutzer des Programms. In dieser Aufgabe sollen Sie verschiedene “künstliche” Spieler entwickeln. Das heisst, anstelle des Menschen, der über die Konsole Tipps eingibt, werden die Tipps von (mehr oder weniger “intelligenten”) Programmen abgegeben. Ihr Ziel ist es, einen künstlichen Spieler zu entwickeln, der über mehrere Spiele hinweg die Wörter in so wenig Versuchen wie möglich errät. Die Übungsvorlage enthält bereits den Code für das Ratespiel. Gegenüber Übung 5 ist dieser nun in verschiedene Klassen aufgeteilt. Die drei Hauptklassen sind RateSpiel, Computer und Spieler. Die Klasse RateSpielApp enthält eine main-Methode, welche das Spiel aufsetzt und durchführt. Durch die Aufteilung ist es möglich, mittels Vererbung Spieler mit unterschiedlichem Verhalten zu schreiben. Die Klasse Spieler enthält nämlich nur die Deklarationen der benötigten Methoden, aber keine (sinnvolle) Funktionalität. Subklassen von Spieler überschreiben diese Methoden und definieren damit das Verhalten eines Spielers. Ein konkreter Spieler ist ebenfalls schon in der Vorlage vorhanden: der KonsolenSpieler. Dieser besitzt allerdings keine eigene “Intelligenz”, sondern holt sich die Tipps über die Konsole vom Benutzer. Ein RateSpiel mit einem KonsolenSpieler verhält sich also so wie das Spiel in 3 Übung 5. Starten Sie die RateSpielApp und überzeugen Sie sich selbst1. a) Schreiben Sie als erstes eine Klasse ZufallsWortSpieler, welche einen Spieler implementiert, der in jeder Runde zufällig ein Wort aus der Liste der verwendeten Wörter tippt. Die Klasse soll von Spieler erben und die benötigten Methoden überschreiben. In der neuesSpiel-Methode, welche immer zu Beginn eines Spiels vom RateSpiel aufgerufen wird, soll sich der Spieler das Array der im Spiel verwendeten Wörter merken. Speichern Sie eine Referenz dazu in ein woerter-Feld. Mit der gibTipp-Methode gibt der Spieler seinen nächsten Tipp ab. Überschreiben Sie diese Methode, so dass sie einen zufälligen Index für das woerter-Array (siehe Random.nextInt(int)) erzeugt und das entsprechende Wort zurück gibt. Das Generieren des Index sollen Sie in einer separaten Methode zufallsWortIndex() implementieren. (Sie sehen später, weshalb.) Überschreiben Sie ausserdem name(). Ändern Sie jetzt das RateSpielApp-Programm so ab, dass statt einem KonsolenSpieler ein ZufallsWortSpieler am Spiel teilnimmt. Erhöhen Sie ausserdem die Anzahl der Spiele, die durchgeführt werden, indem Sie das Argument der nSpiele-Methode von 1 z.B. auf 1000 ändern. Sie sollten ungefähr folgende Ausgabe erhalten: ... Spiel 999 Spiel 1000 Zufalls-Wort-Spieler hat durchschnittlich 495.138 Versuche benötigt. b) Erstellen Sie einen zweiten Spieler, ZufallsWortSpielerMitGedaechtnis, der sich in jedem Spiel merkt, welche Wörter er schon ausprobiert hat. Da dieser einige Ähnlichkeit zum ZufallsWortSpieler hat, sollen Sie ihn als Subklasse von ZufallsWortSpieler entwerfen. Das Gedächtnis des Spielers können Sie als boolean[]-Feld ausdrücken, welches für je- des mögliche Wort angibt, ob dieses Wort schon ausprobiert wurde. Dieses Array sollte zu Beginn jedes Spiels neu initialisiert werden. Überschreiben Sie dazu die neuesSpiel- Methode vom ZufallsWortSpieler. Vorsicht: der Code in der neuesSpiel-Methode von ZufallsWortSpieler sollte trotzdem ausgeführt werden, denn da merkt er sich ja die Liste der Wörter! Fügen Sie deshalb einen entsprechenden super-Methodenaufruf hinzu. Da Sie in a) das Erzeugen des Wort-Index in einer separaten zufallsWortIndex-Methode im- plementierten, können Sie nun diese Methode überschreiben, um das Verhalten von gibTipp() dieses Spielers zu ändern. (Dafür darf die Sichtbarkeit von zufallsWortIndex() in ZufallsWortSpieler nicht private sein). Überschreiben Sie sie so, dass sie das Gedächtnis des Spielers einbezieht. Sie müssen dafür einen zufälligen Index generieren, welcher nicht schon verwendet wurde. Überschreiben Sie auch name() und ändern Sie dann RateSpielApp erneut, so dass beide Zufalls-Spieler spielen. Die Ausgabe sollte jetzt etwa so aussehen: ... Zufalls-Wort-Spieler hat durchschnittlich 492.513 Versuche benötigt. Zufalls-Wort-Spieler mit Gedächtnis hat durchschnittlich 242.493 Versuche benötigt. c) Die beiden Zufalls-Spieler sind noch nicht wirklich “intelligent”. Der Grund ist, dass sie gar keinen Nutzen aus den Hinweisen des Computers (“enthält”, “enthält nicht”, usw.) ziehen. Schreiben Sie deshalb einen (oder mehrere) Spieler, welche bessere Tipps abgeben und die 1Beachten Sie, dass die Wörter-Datei jetzt 500 Wörter enthält! 4 Hinweise nutzen, um die Menge der noch möglichen Wörter einzuschränken. Dazu müssen Sie die bekommeHinweis-Methode von Spieler überschreiben. Wenn Sie verschiedene Ideen ausprobieren wollen, schreiben Sie verschiedene Spieler- Subklassen und vergleichen Sie sie mithilfe der RateSpielApp. Schauen Sie sich auch den RateSpiel-Konstruktor an, welcher zwei hilfreiche Parameter zur Verfügung stellt. Wie schlägt sich Ihr bester Spieler im Vergleich zu den Spielern Ihrer Mitstudierenden? Tipps: • Beginnen Sie einfach – z.B. mit einem Spieler, der zuerst alle Buchstaben des Alphabets tippt und dann die noch möglichen Wörter durchprobiert. • Heuristiken (z.B. “e” kommt öfter vor als “x”) sind hilfreich. • Überlegen Sie sich, ob es so etwas wie eine “optimale” Strategie gibt. Aufgabe 4: Pong In dieser Aufgabe geht es darum, den Klassiker Pong von 1972 nachzubauen. Es sollen zwei Spieler gegen- einander spielen können. Dafür kommt die bereits bekannte Window-Klasse zum Zug. Sie bietet einige Methoden, um Input von Maus und Tastatur aufzuneh- men. Eine davon ist isKeyPressed(String keyName), welche true zurück gibt, wenn die spezifizierte Taste zum Zeitpunkt des Aufrufs gedrückt ist: if(window.isKeyPressed(\"up\")) { // move something around } Das Spiel besteht aus einem Pongball und aus zwei Spielern, welche je einen vertikalen Balken kontrollieren und versuchen, den Pongball im Spiel zu halten. Wenn der Pongball das Spiel seitlich verlässt, erhält der gegenüberliegende Spieler einen Punkt. Wenn der Pongball hingegen die Wände oben und unten oder einen Spielerbalken berührt, prallt er ab. a) In Ihrem Projekt finden Sie bereits Vorlagen für folgende Klassen: PongGame: Verantwortlich für das Speichern und Berechnen der Spielsituation. PongGui: Verantwortlich für die grafische Umsetzung des Spielgeschehens. Beinhaltet die main-Methode und ist für die graphische Oberfläche des Spiels verantwortlich. Erstellen Sie zwei weitere Klassen Player und Pongball, welche alle Informationen zu Spie- ler und Pongball beinhalten. Ein Spieler hat eine (px, py)-Position, eine Balkenlänge und einen Punktestand. Ein Pongball hat ebenfalls eine Position und zusätzlich eine (vx, vy)- Geschwindigkeit (in Pixel/Spielschritt). Ändern Sie ausserdem den Konstruktor von PongGame so, dass er zwei Player- und eine Pongball-Instanz erstellt und in Feldern speichert. Der Pongball soll zu Beginn des Spiels in der Mitte starten und eine zufällige Geschwindigkeit haben. 5 b) Ergänzen Sie PongGui so, dass Pongball und Spielerbalken angezeigt werden und man die Balken mittels Tastatur (z.B. mit up, down und w, s) bewegen kann. In jedem Durchlauf der main-Schleife sollen Sie die step-Methode von PongGame aufrufen. Ändern Sie step() so ab, dass sich der Pongball entsprechend seiner Geschwindigkeit bewegt (noch ohne Kollisionen). Starten Sie das Programm und überprüfen Sie, ob sich Spieler und Pongball wie erwartet bewegen. c) Fangen Sie jetzt in step() die Kollisionen des Pongballs mit den Wänden ab. Es gilt: Einfalls- winkel ist gleich Ausfallswinkel. Tipp: Da alle Wände und Balken senkrecht oder waagrecht sind, ändert sich immer nur eine Komponente der Geschwindigkeit. d) Stellen Sie das Spiel fertig, indem Sie in step() auch Kollisionen zwischen Pongball und Spielerbalken abfangen. Sie können z.B. eine Methode in der Klasse PongGame schreiben, welche überprüft, ob ein Pongball mit einem gegebenen Spieler kollidiert. Zählen Sie jetzt auch die Punkte der Spieler. Wenn der Pongball eine Seitenwand berührt, gibt es einen Punkt und der Pongball startet von Neuem in der Mitte des Feldes. Um den Punktestand zu zeichnen, können Sie die Window.drawString()-Methode verwenden. Zusatzaufgabe: Erweitern Sie das Spiel so, dass mehrere Bälle gleichzeitig im Spiel sind. Immer nach 50 Spielschritten soll ein neuer Pongball hinzukommen und wieder entfernt werden, wenn er das Spielfeld verlässt. Dafür sollen Sie die Klassen der doubly-linked list kopieren und für Pongball-Objekte anpassen. Aufgabe 5: Klassenrätsel In dieser Aufgabe sollen Sie zeigen, dass Sie mit Klassen und Vererbung umgehen können. Im Anhang A finden Sie ein Programm, welches Instanzen von Klassen erstellt und Methoden aufruft. Das Programm macht nichts Sinnvolles und dient nur dem Testen Ihrer Fähigkeiten. In Anhang B befinden sich die verwendeten Klassen, jedoch sind die Klassen noch nicht vollständig. Bei manchen der Klassen fehlt noch die extends-Klausel, welche angibt, dass eine Klasse von einer anderen Klasse erbt. Ihre Aufgabe ist es, die nötigen extends-Klauseln hinzuzufügen, so dass alles kompiliert und so dass die Ausgabe des Programms von Anhang A am Ende so aussieht wie im Anhang C gezeigt. Der Code von Anhang A and Anhang B befindet sich in Ihrem src-Ordner. Zusätzlich enthält “KlassenTest.java” einen Unit-Test, welcher prüft, ob die Ausgabe des Programms dem Output aus Anhang C entspricht. Beachten Sie, dass Sie für diese Aufgabe ausschliesslich extends-Klauseln hinzufügen (diese kann es nur an den grauen Boxen aus Anhang B geben), kein anderer Code darf verändert werden. Tipp: Lösen Sie die Aufgabe zuerst auf Papier, ohne die Hilfe von Eclipse. Sobald Sie heraus- gefunden haben, welche Klassen von welchen Klassen erben, testen Sie Ihre Lösung in Eclipse. Dies hilft Ihnen, Ihr Wissen über Vererbung zu testen. In der Vergangenheit wurden ähnliche Aufgaben im schriftlichen Teil der Prüfung gestellt. 6 Anhang A: Testprogramm Klassenrätsel class Klassen { ... public static void klassen(PrintStream output) { Z ref1 = new B(); ref1.bar(output); output.println(\"++\"); Z ref2 = new A(); ((A) ref2).bar(output); output.println(\"++\"); C c1 = new C(); output.println(\"C.foo():\"); c1.foo(output); output.println(\"--\"); D d1 = new D(); if (d1 instanceof C) { ((C)d1).test(output); } else { d1.foo(output); } } } Anhang B: Klassen Klassenrätsel class C { public void foo(PrintStream output) { output.println(\"Here\"); } public void test(PrintStream output) { output.println(\"Test\"); } } class D { public void foo(PrintStream output) { super.foo(output); 7 } } class Z { public void bar(PrintStream output) { output.println(\"Hello\"); } } class A { int a1 = 0; A() {} A(int v) { a1 = v; } public void foo(PrintStream output) { output.println(\"Found\"); } } class B { B() { } B(int w) { super(w); } public void bar(PrintStream output) { super.bar(output); output.println(\"Bingo\"); } } 8 Anhang C: Ausgabe Klassenrätsel Hello Bingo ++ Hello ++ C.foo(): Here -- Found 9","libVersion":"0.3.1","langs":""}