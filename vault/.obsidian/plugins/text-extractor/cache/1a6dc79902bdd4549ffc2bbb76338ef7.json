{"path":"sem2/AuW/VRL/slides/AuW-L16-random-algorithms.pdf","text":"Al gor i thm e n und Wa h r s c h e i n l i c h k e i t A n g e l i ka S t e g e r E m o W e l zl I n st i t u t f Ã¼ r T h e o r e t i sch e I n f o r m a t i k Wahrscheinlichkeit Kapitel 2.8 Randomisierte Algorithmen Randomisierte Algorithmen Algorithmus A Eingabe I Ausgabe A(I,R) Zufallszahlengenerator Wir beweisen: (1) Korrektheit: fÃ¼r alle Eingaben I gilt: Pr[A(I,R) ist korrekt] â‰¥ â€¦ (2) Laufzeit: fÃ¼r alle Eingaben I mit LÃ¤nge |I|=n: [Laufzeit] = O(f(n)) und/oder Pr[Laufzeit â‰¦ O(f(n))] â‰¥ â€¦ ğ”¼ Idealer Weise: Wâ€™keit â€praktischâ€œ Eins Anfragen der Form: liefere einen Wert fÃ¼r X, wobei X verteilt ist wie â€¦ Annahme: alle Werte, die der Zufallszahlengenerator erzeugt sind unabhÃ¤ngig Las-Vegas und Monte-Carlo Algorithmen Las-Vegas Algorithmen: - geben nie eine falsche Antwort, aber - Laufzeit ist eine Zufallsvariable Monte-Carlo Algorithmen: - Laufzeit immer polynomiell, aber - geben zuweilen eine falsche Antwort Ziel: [Laufzeit] = â€polynomiellâ€œ (in EingabelÃ¤nge) ğ”¼ Ziel: Pr[Antwort falsch] = â€winzigâ€œ Las-Vegas Algorithmen Las-Vegas Algorithmen: - geben nie eine falsche Antwort, aber - Laufzeit ist eine Zufallsvariable T - Laufzeit immer polynomiell, aber - zuweilen Antwort â€???â€œ mit: [T] = â€polynomiell (in EingabelÃ¤nge) â€œ ğ”¼âŸ¹ stoppe Alg nach Schritten 2ğ”¼[T ] Pr[Antwort â€???â€œ] â‰¤ 1/2 (wg Markov Ungleichung) â€¦ wdh 100 Mal ( ) 100 Las-Vegas Algorithmen Las-Vegas Algorithmen: - geben nie eine falsche Antwort, aber - Laufzeit ist eine Zufallsvariable T - Laufzeit immer polynomiell, aber - zuweilen Antwort â€???â€œâŸ¹ while Antwort â€???â€œ: repeat mit: Pr[Antwort â€???â€œ] = Î´ poly ğ”¼[T] = 1 1 âˆ’ Î´ â‹… (Anzahl Versuche: Geo(1- )) Î´ Fehlerkorrektur Einseitiger Fehler: Zweiseitiger Fehler: Îµ -1 ln Î´ -1 Wiederholungen reduzieren Fehler auf Pr[Antwort falsch] â‰¦ Î´ Pr[Antwort falsch] â‰¦ 1/2-Îµ Instanzen 4 Îµ -2 ln Î´ -1 Wiederholungen reduzieren Fehler Pr[Antwort falsch] â‰¦ Î´ âˆ€ (Antwort: Mehrheit der gesehenen Antworten) Monte-Carlo Algorithmen fÃ¼r Entscheidungsprobleme Pr[Alg antwortet â€neinâ€œ] = 0 Ja-Instanzen Pr[Alg antwortet â€jaâ€œ ] â‰¦ 1-Îµ Nein-Instanzen âˆ€ âˆ€ (Antwort â€neinâ€œ: wenn mind. ein Aufruf â€neinâ€œ ausgibt, Antwort â€jaâ€œ: wenn alle Wdh â€œjaâ€œ ausgeben) Target-Shooting Gegeben: zwei Mengen S âŠ† U Aufgabe: bestimme |S| / |U| Annahmen: - wir kÃ¶nnen ein Element aus U efï¬zient zufÃ¤llig gleichverteilt wÃ¤hlen - es gibt eine efï¬zient berechenbare Funktion I S (u):= (1fallsu2S 0sonst Target-Shooting Beweis: Chernoff-Schranke â€¦ Primzahltest Kapitel 2.85 Hashing und Zuordnungsverfahren Hashing Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natÃ¼rliche Zahl ab f : Daten â {0,â€¦,m-1} Hashing - Beispiel Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natÃ¼rliche Zahl ab Freunde Adressbuch Hashing - Beispiel Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natÃ¼rliche Zahl ab Freunde Adressbuch Hashing - Beispiel Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natÃ¼rliche Zahl ab Freunde Adressbuch f : â Hashing - Beispiel Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natÃ¼rliche Zahl ab f : â Freunde Adressbuch Hashing Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natÃ¼rliche Zahl ab f : Daten â {0,â€¦,m-1} GewÃ¼nschte Eigenschaften: - alle Hashwerte sollen â€gleich oftâ€œ vorkommen - â€geringeâ€œ Wahrscheinlichkeit von Kollisionen - Ã¤hnliche Eingaben sollen zu verschieden Ergebnissen fÃ¼hren - f soll efï¬zient berechenbar sein - [in der Kryptographie] f -1 soll nicht efï¬zient berechenbar sein Hashing Anwendungen: - Datenbanken - PrÃ¼fsummen - Kryptographie - Algorithmen fÃ¼r grosse Datenmengen Hashing Theorie: In der Analyse von Algorithmen geht man meist davon, dass Hashfunktionen die gegebenen Daten zufÃ¤llig und unabhÃ¤ngig von einander auf {0,â€¦,m-1} abbilden. Praxis: Man wÃ¤hlt eine Hashfunktion f aus einer vorgegeben Menge von Funktionen (universelle Hashklasse) zufÃ¤llig. m KÃ¶rbe n BÃ¤lle (balls) zufÃ¤llig f : Man geht davon aus, dass die Funktion f die in der theoretischen Analyse gemachten Annahmen erfÃ¼llt. (deterministisch) Hashing Probleme die es zu lÃ¶sen gilt: - Konstruktion einer Hashfunktion - Umgang mit Kollisionen (mod m) notwendig: theoretisches VerstÃ¤ndnis â€was ist Ã¼berhaupt mÃ¶glichâ€œ Balls and Bins m KÃ¶rbe (bins) n BÃ¤lle (balls) zufÃ¤llig X i := Anzahl BÃ¤lle im i-ten Korb Frage: Wie gross ist ? max 1ï£¿iï£¿n X i","libVersion":"0.3.1","langs":""}