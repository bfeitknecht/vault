{"path":"sem1/DMath/PV/leon/DMath-leon-w06.pdf","text":"Diskrete Mathematik Übungsstunde Zusammenfassung Leon Kolmanić 30.10.2023 1 Besprechung Bonusaufgabe Häufige Fehler waren: • Beweisschritte nicht begründet, unter anderem nicht die Eigenschaften einer Ordnungsrelation explizit als Begründung angegeben (Reflexivität, Antisymmetrie, Transitivität) • Gegebene Ordnungsrelation ≤ als “kleiner gleich” Relation interpretiert • Nicht erklärt, wieso aus least([a]θ) = least([b]θ) diese Gleichheit folgt: [a]θ = [b]θ • Fehler bei den Annahmen bei dem Beweisen der Eigenschaften einer Ord- nungsrelation – Falsche Annahmen gemacht – Annahmen nicht korrekt aufgeschrieben – Annahmen nicht/unvollständig hingeschrieben Bei solchen Aufgaben ist es wichtig, die korrekte Anwendung der Eigen- schaften von Ordnungsrelationen zu demonstrieren. Deshalb wird grossen Wert darauf gelegt, dass man Beweisschritte mit den passenden Eigenschaften der Relationen begründet. Wenn in einer Aufgabe ein Poset (A; ≤) gegeben ist, können wir nicht aufgrund des verwendeten Symbols schliessen, dass ≤ für die bereits bekannte Ordnungs- relation “kleiner gleich” steht. Die einzige Annahme, die wir über ≤ machen dürfen, ist, dass ≤ eine Ordnungsrelation ist. Dementsprechend sind Formulie- rungen wie “a ist kleiner gleich b” für a ≤ b oder Begründungen wie “weil a = b folgt a ≤ b” anstelle von “aus der Reflexivität von ≤ und a = b folgt a ≤ b” nicht erlaubt. Der Beweisschritt least([a]θ) = least([b]θ) ˙=⇒[a]θ = [b]θ 1 wurde ohne Begründung nicht akzeptiert. Man hätte stattdessen zuerst folgern sollen, dass [a]θ und [b]θ ein gemeinsames Element haben. Dann kann man ver- wenden, dass die Quotientenmenge A/θ einer Äquivalenzrelation θ auf einer Menge A eine Partition von A ist. Mit anderen Worten: Die Äquivalenzklassen [a]θ sind disjunkt und die Vereinigung der Äquivalenzklassen ist A. Wenn zwei Äquivalenzklassen ein gemeinsames Element haben, müssen sie also gleich sein (sonst hätten wir zwei verschiedene Äquivalenzklassen gefunden, die nicht dis- junkt sind, ein Widerspruch dazu, dass A/θ eine Partition ist). Um die volle Punktzahl zu bekommen, ist es entscheidend, die richtigen Annah- men zu machen und diese formal korrekt zu formulieren. Dabei sollte man am besten nicht bei jeder Aufgabe das Rad neu erfinden, sondern korrekte Formu- lierungen auswendig lernen (oder aufs Cheat Sheet schreiben) und diese immer verwenden. Hier sind Vorschläge von mir: Eigenschaft Formulierung Annahmen Reflexivität Let a ∈ A be arbitrary. Symmetrie Let a, b ∈ A be arbitrary such that a θ b. Antisymmetrie Let a, b ∈ A be arbitrary such that a ⪯ b and b ⪯ a. Transitivität Let a, b, c ∈ A be arbitrary such that a ⪯ b and b ⪯ c. 2 Hasse-Diagramme, besondere Elemente in Po- sets und Verbände1 Der Aufgabentyp ein Hasse-Diagramm zu zeichnen und/oder in einem Poset besondere Elemente auszumachen kommt in der Klausur häufig vor. Man kann diesen aber einfach üben. Eine beispielhafte Aufgabe könnte so aussehen: Sei das Poset (A; |) gegeben, wobei A = {1, 2, 3, 4, 6, 12, 17}. 1. Zeichne das Hasse-Diagramm von (A; |) 2. Zähle separat alle kleinsten, minimalen, grössten und maximalen Elemente von (A; |) auf 3. Entscheide, ob a und b vergleichbar sind, falls (a) a = 3, b = 4 (b) a = 2, b = 12 4. Finde alle oberen und unteren Schranken von B ⊆ A. Gebe ausserdem die kleinste obere und grösste untere Schranke von B an (falls vorhanden). 1engl. lattices 2 (a) B = {1, 2, 3} (b) B = {2} 5. Was sind 4 ∧ 6 und 4 ∨ 6? 6. Beweise, dass (A; |) kein Verband ist. Lösung: Das Hasse-Diagramm sieht wie folgt aus: In den Erklärungen werde ich folgenden Begriff verwenden: Ein nach oben gerichteter Pfad ist ein Pfad, bei dem die Kanten nur von unten nach oben durchlaufen werden. (1, 2, 4, 12) ist ein solcher Pfad, (6, 3) hingegen nicht. In dem Hasse Diagramm bedeutet die Existenz eines nach oben gerichteten Pfades von einem Element x zu einem Element y, dass x | y. Das kleinste Element ist 1, weil jedes Element in A durch 1 teilbar ist. Das kann man anschaulich sehen, weil man von 1 aus jedes Element durch einen nach oben gerichteten Pfad erreichen kann. 1 ist somit auch ein minimales Element (jedes kleinste Element ist minimal). Es gibt keine anderen minimalen Elemen- te, weil für jedes x ∈ A mit x ̸= 1 ein y ∈ A existiert (nämlich 1), sodass y | x und y ̸= x. Anschaulich gesprochen: Jedes Element ausser 1 hat einen von unten eingehenden Strich. Es gibt kein grösstes Element, weil es kein x ∈ A gibt, sodass für alle y ∈ A y | x gilt (keine Zahl in der Menge ist durch alle Zahlen in der Menge teilbar). Das kann man im Diagramm sehen, weil es keinen Knoten x gibt, sodass man von jedem anderen Knoten y aus diesen mit einem nach oben gerichteten Pfad erreichen kann. Es gibt aber maximale Elemente, also Elemente, die keine Zahl in der Menge ausser sich selbst teilen. Diese sind 12 und 17. Man kann das im Diagramm daran erkennen, dass 12 und 17 beide keinen nach oben gehenden Strich haben. 3 Um zu entscheiden, ob zwei Elemente x und y vergleichbar sind, müssen wir prüfen ob x | y oder y | x gilt. 3 und 4 sind nicht vergleichbar, 2 und 12 aber schon. Wenn zwei Elemente vergleichbar sind, kann man von einem der Elemen- te zum anderen durch einen nach oben gerichteten Pfad kommen, andernfalls nicht. Um alle oberen Schranken einer Teilmenge B zu finden, muss man schauen, wel- che Elemente in A durch alle Elemente in B teilbar sind, genau diese Elemente sind obere Schranken. Analog kann man alle unteren Schranken finden: Das sind diejenigen Elemente in A, die alle Elemente in B teilen. Es ist wichtig zu be- achten, dass obere und untere Schranken von B auch selbst in B enthalten sein können. Die oberen Schranken von {1, 2, 3} sind: 6 und 12. Die einzige untere Schranke ist 1. Die oberen Schranken von {2} sind 2, 4, 6 und 12. Die unteren Schranken sind 1 und 2. Weil {1, 2, 3} nur eine untere Schranke hat, ist diese (also 1) gleichzeitig die grösste untere Schranke. Die grösste untere Schranke von {2} ist 2, weil 2 untere Schranke ist und durch alle unteren Schranken (1 und 2) teilbar ist. Die kleinste obere Schranke von {1, 2, 3} ist 6, weil 6 alle oberen Schranken (6 und 12) teilt. {1, 2} hat keine kleinste obere Schranke, weil es keine Zahl unter den oberen Schranken 4, 6 und 12 gibt, die 4, 6 und 12 teilt. 4 ∧ 6 ist per Definition die grösste untere Schranke von {4, 6}. {4, 6} hat die unteren Schranken 2 und 1, also ist 2 die grösste untere Schranke. Es folgt 4 ∧ 6 = 2. 4 ∨ 6 ist die kleinste obere Schranke von {4, 6}. {4, 6} hat nur 12 als obere Schranke, also ist 12 auch die kleinste obere Schranke. Es folgt 4 ∨ 6 = 12. Ein Verband ist ein Poset (A, ⪯), in dem jede zweielementige Teilmenge eine kleinste obere Schranke und eine grösste untere Schranke hat. Wir müssen also nur eine solche Menge finden, für die das nicht gilt. Die Menge {12, 17} ist ein gültiges Gegenbeispiel, weil sie keine obere Schranken hat und somit auch keine kleinste obere Schranke. 3 Beweis der (Über)abzählbarkeit Aufgaben, bei denen man (Über)abzählbarkeit beweisen muss, kommen an fast jeder Prüfung vor. Ich kann sehr empfehlen, diese Aufgaben gut zu üben. Es gibt drei mögliche Herangehensweisen an solche Beweise. Die erste funktioniert nur bei einfachen Mengen, die zweite bei allen Mengen und die dritte nur bei unabzählbaren Mengen. 3.1 Beweis über die Definitionen und Theoreme Das ist die erste Methode, die man versuchen sollte, weil sie am einfachsten ist. Meistens kann man sie aber leider nicht anwenden. Im Skript gibt es heoreme, die man für spezielle Mengen anwenden kann. Beispielsweise sind das kartesi- sche Produkt zweier abzählbarer Mengen, die Menge der endlich langen Folgen mit Gliedern aus einer abzählbaren Menge und die Union einer abzählbaren Liste von abzählbaren Mengen abzählbar. Wenn A Teilmenge von B ist, dann dominiert B A, also A ⪯ B. Ausserdem kann man die Transitivität von ⪯ 4 verwenden. 3.2 Beweis durch Definition einer Funktion Das ist die Methode, die ihr in der Klausur am häufigsten brauchen werdet. Das Vorgehen bei dieser Methode unterscheidet sich je nachdem, ob wir Abzählbar- keit oder Unabzählbarkeit beweisen wollen. 3.2.1 Überabzählbarkeit Um die Überabzählbarkeit von A zu beweisen, gehen wir wie folgt vor: 1. Definiere eine Funktion f : {0, 1}∞ → A 2. Zeige, dass f eine Injektion ist 3. Antwortsatz: Weil es eine Injektion von {0, 1} ∞ nach A gibt, gilt nach Definition von ⪯ {0, 1}∞ ⪯ A. Da {0, 1} ∞ überabzählbar ist, ist A über- abzählbar. 3.2.2 Abzählbarkeit Um die Abzählbarkeit von A zu beweisen gehen wir wie folgt vor: 1. Definiere eine Funktion f : A → N 2. Zeige, dass f eine Injektion ist 3. Antwortsatz: Weil es eine Injektion von A nach N gibt, gilt per Definition von ⪯ A ⪯ N. Also ist A nach Definition von Abzählbarkeit abzählbar. 3.2.3 Injektivität zeigen Injektivität einer Funktion f : A → B kann man wie folgt zeigen: 1. Wähle x, y ∈ A beliebig 2. Zeige f (x) ̸= f (y) Der zweite Schritt unterscheidet sich je nach Funktion. Man muss hier mit der Definition von f arbeiten. 3.3 Cantors Diagonalisierungsargument Ihr braucht diese Methode nur, wenn die Aufgabestellung von euch fordert, Cantors Diagonalisierungsargument zu verwenden. Bei dieser Methode rezitiert ihr den Beweis der Überabzählbarkeit von {0, 1} ∞ aus dem Skript. Ihr müsst hierbei je nach Menge die Definition der neuen Folge, die nicht in der Aufzählung vorkommen kann, anpassen. Wenn man zum Beispiel die Überabzählbarkeit von {0, 1, 2}∞ beweisen soll, kann man das Komplement x von einem x ∈ {0, 1, 2} als x + 1 modulo 3 definieren. 5 4 Beispielaufgaben Überabzählbarkeit 4.1 Beweis mit Theoremen und Definitionen Wir wollen folgendes Theorem zeigen: Theorem. Sei A eine Menge, sodass (A × A) ∗ unendlich ist und nicht (A × A)∗ ∼ N gilt. Dann nicht A ⪯ N. Uns fällt auf, dass die Menge (A × A) ∗ aus A durch das kartesische Produkt und die Menge der endlich langen Folgen mit Gliedern aus einer Menge definiert wird. Für diese speziellen Fälle gibt es einschlägige Lemmas im Skript. Diese können wir aber nur auf abzählbare Mengen anwenden. Deshalb beweisen wir die Implikation indirekt: Dann können wir annehmen, dass A abzählbar ist. Beweis. Wir beweisen die Implikation indirekt. Sei A also eine beliebige Menge, sodass A ⪯ N gilt. A ⪯ N ˙=⇒A ist abzählbar (Definition abzählbar) ˙=⇒A × A ist abzählbar (Korollar 3.20.) ˙=⇒(A × A) ∗ ist abzählbar (Theorem 3.22.) ˙=⇒(A × A) ∗ ist endlich oder (A × A) ∗ ∼ N (Theorem 3.17.) (1) (1) ist die Negation von (A × A) ∗ ist unendlich und nicht (A × A) ∗ ∼ N. 4.2 Beweis durch Konstruktion einer Injektion Nun sollen wir folgendes Theorem zeigen: Theorem. Sei S = {Funktionen N → N}. S ist überabzählbar. Für den Beweis müssen wir es schaffen, jedem unendlich langen Bitstring ei- ne Funktion von den natürlichen Zahlen in die natürlichen Zahlen zuzuordnen. Das entspricht einer Injektion von {0, 1} ∞ nach S. Die intuitive Idee ist folgen- de: Wenn man für jeden Bitstring eine solche Funktion finden kann (ein Element von S), wissen wir, dass es mindestens so viele Funktionen wie unendlich lange Bitstrings gibt. Aber weil es überabzählbar viele unendlich lange Bitstrings gibt, gibt es also auch überabzählbar viele Funktionen von den natürlichen Zahlen in die natürlichen Zahlen. Der Knackpunkt der Aufgabe ist es also, einen Weg zu finden, jeden unendlich langen Bitstring in einem Element von S “unterzubrin- gen”. Wir bemerken folgendes: Jede Funktion f : N → N kann jeder natürlichen Zahl eine natürliche Zahl zuordnen. Ausserdem kann man einen unendlich lan- gen Bitstring dadurch beschreiben, dass man für jeden Index angibt, ob das Bit an diesem Index 1 oder 0 ist. Jeder Index ist eine Zahl i ∈ N. Ein Bit ist 1 oder 0, also ist ein Bit immer eine natürliche Zahl. Wir können also einen unendlich langen Bitstring x als eine Funktion beschreiben, die jedem Index i ∈ N das i-te Bit von x zuordnet. Nun müssen wir diese intuitive Idee noch formalisieren. 6 Beweis. Betrachte die Funktion f : {0, 1}∞ → S definiert durch f (x) = g, wobei g eine Funktion N → N ist, die durch g(n) = n-tes Bit von x definiert ist. Wir zeigen nun, dass f eine Injektion ist: Seien x, y ∈ {0, 1} ∞ mit x ̸= y beliebig. Sei i der Index des ersten Bits, an dem sich x und y unterscheiden. Ohne Verlust der Allgemeinheit sei das i-te Bit von x 1. Es folgt per Definition von f : f (x)(i) = 1 und f (y)(i) = 0, weil das i-te Bit von x 1 ist und das i-te Bit von y 0 ist. Wegen f (x)(i) ̸= f (y)(i) und weil f (x) und f (y) Funktionen sind, folgt f (x) ̸= f (y). Also haben wir gezeigt, dass f injektiv ist. Weil wir eine Injektion {0, 1} ∞ → S gefunden haben, gilt {0, 1}∞ ⪯ S. Da {0, 1}∞ überabzählbar ist, ist S überabzählbar. Ich habe in der Übungsstunde gemerkt, dass der Beweis nicht einfach zu verstehen ist. Das liegt vor allem daran, das darin viele verschiedenen Konzepte auf einmal vorkommen. Deshalb habe ich hier noch eine ausführliche Erklärung angefügt, die hoffentlich Klarheit schafft:) x und y sind in dem Beweis unendlich lange Bitstrings. Die unendlich lange Folge aus Nullen 00000 (...) ist zum Beispiel ein solcher unendlich langer Bit- string. f ist eine Funktion, die jedem unendlich langen Bitstring eine Funktion g : N → N zuordnet. Wir können also unendlich lange Bitstrings (z.B. x) in f einsetzen, so wie wir in die Funktion h(x) = x2 reelle Zahlen einsetzen können. Wenn wir x in f einsetzen wollen, schreiben wir f (x). Das Resultat, also f (x), ist dann eine Funktion von den natürlichen Zahlen in die natürlichen Zahlen. f haben wir in dem Beweis so definiert, dass f (x) eine Funktion von den natürli- chen Zahlen in die natürlichen Zahlen ist, die, wenn man i einsetzt, als Resultat das i-te Bit von x hat. Nun kann man in die Funktion f (x) einen Index i ein- setzen: f (x)(i) ist nach der Definition von f das i-te Bit von dem Bitstring x. Um zu zeigen, dass f injektiv ist, nehmen wir zwei verschiedene aber beliebige unendlich lange Bitstrings x und y. Nun müssen wir f (x) ̸= f (y) zeigen. Das ist genau die Definition der Injektivität: Wenn man zwei verschiedene Sachen in eine Funktion einsetzt, bekommt man zwei verschiedene raus. Wir nennen den Index der ersten Stelle, an der sich x und y unterscheiden, i. Diese Stelle muss es geben, weil wir x ̸= y angenommen haben. Weil sich x und y an der i-ten Stelle unterscheiden (in anderen Worten: Das i-te Bit von x ist ungleich dem i-ten Bit von y), f (x)(i) das i-te Bit von x ist und f (y)(i) das i-te Bit von y ist, folgt f (x)(i) ̸= f (y)(i). Weil sich die Funktionswerte von f (x) und f (y) unterscheiden, wenn man i einsetzt, sind f (x) und f (y) nicht die gleichen Funk- tionen. Also f (x) ̸= f (y), was zu zeigen war. Jetzt schreiben wir nur noch einen Antwortsatz (der bei allen Überabzählbarkeitsbeweisen gleich ist) und sind fer- tig. Falls es noch Fragen zu dem Beweis gibt, könnt ihr mir gerne eine E-Mail schrei- ben: leon.kolmanic@inf.ethz.ch 7","libVersion":"0.3.1","langs":""}