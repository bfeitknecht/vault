{"path":"sem2/DDCA/VRL/slides/DDCA-L04b-verilog-combinational.pdf","text":"C a r ne gi e M e l l on 1 D i g i t a l D e s i g n a nd C o m put e r A r c hi t e c t ur e M o ha m m a d S a dr o s a da t i F r a nk K . G ür k a y na k A d a p t e d f r o m D i g i t a l D e s i g n a n d C o m p u t e r A r c h i t e c t u r e , D a v i d M o n e y H a r r i s & S a r a h L . H a r r i s © 2 0 0 7 E l s e v i e r http:// safari.ethz.ch / ddca V e r i l o g fo r C o m b i n a t i o n a l C i r c u i t s C a r ne gi e M e l l on 2 Wh a t w ill w e lea r n ? ¢ In t r od u ct ion t o V e r ilog ¢ C o m b i n a t i o n a l L o gi c i n V e r i l o g ¢ St r u c t u r al Mo d e l i n g C a r ne gi e M e l l on 3 Ha r dw a r e D es c r ipt io n La ng ua g es ¢ I n t h e b e gi n n i n g H D L s w e r e d e v e l o p e d a s a ‘ sta n d a r d w a y’ o f d r a w i n g c i r c u i t s c h e m a t i c s . ¢ M o d e l e d t h e i n t e r f a c e o f c i r c u i t s , d e s c r i b e d h o w t h e y we r e c o nne c t e d ¢ Al l ow e d c on n e c t i on s b e t w e e n t h e s e m od u l e s ¢ S u p p o r t e d s o m e c o m m o n l o gi c f u n c t i o n s § AN D O R N O T X O R § M ul t i pl e x e r s C a r ne gi e M e l l on 4 C o n v e n i e n t W a y o f D r a w i n g S c h e m a t i c s C a r ne gi e M e l l on 5 C o n v e n i e n t W a y o f D r a w i n g S c h e m a t i c s ¢ It is s t a n d a r d § E v e r y bo dy w i l l i nt e r pr e t t he s c he m a t i c t he s a m e w a y ¢ It is n ot p r op r ie t a r y § H D L s a r e no t t o o l s pe c i f i c ¢ It is m a ch in e r e a d a b le § I t i s e a s i e r f o r c o m put e r s t o unde r s t a nd t he c i r c ui t ¢ O n l y l a t e r o n a d d i t i o n a l b e n e f i t s w e r e di s c o v e re d § S i m ul a t i o n a nd S y nt he s i s C a r ne gi e M e l l on 6 Two H a r dwa r e De s c r i pt i o n L a ngua ge s ¢ Ve r i l o g § de v e l o pe d i n 1 9 8 4 by G a t e w a y D e s i g n A ut o m a t i o n § be c a m e a n I E E E s t a nda r d ( 1 3 6 4 ) i n 1 9 9 5 § M o r e po pul a r i n U S ¢ VH D L ( V H S I C H a r d w a r e D e s c r i p t i o n L a n gu a ge ) § D e v e l o pe d i n 1 9 8 1 by t he D e pa r t m e nt o f D e f e ns e § B e c a m e a n I E E E s t a nda r d ( 1 0 7 6 ) i n 1 9 8 7 § M o r e po pul a r i n E ur o pe ¢ In t h is cou r s e w e w ill u s e V e r ilog C a r ne gi e M e l l on 7 D e fi n i n g a m o d u l e ¢ A m o d u l e i s t h e m a i n b u i l d i n g b l o c k i n V e r i l o g ¢ We f i r s t n e e d t o d e c l a r e : § N a m e o f t he m o dul e § T y pe s o f i t s c o nne c t i o ns ( i nput , o ut put ) § N a m e s o f i t s c o nne c t i o ns ab yc VerilogModule C a r ne gi e M e l l on 8 D e fi n i n g a m o d u l e module example (a, b, c, y); input a; input b; input c; output y; // here comes the circuit description endmodule ab yc VerilogModule C a r ne gi e M e l l on 9 A q u e s t i o n o f s t y l e module test ( a, b, y ); input a; input b; output y; endmodule module test ( input a, input b, output y ); endmodule Th e f o l l o wi n g t wo co d e s a r e i d e n t i ca l C a r ne gi e M e l l on 10 W h a t i f w e h a v e b u s s e s ? input [31:0] a; // a[31], a[30] .. a[0] output [15:8] b1; // b1[15], b1[14] .. b1[8] output [7:0] b2; // b2[7], b2[6] .. b1[0] input clk ; // single signal ¢ Yo u c an al s o d e f i n e m u l t i - bi t bus s e s . § [ r a ng e _ s t a r t : r a ng e _ e nd ] ¢ Ex a m p l e : C a r ne gi e M e l l on 11 Ba s i c S yn t a x // Single line comments start with a // /* Multiline comments are defined like this */ ¢ V e r i l o g i s c a s e s e n s i t i v e : § SomeName a nd somename a r e no t t he s a m e ! ¢ Na m e s c a n n o t s t a r t w i t h n u m b e r s : § 2good i s no t a v a l i d na m e ¢ W h i t e s p a c e i s i gn o r e d C a r ne gi e M e l l on 12 Go o d P r a ct i ce s ¢ D e v e l o p / u s e a c o n s i s t e n t n a m i n g s t yl e ¢ U s e M S B t o L S B o r d e r i n g f o r b u s s e s ( l i t t l e - en d i a n ) § T r y us i ng “ a[31:0] ” a nd no t “ a[0:31] ” ¢ De f i n e o n e m o d u l e p e r f i l e § M a k e s m a na g i ng y o ur de s i g n hi e r a r c hy e a s i e r ¢ Us e a f i l e n a m e t h a t e q u a l s m o d u l e n a m e § i . e . m o dul e T r y T hi s i s de f i ne d i n a f i l e c a l l e d T r y T hi s . v C a r ne gi e M e l l on 13 T h e r e a r e T w o M a i n S t y l e s o f H D L ¢ St r u c t u r al § D e s c r i be ho w m o dul e s a r e i nt e r c o nne c t e d § E a c h m o dul e c o nt a i ns o t he r m o dul e s ( i ns t a nc e s ) § … a nd i nt e r c o nne c t i o ns be t w e e n t he s e m o dul e s § D e s c r i be s a hi e r a r c hy ¢ Be h a v i o r a l § T he m o dul e bo dy c o nt a i ns f unc t i o na l de s c r i pt i o n o f t he c i r c ui t § C o nt a i ns l o g i c a l a nd m a t he m a t i c a l o pe r a t o r s ¢ Pra c t ic a l c irc uit s w o uld us e a c o mbina t io n o f bo t h C a r ne gi e M e l l on 14 St ru c t u ral H D L : I n s t an t i at i n g a M o d u l e C a r ne gi e M e l l on 15 St ru c t u ral H D L E xamp l e module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Mo d u l e D e f i n i t i o n s C a r ne gi e M e l l on 16 St ru c t u ral H D L E xamp l e module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Mo d u l e D e f i n i t i o n s C a r ne gi e M e l l on 17 St ru c t u ral H D L E xamp l e module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Wir e d e f init ions C a r ne gi e M e l l on 18 St ru c t u ral H D L E xamp l e module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; // instantiate small once small i_first ( .A(A), .B(SEL), .Y(n1) ); endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Ins t a nt ia t e f ir s t m od ule C a r ne gi e M e l l on 19 St ru c t u ral H D L E xamp l e module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; // instantiate small once small i_first ( .A(A), .B(SEL), .Y(n1) ); // instantiate small second time small i2 ( .A(n1), .B(C), .Y(Y) ); endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Ins t a nt ia t e s ec ond m od ule C a r ne gi e M e l l on 20 St ru c t u ral H D L E xamp l e module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; // alternative small i_first ( A, SEL, n1 ); /* Shorter instantiation, pin order very important */ // any pin order, safer choice small i2 ( .B(C), .Y(Y), .A(n1) ); endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Sh o r t In s t a n t ia t io n C a r ne gi e M e l l on 21 Wh a t H a p p en s w ith H D L c od e? ¢ A u t o m a t i c S yn t h e s i s § M o de r n t o o l s a r e a bl e t o m a p a be ha v i o r a l H D L c o de i nt o g a t e - l e v e l s c he m a t i c s § T he y c a n pe r f o r m m a ny o pt i m i z a t i o ns § … ho w e v e r t he y c a n no t g ua r a nt e e t ha t a s o l ut i o n i s o pt i m a l § M o s t c o m m o n w a y o f D i g i t a l D e s i g n t he s e da y s ¢ Si m u l at i o n § A l l o w s t he be ha v i o r o f t he c i r c ui t t o be v e r i f i e d w i t ho ut a c t ua l l y m a nuf a c t ur i ng t he c i r c ui t § S i m ul a t o r s c a n w o r k o n be ha v i o r a l o r g a t e - l e v e l s c he m a t i c s C a r ne gi e M e l l on 22 B e h a v i o r a l H D L : D e fi n i n g F u n c t i o n a l i t y module example (a, b , c , y ); input a; input b ; input c ; output y ; // here comes the circuit description assign y = ~ a & ~ b & ~ c | a & ~ b & ~ c | a & ~ b & c ; endmodule C a r ne gi e M e l l on 23 Be h a v i o r a l H D L : S yn t h e s i s R e s u l t s un5_y un8_y y yc b a C a r ne gi e M e l l on 24 Be h a v i o r a l H D L : S i m u l a t i n g t h e C i r c u i t C a r ne gi e M e l l on 25 Bi t w i s e O p e r a t o r s module gates( input [3:0] a, b, output [3:0] y1, y2, y3, y4, y5); /* Five different two - input logic gates acting on 4 bit busses */ assign y1 = a & b; // AND assign y2 = a | b; // OR assign y3 = a ^ b; // XOR assign y4 = ~ (a & b); // NAND assign y5 = ~ (a | b); // NOR endmodule C a r ne gi e M e l l on 26 Bi t w i s e O p e r a t o r s : S yn t h e s i s R e s u l t s C a r ne gi e M e l l on 27 Re d u c t i o n O p e rat o rs module and8( input [7:0] a, output y); assign y = & a; // & a is much easier to write than // assign y = a[7] & a[6] & a[5] & a[4] & // a[3] & a[2] & a[1] & a[0]; endmodule C a r ne gi e M e l l on 28 Re d u c t i o n O p e rat o rs : as s i g n y = &a; C a r ne gi e M e l l on 29 Co n d i t i o n al A s s i g n m e n t module mux2( input [3:0] d0, d1, input s, output [3:0] y); assign y = s ? d1 : d0; // if (s) then y=d1 else y=d0; endmodule ¢ ? : i s a l s o c a l l e d a t e r n a r y o p e r a t o r as i t o p e r at e s o n t h r e e in p u t s : § s § d1 § d0 . C a r ne gi e M e l l on 30 Co n d i t i o n al A s s i g n m e n t : y = s ? d 1 : d 0 ; C a r ne gi e M e l l on 31 Mo r e C o ndi t i o na l A s s i g nm e nt s module mux4( input [3:0] d0, d1, d2, d3 input [1:0] s, output [3:0] y); assign y = s[1] ? ( s[0] ? d3 : d2) : ( s[0] ? d1 : d0); // if (s1) then // if (s0) then y=d3 else y=d2 // else // if (s0) then y=d1 else y=d0 endmodule C a r ne gi e M e l l on 32 Ev e n M o r e C o n d i t i o n a l A s s i g n m e n t s module mux4( input [3:0] d0, d1, d2, d3 input [1:0] s, output [3:0] y); assign y = (s == 2 ’ b11) ? d3 : (s == 2 ’ b10) ? d2 : (s == 2 ’ b01) ? d1 : d0; // if (s = “ 11” ) then y= d3 // else if (s = “ 10” ) then y= d2 // else if (s = “ 01” ) then y= d1 // else y= d0 endmodule C a r ne gi e M e l l on 33 Ho w t o E x pr es s num ber s ? N ’ B xx 8 ’ b 0000_0001 ¢ ( N ) N u m b e r o f b i t s § E x pr e s s e s ho w m a ny bi t s w i l l be us e d t o s t o r e t he v a l ue ¢ ( B ) B as e § C a n be b ( bi na r y ) , h ( he x a de c i m a l ) , d ( de c i m a l ) , o ( o c t a l ) ¢ ( xx ) N u m b e r § T he v a l ue e x pr e s s e d i n ba s e , a pa r t f r o m num be r s i t c a n a l s o ha v e X a nd Z a s v a l ue s . § U nde r s c o r e _ c a n be us e d t o i m pr o v e r e a da bi l i t y C a r ne gi e M e l l on 34 Nu m b er R ep r esen ta tion in V er ilog Ve r i l o g St o r e d N u mb e r Ve r i l o g St o r e d N u mb e r 4 ’ b1 0 0 1 1001 4 ’ d5 0101 8 ’ b1 0 0 1 0000 1001 12 ’ hF A 3 1111 1010 0011 8 ’ b0 0 0 0 _ 1 0 0 1 0000 1001 8 ’ o1 2 00 001 010 8 ’ bx X 0 X 1 z Z 1 XX0 X 1 Z Z 1 4 ’ h7 0111 ‘ b0 1 0000 . . 0001 12 ’ h0 0000 0000 0000 C a r ne gi e M e l l on 35 W h a t h a v e s e e n s o fa r : ¢ D e s c r i b i n g s t r u c t u r a l h i e r a r c h y w i t h V e r i l o g § I ns t a nt i a t e m o dul e s i n a n o t he r m o dul e ¢ W r i t i n g s i m p l e l o gi c e q u a t i o n s § W e c a n w r i t e A N D , O R , X O R et c ¢ Mu l t i p l e x e r f u n c t i o n al i t y § I f … t he n … e l s e ¢ We c a n d e s c r i b e c o n s t a n t s ¢ Bu t t h e r e i s m o r e : C a r ne gi e M e l l on 36 P r e c e d e n c e o f o p e r a t i o n s i n V e r i l o g ~ NO T * , / , % m ul t , di v , m o d + , - a dd,s ub < < , > > s hi f t < < < , > > > a r i t hm e t i c s hi f t < , < = , > , > = c o m pa r i s o n = = , ! = e qua l , no t e qua l & , ~ & A N D , N A N D ^ , ~ ^ X O R , X N O R | , ~ | O R , N O R ?: t e r na r y o pe r a t o r Hi g he s t Lo w es t C a r ne gi e M e l l on 37 Ex a m p l e : C o m p a r i n g t w o n u m b e r s module MyXnor ( input a, b, output z); assign z = ~(a ^ b); //not XOR endmodule module MyAnd ( input a, b, output z); assign z = a & b; // AND endmodule An X N O R gat e An AN D gat e C a r ne gi e M e l l on 38 Ex a m p l e : C o m p a r i n g T w o N u m b e r s module compare ( input a0, a1, a2, a3, b0, b1, b2, b3, output eq ); wire c0, c1, c2, c3, c01, c23; MyXnor i0 (.A(a0), .B(b0), .Z(c0) ); // XNOR MyXnor i1 (.A(a1), .B(b1), .Z(c1) ); // XNOR MyXnor i2 (.A(a2), .B(b2), .Z(c2) ); // XNOR MyXnor i3 (.A(a3), .B(b3), .Z(c3) ); // XNOR MyAnd haha (.A(c0), .B(c1), .Z(c01) ); // AND MyAnd hoho (.A(c2), .B(c3), .Z(c23) ); // AND MyAnd bubu (.A(c01), .B(c23), .Z( eq ) ); // AND endmodule C a r ne gi e M e l l on 39 Ex a m p l e : C o m p a r i n g T w o N u m b e r s module compare ( input a0, a1, a2, a3, b0, b1, b2, b3, output eq ); wire c0, c1, c2, c3, c01, c23; MyXnor i0 (.A(a0), .B(b0), .Z(c0) ); // XNOR MyXnor i1 (.A(a1), .B(b1), .Z(c1) ); // XNOR MyXnor i2 (.A(a2), .B(b2), .Z(c2) ); // XNOR MyXnor i3 (.A(a3), .B(b3), .Z(c3) ); // XNOR assign c01 = c0 & c1; assign c23 = c2 & c3; assign eq = c01 & c23; endmodule C a r ne gi e M e l l on 40 Ex a m p l e : C o m p a r i n g T w o N u m b e r s module compare ( input a0, a1, a2, a3, b0, b1, b2, b3, output eq ); wire c0, c1, c2, c3; MyXnor i0 (.A(a0), .B(b0), .Z(c0) ); // XNOR MyXnor i1 (.A(a1), .B(b1), .Z(c1) ); // XNOR MyXnor i2 (.A(a2), .B(b2), .Z(c2) ); // XNOR MyXnor i3 (.A(a3), .B(b3), .Z(c3) ); // XNOR assign eq = c0 & c1 & c2 & c3; endmodule C a r ne gi e M e l l on 41 Ex a m p l e : C o m p a r i n g T w o N u m b e r s module compare ( input a0, a1, a2, a3, b0, b1, b2, b3, output eq ); wire [3:0] c; // bus definition MyXnor i0 (.A(a0), .B(b0), .Z(c[0]) ); // XNOR MyXnor i1 (.A(a1), .B(b1), .Z(c[1]) ); // XNOR MyXnor i2 (.A(a2), .B(b2), .Z(c[2]) ); // XNOR MyXnor i3 (.A(a3), .B(b3), .Z(c[3]) ); // XNOR assign eq = & c; // short format endmodule C a r ne gi e M e l l on 42 Ex a m p l e : C o m p a r i n g T w o N u m b e r s module compare ( input [3:0] a, input [3:0] b, output eq ); wire [3:0] c; // bus definition MyXnor i0 (.A(a[0]), .B(b[0]), .Z(c[0]) ); // XNOR MyXnor i1 (.A(a[1]), .B(b[1]), .Z(c[1]) ); // XNOR MyXnor i2 (.A(a[2]), .B(b[2]), .Z(c[2]) ); // XNOR MyXnor i3 (.A(a[3]), .B(b[3]), .Z(c[3]) ); // XNOR assign eq = & c; // short format endmodule C a r ne gi e M e l l on 43 Ex a m p l e : C o m p a r i n g T w o N u m b e r s module compare ( input [3:0] a, input [3:0] b, output eq ); wire [3:0] c; // bus definition assign c = ~(a ^ b); // XNOR assign eq = & c; // short format endmodule C a r ne gi e M e l l on 44 Ex a m p l e : C o m p a r i n g T w o N u m b e r s module compare ( input [3:0] a, input [3:0] b, output eq ); assign eq = (a == b) ? 1 : 0; // really short endmodule C a r ne gi e M e l l on 45 W h a t i s t h e B E S T w a y o f w r i t i n g V e r i l o g ¢ Q u i t e s i m p l y IT D O E S N O T E X IS T ! ¢ C o d e s h o u l d b e e a s y t o u n d e r s t a n d § S o m e t i m e s l o ng e r c o de i s e a s i e r t o c o m pr e he nd ¢ H i e r a r c h y i s v e r y u s e f u l § I n t he pr e v i o us e x a m pl e i t di d no t l o o k l i k e t ha t , but f o r l a r g e r de s i g ns i t i s i ndi s pe ns i bl e ¢ T r y t o s t a y c l o s e r t o h a r d w a r e § A f t e r a l l t he g o a l i s t o de s i g n ha r dw a r e C a r ne gi e M e l l on 46 Parame t e ri ze d M o d u l e s module mux2 #( parameter width = 8) // name and default value ( input [ width - 1:0] d0, d1, input s, output [ width - 1:0] y); assign y = s ? d1 : d0; endmodule ¢ We c a n p a s s p a r a m e t e r s t o a m o d u l e C a r ne gi e M e l l on 47 Parame t e ri ze d M o d u l e s : I n s t an t i at i n g // If parameter is not given, default is assumed (here 8) mux2 i_mux (d0, d1, s, out); // The same module with 12 - bit bus width: mux2 #(12) i_mux_b (d0, d1, s, out); // More verbose version: mux2 #(.width(12)) i_mux_b (.d0(d0), .d1(d1), .s(s), .out(out)); module mux2 #( parameter width = 8) // name and default value ( input [ width - 1:0] d0, d1, input s, output [ width - 1:0] y); assign y = s ? d1 : d0; endmodule C a r ne gi e M e l l on 48 Ma ni pul a t i ng B i t s // You can assign partial busses wire [15:0] longbus ; wire [7:0] shortbus ; assign shortbus = longbus [12:5]; // Concatenating is by {} assign y = {a[2],a[1],a[0],a[0]}; // Possible to define multiple copies assign x = {a[0], a[0], a[0], a[0]} assign y = { 4{a[0]} } C a r ne gi e M e l l on 49 Z fl o a t i n g o u t p u t module tristate ( input [3:0] a, input en, output [3:0] y); assign y = en ? a : 4'bz; endmodule y_1[3:0] y[3:0] [3:0] en a[3:0] [3:0] [3:0][3:0] C a r ne gi e M e l l on 50 T r u t h T a b l e fo r A N D w i t h Z a n d X & A 0 1 Z X B 0 0 0 0 0 1 0 1 X X Z 0 X X X X 0 X X X C a r ne gi e M e l l on 51 Wh a t A b ou t T im in g ? ‘ timescale 1ns/1ps module simple (input a, output z1, z2); assign #5 z1 = ~a; // inverted output after 5ns assign #9 z2 = a; // output after 9ns endmodule ¢ I t i s p o s s i b l e t o d e f i n e t i m i n g r e l a t i o n s i n V e r i l o g § T he s e a r e ON L Y f o r S i m ul a t i o n § T he y CA N N O T be s y nt he s i z e d § T he y a r e us e d f o r m o de l i ng de l a y s i n s i m ul a t i o n C a r ne gi e M e l l on 52 Nex t S tep s ¢ We h a v e s e e n a n o v e r v i e w o f V e r i l o g ¢ Di s c u s s e d b e h a v i o r a l a n d s t r u c t u r a l m o d e l i n g ¢ S h o w e d c o m b i n a t i o n a l l o gi c c o n s t r u c t s S t i l l t o c o m e : ( l a t e r ) ¢ Se q u e n t i al c i r c u i t d e s c r i p t i o n i n V e r i l o g ¢ D e v e l o p i n g testb en c h es fo r si m u l a ti o n","libVersion":"0.3.1","langs":""}