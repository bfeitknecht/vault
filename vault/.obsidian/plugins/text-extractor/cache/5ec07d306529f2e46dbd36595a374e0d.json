{"path":"sem2/PProg/VRL/extra/benji/PProg-07-benji.pdf","text":"Parallel Programming Exercise Session 7 Spring 2024 Plan für heute • Nachbesprechung Übung 6 • Theorie Recap • Pause • Vorbesprechung Übung 7 • Teil 1 Rückblick • Quiz Nachbesprechung Übung 6 3 Merge Sort Discussion of solution Longest Sequence Given a sequence of numbers: [1, 9, 4, 3, 3, 8, 7, 7, 7, 0] find the longest sequence of the same consecutive number public class LongestSequenceMulti extends RecursiveTask<Sequence> { protected Sequence compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // return the longest result } } } Outline almost as before, except: Longest SequenceLongest Sequence public class LongestSequenceMulti extends RecursiveTask<Sequence> { protected Sequence compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // check that result is not in between the pieces // return the longest result } } } Outline almost as before, except: Longest Sequence public class LongestSequenceMulti extends RecursiveTask<Sequence> { protected Sequence compute() { if (// work is small) // do the work directly else { // split work into pieces // invoke the pieces and wait for the results // check that result is not in between the pieces // return the longest result } } } Outline almost as before, except: [1, 2, 3, 3, 4, 1] [1, 2, 3] [3, 4, 1] Longest Sequence Discussion of solution Lecture Recap public class Counter { private int value; // returns a unique value public int getNext() { return value++; } } How to implement a thread safe Counter? Thread Safe CounterThread Safe Counter public class AtomicCounter { private AtomicInteger value; public int getNext() { return value.incrementAndGet(); } } public class SyncCounter { private int value; public synchronized int getNext() { return value++; } } public class LockCounter { private int value; private Lock = new ReentrantLock(); public int getNext() { lock.lock(); try { return value++; } finally { lock.unlock() } } } How to implement a thread safe Counter? essentials Thread Safe Counter public class AtomicCounter { private AtomicInteger value; public int getNext() { return value.incrementAndGet(); } } public class SyncCounter { private int value; public synchronized int getNext() { return value++; } } public class LockCounter { private int value; private Lock = new ReentrantLock(); public int getNext() { lock.lock(); try { return value++; } finally { lock.unlock() } } } What is the difference between synchronized and a Lock? essentials Java: The synchronized keyword Synchronization is built around an internal entity known as the intrinsic lock or monitor lock Every intrinsic lock has an object (or class) associated with it A thread that needs exclusive access to an object’s field has to acquire the object’s intrinsic lock before accessing them essentials java.util.concurrent.Lock Interface More low-level primitive than synchronized. Clients need to implement: lock(): Acquires the lock, blocks until it is acquired trylock(): Acquire lock only if its lock is free when function is called unlock(): Release the lock Allows more flexible structuring than synchronized blocks What does it mean to be more flexible? Why is this useful? essentials Lock Flexibility A.lock(); B.lock(); B.unlock(); A.unlock(); synchronized (A) { synchronized (B) { } } Synchronized forces all lock acquisition and release to occur in a block-structured way A.lock(); B.lock(); A.unlock(); B.unlock(); The following lock order cannot be expressed using synchronized blocks essentials Lock Flexibility A.lock(); B.lock(); B.unlock(); A.unlock(); synchronized (A) { synchronized (B) { } } Synchronized forces all lock acquisition and release to occur in a block-structured way A.lock(); B.lock(); A.unlock(); B.unlock(); The following lock order cannot be expressed using synchronized blocks As we will see later in the course, such order is useful for implementing concurred data structures and referred to as “hand-over-hand” locking (or “chain-locking”) essentials Lock Flexibility Consider a list of locks that you should acquire public int getNext(List<Lock> locks) { // acquire all locks // critical section // release all locks } Can this be achieved using synchronized? essentials Lock Flexibility Is the Lock acquired? Is the Lock acquired by current thread? Try acquire the Lock without blocking lock.isLocked() lock.isHeldByCurrentThread() lock.tryLock() https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html essentials Implementing Classes of java.util.concurrent.Lock ReentrantLock ReentrantReadWriteLock.ReadLock ReentrantReadWriteLock.WriteLock https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/locks/Lock.html Readers/Writers Lock will be covered in detail in 3 weeks details Basic Synchronization Rule Access to shared and mutable state needs to be always protected! essentials Synchronization Issues Data Race: ?? Synchronization Issues Data Race: A program has a data race if, during any possible execution, a memory location could be written from one thread, while concurrently being read or written from another thread. essentials Synchronization Issues Data Race: A program has a data race if, during any possible execution, a memory location could be written from one thread, while concurrently being read or written from another thread. Deadlock: ?? Synchronization Issues Data Race: A program has a data race if, during any possible execution, a memory location could be written from one thread, while concurrently being read or written from another thread. Deadlock: Circular waiting/blocking (no instructions are executed/CPU time is used) between threads, so that the system (union of all threads) cannot make any progress anymore. essentials Quiz: What is wrong with this code? void exchangeSecret(Person a, Person b) { a.getLock().lock(); b.getLock().lock(); Secret s = a.getSecret(); b.setSecret(s); a.getLock().unlock(); b.getLock().unlock() } public class Person { private ReentrantLock mLock = new ReentrantLock(); private String mName; public ReentrantLock getLock() { return mLock; } ... } Quiz: What is wrong with this code? void exchangeSecret(Person a, Person b) { a.getLock().lock(); b.getLock().lock(); Secret s = a.getSecret(); b.setSecret(s); a.getLock().unlock(); b.getLock().unlock() } public class Person { private ReentrantLock mLock = new ReentrantLock(); private String mName; public ReentrantLock getLock() { return mLock; } ... } Thread 1: exchangeSecret(p1, p2) Thread 2: exchangeSecret(p2, p1) Deadlock essentials Possible solution void exchangeSecret(Person a, Person b) { ReentrantLock first, second; if (a.getName().compareTo(b.getName()) < 0) { first = a.getLock(); second = b.getLock(); } else if (a.getName().compareTo(b.getName()) > 0) { first = b.getLock(); second = a.getLock(); } else { throw new UnsupportedOperationException(); } first.lock(); second.lock(); Secret s = a.getSecret(); b.setSecret(s); first.unlock(); second.unlock(); } Always acquire and release the Locks in the same order essentials Deadlocks and Race conditions Not easy to spot Hard to debug ➔ Might happen only very rarely ➔ Testing usually not good enough Reasoning about code is required Lesson learned: Need to be careful when programming with locks details Pre-Discussion Exercise 7 Exercise 7 Banking System – Multi-Threaded Implementation – Coding exercise: Use synchronized and/or Locks − Might have to make additions to existing classes – Reason about Performance – Reason about Deadlocks – Run Tests Multi-threaded Implementation Task 1 – Problem Identification: The methods of the classes Account and BankingSystem must be thread-safe. You should understand why the current implementation does not work for more than one thread. Thread-Safe – transferMoney() Task 2 – Synchronized: A simple solution to make the transferMoney() thread-safe is to use the synchronized keyword: public synchronized boolean transferMoney(…) Even though the code works as expected, the performance is poor. The performance of the multi-threaded implementation is worse than the single-threaded. Why does this happen? essentials Performance of transferMoney() Task 3 – Locking: Since the solution with the synchronized keyword does not perform well, you should find a better strategy to achieve the thread-safe implementation. ● Does your proposed solution work if a transaction happens from and to the same account? ● How do you know that your proposed solution does not suffer from deadlocks? essentials ThreadSafe - sumAccounts() Task 4 – Summing Up With a fine-grained synchronization on the transfer method, the method sumAccounts() may return incorrect results when a transaction takes place at the same time. ● Explain why the current implementation of the sumAccounts() method is not thread-safe any more. ● You should provide a thread-safe implementation. ● Is there any way to parallelize this method? essentials Testing You should run the provided tests for your implementation. If the test succeeds, your code is not necessarily correct. It is hard to reproduce a bad interleaving. 37 Old Exam Task (FS 2023) essentials 38 Old Exam Task (FS 2023) essentials Evaluation Please fill in the evaluation (~5min) It is anonymous (you don’t need to be logged in, no PII is stored) It helps us improving the exercise sessions https://docs.google.com/forms/d/e/1FAIpQLSdu HASKhycrs-Ag5CO0zH9srw0pnE565073UAFlp6zJ MCTIWw/viewform Teil 1 Rückblick Teil 1 Rückblick Multithreading Threads in Java Bad Interleavings Synchronization Wait and Notify Concurrency vs parallelism Pipelining ILP + Loop unrolling Amdahl und Gustafson Divide and Conquer, ForkJoin Task graphs Locks https://quizizz.com/admin/quiz/62266270c25f5d001e458bb5 Replace link with link to quiz","libVersion":"0.3.1","langs":""}