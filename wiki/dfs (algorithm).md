
The **DFS** [[algorithm]] is a procedure to explore a graph $G = (V, E)$, going as far as possible before considering other paths. It is very easily implemented recursively, an iterative alternative requires a [[stack (data structure)]]. It's runtime is in $O(|V| + |E|)$, since every vertex is visited once and (in the worst case) every edge is traversed once.

An arbitrary graph $G = (v, E)$ has a **topological sorting** if and only if it's a [[directed acyclic graph]]. This can be computed by the reverse `post` order generated by `dfs(v)` where $v \in V$ is a source i.e. $\deg_{\text{in}}(v) = 0$. For an edge $(u, v) = e \in E$, `pre[u] > pre[v] && post[u] < post[v]` if and only if $e$ is a back edge. The same applies for the converse, `pre[u] < pre[v] && post[u] > post[v]` if and only if $e$ is a forward edge.

```
let k = 0
let pre = []
let post = []

function dfs(u)
    pre[u] = k++        # visit u: pre order
    u.visited = true
    for v adjacent to u
        if v is not visited then
            dfs(v)
        end
    end
    post[u] = k++        # leave u: post order
end
```
