{"path":"sem3/A&D/VRL/extra/lecture-notes/A&D-notes-v04.pdf","text":"SUCHENUNDSORTIEREN-su.de : Beispiel : Finde die Prüfung vo n Ma ria Müller in einem Stapel au s 600 Prüfungen . Problem ( Suche) : Input : Ein ArrayA [ 1 . . . n ] vo n Zahlen und ein Element b. Output : Index K mit ASK ] - _ er oder„ nicht gefunden \" Fa llt : A nicht sortiert •; Äh = AH . . . n ] Array if Al i ] = b : retumirr tum „ nicht gefunden \" Laufzeit 0 (n ) Geht es besser ? NEIN , denn wir müssen jedes Element vo n A- anschauen , falls b nicht vorkommt . It al : A sortiert , 1- [ 1) ≤ Au s ≤ . _ . ≤ A [ n ] m ftp.othmussi.Bin-ouhe-L-EEHAEE-I Binary Search (A , b) N für sortiertes A b- 1, er ← n N ASK .ir ] gibt den Bereich an , indem wir noch suchen müssen while l ≤ r do me - CE I N l . . . I , auch floorl . . . ) geschrieben : abrunden ifb = 1- [ mit : re tte n m if b < 1- [ mit : r ← m - 1 else : l ← m it re tu m „ nicht gefunden \" Laufzeit : TU ) = c Konstant (Wort - und 1-( ng ≤ T ( %) + d , d Konstant ↑ stillschweigend benutzt : Laufzeit wird höchstens grösser für längere Arrays. Behauptung : Tln ) ≤ ct d - login ( n --2 \" ) Beweis > Induktion ( Übung) → Tcm ) ≤ Oclognl Geht es besser ? NEIN ! ( Wir nehmen hieran , dass die Suche du rch Vergleiche ausgeführt wird) Beweis : Betrachte einen beliebigen Iuchalgorithmus als Entscheidungsbaum „ informationsthooretischer Beweis \" Knoten : Vergleiche 2-B.ie b<A[5 v0 Tiefe : beliebige Berechnungen Kneten zwischen Knoten 1¥ A4P t b= Tittel : YES ↓ ◦ ≤ Zuraten YES ↓ V0 ④ j : Tiefe 2 ≤ 47inchEE : ; ; / retourniert : gefunden \" i returns mtum① ↑ Tiefen itllen -11 möglichen Owttpuh müssen ≤ Hitm an → # Knoten ≥ n -11 vorkommen . Am ahl Vergleiche im want on e = Tiefe h Ein Baum der Tiefe h hat höchstens 1+2+4 + . . + 2h = 2h\" - 1 ≤ 2h \" Knoten ( genauere Rechnung : ≤ 2h irrtum \" - Knoten Daher gilt : mit ≤ Ansahl Knoten ≤ 2 \" \" , how h ≥ login + 1) - 1 → Wort - on e - Laufzeit ≥ h ≥ login + 1) - 1- =D ( lag n ) . ☒ Sortieren- Suche ist viel schneller auf sortierten Daten Wie sortieren wir Daten effizient ? Problemckrtierenk.tn mit : ein Array A vo n n Zahlen Output : eine Permutation ( Unordnung) vo n A , die aufsteigend sortiert ist : AK ] ≤ AN ] ≤ . . ≤ AN Elementare Operationen : - Vergleiche - Vertauschungen AGorithmus-Priifekrtiertha.tnsotedc t) forint .in - I if 1- [ i ] > 1-[ i-iifretumfaheretwmt.me Laufzeit 0cm ) AGorithmus%Babbles-Bubblesotltlforj-1.fr notwendig : ein einzelner Durchgang reicht nich t ( siehe Beispiel) fe ri-1.in - I if 1- [ i ] > 1- [ im ] tausche Ali ] und Ali -11] j :| f- 2 f- 3 f- 4 Beispiel : 5-3714 3514 7 31457 13457 35-714 3-5147 -13457 1-3457 35 7-14 3-15-47 15457 13-457 35 171 3145 7 134-57 134-57 35 1 4 7 314-57 1345-7 13457 Laufzeit : -0cm) Vergleiche Oli ) Vertauschungen Wie können wir beweisen /einsehen , dass Bubblesat korrekt ist ? Idee : Finde geeignete Invariante und beweise sie mit- Induktion . Invariante Il j ) : Nach j Durchgängen befinden sich die j grössten Elemente am korrekten Or t Beweis : Induktion ( Übung) Aus Ilm ) folgt : Nach n Durchläufen sind allen Elemente korrekt . Vonderhvariamtezumvtlgorithmus-B.it reichte dieselbe Invariante Icj ) wie oben . GegebenIlj - D, können wir I. 4) mit weniger Aufwand erreichen ? Mit : FIETE:÷ ü:p \" Element Idee : Finde grösstes Element in AK . . . n -ji ] und tausche es mit A [ n - j + it Algorithmentheorie braucht n - j ≤ n µ j = 1 . . . n ✗Alles ab A [njtz ] schon somit Vergleiche K ← Index des Maximums in A [ 1 . . . n - j +1K tausche ALK ] mit A. In - j +1 ] Beispiel : 53714N Il o ) 53 4 117 ICH7-3 1 3 415 7 - I (2 ) 1 314 5 7 15 45 z I (3) I (4) 3 457 I (5) sortiert Laufzeit : 0C n ' ) Vergleiche 0cm ) Vertauschungen ← besser als Bubblesort- Andere Invariante : I ( j ) = 1- [ 1 . . . j ] ist sortiert ( enthält aber nicht garantiert die richtigen Elemente) Array : AH N unsortierter Teil 1 Wenn Icj ) gilt , wie erhalten wir Icj + 1) ? → Setze A- [ j +1 ] an korrekten Stelle in All ] , → AIJ] ein Beispiel . 112 7 9 141 8 351 → 11 2 üT9 18 35 1 AGorithmvn3vtmlrtimsot-geht.mil binärer Suche Insertion Sort ( A ) in Zeit Ocloglj - N for j-2.in/lAE1...j-BschonsortiedFimdeStellek,andieAIjIin-14 . itgehört) K←j , falls AIjt-maxIAHI-yt.li ] } somtk-kleimtnhdexkmitaljk-1.lk ' ) ✗← Alj ] ✗ merke 1- [ j ] , du es gleich überschrieben wird verschiebe AIK . . - j - 1) nach -1111+1 . . . j ][ AU F ✗ aufwendig, braucht j - K Operationen ( wortweise :[ 1) Beispiels 51374 1 Im 3*51741 IC H 35%-141 I (3) 345^711 IC H ) ÖT V Ics ) sortiert Laufzeit . Vergleiche ≤ F.iilogl;D ≤ E. c. logn ≤ Ocrilogn) Vertauschungen ≤ E. # OCNY Bis jetzt : Alle Algorithmen haben Laufzeit Ur i) Selection Sat : 0cm) Vertauschungen Insertion Sat : Ocnbgn ) Vergleiche Geht es besser ? Können wir das beste vo n beidem haben ? Algorithmentheorie Idee : Divide - and - Conquer ( Teile - und - Herrsche ) A TI FFI N ☒ÄÄ¥¥ • Hä r te \" :L.AT?j:::I! \" (kleinste ) übrige Element in einer Hilfsarray MergeSort ( A , lir ) ✗ sortiert den Bereich Al l . . - r ] if he r m ← L LE ] MergeSort ( A , ein ) N sortiere linke Hälfte Merge Sort ( A , mit, r ) \" sortiere rechte Hälfte Merge ( A , l , mir) II verschmelzen beide Hälften Merge ( A, l , mir ) B ← no w Array mit r - lt 1- Zellen ✗ selbe Grüne wie Al l . . - it it l ✗ erstes unbenutztes Element in linker Hälfte j ← mit Nantes unbenutztes Element in rechter Hälfte k ← 1- N nächste Position in B while i ≤ m an d j ≤ r \" beide Hälften noch nicht ausgeschöpft if Al i ] < AIJ ] BIK ] ← 1-[ i ] i. ← it I K ← K -11 ehe BEK ] ← 1-[ j ] j ← j -11 K ← KM übernimm Rest links bow . rechts 11 wenn die andere Hälfte ausgeschöpft ist kopiere B nach Al l . . . r ] Beispiel : 9732111846 f 97 13 2 18446f 9117 3112 1¥ ¥6 Gesamtarbüt § ↓ ≥ 5 ! Ily ¥ , pro Level : }≤ n Vergleiche 4g ¥, tu t 18 ! 2h Kopier - Ops 146g } ≤ \" Vergleiche{ ↓ In Kopier -0ps 237 9 { ≤ n Vergleiche→ 2m Kopien -0ps12346¥89 = jede Zahlwird vo n Anachl} insgesamt Ocnlogn ) , und anschliessend duesolkyn)Levelsgibtwieder zurück kopiert Alternative Bestimmung der Laufzeit : wn =Ü ≤ 2. Tl) -1d m kehrten 1- ( n ) ≤ din.logzn-c.nl Übung!) ≤ Ocnlogn) Beste Laufzeit bisher : Ocnloyn) Nachteil : braucht Zmatzamay ( nicht „ in place \" )","libVersion":"0.3.2","langs":""}