{"path":"AuD/UE/s/AuD-u09-s.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 20 November 2023 Johannes Lengler, David Steurer Lucas Slot, Manuel Wiedmer, Hongjie Chen, Ding Jingqiu Algorithms & Data Structures Exercise sheet 9 HS 23 The solutions for this sheet are submitted at the beginning of the exercise class on 27 November 2023. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. Exercise 9.1 Transitive graphs. Let G = (V, E) be an undirected graph. We say that G is • transitive when, for any two edges {u, v} and {v, w} in E, the edge {u, w} is also in E; • complete when its set of edges is {{u, v} | u, v ∈ V, u ̸= v}; • the disjoint union of G1 = (V1, E1), . . . , Gk = (Vk, Ek) iff V = V1∪· · ·∪Vk, E = E1∪· · ·∪Ek, and the (Vi)1≤i≤k are pairwise disjoint. Show that a undirected graph G is transitive if, and only if, it is a disjoint union of complete graphs. Solution: We first show that disjoint unions of complete graphs are transitive (⇐), and then that any transitive graph is a disjoint union of complete graphs (⇒). ⇐: Let G = (V, E) be a disjoint union of complete graphs G1 = (V1, E1), . . . , Gk = (Vk, Ek). Let {u, v}, {v, w} ∈ E. Since G is a disjoint union, there exists i ∈ {1..k} such that v ∈ Vi, {u, v} ∈ Ei, and {v, w} ∈ Ei. Since Ei ⊆ Vi × Vi, we get u ∈ Vi and w ∈ Vi. From the assumption that Gi is complete, we finally get {u, w} ∈ Ei ⊆ E. ⇒: Let G = (V, E) be a transitive graph. We can decompose G into its connected components G1 = (V1, E1), . . . , Gk = (Vk, Ek). Clearly, G is the disjoint union of its connected components. Let us now show that each connected component is complete. Let i ∈ {1..k}. Consider u, v ∈ Vi with u ̸= v. As u and v are in the same connected component of G, there exists a path u = w1 → w2 → · · · → wp = v from u to v in Gi. We will now show by induction on j ∈ {2, . . . , p}: P (j): “the edge {u, wj} is in Ei.” Base case: j = 2. As u = w1, . . . , wp forms a path in Gi, we have {u, w2} = {w1, w2} ∈ Ei, which immediately yields P (2). Induction step: Let j ∈ {2, . . . , p − 1} such that P (j) holds. This means that we have an edge {u, wj} ∈ Ei. Now, as w1, . . . , wp is a path in Gi, we also have an edge {wj, wj+1} ∈ Ei. Using the transitive property of G, we obtain {u, wj+1} ∈ E, and since G is a disjoint union, we also have {u, wj+1} ∈ Ei. This shows P (j + 1). Conclusion: P (j) holds for all j ∈ {2, . . . , p}. For j = p, we obtain P (p): “the edge {u, wp} is in Ei”. As wp = v, we get {u, v} ∈ Ei. Hence Gi is complete, which concludes the proof. Exercise 9.2 Short statements about graphs (cont’d) (1 point). In the following, let G = (V, E) be a directed graph. For each of the following statements, decide whether the statement is true or false. If the statement is true, provide a proof; if it is false, provide a counterexample. (a) If for every vertex v ∈ V its in-degree degin(v) is even, then |E| is even. Solution: This statement is true. The following equality holds ∑ v∈V degin(v) = |E| since on both sides every edge is counted exactly once. Hence, if all terms on the left side are even, then also |E| is even. (b) For a longest directed path P : v0, . . . , vℓ in G, the endpoint has to be a sink. Solution: This statement is false. Consider the graph with three vertices V = {v1, v2, v3} and the following edges E = {(v1, v2), (v2, v3), (v3, v1)}. A longest directed path is for example v1, v2, v3. However, v3 is not a sink since it has the outgoing edge (v3, v1). Remark: If the graph is assumed to have no directed cycles, i.e. we have a directed acyclic graph, then the statement holds as was used and proven in the lecture. (c) The following graph has a topological sorting. If so, give a topological sorting; if not, prove why no topological sorting can exist. A B C D E F G H I Solution: This statement is true. We construct a topological sorting with the strategy that was discussed in the lecture, that is, we find a sink v in the graph, remove v (and all incident edges) from the graph and iterate. Since the 2 graph is small, we find a sink “by hand”, but we could as well do it with the algorithm that was discussed in the lecture. All graphs that occur in the process are described below, where the cur- rect sinks are marked in blue. Note that there are different possible topological sortings, the one described here is just an example. In the first graph the vertex “B” is a sink, so “B” appears last in our topological sorting. Now, there are several choices, all the vertices “A”, “C” and “I” are sinks. We can add all these three vertices into our sorting, so a possible current end of the sorting is (A,C,I,B). After removing these vertices, the only sink is “D”, leading to the current end of the sorting (D,A,C,I,B). In the next graph, only “H” is a sink, leading to (H,D,A,C,I,B). In the last graph, both “F” and “G” are sinks. After removing these two vertices only the vertex “E” remains, so we get for example the following topological sorting (E,F,G,H,D,A,C,I,B). One can verify in the original graph that this is indeed a topological sorting. This is however not strictly necessary since we know from the lecture that the algorithm we executed is correct. A B C D E F G H I A C D E F G H I D E F G H E F G H E F G Guidelines for correction: For awarding the bonus points, each subexercise should be split into two parts, namely one part is giving the correct answer and the other part is giving a correct proof or counterexample. If at least 3 parts are solved correctly, 1/2 points should be awarded. If all 6 parts are solved correctly, 1 point should be awarded. Exercise 9.3 Data structures for graphs. Consider three types of data structures for storing an undirected graph G with n vertices and m edges: 1) Adjacency matrix. 2) Adjacency lists: 3 11111222233444455566 3) Adjacency lists, and additionally we store the degree of each node, and there are pointers between the two occurences of each edge. (An edge appears in the adjacency list of each endpoint). 11111222233455544466deg: 4deg: 3deg: 1deg: 3deg: 2deg: 1 For each of the above data structures, what is the required memory (in Θ-Notation)? Solution: Θ(n2) for adjacency matrix, Θ(n + m) for adjacency list and improved adjacency list. Which runtime (worst case, in Θ-Notation) do we have for the following queries? Give your answer depending on n, m, and/or deg(u) and deg(v) (if applicable). (a) Input: A vertex v ∈ V . Find deg(v). Solution: Θ(n) in adjacency matrix, Θ(1 + deg(v)) in adjacency list, Θ(1) in improved adjacency list. (b) Input: A vertex v ∈ V . Find a neighbor of v (if a neighbor exists). Solution: Θ(n) in adjacency matrix, Θ(1) in adjacency list and in improved adjacency list. (c) Input: Two vertices u, v ∈ V . Decide whether u and v are adjacent. Solution: Θ(1) in adjacency matrix, Θ(1+min{deg(v), deg(u)}) in adjacency list and in improved adjacency list. (d) Input: Two adjacent vertices u, v ∈ V . Delete the edge e = {u, v} from the graph. Solution: Θ(1) in adjacency matrix, Θ(deg(v) + deg(u)) in adjacency list and Θ(min{deg(v), deg(u)}) in improved adjacency list. (e) Input: A vertex u ∈ V . Find a neighbor v ∈ V of u and delete the edge {u, v} from the graph. Solution: 4 Θ(n) in the adjacency matrix (Θ(n) for finding a neighbor and Θ(1) for the edge deletion). Θ(1+ max w:{u,w}∈E deg(w)) for the adjacency list (Θ(1) for finding a neighbor and Θ( max w:{u,w}∈E deg(w)) for the edge deletion). Θ(1) for the improved adjacency list (Θ(1) for finding a neighbor and Θ(1) for the edge deletion). (f) Input: Two vertices u, v ∈ V with u ̸= v. Insert an edge {u, v} into the graph if it does not exist yet. Otherwise do nothing. Solution: Θ(1) in adjacency matrix, Θ(1+min{deg(v), deg(u)}) in adjacency list and in improved adjacency list. (g) Input: A vertex v ∈ V . Delete v and all incident edges from the graph. Solution: Θ(n2) in adjacency matrix, Θ(n + m) in adjacency list and Θ(n) in improved adjacency list. For the last two queries, describe your algorithm. Solution: Query (f): We check whether the edge {u, v} does not exist. In adjacency matrix this information is directly stored in the u-v-entry. For adjacency lists we iterate over the neighbors of u and the neighbors of v in parallel and stop either when one of the lists is traversed or when we find v among the neighbors of u or when we find u among the neighbors of v. If we didn’t find this edge, we add it: in the adjacency matrix we just fill two entries with ones, in the adjacency lists we add nodes to two lists that correspond to u and v. In the improved adjacency lists, we also need to set pointers between those two nodes, and we need to increase the degree for u and v by one. Query (g): In the adjacency matrix we copy the complete matrix, but leave out the row and column that correspond to v. This takes time Θ(n2). There is an alternative solution if we are allowed to rename vertices: In this case we can just rename the vertex n as v, and copy the n-th row and column into the v-th row and column. Then the (n − 1) × (n − 1) submatrix of the first n − 1 rows and columns will be the new adjacancy matrix. Then the runtime is Θ(n). Whether it is allowed to rename vertices depends on the context. For example, this is not possible if other programs use the same graph. In the adjacency lists we remove v from every list of neighbors of every vertex (it takes time Θ(n + m)) and then we remove a list that corresponds to v from the array of lists (it takes time Θ(n)). In the improved adjacency lists we iterate over the neighbors of v and for every neighbor u we remove v from the list of neighbors of u (notice that for each u we can do it in Θ(1) since we have a pointer between two occurences of {u, v}) and decrease deg(u) by one. Then we remove the list that corresponds to v from the array of lists (it takes time Θ(n)). Exercise 9.4 Number of paths in DAGs (1 point). Let G = (V, E) be a directed graph without directed cycles1 (i.e., a directed acyclic graph or short DAG). Assume that V = {v1, . . . , vn} (for n = |V | ∈ N). Further assume that v1 is a source and vn is a sink. The goal of this exercise is to find the number of paths from v1 to vn. 1A directed cycle is a closed directed walk of length at least 2 for which all vertices are pairwise distinct except the endpoints. 5 (a) Prove that there exists a topological sorting of G that has v1 as first and vn as last vertex. Solution: Define the graph G′ as the graph G without v1 and vn (and all incident edges). This graph is still acyclic, so we know from the lecture that it has a topological sorting. Adding v1 in the beginning of this sorting and vn in the end, we get a topological sorting of G. This is indeed a topological sorting since all edges involving v1 are of the form (v1, vi) for some i (v1 is a source), all edges involving vn are of the form (vi, vn) for some i (vn is a sink) and we started with a topological sorting of G′. Using part (a), we assume from now on that the sorting v1, v2, . . . , vn of the vertices is a topological sorting. We can achieve this by renaming the vertices. Part (a) tells us then that we do not need to rename v1 and vn. (b) Prove that for any directed v1-vn-path P : v1 = vi0, vi1, . . . , viℓ = vn we have i0 < i1 < · · · < iℓ. Solution: In a topological sorting of a graph, for any edge (v, w), we have that v comes before w in the sorting. Since v1, v2, . . . , vn is a topological sorting of G we thus get that for any edge (vi, vj) we have i < j. In particular, if we have a directed v1-vn-path P : v1 = vi0, vi1, . . . , viℓ = vn, then (vi0, vi1), (vi1, vi2), . . . (viℓ−1, viℓ) are edges of G and thus i0 < i1 < · · · < iℓ. (c) Describe a bottom-up dynamic programming algorithm that, given a graph G with the property that v1, . . . , vn is a topological sorting, returns the number of v1-vn paths in G in O(|V | + |E|) time. You can assume that the graph is provided to you as a pair (n, Adj) of the integer n = |V | and the adjacency lists Adj. Your algorithm can access Adj[u], which is a list of vertices to which u has a direct edge, in constant time. Formally, Adj[u] := {v ∈ V | (u, v) ∈ E}. In your solution, address the following aspects: 1. Dimensions of the DP table: What are the dimensions of the DP table? 2. Subproblems: What is the meaning of each entry? 3. Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others. 4. Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps? 5. Extracting the solution: How can the solution be extracted once the table has been filled? 6. Running time: What is the running time of your solution? Hint: Define the entry of the DP table as DP [i] = number of paths in G from vi to vn. Solution: 1. Dimensions of the DP table: DP [1 . . . n] 2. Subproblems: DP [i] is the number of paths in G from vi to vn. 3. Recursion: We initialize DP [n] = 1. DP can then be computed recursively as follows for i < n DP [i] = ∑ j∈{i+1,...,n}: (vi,vj )∈E DP [j]. 6 The reason why this holds is that every path from vi to vn is of the following form: We first have an edge (vi, vj) and then a path from vj to vn (which might be of length 0). By part (b), we have that j > i, which is the reason why we only consider j ∈ {i + 1, . . . , n}. Thus, to get the number of paths from vi to vn we can sum the number of vj-vn paths for all out-neighbors vj of vi (which satisfy j > i since v1, v2, . . . , vn is a topological sorting). Note that if we have the edge (vi, vj), then no vj-vn path contains vi as the graph G is acyclic. Hence, combining an edge (vi, vj) with a path from vj to vn gives always a path (and not just a walk). This shows that our recurrence relation is correct. 4. Calculation order: We can compute the entries by order of decreasing i. Then, for computing DP [i] all entries DP [j] we need have already been computed. 5. Extracting the solution: The solution can be found in DP [1], by definition of the DP table. 6. Running time: Computing the ith entry of DP uses time O(degout(vi) + 1) (the “1” is for access- ing the first element of the list). Summing this over all vertices, we get that the total running time is O(|V | + |E|) as wanted (using that ∑n i=1 degout(vi) = |E|). Remark: Note that we could have also defined the following DP table: DP ′[i] = number of paths in G from v1 to vi. One can initialize DP ′[1] = 1 and find a similar recurrence relation as above for DP ′[i], where we sum over all in-neighbors of vi. Using this, one can find the number of v1-vn paths by computing all entries in increasing order and returning DP ′[n]. When implementing this recursion as the one above (i.e. when computing DP ′[i] we sum over all in-neighbors), the run time of this solution would be O(|V | · (|V | + |E|)) instead of the wanted O(|V | + |E|). The reason for this is that finding all in-neighbors of a given vertex needs time O(|V | + |E|) since we need to go over all adjacency lists as we are only given a list with the out-neighbors for every vertex. However, it is also possible to implement this recursion in linear time. Instead of computing the sum for DP ′[i] when considering i, we can do the following: Whenever we are at position j, we add DP ′[j] to DP ′[i] for all out-neighbors i of j. The values DP ′[j] are initialized as 0 (except DP ′[1], which is still set to 1). Then once we arrive at j, DP ′[j] is correct. One can show this inductively since all in-neighbors of j come before j. Hence, when we arrive at DP ′[n], the value in DP ′[n] is also the number of paths from v1 to vn. Another option is to compute all the in-neighbours in advance and save them in adjacency lists, which can be done in time O(|V | + |E|). Then the update step for DP ′[i] can be done by summing over the in-neighbours as described above. (d)* What happens if the vertices v1 and vn are not a source respectively a sink? Can we still find the number of v1-vn paths using a similar approach as above? Solution: We note that any v1-vn path will not use an incoming edge at v1 nor an outgoing edge at vn (oth- erwise v1 respectively vn would occur twice which cannot happen in a path). Hence, given any directed acylic graph G, we can delete all incoming edges at v1 and all outgoing edges at vn. In this new graph G′ v1 is a source and vn is a sink. Also, G′ is still acyclic and the number of v1-vn paths in G′ is equal to the number of v1-vn paths in G. Hence, to compute the number of v1-vn paths in G, we can equivalently compute the number of v1-vn paths in G′. This can be done using parts (a)–(c). Note that deleting all incoming edges at v1 and all outgoing edges at vn can be done in time O(|V | + |E|), so the overall running time of the algorithm is still O(|V | + |E|). Hence, we can find the number of v1-vn in any directed acyclic graph G in time O(|V | + |E|). Guidelines for correction: 7 1/2 point should be awarded for correctly solving parts (a) and (b). 1/2 point should be awarded for correctly solving part (c). Exercise 9.5 Strongly connected vertices (1 point). Let G = (V, E) be a directed graph with n vertices and m edges. We say two distinct vertices v, w ∈ V are strongly connected if there exists both a directed path from v to w, and from w to v. Describe an algorithm which finds a pair v, w ∈ V of strongly connected vertices in G, or decides that no such pair exists. The runtime of your algorithm should be at most O(n + m). You are provided with the number of vertices n, and the adjacency list Adj of G. Hint: Use DFS as a subroutine. Solution: Solution using the edge classification of DFS: We want to use depth-first search and the edge-classification we get from it. We use the following algorithm: We run DFS and if we encounter a back edge, we return the endpoints of it. If we never encounter a back edge, then we output that the graph G has no pair of strongly connected vertices. The runtime of the execution of DFS is O(n + m). Also, identifying back edges does not increase the runtime. One option to identify the back edges is to go over all edges after the DFS and check the pre- and post-numbers of the endpoints (recall that (u, v) being a back edge is defined as pre(v) < pre(u) < post(u) < post(v)), which takes time O(n + m). Alternatively, we can do it directly during the DFS: When processing the neighbors of u, an edge (u, v) is a back edge exactly when v is already marked but has not yet been assigned a post-number, i.e. “visit(v)” is not yet finished. Checking this does not increase the asymptotic runtime of the DFS. Thus, the runtime of the proposed algorithm is indeed O(n + m). Regarding correctness, note that if we find a back edge (u, v), then {u, v} is strongly connected since there is a path from v to u using tree edges (u is processed during “visit(v)”) and we have the edge (u, v), which gives a path from u to v. Also note that if we do not find a back edge, then we know from the lecture that the graph has a topological ordering. But the existence of a topological ordering implies that there cannot be a pair of strongly connected vertices. Indeed, let u, v ∈ V . Assume that u comes before v in the ordering (otherwise replace the roles of u and v in following argument). All edges in G go from vertices that come earlier in the ordering to vertices that come later. Thus, we cannot have a path from v to u since such a path would need to have at least one edge that goes from some vertex to a vertex that comes earlier in the ordering. Hence, in both cases (we find a back edge or we do not), the algorithm is correct, which finishes the proof of correctness for the proposed algorithm. Direct solution giving an explicit algorithm: We use the following algorithm. 8 Algorithm 1 1: Input: integer n. Adjacency list Adj[1 . . . n]. 2: 3: Let status[1 . . . n] be a global array, with all entries initialized to UNVISITED. 4: 5: function visit(u) 6: status[u] ← VISITING 7: for each v in Adj[u] do ▷ Iterate over all neighbours v. 8: if status[v] = VISITING then ▷ There is a directed cycle containing u and v. 9: Output (u, v) and terminate 10: if status[v] = UNVISITED then 11: visit(v) 12: status[u] ← VISITED. 13: for u = 1, 2, . . . , n do 14: if status[u] = UNVISITED then 15: visit[u] 16: Output ”no strongly connected vertices exist” The algorithm above uses DFS to determine if there is a directed cycle in G. As we traverse the graph at most once, its runtime is at most O(n + m). Note that at any point during the algorithm there is a directed path from any vertex v with status[v] = VISITING to the current vertex u. Therefore, if u has a neighbour v with status[v] = VISITING, there must be a directed cycle containing both u and v. But that means u and v are strongly connected. The algorithm only terminates if a directed cycle is found, or when all vertices have status VISITED. In the latter case, no directed cycle exists in the graph. Guidelines for correction: • 1/2 point should be awarded for the correct idea (i.e., finding a directed cycle using DFS, and using the ‘back edge’ to extract a strongly connected pair). • 1/2 point should be awarded for a correct algorithm and explanation of correctness/runtime. 9","libVersion":"0.3.2","langs":""}