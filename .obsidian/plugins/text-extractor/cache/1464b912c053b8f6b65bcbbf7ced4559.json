{"path":"sem3/AlgoData/VRL/extra/AuD-graph-theory-new-concise.pdf","text":"Graphs and Eulerian tours 11.11.2021 (last taught) David Steurer 8.12.2020 (edited) Contents 1 Seven bridges of Königsberg 2 2 House of Santa Claus 4 3 Hamiltonian path 5 4 Algorithms for Hamiltonian paths and Eulerian walks 6 5 Graphs 6 6 Characterization of Eulerian tours 8 7 Iterative approach 9 8 Walking in graphs 10 9 Fast algorithm 11 10 Running time with adjacency matrix 12 11 Running time with adjacency lists 14 12 Correctness 15 In this lecture, we introduce the notion of a graph, which is of central importance for many branches of computer science as well as other scientiﬁc disciplines. Many questions beneﬁt from being viewed through the lens of graphs. As a ﬁrst example, we discuss a famous mathematical and algorithmic problem, which we call Eulerian-Tour. We use this example to illustrate and motivate some basic concepts in the context of graphs. 1 1 Seven bridges of Königsberg Leonhard Euler (mathematical giant, born 1707 in Basel) solved the following mathematical puzzle (ﬁg. 1), called “Seven Bridges of Königsberg”: Figure 1: Seven Bridges of Königsberg Devise a walk through the city of Königsberg that crosses each of its seven bridges over the Pregel River exactly once. Euler proved that such a walk does not exist. As part of his proof, he proposed the following abstract representation, which we call graph nowadays, for the city parts and the bridges. This representation captures all aspects of the city and bridges relevant for the puzzle. A B D C Here, the four parts of the city separated by the river are represented by four vertices labeled A, B, C, and D. The seven bridges over the river are represented by edges that connect pairs of vertices. The puzzle asks whether it is possible to walk along the edges of the above graph in such a way that each edge is traversed exactly once. We call such a walk Eulerian. To answer the question whether a Eulerian walk exists, it turns out that vertex degrees play an important role, where the degree of a vertex is deﬁned to be the number of edges that touch the vertex. The following table contains the degrees of the vertices in the graph representing the bridges of Königsberg. A B C D 3 5 3 3 A vertex with degree 0 is called isolated. Based on these vertex degrees, the following claim demontrates that the above graph doesn’t have an Eulerian walk. Claim: If there exists a Eulerian walk, then all but at most two vertex degrees must be even. Proof: Suppose a Eulerian walk , exists. Let E be any vertex not at the start or end of ,. Since E is not at the start or end of ,, it experiences the same number of arrivals as departures in ,. Since , is Eulerian, the sum of the number of arrivals and the number of departures at E has to equal the degree of E. Hence, the degree of E is equal to twice the number of arrivals, which means that the degree is even. □ Figure 2: three example graphs with zero, two, and four odd-degree vertices 2 House of Santa Claus Eulerian walks are connected also to an old drawing and rhyming puzzle for children (which appears to be known mostly in German-speaking regions). The puzzle is to draw the following ﬁgure in eight strokes—one for each syllable of the rhyme “Das ist das Haus vom Ni-ko-laus”—without lifting the pen. Observation: A sequence of strokes to draw this ﬁgure without lifting exactly corresponds to a Eulerian walk in the following graph (obtained by placing a vertex at each corner of the drawing). E A B C D This graph indeed has a Eulerian walk: C,A,E,B,D,A,B,C,D. 3 Hamiltonian path A Hamiltoninan path in a graph is deﬁned to be a walk that visits every vertex exactly once. This deﬁnition is syntactically similar to the deﬁnition of Eulerian walks. Only the role of edges and vertices is interchanged. Despite the similar deﬁnition, it turns out that in general it is much more diﬃcult to reason about Hamiltonian paths than about Eulerian walks. The following graph is an example of a graph that has a Eulerian walk but not a Hamiltonian walk. 4 Algorithms for Hamiltonian paths and Eulerian walks Suppose we are given a graph and the goal is to compute a Eulerian walk or a Hamiltonian path if it exists. A naive algorithm is brute-force search: we consider all possible orderings of edges or vertices. However, the running time of this approach is at least exponential. Indeed, for a graph with = vertices and < edges, there are =! possible orderings of vertices and <! possible orderings of edges. For Eulerian walks, as we will see in this lecture, it is possible to avoid brute-force search and compute a Eulerian walk in time $(= + <) if it exists. In contrast, for Hamiltonian paths, brute-force search appears to be unavoidable. The famous % < #% conjecture turns out to be equivalent to conjecturing that there is no polynomial-time algorithm for computing Hamiltonian paths. 5 Graphs Before proceeding, we step back to discuss the broader signiﬁcance of graphs. We also give a mathematical deﬁnition of graphs and introduce some terminology that is commonly used in the context of graphs. Networks are ubiquitous in many diﬀerent human endeavors: • computer networks (like the internet): computing devices are connected to each other by data links • social networks: people are connected to each other by their social relation- ships • transportation networks: cities are connected to each other by streets and train tracks • neural networks (both artiﬁcal and natural ones): neurons are connected to each other at synapses Graphs are mathematical models for networks that highlight some common structure shared by all networks. Deﬁnition: A graph ˝ = (+ , ˆ) consists of a ﬁnite vertex set + and ﬁnite edge set ˆ such that each edge 4 ∈ ˆ is an unordered pair 4 = {D, E} of distinct vertices D, E ∈ +. Typically, we require that + is not the empty set. It is often convenient to choose + to be a set of consecutive natural number. 1 2 4 3 In the above example, the vertex set is {1, 2, 3, 4} and the edge set consists of the following edges, {1, 2}, {2, 3}, {3, 4}, {1, 4} . Deﬁnition: If a graph ˝ = (+ , ˆ) contains an edge 4 = {D, E} ∈ ˆ, we call the vertices D, E adjacent in ˝ and we say 4 is incident to D and E. The degree of a vertex D, denote deg(D), is the number of edges that D is incident to in ˝. Instead of writing 4 = {D, E}, we often use the shorthand 4 = DE. Handshake lemma: For every graph ˝ = (+ , ˆ), Õ E∈+ deg(E) = 2|ˆ| . Proof: Suppose every vertex distributes one coin to each of its incident edges. Then, every edge receives two coin in total, one coin from each of its endpoints. Thus, the sum of the vertex degrees has to equal twice the number of edges. □ Deﬁnition: A walk of length \u0012 is a sequence of \u0012 + 1 vertices E0, . . . , E\u0012 such that consecutive ones are adjacent, i.e., v0 v1 … vℓvℓ-1 To this walk, we also associate the sequence of \u0012 edges {E0, E1}, . . . , {E\u0012 −1, E\u0012 }. Edges and vertices are allowed to be repeated multiple times in a walk. Note: The usual convention is that the length of a walk refers to its number of edges (as opposed to its number of vertices). For a walk , = (E0, . . . , E\u0012 ), we deﬁne the degree deg, (D) of a vertex D to be the number of edges in , incident to D (with repetitions counted), deg, (D) = |{8 ∈ {0, . . . , \u0012 − 1} | D ∈ {E8 , E8+1}}| . Note: If , contains the same edge multiple times, then deg, (D) could be larger than deg(D). A walk is closed, if starts and ends with the same vertex E0 = E\u0012 . A path is a walk without repeated vertices. Claim: A walk , = (E0, . . . , E\u0012 ) is closed if and only if deg, (E\u0012 ) is even. Proof: Each occurrence of E\u0012 in the inner part E1, . . . , E\u0012 −1 of , increases deg, (E\u0012 ) by 2 and thus doesn’t aﬀect the parity of deg, (E\u0012 ). Hence, deg, (E\u0012 ) is even if and only if E\u0012 occurs twice at the two ends of ,, which means that E0 = E\u0012 . □ We say that vertex D reaches vertex E if there exists a walk starting in D and ending in E. This relation satisﬁes all properties of an equivalence relation: symmetry, reﬂexivity, and transitivity. The connected component of a vertex D is the set of all vertices that it can reach. In other words, the connected component of D is the equivalence class of the reachability relation that contains D. A graph is connected if every vertex D reaches every other vertex E. In other words, a graph is connected if it has only one connected component. A Eulerian tour is a closed walk that visits every edge exactly once. 6 Characterization of Eulerian tours The following theorem shows that the only possible obstruction for a Eulerian tour is a vertex of odd degree. Theorem: A connected graph has a Eulerian tour if and only if all vertex degrees are even.1 One direction of the statement of the theorem is easy to prove. In a closed walk ,, all degrees deg, (D) in , are even. If , is a Eulerian, the degrees in , are the same as the degrees in the graph, i.e., deg, (D) = deg(D) for all D ∈ +. To prove the other direction, we exhibit an algorithm that outputs a Eulerian tour in a connected graph whenever all vertex degrees are even. Note: A similar theorem holds for Eulerian (non-closed) walks in connected graphs. We just need to account for up to two vertices with odd degrees. We can reduce questions about Eulerian walks to questions about Eulerian tours 1A graph with a Eulerian tour is not necessarily connected. However, all edges need to be in the same connected component. In other words, the graph needs to be connected after removing isolated vertices. by adding a new vertex adjacent to the two odd-degree vertices if needed (see ﬁg. 3). Figure 3: Reducing Eulerian walks to Eulerian tours: after adding the red vertex and edges all degrees are even 7 Iterative approach Instead of aiming at directly computing a Eulerian tour, we ﬁrst consider simpler but related tasks. For example, we could start by computing any closed walk (of length larger than 0). Then, we could try to compute a list of closed walks /1, . . . , /: such that each edge appears exactly once in the walks. Indeed, if we can ﬁnd such a list of closed walks for a connected graph, we can obtain a Eulerian tour by merging the closed walks as illustrated in the example ﬁg. 4. We can always merge two closed walks that share a vertex to a single closed walk that uses the same edges. In a connected graph, we can keep merging in this way until only one closed walk remains that uses every edge exactly once. Figure 4: merging closed walks to a Eulerian tour To summarize, we consider the following approach for computing a Eulerian tour: • iteratively compute closed walks /1, . . . , /: until every edge ised exactly once • merge the closed walks to a Eulerian tour In the following, we show how to carry out the ﬁrst step for graphs without odd degree vertices. 8 Walking in graphs We consider the following recursive procedure for ﬁnding a maximal walk2 starting in a vertex D without repeating edges. Walk(D): • If there exists an unmarked edge DE ∈ ˆ incident to D: – Mark the edge DE. – Run Walk(E). We take note of a few properties of this procedure: 1. The procedure Walk(D) marks a walk , starting in D. 2. Every edge gets marked at most once. 3. The walk , ends in a vertex E such that all edges incident to E are marked. The second property holds because we never undo markings and we check that an edge is unmarked before marking it. The reason the third property holds is that in the last call of Walk(E) we didn’t mark any edge incident to E, which means that all edges incident to E were marked at this point. In the previous example (ﬁg. 4), suppose we start with no edges marked and run the Walk procedure ﬁrst on B and then on E (without undoing the markings made by Walk(B)). Then, we mark the following walks, assuming we process the edges in alphabetical order: procedure call marked walk Walk(B): B A C B D E F B Walk(E): E G H E In order to analyze the Walk procedure we propose the following property as an invariant: ALL-EVEN: every vertex is incident to an even number of unmarked edges If all edges are unmarked and all vertex degrees are even, then ALL-EVEN holds. Claim: If ALL-EVEN holds before running Walk(D), then it also holds after Walk(D) has ﬁnished. Furthermore, the walk , marked by Walk(D) is closed. 2Here, maximal means that the walk cannot be extended further. We don’t require the walk to have maximum length. Proof: It is enough to prove that , is closed. (If , is closed, then deg, (F) is even for all vertices F ∈ +, which means that ALL-EVEN also holds after Walk(D).) Suppose , ends in vertex E. In order to prove that , is closed, we need to show that deg, (E) is even. (Recall the claim we proved about closed walks in sec. 5). We know that before running Walk(D), vertex E had an even number of unmarked edges (because we assume ALL-EVEN held at that time). After running Walk(D), vertex E has no unmarked edges (the third property of the Walk procedure we noted). Hence, deg, (E), the number of edges incident to E marked by Walk(D), is even. □ The claim implies that we can partition the edges of any graph without odd degree vertices into a collection of closed walks by repeatingly running the Walk routing on vertices with unmarked edges until all edges are marked. 9 Fast algorithm While the approach we have discussed so far allows us to compute a Eulerian tour in polynomial3 time, we need additional ideas in order to achieve linear running time. As a starting point, we consider the following question: After one call of the Walk routine has ﬁnished, which vertex should we choose as the start for the next call of the Walk routine? The idea is to backtrack in the walks we have computed so far. For example, suppose in ﬁg. 4 we run Walk(A) and mark the walk A B C A. Then, we backtrack in this walk two steps, A C B, and arrive at vertex B with unmarked edges incident to it. We run Walk(B) and mark the walk B D E F B. We backtrack two steps, B F B, and arrive at vertex E. Finally, we run Walk(E) and mark the walk E G H E. At this point all edges are marked. To implement the idea of backtracking along the walks we have already found, we will use the following recursive procedure to build up a list /, which will eventually contain a Eulerian tour: Euler-Walk(D): • For the edges DE ∈ ˆ incident to D: – If the edge DE is not yet marked, mark the edge DE and run Euler-Walk(E). • Append D to the end of the list /. Using Euler-Walk as a subroutine, the following procedure ﬁnd a Eulerian tour in a connected graph ˝: 3Here, we are not referring to any speciﬁc running times (like quadratic, cubic, and so on). As we will see later, the speciﬁc running times will depend on the kind of data structures we use to represent graphs. Euler(G): • Initalize / as an empty list and all vertices to be unmarked. • Run Euler-Walk(D0) for an arbitrary4 vertex D0 ∈ +. • Output the ﬁnal content of the list /. Recursion tree of the procedure Euler-Walk applied to vertex A for the example graph in ﬁg. 4. The red numbers indicate the order in which vertices are appended to the list /. A 11 B 10 C 2 D 9 A 1 E 8 F 4 G 7 B 3 H 6 E 5 The content of the ﬁnal list / for this example: 1 2 3 4 5 6 7 8 9 10 11 A C B F E H G E D B A 10 Running time with adjacency matrix In order to analyze the running time of Euler(˝), we need to specify what data structure we use to represent the graph ˝. Let ˝ = (+ , ˆ) be a graph with = ≥ 1 vertices + = {1, . . . , =} and < ≥ 1 edges. Deﬁnition: The adjacency matrix \u0016 = (\u001689)8,9∈+ of ˝ is deﬁned as \u001689 = {1 if {8, 9} ∈ ˆ , 0 otherwise. For example, the graph in ﬁg. 5 has the following adjacency matrix (with the red entries of the matrix corresponding to the red edge in the graph): 4For a connected graph, we can choose the start vertex D0 to be arbitrary. If we allow the underlying graph to have isolated vertices, we should choose D0 to be a non-isolated vertex if one exists. 1 2 4 3 Figure 5: Example graph with adjacency matrix (1)        0 1 0 1 1 0 1 1 0 1 0 1 1 1 1 0        (1) Running times of basic operations on adjacency matrices: 1. Given two vertices D, E ∈ +, we can test if DE ∈ ˆ in time $(1). 2. Given a vertex D ∈ +, we can enumerate the neighbors of D in time $(=). Claim: Euler(˝) can be implemented to have running time $(= · <) if ˝ is represented by its adjacency matrix. Proof: It suﬃces to bound the time for Euler-Walk(D0). Each recursive call of Euler-Walk is associated with with an edge in ˝ marked by the algorithm. Hence, the total number of calls of Euler-Walk is at most5 < + 1 (at most < recursive calls in addition to one initial call for D0). For any individual call of Euler-Walk, the number of elementary operations carried out while this call is active (i.e., not counting operations carried out inside nested recursive calls) is $(=). Hence, the total running time is (< + 1) · $(=) = $(= · <). □ 5Indeed, if the graph is connected and has a Eulerian tour, then the number of calls of Euler-Walkis equal to < + 1. 11 Running time with adjacency lists The main weakness of representing graphs by their adjacency matrix is that enumerating the neighbors of a vertex takes time \u0002(=), even when the number of neighbors is much small than =. A better representation of a graph are its adjacency lists. For example, the graph in ﬁg. 5 has the following adjacency list representation: 1 2 3 4 (2,4) (3,1,4) (4,2) (1,3,2) Let ˝ = (+ , ˆ) be a graph with = ≥ 1 vertices + = {1, . . . , =} and < ≥ 1 edges. Deﬁnition: The adjacency list representation of a graph ˝ is an =-dimensional array \u0016 such that \u0016[8] is a list of all neighbors of vertex 8 in ˝ (in arbitrary order). Running times of basic operations on adjacency list representations: 1. Given two vertices D, E ∈ +, we can test if DE ∈ ˆ in time $(1 + min{deg(D), deg(E)}). 2. Given a vertex D ∈ +, we can enumerate the neighbors of E in time $(1 + deg(D)). Per our convention, $(·) hides only multiplicative constants. We make the additive constant 1 explicit here to account for the possibility that the degree of one of the vertices is 0. The (proof of) following claim illustrates that this additive constant 1 is useful to reason about running times. Claim: The running time to enumerate all edges of ˝ given its adjacency list representation is $(= + <). Proof: Using this fact that enumerating the neighbors of a single vertex D takes time $(1 + deg(D)), the total running time is $ (Õ D∈+ (1 + deg(D))) . Using the handshake lemma, we can compute the sum Õ D∈+(1 + deg(D)) = = + Õ D∈+ deg(D) = = + 2< .□ Note that without the additive 1 term, we might have been tempted to conclude a running time bound of $(<). However, this bound is false for graphs that have much fewer edges than vertices (which happens if there are many isolated vertices). Claim: Euler(˝) can be implemented to have running time $(= + <) for the adjacency list representation \u0016 of ˝. Proof: In order to implement Euler-Walk(D), we enumerate the edges incident to D by traversing the adjacency list \u0016[D]. For every unmarked edge DE, we encounter we start a recursive call for vertex D. Furthermore, after we enumerate an incident edge (be it marked or unmarked), we remove it from the adjacency list in time $(1). To bound the running time of Euler-Walk(D0) for this implementation, we note that we can charge6 every operation to an edge of ˝ such that each edge gets charged with only $(1) operations. The only exceptions are $(1) operations in Euler-Walk(D0) that are carried out even if D0 has no incident edge. Hence, the total running time of Euler-Walk(D0) is $(< + 1). The initialization phase of Euler(˝) takes time $(= + <) in order to set up the data structure to support marking edges. Thus, the total running itme of Euler(˝) is $(= + <). 12 Correctness In this section, we will prove the correctness of the algorithm developed in the previous section. Lemma: For a connected graph ˝ without odd degree vertices, Euler(˝) com- putes a Eulerian tour. To prove this lemma, we imagine a tortoise and hare7 using the recursion tree ) of Euler-Walk(D0) to walk in the graph ˝. First, we note that each edge of ˝ is represented by precisely one edge in ). Since Euler-Walk traverses an edge only if it hasen’t been traversed before, it follows that no edge of ˝ can appear more than once in ˝. Using the assumption that ˝ is connected and the fact that Euler-Walk ﬁnishes only if all edges of a vertex have been traversed, it also follows that each edge of ˝ appears at least once in ˝. Next, we describe how the hare and tortoise move in the recursion tree ). 6More details: let’s look at all Euler-Walk calls that we make during Euler(˝). Every elementary operation of the algorithm happens for one of these calls (except for the operations during the initialization phase of Euler(˝). Let <8 be the number of edges we enumerate during the 8-th call of Euler-Walk. The number of operations for the 8-th call of Euler-Walk is $(1 + <8 ). Each edge appears twice in the adjacency list representation of ˝. Since we delete an edge after we enumerate it in an adjacency list, we have Í8 <8 ≤ 2<. The number of Euler-Walk calls is at most < + 1. Hence,Í8 (1 + <8 ) ≤ 1 + 3<. Hence, the total running time for the Euler-Walk calls is $(< + 1). 7See Aesop’s Fable “The Tortoise and the Hare”. For our proof, the two protagonists give us a non-recursive way to think about the behavior of the Euler-Walk procedure. The hare walks in ) from the root to the ﬁrst8 leaf, from the ﬁrst leaf to the second leaf, and so on. Finally, it walks from the last leaf back to the root. In this way, the hare traverses every edge of ) precisely twice, once in the direction toward the root and once in the direction away from the root. The hare’s movement follows the recursive calls of the Euler-Walk procedure. Moving down the tree (away from the root) corresponds to starting a new recursive call. Moving up the tree (toward the root) corresponds to ﬁnishing a recursive call. The tortoise is waiting at the ﬁrst leaf of ). When the hare arrives there, the tortoise walks toward the root together with the hare until they encounter an ancestor of the second leaf for the ﬁrst time. At this point, the tortoise jumps9 directly to the second leaf of ). Here, the tortoise waits again for the hare to arrive. The tortoise continues moving in this way until it reaches the ﬁnal leaf of ). Here, it waits again until the hare arrives and then walks together with hare from the ﬁnal leaf all the way to the root. In this way, the tortoise traverses each edge of the tree precisely once (in the direction toward the root). Since moving up the tree corresponds to ﬁnishing the recursive call of Euler-Walk for the lower vertex, the sequence of vertices visited by the tortoise, ignoring the vertices it jumped from, equals the content of the ﬁnal list / computed by Euler. Since each vertex and each edge of ) corresponds to vertices and edge in the graph ˝, the movements of the tortoise and hare correspond in a canonical way to movements in the graph. Since the movement of the hare in ) forms a closed walk, its movement in ˝ also forms a closed walk (starting and ending at vertex D0). The following claim shows that, somewhat surprisingly, also the movement of the tortoise in ˝ forms a closed walk (starting and ending at D0). Claim: The root and the ﬁrst leaf of ) correspond to the same vertex in ˝. Furthermore, for every leaf 8 besides the ﬁrst leaf, the lowest common ancestor of leaf 8 − 1 and leaf 8 corresponds to the same vertex in ˝ as leaf 8. This claim shows that the jumps of the tortoise in ) translate to staying put in ˝. Consequently, the tortoise moves along a closed walk in ˝, whose vertex sequence is equal to the ﬁnal list / computed by Euler. As noted before, there is a one-to-one correspondence between the edges in ˝ and in ). Since the tortoise traverses each edge in ) exactly once, its closed walk in ˝ is a Eulerian tour. Hence, to establish the lemma, it remains to prove the claim. Proof: In order to prove this claim, we use the fact that the Euler-Walk procedure behaves the same10 as the Walk procedure from sec. 8 except for branching. We 8The ﬁrst leaf corresponds to the ﬁrst recursive call of Euler-Walk that has ﬁnished. In general, we order the leafs of ) according to the time that the respective recursive calls of Euler-Walk has ﬁnished. 9Although these jumps may not seem tortoise-like, it turns out that, when viewed in the graph ˝, these jumps actually correspond to staying put. 10In order to get a direct correspondence between Euler-Walk and Walk, we shall assume that both procedures process unmarked edges incident to a vertex in the same order (e.g., according to the alphabetical order of the labels of the neighbors). will show that the execution of Euler-Walk(D0) can be viewed as a sequence of executions of the Walk procedure. As part of the proof of the above claim, we will show the following statement by induction on 8 ≥ 1: %(8): If we mark all edges in ˝ visited by the hare until reaching leaf 8 of ), then ALL-EVEN is satisﬁed (see sec. 8). Consider the path in ) from its root to its ﬁrst leaf. This path also corresponds11 to the (non-branching) recursion tree of Walk(D0) initialized with all edges of ˝ unmarked. According to the claim in sec. 8, Walk(D0) marks a closed walk starting at D0 and ending at D0. (Here, we use that the property ALL-EVEN is satisﬁed in ˝ when all edges are unmarked.) It follows that the ﬁrst leaf of ) corresponds to the vertex D0 in ˝ (establishing the ﬁrst part of the claim). It also follows that %(1) holds because the Walk procedure maintains the ALL-EVEN invariant. We are to show that %(8 − 1) implies %(8) for 8 ≥ 2. Mark all edges in ˝ that appears on the paths from the root of ) to the ﬁrst 8 − 1 leafs of ). By the induction hypothesis, %(8 − 1) holds, which means that ALL-EVEN is satisﬁed. Consider the lower lowest common ancestor \u00168−1 of leaf 8 − 1 and leaf 8. Suppose \u00168−1 corresponds to vertex D8−1 in ˝. Then, the (non-branching) recursion tree of Walk(D8−1) is the same12 as the path from \u00168−1 to leaf 8 in ). By the analysis of Walk in sec. 8, this path corresponds to a closed walk in ˝ that starts and ends in D8−1 (establishing the claim for leaf 8). It also follows that %(8) holds because the Walk procedure maintains the ALL-EVEN invariant. □ 11In order to get a direct correspondence between Euler-Walk and Walk, we shall assume that both procedures process unmarked edges incident to a vertex in the same order (e.g., according to the alphabetical order of the labels of the neighbors). 12The recursive call of Euler-Walk represented by \u00168−1 in ) initiates several recursive calls of Euler-Walk. Alternatively, we can simulate this branching by calling the Walk procedure several times from this vertex.","libVersion":"0.3.2","langs":""}