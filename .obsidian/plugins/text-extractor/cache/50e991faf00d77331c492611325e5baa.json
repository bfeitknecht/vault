{"path":"sem3/TI/VRL/extra/nwehrl/TI-nwehrl-w09.pdf","text":"Theoretische Informatik HS24 Nicolas Wehrli ¨Ubungsstunde 09 19. November 2024 ETH Z ¨urich nwehrl@ethz.ch 1 Heute 1 Feedback zur Serie 2 Reduktion continued 3 Satz von Rice - Beweis 4 EE Reduktion angewendet f ¨ur LRE 5 Worked example 6 Reduktionsaufgaben 2 Feedback zur Serie Feedback zur Serie - Recht gut. - EE-Reduktion braucht nur das Eingabe zu Eingabe Mapping. - Ihr m ¨usst erw¨ahnen, dass eure TM terminiert! 3 Reduktion continued Aufgabe 5.22 Wir zeigen L ∈ LRE ∧ L ∁ ∈ LRE ⇐⇒ L ∈ LR ( =⇒ ) : Nehmen wir L ∈ LRE ∧ L∁ ∈ LRE an. Dann existiert eine TM M und MC mit L(M) = L und L(MC) = L∁. Wir konstruieren eine TM A, die f ¨ur eine Eingabe w die beiden TM’s M und MC parallel auf w simuliert. A akzeptiert w, falls M das Wort akzeptiert und verwirft, falls MC das Wort akzeptiert. 4 Aufgabe 5.22 Bemerke, dass L(M) ∩ L(MC) = ∅ und L(M) ∪ L(MC) = Σ∗. Da w ∈ L(M) oder w ∈ L(MC), h¨alt A immer. Da A genau dann akzeptiert, falls w ∈ L(M), folgt L(A) = L(M) = L. Demnach gilt L ∈ LR. ( ⇐= ) : Nehmen wir L ∈ LR an. Per Lemma 5.4 gilt L∁ ≤R L und daraus folgt auch L∁ ∈ LR. Da LR ⊂ LRE, folgt L ∈ LRE ∧ L∁ ∈ LRE. ■ 5 Satz von Rice - Beweis Satz von Rice Satz 5.9 Jedes semantisch nichttriviale Entscheidungsproblem ¨uber Turingmaschinen ist unentscheidbar. 6 Prerequisites Zur Erinnerung: Semantisch nichttriviales Entscheidungsproblem ¨uber TMs Das Entscheidungsproblem (Σ, L), bzw. die Sprache L muss folgendes erf ¨ullen. I. L ⊆ KodTM II. ∃M1 so dass Kod(M1) ∈ L(i.e. L ̸= ∅) III. ∃M2 so dass Kod(M2) /∈ L(i.e. L ̸= KodTM) IV. F ¨ur zwei TM A und B mit L(A) = L(B) gilt Kod(A) ∈ L ⇐⇒ Kod(B) ∈ L KodTM ⊆ (Σbool)∗ ist die Menge aller Kodierungen von Turingmaschinen. 7 Prerequisites Wir brauchen Lemma 5.8 LH,λ /∈ LR Zur Erinnerung: LH,λ = {Kod(M) | M h¨alt auf λ} 8 Idee Wir zeigen f ¨ur jedes semantisch nichtriviale Entscheidungsproblem (Σ, L) L ∈ LR =⇒ LH,λ ∈ LR Aus dem folgt dann per Kontraposition LH,λ /∈ LR =⇒ L /∈ LR Mit der Aussage LH,λ /∈ LR von Lemma 5.8, k ¨onnen wir dann L /∈ LR wie gew ¨unscht folgern. 9 Idee Wir m ¨ussen noch die Implikation L ∈ LR =⇒ LH,λ ∈ LR beweisen. Kernidee Wir zeigen die Existenz einer Reduktion, aus der die Implikation folgt. 10 Idee Konkret machen wir eine Case Distinction und zeigen jeweils - Die Existenz einer EE-Reduktion von LH,λ auf L Daraus folgt LH,λ ≤EE L. - oder die Existenz einer EE-Reduktion LH,λ auf L∁ Daraus folgt LH,λ ≤EE L∁. Zur Erinnerung: Lemma 5.3 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. L1 ≤EE L2 =⇒ L1 ≤R L2 11 Idee Weshalb reicht es LH,λ ≤EE L∁ zu zeigen? Lemma 5.4 Sei Σ ein Alphabet. F ¨ur jede Sprache L ⊆ Σ∗ gilt: L ≤R L∁ und L ∁ ≤R L In beiden Cases folgt mit Lemma 5.3 und Lemma 5.4, die gew ¨unschte Aussage LH,λ ≤R L. 12 Idee Explizit gilt nun 1. LH,λ ≤EE L ∁ Lemma 5.3 ======⇒ LH,λ ≤R L∁ Lemma 5.4 ======⇒ LH,λ ≤R L 2. LH,λ ≤EE L Lemma 5.3 ======⇒ LH,λ ≤R L Aus LH,λ ≤R L folgt (in beiden Cases) die gew ¨unschte Implikation L ∈ LR =⇒ LH,λ ∈ LR 13 Beweis Sei M∅ eine TM s.d. L(M∅) = ∅. Case Distinction I. Kod(M∅) ∈ L Wir zeigen LH,λ ≤EE L∁. II. Kod(M∅) /∈ L Wir zeigen LH,λ ≤EE L. 14 Case I. Kod(M∅) ∈ L Es existiert eine TM M, so dass Kod(M) /∈ L. (Nichttrivialit¨at) Wir beschreiben eine TM S, so dass f ¨ur eine Eingabe x ∈ (Σbool)∗ x ∈ LH,λ ⇐⇒ S(x) ∈ L ∁ Daraus folgt dann die gew ¨unschte EE-Reduktion. Wir verwenden dabei M∅ und M, da Kod(M∅) /∈ L∁ und Kod(M) ∈ L∁. 15 Case I. Kod(M∅) ∈ L - Beschreibung von S Eingabe x ∈ (Σbool)∗ 1. S ¨uberpr ¨uft ob x = Kod(M) f ¨ur eine TM M. Falls dies nicht der Fall ist, gilt S(x) = Kod(M∅) 2. Sonst x = Kod(M). Dann S(x) = Kod(A), wobei A wie folgt kodiert ist. i. Gleiches Eingabealphabet wie M, i.e. ΣA = ΣM. ii. F ¨ur eine beliebige Eingabe y ∈ (ΣM)∗, simuliert A zuerst M auf λ ohne die Eingabe y zu ¨uberschreiben. iii. Danach simuliert A die TM M auf die gegebene Eingabe y. iv. Akzeptiert y genau dann, wenn M y akzeptiert. 16 Korrektheit Wir zeigen x ∈ LH,λ ⇐⇒ S(x) ∈ L ∁ ( =⇒ ) : Wir nehmen x ∈ LH,λ an und zeigen S(x) ∈ L∁. Da M auf λ h¨alt, wird A immer M auf der Eingabe y simulieren und wir haben L(A) = L(M). Da L (und somit auch L∁) ein semantisches Entscheidungsproblem ist, gilt Kod(M) ∈ L ∁ =⇒ Kod(A) ∈ L ∁ Da die LHS der Implikation gegeben ist, folgt S(x) = Kod(A) ∈ L∁ 17 Korrektheit ( ⇐= ) : Wir nehmen x /∈ LH,λ an und zeigen S(x) /∈ L∁. Aus Kontraposition folgt dann die gew ¨unschte R ¨uckimplikation. Da M nicht auf λ h¨alt, wird A bei jeder Eingabe nicht halten. Somit folgt L(A) = L(M∅) und da Kod(M∅) /∈ L∁ per semantische Eigenschaft von L S(x) = Kod(A) /∈ L∁ 18 Case II. Zweite Case funktioniert genau gleich. Wir haben Kod(M∅) /∈ L. Per Nichttrivialit¨at existiert eine TM M mit Kod(M) ∈ L. ... ■ 19 EE Reduktion angewendet f ¨ur LRE Lemma zu RE-Reduktion EE-Reduktion impliziert RE-Reduktion (nicht in der Vorlesung) L1 ≤EE L2 =⇒ (L2 ∈ LRE =⇒ L1 ∈ LRE) Beweis Sei L1 ≤EE L2 und L2 ∈ LRE. Wir zeigen nun L1 ∈ LRE. Per Definition von L1 ≤EE L2 existiert ein Algorithmus F, der die Funktion f : Σ∗ 1 → Σ∗ 2 berechnet, so dass ∀x ∈ Σ∗ 1.x ∈ L1 ⇐⇒ f (x) ∈ L2 20 Lemma zu RE-Reduktion Da L2 ∈ LRE existiert eine TM M2 (die nicht unbedingt immer terminiert) mit L(M2) = L2. Wir beschreiben mit F und M2 nun eine TM M1 mit L(M1) = L1. Eingabe: x ∈ Σ∗ 1 1. F berechnet auf x und ¨ubergibt seine Ausgabe f (x) zur TM M2 2. M2 berechnet auf f (x) und die Ausgabe wird ¨ubernommen. 21 Lemma zu RE-Reduktion Abbildung 1: TM M1, Zsf. Fabian Frei 22 Lemma zu RE-Reduktion Korrektheit (L1 = L(M1)) Case Distinction I. x ∈ L1 =⇒ f (x) ∈ L2 (Algorithmus F terminiert immer) L(M2) = L2 =⇒ f (x) ∈ L(M2) da die Ausgabe von M2 ¨ubernommen wird =⇒ x ∈ L(M1) II. x /∈ L1 =⇒ f (x) /∈ L2 =⇒ f (x) /∈ L(M2) =⇒ x /∈ L(M1) ■ 23 Worked example Worked example Aufgabe Sei Lall = {Kod(M) | M akzeptiert jede Eingabe}. Zeigen Sie L∁ H ≤EE Lall. Kernidee F ¨ur eine Eingabe x = Kod(M)#w, generieren wir Kod(A) einer TM A, die folgendes folgendes macht: 24 Worked example A : Eingabe y 1. Berechnet |y| Schritte von M auf w. 2. Falls danach die Berechnung nach |y| noch nicht terminiert hat, akzeptiert A die Eingabe y. 3. Sonst verwirft A die Eingabe. A akzeptiert jede Eingabe ⇐⇒ M l¨auft unendlich auf w Kod(A) ∈ Lall ⇐⇒ Kod#w ∈ L∁ H 25 L1 ≤R L2 ̸=⇒ (L2 ∈ LRE =⇒ L1 ∈ LRE) Wir beweisen diese Aussage per Gegenbeispiel. Sei L1 = Ldiag und L2 = L∁ diag. Wir haben ▶ L1 = Ldiag /∈ LRE (Satz 5.5) ▶ L2 = L∁ diag ∈ LRE \\ LR (Korollar 5.2, Lemma 5.5) Per Lemma 5.4 gilt Ldiag ≤R L∁ diag. Die rechte Implikation gilt jedoch nicht. ■ 26 L1 ≤R L2 ̸⇐= (L2 ∈ LRE =⇒ L1 ∈ LRE) Sei L1 = LU und L2 = {0i | i ∈ N}. Wir haben ▶ L1 = LU ∈ LRE \\ LR (Satz 5.6 und 5.7) ▶ L2 = {0i | i ∈ N} ∈ LR (da LEA ⊂ LR) Da L1 ∈ LRE, gilt die Implikation auf der rechten Seite f ¨ur dieses L1 und L2. Da per Definition L1 ≤R L2 ⇐⇒ (L2 ∈ LR =⇒ L1 ∈ LR) folgt aus L1 /∈ LR und L2 ∈ LR, dass diese Instanzierung von L1 und L2 ein Gegenbeispiel ist. ■ 27 Relation zu EE-Reduktion Wir haben aber gezeigt, dass L1 ≤EE L2 =⇒ L1 ≤R L2 und L1 ≤EE L2 =⇒ (L2 ∈ LRE =⇒ L1 ∈ LRE) Die R ¨uckrichtung gilt jeweils nicht. 28 Reduktionsaufgaben Aufgabe 1 Zeige Ldiag ≤EE L∁ H Zur Erinnerung: Ldiag = {wi ∈ (Σbool) ∗ | Mi akzeptiert wi nicht} L∁ H = {Kod(M)#w ∈ {0, 1, #}∗ | M h¨alt nicht auf w} ∪ {x ∈ {0, 1, #} ∗ | x nicht von der Form Kod(M)#w} 29 L ¨osung 1 Wir beschreiben einen Algorithmus A, so dass x ∈ Ldiag ⇐⇒ A(x) ∈ L ∁ H Eingabe: x ∈ (Σbool)∗ 1. Findet i so dass x = wi 2. Generiert Kod(Mi) 3. Generiert Kod(Mi) mit folgenden Modifikationen zu Kod(Mi) - Transitionen nach qreject werden in eine Endlosschleife umgeleitet. 4. Gibt Kod(Mi)#wi aus. 30 L ¨osung 1 Case Distinction I. x ∈ Ldiag =⇒ Mi akzeptiert x = wi nicht =⇒ Mi h¨alt nicht auf wi =⇒ A(x) = Kod(Mi)#wi ∈ L∁ H II. x /∈ Ldiag =⇒ Mi akzeptiert x = wi =⇒ Mi h¨alt auf wi =⇒ A(x) = Kod(Mi)#wi /∈ L∁ H ■ 31 Aufgabe 2 Zeige L ∁ U ≤EE Ldiag 32","libVersion":"0.5.0","langs":""}