{"path":"sem5/VLSI1/VRL/extra/slides/VLSI1-s02-FPGA.pdf","text":"22 September 2025 VLSI 1: HDL Based Design for FPGAs An Introduction to FPGAs Luca Benini Frank K. Gürkaynak Danilo Cammarata Key take-aways ▪ IC design: 0.6% of world GDP and key growth booster ▪ Moore’s law is slowing down (dead?) – design is ever more important ▪ Designing ASIC is complicated and costly ▪ Specialized ASICs only viable for high volume ▪ But what if we do not have high volume? VLSI 1: HDL Based Design for FPGAs Let’s talk about FPGAs 2 “To what extent is a circuit manufactured to user specs?” ▪ Full-custom IC: (ASIC) All fabrication layers, full set of photomasks ▪ Semi-custom IC: (gate array, sea-of-gates, structured ASIC) A few metal layers only, subset of photomasks. ▪ Field-programmable logic: (FPGA, PLD) Customization occurs electrically, no masks involved. 3 Curtailing the Cost of ASICs... VLSI 1: HDL Based Design for FPGAs When you say electrically programmable? ▪ What is the difference between these main chips on these PCBs ▪ They look the same ▪ They all have some degree of customization (programmability) ▪ Some you buy already manufactured, some you program with HDL VLSI 1: HDL Based Design for FPGAs 4 When you say electrically programmable? ▪ A microprocessor/microcontroller (GAP9 from Greenwaves) ▪ This is a component off the shelf, you can buy it from the manufacturer ▪ Programmed using C/C++ or any other programming language VLSI 1: HDL Based Design for FPGAs 5 When you say electrically programmable? ▪ An ASIC designed specifically at ETH Zürich (Imperio, semester thesis) ▪ We designed every aspect of it, it was manufactured following our design ▪ HDL (SystemVerilog) was used to describe it. ▪ Imperio implements a RISC-V processor, you program it using C/C++ VLSI 1: HDL Based Design for FPGAs 6 When you say electrically programmable? ▪ An FPGA (on a Digilent FPGA board) ▪ This is a component off the shelf, you can buy it and use it. ▪ It is progammed using HDL (similar to ASIC) ▪ Any digital functionality can be mapped to it VLSI 1: HDL Based Design for FPGAs 7 When you say electrically programmable? ▪ An FPGA (on a Digilent FPGA board) ▪ This is a component off the shelf, you can buy it and use it. ▪ It is progammed using HDL (similar to ASIC) ▪ In this case we designed a processor which in turn can be programmed using C/C++ VLSI 1: HDL Based Design for FPGAs 8 Devil is in the details We use FPGAs so that we can make custom hardware easily FPGAs fill a gap between custom and off the shelf HW Processor Readily available yes Can be customized no Initial cost minimal Unit cost medium (1-1000) Performance Decent Programming C/C++ Time to program seconds VLSI 1: HDL Based Design for FPGAs 9 FPGAs fill a gap between custom and off the shelf HW Processor ASIC Readily available yes no Can be customized no yes Initial cost minimal millions Unit cost medium (1-1000) very little (0.5 - 5) Performance Decent Best Programming C/C++ HDL Time to program seconds months VLSI 1: HDL Based Design for FPGAs 10 FPGAs fill a gap between custom and off the shelf HW Processor FPGA ASIC Readily available yes yes no Can be customized no yes yes Initial cost minimal minimal millions Unit cost medium (1-1000) high (40 - 10’000) very little (0.5 - 5) Performance Decent Better Best Programming C/C++ HDL HDL Time to program seconds seconds months VLSI 1: HDL Based Design for FPGAs 11 VLSI1 We want to learn how to design custom digital hardware ▪ We may have a new/better idea that we want to implement ▪ Innovative new idea, research, or quickly prototype our idea to see if it works ▪ Higher performance, differentiation from other products ▪ Customization, again differentiation from other products ▪ ASIC is our best chance ▪ Needs high volume to be practical ▪ Design is complex and takes months to finish ▪ FPGA is readily available and can be programmed ▪ The same description for ASIC can be mapped to FPGA ▪ Immediately available ▪ High unit cost, may pay off for small volume VLSI 1: HDL Based Design for FPGAs 12 FPGA vs. ASIC – Cost vs Volume ▪ FPGA ▪ Low NRE cost ▪ High unit cost ▪ ASIC ▪ High NRE cost ▪ Low unit cost ▪ At some point they cross ▪ Crossover depends on implementation VLSI 1: HDL Based Design for FPGAs 13 This lecture is about learning how to design digital HW ▪ We need HDL to do this efficiently ▪ We want to design HW that is more efficient/better than what you can buy ▪ HDL allows us to translate our ideas into reality ▪ What we learn would work both for FPGA and ASIC flows ▪ The design philosophy we use is exactly the same ▪ HDL you use is the same for both flows ▪ Specific tools for FPGA and ASIC are slightly different (main idea is the same) ▪ In this lecture we concentrate on FPGA as implementation ▪ We will use FPGAs in exercises ▪ VLSI2 will complement this knowledge with ASIC specific design flow VLSI 1: HDL Based Design for FPGAs 14 Starting next week we will talk about HDL In the early days, we needed ‘glue logic’ ▪ Few main ICs ▪ These provide the main functionality ▪ Glue logic in between ▪ Simpler functions AND OR FFS ▪ Large part of PCB ▪ Means more parts ▪ Translates to more cost VLSI 1: HDL Based Design for FPGAs 15https://commons.wikimedia.org/wiki/File:Adaptec_ACB-4000A_SASI_card.jpg54xx and 74xx series logic gates ▪ Common in 80s, 90s ▪ Usually DIP 14-20 pins ▪ Standard functions ▪ Multiple gates in one chip ▪ 100s of different chips ▪ Glue logic designed using multiple such gates ▪ Allows simple manipulation of signals between custom ICs VLSI 1: HDL Based Design for FPGAs 16https://en.wikipedia.org/wiki/7400-series_integrated_circuits The first solution: Programmable Logic Arrays ▪ Could map any combinational circuit ▪ Programmed with min/maxterms of function ▪ Most cases was one time programmable ▪ Good for simple circuits ▪ Several 74xx could be merged into one ▪ Similar package DIP 14-28 pins ▪ Reduces component count ▪ Known under different names ▪ PLA, PLD, CPLD VLSI 1: HDL Based Design for FPGAs 17 A memory can implement any Logic function Combinational logic is represented by a truth table (e.g. full adder). ▪ Implement truth table in small memories called lookup-tables (LUTs). ▪ A function is implemented by writing all possible values that the function can take in the LUT ▪ The inputs values are used to address the LUT and retrieve the value of the function corresponding to the input values ▪ Only limitation #of inputs! Full adder circuit diagram Inputs: {A, B, CarryIn} → Outputs: {Sum, CarryOut} VLSI 1: HDL Based Design for FPGAs 18 LUT = FFs + MUY A LUT is basically a multiplexer that evaluates the truth table stored in the configuration SRAM cells . How to handle sequential logic? Add a flip-flop to the output of LUT (Clocked Storage element). This is called Basic Logic Element (BLE): circuit can now use output from LUT or from FF. VLSI 1: HDL Based Design for FPGAs 19 We can have a ‘generic’ logic block CLB 4 bits LUT 1b FF4 bits input Block with 4 bits input and 1 bit output Function define by the configuration bitstream output 0 1 16 bit ‘program’ 1 bit ‘program’ Memory (RAM/FLASH) Configuration Bitstream Optionally stores the output Implements combinational logic functions VLSI 1: HDL Based Design for FPGAs 20 Basic FPGA Architecture An FPGA chip is composed of an array of the following elements: ▪ Blocks for implementing logic ▪ Look-up table (LUT) in Logic Block: This element performs logic operations ▪ Flip-Flop (FF): This register element stores the result of the LUT ▪ Wires: These elements connect elements to one another, both logic and clock ▪ Input/Output (I/O) pads: These physically available ports get signals in and out of the FPGA. Configure LUT by writing into a memory the truth table of logic function Configure a Switch Matrix (SM) by writing into a memory the IO connectivity The logic functions and connectivity are configured post fabrication (by writing memory cells) VLSI 1: HDL Based Design for FPGAs 21Top-Down Digital VLSI Design: From Architectures to Gate-Level Circuits and FPGAs by Hubert Kaeslin The early days, Xilinx XC2064 ▪ First commercial Xilinx FPGA ▪ Launched in 1985 ▪ 2000nm technology, 5V supply ▪ Total of 64 CLBs ▪ Organized in an 8x8 array ▪ Each with a 4-input LUT ▪ And a FF ▪ 58 User I/Os ▪ Goal: to replace glue logic VLSI 1: HDL based design for FPGAs See an amazing reverse engineering report on XC2064 here http://www.righto.com/2020/09/reverse-engineering-first-fpga-chip.html P. Alfke, I. Bolsens, B. Carter, M. Santarini and S. Trimberger, \"It's an FPGA!,\" in IEEE Solid- State Circuits Magazine, vol. 3, no. 4, pp. 15-20, Fall 2011, doi: 10.1109/MSSC.2011.942449. 22 We came quite some way VLSI 1: HDL Based Design for FPGAs 23https://docs.amd.com/v/u/en-US/ultrascale-fpga-product-selection-guide 2.5 Million Look Up Tables !! Only 50’000 EUR There are also cheaper ones for 20 EUR Back to FPGA Architecture VLSI 1: HDL Based Design for FPGAs 24Top-Down Digital VLSI Design: From Architectures to Gate-Level Circuits and FPGAs by Hubert Kaeslin How do we connect an array of logic cells to each other? 25VLSI 1: HDL Based Design for FPGAsTop-Down Digital VLSI Design: From Architectures to Gate-Level Circuits and FPGAs by Hubert Kaeslin Switch (Connection) boxes VLSI 1: HDL Based Design for FPGAs 26 What is Inside a connection block? Configurable switches Xilinx XC4000 Programmable Interconnect Point (PIP) Switch box Connection hierarchy Connecting through switch boxes there are short channels (useful for connecting adjacent CLBs) and long channels (useful for connecting CLBs that are separated, this reduces routing delay for non- adjacent CLBs) VLSI 1: HDL Based Design for FPGAs 27 The exact mix/number of connections are vendor/device specific How does it work ? Mapping logic VLSI 1: HDL Based Design for FPGAs 28 Top-Down Digital VLSI Design: From Architectures to Gate-Level Circuits and FPGAs by Hubert Kaeslin How does it work ? Mapping connections VLSI 1: HDL Based Design for FPGAs 29Top-Down Digital VLSI Design: From Architectures to Gate-Level Circuits and FPGAs by Hubert Kaeslin The configuration comes at a cost ▪ An FPGA fabric is very configurable ▪ Logic function can be selected, FFs can be added to the outputs ▪ Interconnection between blocks, different distance options can be selected ▪ I/O drivers can be configured ▪ All these configurations need some logic to realize ▪ Extra cost (power, area, delay) for the configuration ▪ There is a significant perfomance difference between ASIC and FPGA ▪ We trade-off flexibility vs performance ▪ The same FPGA can be used for multiple applications ▪ Increases the volume for the FPGA manufacturing which makes it possible VLSI 1: HDL Based Design for FPGAs 30 VLSI 1: HDL Based Design for FPGAs Bottom Line: FPGA solutions are viable FPGA vs. ASIC: Factoring in Technology 31VLSI 1: HDL Based Design for FPGAs FPGA Components: input/output ▪ FPGA vendors need to appeal to a broad customer base ▪ The application is not known when you make the FPGA ▪ Customers will adapt/program as they please ▪ The resources need to be there ▪ Need to support many different ▪ I/O Voltages (1.2/1.8/2.5/3.3/5) ▪ connection speeds ▪ synchronization/delays ▪ standard interfaces 32VLSI 1: HDL Based Design for FPGAs FPGA Components: input/output ▪ The IO PAD connect the signals from the PCB to the internal logic. ▪ The IOB are organized in banks (depending on the technology and the producer the number of IOB per bank change). ▪ All the PADs in the same bank, share a common supply voltage: not all the different standard could be implemented at the same time in the same bank!!! ▪ There are special PAD for ground (GND), supplies (VCC, VCCINT, VCCAUX, etc…), clocks and for programming (JTAG). 33VLSI 1: HDL Based Design for FPGAs FPGA Components: input/output ▪ The IO Blocks (IOB) support a wide range of commercial standard (LVTTL, LVCMOS, LVDS, etc…) both single ended and differential (in that case pair of contiguous pads are used). ▪ IO Blocks also have synchronization and delay adjustment capabilities 34VLSI 1: HDL Based Design for FPGAs Moore’s Law gives us ever more transistors for FPGAs ▪ The array size of the logic blocks keeps increasing ▪ More logic, more functionality, in theory great ▪ However most designs make use of some common blocks ▪ Memories ▪ Adders / Multipliers ▪ Processors ▪ In theory these can all be mapped to logic blocks ▪ Every logic block can have 1-2 bits of memory (in FFs) ▪ But we can do better 35VLSI 1: HDL Based Design for FPGAs Why not add some pre- designed blocks into the FPGA array In a modern FPGA the array contains specialized blocks 36VLSI 1: HDL Based Design for FPGAs Memory, memory and more memory ▪ FFs in logic blocks can be used as memory ▪ Normally 1-2 FFs per logic block ▪ Not high density, but very flexible ▪ Logic blocks with more memory resources ▪ Dedicated SRAMs inside the FPGA ▪ Xilinx/AMD has 36kbit BRAMs (32k data + 4k parity) ▪ The FPGA in our exercises has 140 of these (615 kByte) ▪ These can be configured in various constellations ▪ Memory controllers for external memory ▪ Specialized high-speed controllers for DDR/SRAM ▪ Xilinx/AMD BRAM configurations ▪ 32k x 1 ▪ 16k x 2 ▪ 8k x 4 ▪ 4k x 9 (or 8) ▪ 2k x 18 (or 16) ▪ 1k x 36 (or 32) ▪ 512 x 72 (or 64) VLSI 1: HDL Based Design for FPGAs 37 Digital Signal Processing (DSP) slice VLSI 1: HDL Based Design for FPGAs 38 We will discuss arithmetic operations and use of DSP blocks in week 13AMD Technical Information Portal https://docs.amd.com/ Specialization in FPGAs: double edged sword ▪ Every vendor adds a great mix of resources ▪ Memories, adder/multipliers, even complete processors ▪ These resources are vendor specific ▪ Everyone has a different solution, different names, capabilities ▪ There are even differences between products of the same vendor ▪ There is not one FPGA ▪ Efficient FPGA design requires you to take advantage of these ▪ Tools can not always utilize these resources correctly ▪ Knowledge of the vendor specific resources is needed 39VLSI 1: HDL Based Design for FPGAs We will use AMD/Xilinx FPGAs Some parts of the lecture will refer to vendor specific features The FPGA we will use in exercises: Xilinx/AMD Zynq 7020 ▪ Quite Complex FPGA ▪ Based on Artix-7 ▪ Contains also a complete processor ▪ Only basic functions now ▪ We will talk more about the rest in Lecture 11 ▪ ZyboZ7 board contains various interfaces ▪ Designed for teaching and experimentation VLSI 1: HDL Based Design for FPGAs 40 The heart of the logic block of AMD/Xilinx Artix-7 41VLSI 1: HDL Based Design for FPGAsAMD Technical Information Portal https://docs.amd.com/ CLB LUT/FF from previous slide VLSI 1: HDL Based Design for FPGAs 42 ▪ Over years FPGAs have evolved ▪ Logic blocks optimized to perform better for the most common cases ▪ Different vendors try to offer a better set of configurable resources ▪ We will not study details ▪ Hopefully tools will be able to optimize the configuration automatically. The LUT/FF is combined into a SLICE Fast carry chain, more in Lecture 13AMD Technical Information Portal https://docs.amd.com/AMD Technical Information Portal https://docs.amd.com/ SLICEs are combined into a Configurable Logic Block (CLB) ▪ Every FPGA family has its own organization ▪ Xilinx uses CLBs as their main building block ▪ Altera equivalent would be ALM (Adaptive Logic Module) ▪ Devil is in the details ▪ There are actually different SLICEs ▪ More for logic: SLICEL ▪ More for memory: SLICEM ▪ We will not go into details VLSI 1: HDL Based Design for FPGAs 43 SLICE from previous slide Fast carry chain more in Lecture 13 Designing with FPGA ▪ FPGAs are configured using a HW design flow ▪ Describe the desired behavior using HDL ▪ Use the FPGA design automation tools to turn the HDL description into a configuration bitstream ▪ First map functions to logic blocks ▪ Then interconnect the logic blocks through the routing ▪ The configuration bits altogether form the bitstream ▪ After configuration, the FPGA operates like dedicated hardware ▪ HW design expertise needed, low abstraction level, much slower than SW design on processors! VLSI 1: HDL Based Design for FPGAs 44 Abstraction Levels in Automated Design ▪ Hand layout ▪ Confined to niches (i.e. memories, analog circuits, lib cells, and datapaths). ▪ Schematic Entry ▪ Important at its time, largely confined to analog circuit design today. ▪ RTL Synthesis ▪ SystemVerilog or VHDL code → automatic gate level netlist. Universally adopted ▪ Incorporation of Virtual Components (VCs) ▪ Purchased RTL code → automatic gate level netlist. Routine practice today ▪ Architecture Synthesis ▪ SW code → automatic RTL synthesis. Research, viable for specific fields VLSI 1: HDL Based Design for FPGAs 45 Modern design regularly uses a combination of these architecture procedural of patternmatch is signal PREST : std_Logic_Vector(0 to 5); begin allbits : for i in 1 to 5 generate process (CLK,CLR) is begin if CLR=’1’ then PREST(i) <= ’0’; elsif CLK’event and CLK=’1’ then PREST(i) <= PREST(i-1); end if; end process; end generate; PREST(0) <= INP; OUP <= true when PREST(1 to 5)= \"11011\" else false; end architecture procedural; Register-Transfer-Level Design Abstraction ▪ Define the circuit as a network of state holding elements (FF, RAMs) Held together by combinational logic ▪ Syntax allows arithmetic functions, string operations, arrays, enumerated types, ▪ Technology-independent, supports parametrization, favors reuse. ▪ Dispenses with manual logic design, fair productivity. VLSI 1: HDL Based Design for FPGAs 46 FPGA Design flow ▪ Specifications ▪ Design Entry (RTL Design) ▪ Also 3rd party IP can be added ▪ Synthesis ▪ Map RTL code to Logic blocks ▪ Optimize design ▪ Check timing requirements, resynthesis ▪ Place and route ▪ Find which logic block to use and configure the interconnect ▪ Write bitfile to FPGA device VLSI 1: HDL Based Design for FPGAs 47https://github.com/Xilinx/xup_fpga_vivado_flow The Y-chart: plenty of room at the top physical perspective back-end design behavioral perspective structural perspective front-end design behavioral perspective structural perspective electrical logic (aka gate-level) architecture system register transfer FINISH mask polygons, algorithm START subtasks data moves and operations truth tables, state graphs transfer functions transistors, wires top blocks and I/O subblocks ALUs, registers, memories gates, latches, flip-flops standard cells, macrocells placement and routing floorplan, partitioning chip or board physical perspective detailed layout Abstraction Levels in Automated Design 48VLSI 1: HDL Based Design for FPGAs System-level design ▪ Decisions taken at this stage determine the final outcome more than anything else: ▪ Specify the functionality and characteristics of the system to be ▪ Partition the system’s functionality into subtasks ▪ Explore alternative hardware and software tradeoffs ▪ Decide on make or buy for all major building blocks ▪ Decide on interfaces and protocols for data exchange ▪ Decide on data formats, operating modes, exception handling, etc. ▪ Define, model, evaluate and refine the various subtasks ▪ Result: System-level model. 49VLSI 1: HDL Based Design for FPGAs Algorithm Design ▪ Streamline computations in view of their implementation in hardware: ▪ Cut down computational burden and memory requirements ▪ Find compromises between computational complexity and accuracy ▪ Contain effects due to finite word-length computation ▪ Decide on number representation schemes ▪ Evaluate alternatives and selecting the one best suited ▪ Quantify the minimum required computational resources ▪ Result: Bit-true software model. 50VLSI 1: HDL Based Design for FPGAs Architecture design I ▪ Take important high-level decisions: ▪ Partition a computational task in view of a hardware realization. ▪ Organize the interplay of the various subtasks. ▪ Allocate hardware resources to each subtask → allocation ▪ Define datapaths and controllers. ▪ Decide between off-chip RAMs, on-chip RAMs, and registers. ▪ Decide on communication topologies and protocols (parallel, serial). ▪ Define how much parallelism to provide in hardware. ▪ Decide where to opt for pipelining and to what degree. ▪ Decide on a circuit style and fabrication process. ▪ Get a first estimate of the circuit’s size and cost. ▪ Results: High-level block diagram and preliminary floorplan. 51VLSI 1: HDL Based Design for FPGAs Architecture design II ▪ Work out lower-levels details of an architecture by deciding: ▪ How to implement arithmetic and logic units? ▪ Whether to use hardwired logic or microcode for a controller? ▪ When to use a ROM rather than random logic? ▪ What operations to perform during which clock cycle? → scheduling ▪ What operations to carry out on which processing unit? → binding ▪ What clocking discipline to adopt? ▪ What time interval to use as the basic clock period? ▪ Where to prefer a bidirectional bus over a unidirectional one? ▪ How to control the access to a bus with multiple drivers? ▪ By what test strategy to ensure testability? ▪ How to initialize the circuit? ▪ Results: Set of more detailed diagrams and verified RTL code. 52VLSI 1: HDL Based Design for FPGAs What is next ▪ FPGAs have grown quite complex ▪ We will talk more on advanced FPGAs in Lecture 11 ▪ HDL is the primary way to program FPGAs ▪ Upcoming lectures are on HDL (Lecture 3,4) and verification (Lecture 5,6) ▪ Lecture 11 will also show IP based design techniques ▪ We will also talk about High-Level Synthesis (HLS) in Lecture 12 ▪ The skill is to map your idea/agorithm to an architecture ▪ We will tak about the trick of the trade in Lecture 7, 8, and 9 ▪ How to transform your idea into something that works on FPGAs (and ASICs) VLSI 1: HDL Based Design for FPGAs 53","libVersion":"0.5.0","langs":""}