{"path":"sem1/DMath/VRL/extra/lkolmanic/DMath-lkolmanic-w11.pdf","text":"Diskrete Mathematik Übungsstunde Zusammenfassung Leon Kolmanić 04.12.2023 1 Besprechung Bonusaufgabe Häufige Fehler waren: • a |G| berechnet • Vergessen zu erwähnen, dass Polynom bei a) Grad 2 hat • Faktoren/Rechnungen vergessen Die Aufgabe ist insgesamt sehr gut ausgefallen, fast alle Abgaben sind genau dem Schema der Musterlösung gefolgt. Es gab nur häufig kleinere Fehler: Zum Einen wurde sehr oft a |G| berechnet, also im Kontext der b) (x + 3)24. Die- se Rechnung ist aber redundant, weil in jeder endlichen Gruppe a |G| = e gilt, also ein Element zur Potenz der Gruppenordnung ergibt das neutrale Element, in unserem Fall 1. Wenn wir zeigen wollen, dass ein Element ein Generator ist, zeigen wir, dass die Ordnung des Elements nicht strikt kleiner sein kann als die Gruppenordnung. Es ist dann klar, dass die Ordnung des Elements die Gruppenordnung selbst ist, weil die Ordnung eines Elements immer die Grup- penordnung teilt. Es ist natürlich nicht falsch, diese Rechnung durchzuführen. Ich wollte hier nur darauf hinweisen, dass man sie auslassen kann, um in der Prüfung Zeit zu sparen. Es ist wichtig zu beachten, dass ein Polynom ohne Nullstellen reduzibel sein kann. Ein Beispiel ist x4 + x2 + 1 über Z2. Dieses Polynom hat keine Nullstellen, aber man kann es faktorisieren mit (x2 + x + 1) 2. Deshalb sollte man bei Poly- nomen vom Grad 2 oder 3 explizit erwähnen, dass es reicht zu prüfen, ob diese Nullstellen haben, weil sie Grad 2/3 haben. Als Begründung kann man Korollar 5.30 verwenden. Es ist auch manchmal vorgekommen, dass Faktoren der Gruppenordnung verges- sen wurden. Somit wurden dann auch bei der b) einige Potenzen nicht berechnet. Um das zu vermeiden kann ich nur empfehlen, am Ende noch mal ganz genau zu schauen, ob man alle positiven Faktoren der Gruppenordnung gefunden hat. Das sind sonst verschenkte Punkte. 1 2 Logische Kalküle 2.1 Einführung in logische Kalküle Logische Kalküle sind endliche Mengen von Schlussregeln. Eine Schlussregel gibt eine Formel an, die man aus einer Menge von Formeln, den Precondtions, herlei- ten kann. Beweise mittels logischen Kalkülen sind die formalste Art von Beweis, die wir in dieser Vorlesung betrachten. Im Gegensatz zu anderen Beweisen kann man in einem logischen Kalkül nur die Schlussregeln verwenden und das gesam- te Format des Beweises ist fest vorgegeben. In einer typischen Aufgabe zu logischen Kalkülen ist ein logisches Kalkül und eine Menge von Formeln gegeben. Weiter wird eine Zielformel bestimmt, die man aus der Menge von Formeln herleiten soll. Der häufigste Fehler bei diesen Aufgaben ist, dass Lemmas/Theoreme/... aus dem Skript verwendet werden. Man könnte ja zum Beispiel denken, dass wenn man die Zielformel ¬¬A her- leiten soll, alternativ die Zielformel A herleiten kann, weil diese nach Lemma 6.1 äquivalent sind. Das ist aber in so einem Beweis nicht erlaubt, weil Lemma 6.1 keine Schlussregel in dem logischen Kalkül ist und man in dem Beweis nur diese verwenden darf. Ein weiterer häufiger Fehler ist die Annahme, dass die Schlussregeln in einem Kalkül immer sound sind. Betrachte zum Beispiel das Kalkül K = {R}, mit einer einzigen Schlussregel R: ∅ ⊢R F Die Schlussregel R hat keine Preconditions, das heisst wir können diese immer anwenden. Sie enthält ausserdem einen Platzhalter F . Da die Preconditions immer erfüllt sind, dürfen wir für F beliebige Formeln einsetzen. Wir können also zum Beispiel aus der Formelmenge {A} die Formel ¬A herleiten, indem wir die Schlussregel R einmal verwenden und F = ¬A setzen. Es ist also korrekt {A} ⊢K ¬A zu schreiben, weil es in dem Kalkül K eine Herleitung von ¬A aus der Menge {A} gibt. Natürlich widerspricht dies unserer Intuition, die uns sagt, dass ¬A natürlich keine logische Konsequenz von A ist. Aber das ist genau der Punkt: Der Begriff der logischen Konsequenz ⊨ kann zu dem Begriff der Herleitbarkeit ⊢K in einem Missverhältnis stehen. Für ⊢K ist einzig und allein entscheidend, ob die Schlussregeln im Kalkül K eine Herleitung erlauben oder nicht. Kalküle, in denen wir aus einer Menge M nur logische Konsequenzen von M ableiten können, nennen wir sound. Ausserdem nennen wir Kalküle komplett, wenn man jede logische Konsequenz von M auch tatsächlich in dem Kalkül herleiten kann. Auch diese Eigenschaft muss nicht immer erfüllt sein. Betrachte zum Beispiel das Kalkül ∅. Dieses Kalkül enthält keine Herleitungsregeln. Natürlich gilt A ∧ B ⊨ A, das kann man mittels der Wahrheitstabellen überprüfen. Aber {A ∧ B} ̸⊢∅ A weil man mangels Herleitungsregeln A in dem Kalkül ∅ nicht aus der Menge {A ∧ B} herleiten kann. Hier sind noch mal die wichtigsten Erkenntnisse zusammengefasst: 2 • In einem Beweis mit einem logischen Kalkül darf man ausschliesslich auf die Schlussregeln dieses Kalkül zurückgreifen, es ist insbesondere nicht erlaubt, Lemmas/Theoreme/... aus dem Skript zu verwenden oder den Beweis durch Argumentationen in Worten zu stützen • Beweise mittels Kalkülen folgen einem fest vorgegeben Format • In einem Kalkül kann man unter Umständen “unsinnige Konsequenzen” beweisen, davon soll man sich nicht beirren lassen. Alles, was durch die Schlussregeln erlaubt ist, darf man herleiten. 2.2 Beweis mit einem logischen Kalkül Im Folgendem betrachten wir an einem Beispiel das erwartete Format bei Kal- külbeweisen und wie die Anwendung einer Schlussregel genau abläuft. Zunächst ist das Kalkül K1 mit den folgenden Schlussregeln gegeben: ∅ ⊢R1 F → F {F } ⊢R2 G → F {F → G, F → (H → ¬G)} ⊢R3 F → ¬H Wir sollen in diesem Kalkül die Formel A → ¬¬A aus ∅ herleiten. Es ist häu- fig vorteilhaft bei diesen Aufgaben rückwärts zu arbeiten, also sich zuerst zu überlegen, welche Regel man im letzten Schritt anwenden wird. Wir können im letzten Schritt nicht die Regel R1 anwenden, weil wir mit R1 nur Implikationen herleiten können, bei denen die linke Seite der Implikation gleich der rechten ist. Aber bei A → ¬¬A ist nicht das gleiche auf beiden Seiten. Hier muss man vorsichtig sein: Mit “gleich” meine ich hier =, also die Formeln sind exakt gleich geschrieben. Ich meine nicht ≡, also dass die Formeln die gleichen Wahrheits- tabellen haben. Wenn wir hingegen R2 im letzten Schritt verwenden wollen, müssen wir im letzten Schritt F = ¬¬A und G = A setzen. Wenn wir F und G so setzen, bedeutet das, dass die Menge der Preconditions {F } = {¬¬A} ist. Wir müssen also um R2 so anzuwenden zunächst ¬¬A mit dem Kalkül herleiten. Aber jede der Schlussregeln im Kalkül erlaubt uns nur Implikationen herzulei- ten. Wir können also die Preconditions nicht erfüllen, also können wir auch R2 nicht im letzten Schritt verwenden. Nun ist klar, dass wir im letzten Schritt R3 verwenden müssen. Damit F → ¬H = A → ¬¬A gilt, müssen wir F = A und H = ¬A wählen. Hier gilt auch wieder: F → ¬H ≡ A → ¬¬A ist nicht aus- reichend. Wir müssen in einem Kalkül die geforderte Formel syntaktisch exakt herleiten. Bei R3 gibt es aber noch einen dritten Platzhalter G. Je nachdem wie wir diesen wählen, ändert sich die Menge der Preconditions. Wir wählen G = A und probieren, ob die Herleitung klappt. Falls nicht, müssen wir uns für G etwas anderes einfallen lassen. Das passiert bei solchen Aufgaben häufig: Man muss manchmal die Wahl der Platzhalter solange raten, bis man die Herleitung schafft. Wir erhalten für die Menge der Preconditions {F → G, F → (H → ¬G)} = {A → A, A → (¬A → ¬A)} 3 Gelingt es uns, alle Formeln in dieser Menge im Kalkül herzuleiten, können wir den finalen Schritt mit R3 durchführen und sind fertig. Versuchen wir zunächst A → A herzuleiten. Dafür können wir R1 verwenden. Wir wählen F = A, denn dann F → F = A → A. Die Menge der Preconditions ist leer, also können wir diesen Schritt durchführen. Formal notieren wir das so: ∅ ⊢R3 A → A (1) Jeder Beweisschritt gibt an, was unsere Preconditions sind, welche Regel wir verwenden, welche Formel wir erhalten und welche Nummer wir dieser Formel geben, damit wir sie später wiederverwenden können. Die Belegung der Platz- halter geben wir nicht an, weil diese aus den Preconditions und der erhaltenen Formel klar ist. Nun müssen wir noch A → (¬A → ¬A) herleiten. Diese Formel können wir nur mit Regel R2 herleiten, weil die linke und rechte Seite der Im- plikation verschieden sind und die rechte Seite der Implikation ¬A → ¬A nicht negiert ist. Damit G → F = A → (¬A → ¬A) gilt, müssen wir G = A und F = ¬A → ¬A wählen. Um R2 so anzuwenden brauchen wir die Precondition {F } = {¬A → ¬A} Diese können wir mit R1 herleiten. Jetzt haben wir uns den gesamten Beweis rückwärts überlegt. Nun müssen wir von vorne anfangen und Schritt für Schritt die Herleitungen durchführen. Wir müssen aufpassen, dass wir eine Herleitung nur dann machen, wenn wir alle nötigen Preconditions gesammelt haben. Formal schreiben wir den Beweis so auf: Beweis. ∅ ⊢R1 A → A (1) ∅ ⊢R1 ¬A → ¬A (2) {(2)} ⊢R2 A → (¬A → ¬A) (3) {(1), (3)} ⊢R3 A → ¬¬A Noch einmal kurz zusammengefasst, wie ein Herleitungsschritt abläuft: Wir wählen für die Platzhalter in dem Herleitungsschritt beliebige Formeln. Wir können für die Platzhalter auch Formeln wählen, die wir noch nicht hergeleitet haben. Wir haben im Beweis vorhin zum Beispiel F = A im letzten Schritt gewählt, obwohl wir A selbst nie hergeleitet haben. Wichtig ist nur, dass die Menge der Preconditions nach Einsetzen der Platzhalter nur Formeln enthält, die man schon hergeleitet hat. Falls alles passt, notieren wir den Herleitungs- schritt formal wie oben beschrieben. 4 3 Beweissysteme 3.1 Einführung in die Beweissysteme Beweissysteme sind ein sehr abstraktes Konzept. Sie sind definiert als ein Tupel (S, P, τ, ϕ), das eine Menge von Aussagen S, eine Menge von Beweisen P, eine Wahrheitsfunktion τ und eine Beweisverifikationsfunktion ϕ enthält. Obwohl wir von Aussagen und Beweisen sprechen, können die Elemente der Aussagenmen- ge/Beweismenge beliebige mathematische Objekte sein. In einem Beweissystem kann zum Beispiel N eine Aussage sein oder 4 ein Beweis sein. Beweissysteme müssen ausserdem nicht sinnvoll sein. Man könnte zum Beispiel ein Beweissy- tem definieren, in dem die Aussage “3 ist keine Primzahl” wahr ist, weil das so durch die Wahrheitsfunktion definiert wird. Ob eine Aussage in einem Beweis- system wahr ist oder ob ein Beweis ein gültiger Beweis für eine Aussage ist, wird einzig und allein durch die Wahrheitsfunktion und Beweisverifikationsfunktion bestimmt. Es gibt zwei Eigenschaften, die wir bei einem Beweissystem betrach- ten. Wir nennen ein Beweissytem sound, falls es keine falsche Aussage gibt, die einen gültigen Beweis hat. Ausserdem nennen wir ein Beweissytem komplett, falls es für jede wahre Aussage einen Beweis gibt. Was bedeutet dies ausge- drückt durch die Wahrheitsfunktion τ und die Beweisverifikationsfunktion ϕ? Eine Aussage s ist falsch, wenn τ (s) = 0. Wir sagen, dass p ein gültiger Beweis für s ist, falls ϕ(s, p) = 1. Also bedeutet die Eigenschaft sound, dass es kein s ∈ S gibt, sodass τ (s) = 0 und es ein p gibt mit ϕ(s, p) = 1. Analog bedeutet die Eigenschaft komplett, dass es für jedes s ∈ S mit τ (s) = 1 ein p gibt mit ϕ(s, p) = 1. Weil Beweissysteme ein so abstraktes Konzept sind, darf man in einem Beweis von Eigenschaften eines Beweissystems nur die Definitionen von τ und ϕ und die beiden Begriffe sound und komplett verwenden. Lemmas oder Theoreme gibt es im Skript für diese nicht. Argumente, die sich nicht auf diese Eigenschaften stützen, kommen in einem korrekten Beweis nicht vor. 3.2 Beweis durch Gegenbeispiel Wenn wir eine Aussage über Beweissysteme widerlegen sollen, machen wir das genauso wie bei allen anderen Aussagentypen. Wir geben ein Gegenbeispiel an. Wir müssen also eine Menge von Aussagen S, eine Menge von Beweisen P, eine Wahrheitsfunktion τ und eine Beweisverifikationsfunktion ϕ für alle Be- weissysteme angeben, die in unserem Gegenbeispiel vorkommen. Betrachten wir folgende falsche Behauptung, die wir widerlegen sollen: Behauptung. Seien ∏ 1 = (S1, P1, τ1, ϕ1) und ∏ 2 = (S2, P2, τ2, ϕ2) zwei Be- weissysteme. Wir definieren ein weiteres Beweissystem ∏ 3 = (S1 × S2, P1 × P2, τ3, ϕ3) mit τ3(s1, s2) = 1 def ⇐⇒ τ1(s1) ̸= τ2(s2) 5 und ϕ3((s1, s2), (p1, p2)) = 1 def ⇐⇒ ϕ1(s1, p1) ̸= ϕ2(s2, p2) Wenn ∏ 3 sound ist, dann ist ∏ 1 oder ∏ 2 sound. Die Aussagen im neuen Beweissystem 3 sind Paare von Aussagen, wobei die linke Aussage aus dem Beweissystem 1 und die rechte Aussage aus dem Beweissystem 2 kommt. Eine Aussage in Beweissystem 3 ist wahr, wenn die linke Aussage einen anderen Wahrheitswert als die rechte Aussage hat. Analoges gilt für die Beweisverifikationsfunktion. Nun ist ein Gegenbeispiel gefragt. Wir müssen Beweissysteme ∏ 1 und ∏ 2 finden, sodass ∏ 3 sound ist, aber weder ∏ 1 noch ∏ 2 sound ist. Um ein Gegenbeispiel bei so einer Aufgabe zu finden, muss man etwas herumprobieren, bis man alle Anforderungen erfüllt. Wir starten mit folgendem einfachem Beweissytem: ∏ 1 = ∏ 2 = ({♡}, {□}, τ, ϕ) τ (♡) = 0 ϕ(♡, □) = 1 In diesem System gibt es nur eine Aussage ♡ und nur einen Beweis □. Die Aussage ♡ ist falsch, weil τ (♡) = 0. □ ist aber trotzdem ein gültiger Beweis für ♡, weil ϕ(♡, □) = 1. Das heisst es gibt in dem Beweissystem eine falsche Aussage, die einen gültigen Beweis hat. Also ist dieses Beweissystem nicht sound. Wir haben also die erste Bedingung für ein Gegenbeispiel erfüllt: Sowohl ∏ 1 als auch ∏ 2 ist nicht sound. Schauen wir uns nun ∏ 3 wie in der Behauptung definiert an. Die Menge der Aussagen ist {(♡, ♡)}, weil das das kartesische Produkt {♡} × {♡} ist. Analog ist die Menge der Beweise in ∏ 3 {(□, □)}. Es gilt τ3(♡, ♡) = 0, weil τ (♡) = τ (♡). Um das zu prüfen, haben wir lediglich die Definition von τ3 benutzt, wobei in unserem Gegenbeispiel τ1 = τ2 = τ gilt. Also ist die Aussage (♡, ♡) in ∏ 3 falsch. Es gilt ausserdem ϕ3((♡, ♡), (□, □)) = 0, weil ϕ(♡, □) = ϕ(♡, □). Auch hier haben wir nur die Definition von ϕ3 eingesetzt, wobei in unserem Gegenbeispiel ϕ1 = ϕ2 = ϕ gilt. Also ist (□, □) kein gültiger Beweis für (♡, ♡). Wir halten abschliessend fest, dass es für die einzige falsche Aussage (♡, ♡) in ∏ 3 keinen gültigen Beweis gibt, weil der einzige Beweis in ∏ 3 (□, □) nicht gültig ist. Das bedeutet, dass ∏ 3 sound ist und somit ist unser Gegenbeispiel gültig. Wir müssen dieses Argument nur noch formal aufschreiben. Beweis. Die Behauptung ist falsch. Betrachte ∏ 1 = ∏ 2 = ({♡}, {□}, τ, ϕ) τ (♡) = 0 ϕ(♡, □) = 1 6 ∏1 und ∏ 2 sind beide nicht sound, weil es in beiden eine falsche Aussage ♡ gibt mit ϕ(♡, □) = 1. Es gilt nach Definition von ∏ 3 ∏ 3 = ({(♡, ♡), (□, □), τ3, ϕ3) Wegen ϕ(♡, □) = ϕ(♡, □) und der Definition von ϕ3 folgt ϕ3((♡, ♡), (□, □)) = 0 Das heisst es gibt in ∏ 3 keine Aussage, sodass es für diese Aussage einen gültigen Beweis gibt. Also kann es auch keine falsche Aussage mit einem gültigen Beweis geben. Es folgt, dass ∏ 3 sound ist. 3.3 Beweis einer wahren Eigenschaft Wenn wir eine wahre Eigenschaft über Beweissysteme zeigen wollen, dürfen wir uns nicht wie beim Widerlegen ein Beweissytem herauspicken. Wir müssen un- seren Beweis über alle beliebigen Beweissysteme führen. Wir betrachten wieder eine Aussage über die Kombination von zwei Beweissystemen. Behauptung. Seien ∏ 1 = (S1, P1, τ1, ϕ1) und ∏ 2 = (S2, P2, τ2, ϕ2) zwei Be- weissysteme. Wir definieren ein weiteres Beweissystem ∏ 3 = (S1 × S2, P1 × P2, τ3, ϕ3) mit τ3(s1, s2) = 1 def ⇐⇒ τ1(s1) = 1 oder τ2(s2) = 1 und ϕ3((s1, s2), (p1, p2)) = 1 def ⇐⇒ ϕ1(s1, p1) = 1 oder ϕ2(s2, p2) = 1 Wenn ∏ 3 komplett ist, dann ist ∏ 1 oder ∏ 2 komplett. Wenn man eine Implikation mit einer Veroderung auf der rechten Seite zeigen muss, empfiehlt sich ein indirekter Beweis. Denn es ist meist einfacher, aus einer Verundung etwas herzuleiten als eine Veroderung zu zeigen, weil das meistens auf eine Fallunterscheidung hinausläuft. Wir dürfen im Beweis also annehmen, dass ∏ 1 und ∏ 2 beide nicht vollständig sind. Dann müssen wir zeigen, dass ∏ 3 nicht vollständig ist, wir müssen also eine wahre Aussage in ∏ 3 finden, für die es keinen gültigen Beweis gibt. Beweis. Seien ∏ 1 = (S1, P1, τ1, ϕ1) und ∏ 2 = (S2, P2, τ2, ϕ2) zwei Beweissy- steme, die beide nicht vollständig sind. Weil ∏ 1 nicht vollständig ist, gibt es eine Aussage s1 ∈ S1 mit τ1(s1) = 1 sodass für alle p1 ∈ P1 ϕ1(s1, p1) = 0 gilt. Weil ∏ 2 nicht vollständig ist, gibt es eine Aussage s2 ∈ S2 mit τ1(s2) = 1 sodass für alle p2 ∈ P2 ϕ2(s2, p2) = 0 gilt. Sei nun ∏ 3 wie in der Behauptung definiert. Aus der Definition von ∏ 3 und τ1(s1) = 1 folgt τ (s1, s2) = 1. Sei nun (p1, p2) ∈ P1 × P2 beliebig. Wir haben schon gezeigt, dass ϕ1(s1, p1) = 0 und ϕ2(s2, p2) = 0. Also gilt nach der Definition von ϕ3 auch ϕ3((s1, s2), (p1, p2)) = 0 7 Insgesamt haben wir gezeigt, dass für alle (p1, p2) ∈ P1 × P2 ϕ3((s1, s2), (p1, p2)) = 0 Weil τ3(s1, s2) = 1 ist ∏ 3 nicht vollständig. Die Idee des Beweises noch mal informell zusammengefasst: Wir haben zwei Beweissysteme gegeben, die beide unvollständig sind, also wahre Aussagen oh- ne gültigen Beweis enthalten. Nennen wir diese beiden wahren Aussagen ohne Beweis s1 und s2. Nun betrachten wir die Kombination dieser zwei Beweissy- steme, in der Aussagen und Beweise Paare von Aussagen und Beweisen der ursprünglichen Beweissysteme sind. Eine Aussage in dem neuen System, also ein Aussagenpaar, ist wahr, wenn eine der beiden Aussagen im Paar wahr ist. Das Paar (s1, s2) ist deshalb eine wahre Aussage. Aber diese Aussage hat keinen Beweis, weil jedes Beweispaar (p1, p2) kein gültiger Beweis ist. Das liegt daran, dass p1 nie ein gültiger Beweis für s1 ist und p2 nie ein gültiger Beweis für s2 ist, weil s1 und s2 ja nach Annahme keinen gültigen Beweis haben. 8","libVersion":"0.5.0","langs":""}