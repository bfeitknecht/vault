{"path":"sem3/DMath/UE/s/DMath-s-u06.pdf","text":"ETH Z ¨urich, D-INFK HS 2024, 3. November 2024 Prof. Ueli Maurer Giovanni Deligios Diskrete Mathematik Solution 6 6.1 Partial Order Relations a) i) 11 and 12 are incomparable, since 11 ̸ | 12 and 12 ̸ | 11. ii) 4 and 6 are incomparable, since 4 ̸ | 6 and 6 ̸ | 4. iii) 5 and 15 are comparable, since 5 | 15. iv) 42 and 42 are comparable, since 42 | 42. b) The elements (a, b) ∈ A, such that (a, b) ≤lex (2, 5) are: (2, 1), (2, 5) and (1, n) for all n ∈ N \\ {0}. Justification: Let (a, b) ∈ A. We distinguish the following cases: Case a = 1: Since 1 | 2, we have (a, b) ≤lex (2, 5) for any b. Case a = 2: Since 1 and 5 are the only natural numbers which divide 5, we have (a, b) ≤lex (2, 5) only for b ∈ {1, 5}. Case a > 2: Since a ̸ | 2, (a, b) ≤lex (2, 5) cannot hold for any b. c) ({1, 3, 6, 9, 12}, | ) is not a lattice, since 9 and 12 do not have a common upper bound. d) (A; ̂⪯) is a poset. To prove this, we show that ̂⪯ is a partial order on A. Reflexivity: For any a ∈ A, by the reflexivity of ⪯, we have a ⪯ a, hence, a ̂⪯a. Antisymmetry: Let a, b ∈ A be such that a ̂⪯b and b ̂⪯a. This means that b ⪯ a and a ⪯ b By the antisymmetry of ⪯, it follows that a = b. Transitivity: Let a, b, c ∈ A be such that a ̂⪯b and b ̂⪯c. This means that b ⪯ a and c ⪯ b. By the transitivity of ⪯, we have c ⪯ a. Hence, a ̂⪯c. 6.2 Hasse Diagrams a) The Hasse diagrams of the posets ({1, 2, 3}; ≤) and ({1, 2, 3, 5, 6, 9}; | ) are as follows: 3 6 9 2 2 3 5 1 1 In both cases, 1 is the least and the only minimal element. In the poset ({1, 2, 3}; ≤), the greatest and the only maximal element is 3. In the poset ({1, 2, 3, 5, 6, 9}; | ) there is no greatest element. The maximal elements in this poset are 5, 6 and 9. 6.3 The Lexicographic Order For posets (A; ⪯) and (B; ⊑) the lexicographic order ≤lex on A × B is defined by (a1, b1) ≤lex (a2, b2) :⇐⇒ a1 ≺ a2 ∨ (a1 = a2 ∧ b1 ⊑ b2) We show that ≤lex is a partial order relation. Reflexivity: Take any (a1, b1) ∈ A × B. Since ⊑ is reflexive, we have b1 ⊑ b1. Hence, it is true that (a1 = a1 ∧ b1 ⊑ b1) and, thus, (a1, b1) ≤lex (a1, b1). Antisymmetry: Take any (a1, b1) and (a2, b2) in A × B such that (a1, b1) ≤lex (a2, b2) and (a2, b2) ≤lex (a1, b1). This means that a1 ≺ a2︸ ︷︷ ︸ (1) ∨ (a1 = a2 ∧ b1 ⊑ b2) ︸ ︷︷ ︸ (2) and a2 ≺ a1︸ ︷︷ ︸ (3) ∨ (a2 = a1 ∧ b2 ⊑ b1) ︸ ︷︷ ︸ (4) . We have to show that (a1, b1) = (a2, b2). The proof proceeds by case distinction. (1) and (3): We have a1 ⪯ a2 ∧ a1 ̸= a2 and a2 ⪯ a1 ∧ a2 ̸= a1. But since ⪯ is antisymmetric, it follows that a1 = a2, which is a contradiction with a1 ̸= a2. Therefore, this case cannot occur. (1) and (4): We have a1 ⪯ a2 ∧ a1 ̸= a2 and a2 = a1∧b2 ⊑ b1, which is a contradiction. Therefore, this case also cannot occur. (2) and (3): We have a1 = a2∧b1 ⊑ b2 and a2 ⪯ a1 ∧ a2 ̸= a1, which is a contradiction. Therefore, this case cannot occur as well. (2) and (4): We have a1 = a2∧b1 ⊑ b2 and a2 = a1∧b2 ⊑ b1. Since ⊑ is antisymmetric, it follows that b1 = b2. But we also have a1 = a2 and, thus, (a1, b1) = (a2, b2). Transitivity: Take any (a1, b1), (a2, b2), (a3, b3) in A × B such that (a1, b1) ≤lex (a2, b2) and (a2, b2) ≤lex (a3, b3). This means that a1 ≺ a2︸ ︷︷ ︸ (1) ∨ (a1 = a2 ∧ b1 ⊑ b2) ︸ ︷︷ ︸ (2) and a2 ≺ a3︸ ︷︷ ︸ (3) ∨ (a2 = a3 ∧ b2 ⊑ b3) ︸ ︷︷ ︸ (4) . We have to show that (a1, b1) ≤lex (a3, b3). The proof proceeds by case distinction. (1) and (3): We have a1 ≺ a2 and a2 ≺ a3. Since ⪯ is transitive we have a1 ⪯ a3. Moreover, if we had a1 = a3, the antisymmetry of ⪯ would imply that a1 = a2, a contradiction to a1 ≺ a2. Thus, a1 ̸= a3, and therefore a1 ≺ a3. Hence, (a1, b1) ≤lex (a3, b3). (1) and (4): We have a1 ≺ a2 and a2 = a3 ∧ b2 ⊑ b3. Hence, a1 ≺ a3 and, therefore, (a1, b1) ≤lex (a3, b3). (2) and (3): We have a1 = a2 ∧ b1 ⊑ b2 and a2 ≺ a3. Hence, a1 ≺ a3 and, therefore, (a1, b1) ≤lex (a3, b3). (2) and (4): We have a1 = a2 ∧ b1 ⊑ b2 and a2 = a3 ∧ b2 ⊑ b3. It follows that a1 = a3. Since ⊑ is transitive, we also have b1 ⊑ b3. Therefore, (a1, b1) ≤lex (a3, b3). 6.4 Inverses of Functions We prove the two implications separately. ( =⇒ ) Let g be a function such that g ◦ f = id. We show that f is injective. Assume that f (a) = f (b) for some a, b ∈ A. Then a = (g ◦ f )(a) (g ◦ f = id) = g(f (a)) (def. ◦) = g(f (b)) (f (a) = f (b)) = (g ◦ f )(b) (def. ◦) = b (g ◦ f = id) ( ⇐= ) Assume that f is injective. We construct a function g such that g ◦ f = id as follows. For any b ∈ Im(f ), by the injectivity of f , there exists a unique a such that f (a) = b, and we define g(b) = a. For b ̸∈ Im(f ), we define g(b) = b. We have g ◦ f = id, because for any a ∈ A, f (a) ∈ Im(f ), so g(f (a)) = a. Note: The choice g(b) = b in case b ̸∈ Im(f ) is irrelevant. For example, we could set g(b) = a0 for some fixed a0 ∈ A. 6.5 Countability For all ℓ ∈ N with ℓ ≥ 1 we show that the set Aℓ is uncountable by providing an injection ϕℓ from the uncountable set {0, 1}∞ (Theorem 3.23) to Aℓ. This strategy can be used to prove that any set is uncountable without reproducing any complicated diagonalization argument from scratch. To see why this works, suppose that an injection ϕℓ : {0, 1}∞ → Aℓ (1) exists, or equivalently (Definition 3.42) that {0, 1}∞ ⪯ Aℓ. Suppose, by contradiction, that Aℓ is countable, that is Aℓ ⪯ N. By transitivity of ⪯ (Lemma 3.15) this implies that {0, 1}∞ ⪯ N, or in other words {0, 1}∞ is countable, a contradiction. We now show that indeed, for all ℓ ∈ N with ℓ ≥ 1 an injection as in Equation (1) exists. The idea is that for any ℓ, we can simply take an infinite bit sequence and map it to the bit sequence where ℓ zeroes are added between any two values of the original sequence: for example for ℓ = 2 the sequence 111111 . . . is mapped to 100100100100 . . . . Intuitively, this works because summing the first k positions will yield a sum of at most ⌊ k ℓ ⌋ + 1. The reason is that all sequence values at positions that are not multiple of ℓ will be 0, and there are at most ⌊ k ℓ ⌋ + 1 positions that are multiples of ℓ smaller or equal to k. More formally, for all f ∈ {0, 1}∞ and for all n ∈ N we define (ϕℓ(f ))(n) = { f (k) if n = k · ℓ, 0 otherwise. (2) First, we show that for all ℓ ∈ N with ℓ ≥ 1 and for all f ∈ {0, 1}∞, indeed it is the case that ϕℓ(f ) ∈ Aℓ. For all k ∈ N (by performing division with remainder of k by ℓ) we have k = ℓ · k′ + r for some k′ ∈ N and r ∈ N with r < ℓ. Therefore k∑ i=0 (ϕ(f ))(i) = ℓ·k′ ∑ i=0 (ϕ(f ) )(i) + k∑ ℓ·k′+1 (ϕ(f ) )(i) (k = ℓ · k′ + r) = ℓ·k′ ∑ i=0 (ϕ(f ) )(i) + 0 (Equation(2)) = k′ ∑ i=0 f (i) (Equation(2)) ≤ k′ + 1 (f (i) ≤ 1 for all i ∈ N) = k − r ℓ + 1 (k = ℓ · k′ + r) ≤ k ℓ + 1 (r ≥ 0 and ℓ ≥ 0). (3) Now, we show that ϕℓ is injective for all ℓ ≥ 1. Suppose that ϕℓ(f ) = ϕℓ(g) for some f ∈ {0, 1}∞ and g ∈ {0, 1}∞. This means that for all k ∈ N it holds that f (k) = (ϕℓ(f ) )(k · ℓ) (Equation (2)) = (ϕℓ(g))(k · ℓ) (ϕℓ(f ) = ϕℓ(g)) = g(k) (Equation (2)). (4) This means that f = g and therefore ϕℓ is injective. 6.6 The Hunt for the Red October The set Z × Z of possible parameters (v, s0) is countable due to the fact that Z is countable (see Example 3.57) and Corollary 3.20. Thus, due to Theorem 3.17 there exists a bijection ψ : N → Z × Z. The strategy is to attempt the parameters in the sequence ψ(0), ψ(1), ψ(2), . . . Since ψ is a bijection, Svetlana will find the correct values (̂v, ̂s0) ∈ Z × Z in the i-th attempt (we start to count from zero), where i = ψ−1(̂v, ̂s0). Hence, Svetlana only needs finitely many attempts, so she is guaranteed to find the correct parameters in a finite time. 6.7 More Countability a) The set of all Java programs is countable. Every Java program can be seen as a finite binary sequence. That is, there is an injection from the set of all Java programs to the set {0, 1}∗ of finite binary sequences. By Theorem 3.18, this set is countable. b) This set is uncountable. To prove this, we notice that {0, 1}∞ ⊆ A, which implies that {0, 1}∞ ⪯ A (Lemma 3.15). Since {0, 1}∞ is uncountable, A must be uncountable as well (if A was countable, the transitivity of ⪯ would imply that {0, 1}∞ is countable, which is a contradiction). An alternative proof. We can also apply directly the diagonalization argument. Assume towards a contradiction that there is a bijection f : N → A. Let βi,j denote the j-th number in the i-th sequence. We define a new sequence as follows: α def = R10(β0,0 + 1), R10(β1,1 + 1), R10(β2,2 + 1), . . . , where R10(a) denotes the remainder when a is divided by 10. Of course, α ∈ A. Moreover, there is no n ∈ N such that α = f (n), since α disagrees with a sequence f (n) on position n. c) This set is uncountable. We can define an injective function f : [0, 1] → C by f (x) =(x, √1 − x2). Hence, we have [0, 1] ⪯ C. Since [0, 1] is uncountable, C must be uncountable as well (if C was countable, the transitivity of ⪯ would imply that [0, 1] is countable as well, which is a contradiction). Note: The fact that the interval [0, 1] is uncountable follows from Theorem 3.23 and the fact that any element of {0, 1}∞ can be interpreted as the binary expansion of a number in the interval [0, 1], and vice versa. d) To begin, consider the subset P ⊆ N of prime numbers and consider the inclusion function i : P → N, p ↦→ p. (5) The function i is injective, as i(p) = i(p′) clearly implies p = p′. This means P ⪯ N (Definition 3.42). Since P is infinite (hint), then P ∼ N (Theorem 3.17), or equivalently there exists a bijection between N and P. Let ϕ : N → P be such a bijective function. We prove that S is uncountable by exhibiting an injection from {0, 1}∞ to S. In what follows, we understand the set {0, 1}∞ as the set of functions N → {0, 1}. Consider the following function ψ : {0, 1}∞ → S, f ↦→ g (6) where g is defined as follows: g(n) =    1 if n = 1, 0 if n ̸= 1 and n is not prime , f (ϕ−1(n)) otherwise. (7) First of all, we prove that ψ is well defined, that is, for all f ∈ {0, 1}∞ it holds that ψ(f ) ∈ S. Let f ∈ {0, 1}∞ and let g = ψ(f ). Let n ∈ N such that g(n) = 0. There are three cases to consider. - The first case is that n = 0. In this case, for all m ∈ N we have 0 ∤ m so that there is nothing to check. - The second case is that n /∈ {0, 1} and n is not prime. In this case, if n | m then m ̸= 1 and m is not prime, so that g(m) = 0. - The last case is that n is prime. In this case, if n | m then m is not prime, so that g(m) = 0. This shows that g ∈ S. Next, we show that ψ is injective. Suppose that ψ(f ) = ψ(f ′) for some f, f ′ ∈ {0, 1}∞. Let g = ψ(f ) and g′ = ψ(f ′). This means that for all n ∈ N it holds that g(n) = g′(n). We want to show that f (n) = f ′(n) for all n ∈ N. Let n ∈ N. Since ϕ is bijective we have n = ϕ−1(p) for some p ∈ P. Therefore f (n) = f (ϕ−1(p)) (n = ϕ−1(p)) = g(p) (Definition of g) = g′(p) (g(n) = g′(n) for all n ∈ N) = f ′(ϕ−1(p)) (Definition of g) = f ′(n) (n = ϕ−1(p)). (8) This shows that ψ is injective.","libVersion":"0.3.2","langs":""}