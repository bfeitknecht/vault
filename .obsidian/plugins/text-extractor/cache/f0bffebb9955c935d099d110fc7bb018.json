{"path":"sem4/FMFP/PV/FMFP-finals/FMFP-FS13.pdf","text":"Computer Science Department D. Basin A. Summers Formal Methods and Functional Programming Exam August 9th, 2013, 14:00 – 17:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. Check that your exam papers are complete (5 assignments for the FP part, 5 assign- ments and 3 pages of background material for the FM part). 2. Only write on the exam paper and extra paper sheets which are given by the assis- tants. Write your ﬁrst and last name and your student number on every sheet of paper that you submit. 3. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no prepared notes. Do not use pencil and do not use red. 4. Write your answers in English.Write clearly in the sense of logic, language, and readability. Label all rule applications in your derivation trees and inference trees. The clarity of your arguments and explanations a↵ects your grade. 5. If you have a question regarding the meaning of a problem statement, you may ask one of the assistants in charge of the exam. 6. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 8 9 10 ∑ Max. points 7 8 9 9 12 4 8 13 9 11 90 Your points Part I: Functional Programming Formal Methods and Functional Programming, Exam, SS13 4 Assignment 1: Typing (7 points) Recall the types of the following functions and constants deﬁned in the Haskell Prelude: 0:: Num a => a True :: Bool head :: [a] -> a (==) :: Eq a => a -> a -> Bool (.) :: (b -> c) -> (a -> b) -> a -> c takeWhile :: (a -> Bool) -> [a] -> [a] [] :: [a] (:) :: a -> [a] -> [a] (a) Give the most general type for the following expressions: 1. \\x y -> x y True 2. \\x y z -> if z x then y x else x 3. \\x y -> takeWhile (x 0) y (b) For each type given below, ﬁnd an expression with exactly the same most general type. 1. (a -> a -> b) -> a -> b 2. (a -> b) -> [a] -> b 3. (Num a, Eq b) => (b -> Bool) -> [b] -> [a] Hint: Lambda abstractions, applications, and the above library functions su\u0000ce to build such expressions. Your solution may also use other functions from the Haskell Prelude. Formal Methods and Functional Programming, Exam, SS13 6 Assignment 2: Natural Deduction (8 points) Recall the following rules from natural deduction for propositional logic. \u0000,A ￿ A Ax \u0000,A ￿ B \u0000 ￿ A → B → I \u0000 ￿ A → B \u0000 ￿ A \u0000 ￿ B → E \u0000 ￿ ￿ \u0000 ￿ A ￿E \u0000,A ￿ ￿ \u0000 ￿ ¬A ¬I \u0000 ￿ ¬A \u0000 ￿ A \u0000 ￿ B ¬E \u0000 ￿ A \u0000 ￿ B \u0000 ￿ A ∧ B ∧I \u0000 ￿ A ∧ B \u0000 ￿ A ∧EL \u0000 ￿ A ∧ B \u0000 ￿ B ∧ER \u0000 ￿ A \u0000 ￿ A ∨ B ∨IL \u0000 ￿ B \u0000 ￿ A ∨ B ∨IR \u0000 ￿ A ∨ B \u0000,A ￿ C \u0000,B ￿ C \u0000 ￿ C ∨E (a) Prove ￿ ￿(A ∨ B) ∧ ¬A￿ → B using natural deduction and label each inference step with the name of the corresponding rule. (b) Give the induction rule for the following Haskell datatype as a proof rule for natural deduction. State all the necessary side conditions. data Tree a b = Leaf a | Node (Tree a b) (Tree a b) | List [b] (Tree a b) Formal Methods and Functional Programming, Exam, SS13 8 Assignment 3: Proof by Induction (9 points) Consider the following functions. take :: Integer -> [a] -> [a] take _ [] = [] -- take.1 take 0 _ = [] -- take.2 take n (x:xs) = x : take (n-1) xs -- take.3 drop :: Integer -> [a] -> [a] drop _ [] = [] -- drop.1 drop 0 xs = xs -- drop.2 drop n (x:xs) = drop (n-1) xs -- drop.3 (++) :: [a] -> [a] -> [a] [] ++ ys = ys -- app.1 (x:xs) ++ ys = x : (xs ++ ys) -- app.2 Prove by induction that for all integers n and all ﬁnite lists xs the equality (take n xs) ++ (drop n xs) = xs holds. Structure your proof clearly and justify every proof step. Formal Methods and Functional Programming, Exam, SS13 10 Assignment 4: Programming (9 points) A sequence is either empty, a single element, or concatenates two sequences. We model sequences by the following data type. data Seq a = Empty | Single a | Concat (Seq a) (Seq a) That is, a sequence is a binary tree whose leaves store nothing or a single value. Inner nodes do not store a value. The canonical fold function for Seq a is deﬁned as follows. foldSeq :: b -> (a -> b) -> (b -> b -> b) -> Seq a -> b foldSeq empty single concat = go where go Empty = empty go (Single a) = single a go (Concat l r) = concat (go l) (go r) (a) Give the result of foldSeq [] (:[]) (++) seq where seq :: Seq String is deﬁned as seq = Concat (Concat Empty (Single \"moo\")) (Concat Empty (Concat (Single \"foo\") (Single \"goo\"))) (b) Deﬁne a ﬁlter function filterSeq :: (a -> Bool) -> Seq a -> Seq a that retains only those elements of a sequence that satisfy the given predicate. Use foldSeq. (c) Deﬁne a function toSeq :: [a] -> Seq a that transforms a list into a sequence. The sequence should not contain the empty sequence except at the root node. Furthermore, the sequence should be balanced, i.e., the depth of any leaf di↵ers at most by 1 from the depth of any other leaf. Formal Methods and Functional Programming, Exam, SS13 12 Assignment 5: Programming (12 points) (a) Deﬁne a function shuffleAdjacent :: [a] -> [a] that interchanges the ﬁrst and second element of the list, the third and fourth, etc. That is, the element at index 2i is swapped with the one at index 2i +1, where 0 ≤ i< n 2 for a list of n elements. Make sure that your solution also works for inﬁnite lists. Example: shuffleAdjacent [1,2,3,4,5,6,7] = [2,1,4,3,6,5,7] (b) The Goldbach conjecture claims that every even natural number greater than two can be written as a sum of two primes. Write a function goldbach :: Int -> Bool that tests the conjecture for a given natural number (even or odd). Hint: You might ﬁnd list comprehension useful here. (c) Deﬁne a function cartesian :: [[a]] -> [[a]] that, given a list of lists [l1,l2 ...ln], calculates their Cartesian product, that is, the list of all lists [e1,e2,...en] where ei occurs in li. Example: cartesian [[1],[2,3]] = [[1,2],[1,3]] cartesian [[1,2,3],[4],[5,6]] = [[1,4,5],[1,4,6],[2,4,5],[2,4,6],[3,4,5],[3,4,6]] Hint: You might ﬁnd the functions map :: (a -> b) -> [a] -> [b] and concat :: [[a]] -> [a] useful here. Part II: Formal Methods Formal Methods and Functional Programming, Exam, SS13 15 Assignment 6 (4 points) Consider the following IMP program s: while x < y do y:= y- 1; if x < y then x:= x+ 1 else skip end end and a starting state \u0000 in which \u0000(x) =0 and \u0000(y) =2. Write a structural operational semantics (small-step semantics) derivation sequence to ﬁnd the state \u0000′ such that ￿s, \u0000￿ → ∗ 1 \u0000′ You do not need to provide the derivation trees justifying each step of your sequence. Formal Methods and Functional Programming, Exam, SS13 16 Assignment 7 (8 points) Prove that: ∀b, s, \u0000, \u0000′⋅ ￿ ￿while b do s end, \u0000￿ → \u0000′ ⇒ B[[b]]\u0000′ = ↵ Formal Methods and Functional Programming, Exam, SS13 18 Assignment 8 (13 points) The Fibonacci sequence can be described by the following recursively-deﬁned function from natural numbers to natural numbers: ﬁb(0) = ﬁb(1) =1 ∀n ⋅ n > 1 ⇒ ﬁb(n) = ﬁb(n − 1) + ﬁb(n − 2) The direct use of the recursive deﬁnition to calculate an arbitrary Fibonacci number ﬁb(n) is not a good idea, because it gives exponential time. We can achieve linear time by computing and storing both ﬁb(k − 1) and ﬁb(k) during the execution of a loop in which k starts o↵ at 1 and goes up to n: (k:=1; (res:=1; aux:=1)); while k<n do (res := res+aux; aux := res-aux); k:=k+1 end // at this point: res=fib(n) (a) Find an appropriate loop invariant and loop variant for the while loop. The loop invariant must be strong enough to guarantee the postcondition res = ﬁb(N ),where N is the initial value of the variable n. Assume N > 0. (2pts) (b) As a further optimization, assume that we have performed this computation before and have stored all the values of interest in variables o res, o aux and o n.If o n ≤ N , then the loop can begin with k = o n instead of k =1. (In the above names the preﬁx o stands for “old”). The complete program s is as follows: if n>=o_n then k:=o_n; (res:=o_res; aux:=o_aux) else k:=1; (res:=1; aux:=1) end; while k<n do (res := res+aux; aux:=res-aux); k:=k+1 end Formal Methods and Functional Programming, Exam, SS13 19 Use a proof outline to show that: ￿ { o n > 0 ∧ o res = ﬁb(o n) ∧ o aux = ﬁb(o n − 1) ∧ n = N ∧ N > 0 } s { ⇓ res = ﬁb(N )} Hint: Use the invariant and variant from your answer in part (a). (11pts) Formal Methods and Functional Programming, Exam, SS13 22 Assignment 9 (9 points) Prove the generation lemma for if,that is, ∀P, Q, b, s1,s2⋅ ￿ {P } if b then s1 else s2 end {Q} ⇔ (￿ {P ∧ b} s1 {Q}) ∧ (￿ {P ∧ ¬b} s2 {Q}) You must provide a proof; you may not use the generation lemmas shown in the lectures. Hint:You may wish to proceed by proving the two directions of the equivalence sepa- rately, i.e., by proving: (i) ∀P, Q, b, s1,s2⋅ ￿ {P } if b then s1 else s2 end {Q} ⇒ (￿ {P ∧ b} s1 {Q}) ∧ (￿ {P ∧ ¬b} s2 {Q}) and (ii) ∀P, Q, b, s1,s2⋅ (￿ {P ∧ b} s1 {Q}) ∧ (￿ {P ∧ ¬b} s2 {Q}) ⇒￿ {P } if b then s1 else s2 end {Q} Formal Methods and Functional Programming, Exam, SS13 25 Assignment 10 (11 points) (a) Consider the following program that is written in IMP together with the parallel con- struct par: x:=2; (((x:=1) par (x:=2; x:=x+2)); while true do skip end) Write a Promela model (that is, a Promela program) which mimics the step-by-step be- haviour of this IMP program, as closely as possible. (2pts) Formal Methods and Functional Programming, Exam, SS13 26 (b) Assume that we want to represent the condition x==i with the atomic proposition pi,for all i =1, 2, 3, 4. Consider the following automaton: {p1} {p2} {p3} {p4} 1 2 3 4 Note that the numbers on the states are for labelling and have no other meaning. The automaton does not behave exactly like the model of Question (a). (i) Find an LTL formula that the model of Question (a) satisﬁes, but that the automaton above does not (ii) Is your answer a safety property, a liveness property, both, or neither? Explain why. (5pts) Formal Methods and Functional Programming, Exam, SS13 27 (c) The automaton of Question (b) satisﬁes the property ￿(p3 → ￿(p3)) whose bad- preﬁx automaton is shown below: A B C ¬p3 p3 p3 p3 ¬p3 ¬p3 Construct the product of the above automaton with the one in Question (b), to show that the property is satisﬁed. Draw only reachable states. (4pts) Formal Methods and Functional Programming, Exam, SS13 29 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ∶∶= skip ￿ x:=e ￿ s; s ￿ if b then s else s end ￿ while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). Natural Semantics (Big-Step Semantics) (SkipNS) ￿skip, \u0000￿ → \u0000 (AssNS) ￿x:=e, \u0000￿ → \u0000[x ￿ A[[e]]\u0000] ￿s1, \u0000￿ → \u0000′ ￿s2, \u0000′￿ → \u0000′′ (SeqNS) ￿s1;s2, \u0000￿ → \u0000′′ ￿s1, \u0000￿ → \u0000′ (IfTNS) ∗ ￿if b then s1 else s2 end, \u0000￿ → \u0000′ ∗if B[[b]]\u0000 = tt ￿s2, \u0000￿ → \u0000′ (IfFNS) ∗ ￿if b then s1 else s2 end, \u0000￿ → \u0000′ ∗if B[[b]]\u0000 = ↵ ￿s, \u0000￿ → \u0000′ ￿while b do s end, \u0000′￿ → \u0000′′ (WhTNS) ∗ ￿while b do s end, \u0000￿ → \u0000′′ ∗if B[[b]]\u0000 = tt (WhFNS) ∗ ￿while b do s end, \u0000￿ → \u0000 ∗if B[[b]]\u0000 = ↵ Formal Methods and Functional Programming, Exam, SS13 30 Structural Operational Semantics (Small-Step Semantics) (SkipSOS) ￿skip, \u0000￿ →1 \u0000 (AssSOS) ￿x:=e, \u0000￿ →1 \u0000[x ￿ A[[e]]\u0000] ￿s1, \u0000￿ →1 \u0000′ (Seq1SOS) ￿s1;s2, \u0000￿ →1 ￿s2, \u0000′￿ ￿s1, \u0000￿ →1 ￿s′ 1, \u0000′￿ (Seq2SOS) ￿s1;s2, \u0000￿ →1 ￿s′ 1;s2, \u0000′￿ (IfTSOS)∗ ￿if b then s1 else s2 end, \u0000￿ →1 ￿s1, \u0000￿ ∗if B[[b]]\u0000 = tt (IfFSOS) ∗ ￿if b then s1 else s2 end, \u0000￿ →1 ￿s2, \u0000￿ ∗if B[[b]]\u0000 = ↵ (WhileSOS) ￿while b do s end, \u0000￿ →1 ￿if b then s;while b do s end else skip end, \u0000￿ The IMP language can be extended with the interleaving parallelism construct par, which has the following semantics: ￿s, \u0000￿ →1 ￿s′′, \u0000′￿ (Par1SOS) ￿s par s′, \u0000￿ →1 ￿s′′ par s′, \u0000′￿ ￿s, \u0000￿ →1 \u0000′ (Par2SOS) ￿s par s′, \u0000￿ →1 ￿s′, \u0000′￿ ￿s′, \u0000￿ →1 ￿s′′, \u0000′￿ (Par3SOS) ￿s par s′, \u0000￿ →1 ￿s par s′′, \u0000′￿ ￿s′, \u0000￿ →1 \u0000′ (Par4SOS) ￿s par s′, \u0000￿ →1 ￿s, \u0000′￿ Formal Methods and Functional Programming, Exam, SS13 31 Axiomatic Semantics (partial correctness) (SkipAx) {P} skip {P} (AssAx) {P[x ￿ e]} x:=e {P} {P} s1 {Q}{Q} s2 {R} (SeqAx) {P} s1;s2 {R} {b ∧ P} s1 {Q}{¬b ∧ P} s2 {Q} (IfAx) {P} if b then s1 else s2 end {Q} {b ∧ P} s {P} (WhAx) {P} while b do s end {¬b ∧ P} {P′} s {Q′} (ConsAx) ∗ {P} s {Q} ∗if P ￿ P′ and Q′ ￿ Q Axiomatic Semantics (total correctness) As for partial correctness above, except for the following rule, which replaces WhAx : {b ∧ P ∧ e = Z} s {⇓ P ∧ e <Z} (WhTotAx) ∗ {P} while b do s end {⇓ ¬b ∧ P} ∗if b ∧ P ￿ 0 ≤ e","libVersion":"0.5.0","langs":""}