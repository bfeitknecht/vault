{"path":"sem3/AuD/UE/s/AuD-u10-s.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 27 November 2023 Johannes Lengler, David Steurer Lucas Slot, Manuel Wiedmer, Hongjie Chen, Ding Jingqiu Algorithms & Data Structures Exercise sheet 10 HS 23 The solutions for this sheet are submitted at the beginning of the exercise class on 4 December 2023. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. Exercise 10.1 Eulerian tours in multigraphs (1 point). A multigraph G = (V, E) is a graph which is permitted to have multiple copies of the same edge. That is, the edges E form a multiset (a set in which elements are allowed to occur multiple times). For example, the multigraph with V = {1, 2, 3, 4} and E = {{A, B}, {A, B}, {A, D}, {B, C}, {A, C}} is depicted below. To avoid confusion, the term simple graph is sometimes used to indicate that duplicate edges are not allowed. A B CD (a) An Eulerian tour in a multigraph is a tour which visits every edge exactly once. If multiple copies of an edge exist, the tour should visit each of them exactly once. Given a multigraph G = (V, E), describe an algorithm which constructs a simple graph G′ = (V ′, E′) such that G has a Eulerian tour if and only if G′ has a Eulerian tour. The new graph should satisfy |V ′| ≤ |V | + |E|, and |E′| ≤ 2 · |E|. The runtime of your algorithm should be at most O(n + m). You are provided with the number of vertices n and an adjacency list of G (if there are multiple edges between v, w ∈ V , then w appears that many times in the list of neighbours of v). Solution: The idea is to subdivide each edge of G. For the construction, it is convenient to first number the edges E = {e1, e2, . . . , e|E|}. For each k, we write vk, wk for the endpoints of ek (i.e., ek = {vk, wk}). Now, to construct V ′, we start with all vertices in V , and then add a vertex v′ k for each edge ek ∈ E, 1 ≤ k ≤ |E|. Then, the edges E′ are given by: E′ = |E|⋃ k=1 {e1 k, e 2 k}, where we set e 1 k = {vk, v′ k}, e 2 k = {wk, v′ k}. See the picture below for an illustration of this procedure for the multigraph example above. A B CD Note that G′ = (V ′, E′) satisfies the required bounds on the number of vertices and edge, and that our algorithm runs in time O(n + m). It remains to see that G has an Eulerian tour if and only G′ does. First, if G has an Eulerian tour T = (ej1, ej2, . . . , ej|E|), then we can construct an Eulerian tour T ′ in G′ by replacing each ejk by the two edges e1 jk , e2 jk (in the correct order). On the other hand, if T ′ is an Eulerian tour in G′, then we note that for any k, the edges e1 k, e2 k must appear directly adjacent in T ′ (in either order), since they are the only edges that have v′ k as an endpoint. But then we may obtain an Eulerian tour in G by simply replacing all these pairs by the edge ek. (b)* Let G = (V, E) be a simple graph, and let f : E → N ∪ {0} be a function. A Eulerian f -tour of G is a tour which visits each edge e ∈ E exactly f (e) times. Describe an algorithm which constructs a simple graph G′ = (V ′, E′) such that G has a Eulerian f -tour if and only if G′ has a Eulerian tour. The new graph should satisfy |V ′| ≤ |V | + ∑ e∈E f (e), and |E′| ≤ 2 ∑ e∈E f (e). The runtime of your algorithm should be at most O(n + m + ∑ e∈E f (e)). Solution: To construct G′, first, we remove all edges e from G with f (e) = 0. Then, we construct a multigraph H = (V, F ), where F contains exactly f (e) copies of each edge in G. Note that |F | = ∑ e∈E f (e). Note also that, by definition, an Eulerian tour exists in H if and only if a Eulerian f -tour exists in G. Finally, we use part (a) to convert H into a simple graph G′ = (V ′, E′), where we know that |V ′| ≤ |V | + |F | = |V | + ∑ e∈E f (e) and |E′| ≤ 2 · |F | = 2 · ∑ e∈E f (e). Guidelines for correction: Award 1/2 points for a correct construction, and 1/2 points for a correct proof of the iff-statement. Exercise 10.2 Depth-first search (1 point). Execute a depth-first search (Tiefensuche) on the following graph. Use the algorithm presented in the lecture. Always do the calls to the function “visit” in alphabetical order, i.e. start the depth-first search from A and once “visit(A)” is finished, process the next unmarked vertex in alphabetical order. When processing the neighbors of a vertex, also process them in alphabetical order. 2 A B H F G E I C D (a) Mark the edges that belong to the depth-first forest (Tiefensuchwald) with a “T” (for tree edge). Solution: In the following, both the solution to subtask (a) and the solution to subtask (d) are showed. A B H F G E I C DT T F B T F TF T T C T C CC C C (b) For each vertex in the depth-first forest, give its pre- and post-number. Solution: A(1,16) B(5,6) C(2,13) D(3,8) E(4,7) F(14,15) G(9,12) H(10,11) I(17,18). (c) Give the vertex ordering that results from sorting the vertices by pre-number. Give the vertex ordering that results from sorting the vertices by post-number. Solution: Pre-ordering: A, C, D, E, B, G, H, F, I. Post-ordering: B, E, D, H, G, C, F, A, I. 3 (d) Mark every forward edge (Vorw¨artskante) with an “F”, every backward edge (R¨uckw¨artskante) with a “B”, and every cross edge (Querkante) with a “C”. Solution: See above in the solution to part (a). (e) Does the above graph have a topological ordering? If yes, write down the topological ordering we get from the above execution of depth-first search; if no, argue how we can use the above execution of depth-first search to find a directed cycle. Solution: The decreasing order of the post-numbers gives a topological ordering whenever the graph is acyclic. This is the case if and only if there are no back edges. If there is a back edge, then to- gether with the tree edges between its end points it forms a directed cycle. In our graph, the only back edge is B → A, and the tree edges from A to B are A → C, C → D, D → E and E → B. Together they form the directed cycle (A → C → D → E → B → A). (f) Draw a scale from 1 to 18, and mark for every vertex v the interval Iv from pre-number to post- number of v. What does it mean if Iu ⊂ Iv for two different vertices u and v? Solution: 1 16A 2 13C 3 8D 4 7E 5 6B 9 12G 10 11H 14 15F 17 18I If Iu ⊂ Iv for two different vertices u and v, then u is visited during the call of visit(v). (g) Consider the graph above where the edge from B to A is removed and an edge from F to I is added. How does the execution of depth-first search change? Does the graph have a topological ordering? If yes, write down the topological ordering we get from the execution of depth-first search; if no, argue how we can use the execution of depth-first search to find a directed cycle. If you sort the vertices by pre-number, does this give a topological sorting? Solution: The execution of the depth-first search only changes in the last step, where I is visited from F instead of starting the call of “visit(I)” after completing “visit(A)”. This gives the following post-ordering: B, E, D, H, G, C, I, F, A. Since the graph has no back edges anymore, it has a topological ordering. The topological ordering we get from the execution of the depth-first search (reversed post-ordering) is: A, F, I, C, G, H, D, E, B. The pre-ordering is A, C, D, E, B, G, H, F, I; it does not give a topological ordering, since there is for example the edge (G, B) in the graph. 4 Guidelines for correction: The following 5 elements are important in this exercise. If all of them are solved correctly, award 1 point. If at least 3 are solved correctly, award 1/2 point. • Labeling the graph in parts (a) and (d). • Determining the pre- and post numbers as well as the pre- and post orderings in parts (b) and (c). • Finding a directed cycle in part (e) using the execution of the DFS. • Mentioning what it means if Iu ⊂ Iv in part (f). • Answering the three question in part (g). Exercise 10.3 Driving on highways. In order to encourage the use of train for long-distance traveling, the Swiss government has decided to make all the m highways between the n major cities of Switzerland one-way only. In other words, for any two of these major cities C1 and C2, if there is a highway connecting them it is either from C1 to C2 or from C2 to C1, but not both. The government claims that it is however still possible to drive from any major city to any other major city using highways only, despite these one-way restrictions. (a) Model the problem as a graph problem. Describe the set of vertices V and the set of edges E in words. Reformulate the problem description as a graph problem on the resulting graph. Solution: V is the set of major cities in Switzerland (which is of size |V | = n), and there is a directed edge from u ∈ V to v ∈ V if and only if there is a highway going from city u to city v. The corresponding graph problem is to determine whether for any two vertices u, v ∈ V , there is a (directed) path from u to v in G = (V, E). (b) Describe an algorithm that verifies the correctness of the claim in time O(n + m). Argue why your algorithm is correct and why it satisfies the runtime bound. Hint: You can make use of an algorithm from the lecture. However, you might need to modify the graph described in part (a) and run the algorithm on some modified graph. Solution: The algorithm is the following. Let v0 ∈ V be any vertex in the graph. We first run DFS starting from vertex v0 on the graph G described in part (a), and denote by V0 the set of vertices that were visited by the DFS during “visit(v0)” (including v0 itself). Then, we define a new graph G′ = (V, E′) with the same vertices, and whose edges are given by the reversed edges of G, i.e. we have E′ = {(v, u) ∈ V 2 : (u, v) ∈ E}. We run DFS again starting from vertex v0 on the graph G′, and denote by V ′ 0 the set of vertices that were visited by the DFS (again only during “visit(v0)” and including v0). The algorithm outputs that the claim is correct if V0 = V = V ′ 0, and that the claim is false otherwise. Note that the first DFS takes time O(|V | + |E|), constructing the graph G′ takes times O(|V | + |E|) and the second DFS takes also time O(|V | + |E′|). Since |V | = n and |E′| = |E| = m the total runtime is indeed O(n + m). For correctness, we have to show the equivalence of the following two statements: (1) For any two vertices u, v ∈ V , there is a (directed) path from u to v in G = (V, E). (2) V0 = V and V ′ 0 = V . 5 (1) =⇒ (2): Note that V0 is the set of vertices v for which there is a directed path from v0 to v in G. By (1), there is a path from v0 to v for all vertices v ∈ V , and thus V0 = V . On the other hand, V ′ 0 is the set of all vertices v for which there is a directed path from v to v0 in G. Indeed, if v ∈ V ′ 0, this means that in the graph G′ with reversed edges there is a path from v0 to v, which corresponds to a path from v to v0 in the original graph G. Again by (1), we conclude that V ′ 0 = V . Together, these show (2). (2) =⇒ (1): Let u, v ∈ V . Since V ′ 0 = V and we have seen that V ′ 0 is the set of vertices from which we can reach v0 in G, we know there is a directed path Pu from u to v0 in G. Since V0 = V and V0 is the set of vertices that we can reach from v0 in G, we know there is a directed path Pv from v0 to v in G. Concatenating the paths Pu and Pv, we obtain a directed walk from u to v in G. Since the existence of a walk from u to v is equivalent to the existence of a path from u to v, this shows (1). Exercise 10.4 Strongly connected components (1 point). Let G = (V, E) be a directed graph with n vertices and m edges. Recall from Exercise 9.5 that two distinct vertices v, w ∈ V are strongly connected if there exist both a directed path from v to w, and from w to v. The vertices of G can be partitioned into disjoint subsets V1, V2, . . . , Vk ⊆ V with V = V1∪V2∪. . .∪Vk, such that any two distinct vertices v, w ∈ V are strongly connected if and only if they are in the same subset Vℓ, for some 1 ≤ ℓ ≤ k. The subsets Vℓ are called the strongly connected components of G. As in Exercise 9.5, you are provided with the number of vertices n, and the adjacency list Adj of G. (a) Describe an algorithm that outputs the strongly connected components of G in time O(n · (n + m)). Hint: Apply the algorithm of Exercise 9.5 several times. After each application, remove a vertex from G. Solution: For each v ∈ V , create a list Lv = [v]. We iteratively apply the following procedure: (i) Apply the algorithm of Exercise 9.5 to find two strongly connected vertices, say v, w in G. If no such vertices exist, stop and output Lv for each vertex v that is still in G. (ii) Set Lv ← Lv ∪ Lw. (iii) For every in-neighbor x of w (except possibly v) add an edge (x, v) to G. For every out- neighbor y of w (except possibly v) add an edge (v, y) to G. Then remove w from G. For the runtime of the algorithm, note that in each iteration, one vertex is removed from G, and so there can be at most n iterations. Each iteration can be executed in time O(n + m), leading to total runtime O(n · (n + m)). For correctness, note first that, at any point during the algorithm, for any vertex v still in G, all elements of the list Lv are strongly connected to v. Second, note that after removing w in step, and adding the new edges in step (iii), we have not changed strong connectivity of any of the remaining vertices. We conclude that, when the algorithm terminates, the lists Lv of each remaining vertex v contains the strongly connected component of G to which v belongs. It turns out that we can find the strongly connected components of G in time O(n + m). In the rest of the exercise we construct an algorithm to do so. 6 (b)* Let L = [v1, v2, . . . , vn] be a list containing the vertices of G in the reversed post-order of a DFS. Show that L has the following property: ‘For any distinct v, w ∈ V , if there is a directed path from v to w, then (1) v and w are strongly connected; and/or (2) there exists a u ∈ V which is in the same strongly connected component as v, and which appears before w in L.’ Remark. You are allowed to use this part in the rest of the exercise, even if you do not solve it. (c) Let ←− G = (V, ←− E ) be the directed graph obtained by inverting all edges in G. Let v1 be the first element of L. Let W ⊆ V be the set of vertices w for which there is a directed path from v1 to w in ←− G . Show that W is a strongly connected component of G. Solution: Let Vv1 be the strongly connected component to which v1 belongs. For any w ∈ Vv1, there must be a directed path from w to v1 in G, by definition. But then there is a directed path from v1 to w in ←− G , meaning w ∈ W . So, Vv1 ⊆ W . Now let w ∈ W . By definition, there is a directed path from w to v1 in G. By part (b), we know this means that either v and w are strongly connected, or there exists a u ∈ V which appears before v1 in L, and is strongly connected to w. But v1 is the first element of L, and so we must have that v and w are strongly connected, i.e., w ∈ Vv1. So, Vv1 ⊇ W . (d) Describe an algorithm that outputs all strongly connected components of G. The runtime of your algorithm should be at most O(n + m). Prove that your algorithm is correct, and achieves the desired runtime. Hint: Use DFS on the inverted graph ←− G . Make visit-calls based on the list L. Solution: We first compute the list L as in the above, and then we apply DFS on ←− G , with two modifications: (i) We always call visit on the left-most unmarked vertex v ∈ V in L. (ii) We count the number k of (outer) calls made to visit. Whenever we reach an unmarked vertex in the k-th call to visit, we mark that vertex with this number. The total runtime of our algorithm is O(n + m) (as we traverse G only twice using DFS). We claim that when the algorithm terminates, the strongly connected components of G are given by the sets Vk := {v ∈ V : mark(v) = k}. That is, they are exactly the unmarked vertices reached by each of the (outer) calls to visit. To prove the claim, we use induction on k. We have shown the base case in part (c). Now let k > 1, and let W be the set of unmarked vertices reached by the k-th (outer) call visit(vk) during our algorithm. We show first W ⊆ Vk, the strongly connected component containing vk. Let w ∈ W . Then, by definition, there is a directed path from w to v1 in G. By part (b), we know this means that either v and w are strongly connected, or there exists a u ∈ V which appears before v1 in L, and is strongly connected to w. In the former case we are done. In the latter, note that u must have already been reached in an earlier visit call (as it appears before v1, and we make outer visit calls in order of L). 7 But that is not possible, as, by induction1, this means w should have already been marked (since it is in the same strongly connected component as u). So we cannot be in the latter case. To show that W ⊇ Vk, let u ∈ Vk. Then by definition, there is a directed path P from vk to u in ←− G . If no vertex on this path was already marked (before the current call to visit), then u ∈ W , and we are done. So suppose for a contradiction that there is a marked vertex x in P . Note that, since u ∈ Vk, there is a directed cycle containing u and vk in G. But also, there is directed path from u to x and from x to vk in G. That is, vk is strongly connected to x. But then, using induction, vk should have already been marked in an earlier call to visit (the one that marked x). Guidelines for correction: The following points are important in this exercise: • In part (a), the correct construction. • In part (a), a proof of correctness. • In part (c), a correct proof of ⊆. • In part (c), a correct proof of ⊇. • In part (d), a correct algorithm. • In part (d), a correct proof of ⊆. • In part (d), a correct proof of ⊇. If at least 2 of these bullets are present, award 1/2 points. If at least 5 are present, award 1 point. Exercise 10.5 Shortest paths by hand. Dijkstra’s algorithm allows to find shortest paths in a directed graph when all edge costs are nonnega- tive. Here is a pseudo-code for that algorithm: Algorithm 1 Input: a weighted graph, represented via c(·, ·). Specifically, for two vertices u, v the value c(u, v) represents the cost of an edge from u to v (or ∞ if no such edge exists). function Dijkstra(G, s) d[s] ← 0 ▷ upper bounds on distances from s d[v] ← ∞ for all v ̸= s S ← ∅ ▷ set of vertices with known distances while S ̸= V do choose v∗ ∈ V \\ S with minimum upper bound d[v∗] add v∗ to S update upper bounds for all v ∈ V \\ S: d[v] ← minpredecessor u∈S of v d[u] + c(u, v) (if v has no predecessors in S, this minimum is ∞) 1It is not necessarily true that u was marked in the previous call to visit (it could have been any earlier call). However, we use here that the induction hypothesis holds for all earlier calls. This principle is called strong induction. 8 We remark that this version of Dijkstra’s algorithm focuses on illustrating how the algorithm explores the graph and why it correctly computes all distances from s. You can use this version of Dijkstra’s algorithm to solve this exercise. In order to achieve the best possible running time, it is important to use an appropriate data structure for efficiently maintaining the upper bounds d[v] with v ∈ V \\ S as you will see in the lecture on November 30. In the other exercises/sheets and in the exam you should use the running time of the efficient version of the algorithm (and not the running time of the pseudocode described above). Consider the following weighted directed graph: s a b c d e 5 3 10 1 8 5 9 3 1 2 (a) Execute the Dijkstra’s algorithm described above by hand to find a shortest path from s to each vertex in the graph. After each step (i.e. after each iteration of the while-loop), write down: 1) the upper bounds d[u], for u ∈ V , between s and each vertex u computed so far, 2) the set M of all vertices for which the minimal distance has been correctly computed so far, 3) and the predecessor p(u) for each vertex in M . Solution: In the beginning: d[s] = 0, d[a] = d[b] = d[c] = d[d] = d[e] = ∞, M = ∅. After we choose s: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 10, d[d] = d[e] = ∞, M = {s}, there is no p(s). After we choose b: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 8, d[d] = d[e] = ∞, M = {s, b}, there is no p(s), p(b) = s. After we choose a: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 6, d[d] = 13, d[e] = ∞, M = {s, a, b}, there is no p(s), p(a) = p(b) = s. After we choose c: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 6, d[d] = 13, d[e] = 9, M = {s, a, b, c}, there is no p(s), p(a) = p(b) = s, p(c) = a. After we choose e: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 6, d[d] = 11, d[e] = 9, M = {s, a, b, c, e}, there is no p(s), p(a) = p(b) = s, p(c) = a, p(e) = c. After we choose d: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 6, d[d] = 11, d[e] = 9, M = {s, a, b, c, d, e}, there is no p(s), p(a) = p(b) = s, p(c) = a, p(d) = e, p(e) = c. 9 We find the shortest path by backtracking them using the predecessors. In this example, they are given by s, s → a, s → b, s → a → c, s → a → c → e → d and s → a → c → e. (b) Change the weight of the edge (a, c) from 1 to −1 and execute Dijkstra’s algorithm on the new graph. Does the algorithm work correctly (are all distances computed correctly) ? In case it breaks, where does it break? Solution: The algorithm works correctly. In the beginning: d[s] = 0, d[a] = d[b] = d[c] = d[d] = d[e] = ∞. After we choose s: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 10, d[d] = d[e] = ∞. After we choose b: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 8, d[d] = d[e] = ∞. After we choose a: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 4, d[d] = 13, d[e] = ∞. After we choose c: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 4, d[d] = 13, d[e] = 7. After we choose e: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 4, d[d] = 9, d[e] = 7. After we choose d: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 4, d[d] = 9, d[e] = 7. (c) Now, additionally change the weight of the edge (e, b) from 1 to −6 (so edges (a, c) and (e, b) now have negative weights). Show that in this case the algorithm doesn’t work correctly, i.e. there exists some u ∈ V such that d[u] is not equal to a minimal distance from s to u after the execution of the algorithm. Solution: The algorithm doesn’t work correctly, for example, the distance from s to b is 1 (via the path s-a-c- e-b), but the algorithm computes exactly the same values of d[·] as in part (b), so d[b] = 3. 10","libVersion":"0.3.2","langs":""}