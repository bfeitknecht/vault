{"path":"sem2a/DDCA/VRL/slides/DDCA-L20-out-of-order-execution.pdf","text":"Digital Design & Computer Arch. Lecture 20: Out-of-Order Execution Frank K. Gürkaynak Mohammad Sadrosadati Prof. Onur Mutlu ETH Zürich Spring 2024 10 May 2024 Agenda for Today Lecture  Prior to last week: Microarchitecture Fundamentals  Single-cycle Microarchitectures  Last week: Pipelining  Pipelining  Pipelined Processor Design  Control & Data Dependence Handling  Precise Exceptions: State Maintenance & Recovery  Out-of-Order Execution  Out-of-Order Execution  Issues in OoO Execution: Load-Store Handling, … 2 Micro-architecture SW/HW Interface Program/Language Algorithm Problem Logic Devices System Software Electrons Readings  Past weeks & today  Pipelining  H&H, Chapter 7.5  Pipelining Issues  H&H, Chapter 7.7, 7.8.1-7.8.3  This week  Out-of-order execution  H&H, Chapter 7.8-7.9  Smith & Sohi, “The Microarchitecture of Superscalar Processors,” Proceedings of the IEEE, 1995  More advanced pipelining  Interrupt and exception handling  Out-of-order and superscalar execution concepts 3 Pipelining and Precise Exceptions: Preserving Sequential Semantics Multi-Cycle Execution  Not all instructions take the same amount of time in the “execute stage” of the pipeline  Idea: Have multiple different functional units that take different number of cycles  Can be pipelined or not pipelined  Can let independent instructions start execution on a different functional unit before a previous long-latency instruction finishes execution 5 F D E ? E E E E E E E E E E E E E E E E E E E E . . . Integer add Integer mul FP mul Load/store Issues in Pipelining: Multi-Cycle Execute  Instructions can take different number of cycles in EXECUTE stage  Integer ADD versus Integer DIVide  What is wrong with this picture in a Von Neumann architecture?  Sequential semantics of the ISA NOT preserved!  What if DIV incurs an exception? (e.g., DIV by zero) 6 F D E W F D E WE E E E E E EDIV R4  R1, R2 ADD R3  R1, R2 F D E W F D E W F D E W F D E W DIV R2  R5, R6 ADD R7  R5, R6 F D E WE E E E E E E Exception-causing instruction Exceptions and Interrupts  “Unplanned” changes or interruptions in program execution  Due to internal problems in execution of the program  Exceptions  Due to external events that need to be handled by the processor  Interrupts  Both exceptions and interrupts require  stopping of the current program  saving the architectural state  handling the exception/interrupt  switch to handler  (if possible and makes sense) returning back to program execution 7 Exceptions and Interrupts: Examples  Exception examples  Divide by zero  Overflow  Undefined opcode  General protection (or access protection)  Page fault  …  Interrupt examples  I/O device needing service (e.g., keyboard input, video input)  (Periodic) system timer expiration  Power failure  Machine check  … 8 Exceptions vs. Interrupts  Cause  Exceptions: internal to the running thread  Interrupts: external to the running thread  When to Handle  Exceptions: when detected (and known to be non-speculative)  Interrupts: when convenient  Except for very high priority ones  Power failure  Machine check (error)  Priority: process (exception), depends (interrupt)  Handling Context: process (exception), system (interrupt) 9 Precise Exceptions/Interrupts  The architectural state should be consistent (precise) when the exception/interrupt is ready to be handled 1. All previous instructions should be completely retired 2. No later instruction should be retired Retire = commit = finish execution and update arch. state 10 DIV R4  R1, R2 ADD R3  R1, R2 DIV R2  R5, R6 ADD R7  R5, R6 Precise state (clean separation of sequential instructions) Checking for and Handling Exceptions in Pipelining  When the oldest instruction ready-to-be-retired is detected to have caused an exception, the control logic  Ensures architectural state is precise (register file, PC, memory)  Flushes all younger instructions in the pipeline  Saves PC and registers (as specified by the ISA)  Redirects the fetch engine to the appropriate exception handling routine 11 Aside: From the x86-64 ISA Manual 12https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html Why Do We Want Precise Exceptions?  Semantics of the von Neumann model ISA specifies it  Remember von Neumann vs. Dataflow  Aids software debugging  Enables (easy) recovery from exceptions  Enables (easily) restartable processes  Enables traps into software (e.g., software implemented opcodes) 13 Multi-Cycle Execute: More Complications  Instructions can take different number of cycles in EXECUTE stage  This complicates exception/interrupt handling  What is wrong with this picture in a Von Neumann architecture?  Sequential semantics of the ISA NOT preserved!  What if DIV incurs an exception? (e.g., DIV by zero) 14 F D E W F D E WE E E E E E EDIV R4  R1, R2 ADD R3  R1, R2 F D E W F D E W F D E W F D E W DIV R2  R5, R6 ADD R7  R5, R6 F D E WE E E E E E E F D E W Exception-causing instruction Ensuring Precise Exceptions in Pipelining  Idea: Make each operation take the same amount of time  Downside  Worst-case instruction latency determines all instructions’ latency  What about memory operations?  Each functional unit takes worst-case number of cycles? 15 F D E W F D E WE E E E E E E F D E W F D E W F D E W F D E W F D E W E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E DIV R3  R1, R2 ADD R4  R1, R2 Solutions: Supporting Precise Exceptions  How do we support precise exceptions in the presence of instructions completing out of program order?  Reorder buffer  History buffer  Future register file  Checkpointing  Smith and Plezskun, “Implementing Precise Interrupts in Pipelined Processors,” IEEE Trans on Computers 1988 and ISCA 1985. 16 We will not cover these See suggested lecture video from Spring 2015 Also see backup slides Solution I: Reorder Buffer (ROB)  Idea: Complete instructions out-of-order, but reorder them before making results visible to architectural state  When instruction is decoded, it reserves the next-sequential entry in a special buffer called the Reorder Buffer (ROB)  When instruction completes, it writes result into ROB entry  When instruction oldest in ROB and it has completed without exceptions, its result moved to reg. file or memory 17 Register File Func Unit Func Unit Func Unit Reorder Buffer (ROB) Instruction Cache ROB is implemented as a circular queue in hardware Reorder Buffer  A hardware structure that keeps information about all instructions that are decoded but not yet retired/committed 18 Oldest instruction (pointer to ROB entry that contains information about oldest instruction in the machine) Youngest instruction ROB is implemented as a circular queue in hardware Entry 0 Entry 1 Entry 2 Entry 8 Entry 14 Entry 15 Entry 13Entry Valid?Destreg IDDestreg valueDestreg written? What’s in a ROB Entry?  Everything required to:  correctly reorder instructions back into the program order  update the architectural state with the instruction’s result(s), if instruction can retire without any issues  handle an exception/interrupt precisely, if an exception/interrupt needs to be handled before retiring the instruction  Need valid bits to keep track of readiness of the result(s) and find out if the instruction has completed execution 19 V DestRegID DestRegVal StoreAddr StoreData PC Valid bits for reg/data + control bits Exception? Reorder Buffer: Independent Operations  Result first written to ROB on instruction completion  Result written to register file at commit time  What if a later instruction needs a value in the reorder buffer?  One option: stall the operation  stall the pipeline  Better: Read the value from the reorder buffer. How? 20 F D E W F D E RE E E E E E E F D E W F D E R F D E R F D E R F D E RE E E E E E E W R R W W W W Reorder Buffer: How to Access?  A register value can be in the register file, reorder buffer, (or bypass/forwarding paths) 21 Register File Func Unit Func Unit Func UnitReorder Buffer Instruction Cache bypass paths Content Addressable Memory (searched with register ID, which is part of the content of an entry) Random Access Memory (indexed with Register ID, which is the address of an entry) Reorder Buffer Example 22 Oldest instruction Youngest instruction Entry 0 Entry 1 Entry 2 Entry 8 Entry 14 Entry 15 Entry 13 R0 R1 R2 R3 R4 R5 R6 R7 Register File (RF) Reorder Buffer (ROB)Value Valid?ValueEntry Valid?Destreg IDDestreg valueDestreg written? Initially: all registers are valid in RF & ROB is empty Simulate: MUL R1, R2  R3 MUL R3, R4  R11 ADD R5, R6  R3 ADD R3, R8  R12 Simplifying Reorder Buffer Access  Idea: Use indirection  Access register file first (check if the register is valid)  If register not valid, register file stores the ID of the reorder buffer entry that contains (or will contain) the value of the register  Mapping of the register to a ROB entry: Register file maps the register to a reorder buffer entry if there is an in-flight instruction writing to the register  Access reorder buffer next  Now, reorder buffer does not need to be content addressable 23 Reorder Buffer Example 24 Oldest instruction Youngest instruction Entry 0 Entry 1 Entry 2 Entry 8 Entry 14 Entry 15 Entry 13 R0 R1 R2 R3 R4 R5 R6 R7 Register File (RF) Reorder Buffer (ROB)Value Valid?ValueEntry Valid?Destreg IDDestreg valueDestreg written? Initially: all registers are valid in RF & ROB is empty Simulate: MUL R1, R2  R3 MUL R3, R4  R11 ADD R5, R6  R3 ADD R3, R8  R12 Tag (pointer to ROB entry) Pipeline with Reorder Buffer Data Dependence Types 26 Flow dependence r3  r1 op r2 Read-after-Write r5  r3 op r4 (RAW) Anti dependence r3  r1 op r2 Write-after-Read r1  r4 op r5 (WAR) Output dependence r3  r1 op r2 Write-after-Write r5  r3 op r4 (WAW) r3  r6 op r7 Important: Register Renaming with a Reorder Buffer  Output and anti dependences are not true dependences  WHY? The same register refers to values that have nothing to do with each other  They exist due to lack of register ID’s (i.e. names) in the ISA  The register ID is renamed to the reorder buffer entry that will hold the register’s value  Register ID  ROB entry ID  Architectural register ID  Physical register ID  After renaming, ROB entry ID used to refer to the register  This eliminates anti and output dependences  Gives the illusion that there are a large number of registers 27 Register Renaming Example (On Your Own)  Assume  Register file has a pointer to the reorder buffer entry that contains or will contain the value, if the register is not valid  Reorder buffer works as described before  Where is the latest definition of R3 for each instruction below in sequential order? LD R0(0)  R3 LD R3, R1  R10 MUL R1, R2  R3 MUL R3, R4  R11 ADD R5, R6  R3 ADD R3, R8  R12 28 Reorder Buffer Example 29 Oldest instruction Youngest instruction Entry 0 Entry 1 Entry 2 Entry 8 Entry 14 Entry 15 Entry 13 R0 R1 R2 R3 R4 R5 R6 R7 Register File (RF) Reorder Buffer (ROB)Value Valid?ValueEntry Valid?Destreg IDDestreg valueDestreg written? Initially: all registers are valid in RF & ROB is empty Tag (pointer to ROB entry) Simulate: LD R0(0)  R3 LD R3, R1  R10 MUL R1, R2  R3 MUL R3, R4  R11 ADD R5, R6  R3 ADD R3, R8  R12 In-Order Pipeline with Reorder Buffer  Decode (D): Access regfile/ROB, allocate entry in ROB, check if instruction can execute, if so dispatch instruction  Execute (E): Instructions can complete out-of-order  Completion (R): Write result to reorder buffer  Retirement/Commit (W): Check oldest instruction for exceptions; if none, write result to architectural register file or memory; else, flush pipeline and start from exception handler  In-order dispatch/execution, out-of-order completion, in-order retirement 30 F D E W E E E E E E E E E E E E E E E E E E E E . . . Integer add Integer mul FP mul Load/store R R ROB is implemented as a circular queue in hardware Reorder Buffer Tradeoffs  Advantages  Conceptually simple for supporting precise exceptions  Can eliminate false dependences  Disadvantages  Reorder buffer needs to be accessed to get the results that are yet to be written to the register file  CAM or indirection  increased latency and complexity  Other solutions aim to eliminate the disadvantages  History buffer  Future file  Checkpointing 31 We will not cover these See suggested lecture video from Spring 2015 Also see backup slides More on State Maintenance & Precise Exceptions https://www.youtube.com/watch?v=nMfbtzWizDA&list=PL5PHm2jkkXmi5CxxI7b3JCL1TWybTDtKq&index=13 More on State Maintenance & Precise Exceptions https://www.youtube.com/watch?v=upJPVXEuqIQ&list=PL5Q2soXY2Zi-iBn_sw_B63HtdbTNmphLc&index=18 More on State Maintenance & Precise Exceptions https://www.youtube.com/watch?v=9yo3yhUijQs&list=PL5Q2soXY2Zi8J58xLKBNFQFHRO3GrXxA9&index=17 Lectures on State Maintenance & Recovery  Computer Architecture, Spring 2015, Lecture 11  Precise Exceptions, State Maintenance/Recovery (CMU, Spring 2015)  https://www.youtube.com/watch?v=nMfbtzWizDA&list=PL5PHm2jkkXmi5CxxI7b3J CL1TWybTDtKq&index=13  Digital Design & Computer Architecture, Spring 2019, Lecture 15a  Reorder Buffer (ETH Zurich, Spring 2019)  https://www.youtube.com/watch?v=9yo3yhUijQs&list=PL5Q2soXY2Zi8J58xLKBNFQ FHRO3GrXxA9&index=17  Digital Design & Computer Architecture, Spring 2021, Lecture 15a  Precise Exceptions (ETH Zurich, Spring 2021)  https://www.youtube.com/watch?v=upJPVXEuqIQ&list=PL5Q2soXY2Zi- iBn_sw_B63HtdbTNmphLc&index=18 35https://www.youtube.com/onurmutlulectures Suggested Readings for the Interested  Smith and Plezskun, “Implementing Precise Interrupts in Pipelined Processors,” IEEE Trans on Computers 1988 and ISCA 1985.  Smith and Sohi, “The Microarchitecture of Superscalar Processors,” Proceedings of the IEEE, 1995  Hwu and Patt, “Checkpoint Repair for Out-of-order Execution Machines,” ISCA 1987.  Backup Slides 36 Out-of-Order Execution (Dynamic Instruction Scheduling) An In-order Pipeline  Dispatch: Act of sending an instruction to a functional unit  Renaming with ROB eliminates stalls due to false dependences  Problem: A non-ready instruction stalls dispatch of younger instructions into functional (execution) units 38 F D E R E E E E E E E E E E E E E E E E E E E E . . . Integer add Integer mul FP mul Cache miss W An Example Non-Ready Instruction 39 Long-latency instruction stalls the pipeline Independent instruction cannot enter the execution unit Time: 12:55 An Example Non-Ready Instruction 40 Stalls the pipeline Time: 12:57 An Example Non-Ready Instruction 41Time: 12:58 An Example Non-Ready Instruction 42Time: 13:00 Another View 43 Stalling Done & Independents Execute 44Time: 13:06 Independent instruction finally dispatched and executing An In-order Pipeline  Dispatch: Act of sending an instruction to a functional unit  Renaming with ROB eliminates stalls due to false dependences  Problem: A non-ready instruction stalls dispatch of younger instructions into functional (execution) units 45 F D E R E E E E E E E E E E E E E E E E E E E E . . . Integer add Integer mul FP mul Cache miss W Can We Do Better? 46 How Can We Do Better?  What do the following two pieces of code have in common (with respect to execution in the previous design)?  Answer: First ADD stalls the whole pipeline!  ADD cannot dispatch because its source register unavailable  Later independent instructions cannot get dispatched  How are the above code portions different?  Answer: Load latency is variable (unknown until runtime)  What does this affect? Think compiler vs. microarchitecture 47 MUL R3  R1, R2 ADD R3  R3, R1 ADD R4  R6, R7 MUL R5  R6, R8 ADD R7  R9, R9 LD R3  R1 (0) ADD R3  R3, R1 ADD R4  R6, R7 MUL R5  R6, R8 ADD R7  R9, R9 Preventing Dispatch Stalls  Problem: in-order dispatch (scheduling, or execution)  Solution: out-of-order dispatch (scheduling, or execution)  The basic idea:  Dataflow: “fire” an instruction only when its inputs are ready  We will use similar principles, but not expose it in the ISA  Aside: Any other way to prevent dispatch stalls? 1. Compile-time instruction scheduling/reordering 2. Value prediction 3. Fine-grained multithreading 48 Out-of-order Execution (Dynamic Scheduling)  Idea: Move the non-ready instructions out of the way of independent ones (such that independent ones can dispatch)  Rest areas for non-ready instructions: Reservation stations  Monitor the source “values” of each instruction in the resting (waiting) area  When all source “values” of an instruction are available, “fire” (i.e., dispatch) the instruction  Instructions dispatched in dataflow (not control-flow) order  Benefit:  Latency tolerance: Allows independent instructions to execute and complete in the presence of a long-latency operation 49 In-order vs. Out-of-order Dispatch  In order dispatch + precise exceptions:  Out-of-order dispatch + precise exceptions:  16 vs. 12 cycles 50 F D WE E E E R F D E R W F IMUL R3  R1, R2 ADD R3  R3, R1 ADD R1  R6, R7 IMUL R5  R6, R8 ADD R7  R3, R5 D E R W F D E R W F D E R W F D WE E E E R F D STALL STALL E R W F D E E E E STALL E R F D E E E E R W F D E R W WAIT WAIT W Enabling OoO Execution 1. Need to link the consumer of a value to the producer  Register renaming: Associate a “tag” with each data value 2. Need to buffer instructions until they are ready to execute  Insert instruction into reservation stations after renaming 3. Instructions need to keep track of readiness of source values  Broadcast the “tag” when the value is produced  Instructions compare their “source tags” to the broadcast tag  if match, source value becomes ready 4. When all source values of an instruction are ready, need to dispatch the instruction to its functional unit (FU)  Instruction wakes up if all sources are ready  If multiple instructions are awake, need to select one per FU 51 Tomasulo’s Algorithm for OoO Execution  OoO with register renaming invented by Robert Tomasulo  Used in IBM 360/91 Floating Point Units  Reading: Tomasulo, “An Efficient Algorithm for Exploiting Multiple Arithmetic Units,” IBM Journal of R&D, Jan. 1967.  What is the major difference today?  Precise exceptions  Provided by  Patt, Hwu, Shebanow, “HPS, a new microarchitecture: rationale and introduction,” MICRO 1985.  Patt et al., “Critical issues regarding HPS, a high performance microarchitecture,” MICRO 1985.  OoO variants are used in most high-performance processors  Initially in Intel Pentium Pro, AMD K5  Alpha 21264, MIPS R10000, IBM POWER5, IBM z196, Oracle UltraSPARC T4, ARM Cortex A15, Apple M1, … 52 Two Humps in a Modern Pipeline  Hump 1: Reservation stations (scheduling window)  Hump 2: Reordering (reorder buffer, aka instruction window or active window) 53 F D E W E E E E E E E E E E E E E E E E E E E E . . . Integer add Integer mul FP mul Load/store R E O R D E R S C H E D U L E TAG and VALUE Broadcast Bus in order out of order in order Two Humps in a Modern Pipeline  Hump 1: Reservation stations (scheduling window)  Hump 2: Reordering (reorder buffer, aka instruction window or active window) 54 F D E W E E E E E E E E E E E E E E E E E E E E . . . Integer add Integer mul FP mul Load/store R E O R D E R S C H E D U L E TAG and VALUE Broadcast Bus in order out of order in order Photo credit: http://true-wildlife.blogspot.ch/2010/10/bactrian-camel.html S C H E D U L E R E O R D E R General Organization of an OOO Processor  Smith and Sohi, “The Microarchitecture of Superscalar Processors,” Proc. IEEE, Dec. 1995. 55 Tomasulo’s Machine: IBM 360/91 56 FP FU FP FU from memory load buffers from instruction unit FP registers store buffers to memory operation bus reservation stations Common data bus IBM 360/91 in Real World 57http://www.columbia.edu/cu/computinghistory/36091.html IBM 360/91 in Real World 58http://www.righto.com/2019/04/iconic-consoles-of-ibm-system360.html Recall: Register Renaming  Output and anti dependences are not true dependences  WHY? The same register refers to values that have nothing to do with each other  They exist due to lack of register ID’s (i.e. names) in ISA  The register ID is renamed to the reorder buffer entry (or reservation station entry) that will hold the register’s value  Register ID  ROB or RS entry ID  Architectural register ID  Physical register ID  After renaming, ROB or RS entry ID used to refer to the register  This eliminates anti and output dependences  Gives the illusion that there are a large number of registers  Approximates the performance benefit of having more registers 59  Register rename table (register alias table) Tomasulo’s Algorithm: Renaming 60 R0 R1 R2 R3 Tag Value Valid? R4 R5 R6 R7 1 1 1 1 1 1 1 1 If Valid bit is set, the Value in the table is correct. Otherwise, Tag specifies where to find the correct value. Tag is a unique name for the Value to be produced. Tomasulo’s Algorithm: Renaming 61 R0 R1 R2 R3 R4 R5 R6 R7 Register File (RF) or Register Alias Table (RAT)Value Valid?Value Tag (pointer to the reservation station entry that will produce the value) We will ignore Reorder Buffer for simplicity Tomasulo’s Algorithm  If reservation station available before renaming  Instruction + renamed operands (source value/tag) inserted into the reservation station  Only rename if reservation station is available  Else stall  While in reservation station, each instruction:  Watches common data bus (CDB) for tag of its sources  When tag seen, grab value for the source and keep it in the reservation station  When both operands available, instruction ready to be dispatched  Dispatch instruction to the Functional Unit when instruction is ready  After instruction finishes in the Functional Unit  Arbitrate for CDB  Put tagged value onto CDB (tag broadcast)  Register file is connected to the CDB  Register contains a tag indicating the latest writer to the register  If the tag in the register file matches the broadcast tag, write broadcast value into register (and set valid bit)  Reclaim rename tag  no valid copy of tag in system! 62 An Exercise  Assume ADD (4 cycle execute), MUL (6 cycle execute)  Assume one adder and one multiplier  How many cycles  in a non-pipelined machine: 50 cycles (4*7 + 2*11)  in an in-order-dispatch pipelined machine with imprecise exceptions (no forwarding and forwarding)  in an out-of-order dispatch pipelined machine imprecise exceptions (forwarding) 63 MUL R3  R1, R2 ADD R5  R3, R4 ADD R7  R2, R6 ADD R10  R8, R9 MUL R11  R7, R10 ADD R5  R5, R11 F D E W F D E E E E W F D E E E E E E E E W ADD MUL Pipeline Exercise Continued 64 in-order-dispatch pipelined machine w/o forwarding: 31 cycles in-order-dispatch pipelined machine w/ forwarding: 25 cycles Exercise Continued 65 MUL R3  R1, R2 ADD R5  R3, R4 ADD R7  R2, R6 ADD R10  R8, R9 MUL R11  R7, R10 ADD R5  R5, R11 out-of-order dispatch pipelined machine w/ forwarding: 20 cycles How It Works 66 Our First OoO Machine Simulation 67 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 3 R4 1 4 R5 1 5 R6 1 6 R7 1 7 R8 1 8 R9 1 9 R10 1 10 R11 1 11 + ∗ Source 1 Source 2 V Tag Value V Tag Value a b c d Source 1 Source 2 V Tag Value V Tag Value x y z t MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Tag ValueTag Value RS for ADD Unit RS for MUL Unit Register Alias Table Program We Will Simulate ADD and MUL Execution Units have separate Tag & Value buses Initially: 1. Reservation Stations (RS’s) are all Invalid (Empty) 2. All Registers are Valid Cycle 0 68 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 3 R4 1 4 R5 1 5 R6 1 6 R7 1 7 R8 1 8 R9 1 9 R10 1 10 R11 1 11 + ∗ Source 1 Source 2 V Tag Value V Tag Value a b c d Source 1 Source 2 V Tag Value V Tag Value x y z t Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Cycle 1 69 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 3 R4 1 4 R5 1 5 R6 1 6 R7 1 7 R8 1 8 R9 1 9 R10 1 10 R11 1 11 + ∗ Source 1 Source 2 V Tag Value V Tag Value a b c d Source 1 Source 2 V Tag Value V Tag Value x y z t F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Cycle 2 70 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 3 R4 1 4 R5 1 5 R6 1 6 R7 1 7 R8 1 8 R9 1 9 R10 1 10 R11 1 11 + ∗ Source 1 Source 2 V Tag Value V Tag Value a b c d Source 1 Source 2 V Tag Value V Tag Value x y z t D 2 F F 1 MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Cycle 1 2 Step 2: Access the Register Alias Table Step 3: Put source registers into reservation station x 1 1 ~ ~ Step 4: Rename destination register R3  x 0 x R3 is now renamed to x. Its new value will produced by the reservation station that is identified by tag x. MUL in RS x is ready to execute in the next cycle! Step 1: Check if reservation station available. Yes: x MUL gets decoded and allocated into RS x Cycle 3 71 Register Valid Tag Value R1 1 1 R2 1 2 R3 0 x R4 1 4 R5 1 5 R6 1 6 R7 1 7 R8 1 8 R9 1 9 R10 1 10 R11 1 11 + ∗ Source 1 Source 2 V Tag Value V Tag Value a b c d Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y z t E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Check readiness (Both sources ready?)  Wakeup Ready  Dispatch the instruction to the MUL unit 6 Cycles 0 x 41 ~ 0 a Same Steps 1-4 for ADD… Rename R5  a ADD in RS a cannot execute in the next cycle: one source is not valid 1. MUL in RS x starts executing 2. ADD gets decoded and allocated into RS aCycle 4 72 + ∗ Source 1 Source 2 V Tag Value V Tag Value a 0 x 1 ~ 4 b c d Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y z t E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Register Valid Tag Value R1 1 1 R2 1 2 R3 0 x R4 1 4 R5 0 a R6 1 6 R7 1 7 R8 1 8 R9 1 9 R10 1 10 R11 1 11 ADD in RS a waits because one source is not valid. 21 ~ 61 ~ Rename R7  b 0 b ADD in RS b is ready to execute in the next cycle! It will be executed out of order in the next cycle. Cycle 5 73 + ∗ E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Register Valid Tag Value R1 1 1 R2 1 2 R3 0 x R4 1 4 R5 0 a R6 1 6 R7 0 b R8 1 8 R9 1 9 R10 1 10 R11 1 11 Source 1 Source 2 V Tag Value V Tag Value a 0 x 1 ~ 4 b 1 ~ 2 1 ~ 6 c d Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y z t 81 ~ 91 ~ 4 Cycles 0 c ADD in RS c is ready to execute in the next cycle! Cycle 6 74 + ∗ E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Register Valid Tag Value R1 1 1 R2 1 2 R3 0 x R4 1 4 R5 0 a R6 1 6 R7 0 b R8 1 8 R9 1 9 R10 0 c R11 1 11 Source 1 Source 2 V Tag Value V Tag Value a 0 x 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y z t 0 y 0 b 0 c Cycle 7 75 + ∗ E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Register Valid Tag Value R1 1 1 R2 1 2 R3 0 x R4 1 4 R5 0 a R6 1 6 R7 0 b R8 1 8 R9 1 9 R10 0 c R11 0 y Source 1 Source 2 V Tag Value V Tag Value a 0 x 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 0 a 0 y 0 d Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 0 b 0 c z t All six instructions are now decoded and renamed Note what happened to R5: Renamed twice! Source 1 Source 2 V Tag Value V Tag Value a 0 x 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 0 a 0 y Cycle 8 (First Slide) 76 + ∗ E6 8 E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Register Valid Tag Value R1 1 1 R2 1 2 R3 0 x R4 1 4 R5 0 d R6 1 6 R7 0 b R8 1 8 R9 1 9 R10 0 c R11 0 y Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 0 b 0 c z t Broadcast MUL’s tag (x)  Check tag  Check for invalidity 2 MUL in RS x is done x Broadcast MUL’s result (2) 1 x 1 2 2 2 ADD in RS a is ready to execute in the next cycle! Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 0 a 0 y Cycle 8 (Second Slide) 77 + ∗ E6 8 E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 0 b R8 1 8 R9 1 9 R10 0 c R11 0 y Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 0 b 0 c z t Broadcast ADD’s tag (b)  Check tag  Check for invalidity ADD in RS b is also done Broadcast ADD’s result (8) 1 1 8 E4 - 8b b 8 8 MUL in RS y is still NOT ready to execute in the next cycle! Cycle 8 (Third Slide) 78 + ∗ E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 0 c z t Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 0 a 0 y Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 b 8 R8 1 8 R9 1 9 R10 0 c R11 0 y Cycle 9 79 + ∗ W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 0 c R11 0 y Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 0 a 0 y Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 0 c z t 171 ~ c 17 1 17 Broadcast and Update MUL in RS y is ready to execute in the next cycle! Cycle 10 80 + ∗ 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 0 a 0 y Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 0 y Cycle 11 81 + ∗ 11 E3 E2 - 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 0 a 0 y Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 0 y Cycle 12 82 + ∗ 12 E4 E3 - 11 E3 E2 - 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 0 a 0 y Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t a 6 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 0 y 61 ~ Broadcast and Update Cycle 13 83 + ∗ 13 W E4 - 12 E4 E3 - 11 E3 E2 - 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 1 ~ 6 0 y Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 0 y Cycle 14 84 + ∗ 14 E5 - 13 W E4 - 12 E4 E3 - 11 E3 E2 - 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 0 y Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 1 ~ 6 0 y Cycle 15 85 + ∗ 15 E6 - 14 E5 - 13 W E4 - 12 E4 E3 - 11 E3 E2 - 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 1 ~ 6 0 y Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 0 y1 136 1361 ~ y 136 Broadcast and Update ADD in RS d is ready to execute in the next cycle! Cycle 16 86 + ∗ 16 W E1 15 E6 - 14 E5 - 13 W E4 - 12 E4 E3 - 11 E3 E2 - 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 1 ~ 6 1 ~ 136 Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 1 136 Cycle 17 87 + ∗ 17 E2 16 W E1 15 E6 - 14 E5 - 13 W E4 - 12 E4 E3 - 11 E3 E2 - 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 1 136 Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 1 ~ 6 1 ~ 136 Cycle 18 88 + ∗ 18 E3 17 E2 16 W E1 15 E6 - 14 E5 - 13 W E4 - 12 E4 E3 - 11 E3 E2 - 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 1 136 Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 1 ~ 6 1 ~ 136 Cycle 19 89 + ∗ 19 E4 18 E3 17 E2 16 W E1 15 E6 - 14 E5 - 13 W E4 - 12 E4 E3 - 11 E3 E2 - 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 0 d R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 1 136 Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 1 ~ 6 1 ~ 136 d 142 1 142 Broadcast and Update Cycle 20 90 + ∗ 20 W 19 E4 18 E3 17 E2 16 W E1 15 E6 - 14 E5 - 13 W E4 - 12 E4 E3 - 11 E3 E2 - 10 E2 W E1 - W 9 E1 W E4 - - E6 8 - E4 E3 - - E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 1 ~ 8 1 ~ 17 z t Register Valid Tag Value R1 1 1 R2 1 2 R3 1 2 R4 1 4 R5 1 142 R6 1 6 R7 1 8 R8 1 8 R9 1 9 R10 1 17 R11 1 136 Source 1 Source 2 V Tag Value V Tag Value a 1 ~ 2 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 1 ~ 6 1 ~ 136 Some Questions  What is needed in hardware to perform tag broadcast and value capture?  make a value valid  wake up an instruction  Does the tag have to be the ID of the Reservation Station Entry?  What can potentially become the critical path?  Tag broadcast  value capture  instruction wake up  How can you reduce the potential critical paths?  More pipelining and prediction 91 Wires, Comparators & Logic No, could be any unique name that enables linking of producer to consumer Dataflow Graph for Our Example 92 MUL R3  R1, R2 ADD R5  R3, R4 ADD R7  R2, R6 ADD R10  R8, R9 MUL R11  R7, R10 ADD R5  R5, R11 Easy task for you: Draw the dataflow graph for the above code State of RAT and RS in Cycle 7 93 + ∗ E5 7 - E3 E2 - D E4 6 - E2 E1 D F E3 5 - E1 D F E2 4 - D F E1 3 D F D 2 F F 1Cycle MUL R1, R2  R3 ADD R3, R4  R5 ADD R2, R6  R7 ADD R8, R9  R10 MUL R7, R10  R11 ADD R5, R11  R5 Register Valid Tag Value R1 1 1 R2 1 2 R3 0 x R4 1 4 R5 0 a R6 1 6 R7 0 b R8 1 8 R9 1 9 R10 0 c R11 0 y Source 1 Source 2 V Tag Value V Tag Value a 0 x 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 0 a 0 y 0 d Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 0 b 0 c z t All 6 instructions are decoded and renamed Note what happened to R5: Renamed twice! RS for ADD Unit RS for MUL Unit Register Alias Table State of RAT and RS in Cycle 7 94 + ∗ Register Valid Tag Value R1 1 1 R2 1 2 R3 0 x R4 1 4 R5 0 a R6 1 6 R7 0 b R8 1 8 R9 1 9 R10 0 c R11 0 y Source 1 Source 2 V Tag Value V Tag Value a 0 x 1 ~ 4 b 1 ~ 2 1 ~ 6 c 1 ~ 8 1 ~ 9 d 0 a 0 y 0 d Source 1 Source 2 V Tag Value V Tag Value x 1 ~ 1 1 ~ 2 y 0 b 0 c z t Slightly harder tasks for you: 1. Draw the dataflow graph for the executing code 2. Provide the executing code in sequential order RS for ADD Unit RS for MUL Unit Register Alias Table Corresponding Dataflow Graph (Reverse Engineered) We can “easily” reverse-engineer the dataflow graph of the executing code! Out-of-Order Execution with Precise Exceptions  Idea: Use a reorder buffer to reorder instructions before committing them to architectural state  An instruction updates the RAT when it completes execution  Also called frontend register file  An instruction updates a separate architectural register file when it retires  i.e., when it is the oldest in the machine and has completed execution  In other words, the architectural register file is always updated in program order  On an exception: flush pipeline, copy architectural register file into frontend register file 96 Recall: Our Initial OoO Machine 97 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 3 R4 1 4 R5 1 5 R6 1 6 R7 1 7 R8 1 8 R9 1 9 R10 1 10 R11 1 11 + ∗ Source 1 Source 2 V Tag Value V Tag Value a b c d Source 1 Source 2 V Tag Value V Tag Value x y z t Tag ValueTag Value RS for ADD Unit RS for MUL Unit Register Alias Table Add Arch Reg File & ROB for Precise Exceptions 98 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 3 R4 1 4 R5 1 5 R6 1 6 R7 1 7 R8 1 8 R9 1 9 R10 1 10 R11 1 11 Frontend Register File Register Value R1 1 R2 2 R3 3 R4 4 R5 5 R6 6 R7 7 R8 8 R9 9 R10 10 R11 11 Architectural Register File Entry 0 Entry 1 Entry 2 Entry 8 Entry 14 Entry 15 Entry 13 Reorder Buffer (ROB) OoO Machine with Precise Exceptions 99 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 3 R4 1 4 R5 1 5 R6 1 6 R7 1 7 R8 1 8 R9 1 9 R10 1 10 R11 1 11 Frontend Register File Register Value R1 1 R2 2 R3 3 R4 4 R5 5 R6 6 R7 7 R8 8 R9 9 R10 10 R11 11 Architectural Register File Entry 0 Entry 1 Entry 2 Entry 8 Entry 14 Entry 15 Entry 13 Reorder Buffer (ROB) Source 1 Source 2 V Tag Value V Tag Value x y z t RS for MUL Unit Source 1 Source 2 V Tag Value V Tag Value a b c d RS for ADD Unit Out-of-Order Execution with Precise Exceptions  Hump 1: Reservation stations (scheduling window)  Hump 2: Reordering (reorder buffer, aka instruction window or active window) 100 F D E W E E E E E E E E E E E E E E E E E E E E . . . Integer add Integer mul FP mul Load/store R E O R D E R S C H E D U L E TAG and VALUE Broadcast Bus in order out of order in order Two Humps in a Modern Pipeline  Hump 1: Reservation stations (scheduling window)  Hump 2: Reordering (reorder buffer, aka instruction window or active window) 101 F D E W E E E E E E E E E E E E E E E E E E E E . . . Integer add Integer mul FP mul Load/store R E O R D E R S C H E D U L E TAG and VALUE Broadcast Bus in order out of order in order Photo credit: http://true-wildlife.blogspot.ch/2010/10/bactrian-camel.html S C H E D U L E R E O R D E R Enabling OoO Execution, Revisited 1. Link the consumer of a value to the producer  Register renaming: Associate a “tag” with each data value 2. Buffer instructions until they are ready  Insert instruction into reservation stations after renaming 3. Keep track of readiness of source values of an instruction  Broadcast the “tag” when the value is produced  Instructions compare their “source tags” to the broadcast tag  if match, source value becomes ready 4. When all source values of an instruction are ready, dispatch the instruction to functional unit (FU)  Wakeup and select/schedule the instruction 102 Summary of OOO Execution Concepts  Register renaming eliminates false dependences, enables linking of producer to consumers  Buffering in reservation stations enables the pipeline to move for independent instructions  Tag broadcast enables communication (of readiness of produced value) between instructions  Wakeup and select enables out-of-order dispatch 103 OOO Execution: Restricted Dataflow  An out-of-order engine dynamically builds the dataflow graph of a piece of the program  which piece?  The dataflow graph is limited to the instruction window  Instruction window: all decoded but not yet retired instructions  Can we do it for the whole program?  Why would we like to?  In other words, how can we have a large instruction window?  Can we do it efficiently with Tomasulo’s algorithm? 104 See Backup Slides for: More details on Out-of-Order Execution Digital Design & Computer Arch. Lecture 20: Out-of-Order Execution Frank K. Gürkaynak Mohammad Sadrosadati Prof. Onur Mutlu ETH Zürich Spring 2024 10 May 2024 Backup Slides on Precise Exceptions 107 Reorder Buffer Tradeoffs  Advantages  Conceptually simple for supporting precise exceptions  Can eliminate false dependences  Disadvantages  Reorder buffer needs to be accessed to get the results that are yet to be written to the register file  CAM or indirection  increased latency and complexity  Other solutions aim to eliminate the disadvantages  History buffer  Future file  Checkpointing 108 Solution II: History Buffer (HB)  Idea: Update the register file when instruction completes, but UNDO UPDATES when an exception occurs  When instruction is decoded, it reserves an HB entry  When the instruction completes, it stores the old value of its destination in the HB  When instruction is oldest and no exceptions/interrupts, the HB entry discarded  When instruction is oldest and an exception needs to be handled, old values in the HB are written back into the architectural state from tail to head 109 History Buffer  Advantage:  Register file contains up-to-date values for incoming instructions  History buffer access not on critical path  Disadvantage:  Need to read the old value of the destination register  Need to unwind the history buffer upon an exception  increased exception/interrupt handling latency 110 Register File Func Unit Func Unit Func Unit History Buffer Instruction Cache Used only on exceptions Comparison of Two Approaches  Reorder buffer  Pessimistic register file update  Update only with non-speculative values (in program order)  Leads to complexity/delay in accessing the new values  History buffer  Optimistic register file update  Update immediately, but log the old value for recovery  Leads to complexity/delay in logging old values  Can we get the best of both worlds?  Principle: Heterogeneity  Idea: Have both types of register files 111 Solution III: Future File (FF) + ROB  Idea: Keep two register files (speculative and architectural)  Arch reg file: Updated in program order for precise exceptions  Use a reorder buffer to ensure in-order updates  Future reg file: Updated as soon as an instruction completes (if the instruction is the youngest one to write to a register)  Future file is used for fast access to latest register values (speculative state)  Frontend register file  Architectural file is used for state recovery on exceptions (architectural state)  Backend register file 112 Future File  Advantage  No need to read the new values from the ROB (no CAM or indirection) or the old value of destination register  Disadvantage  Multiple register files  Need to copy arch. reg. file to future file on an exception 113 Future File Func Unit Func Unit Func Unit Arch. File Instruction Cache Used only on exceptions ROB VData and Tag In-Order Pipeline with Future File and Reorder Buffer  Decode (D): Access future file, allocate entry in ROB, check if instruction can execute, if so dispatch instruction  Execute (E): Instructions can complete out-of-order  Completion (R): Write result to reorder buffer and future file  Retirement/Commit (W): Check for exceptions; if none, write result to architectural register file or memory; else, flush pipeline, copy architectural file to future file, and start from exception handler  In-order dispatch/execution, out-of-order completion, in-order retirement 114 F D E W E E E E E E E E E E E E E E E E E E E E . . . Integer add Integer mul FP mul Load/store R Can We Reduce the Overhead of Two Register Files?  Idea: Use indirection, i.e., pointers to data in frontend and retirement  Have a single storage that stores register data values  Keep two register maps (speculative and architectural); also called register alias tables (RATs)  Future map used for fast access to latest register values (speculative state)  Frontend register map  Architectural map is used for state recovery on exceptions (architectural state)  Backend register map 115 Future Map in Intel Pentium 4 116 Boggs et al., “The Microarchitecture of the Pentium 4 Processor,” Intel Technology Journal, 2001. Many modern processors are similar: - MIPS R10K - Alpha 21264 https://courses.cs.washington.edu/courses/cse378/10au/lectures/Pentium4Arch.pdf Reorder Buffer vs. Future Map Comparison 117https://courses.cs.washington.edu/courses/cse378/10au/lectures/Pentium4Arch.pdf Before We Get to Checkpointing …  Let’s cover what happens on exceptions  And branch mispredictions 118 Checking for and Handling Exceptions in Pipelining  When the oldest instruction ready-to-be-retired is detected to have caused an exception, the control logic  Recovers architectural state (register file, IP, and memory)  Flushes all younger instructions in the pipeline  Saves IP and registers (as specified by the ISA)  Redirects the fetch engine to the exception handling routine  Vectored exceptions 119 Pipelining Issues: Branch Mispredictions  A branch misprediction resembles an “exception”  Except it is not visible to software (i.e., it is microarchitectural)  What about branch misprediction recovery?  Similar to exception handling except can be initiated before the branch is the oldest instruction (not architectural)  All three state recovery methods can be used  Difference between exceptions and branch mispredictions?  Branch mispredictions are much more common  need fast state recovery to minimize performance impact of mispredictions 120 How Fast Is State Recovery?  Latency of state recovery affects  Exception service latency  Interrupt service latency  Latency to supply the correct data to instructions fetched after a branch misprediction  Which ones above need to be fast?  How do the three state maintenance methods fare in terms of recovery latency?  Reorder buffer  History buffer  Future file 121 Branch State Recovery Actions and Latency  Reorder Buffer  Flush instructions in pipeline younger than the branch  Finish all instructions in the reorder buffer  History buffer  Flush instructions in pipeline younger than the branch  Undo all instructions after the branch by rewinding from the tail of the history buffer until the branch & restoring old values one by one into the register file  Future file  Wait until branch is the oldest instruction in the machine  Copy arch. reg. file to future file  Flush entire pipeline 122 Can We Do Better?  Goal: Restore the frontend state (future file) such that the correct next instruction after the branch can execute right away after the branch misprediction is resolved  Idea: Checkpoint the frontend register state/map at the time a branch is decoded and keep the checkpointed state updated with results of instructions older than the branch  Upon branch misprediction, restore the checkpoint associated with the branch  Hwu and Patt, “Checkpoint Repair for Out-of-order Execution Machines,” ISCA 1987. 123 Checkpointing  When a branch is decoded  Make a copy of the future file/map and associate it with the branch  When an instruction produces a register value  All future file/map checkpoints that are younger than the instruction are updated with the value  When a branch misprediction is detected  Restore the checkpointed future file/map for the mispredicted branch when the branch misprediction is resolved  Flush instructions in pipeline younger than the branch  Deallocate checkpoints younger than the branch 124 Checkpointing  Advantages  Correct frontend register state available right after checkpoint restoration  Low state recovery latency  …  Disadvantages  Storage overhead  Complexity in managing checkpoints  … 125 Many Modern Processors Use Checkpointing  MIPS R10000  Alpha 21264  Pentium 4  …  Yeager, “The MIPS R10000 Superscalar Microprocessor,” IEEE Micro, April 1996  Kessler, “The Alpha 21264 Microprocessor,” IEEE Micro, March-April 1999.  Boggs et al., “The Microarchitecture of the Pentium 4 Processor,” Intel Technology Journal, 2001. 126 Summary: Maintaining Precise State  Reorder buffer  History buffer  Future register file  Checkpointing  Readings  Smith and Plezskun, “Implementing Precise Interrupts in Pipelined Processors,” IEEE Trans on Computers 1988 and ISCA 1985.  Hwu and Patt, “Checkpoint Repair for Out-of-order Execution Machines,” ISCA 1987. 127 Registers versus Memory  So far, we considered mainly registers as part of state  What about memory?  What are the fundamental differences between registers and memory?  Register dependences known statically – memory dependences determined dynamically  Register state is small – memory state is large  Register state is not visible to other threads/processors – memory state is shared between threads/processors (in a shared memory multiprocessor) 128 Maintaining Speculative Memory State: Stores  Handling out-of-order completion of memory operations  UNDOing a memory write more difficult than UNDOing a register write. Why?  One idea: Keep store address/data in reorder buffer  How does a load instruction find its data?  Store/write buffer: Similar to reorder buffer, but used only for store instructions  Program-order list of un-committed store operations  When store is decoded: Allocate a store buffer entry  When store address and data become available: Record in store buffer entry  When the store is the oldest instruction in the pipeline: Update the memory address (i.e. cache) with store data  We will get back to this when we discuss store-load handling 129 Reorder Buffer Example 130 Oldest instruction Youngest instruction Entry 0 Entry 1 Entry 2 Entry 8 Entry 14 Entry 15 Entry 13 R0 R1 R2 R3 R4 R5 R6 R7 Register File (RF) Reorder Buffer (ROB)Value Valid?Value or Tag (i.e., pointer to ROB entry)Entry Valid?Destreg IDDestreg valueDestreg written? Initially: all registers are valid in RF & ROB is empty Simulate: MUL R1, R2  R3 MUL R3, R4  R11 ADD R5, R6  R3 ADD R3, R8  R12 Out-of-Order Execution One Issue: Value Replication All Over the Place One Issue: Value Replication All Over the Place 132 Register Valid Tag Value R1 1 1 R2 1 2 R3 1 3 R4 1 4 R5 1 5 R6 1 6 R7 1 7 R8 1 8 R9 1 9 R10 1 10 R11 1 11 Frontend Register File Register Value R1 1 R2 2 R3 3 R4 4 R5 5 R6 6 R7 7 R8 8 R9 9 R10 10 R11 11 Architectural Register File Entry 0 Entry 1 Entry 2 Entry 8 Entry 14 Entry 15 Entry 13 Reorder Buffer (ROB) Source 1 Source 2 V Tag Value V Tag Value x y z t RS for MUL Unit Source 1 Source 2 V Tag Value V Tag Value a b c d RS for ADD Unit Getting Rid of Replicated Values Register PR R1 18 R2 13 R3 10 R4 22 R5 14 R6 19 R7 17 R8 20 R9 3 R10 4 R11 1 Frontend Register Map Architectural Register Map Entry 0 Entry 1 Entry 2 Entry 8 Entry 14 Entry 15 Entry 13 Reorder Buffer (ROB) Register PR R1 12 R2 2 R3 10 R4 22 R5 5 R6 9 R7 11 R8 20 R9 7 R10 6 R11 1 Physical Register File PR Value PR1 1 PR2 2 PR3 3 PR4 4 PR5 5 PR6 6 PR7 7 PR8 8 PR9 9 PR10 10 PR11 11 PR12 12 PR13 13 PR14 14 PR15 15 PR16 16 PR17 17 PR18 18 PR19 19 PR20 20 PR21 21 PR22 22 Centralized Value Storage Pointers to PRF Pointers to PRF Modern OoO Execution w/ Precise Exceptions  Most modern processors use the following  Reorder buffer to support in-order retirement of instructions  A single register file (physical RF) to store all registers  Both speculative and architectural registers  INT and FP are still separate  Two register maps store pointers to the physical RF  Future/frontend register map  used for renaming  Architectural register map  used for maintaining precise state  This design avoids value replication in RSs, ROB, etc. 134 Getting Rid of Replicated Values (I) Register PR R1 18 R2 13 R3 10 R4 22 R5 14 R6 19 R7 17 R8 20 R9 3 R10 4 R11 1 Frontend Register Map Architectural Register Map Entry 0 Entry 1 Entry 2 Entry 8 Entry 14 Entry 15 Entry 13 Reorder Buffer (ROB) Register PR R1 12 R2 2 R3 10 R4 22 R5 5 R6 9 R7 11 R8 20 R9 7 R10 6 R11 1 Physical Register File (PRF) PR Value PR1 1 PR2 2 PR3 3 PR4 4 PR5 5 PR6 6 PR7 7 PR8 8 PR9 9 PR10 10 PR11 11 PR12 12 PR13 13 PR14 14 PR15 15 PR16 16 PR17 17 PR18 18 PR19 19 PR20 20 PR21 21 PR22 22 Centralized Value Storage Pointers to PRF Pointers to PRF Getting Rid of Replicated Values (II) + ∗ DestPR ValueDestPR Value RS for ADD Unit RS for MUL Unit Before Execution: Access Physical Register File to Get Source Values After Execution: Access Physical Register File to Write Result Values At Retirement : Update Architectural Register Map with DestPR At Decode/Rename: Allocate DestPR to Dest Reg At Decode/Rename: Read and Update Frontend Register Map Source 1 Source 2 V PR V PR a b c d Source 1 Source 2 V PR V PR a b c d An Example from Modern Processors 137 Boggs et al., “The Microarchitecture of the Pentium 4 Processor,” Intel Technology Journal, 2001. Handling Out-of-Order Execution of Loads and Stores Registers versus Memory  So far, we considered mainly registers as part of state  What about memory?  What are the fundamental differences between registers and memory?  Register dependences known statically – memory dependences determined dynamically  Register state is small – memory state is large  Register state is not visible to other threads/processors – memory state is shared between threads/processors (in a shared memory multiprocessor) 139 Memory Dependence Handling (I)  Need to obey memory dependences in an out-of-order machine  and need to do so while providing high performance  Observation and Problem: Memory address is not known until a load/store executes  Corollary 1: Renaming memory addresses is difficult  Corollary 2: Determining dependence or independence of loads/stores has to be handled after their (partial) execution  Corollary 3: When a load/store has its address ready, there may be older/younger stores/loads with unknown addresses in the machine 140 Memory Dependence Handling (II)  When do you schedule a load instruction in an OOO engine?  Problem: A younger load can have its address ready before an older store’s address is known  Known as the memory disambiguation problem or the unknown address problem  Approaches  Conservative: Stall the load until all previous stores have computed their addresses (or even retired from the machine)  Aggressive: Assume load is independent of unknown-address stores and schedule the load right away  Intelligent: Predict (with a more sophisticated predictor) if the load is dependent on any unknown address store 141 Handling of Store-Load Dependences  A load’s dependence status is not known until all previous store addresses are available.  How does the OOO engine detect dependence of a load instruction on a previous store?  Option 1: Wait until all previous stores committed (no need to check for address match)  Option 2: Keep a list of pending stores in a store buffer and check whether load address matches a previous store address  How does the OOO engine treat the scheduling of a load instruction wrt previous stores?  Option 1: Assume load dependent on all previous stores  Option 2: Assume load independent of all previous stores  Option 3: Predict the dependence of a load on an outstanding store 142 Memory Disambiguation (I)  Option 1: Assume load is dependent on all previous stores + No need for recovery -- Too conservative: delays independent loads unnecessarily  Option 2: Assume load is independent of all previous stores + Simple and can be common case: no delay for independent loads -- Requires recovery and re-execution of load and dependents on misprediction  Option 3: Predict the dependence of a load on an outstanding store + More accurate. Load store dependences persist over time -- Still requires recovery/re-execution on misprediction  Alpha 21264 : Initially assume load independent, delay loads found to be dependent  Moshovos et al., “Dynamic speculation and synchronization of data dependences,” ISCA 1997.  Chrysos and Emer, “Memory Dependence Prediction Using Store Sets,” ISCA 1998. 143 Memory Disambiguation (II)  Chrysos and Emer, “Memory Dependence Prediction Using Store Sets,” ISCA 1998.  Predicting store-load dependences important for performance  Simple predictors (based on past history) can achieve most of the potential performance 144 Data Forwarding Between Stores and Loads  We cannot update memory out of program order  Need to buffer all store and load instructions in instruction window  Even if we know all addresses of past stores when we generate the address of a load, two questions still remain: 1. How do we check whether or not it is dependent on a store 2. How do we forward data to the load if it is dependent on a store  Modern processors use a LQ (load queue) and a SQ for this  Can be combined or separate between loads and stores  A load searches the SQ after it computes its address. Why?  A store searches the LQ after it computes its address. Why? 145 Out-of-Order Completion of Memory Ops  When a store instruction finishes execution, it writes its address and data in its reorder buffer entry (or SQ entry)  When a later load instruction generates its address, it:  searches the SQ with its address  accesses memory with its address  receives the value from the youngest older instruction that wrote to that address (either from ROB or memory)  This is a complicated “search logic” implemented as a Content Addressable Memory  Content is “memory address” (but also need size and age)  Called store-to-load forwarding logic 146 Store-Load Forwarding Complexity  Content Addressable Search (based on Load Address)  Range Search (based on Address and Size of both the Load and earlier Stores)  Age-Based Search (for last written values)  Load data can come from a combination of multiple places  One or more stores in the Store Buffer (SQ)  Memory/cache 147148","libVersion":"0.3.2","langs":""}