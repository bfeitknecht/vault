{"path":"other/attachments/DDCA-recap-57054AB1D4812440734A3E8EC74D82EE.pdf","text":"Carnegie Mellon 1 Digital Design and Computer Architecture Mohammad Sadrosadati Frank K. Gürkaynak Adapted from Digital Design and Computer Architecture, David Money Harris & Sarah L. Harris ©2007 Elsevier http://safari.ethz.ch/ddca Binary Numbers Carnegie Mellon 2 In This Lecture  How to express numbers using only 1s and 0s  Using hexadecimal numbers to express binary numbers  Different systems to express negative numbers  Adding and subtracting with binary numbers Carnegie Mellon 3 Number Systems  Decimal Numbers  Binary Numbers 537410 =10's column100's column1000's column1's column 11012 =2's column4's column8's column1's column Carnegie Mellon 4 Number Systems  Decimal Numbers  Binary Numbers 537410 = 5 × 10 3 + 3 × 10 2 + 7 × 10 1 + 4 × 10 0 five thousands10's column100's column1000's column three hundreds seven tens four ones1's column 11012 = 1 × 2 3 + 1 × 2 2 + 0 × 2 1 + 1 × 2 0 = 1310 one eight2's column4's column8's column one four no two one one1's column Carnegie Mellon 5 Powers of two 20 = 28 = 21 = 29 = 22 = 210 = 23 = 211 = 24 = 212 = 25 = 213 = 26 = 214 = 27 = 215 = Carnegie Mellon 6 Powers of two 20 = 1 28 = 256 21 = 2 29 = 512 22 = 4 210 = 1024 23 = 8 211 = 2048 24 = 16 212 = 4096 25 = 32 213 = 8192 26 = 64 214 = 16384 27 = 128 215 = 32768 Handy to memorize up to 215 Carnegie Mellon 7 Binary to Decimal Conversion  Convert 100112 to decimal Carnegie Mellon 8 Binary to Decimal Conversion  Convert 100112 to decimal 24 × 1 + 23 × 0 + 22 × 0 + 21 × 1 + 20 × 1 = Carnegie Mellon 9 Binary to Decimal Conversion  Convert 100112 to decimal 24 × 1 + 23 × 0 + 22 × 0 + 21 × 1 + 20 × 1 = 16 × 1 + 8 × 0 + 4 × 0 + 2 × 1 + 1 × 1 = 16 + 0 + 0 + 2 + 1 = 1910 Carnegie Mellon 10 Decimal to Binary Conversion  Convert 4710 to binary Carnegie Mellon 11 Decimal to Binary Conversion  Convert 4710 to binary ▪ Start with 26 = 64 is 64 ≤ 47 ? no do nothing ▪ Now 25 = 32 Carnegie Mellon 12 Decimal to Binary Conversion  Convert 4710 to binary ▪ Start with 26 = 64 is 64 ≤ 47 ? no do nothing ▪ Now 25 = 32 is 32 ≤ 47 ? yes subtract 47 – 32 =15 ▪ Now 24= 16 is 16 ≤ 15 ? no do nothing ▪ Now 23= 8 is 8 ≤ 15 ? yes subtract 15 – 8 = 7 ▪ Now 22= 4 is 4 ≤ 7 ? yes subtract 7-4 = 3 ▪ Now 21= 2 is 2 ≤ 3 ? yes subtract 3-2 =1 ▪ Now 20= 1 is 1 ≤ 1 ? yes we are done Carnegie Mellon 13 Decimal to binary conversion  Convert 4710 to binary ▪ Start with 26 = 64 is 64 ≤ 47 ? no 0 do nothing ▪ Now 25 = 32 is 32 ≤ 47 ? yes 1 subtract 47 – 32 =15 ▪ Now 24= 16 is 16 ≤ 15 ? no 0 do nothing ▪ Now 23= 8 is 8 ≤ 15 ? yes 1 subtract 15 – 8 = 7 ▪ Now 22= 4 is 4 ≤ 7 ? yes 1 subtract 7-4 = 3 ▪ Now 21= 2 is 2 ≤ 3 ? yes 1 subtract 3-2 =1 ▪ Now 20= 1 is 1 ≤ 1 ? yes 1 we are done  Result is 01011112 Carnegie Mellon 14 Binary Values and Range  N-digit decimal number ▪ How many values? ▪ Range? ▪ Example: 3-digit decimal number ▪ 103 = 1000 possible values ▪ Range: [0, 999]  N-bit binary number ▪ How many values? ▪ Range: ▪ Example: 3-digit binary number ▪ 23 = 8 possible values ▪ Range: [0, 7] = [0002 to 1112] 10N [0, 10N - 1] 2N [0, 2N - 1] Carnegie Mellon 15 Hexadecimal (Base-16) Numbers Decimal Hexadecimal Binary 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Carnegie Mellon 16 Hexadecimal (Base-16) Numbers Decimal Hexadecimal Binary 0 0 0000 1 1 0001 2 2 0010 3 3 0011 4 4 0100 5 5 0101 6 6 0110 7 7 0111 8 8 1000 9 9 1001 10 A 1010 11 B 1011 12 C 1100 13 D 1101 14 E 1110 15 F 1111 Carnegie Mellon 17 Hexadecimal Numbers  Binary numbers can be pretty long.  A neat trick is to use base 16  How many binary digits represent a hexadecimal digit?  Example 32 bit number: 0101 1101 0111 0001 1001 1111 1010 0110 4 (since 24 = 16) Carnegie Mellon 18 Hexadecimal Numbers  Binary numbers can be pretty long.  A neat trick is to use base 16  How many binary digits represent a hexadecimal digit?  Example 32 bit number: 0101 1101 0111 0001 1001 1111 1010 0110 5 D 7 1 9 F A 6 4 (since 24 = 16) Carnegie Mellon 19 Hexadecimal Numbers  Binary numbers can be pretty long.  A neat trick is to use base 16  How many binary digits represent a hexadecimal digit?  Example 32 bit number: 0101 1101 0111 0001 1001 1111 1010 0110 5 D 7 1 9 F A 6  The other way is just as simple C E 2 8 3 5 4 B 4 (since 24 = 16) Carnegie Mellon 20 Hexadecimal Numbers  Binary numbers can be pretty long.  A neat trick is to use base 16  How many binary digits represent a hexadecimal digit?  Example 32 bit number: 0101 1101 0111 0001 1001 1111 1010 0110 5 D 7 1 9 F A 6  The other way is just as simple C E 2 8 3 5 4 B 1100 1110 0010 1000 0011 0101 0100 1011 4 (since 24 = 16) Carnegie Mellon 21 Hexadecimal to Decimal Conversion  Convert 4AF16 (or 0x4AF) to decimal Carnegie Mellon 22 Hexadecimal to decimal conversion  Convert 4AF16 (or 0x4AF) to decimal 162 × 4 + 161 × A + 160 × F = 256 × 4 + 16 × 10 + 1 × 15 = 1024 + 160 + 15 = 119910 Carnegie Mellon 23 Bits, Bytes, Nibbles… 10010110 least significant bit most significant bit 10010110 nibble byte CEBF9AD7 least significant byte most significant byte Carnegie Mellon 24 Powers of Two  210 = 1 kilo ≈ 1000 (1024)  220 = 1 mega ≈ 1 million (1,048,576)  230 = 1 giga ≈ 1 billion (1,073,741,824) Carnegie Mellon 25 Powers of Two (SI Compatible)  210 = 1 kibi ≈ 1000 (1024)  220 = 1 mebi ≈ 1 million (1,048,576)  230 = 1 gibi ≈ 1 billion (1,073,741,824) Carnegie Mellon 26 Estimating Powers of Two  What is the value of 224?  How many values can a 32-bit variable represent? Carnegie Mellon 27 Estimating Powers of Two  What is the value of 224? 24 × 220 ≈ 16 million  How many values can a 32-bit variable represent? 22 × 230 ≈ 4 billion Carnegie Mellon 28 Addition  Decimal  Binary 3734 5168+ 8902 carries 11 1011 0011+ 1110 11 carries Carnegie Mellon 29 Add the Following Numbers 1001 0101+ 1011 0110+ Carnegie Mellon 30 Add the Following Numbers 1001 0101+ 1110 1 1011 0110+ 10001 111 OVERFLOW ! Carnegie Mellon 31 Overflow  Digital systems operate on a fixed number of bits  Addition overflows when the result is too big to fit in the available number of bits  See previous example of 11 + 6 Carnegie Mellon 32 Overflow (Is It a Problem?)  Possible faults  Security issues Carnegie Mellon 33 Binary Values and Range  N-digit decimal number ▪ How many values? ▪ Range? ▪ Example: 3-digit decimal number ▪ 103 = 1000 possible values ▪ Range: [0, 999]  N-bit binary number ▪ How many values? ▪ Range: ▪ Example: 3-digit binary number ▪ 23 = 8 possible values ▪ Range: [0, 7] = [0002 to 1112] 10N [0, 10N - 1] 2N [0, 2N - 1] Carnegie Mellon 34 Signed Binary Numbers  Sign/Magnitude Numbers  One’s Complement Numbers  Two’s Complement Numbers Carnegie Mellon 35 Sign/Magnitude Numbers  1 sign bit, N-1 magnitude bits  Sign bit is the most significant (left-most) bit ▪ Positive number: sign bit = 0 ▪ Negative number: sign bit = 1  Example, 4-bit sign/mag representations of ± 6: +6 = - 6 =  Range of an N-bit sign/magnitude number:   1 1 2 2 1 0 2 0 : , , , , ( 1) 2 n NN n a i i i A a a a a a Aa − −− − = =−  Carnegie Mellon 36 Sign/Magnitude Numbers  1 sign bit, N-1 magnitude bits  Sign bit is the most significant (left-most) bit ▪ Positive number: sign bit = 0 ▪ Negative number: sign bit = 1  Example, 4-bit sign/mag representations of ± 6: +6 = 0110 - 6 = 1110  Range of an N-bit sign/magnitude number: [-(2N-1-1), 2N-1-1]  1 1 2 2 1 0 2 0 : , , , , ( 1) 2 n NN n a i i i A a a a a a Aa − −− − = =−  Carnegie Mellon 37 Problems of Sign/Magnitude Numbers  Addition doesn’t work, for example -6 + 6: 1110 + 0110 10100 wrong!  Two representations of 0 (± 0): 1000 0000  Introduces complexity in the processor design (Was still used by some early IBM computers) Carnegie Mellon 38 One’s Complement  A negative number is formed by reversing the bits of the positive number (MSB still indicates the sign of the integer): 27 26 25 24 23 22 21 20 One’s Complement Unsigned 0 0 0 0 0 0 0 0 = +0 0 0 0 0 0 0 0 0 1 = 1 1 0 0 0 0 0 0 1 0 = 2 2 … … … … … … … … … … 0 1 1 1 1 1 1 1 = 127 127 1 0 0 0 0 0 0 0 = -127 128 1 0 0 0 0 0 0 1 = -126 129 … … … … … … … … … … 1 1 1 1 1 1 0 1 = -2 253 1 1 1 1 1 1 1 0 = -1 254 1 1 1 1 1 1 1 1 = -0 255 Carnegie Mellon 39 One’s Complement  A negative number is formed by reversing the bits of the positive number (MSB still indicates the sign of the integer): 27 26 25 24 23 22 21 20 One’s Complement Unsigned 0 0 0 0 0 0 0 0 = +0 0 0 0 0 0 0 0 0 1 = 1 1 0 0 0 0 0 0 1 0 = 2 2 … … … … … … … … … … 0 1 1 1 1 1 1 1 = 127 127 1 0 0 0 0 0 0 0 = -127 128 1 0 0 0 0 0 0 1 = -126 129 … … … … … … … … … … 1 1 1 1 1 1 0 1 = -2 253 1 1 1 1 1 1 1 0 = -1 254 1 1 1 1 1 1 1 1 = -0 255 Carnegie Mellon 40 One’s Complement  The range of n-bit one’s complement numbers is: [-2n-1-1, 2n-1-1] 8 bits: [-127,127]  Addition: Addition of signed numbers in one's complement is performed using binary addition with end-around carry. If there is a carry out of the most significant bit of the sum, this bit must be added to the least significant bit of the sum:  Example: 17 + (-8) in 8-bit one’s complement 0001 0001 (17) + 1111 0111 (-8) 1 0000 1000 + 1 0000 1001 = (9) Carnegie Mellon 41 Two’s Complement Numbers  Don’t have same problems as sign/magnitude numbers: ▪ Addition works ▪ Single representation for 0  Has advantages over one’s complement: ▪ Has a single zero representation ▪ Eliminates the end-around carry operation required in one's complement addition Carnegie Mellon 42 Two’s Complement Numbers  A negative number is formed by reversing the bits of the positive number (MSB still indicates the sign of the integer) and adding 1: 27 26 25 24 23 22 21 20 Two’s Complement Unsigned 0 0 0 0 0 0 0 0 = 0 0 0 0 0 0 0 0 0 1 = 1 1 0 0 0 0 0 0 1 0 = 2 2 … … … … … … … … … … 0 1 1 1 1 1 1 1 = 127 127 1 0 0 0 0 0 0 0 = -255 128 1 0 0 0 0 0 0 1 = -254 129 … … … … … … … … … … 1 1 1 1 1 1 0 1 = -3 253 1 1 1 1 1 1 1 0 = -2 254 1 1 1 1 1 1 1 1 = -1 255 Carnegie Mellon 43 Two’s Complement Numbers  A negative number is formed by reversing the bits of the positive number (MSB still indicates the sign of the integer) and adding 1: 27 26 25 24 23 22 21 20 Two’s Complement Unsigned 0 0 0 0 0 0 0 0 = 0 0 0 0 0 0 0 0 0 1 = 1 1 0 0 0 0 0 0 1 0 = 2 2 … … … … … … … … … … 0 1 1 1 1 1 1 1 = 127 127 1 0 0 0 0 0 0 0 = -128 128 1 0 0 0 0 0 0 1 = -127 129 … … … … … … … … … … 1 1 1 1 1 1 0 1 = -3 253 1 1 1 1 1 1 1 0 = -2 254 1 1 1 1 1 1 1 1 = -1 255 Carnegie Mellon 44 Two’s Complement Numbers  Same as unsigned binary, but the most significant bit (msb) has value of -2N-1 ▪ Most positive 4-bit number: ▪ Most negative 4-bit number:  The most significant bit still indicates the sign (1 = negative, 0 = positive)  Range of an N-bit two’s comp number: I = ∑ bi2i – bn-12n-1 i=0 i=n-2 Carnegie Mellon 45 Two’s Complement Numbers  Same as unsigned binary, but the most significant bit (msb) has value of -2N-1 ▪ Most positive 4-bit number: 0111 ▪ Most negative 4-bit number: 1000  The most significant bit still indicates the sign (1 = negative, 0 = positive)  Range of an N-bit two’s comp number: [-2N-1, 2N-1-1] 8 bits: [-128,127] I = ∑ bi2i – bn-12n-1 i=0 i=n-2 Carnegie Mellon 46 “Taking the Two’s Complement”  How to flip the sign of a two’s complement number: ▪ Invert the bits ▪ Add one  Example: Flip the sign of 310 = 00112 Carnegie Mellon 47 “Taking the Two’s Complement”  How to flip the sign of a two’s complement number: ▪ Invert the bits ▪ Add one  Example: Flip the sign of 310 = 00112 ▪ Invert the bits 11002 Carnegie Mellon 48 “Taking the Two’s Complement”  How to flip the sign of a two’s complement number: ▪ Invert the bits ▪ Add one  Example: Flip the sign of 310 = 00112 ▪ Invert the bits 11002 ▪ Add one 11012 Carnegie Mellon 49 “Taking the Two’s Complement”  How to flip the sign of a two’s complement number: ▪ Invert the bits ▪ Add one  Example: Flip the sign of 310 = 00112 ▪ Invert the bits 11002 ▪ Add one 11012  Example: Flip the sign of -810 = 110002 Carnegie Mellon 50 “Taking the Two’s Complement”  How to flip the sign of a two’s complement number: ▪ Invert the bits ▪ Add one  Example: Flip the sign of 310 = 00112 ▪ Invert the bits 11002 ▪ Add one 11012  Example: Flip the sign of -810 = 110002 ▪ Invert the bits 001112 ▪ Add one 010002 Carnegie Mellon 51 Two’s Complement Addition  Add 6 + (-6) using two’s complement numbers  Add -2 + 3 using two’s complement numbers + 0110 1010+ 1110 0011 Carnegie Mellon 52 Two’s Complement Addition  Add 6 + (-6) using two’s complement numbers  Add -2 + 3 using two’s complement numbers  Correct results if overflow bit is ignored + 0110 1010 10000 111 + 1110 0011 10001 111 Carnegie Mellon 53 Increasing Bit Width  A value can be extended from N bits to M bits (where M > N) by using: ▪ Sign-extension ▪ Zero-extension Carnegie Mellon 54 Sign-Extension  Sign bit is copied into most significant bits  Number value remains the same  Give correct result for two’s complement numbers  Example 1: ▪ 4-bit representation of 3 = 0011 ▪ 8-bit sign-extended value: 00000011  Example 2: ▪ 4-bit representation of -5 = 1011 ▪ 8-bit sign-extended value: 11111011 Carnegie Mellon 55 Zero-Extension  Zeros are copied into most significant bits  Value will change for negative numbers  Example 1: ▪ 4-bit value = 00112 = 310 ▪ 8-bit zero-extended value: 000000112 = 310  Example 2: ▪ 4-bit value = 10112 = -510 ▪ 8-bit zero-extended value: 000010112 = 1110 Carnegie Mellon 56 Number System Comparison Number System Range Unsigned [0, 2N-1] Sign/Magnitude [-(2N-1-1), 2N-1-1] Two’s Complement [-2N-1, 2N-1-1] -8 1000 1001 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1010 1011 1100 1101 1110 1111 0000 0001 0010 0011 0100 0101 0110 0111 Two's Complement 1000 1001101010111100110111101111 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 11110000 0001 0010 0011 0100 0101 0110 0111 Sign/Magnitude Unsigned For example, 4-bit representation: Carnegie Mellon 57 Lessons Learned  How to express decimal numbers using only 1s and 0s  How to simplify writing binary numbers in hexadecimal  Adding binary numbers  Methods to express negative numbers ▪ Sign Magnitude ▪ One’s complement ▪ Two’s complement (the one commonly used)","libVersion":"0.3.2","langs":""}