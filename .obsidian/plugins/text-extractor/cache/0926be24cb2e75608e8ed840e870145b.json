{"path":"sem3/TI/UE/s/TI-s-u06.pdf","text":"Departement Informatik Theoretische Informatik Prof. Dr. Dennis Komm Prof. Dr. Juraj Hromkoviˇc Dr. Hans-Joachim B¨ockenhauer Exemplary Solutions – Sheet 6 Z¨urich, November 1, 2024 Solution to Task 16 (a) First, we show that L = {ambncn | m ∈ N − {0}, n ∈ N} ∪ {b, c} ∗ is not regular. Assume that L is regular. Then there exists an automaton A = (Q, {a, b, c}, δ, q0, F ) with L(A) = L. Let m = |Q|. We consider the words ab0, ab 1, ab 2, . . . , abm. Since these are m + 1 words, there are more words than there are states in A, hence there exist i, j ∈ {0, . . . , m} with i ̸= j such that ˆδ(q0, ab i) = ˆδ(q0, ab j). According to Lemma 3.3, it follows that for all z ∈ {a, b, c}∗ abiz ∈ L ⇐⇒ abjz ∈ L. However, choosing z = ci leads to a contradiction, because abici ∈ L and abjci /∈ L. (b) Now we show that L satisfies the slightly weakened pumping lemma from the task statement. Let n0 = 1. We need to specify a decomposition w = yxz for every word w ∈ L with |w| ≥ 1 that satisfies conditions (i), (ii), and (iii′). To do this, we distinguish between two cases: First, consider the case w = ambncn for some m ∈ N − {0} and some n ∈ N. We consider the decomposition w = yxz given by y := λ, x := a, z := am−1bncn. This obviously satisfies conditions (i) and (ii). To check condition (iii ′), we consider yx kz for any k ∈ N. It holds that yx kz = am+k−1bncn If m = 1 and k = 0, then yx kz is in {b, c}∗ ⊆ L, and otherwise m + k − 1 ≥ 1, so yx kz ∈ {a mbncn | m ∈ N − {0}, n ∈ N} ⊆ L. Thus, condition (iii ′) is also satisfied. Now consider the case w ∈ {b, c}∗. Here we again choose y := λ, x as the first symbol of w, and z as the corresponding remainder. This decomposition obviously satisfies (i) and (ii), and since for every k ∈ N, yx kz ∈ {b, c}∗ ⊆ L, condition (iii′) is also satisfied. Solution to Task 17 Since L1 and L2 are regular languages, there exist finite automata A1 = (Q1, {a, b}, δ1, q0,1, F1) and A2 = (Q2, {a, b}, δ2, q0,2, F2) with L(A1) = L1 and L(A2) = L2. We provide a finite automaton A with L(A) = L that implies the regularity of L = L1{c}L2. Without loss of generality, we assume that the sets Q1, Q2, and {qs} are pairwise disjoint, where qs is an additional state. Let A = (Q1 ∪ Q2 ∪ {qs}, {a, b, c}, δ, q0,1, F2) be the automaton with the transition function δ defined as follows: δ(q, s) = q′ for all s ∈ {a, b} and q ∈ Q1 with δ1(q, s) = q′, δ(q, s) = q′ for all s ∈ {a, b} and q ∈ Q2 with δ2(q, s) = q′, δ(q, c) = q0,2 for all q ∈ F1, δ(q, c) = qs for all q ∈ (Q1 − F1) ∪ Q2, and δ(qs, s) = qs for all s ∈ {a, b, c}. The automaton A first proceeds exactly like the automaton A1, as long as symbols from {a, b} are read, except that the states F1 ⊆ Q1 are not accepting in A. If c is read in one of the states from F1, the automaton A makes a transition to the initial state q0,2 of the automaton A2 and then proceeds exactly like A2, as long as symbols from {a, b} are read. If c is read in some state outside F1, the automaton A makes a transition to the sink state qs that is not accepting and stays there independently of the remaining input. Hence, exactly the words from L1{c}L2 = {w1cw2 | w1 ∈ L1, w2 ∈ L2} are accepted. Solution to Task 18 (a) The taster may use a first-in-first-out strategy: In each round, she chooses one among the oldest chocolates currently on offer to eat. In other words, she organizes the chocolates in a queue. She eats the frontmost chocolate in the queue in each round and adds the newly served chocolates to the back of the queue. It is easy to see that with this strategy, the taster will have eaten all the chocolates by the end of the game: since the chocolatier serves only finitely many chocolates in each round, the queue will always be finite (after the n-th round, the queue contains all the chocolates served in one of the rounds 1 to n, minus n chocolates that the taster has eaten by then). So, if a chocolate p is served in round n, only finitely many chocolates (say, m) will be ahead of p in the queue, meaning the taster will eat the chocolate p in round n + m. (b) We first note that the strategy from (a) no longer works here: if the chocolatier serves infinitely many chocolates in the first round, the taster will be eating chocolates from round 1 throughout the entire game and will never reach the chocolates from round 2. Therefore, we consider an enumeration of (N − {0}) × (N − {0}), e.g., the inverse of the bijection f : (N−{0})×(N−{0}) → N−{0} given by f ((k, l)) := (k+l−1 2 )+l (c.f. Lemma 5.11 in the english version of the book, Lemma 5.2 in the german version). Note that for all (k, l) ∈ (N − {0}) × (N − {0}), it holds that f ((k, l)) ≥ l. The taster enumerates the freshly served chocolates in each round: say, in the n-th round, the chocolatier serves the chocolates pn 1 , p n 2 , . . .. Let f −1(n) = (k, l). In the n-th round, 2 the taster eats the chocolate pl k. Since l ≤ f ((k, l)) = n, chocolate pl k has indeed already been served by round n, so this strategy is well-defined. Since f is a bijection, the taster will eat every chocolate using this strategy. 3","libVersion":"0.5.0","langs":""}