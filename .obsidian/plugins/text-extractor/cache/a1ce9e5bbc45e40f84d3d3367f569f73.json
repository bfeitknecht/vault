{"path":"sem4/FMFP/PV/exams/endterms/FMFP-FS23.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Part II Midterm Exam, SS23 May 9, 2023, 10:15 – 10:45 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 6 pages. After the exam begins, check that your exam papers are complete (3 assignments and 1 page of background material). 2. Only write on the exam paper. Write your first and last name and your student number on every sheet of exam paper that you write on. 3. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 4. Each correct answer in assignment 1 gives you 2 points, while a wrong answer removes 2 points. Each correct answer in assignments 2 and 3 gives you 1 point, while a wrong answer removes 1 point. If an assignment has a negative number of points, it will be counted as 0 points. 5. You have 30 minutes to complete the exam. Assignment 1 2 3 ∑ Max 8 5 11 24 Points 1 NATURAL SEMANTICS OF IMP (8 POINTS) 2 1 Natural Semantics of IMP (8 points) In this task, we consider the IMP language from the lectures, extended with an assert statement. Intuitively, this command checks whether a condition holds, and allows the program to continue executing if it does. The semantics of this command is given by the following rule: (AssertNS) ⟨assert e, σ⟩ → σ if B[[e]]σ = tt Let s be the statement while x > 0 do (assert x > 1; y := y + 1); x := x − 2 end and let sb be the body of the loop, i.e. the statement (assert x > 1; y := y + 1); x := x − 2 For every statement below, decide whether it is True (T) or False (F). T F (a) for every state σ, s terminates successfully if it is executed in state σ and σ(x) is even. □ □ (b) ∀σ.⟨sb, σ⟩ → σ[y ↦→ σ(y) + 1][x ↦→ σ(x) − 2] □ □ (c) The derivation of ⟨s, σzero[x ↦→ 2]⟩ → σzero[y ↦→ 1] contains exactly 8 rule applications. □ □ (d) Let T be a derivation tree with root ⟨s, σzero[x ↦→ 2]⟩ → σzero[y ↦→ 1]. Then, there exists a subtree T ′ of T with root ⟨x := x − 2;s, σzero[x ↦→ 2][y ↦→ 1]⟩ → σzero[y ↦→ 1]. □ □ 2 LET-EXPRESSIONS - PART 1 (5 POINTS) 3 2 Let-Expressions - Part 1 (5 points) In this task, we extend the language of arithmetic expressions defined in the lectures (Aexp) with let-expressions, similar to the ones found in Haskell. Formally, we add the expression (let x := e1 in e2) to arithmetic expressions, where x is a variable and e1 and e2 are arithmetic expressions, and define its meaning as follows: A[[(let x := e1 in e2)]]σ = A[[e2]]σ[x ↦→ A[[e1]]σ] Intuitively, we evaluate expression e1 in the state σ (which gives a value v) and then evaluate e2 in the state σ, but with x bound to v. As an example: A[[(let x := y + 1 in x + 2)]]σzero = 3 In the following, we consider the equivalence of expressions. Two expressions e1 and e2 are equivalent, written e1 ∼ e2, if and only if they evaluate to the same value in every state. Formally e1 ∼ e2 holds if and only if ∀σ. A[[e1]]σ = A[[e2]]σ. Determine whether the following statements are true (T) or false (F). T F (a) ∀e, x. (let x := e in e) ∼ e □ □ (b) ∀e, x. (let x := e in x) ∼ e □ □ (c) ∀e1, e2, x. (let x := e1 in (let x := e1 in e2)) ∼ (let x := e1 in e2) □ □ We now consider free variables. We can prove that an expression will always be evaluated to the same value in two different states, if the states agree on the values assigned to the free variables of the expression. More formally, we can prove the following property for all arithmetic expressions e and all states σ and σ′: ( ∀x. x ∈ FV(e) =⇒ σ(x) = σ′(x) ) =⇒ A[[e]]σ = A[[e]]σ′ (P1) Assuming that (P1) holds for every arithmetic expression e, determine whether the following statements are true (T) or false (F). T F (d) ∀x, e1, e2. x /∈ FV(e1) =⇒ (let x := e1 in e2) ∼ e2 □ □ (e) ∀x, e1, e2. x /∈ FV(e2) =⇒ (let x := e1 in e2) ∼ e2 □ □ 3 LET-EXPRESSIONS - PART 2 (11 POINTS) 4 3 Let-Expressions - Part 2 (11 points) Note: This task depends on let-expressions introduced in the previous task. We extend the definition of FV to let-expressions as follows: FV(n) = ∅ FV(x) = {x} FV(e1 op e2) = FV(e1) ∪ FV(e2) FV((let x := e1 in e2)) = FV(e1 + e2) ∪ {x} We will prove (P1) (introduced in task 1) by induction for this extended definition. That is, we prove the following property for all states σ and σ′: ( ∀x. x ∈ FV(e) =⇒ σ(x) = σ′(x) ) =⇒ A[[e]]σ = A[[e]]σ′ The following induction proof contains mistake(s). Indicate (after the proof) which steps are correct, and which steps are incorrect. When considering the correctness of a step, assume that all previous steps are correct. Let σ and σ′ be arbitrary. We define P (e) ≡ ((∀x. x ∈ FV(e) =⇒ σ(x) = σ′(x)) =⇒ A[[e]]σ = A[[e]]σ′), and we prove ∀e. P (e) by strong structural induction on e. (A) Let e be arbitrary. We assume ∀e ′. e ′ ⊏ e =⇒ P (e ′) (IH) and we prove P (e). (B) To prove P (e), we distinguish the three following cases for e. Case 1: e ≡ z for some variable z. (the rest of this case is correct but omitted) Case 2: e ≡ e1 op e2 for some arithmetic expressions e1 and e2 and op ∈ {+, −, ×}. (the rest of this case is correct but omitted) (C) Case 3: e ≡ (let x := e1 in e2) for some variable x and expressions e1 and e2. To prove P ((let x := e1 in e2)), we assume ∀y. y ∈ FV((let x := e1 in e2)) =⇒ σ(y) = σ′(y), and prove A[[(let x := e1 in e2)]]σ = A[[(let x := e1 in e2)]]σ′. (D) We know that FV((let x := e1 in e2)) = FV(e1+e2)∪{x} = FV(e1)∪FV(e2)∪{x}. Thus, from the assumption, we get ∀y. y ∈ FV(e1) =⇒ σ(y) = σ′(y) (A1) ∀y. y ∈ FV(e2) =⇒ σ(y) = σ′(y) (A2) (E) Since e1 ⊏ (let x := e1 in e2), we get P (e1) from (IH). (F) From P (e1) and (A1), we get A[[e1]]σ = A[[e1]]σ′ (L1). (G) Since e2 ⊏ (let x := e1 in e2), we get P (e2) from (IH). (H) From P (e2) and (A2), and by instantiating σ and σ′ with σ[x ↦→ A[[e1]]σ] and σ′[x ↦→ A[[e1]]σ], respectively, we get A[[e2]]σ[x ↦→ A[[e1]]σ] = A[[e2]]σ′[x ↦→ A[[e1]]σ] (L2). 3 LET-EXPRESSIONS - PART 2 (11 POINTS) 5 (I) ThusA[[(let x := e1 in e2)]]σ = A[[e2]]σ[x ↦→ A[[e1]]σ] (definition) = A[[e2]]σ′[x ↦→ A[[e1]]σ] (L2) = A[[e2]]σ′[x ↦→ A[[e1]]σ′] (L1) = A[[(let x := e1 in e2)]]σ′ (definition) which concludes the proof. Determine whether the following statements are true (T) or false (F). T F (a) The extended definition of FV is total. □ □ (b) The extended definition of FV is inductive. □ □ (c) Step (A) is correct. □ □ (d) Step (B) is correct (assuming step (A) is correct). □ □ (e) Step (C) is correct (assuming steps (A) and (B) are correct). □ □ (f) Step (D) is correct (assuming steps (A)-(C) are correct). □ □ (g) Step (E) is correct (assuming steps (A)-(D) are correct). □ □ (h) Step (F) is correct (assuming steps (A)-(E) are correct). □ □ (i) Step (G) is correct (assuming steps (A)-(F) are correct). □ □ (j) Step (H) is correct (assuming steps (A)-(G) are correct). □ □ (k) Step (I) is correct (assuming steps (A)-(H) are correct). □ □ 3 LET-EXPRESSIONS - PART 2 (11 POINTS) 6 Syntax and Semantics of IMP Syntax The statements s (Stm) and arithmetic expressions e (Aexp) of the programming language IMP are given by the grammar s ::= skip ∣ ∣ x := e ∣ ∣ s;s ∣ ∣ if b then s else s end ∣ ∣ while b do s end e ::= n ∣ ∣ x ∣ ∣ e op e where n ranges over numerals (Numeral), x ranges over variables (Var), b ranges over boolean expressions (Bexp), and op ranges over arithmetic operators (Op). Free Variables and Substitution FV(e) =    ∅ if e ≡ n for some numeral n {x} if e ≡ x for some variable x FV(e1) ∪ FV(e2) if e ≡ e1 op e2 for some e1, e2, and op e[x ↦→ e′] ≡    n if e ≡ n for some numeral n e ′ if e ≡ y for some variable y with y ≡ x y if e ≡ y for some variable y with y ̸≡ x e1[x ↦→ e ′] op e2[x ↦→ e′] if e ≡ e1 op e2 for some e1, e2, and op Natural Semantics (Big-Step Semantics) (SkipNS) ⟨skip, σ⟩ → σ (AssNS) ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ → σ′ ⟨s2, σ′⟩ → σ′′ (SeqNS) ⟨s1;s2, σ⟩ → σ′′ ⟨s1, σ⟩ → σ′ (IfTNS) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = tt ⟨s2, σ⟩ → σ′ (IfFNS) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = ff ⟨s, σ⟩ → σ′ ⟨while b do s end, σ′⟩ → σ′′ (WhTNS) ⟨while b do s end, σ⟩ → σ′′ if B[[b]]σ = tt (WhFNS) ⟨while b do s end, σ⟩ → σ if B[[b]]σ = ff","libVersion":"0.5.0","langs":""}