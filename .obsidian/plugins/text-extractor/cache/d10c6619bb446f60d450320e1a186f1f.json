{"path":"sem2a/PProg/VRL/extra/benji/PProg-w05-benji.pdf","text":"Parallel Programming Exercise Session 5 Spring 2024 Plan für heute • Nachbesprechung Übung 4 • Demo: Loop unrolling • Zusätzliche Aufgabe • Theorie Recap: Divide & Conquer • Vorbesprechung Übung 5 • Quiz Nachbesprechung Übung 4 Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task a) total time if strictly sequential order? Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task a) total time if strictly sequential order? 50 + 90 + 15 155 Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task a) total time if strictly sequential order? 155 155+ Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task a) total time if strictly sequential order? 155 155 155 155+ + + = 620 Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? Throughput? 1 person per 106.25 min (425 min / 4) With lead in & lead out (fixed number of students) Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? Throughput? 1 person per 90 min Full utilization (indefinite number of students) Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? Throughput? 1 person per 90 min How to compute throughput fast for pipelines with no duplicated stages? PipeliningLast Week 14 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes Question 2: The library introduces a ”one book at a time” policy, i.e., the students have to return a book before they can start on the next one. How long will it now take for 4 students until all of them have started writing their essays? student 1 student 2 student 3 student 4 Throughput: 1 student per 120 min Throughput: 1 student per 160 min Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Throughput?Latency? 155 min 1 person per 50 min (full utilization) 1 person per 76.25 min (with lead in & lead out) 50 min 305 min Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Pipeline is not balanced as the stages do not take the same time. Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } Annahmen: ● Nur eine Instruktion kann pro CPU-Zyklus gestartet werden ● Loop-Body muss fertig sein, bevor die nächste Loop Iteration startet ● Nur arithmetische Operationen im Loop-Body werden gezählt Wie viele Zyklen braucht der Prozessor, um fertig zu werden? ● Latenz Addition: 3 Zyklen ● Latenz Multiplikation: 6 Zyklen Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } 1 2 3i-1 loop iteration i+1 loop iteration 4 5 6 essentials Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } 1 2 3 4 5 6 7 8 9 i-2 loop iteration i+2 loop iteration 1 2 3i-1 loop iteration i+1 loop iteration 4 5 6 essentials Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } 1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6 7 8 9 1 2 3i-1 loop iteration i+1 loop iteration i-2 loop iteration i-4 loop iteration i+2 loop iteration i+4 loop iteration 4 5 6 essentials Demo: Loop unrolling Extra: ILP & Loop unrolling ● Eine Form von ILP ● Ziel: Mehr Instruktionen zu pipelinen ● Space-Time Tradeoff ● Andere Formen von ILP: Superscalar, Out-of-order execution, branch prediction, etc. (kommt alles in DDCA) ● Links: ILP, Loop unrolling, Space-Time Tradeoff Loop Parallelism for (int i=1; i<size; i++) { // for loop: i from 1 to (size-1) if (data[i-1] > 0) // If the previous value is positive data[i] = (-1)*data[i]; // change the sign of this value } // end for loop Can we parallelize the following loop? essentials Loop Parallelism for (int i=1; i<size; i++) { // for loop: i from 1 to (size-1) if (data[i-1] > 0) // If the previous value is positive data[i] = (-1)*data[i]; // change the sign of this value } // end for loop Can we parallelize the following loop? for (int i = 0; i < size; i++) { // for loop: i from 0 to (size-1) data[i] = Math.sin(data[i]); // calculate sin() of the value } // end for loop essentials Zusätzliche Aufgabe SOLA Stafette public class RunnerThread extends Thread { private AtomicInteger y; private int id; public RunnerThread(int id, AtomicInteger y) { this.id = id; this.y = y; } public void run(){ while (y.get() != this.id) { // warten bis ich an der Reihe bin / wait until it is my turn } // laufen / do running y.incrementAndGet(); } } ● 14 runners (numbered from 0 to 13) ● each runner can start after the previous runner finished (except the first one). Under which assumption does the following code work? Initial value of y? Reference to object y? 0 needs to be the same object shared across all the threads SOLA Stafette public class RunnerThread extends Thread { private AtomicInteger y; private int id; public RunnerThread(int id, AtomicInteger y) { this.id = id; this.y = y; } public void run(){ while (y.get() != this.id) { // warten bis ich an der Reihe bin / wait until it is my turn } // laufen / do running y.incrementAndGet(); } } ● 14 runners (numbered from 0 to 13) ● each runner can start after the previous runner finished (except the first one). Under which assumption does the following code work? Initial value of y? Reference to object y? 0 needs to be the same object shared across all the threads Ensures that y.get() returns the updated value after calling y.incrementAndGet(); SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ ................................................... ................................................... ................................................... ................................................... ................................................... ................................................... ................................................... ................................................... } } Complete the implementation using wait/notify SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { ................................................... ................................................... ................................................... ................................................... ................................................... ................................................... ................................................... } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { while (condition) { ?.wait(); } ................................................... ................................................... ................................................... ................................................... } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { while (condition) { ?.wait(); } // laufen / do running ................................................... ................................................... ................................................... } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { while (condition) { ?.wait(); } // laufen / do running // update the condition ................................................... ................................................... } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { while (condition) { ?.wait(); } // laufen / do running // update the condition ?.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads This is a basic pattern that you will see in many tasks. Now, let’s fill in the details. essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { while (condition) { ?.wait(); } // laufen / do running // update the condition ?.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (condition) { x.wait(); } // laufen / do running // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (condition) { x.wait(); } // laufen / do running // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads while (y.get() != this.id) { original condition can we reuse it? Yes! essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Should we use notify or notifyAll? essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Should we use notify or notifyAll? notifyAll because multiple threads can be waiting essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Can we replace synchronized (x) with synchronizing the method? No essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Can we replace AtomicInteger x With Integer x ? essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private Integer x; private int id; public WaitNotifyRunnerThread(int id, Integer x) { this.id = id; this.x = x; } public void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x += 1; // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Can we replace AtomicInteger x With Integer x ? essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private Integer x; private int id; public WaitNotifyRunnerThread(int id, Integer x) { this.id = id; this.x = x; } public void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x += 1; // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify Can we replace AtomicInteger x With Integer x ? Do these assumptions still hold? Initial value of x? Reference to object x? 0 needs to be the same object shared across all the threads No, because x += 1 in Java creates a new Object! details Theorie Recap: Divide & Conquer Divide and Conquer Beispiele für Divide-and-conquer Algorithmen: Quicksort, Mergesort, Strassen matrix multiplication, und viele weitere. Aufbau eines Divide-and-conquer Algorithmus: 1. Falls das Problem klein genug ist -> Direkt lösen 2. Sonst a. Problem in Teilprobleme zerlegen b. Teilprobleme rekursiv lösen c. Lösung der Teilprobleme zusammenführen essentials Adding Numbers from Vector: (Recursive Version) public static int do_sum_rec(int[] xs, int l, int h) { int size = h – l; if (size == 1) return xs[l]; int mid = size / 2; int sum1 = do_sum_rec(xs, l, l + mid); int sum2 = do_sum_rec(xs, l + mid, h); return sum1 + sum2; } essentials Parallel Version: Task Parallelism Model Normaler Kontrollfluss ●Erstelle parallele Tasks ●Warte bis die parallelen Tasks fertig sind Parallele Version eines Divide-and-conquer Problems: ●Erstelle einen parallelen Task für jedes Teilproblem ●Warte bis die Teilprobleme gelöst sind ●Resultate zusammenführen essentials ++++++++ ++++ ++ + Divide and Conquer essentials ++++++++ ++++ ++ + base case no further split Divide and Conquer essentials ++++++++ ++++ ++ + Tasks mit unterschiedlicher Granularität Divide and Conquer essentials ++++++++ ++++ ++ + Was definiert einen Task? Divide and Conquer essentials Tasks mit unterschiedlicher Granularität ++++++++ ++++ ++ + Was definiert einen Task? i) Input array ii) Startindex iii)Länge/Endindex Das sind die Attribute, die wir pro Task speichern Divide and Conquer essentials Tasks mit unterschiedlicher Granularität Vorbesprechung Übung 5 57 Assignment 5 1. Parallel Search and Count Search an array of integers for a certain feature and count integers that have this feature. ● Light workload: count number of non-zero values. ● Heavy workload: count how many integers are prime numbers. We will study single threaded and multi-threaded implementation of the problem. -> Code durchgehen Assignment 5 1. Parallel Search and Count Search an array of integers for a certain feature and count integers that have this feature. ● Light workload: count number of non-zero values. ● Heavy workload: count how many integers are prime numbers. We will study single threaded and multi-threaded implementation of the problem. 3. Amdahl’s and Gustafson’s Law II 4. Amdahl’s and Gustafson’s Law 5. Task Graph Amdahl’s Law • Menge an Arbeit fix, d.h. • wird durch mehr Threads beschleunigt. • Speedup bezieht sich auf die Zeit • D.h. (Wegen Overheads ist es und nicht ) • Beschränkter Speedup! Gustafson’s Law • Gegebene Zeit fix • Mit mehr Threads kann mehr Arbeit erledigt werden. • Speedup bezieht sich auf die Arbeit Amdal’s & Gustavson’s Law Assuming a program consists of 50% non-parallelizable code. a) Compute the speed-up when using 2 and 4 processors according to Amdahl’s law. b) Now assume that the parallel work per processor is fixed. Compute the speed-up when using 2 and 4 processors according to Gustafson’s law. Time is constant  More work overall Old Exam Task (HS20 – Task 1) Gustafson: From the text:  5 processors are required! ⟺ ⟺ ⟺ https://quizizz.com/admin/quiz/65f7e8ede558fa3845d65bf3?source=quiz_share Replace link with link to quiz","libVersion":"0.3.2","langs":""}