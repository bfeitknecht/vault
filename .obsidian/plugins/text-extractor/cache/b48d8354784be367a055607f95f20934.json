{"path":"sem4/FMFP/pvw/FMFP-pvw-s05.pdf","text":"Formal Methods and Functional Programming PVW July 14-19, 2025 Wochenplan Freitag Heute auf dem Programm ▶ LTL (Linear Temporal Logic) ▶ Promela ▶ Verschiedenes Linear Temporal Logic Transition System (Programm) ▶ Finite set of states Γ ▶ Starting state s0 ∈ Γ ▶ Transition relation → Berechnung (eine Programm Execution) ▶ Können wir nun schreiben als: s0 → si1 → si2 → . . . ▶ Alle sind unendlich. Variable o sagt ob ein file handler offen ist o = 1 oder geschlossen ist o != 0 ∀isi[o] = 1 ⇒ ∃jsi+j[o] ̸= 0 Linear Temporal Logic Transition System (Programm) ▶ Finite set of states Γ ▶ Starting state s0 ∈ Γ ▶ Transition relation → Berechnung (eine Programm Execution) ▶ Können wir nun schreiben als: s0 → si1 → si2 → . . . ▶ Alle sind unendlich. Variable o sagt ob ein file handler offen ist o = 1 oder geschlossen ist o != 0 ∀isi[o] = 1 ⇒ ∃jsi+j[o] ̸= 0 Linear Temporal Logic Transition System (Programm) ▶ Finite set of states Γ ▶ Starting state s0 ∈ Γ ▶ Transition relation → Berechnung (eine Programm Execution) ▶ Können wir nun schreiben als: s0 → si1 → si2 → . . . ▶ Alle sind unendlich. Variable o sagt ob ein file handler offen ist o = 1 oder geschlossen ist o != 0 ∀isi[o] = 1 ⇒ ∃jsi+j[o] ̸= 0 Einige Mengen Für ein Transition System TS ▶ C(TS) alle mögliche Berechnungen. ▶ Eine property P ist auch eine Menge von Berechnungen. P ⊆ Γω ▶ Eine property hält (TS ⊨ P) gdw C(TS) ⊆ P Label System Vorallem wenn die property von mehreren variablen abhängt wird es sehr mühsam zu schreiben. Label System ▶ Atomic Propositions (Labels) P = {open, closed} ▶ Label function L : Γ → P(P) ▶ Program execution s0 → si1 → si2 → . . . wird zur trace: L(s0) → L(si1) → L(si2) → . . . Ampel Beispiel: P = {r , y , g} (red, yellow, green) Eine trace könnte so aussehen: {r } → {y } → {g} → · · · → {g} → {y , g} → {r } → . . . ∀ir ∈ L(si) ⇒ y ∈ L(si−1) Label System Vorallem wenn die property von mehreren variablen abhängt wird es sehr mühsam zu schreiben. Label System ▶ Atomic Propositions (Labels) P = {open, closed} ▶ Label function L : Γ → P(P) ▶ Program execution s0 → si1 → si2 → . . . wird zur trace: L(s0) → L(si1) → L(si2) → . . . Ampel Beispiel: P = {r , y , g} (red, yellow, green) Eine trace könnte so aussehen: {r } → {y } → {g} → · · · → {g} → {y , g} → {r } → . . . ∀ir ∈ L(si) ⇒ y ∈ L(si−1) LTL Syntax Syntax: φ = p | ¬φ | φ ∧ φ | φ U φ | ⃝φ LTL Semantics t ∈ P(P) w t |= p ⇐⇒ p ∈ t[0] t |= ¬φ ⇐⇒ not (t |= φ) t |= φ ∧ ψ ⇐⇒ (t |= φ and t |= ψ) t |= φ U ψ ⇐⇒ ∃k :k ≥0. (t(≥k ) |= ψ ∧ ∀j:0≤j<k . t(≥j) |= φ) t |= ⃝φ ⇐⇒ t(≥1) |= φ LTL Semantics t ∈ P(P) w t |= p ⇐⇒ p ∈ t[0] t |= ¬φ ⇐⇒ not (t |= φ) t |= φ ∧ ψ ⇐⇒ (t |= φ and t |= ψ) t |= φ U ψ ⇐⇒ ∃k :k ≥0. (t(≥k ) |= ψ ∧ ∀j:0≤j<k . t(≥j) |= φ) t |= ⃝φ ⇐⇒ t(≥1) |= φ LTL Semantics t ∈ P(P) w t |= p ⇐⇒ p ∈ t[0] t |= ¬φ ⇐⇒ not (t |= φ) t |= φ ∧ ψ ⇐⇒ (t |= φ and t |= ψ) t |= φ U ψ ⇐⇒ ∃k :k ≥0. (t(≥k ) |= ψ ∧ ∀j:0≤j<k . t(≥j) |= φ) t |= ⃝φ ⇐⇒ t(≥1) |= φ LTL Semantics t ∈ P(P) w t |= p ⇐⇒ p ∈ t[0] t |= ¬φ ⇐⇒ not (t |= φ) t |= φ ∧ ψ ⇐⇒ (t |= φ and t |= ψ) t |= φ U ψ ⇐⇒ ∃k :k ≥0. (t(≥k ) |= ψ ∧ ∀j:0≤j<k . t(≥j) |= φ) t |= ⃝φ ⇐⇒ t(≥1) |= φ LTL Semantics t ∈ P(P) w t |= p ⇐⇒ p ∈ t[0] t |= ¬φ ⇐⇒ not (t |= φ) t |= φ ∧ ψ ⇐⇒ (t |= φ and t |= ψ) t |= φ U ψ ⇐⇒ ∃k :k ≥0. (t(≥k ) |= ψ ∧ ∀j:0≤j<k . t(≥j) |= φ) t |= ⃝φ ⇐⇒ t(≥1) |= φ LTL - Semantics con’t ♢φ ≡ (true U φ) □φ ≡ ¬♢¬φ Precedence: unary operators have higher precendence. Hence. ♢ψ ⇒ ϕ ≡ (♢ψ) ⇒ ϕ LTL - Semantics con’t ♢φ ≡ (true U φ) □φ ≡ ¬♢¬φ Precedence: unary operators have higher precendence. Hence. ♢ψ ⇒ ϕ ≡ (♢ψ) ⇒ ϕ Üben Consider a transition system with two states s1, s2, where s1 is the initial state, and with transitions back and forth from s1 to s2 as well as a loop from s2 to itself. Let p be true in and only in state s2. Decide for these two LTL formulas if they hold or don’t hold for any trace in this transition system: ▶ □♢p ▶ ♢□p Aufgaben ▶ PVW p.73, Hands-On 1 (ex. 1.2-) Safety Property Something bad is never allowed to happen (and can’t be fixed) An LT-property P is a safety property if for all infinite sequences t ∈ P(AP)ω if t /∈ P then there is a finite prefix ˆt of t such that for every infinite sequence t ′ with prefix ˆt, t ′ /∈ P ▶ Safety properties are violated in finite time. ▶ If a safety property is broken, it cannot be fixed. ▶ \"Bad prefix\" Safety Property Something bad is never allowed to happen (and can’t be fixed) An LT-property P is a safety property if for all infinite sequences t ∈ P(AP)ω if t /∈ P then there is a finite prefix ˆt of t such that for every infinite sequence t ′ with prefix ˆt, t ′ /∈ P ▶ Safety properties are violated in finite time. ▶ If a safety property is broken, it cannot be fixed. ▶ \"Bad prefix\" Safety Property Something bad is never allowed to happen (and can’t be fixed) An LT-property P is a safety property if for all infinite sequences t ∈ P(AP)ω if t /∈ P then there is a finite prefix ˆt of t such that for every infinite sequence t ′ with prefix ˆt, t ′ /∈ P ▶ Safety properties are violated in finite time. ▶ If a safety property is broken, it cannot be fixed. ▶ \"Bad prefix\" Liveness Property If the good thing has not happened yet, it could happen in the future An LT-property P is a liveness property if every finite sequence ˆt ∈ P(AP) ∗ is a prefix of an infinite seqence t ∈ P ▶ Every finite prefix can be fixed. ▶ Liveness properties are violated in infinite time. Liveness Property If the good thing has not happened yet, it could happen in the future An LT-property P is a liveness property if every finite sequence ˆt ∈ P(AP) ∗ is a prefix of an infinite seqence t ∈ P ▶ Every finite prefix can be fixed. ▶ Liveness properties are violated in infinite time. Liveness Property If the good thing has not happened yet, it could happen in the future An LT-property P is a liveness property if every finite sequence ˆt ∈ P(AP) ∗ is a prefix of an infinite seqence t ∈ P ▶ Every finite prefix can be fixed. ▶ Liveness properties are violated in infinite time. Übung I Let p be an atomic proposition. ▶ Prove that both □♢p and ♢□p express liveness properties. ▶ Prove that □p expresses a safety property. Safety LivenessProveDisprove Übung I Let p be an atomic proposition. ▶ Prove that both □♢p and ♢□p express liveness properties. ▶ Prove that □p expresses a safety property. Safety LivenessProveDisprove Übung I con’t ▶ Prove that ♢□p is not a safety property. ▶ Prove that □p is not a lifeness property. Aufgaben ▶ PVW p 75, Hands-On 2 ▶ Exercise Sheet 14, Assignment 2 und 3 Promela ▶ Startpunk Programm i n i t { p r i n t f ( \" H e l l o World ! \\ n \" ) } ▶ Constant declaration # d e f i n e N 5 ▶ Structure declarations t y p e d e f v e c t o r { i n t x ; i n t y } ; ▶ Global channel declarations chan b u f = [ 2 ] o f { i n t } ; Promela ▶ Startpunk Programm i n i t { p r i n t f ( \" H e l l o World ! \\ n \" ) } ▶ Constant declaration # d e f i n e N 5 ▶ Structure declarations t y p e d e f v e c t o r { i n t x ; i n t y } ; ▶ Global channel declarations chan b u f = [ 2 ] o f { i n t } ; Promela ▶ Startpunk Programm i n i t { p r i n t f ( \" H e l l o World ! \\ n \" ) } ▶ Constant declaration # d e f i n e N 5 ▶ Structure declarations t y p e d e f v e c t o r { i n t x ; i n t y } ; ▶ Global channel declarations chan b u f = [ 2 ] o f { i n t } ; Promela ▶ Startpunk Programm i n i t { p r i n t f ( \" H e l l o World ! \\ n \" ) } ▶ Constant declaration # d e f i n e N 5 ▶ Structure declarations t y p e d e f v e c t o r { i n t x ; i n t y } ; ▶ Global channel declarations chan b u f = [ 2 ] o f { i n t } ; Promela ▶ Startpunk Programm i n i t { p r i n t f ( \" H e l l o World ! \\ n \" ) } ▶ Constant declaration # d e f i n e N 5 ▶ Structure declarations t y p e d e f v e c t o r { i n t x ; i n t y } ; ▶ Global channel declarations chan b u f = [ 2 ] o f { i n t } ; Promela ▶ Global variable declarations b y t e c o u n t e r ; ▶ Process declarations p r o c t y p e myProc ( i n t p ) { . . . } Promela ▶ Global variable declarations b y t e c o u n t e r ; ▶ Process declarations p r o c t y p e myProc ( i n t p ) { . . . } Executable vs blocked A statement can be executable or blocked ▶ Send is blocked if channel is full ▶ s1; s2 is blocked if s1 is blocked ▶ timeout is executable if all other statements are blocked. Programm Execution: 1. Finds all executable states 2. Choose non-deterministically one of them 3. Change state accordingly Executable vs blocked A statement can be executable or blocked ▶ Send is blocked if channel is full ▶ s1; s2 is blocked if s1 is blocked ▶ timeout is executable if all other statements are blocked. Programm Execution: 1. Finds all executable states 2. Choose non-deterministically one of them 3. Change state accordingly Promela Statements s k i p / / Always e x e c u t a b l e t i m e o u t / / Executable i f a l l o t h e r are blocked a s s e r t (E) / / Always e x e c u t a b l e x = E / / Always e x e c u t a b l e a [ n ] = E / / Always e x e c u t a b l e x > 0 ; / / Execuatble i f E e v a l u a t e s t o non zero ( t r u e ) Promela Selection i f : : s1 / / o p t i o n 1 : : . . . : : sn / / o p t i o n n f i Executable if at least one option is executable. Chooses an option non-deterministically and executes it. i f / * Move a s p r i t e * / : : x < maxX −> x = x + 1 ; : : x > minX −> x = x − 1 ; : : y < maxY −> y = y + 1 ; : : y > minY −> y = y − 1 ; : : c o l o r = c o l o r + 1 ; f i else is executable iff all the others in the if fi are not. Promela Selection i f : : s1 / / o p t i o n 1 : : . . . : : sn / / o p t i o n n f i Executable if at least one option is executable. Chooses an option non-deterministically and executes it. i f / * Move a s p r i t e * / : : x < maxX −> x = x + 1 ; : : x > minX −> x = x − 1 ; : : y < maxY −> y = y + 1 ; : : y > minY −> y = y − 1 ; : : c o l o r = c o l o r + 1 ; f i else is executable iff all the others in the if fi are not. Promela Selection i f : : s1 / / o p t i o n 1 : : . . . : : sn / / o p t i o n n f i Executable if at least one option is executable. Chooses an option non-deterministically and executes it. i f / * Move a s p r i t e * / : : x < maxX −> x = x + 1 ; : : x > minX −> x = x − 1 ; : : y < maxY −> y = y + 1 ; : : y > minY −> y = y − 1 ; : : c o l o r = c o l o r + 1 ; f i else is executable iff all the others in the if fi are not. Promela Repetition do : : s1 / * o p t i o n 1 * / : : . . . : : sn / * o p t i o n n * / od Executable if at least one of its options is executable. do : : n > 1 −> r = r * n ; n = n −1; : : e l s e −> break od Promela Repetition do : : s1 / * o p t i o n 1 * / : : . . . : : sn / * o p t i o n n * / od Executable if at least one of its options is executable. do : : n > 1 −> r = r * n ; n = n −1; : : e l s e −> break od Promela Atomic Example: / / l o c k atomic { l o c k e d == 0 ; l o c k e d = 1 ; } / / c r i t i c a l s e c t i o n l o c k e d = 0 ; Executable if the first statement of s is executable. Übung Lets write some Promela :) Generelle Übungen - FS20Generell Übungen - Optional Sheet 10Das wars :) Figure: Feedback Umfrage Weiterhin erreichbar: ▶ Mail: rawick@ethz.ch ▶ Discord: the_ray_man","libVersion":"0.5.0","langs":""}