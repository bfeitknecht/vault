{"path":"sem2a/DDCA/VRL/slides/DDCA-L12a_MIPS-ASM.pdf","text":"Carnegie Mellon 1 Digital Design and Computer Architecture Mohammad Sadrosadati Frank K. Gürkaynak Adapted from Digital Design and Computer Architecture, David Money Harris & Sarah L. Harris ©2007 Elsevier http://safari.ethz.ch/ddca MIPS Assembly Carnegie Mellon 2 In This Lecture ¢ Assembly Language ¢ Architecture Design Principles § Simplicity favors regularity § Make the common case fast § Smaller is faster § Good design demands good compromises ¢ Where to store data (memory/register) ¢ Main types of MIPS instructions § (R)egister type § (I)mmediate type § (J)ump type Carnegie Mellon 3 Introduction ¢ Jumping up a few levels of abstraction ¢ Architecture: the programmer’s view of the computer § Defined by instructions (operations) and operand locations ¢ Microarchitecture: Implementation of an architecture (Chapter 7) Abstraction Levels Examples Application Software Programs Operating Systems Device drivers Architecture Instructions, Registers Micro architecture Datapath, Controllers Logic Adders, Memories Digital Circuits AND gates, NOT gates Analog Circuits Amplifiers Devices Transistors, Diodes Physics Electrons Carnegie Mellon 4 Assembly Language ¢ To command a computer, you must understand its language § Instructions: words in a computer’s language § Instruction set: the vocabulary of a computer’s language ¢ Instructions indicate the operation to perform and the operands to use § Assembly language: human-readable format of instructions § Machine language: computer-readable format (1’s and 0’s) ¢ MIPS architecture: § Developed by John Hennessy and colleagues at Stanford in the 1980’s § Used in many commercial systems (Silicon Graphics, Nintendo, Cisco) ¢ Once you’ve learned one architecture, it’s easy to learn others Carnegie Mellon 5 John Hennessy ¢ President of Stanford University ¢ Professor of Electrical Engineering and Computer Science at Stanford since 1977 ¢ Co-invented the Reduced Instruction Set Computer (RISC) ¢ Developed the MIPS architecture at Stanford in 1984 and cofounded MIPS Computer Systems ¢ As of 2004, over 300 million MIPS microprocessors have been sold Carnegie Mellon 6 Architecture Design Principles ¢ Underlying design principles, as articulated by Hennessy and Patterson: § Simplicity favors regularity § Make the common case fast § Smaller is faster § Good design demands good compromises Carnegie Mellon 7 MIPS Instructions: Addition a = b + c; add a, b, c High-level code MIPS assembly ¢ add: mnemonic indicates what operation to perform ¢ b, c: source operands on which the operation is performed ¢ a: destination operand to which the result is written Carnegie Mellon 8 MIPS Instructions: Subtraction a = b - c; sub a, b, c High-level code MIPS assembly ¢ Subtraction is similar to addition, only mnemonic changes ¢ sub: mnemonic indicates what operation to perform ¢ b, c: source operands on which the operation is performed ¢ a: destination operand to which the result is written Carnegie Mellon 9 Design Principle 1 Simplicity favors regularity ¢ Consistent instruction format ¢ Same number of operands (two sources and one destination) § easier to encode and handle in hardware Carnegie Mellon 10 Instructions: More Complex Code a = b + c - d; add t, b, c # t = b + c sub a, t, d # a = t - d High-level code MIPS assembly code ¢ More complex code is handled by multiple MIPS instructions. Carnegie Mellon 11 Design Principle 2 Make the common case fast ¢ MIPS includes only simple, commonly used instructions ¢ Hardware to decode and execute the instruction can be simple, small, and fast ¢ More complex instructions (that are less common) can be performed using multiple simple instructions Carnegie Mellon 12 RISC and CISC ¢ Reduced instruction set computer (RISC) § means: small number of simple instructions § example: MIPS ¢ Complex instruction set computers (CISC) § means: large number of instructions § example: Intel’s x86 Carnegie Mellon 13 Operands ¢ A computer needs a physical location from which to retrieve binary operands ¢ A computer retrieves operands from: § Registers § Memory § Constants (also called immediates) Carnegie Mellon 14 Operands: Registers ¢ Main Memory is slow ¢ Most architectures have a small set of (fast) registers § MIPS has thirty-two 32-bit registers ¢ MIPS is called a 32-bit architecture because it operates on 32-bit data § A 64-bit version of MIPS also exists, but we will consider only the 32- bit version Carnegie Mellon 15 Design Principle 3 Smaller is Faster ¢ MIPS includes only a small number of registers ¢ Just as retrieving data from a few books on your table is faster than sorting through 1000 books, retrieving data from 32 registers is faster than retrieving it from 1000 registers or a large memory. Carnegie Mellon 16 The MIPS Register Set Name Register Number Usage $0 0 the constant value 0 $at 1 assembler temporary $v0-$v1 2-3 procedure return values $a0-$a3 4-7 procedure arguments $t0-$t7 8-15 temporaries $s0-$s7 16-23 saved variables $t8-$t9 24-25 more temporaries $k0-$k1 26-27 OS temporaries $gp 28 global pointer $sp 29 stack pointer $fp 30 frame pointer $ra 31 procedure return address Carnegie Mellon 17 Operands: Registers ¢ Written with a dollar sign ($) before their name § For example, register 0 is written “$0”, pronounced “register zero” or “dollar zero” ¢ Certain registers used for specific purposes: § $0 always holds the constant value 0 § the saved registers, $s0-$s7, are used to hold variables § the temporary registers, $t0 - $t9, are used to hold intermediate values during a larger computation ¢ For now, we only use the temporary registers ($t0 - $t9) and the saved registers ($s0 - $s7) ¢ We will use the other registers in later slides Carnegie Mellon 18 Instructions with registers a = b + c; # $s0 = a # $s1 = b # $s2 = c add $s0, $s1, $s2 High-level code MIPS assembly ¢ Revisit add instruction § The source and destination operands are now in registers Carnegie Mellon 19 Operands: Memory ¢ Too much data to fit in only 32 registers ¢ Store more data in memory § Memory is large, so it can hold a lot of data § But it’s also slow ¢ Commonly used variables kept in registers ¢ Using a combination of registers and memory, a program can access a large amount of data fairly quickly Carnegie Mellon 20 Word-Addressable Memory ¢ Each 32-bit data word has a unique address Data 00000003 4 0 F 3 0 7 8 8 0 1 E E 2 8 4 2 F 2 F 1 A C 0 7 A B C D E F 7 8 00000002 00000001 00000000 Word Address Word 3 Word 2 Word 1 Word 0 Carnegie Mellon 21 Reading Word-Addressable Memory lw $s3, 1($0) # read memory word 1 into $s3 ¢ Memory reads are called loads ¢ Mnemonic: load word (lw) ¢ Example: read a word of data at memory address 1 into $s3 Data 00000003 4 0 F 3 0 7 8 8 0 1 E E 2 8 4 2 F 2 F 1 A C 0 7 A B C D E F 7 8 00000002 00000001 00000000 Word Address Word 3 Word 2 Word 1 Word 0 Carnegie Mellon 22 Reading Word-Addressable Memory lw $s3, 1($0) # read memory word 1 into $s3 ¢ Example: read a word of data at memory address 1 into $s3 ¢ Memory address calculation: § add the base address ($0) to the offset (1) § address = ($0 + 1) = 1 § $s3 holds the value 0xF2F1AC07 after the instruction completes ¢ Any register may be used to store the base address Data 00000003 4 0 F 3 0 7 8 8 0 1 E E 2 8 4 2 F 2 F 1 A C 0 7 A B C D E F 7 8 00000002 00000001 00000000 Word Address Word 3 Word 2 Word 1 Word 0 Carnegie Mellon 23 Writing Word-Addressable Memory sw $t4, 0x7($0) # write the value in $t4 # to memory word 7 ¢ Memory writes are called stores ¢ Mnemonic: store word (sw) ¢ Example: Write (store) the value held in $t4 into memory address 7 Data 00000003 4 0 F 3 0 7 8 8 0 1 E E 2 8 4 2 F 2 F 1 A C 0 7 A B C D E F 7 8 00000002 00000001 00000000 Word Address Word 3 Word 2 Word 1 Word 0 Carnegie Mellon 24 Writing Word-Addressable Memory sw $t4, 0x7($0) # write the value in $t4 # to memory word 7 ¢ Example: Write (store) the value held in $t4 into memory address 7 ¢ Memory address calculation: § add the base address ($0) to the offset (7) § address = ($0 + 7) = 7 § Offset can be written in decimal (default) or hexadecimal ¢ Any register may be used to store the base address Data 00000003 4 0 F 3 0 7 8 8 0 1 E E 2 8 4 2 F 2 F 1 A C 0 7 A B C D E F 7 8 00000002 00000001 00000000 Word Address Word 3 Word 2 Word 1 Word 0 Carnegie Mellon 25 Byte-Addressable Memory ¢ Each data byte has a unique address ¢ Load/store words or single bytes: load byte (lb) and store byte (sb) ¢ Each 32-bit words has 4 bytes, so the word address increments by 4. MIPS uses byte addressable memory Word Address Data 0000000C 00000008 00000004 00000000 width = 4 bytes 4 0 F 3 0 7 8 8 0 1 E E 2 8 4 2 F 2 F 1 A C 0 7 A B C D E F 7 8 Word 3 Word 2 Word 1 Word 0 Carnegie Mellon 26 Reading Byte-Addressable Memory lw $s3, 4($0) # read word at address 4 into $s3 ¢ Load a word of data at memory address 4 into $s3. ¢ Memory address calculation: § add the base address ($0) to the offset (4) § address = ($0 + 4) = 4 ¢ $s3 holds the value 0xF2F1AC07 after the instruction completes Word Address Data 0000000C 00000008 00000004 00000000 width = 4 bytes 4 0 F 3 0 7 8 8 0 1 E E 2 8 4 2 F 2 F 1 A C 0 7 A B C D E F 7 8 Word 3 Word 2 Word 1 Word 0 Carnegie Mellon 27 Writing Byte-Addressable Memory sw $t7, 44($0) # write $t7 into address 44 ¢ Example: store the value held in $t7 into the eleventh 32- bit memory location. ¢ Memory address calculation: § Byte addressable address for word eleven 11x4 = 4410 = 0x2C16 § add the base address ($0) to the offset (0x2c) § address = ($0 + 44) = 44 Carnegie Mellon 28 Big-Endian and Little-Endian Memory ¢ How to number bytes within a word? ¢ Word address is the same for big- or little-endian § Little-endian: byte numbers start at the little (least significant) end § Big-endian: byte numbers start at the big (most significant) end 0 1 2 3 MSB LSB 4 5 6 7 8 9 A B C D E F Byte Address 3 2 1 00 7 6 5 44 B A 9 88 F E D CC Byte Address Word Address Big-Endian Little-Endian MSB LSB Carnegie Mellon 29 Big-Endian and Little-Endian Memory ¢ From Jonathan Swift’s Gulliver’s Travels where the Little- Endians broke their eggs on the little end of the egg and the Big-Endians broke their eggs on the big end. § As indicated by the farcical name, it doesn’t really matter which addressing type is used – except when the two systems need to share data! 0 1 2 3 MSB LSB 4 5 6 7 8 9 A B C D E F Byte Address 3 2 1 00 7 6 5 44 B A 9 88 F E D CC Byte Address Word Address Big-Endian Little-Endian MSB LSB Carnegie Mellon 30 Big- and Little-Endian Example ¢ Suppose $t0 initially contains 0x23456789. After the following program is run on a big-endian system, what value does $s0 contain? In a little-endian system? sw $t0, 0($0) lb $s0, 1($0) 23 45 67 89 0 1 2 3 23 45 67 890 3 2 1 0 Word Address Big-Endian Little-Endian Byte Address Data Value Byte Address Data Value MSB LSB MSB LSB Carnegie Mellon 31 Big- and Little-Endian Example ¢ Suppose $t0 initially contains 0x23456789. After the following program is run on a big-endian system, what value does $s0 contain? In a little-endian system? sw $t0, 0($0) lb $s0, 1($0) ¢ Big-endian: 0x00000045 Little-endian: 0x00000067 23 45 67 89 0 1 2 3 23 45 67 890 3 2 1 0 Word Address Big-Endian Little-Endian Byte Address Data Value Byte Address Data Value MSB LSB MSB LSB Carnegie Mellon 32 Design Principle 4 Good design demands good compromises ¢ Multiple instruction formats allow flexibility § add, sub: use 3 register operands § lw, sw: use 2 register operands and a constant ¢ Number of instruction formats kept small § to adhere to design principles 1 and 3 (simplicity favors regularity and smaller is faster) Carnegie Mellon 33 Operands: Constants/Immediates a = a + 4; b = a – 12; # $s0 = a, $s1 = b addi $s0, $s0, 4 addi $s1, $s0, -12 High-level code MIPS assembly code ¢ lw and sw illustrate the use of constants or immediates § Called immediates because they are directly available § Immediates don’t require a register or memory access ¢ The add immediate (addi) instruction adds an immediate to a variable (held in a register) § An immediate is a 16-bit two’s complement number ¢ Is subtract immediate (subi) necessary? Carnegie Mellon 34 Machine Language ¢ Computers only understand 1’s and 0’s ¢ Machine language: binary representation of instructions ¢ 32-bit instructions § Again, simplicity favors regularity: 32-bit data, 32-bit instructions, and possibly also 32-bit addresses ¢ Three instruction formats: § R-Type: register operands § I-Type: immediate operand § J-Type: for jumping (we’ll discuss later) Carnegie Mellon 35 R-Type ¢ Register-type, 3 register operands: § rs, rt: source registers § rd: destination register ¢ Other fields: § op: the operation code or opcode (0 for R-type instructions) § funct: the function together, the opcode and function tell the computer what operation to perform § shamt: the shift amount for shift instructions, otherwise it’s 0 op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits R-Type Carnegie Mellon 36 R-Type Examples add $s0, $s1, $s2 sub $t0, $t3, $t5 Assembly Code 0 17 18 16 0 32 Field Values 0 11 13 8 0 34 op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits 000000 10001 10010 10000 00000 100000 op rs rt rd shamt funct 000000 01011 01101 01000 00000 100010 Machine Code 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits (0x02328020) (0x016D4022) Note the order of registers in the assembly code: add rd, rs, rt Carnegie Mellon 37 I-Type ¢ Immediate-type, has 3 operands: § rs, rt: register operands § imm: 16-bit two’s complement immediate ¢ Other fields: § op: the opcode ¢ Simplicity favors regularity: all instructions have opcode ¢ Operation is completely determined by the opcode op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type Carnegie Mellon 38 I-Type Examples Assembly Code 8 17 16 5 Field Values op rs rt imm 6 bits 5 bits 5 bits 16 bits addi $s0, $s1, 5 addi $t0, $s3, -12 lw $t2, 32($0) sw $s1, 4($t1) 8 19 8 -12 35 0 10 32 43 9 17 4 (0x22300005) (0x2268FFF4) (0x8C0A0020) (0xAD310004) 001000 10001 10000 0000 0000 0000 0101 op rs rt imm Machine Code 6 bits 5 bits 5 bits 16 bits 001000 10011 01000 1111 1111 1111 0100 100011 00000 01010 0000 0000 0010 0000 101011 01001 10001 0000 0000 0000 0100 Note the differing order of registers in the assembly and machine codes: addi rt, rs, imm lw rt, imm(rs) sw rt, imm(rs) Carnegie Mellon 39 Machine Language: J-Type ¢ Jump-type ¢ 26-bit address operand (addr) ¢ Used for jump instructions (j) op addr 6 bits 26 bits J-Type Carnegie Mellon 40 Review: Instruction Formats op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits R-Type op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type op addr 6 bits 26 bits J-Type Carnegie Mellon 41 The Power of the Stored Program ¢ 32-bit instructions and data stored in memory ¢ Sequence of instructions: only difference between two applications (for example, a text editor and a video game) ¢ To run a new program: § No rewiring required § Simply store new program in memory ¢ The processor hardware executes the program: § fetches (reads) the instructions from memory in sequence § performs the specified operation Carnegie Mellon 42 Program counter ¢ The processor hardware executes the program: § fetches (reads) the instructions from memory in sequence § performs the specified operation § continues with the next instruction ¢ The program counter (PC) keeps track of the current instruction § In MIPS, programs typically start at memory address 0x00400000 Carnegie Mellon 43 The Stored Program addi $t0, $s3, -12 Machine CodeAssembly Code lw $t2, 32($0) add $s0, $s1, $s2 sub $t0, $t3, $t5 0x8C0A0020 0x02328020 0x2268FFF4 0x016D4022 Address Instructions 0040000C 0 1 6 D 4 0 2 2 2 2 6 8 F F F 4 0 2 3 2 8 0 2 0 8 C 0 A 0 0 2 0 00400008 00400004 00400000 Stored Program Main Memory PC Carnegie Mellon 44 Interpreting Machine Language Code ¢ Start with opcode § Opcode tells how to parse the remaining bits ¢ If opcode is all 0’s § R-type instruction § Function bits tell what instruction it is ¢ Otherwise § opcode tells what instruction it is 001000 10001 10111 1111 1111 1111 0001 op rs rt imm addi $s7, $s1, -15 Machine Code Assembly Code 8 17 23 -15 Field Values (0x2237FFF1) op rs rt imm 2 2 3 7 F F F 1 000000 10111 10011 01000 00000 100010 op rs rt rd shamt funct sub $t0, $s7, $s3 0 23 19 8 0 34(0x02F34022) op rs rt rd shamt funct 0 2 F 3 4 0 2 2 Carnegie Mellon 45 What did we learn? ¢ Addressing types § Byte addressable (MIPS is byte addressable) § Word addressable ¢ Three different types of MIPS instructions § R-type: operates on registers § I-type: immediate type, using constants § J-type: for jump instructions, 24 bit address","libVersion":"0.3.2","langs":""}