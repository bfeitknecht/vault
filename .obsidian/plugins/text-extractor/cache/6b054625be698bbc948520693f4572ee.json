{"path":"sem4/FMFP/UE/e/exercises-w5.pdf","text":"Formal Methods and Functional Programming Exercise Sheet 5 252-0058-00L March 17, 2025 For the first part of the course, there will be both pen-and-paper exercises and programming exercises. The programming exercises are uploaded on Code Expert: https://expert.ethz.ch/enrolled/SS25/fmfp/exercises Happy coding! As for the pen-and paper exercises, each week you may hand in your solution to the exercise marked with a (⋆) and receive feedback from your TA. You are encouraged to do so. Of course, if you have any questions about the solutions of the other exercises, please also reach out to your TA! Exercises marked as weekly headaches are challenging bonus problems. They are just meant as supplements to test your FMFP skills. 1. Types (Exercise from last week) Give the most general type for each of the following functions. (a) (\\x y z -> (x y) z) (b) (\\f -> fst (f,f)) (c) (\\p f -> filter p . map f) 2(⋆). More types (a) Recall the following functions from the Haskell Prelude. (<) :: Ord a => a -> a -> Bool (.) :: (b -> c) -> (a -> b) -> a -> c flip :: (a -> b -> c) -> b -> a -> c id :: a -> a Give the most general type for each of the following functions. 1. (\\x y z -> x (y z)) 2. (\\f -> (\\h -> (f,h))) 3. (\\x -> x (<)) 4. (.) . (.) 5. flip id 1 Formal Methods and Functional Programming Exercise Sheet 5 252-0058-00L March 17, 2025 (b) For each type given below, find an expression with exactly the same most general type. 1. (a -> a -> b) -> a -> b 2. (a -> b) -> [a] -> b 3. (Num a, Eq b) => (b -> Bool) -> [b] -> [a] Hint: Lambda abstractions, applications, and the above library functions suffice to build such expressions. Your solution may also use other functions from the Haskell Prelude. (c) We extend Mini-Haskell with the let construct that binds a term t1 locally to a variable x in term t2: let x = t1 in t2 We do not allow recursive usage of x in t1 unlike in Haskell. The extended term language is as follows, where V is a set of variables and Z is the set of integers: t ::= V | (\\x -> t) | (t1 t2) | True | False | (isZero t) | Z | (t1 + t2) | (t1 * t2) | (if t0 then t1 else t2) | (t1 , t2) | (fst t1) | (snd t2) | (let x = t1 in t2) Give the typing rule for the let constructor. 3. Typing proofs and Inference Use the typing rules for Mini-Haskell (recalled below) to prove the following statement. (a) λx.(x 1 True, x 0) :: (Int -> Bool -> a) -> (a, Bool -> a) Now use those typing rules to infer the type of the following expressions, if possible. (b) (λ x.( λy.(y (iszero (y x))))) True (c) λ x.λy. if y x then (fst x) else (snd (snd x)) (d) iszero (fst (3+5)) (e) (λ x. 0) (True 5) 2 Formal Methods and Functional Programming Exercise Sheet 5 252-0058-00L March 17, 2025 We recall the typing rules for Mini-Haskell: 3","libVersion":"0.3.2","langs":""}