{"path":"sem3/A&D/VRL/script/A&D-script-w02-landau.pdf","text":"Skript zur Vorlesung Algorithmen und Datenstrukturen Woche 2: Star Suche und Asymptotische Analyse Herbstsemester 2024 Stand: 16. Oktober 2024 Johannes Lengler David Steurer Inhaltsverzeichnis 1 Star Suche 1 2 Berechnungsmodell und asymptotische Analyse 5 i ii Kapitel 1 Star Suche Wenn wir uns vorstellen, dass eine ber¨uhmte Person wie Roger Federer zu einer Vorlesung an der ETH Z¨urich kommt, dann werden vermutlich alle anderen Personen im Vorlesungssaal diese ber¨uhmte Person erkennen. Andererseits erwarten wir, dass diese ber¨uhmte Person keine andere Person im Saal erkennt. Mit diesem Beispiel im Hinterkopf definieren wir eine Person Ps als Star einer Gruppe von n Personen P1, . . . , Pn, falls alle anderen Personen Pt f¨ur t ̸= s die Person Ps kennen und gleichzeitig die Person Ps keine andere Person Pt der Gruppe f¨ur t ̸= s kennt. Wir betrachten die folgenden Beispiele von Gruppen mit jeweils drei Personen. In den Diagrammen bedeutet ein Pfeil von einer Person Pi zu einer Person Pj, dass die Person Pi die Person Pj kennt. P3 P1 P2 Star P3 P3 P1 P2 kein Star! Das zweite Beispiel zeigt, dass es in manchen Gruppen keinen Star gibt. Wir k¨onnen uns davon ¨uberzeugen, dass es nie mehr als einen Star geben kann. Denn falls Ps ein Star ist, dann kennt jede andere Person Pt mit t ̸= s den Star Ps und ist damit selbst kein Star. Fragestellung Wir wollen einen Algorithmus entwerfen, der den Star in einer Grup- pe von n Personen findet, falls es einen Star gibt. Der Algorithmus darf nur Ja/Nein- Fragen der folgenden Form stellen: “Kennt Person Pi die Person Pj?”. Das Ziel ist es, einen Algorithmus zu entwerfen, der mit m¨oglichst wenigen solcher Fragen aus- kommt. Naiver Algorithmus Ein naiver Algorithmus f¨ur die Star-Suche stellt alle m¨oglichen Fragen. F¨ur jede Person Pi gibt es n − 1 andere Personen Pj mit j ̸= i, die Pi kennen k¨onnte. Insgesamt gibt es also n · (n − 1) m¨ogliche Fragen. Nach dem Stellen aller Fragen weiss der Algorithmus alle “Kennt-Beziehungen” innerhalb der Gruppe und kann damit den Star bestimmen, falls es einen gibt. 1 2 Star Suche Geht es besser? Es stellt sich die Frage, ob es einen besseren Algorithmus gibt, der wesentlich weniger als n · (n − 1) Fragen ben¨otigt. Rekursiver Algorithmus Um einen besseren Algorithmus zu finden, verfolgen wir eine rekursive Strategie: Wir versuchen, die Star-Suche in einer Gruppe von n Perso- nen auf die Star-Suche in einer Gruppe von n − 1 Personen zur¨uckzuf¨uhren. F¨ur den Basisfall n = 2 k¨onnen wir den Star einfach durch das Stellen der beiden m¨oglichen Fragen finden. F¨ur n ⩾ 3 f¨uhren wir die Star-Suche wie folgt rekursiv aus. 1. Finde den Star Ps in der Gruppe P1, P2, . . . , Pn−1. 2. Teste, ob Ps ein Star in der Gruppe P1, P2, . . . , Pn ist, indem die beiden fol- genden Fragen gestellt werden: ‹ Kennt Ps die Person Pn? ‹ Kennt Pn die Person Ps? Falls Ps kein Star ist, dann fahre mit dem n¨achsten Schritt fort. 3. Teste, ob Pn ein Star in der Gruppe P1, P2, . . . , Pn ist, indem f¨ur alle i = 1, 2, . . . , n − 1 die folgenden Fragen gestellt werden: ‹ Kennt Pi die Person Pn? ‹ Kennt Pn die Person Pi? Best-Case-Analyse Der rekursive Algorithmus ben¨otigt im Best Case nur 2(n − 1) Fragen. Dieser Fall tritt ein, falls der Algorithmus in keiner der rekursiven Aufrufen Schritt 3 ausf¨uhren muss und den Star immer schon bei Schritt 2 findet. Dieser Best Case tritt f¨ur das folgende Beispiel ein: P1 P2 P3 . . . Pn−1 Pn Die folgende Tabelle verdeutlicht die Anzahl der gestellten Fragen in diesem Best Case. F¨ur den Basisfall (zwei Personen) ben¨otigen wir zwei Fragen. Wir f¨uhren n − 2 rekursive Aufrufe aus und f¨ur jeden rekursiven Aufruf stellen wir zwei zus¨atzliche Fragen, um den Star in Schritt 2 zu ermitteln. Insgesamt stellen wir daher 2 + (n − 2) · 2 = 2(n − 1) Fragen. Personen 2 3 4 . . . n Total Fragen 2 +2 +2 . . . +2 2(n − 1) 1.0 Star Suche 3 Worst-Case-Analyse Der Worst Case tritt ein, falls die Person, die vor jedem re- kursiven Aufruf aus der Gruppe entfernt wird, sich als Star der Gruppe herausstellt. In diesem Fall m¨ussen wir Schritt 3 f¨ur jeden rekursiven Aufruf ausf¨uhren. P1 P2 P3 . . . Pn−1 Pn Wir verdeutlichen die Anzahl der gestellten Fragen mithilfe der folgenden Ta- belle. Im Basisfall (zwei Personen) ben¨otigen wir wie zuvor zwei Fragen. Allerdings m¨ussen wir f¨ur jeden rekursiven Aufruf 2(n − 1) zus¨atzliche Fragen stellen, um zu testen, ob die entfernte Person der Star ist. Insgesamt berechnet sich die Anzahl der gestellten Fragen als das Doppelte der Summe der ersten n − 1 nat¨urlichen Zahlen. Diese Summe betr¨agt 1 2 n · (n − 1). Also stellt der rekursive Algorithmus im Worst Case n · (n − 1) Fragen, genau so viele Fragen wie der naive Algorithmus. Personen 2 3 4 . . . n Total Fragen 2 +2 · 2 +2 · 3 . . . +2(n − 1) n(n − 1) Verbesserung Der rekursive Algorithmus l¨asst sich tats¨achlich so verbessern, dass er im Worst Case nur noch 3n − 4 Fragen ben¨otigt. Die Idee der Verbesserung ist es, vor jedem rekursiven Aufruf sicherzustellen, dass die Person, die aus der Gruppe entfernt wird, garantiert kein Star ist. Dazu f¨uhren wir vor Schritt 1 des rekursiven Algorithmus den folgenden Schritt aus: 0. Falls Pn−1 die Person Pn kennt, dann vertausche Pn−1 und Pn. Beachte, dass dieser Schritt nur eine zus¨atzliche Frage ben¨otigt. Zudem ist die Person, die nach diesem Schritt als Pn bezeichnet wird, garantiert kein Star. Falls n¨amlich die urspr¨ungliche Person Pn ein Star ist, dann kennt Pn−1 die Person Pn und die beiden Personen werden vertauscht. Nach dem Vertauschen ist Pn kein Star mehr, da Pn die Person Pn−1 kennt. Falls wir in diesem Schritt die beiden letzten Person vertauschen, dann ist die urspr¨ungliche Person Pn−1 garantiert kein Star, da sie ja die urspr¨unglich als Pn bezeichnete Person kennt. Die folgende Tabelle veranschaulicht die Worst-Case-Analyse dieses Algorithmus. F¨ur jeden rekursiven Aufruf ben¨otigt der Algorithmus nun h¨ochstens 3 Fragen, eine Frage bei Schritt 0 und zwei Fragen bei Schritt 2. (Es kann sein, dass diese Fragen nicht alle verschieden sind.) Also ben¨otigt der Algorithmus insgesamt h¨ochstens 3(n − 2) + 2 = 3n − 4 ver- schiedene Fragen. Personen 2 3 4 5 . . . n Total Fragen 2 +3 +3 +3 . . . +3 2 + 3 · (n − 2) = 3n − 4 Zusammenfassung Wir haben gesehen, dass sich der naive Algorithmus f¨ur die Star-Suche, der im Worst Case n(n − 1) Fragen stellt, durch einen rekursiven Al- gorithmus verbessern l¨asst, der nur 3n − 4 Fragen ben¨otigt. Die Verbesserungsidee war, den Algorithmus so zu modifizieren, dass wir vor jedem rekursiven Aufruf eine Person aus der Gruppe entfernen, die garantiert kein Star ist. 4 Star Suche Kapitel 2 Berechnungsmodell und asymptotische Analyse Wir haben mehrere Beispiele von Problemen betrachtet, f¨ur die wir unterschiedliche L¨osungsverfahren miteinander verglichen haben. F¨ur die n-stellige Multiplikation haben wir die schriftliche Multiplikation und den Karatsuba-Algorithmus dahinge- hend verglichen, wie viele 1-stellige Multiplikationen sie ausf¨uhren. F¨ur das Pasture- Break-Problem haben wir die L¨osungsverfahren dahingehend verglichen, wie viele Schritte die Kuh im Worst Case zur¨ucklegen muss. F¨ur die Star-Suche haben wir die Anzahl der gestellten Fragen im Worst Case analysiert. In diesem Abschnitt wollen wir diese Vorgehensweise verallgemeinern und forma- le Werkzeuge entwickeln, die es uns erlauben, Algorithmen f¨ur beliebige Probleme sinnvoll miteinander zu vergleichen. Kriterien Um Algorithmen zu bewerten und miteinander zu vergleichen, werden wir in dieser Vorlesung zwei Kriterien besonders hervorheben: Korrektheit und Lauf- zeit. ‹ Ein Algorithmus ist korrekt, falls er f¨ur jede Eingabe die gew¨unschte Ausgabe liefert. ‹ Die Laufzeit eines Algorithmus misst, wie viel Zeit ein Algorithmus braucht, um eine Ausgabe zu berechnen, meist in Abh¨angigkeit von der Gr¨osse der Eingabe. Herausforderungen Wenn wir diese beiden Kriterien verwenden wollen, um Algo- rithmen zu bewerten und miteinander zu vergleichen, dann m¨ussen wir verschiedene Herausforderungen bew¨altigen. Zum einen ist es zun¨achst unklar, wie wir uns da- von ¨uberzeugen k¨onnen, dass ein Algorithmus wirklich f¨ur alle m¨oglichen Eingaben ein korrektes Ergebnis liefert. Zum anderen h¨angt die Laufzeit eines Algorithmus oft stark von der jeweiligen Eingabe ab, sodass der Algorithmus f¨ur manche Ein- gaben deutlich schneller ist als f¨ur andere. Des Weiteren h¨angt die Laufzeit eines Algorithmus von der Maschine ab, auf der er ausgef¨uhrt wird. Moderne Computer rechnen in der Regel wesentlich schneller als ¨altere Computer. Die Laufzeit h¨angt auch davon ab, welche Schnittstellen zu den Maschinen wir verwenden, z.B. welche Programmiersprache. Ziel Unser Ziel ist es, universelle Garantien f¨ur die Korrektheit und die Laufzeit von Algorithmen zu erhalten. Das heisst, wir wollen Aussagen ¨uber Algorithmen treffen, die f¨ur alle Eingaben und alle Maschinen gelten. 5 6 Berechnungsmodell und asymptotische Analyse L¨osungsansatz Um dieses Ziel zu erreichen, werden wir in dieser Vorlesung zwei wichtige Strategien verwenden: mathematische Beweise sowie Abstraktionen und Modelle. ‹ Mathematische Beweise erlauben uns, Allaussagen ¨uber Algorithmen zu tref- fen, die f¨ur alle m¨oglichen Eingaben gelten. ‹ Abstraktionen und Modelle erlauben uns, Aussagen ¨uber die Laufzeit eines Algorithmus zu treffen, unabh¨angig von der konkreten Maschine, auf der der Algorithmus ausgef¨uhrt wird. Wenn wir diese Abstraktionen und Modelle ver- wenden, verlieren unsere Aussagen zwar ein gewisses Mass an Aussagekraft f¨ur konkrete Maschinen. Die verbleibende Aussagekraft reicht aber in den meisten F¨allen aus, um Algorithmen quantitativ in Bezug auf ihre Laufzeit miteinander zu vergleichen. Berechnungsmodell Wir verwenden in dieser Vorlesung ein stark vereinfachtes Berechnungsmodell, das als stilisierter Computer interpretiert werden kann. Die- ser stilisierte Computer besteht aus zwei Komponenten: einem Speicher und einem Prozessor, die ¨uber einen Bus miteinander Daten austauschen k¨onnen. . . . . . . Speicher Prozessor Der Speicher ist eine unendlich lange Liste von Speicherzellen. Jede Speicherzel- le ist entweder leer oder enth¨alt eine ganze Zahl. Zu Beginn der Berechnung ist die Eingabe auf den ersten n Speicherzellen gespeichert und alle anderen Speicherzellen sind leer. Wir bezeichnen dann n als Eingabegr¨osse. Zudem nehmen wir an, dass es eine obere Schranke f¨ur die Gr¨osse der Zahlen gibt, die in einer Speicherzelle gespei- chert werden k¨onnen. Diese obere Schranke h¨angt polynomiell von der Gr¨osse der Eingabe ab. Konkret k¨onnen wir uns n100 als Schranke vorstellen. Die Speicherzellen sind frei adressierbar. Das heisst der Prozessor kann auf jede Speicherzelle zugreifen, indem er die Adresse der Speicherzelle angibt, also die Position der Speicherzelle in der Liste. Der Prozessor kann elementare Operationen ausf¨uhren. Zu diesen elementaren Operationen geh¨oren: ‹ Lesen und Schreiben von Speicherzellen, ‹ Vergleichen von Zahlen, z.B. testen, ob zwei Zahlen gleich sind oder ob eine Zahl gr¨osser ist als eine andere, ‹ Rechnen mit Zahlen, z.B. Addieren, Subtrahieren, Multiplizieren und Dividie- ren. 2.0 Berechnungsmodell und asymptotische Analyse 7 Die Laufzeit eines Algorithmus in diesem Modell definieren wir als die Anzahl der elementaren Operationen, die der Prozessor ausf¨uhrt, um die gew¨unschte Ausgabe zu berechnen. Vergleich mit der Praxis Wie realistisch ist dieses einfache Berechnungsmodell? Tats¨achlich gibt es Unterschiede zu realen Computern, insbesondere in Bezug auf die Organisation und die Geschwindigkeit des Speichers. Reale Computer haben oft eine Hierarchie von Speichern, die sich in ihrer Gr¨osse und Geschwindigkeit unterscheiden. Zum Beispiel haben moderne Computer oft einen Cache, der einen kleinen, aber sehr schnellen Speicher darstellt, in dem die Daten gespeichert werden, auf die der Prozessor am h¨aufigsten zugreift. Diese Speicherhierarchie hat zur Folge, dass Speicherzugriffe unterschiedlich viel Zeit beanspruchen, je nachdem, wo sich die angefragten Daten gerade in der Speicherhierarchie befinden. Trotz dieser erheblichen Unterschiede zu realen Computern erlaubt uns dieses einfache Berechnungsmodell, die Laufzeit von Algorithmen in einer Weise zu ana- lysieren, die zu einem gewissen Mass Aussagen ¨uber die Laufzeit auf konkreten Maschinen zul¨asst. Wir k¨onnen diesen Zusammenhang wie folgt formalisieren. F¨ur jede Maschine und jede Implementierung eines Algorithmus gibt es Konstanten C1 und C2, so dass f¨ur alle Eingaben I gilt, C1 · TModell(I) ⩽ TMaschine(I) ⩽ C2 · TModell(I) , wobei TModell(I) die Laufzeit des Algorithmus im Modell f¨ur die Eingabe I ist und TMaschine(I) die Laufzeit des Algorithmus auf der Maschine f¨ur die Eingabe I ist. Diese Ungleichung besagt, dass die Laufzeit des Algorithmus im Modell h¨ochstens um einen konstanten Faktor von der Laufzeit des Algorithmus auf der Maschine abweicht. Beachte, dass die Konstanten C1 und C2 von der Maschine und der Implemen- tierung abh¨angen k¨onnen. Allerdings d¨urfen sie nicht von der Eingabe I abh¨angen. Die Rechtfertigung f¨ur die Ungleichung ist, dass jede elementare Operation in unse- rem Modell mindestens Zeit C1 und h¨ochstens Zeit C2 auf der konkreten Maschine ben¨otigt. Konsequenzen f¨ur die Laufzeitanalyse Da unser Berechnungsmodell die Laufzeit auf realen Maschinen nur bis auf konstante Faktoren erfasst, macht es keinen Sinn, konstante Faktoren bei Laufzeiten in unserem Modell zu unterscheiden. Das heisst, zwei Algorithmen, deren Laufzeiten sich in unserem Modell nur um einen konstanten Faktor unterscheiden, m¨ussen wir als gleichwertig auffassen. Um diese Idee zu formalisieren, verwenden wir die asymptotische Notation. Die- se Notation erlaubt es uns, konstante Faktoren zu ignorieren und stattdessen das Wachstumsverhalten von Funktionen zu beschreiben. Asymptotische Notation Sei N eine Menge m¨oglicher Eingabegr¨ossen, z.B. die Menge aller nat¨urlichen Zahlen gr¨osser gleich 2. Sei f : N → R+ eine Funktion, die jeder Eingabegr¨osse n ∈ N eine positive reelle Zahl f (n) zuordnet. Zum Beispiel k¨onnte f (n) die Laufzeit eines Algorithmus im Worst Case f¨ur Eingaben der Gr¨osse n sein. Die Ordnung von f , geschrieben O(f ), ist die Menge aller Funktionen g : N → 8 Berechnungsmodell und asymptotische Analyse R+, f¨ur die es eine Konstante C > 0 gibt, so dass f¨ur alle n ∈ N gilt, g(n) ⩽ C · f (n) . Die Bedingung g ∈ O(f ) ist ¨aquivalent dazu, dass die Funktion g(n) f (n) f¨ur n ∈ N beschr¨ankt ist. In diesem Fall schreiben wir g(n) ⩽ O(f (n)). Diese Schreibweise legt nahe, dass wir O(f (n)) als Platzhalter f¨ur einen unbestimmten konstanten Faktor auffassen k¨onnen. Beispiele 1. Die Funktion g(n) = 10n1.6 + 1000n + 100 ist in O(n1.6), denn f¨ur n ⩾ 1 gilt, g(n) n1.6 = 10 + 1000 n0.6 + 100 n1.6 ⩽ 10 + 1000 + 100 = 1110. Also k¨onnen wir C = 1110 w¨ahlen. 2. Die Funktion g(n) = 0.0001n2 ist nicht in O(n1.6), denn g(n) n1.6 = 0.0001n0.4 ist unbeschr¨ankt f¨ur n ⩾ 1. Zusammenfassung Mithilfe des eingef¨uhrten Berechnungsmodells und der asym- ptotischen Notation k¨onnen wir die Laufzeit von Algorithmen unabh¨angig von konkreten Maschinen analysieren. Die asymptotische Notation erlaubt es uns, das Wachstumsverhalten von Funktionen zu beschreiben, indem wir konstante Faktoren ignorieren. In den folgenden Abschnitten werden wir diese Werkzeuge verwenden, um die Laufzeit von verschiedenen Algorithmen zu analysieren und zu vergleichen.","libVersion":"0.3.2","langs":""}