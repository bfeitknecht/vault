{"path":"sem2a/PProg/VRL/extra/benji/PProg-w11-benji.pdf","text":"Parallel Programming Exercise Session 11 Outline 2 1. Feedback: Assignment 10 2. Barrier Repetition 3. Assignment 11 4. Kahoot Feedback: Assignment 10 3 Assignment 10 4 Dining Philosophers: One philosophers left side is anothers right side! But we take left first, then right. So we hold one fork, then wait – leads to cycle in dependency graph. Essential Assignment 10 5 Dining Philosophers: • To avoid cyclic dependencies: Lock-ordering! • Number all forks, take the one with smaller number first. • Same principle we saw with bank-account already! Essential Assignment 10 6 F0 F1 F2 F3 F4 Take smaller first - success Take bigger next - success Take smaller first - success Take bigger next - success Two can eat at the same time. Three is impossible (would need six forks). Essential Assignment 10 7 F0 F1 F2 F3 F4 Now only one is eating. All others have to wait - Not great, not terrible (no deadlock!) Assignment 10 8 Now only one is eating. All others have to wait - Not great, not terrible (no deadlock!) Dining Philosophers: • The only way to ensure that two can always eat at the same time is to introduce additional elements (communication, a waiter, etc.) Assignment 10 – Bridge with monitor 9 Is this really needed? Why notifyAll()? We only want to wake up one car or maybe a truck (if carCount ==0) Essential Assignment 10 – Bridge with condition 10 Make two separate groups of “waiters” Essential Assignment 10 – Bridge with condition 11 Choose who to wake up based on conditions. Essential Assignment 10 – Semaphore implementation 12 Why a while loop here and not an if? Why notifyAll and not notify? Note that we use “this” here – could also have created new object (see Bridge monitor) Essential Assignment 10 – Semaphore implementation 13 Essential Why do we distinguish between draining and non- draining? Barriers: Flawed example 14 Barriers: Two-phase barrier 15 Barriers: More Infos 16 • The Art of Multiprocessor Programming – Chapter 18 by Herlihy and Shavit Assignment 11 17 Assignment 11 18 • Implement SortedList with different lock strategies • Exercise about effective use of locks • Coarse grained vs. fine grained locks • Tricks to avoid locking altogether for certain operations • Measure the performance impact of your implementation choice SortedListInterface Add, Remove and Find unique elements in a sorted linked list. add(c) 19 a b d e Essential SortedListInterface Add, Remove and Find unique elements in a sorted linked list. add(c) find b and d b.next=c c.next=d 20 a b d e c Essential SortedListInterface Add, Remove and Find unique elements in a sorted linked list. remove(c) 21 a b c d Essential SortedListInterface Add, Remove and Find unique elements in a sorted linked list. remove(c) fin\u0000d b a\u0000d c b.\u0000ext=c.\u0000ext 22 a b c d Essential List and Node public interface SortedListInterface<T extends Comparable<T>> { public boolean add (T item); public boolean remove (T item); public boolean contains (T item); } 23 Make sure we can sort the entries in the list! Implement those methods in a thread-safe way Implementation tipps 24 • Keep an abstract Node to store list element: private class Node { public Node \u0000ext ; public T item; } • Code is simpler if we always have two sentinel nodes in the list: public Seque\u0000tialList() { finrst = \u0000ew Node(I\u0000teger.MIN_VALUE); finrst.\u0000ext = \u0000ew Node(I\u0000teger.MAX_VALUE); } Coarse Grained Locking 25 public sy\u0000chro\u0000ized boolea\u0000 add(T x) {...}; public sy\u0000chro\u0000ized boolea\u0000 remove(T x) {...}; public sy\u0000chro\u0000ized boolea\u0000 co\u0000tai\u0000s(T x) {...}; add(c) a b d e Essential Coarse Grained Locking 26 public sy\u0000chro\u0000ized boolea\u0000 add(T x) {...}; public sy\u0000chro\u0000ized boolea\u0000 remove(T x) {...}; public sy\u0000chro\u0000ized boolea\u0000 co\u0000tai\u0000s(T x) {...}; a b d e Essential Coarse Grained Locking 27 public sy\u0000chro\u0000ized boolea\u0000 add(T x) {...}; public sy\u0000chro\u0000ized boolea\u0000 remove(T x) {...}; public sy\u0000chro\u0000ized boolea\u0000 co\u0000tai\u0000s(T x) {...}; Simple, but a bottleneck for many threads, why? a b d e c Essential Fine grained Locking Often more intricate than visible at a first sight • requires careful consideration of special cases Idea: split object into pieces with separate locks • no mutual exclusion for algorithms on disjoint pieces 28 Essential Let's try this remove(c) 29 a b c d Essential Let's try this remove(c) Locki\u0000g the predecessor is ok? 30 a b c d Essential Let's try this A: remove(c) B: remove(b) c not deleted! 31 a b c d AB Essential Let's try this A: remove(c) B: remove(b) c not deleted! When removing, lock the successor defensively. 32 a b c d AB B A Waiting Essential Let's try this A: remove(c) B: remove(b) c not deleted! When removing, lock the successor defensively. 33 a b c d B B Essential What's the problem? When deleting, the next field of next is read, i.e. next also has to be protected. 34 a b d e BB fin\u0000d a a\u0000d b a.\u0000ext=b.\u0000ext Essential What about add? add(b’) 35 a b c d b’ Essential What about add? A: add(b’) B: remove(b) b’ not added! 36 a b c d b’ AB Essential What about add? A: add(b’) B: remove(b) b’ not added! Also when adding lock the successor defensively. 37 a b c d b’ AB B Waiting A Essential What about add? A: add(b’) B: remove(b) b’ not added! Also when adding lock the successor defensively. 38 a b c d b’ B B Essential Hand-over-hand locking (remove d) 39 a b d e pred=-∞,curr=a check(a<d) a b d e pred=a,curr=b check(b<d) a b d e pred=b,curr=d check(d<d) if(d==d) remove(d) Essential Hand-over-hand locking (remove d) 40 a b d e pred=-∞,curr=a check(a<d) a b d e pred=a,curr=b check(b<d) a b d e pred=b,curr=d check(d<d) if(d==d) remove(d) What about add(c) and contains(e)? Essential Hand-over-hand locking Benefits: • Multiple readers and writers can be actively doing work in the same list. • Readers and writers that are traversing the list in the same order will not pass each other. • The locks taken on parts of the list won't deadlock with each other, because multiple locks are acquired in the same order. 41 Essential Optimistic Synchronization 42 Idea Algorithm: • find nodes without locking, • then lock the two nodes and • check that everything is ok (validation) • if so perform the operation (add, remove or contains) and return true • if not return false • finally release the two locks e.g. add(c) 43 Essential add(c) Aha! Finding without locking a b d e Essential add(c) Locking a b d e Essential add(c) a b d e Validation Essential add(c) a b d e Yes. b is still reachable from head. Validation Essential add(c) a b d e Yes. b still points to d. Validation Essential c add(c) a b d e Essential c add(c) a b d e Essential Validation: what can go wrong? A: add(c) A: fin\u0000d i\u0000sertio\u0000 poi\u0000t B: remove(b) A: lock A: validate: resca\u0000 A: b \u0000ot reachable →retur\u0000 false 51 a b d e a b d e A A a b d e B B Essential Validation: what can go wrong? A: add(c) A: fin\u0000d i\u0000sertio\u0000 poi\u0000t B: i\u0000sert(b') A: lock A: validate: resca\u0000 A: d != succ(b) →retur\u0000 false 52 a b d e a b d e B B b' a b d e A A b' Essential Correctness (remove c) If • nodes b and c both locked • node b still accessible • node c still successor to b then • neither will be deleted • ok to delete and return true If • nodes b and d both locked • node b still accessible • node d still successor to b then • neither will be deleted • no thread can add between b and d • ok to return false 53 Essential Optimistic List Good: No contention on traversals. Traversals are wait-free. Less lock acquisitions. Bad: Need to traverse list twice (find + validate) contains() method needs to acquire locks 54 Essential Lazy Synchronisation 55 Lazy List Like optimistic list but • scan only once • contains() never locks How? • Removing nodes causes trouble • do it \"lazily” • add a special ”removed?” flag to the nodes 56 New Validate Given two locked nodes • Pred is not marked • Curr is not marked • Pred points to Curr 57 b c ? ? ? Lazy List: Remove Find nodes to remove (as before) Lock predecessor and current (as before) Validate (new validation) Logical delete: mark current node as removed Physical delete: redirect predecessor's next e.g. remove(c) 58 a b c d Invariant If a node is not marked then • it is reachable from head • and reachable from its predecessor Only check if nodes are adjacent. Why? A: remove(c) lock check if b or c are marked not marked? ok to delete: mark c delete c 59 a b c d Lazy List: Add Find nodes to where to add (as before) Lock predecessor and current (as before) Validate (new validation) Physical add: change predecessor's next e.g. add(b’) 60 a b c d b’ Lazy List: Contains Find nodes to return without locking Return true if node is not marked e.g. contains(b) 61 a b c d ? New Validation: What can go wrong? 62 a b d e a b d e A A A: add(c) A: fin\u0000d i\u0000sertio\u0000 poi\u0000t B: remove(b) A: lock A: validate: marks + pred --> curr A: b marked →retur\u0000 false a b d e B B New Validation: What can go wrong? A: add(c) A: fin\u0000d i\u0000sertio\u0000 poi\u0000t B: i\u0000sert(b') A: lock A: validate: marks + pred --> curr A: pred –x-> curr →retur\u0000 false 63 a b d e a b d e B B b' a b d e A A b' Kahoot 64 https://create.kahoot.it/share/pprog11/a53c8ae7-291b-478f-8860-6b183b19f de9","libVersion":"0.3.2","langs":""}