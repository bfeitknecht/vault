{"path":"HS23/EProg/VRL/extra/slides/EProg_s09_methoden++.pdf","text":"252-0027 EinfÃ¼hrung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH ZÃ¼rich 1 252-0027 EinfÃ¼hrung in die Programmierung 2.6 Methoden, Teil 2 Thomas R. Gross Department Informatik ETH ZÃ¼rich 2 Ãœbersicht Â§ 2.6 Methoden, Teil 2 Â§ 2.6.1 Methoden mit Parametern Â§ 2.6.2 RÃ¼ckgabewerte Â§ 2.6.3 NamensrÃ¤ume Â§ 2.7 Strings Â§ 2.8 Nochmals Schleifen 3 2.6.3 Sichtbarkeit von Variablennamen Â§ NamesrÃ¤ume (Â«ScopeÂ»): Bereich in dem ein Name sichtbar ist Â§ Dann kann die Variable gelesen/modifiziert werden Â§ Dann kann eine Methode aufgerufen werden (spÃ¤ter) Â§ 1. Approximation fÃ¼r das Innenleben von Methoden Â§ Weitere Aspekte in spÃ¤teren Vorlesungen 4 Scope (Sichtbarkeitsbereich) scope: Der Teil eines Programm in dem eine Variable sichtbar ist. Â§ Variable mÃ¼ssen deklariert sein bevor sie sichtbar sind Â§ Deklarationen mÃ¼ssen eindeutig sein Â§ Sichtbar von Deklaration bis zum Ende des Blocks fÃ¼r den die Variable deklariert ist Block: durch { und } begrenzt 6 { und } strukturieren ein Programm public static void fct(int j) { int i; int k; } 7 i sichtbar k sichtbar j sichtbar { und } strukturieren ein Programm if (...) { int i; } else { } ... 8 i sichtbar { und } strukturieren ein Programm for (int i = 0; ...; ...) { } ... for (int i = 1; ...; ...) { } ... 9 i sichtbar (anderes) i sichtbar Scope (Sichtbarkeitsbereich) scope: Der Teil eines Programm in dem eine Variable sichtbar ist Â§ Variable mÃ¼ssen deklariert sein bevor sie sichtbar sind Â§ Deklarationen mÃ¼ssen eindeutig sein Â§ Sichtbar von Deklaration bis zum Ende des Blocks (der durch { und } angegeben wird) Â§ Eine Variable die in einer Â«forÂ»-Schleife deklariert wurde kann nur im Rumpf der Schleife verwendet werden. Â§ Eine Variable die in einer Methode deklariert wurde existiert nur in der Methode. 11 BlÃ¶cke kÃ¶nnen geschachtelt sein Â§ Loops in Methoden Â§ Loops in Loops -- geschachtelte Schleifen (Â«nested loopsÂ») Â§ (Java: Methoden kÃ¶nnen nicht in anderen Methoden geschachtelt sein.) 12 Scope (Sichtbarkeitsbereich) public static void example() { int x = 3; x = x * x; for (int i = 1; i <= 10; i = i+1) { System.out.println(x+i); } // i no longer exists here System.out.println(x); } // x ceases to exist here 13 x's scopei'sscope Scope (Sichtbarkeitsbereich) public static void example(int x) { for (int i = 1; i <= 10; i=i+1) { for (int j = i; j<=10; j=j+1) { System.out.print(x + i + j + \" \"); } // j no longer exists here System.out.println(i); } // i no longer exists here System.out.println(x); } // x no longer exists here 14 Folgen der Sichtbarkeitsregeln Â§ Variable ohne Ã¼berlappenden Sichtbarkeitsbereich kÃ¶nnen den selben Namen haben. for (int i = 1; i <= 100; i=i+1) { System.out.print(\"/\"); } for (int i = 1; i <= 100; i=i+1) { // OK System.out.print(\"\\\\\"); } int i = 5; // OK: outside of loop's scope 15 Folgen der Sichtbarkeitsregeln Â§ Eine Variable kann in einem Sichtbarkeitsbereich nur einmal deklariert werden. for (int i = 1; i <= 100 * line; i=i+1) { int i = 2; // ERROR: overlapping scope System.out.print(\"/\"); } i = 4; // ERROR: outside scope Â§ Eine Variable kann nicht ausserhalb ihres Sichtbarkeitsbe- reiches verwendet werden 16 Folgen der Sichtbarkeitsregeln Â§ Eine Variable kann in einem Sichtbarkeitsbereich nicht mehrmals deklariert werden. for (int i = 1; i <= 100 * line; i=i+1) { for (int i = 2; i < line; i=i+1) { // ERROR: overlapping scope // variable i is already defined in method â€¦ System.out.print(\"/\"); } } 18 Sichtbarkeitsregeln fÃ¼r Parameter Variable Â§ Die selben Regeln gelten auch fÃ¼r Parameter Variable 19 Scope (Sichtbarkeitsbereich) public static void function(int k) { int x = 3; int y = k+x; System.out.println(y); } // k ceases to exist here 20 k's scopey's scope Scope (Sichtbarkeitsbereich) public static void function(int k) { int x = 3; int y = anotherFct(k+x); System.out.println(y); } // k ceases to exist here public static void otherFct(int x) { int y = 5; System.out.println(x+y); } 21 x's scopey's scope x's scopey's scope Scope (Sichtbarkeitsbereich) public static void function(int k) { int x = 3; int y = anotherFct(k+x); System.out.println(y); } // k ceases to exist here public static void otherFct(int k) { int y = 5; System.out.println(k+y); } // k ceases to exist here 22 k's scope k's scope Verschiedene k ! public static void f(int x) { int i = 3; // A for (int j = 0; j < x; j=j+1) { // B if (j == x-1) { int k = 0; // C k = i; } else { int m = 1; // D } // E } //F } // G Wo sind i, j, k, m, x sichtbar? Poll 23 Ist â€¦. am Punkt â€¦. sichtbar? 24 A B C D E F G i j k m x Warum diese Regeln Â§ Lesbarkeit der Programme Â§ Vereinfachung der Verwaltung des Speichers Â§ Platz fÃ¼r eine Variable eines Basistypes muss nur in dem Block organisiert werden, in dem die Variable deklariert ist Â§ Werte (die in einer Variable eines Basistypes) gespeichert werden verschwinden am Ende des Blockes 26 Ãœbersicht Â§ 2.7 Strings Â§ Nur das wichtigste ... 27 2.7 Strings 28 Strings Â§ String: Eine Folge von Buchstaben/Zeichen Â§ Java Typ String definiert in Standard Bibliothek Â§ String Variable definiert wie alle anderen Variablen String name ; Â§ Initialisierung durch String Literal Â§ Folge zwischen \" und \" ohne Zeilenende, ggf. mit Ersatzdarstellungen String name = \"Here \"; oder Textblock String name = \"\"\" Here we go\"\"\"; 29 3 x \" 3 x \" Ende der Zeile Leerzeichen ignoriert! Strings Â§ String: Eine Folge von Buchstaben/Zeichen Â§ Java Typ String definiert in Standard Bibliothek Â§ String Variable definiert wie alle anderen Variablen String name ; Â§ Initialisierung durch String Literal Â§ Folge zwischen \" und \" ohne Zeilenende, ggf. mit Ersatzdarstellungen String name = \"Here \"; oder Textblock String name = \"\"\" Here we go\"\"\"; System.out.println(name); 30 Strings Â§ + erzwingt Konversion von anderen Typen (zu String) int x = 3; String point = \"(\" + x + \", \" + 5 + \")\"; Â§ Konversion von anderen Typen (z.B. int) zu String String s = \"\" + x; Â§ \"\" ist ğ›†, der leere String 32 Strings Â§ Weil Strings wichtig sind werden sie vom Compile/Laufzeit- system besonders behandelt Â§ Wie bei int und double zwingen praktische Ãœberlegungen die Programmiersprache dazu, Details in der Programmierung zu erwarten Â§ Standard Bibliothek enthÃ¤lt viele Methoden um Strings zu bearbeiten Â§ Immer vorhanden, ohne import java.util.*; Â§ Alle Methoden lassen Strings unverÃ¤ndert Â§ Strings sind unverÃ¤nderbar (Â«immutableÂ») 33 Strings Â§ Strings sind Objekte â€“ Methoden mit Â«dotÂ» Notation Â§ Beispiele: toUpperCase(), toLowerCase(), ... Â§ KÃ¶nnen fÃ¼r jeden String seine LÃ¤nge (Anzahl Zeichen) herausfinden Â§ String str = \"Hello\"; Â§ System.out.println(\"Laenge: \" + str.length() ); Â§ Strings erlauben Zugriff auf die Buchstaben die den Text ausmachen. 34 Output: Laenge: 5 Teile eines Strings Â§ Auf Teile eines Strings wird mit einem Index zugegriffen Â§ Basis 0 String name = \"B. Dylan\"; Â§ Index des ersten Buchstabens: 0 Â§ Index des letzten Buchstabens: 1 weniger als die LÃ¤nge des Strings Â§ name.length() == 8 Â§ Strings sind keine Arrays! Â§ Arrays werden in Teil 3 behandelt (Fragen bitte zurÃ¼ckhalten) index 0 1 2 3 4 5 6 7 Zeichen B . D y l a n 35 Strings Â§ Zugriff auf Elemente eines Strings erfolgt mit (vordefinierten) Methoden Â§ Aufruf dieser Methoden in Punktnotation (Â«dot notationÂ») String s = \"hello\"; s.method(parameterValues); Â§ FÃ¼hre Methode method fÃ¼r s aus, Â«wende method auf s anÂ», Â«rufe method fÃ¼r s aufÂ» Â§ Keine Ã„nderung von s ! Â§ Ergebnis kann sein String, int, boolean oder ein Zeichen (Buchstabe) 36 String Methoden die String liefern Â§ Â«white spaceÂ» -- Leerzeichen (blank, space), Tabulatorzeichen, LineFeed/CarriageReturn/Return/Enter/Zeilenumbruch â€¦ Method name Description substring(index1, index2) or substring(index1) the characters in this string from index1 (inclusive) to index2 (exclusive); if index2 is omitted, grabs till end of string toLowerCase() a new string with all lowercase letters toUpperCase() a new string with all uppercase letters stripLeading() a new string whose value is this string, with all leading white space removed. stripTrailing() a new string whose value is this string, with all trailing white space removed. 37 String Methoden die String liefern Â§ Beispiel String writer = \"S. Beckett\"; //Laenge: 10 System.out.println(writer.substring(8)); // tt System.out.println(writer.substring(0,1)); // S System.out.println(writer.substring(3,7)); // Beck String w = writer.substring(1,2); // wie w = \".\" Method name Description substring(index1, index2) or substring(index1) the characters in this string from index1 (inclusive) to index2 (exclusive); if index2 is omitted, grabs till end of string 38 index 0 1 2 3 4 5 6 7 8 9 Zeichen S . B e c k e t t String Methoden die int liefern Â§ Beispiel String writer = \"S. Beckett\"; //Laenge: 10 System.out.println(writer.indexOf(\"Beck\")); // 3 System.out.println(writer.indexOf(\"e\")); // 4 System.out.println(writer.indexOf(\"e\",5)); // 7 Method name Description indexOf(str) index where the start of the given string appears in this string (-1 if not found) length() number of characters in this string indexOf(str, fromIndex) index within this string of the first occurrence of the specified substring, starting at the specified index (-1 if not found) 40 index 0 1 2 3 4 5 6 7 8 9 Zeichen S . B e c k e t t String weitere Beispiele // index 0123456789012 String s1 = \"Alice Munro\"; String s2 = \"Doris Lessing\"; System.out.println(s1.length()); // 11 System.out.println(s1.indexOf(\"e\")); // 4 System.out.println(s2.substring(6, 9)); // Les String s3 = s2.substring(1, 7); System.out.println(s3.toLowerCase()); // oris l Â§ Mit diesem String // index 012345678901234567890123456789012 String vorlesung = \"Einfuehrung in die Programmierung\"; Wie wÃ¼rden Sie das Wort \"die\" extrahieren ? 41 012345678911234567892123456789312 String weitere Beispiele // index 0123456789012 String s1 = \"Alice Munro\"; String s2 = \"Doris Lessing\"; System.out.println(s1.length()); // 11 System.out.println(s1.indexOf(\"e\")); // 4 System.out.println(s2.substring(6, 9)); // Les String s3 = s2.substring(1, 7); System.out.println(s3.toLowerCase()); // oris l Â§ Mit diesem String // index 012345678901234567890123456789012 String vorlesung = \"Einfuehrung in die Programmierung\"; Wie wÃ¼rden Sie das Wort \"die\" extrahieren ? vorlesung.indexOf(\"die\"); // 15 vorlesung.substring(15, 18); 42 012345678911234567892123456789312 String weitere Beispiele // index 0123456789012 String s1 = \"Alice Munro\"; String s2 = \"Doris Lessing\"; System.out.println(s1.length()); // 11 System.out.println(s1.indexOf(\"e\")); // 4 System.out.println(s2.substring(6, 9)); // Les String s3 = s2.substring(1, 7); System.out.println(s3.toLowerCase()); // oris l Â§ Mit diesem String // index 012345678901234567890123456789012 String vorlesung = \"Einfuehrung in die Programmierung\"; Wie wÃ¼rden Sie das Wort \"die\" extrahieren ? int loc = vorlesung.indexOf(\"die\"); // 15 vorlesung.substring(loc, loc+3); 43 012345678911234567892123456789312 String Vergleiche/Abfragen String s = \"Hello\"; String t = s.toUpperCase(); if (s.equals(t)) { System.out.println(\"Equal\")); } else {System.out.println(\"Not equal\")); } //Not equal if (\"Hello\".equals(s)) { System.out.println(\"Equal\")); } else {System.out.println(\"Not equal\")); } //Equal Method Description equals(str) ob 2 Strings die selben Buchstaben enthalten equalsIgnoreCase(str) ob 2 Strings die selben Buchstaben enthalten, ohne BerÃ¼cksichtigung von Gross- und Kleinschreibung startsWith(str) ob der String mit den Buchstaben des anderen (str) anfÃ¤ngt endsWith(str) ob â€¦ endet contains(str) ob der String str (irgendwo) auftritt 44 Elemente eines Strings Â§ Die einzelnen Buchstaben sind Werte des (Basistyps) char (spÃ¤ter mehr) String name = \"B. Dylan\"; name.charAt(0) // B if (name.charAt(1) == '.') { â€¦ } // Paar single quote ' ' char c = name.charAt(7); System.out.println(name.indexOf('.')); // 1 Â§ Verwenden Sie == nur fÃ¼r Basistypen (z.B. int oder char), nicht fÃ¼r String Variable Â§ SpÃ¤ter sehen wir wann wir == verwenden kÃ¶nnen index 0 1 2 3 4 5 6 7 Zeichen B . D y l a n 45 Zur Erinnerung Â§ Zuweisungen zu String Variablen Ã¤ndern nicht den String Â§ Die Variable verweist auf einen anderen String 46 Animation 48 Zur Erinnerung Â§ Zuweisungen zu String Variablen Ã¤ndern nicht den String Â§ Die Variable verweist auf einen anderen String Â§ Methoden (z.B. substring) liefern neuen String Â§ Keine Modifikation des String fÃ¼r den sie aufgerufen wurden String s = \"Hello World\"; s.toUpperCase(); System.out.println(s); // Hello World Â§ Ergebnis kann in Variable gespeichert werden String s = \"Hello World\"; String t = s.toUpperCase(); System.out.println(t); // HELLO WORLD 49 Zur Erinnerung Â§ Zuweisungen zu String Variablen Ã¤ndern nicht den String Â§ Die Variable verweist auf einen anderen String Â§ Methoden (z.B. substring) liefern neuen String Â§ Keine Modifikation des String fÃ¼r den sie aufgerufen wurden String s = \"Hello World\"; s.toUpperCase(); System.out.println(s); // Hello World Â§ Ergebnis kann in Variable gespeichert werden String s = \"Hello World\"; s = s.toUpperCase(); // kann selbe Variable sein System.out.println(s); // HELLO WORLD 50 String als Parameter public class StringParameters { public static void main(String[] args) { String friend = \"Mark\"; sayHello(friend); sayHello(\"Peter\"); } public static void sayHello(String name) { System.out.println(\"Welcome, \" + name); } } Output: Welcome, Mark Welcome, Peter String als Parameter public class StringParameters { public static void main(String[] args) { String friend = \"Mark\"; sayHello(friend); sayHello(friend); } public static void sayHello(String name) { System.out.println(\"Welcome, \" + name); name = \"Incognito\"; } } 53 Output: Welcome, Mark Welcome, Mark Zerlegen in Teilaufgaben Â§ Ziel: ... so dass Teilaufgaben Ti wiederverwendet werden kÃ¶nnen Â§ Genauer: die Anweisungen fÃ¼r Ti kÃ¶nnen wiederverwendet werden Â§ Anweisungen fÃ¼r Ti: Methode Mi Â§ Evtl. Hilfsmethoden Mj 5454 Aufgabe T1 T2 TnT2 Programm MmM1 M2 Zerlegen in Teilaufgaben Â§ Anweisungen fÃ¼r Ti: Methode Mi Â§ Evtl. Hilfsmethoden Mj Â§ Methoden kÃ¶nnen Schleifen enthalten Â§ Beliebige Anweisungen Â§ Methoden kÃ¶nnen in Schleifen aufgerufen werden 5555 Aufgabe T1 T2 Tn Programm MmM1 M2 Aufgabe Â§ Schreiben Sie eine Methode oneCount(String) die berichtet wie oft das Zeichen 1 im Eingabe-String auftritt. Â§ Wenn Sie wollen kÃ¶nnen Sie sich vorstellen, dass die Eingabe-Strings Zahlen in BinÃ¤rdarstellung sind Â§ Beispiele Â§ oneCount(\"001\") Ã  1 Â§ oneCount(\"1010\") Ã  2 56 Aufgabe Â§ Schreiben Sie eine Methode oneCount(String) die berichtet wie oft das Zeichen 1 im Eingabe-String auftritt. Â§ Wenn Sie wollen kÃ¶nnen Sie sich vorstellen, dass die Eingabe-Strings Zahlen in BinÃ¤rdarstellung sind Â§ Fragen Â§ Typ des RÃ¼ckgabewertes: int Â§ SonderfÃ¤lle Â§ oneCount(\"abc\") Ã  0 Â§ oneCount(\"\") Ã  0 57 Aufgabe Â§ Was fÃ¼r ein Parameter? String s Â§ Wie kann oneCount jedes Zeichen analysieren? Â§ Loop Â§ Ein Zeichen? substring(index, index+1) Â§ PrÃ¼fen ob Zeichen eine 1 ist? \"1\".equals(s.substring(..)) Â§ Wie wird Ergebnis berechnet? Â§ int Variable, um 1 erhÃ¶hen wenn Zeichen eine 1 ist 58 LÃ¶sung 1 public static int oneCount (String s) { int result = 0; for (int i=0; i<s.length(); i = i + 1) { if (\"1\".equals(s.substring(i, i+1))) { result = result + 1; } } return result; } 59 Anderer Ansatz Â§ Was fÃ¼r Anweisungen kÃ¶nnen im Rumpf einer Methode method() auftreten? Â§ Alle. Â§ Auch Aufrufe von Methoden. Â§ Auch Aufrufe der Methode method(). Â§ Wie wird Ergebnis berechnet? Â§ oneCount(s.substring(0,1)) + oneCount(s.substring(1)) Â§ (0 oder 1) + oneCount(Rest_des_Strings) 60 index 0 1 2 Zeichen 1 0 1 Zerlegen einer (Teil)Aufgabe (Methode Mi) Â§ Teilaufgabe T1 : fÃ¼r Input X sofort lÃ¶sbar Â§ Beispiel: X ein String der LÃ¤nge 1 oneCount(X) Ã  1 wenn X String \"1\" ist, sonst 0 Â§ Teilaufgabe T2 : Â§ Zerlege Input in zwei Teile X1 und X2 Â§ Ergebnis kann (leicht) aus Mi(X1) und Mi(X2) berechnet werden Â§ Bespiel: X lÃ¤nger als 1 Zeichen oneCount(Erstes_Zeichen) + oneCount(Rest_des_Strings) 6161 Aufgabe T1 T2 Tn Programm MmM1 M2 62 index 0 1 2 Zeichen 1 0 1 oneCount(s.substring(0,1)) + oneCount(s.substring(1)) index 0 Zeichen 1 index 0 1 Zeichen 0 1 oneCount(s.substring(0,1)) + oneCount(s.substring(1)) index 0 Zeichen 0 index 0 Zeichen 1 oneCount(s.substring(0,1)) + oneCount(\"\") index 0 Zeichen 1 index Zeichen LÃ¶sung 2 public static int oneCount (String s) { int result = 0; if (s.length()==0) return 0; if (s.substring(0,1).equals(\"1\")) { result = 1; } return result + oneCount(s.substring(1)); } 63 LÃ¶sung 2a public static int oneCount (String s) { if (s.length()==0) return 0; if (s.length()==1 && \"1\".equals(s)) { return 1; } else if (s.length()==1 && !(\"1\".equals(s))) { return 0; } else { return oneCount(s.substring(0,1)) + oneCount(s.substring(1)); } } 64 LÃ¶sung 3 public static int oneCount (String s) { if (s.length()==0) return 0; if (s.length()==1) { return (\"1\".equals(s) ? 1 : 0); } else { return oneCount(s.substring(0,1)) + oneCount(s.substring(1)); } } 65 LÃ¶sung 4 public static int oneCount (String s) { if (s.length()==0) return 0; if (s.length()==1) { return (\"1\".equals(s) ? 1 : 0); } else { return oneCount(s.substring(0,s.length()/2)) + oneCount(s.substring(s.length()/2+1)); } } 67 Ãœbersicht Â§ 2.8 Nochmals Schleifen Â§ 2.8.1 Kurzformen (fÃ¼r Aktualisierung) Â§ 2.8.2 Kurzformen und bedingte (Â«short-circuitÂ») AusfÃ¼hrung Â§ 2.8.3 Terminierung von Schleifen Â§ 2.8.4 Input Werte zur Schleifenkontrolle Â§ 2.8.5 Invarianten 68 2.8 Nochmals Schleifen Â§ Kurzform zur Aktualisierung des Loop Counters (SchleifenzÃ¤hlers) Â§ Tipps fÃ¼r korrekte Terminierung der Schleifen Â§ Hoare Tripel fÃ¼r Schleifen 69 2.8.1 Aktualisierung for (int i = start ; i < bound; i = i + 1) { // Statement } Aktualisierung: i wird um 1 erhÃ¶ht for (int i = start ; i > bound; i = i - 1) { // Statement } Aktualisierung: i wird um 1 reduziert Auch andere Aktualisierungen sind mÃ¶glich aber diese hier treten hÃ¤ufig auf 70 Kurzformen fÃ¼r Zuweisungen Â§ Zuweisungen der Form j = j+1 tretten hÃ¤ufig auf Â§ Machen Programm unÃ¼bersichtlich Â§ FrÃ¼her: unnÃ¶tige Extra-Arbeit fÃ¼r Compiler und Computer Â§ Kurzformen erlauben Inkrement (Addition von 1) und Dekrement (Subtraktion von 1) Â§ Â«incrementÂ» und Â«decrementÂ» Operator Â§ VerÃ¤nderung immer um 1 71 Inkrement und Dekrement Kurzform Ã„quivalente ausfÃ¼hrlichere Version variable++; variable = variable + 1; //increment variable--; variable = variable - 1; //decrement Beispiele int x = 2; x++; // x = x + 1; // x now stores 3 double note = 4.5; note--; // note = note - 1; // note now stores 3.5 72 Aktualisierung for (int i = start ; i < bound; i++) { // Statement } Aktualisierung: i wird um 1 erhÃ¶ht for (int i = start ; i > bound; i--) { // Statement } Aktualisierung: i wird um 1 reduziert ++ (und --) oft in Aktualisierungen des Loop Counters 74 Inkrement und Dekrement Kurzform Ã„quivalente ausfÃ¼hrlichere Version variable++; variable = variable + 1; variable--; variable = variable - 1; Variable wird verwendet und dann verÃ¤ndert Dies gilt auch in AusdrÃ¼cken und Zuweisungen Beispiel int x = 2; int y; y = x++; 75 Inkrement und Dekrement Kurzform Ã„quivalente ausfÃ¼hrlichere Version variable++; variable = variable + 1; //increment variable--; variable = variable - 1; //decrement Beispiele int x = 2; System.out.println(x++); // x = x + 1; x now stores 3 System.out.println(x++); // x = x + 1; x now stores 4 76 Output: 2 3 Inkrement und Dekrement Kurzform Ã„quivalente ausfÃ¼hrlichere Version variable++; variable = variable + 1; variable--; variable = variable - 1; Variable wird verwendet und dann verÃ¤ndert Dies gilt auch in AusdrÃ¼cken und Zuweisungen Beispiel int x = 2; int y; y = x++; 77 Inkrement und Dekrement Kurzform Ã„quivalente ausfÃ¼hrlichere Version variable++; variable = variable + 1; variable--; variable = variable - 1; Variable wird verwendet und dann verÃ¤ndert Dies gilt auch in AusdrÃ¼cken und Zuweisungen Beispiel int x = 2; int y; y = x++; 78 int temp = x; x++; y = temp; //x: //y: Inkrement und Dekrement Kurzform Ã„quivalente ausfÃ¼hrlichere Version variable++; variable = variable + 1; variable--; variable = variable - 1; Variable wird verwendet und dann verÃ¤ndert Dies gilt auch in AusdrÃ¼cken und Zuweisungen Beispiel int x = 2; int y; y = x++; 79 int temp = x; x = x + 1; y = temp; //x: //y: Zuweisungen (Assignment Statement) 83 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiele LHS: int k int i = 3; int j = 7; RHS Resultat: 9 9 3+5 8 i+2 5 i++ 3 // i: 4 j-- + j%4 9 // j: 6 Zuweisungen (Assignment Statement) 84 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; Achtung: Zwei Variablen werden verÃ¤ndert! Zuweisungen (Assignment Statement) 85 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; Zuweisungen (Assignment Statement) 86 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 1. RHS: 3 2. 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; = 3; //update i!! Zuweisungen (Assignment Statement) 87 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 1. RHS: 3 2. Addiere 1 zu Variable i 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; = 3; //update i!! // i+1 Zuweisungen (Assignment Statement) 88 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 1. RHS: 3 2. Addiere 1 zu Variable i 3. Speichere Variable i 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; = 3; //update i!! // i+1 // i= Zuweisungen (Assignment Statement) 89 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 1. RHS: 3 2. Addiere 1 zu Variable i 3. Speichere Variable i 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; = 3; //update i!! // i+1 // i= j = Inkrement und Dekrement Puzzles 100 Â§ Unser Ziel ist es verstÃ¤ndliche Programme zu schreiben Inkrement und Dekrement Puzzles 101 Â§ Unser Ziel ist es verstÃ¤ndliche Programme zu schreiben Â§ â€¦ und nicht Puzzles zu konstruieren! Â§ Sie sollten ++ und -- (er)kennen Â§ Auch in komplexen AusdrÃ¼cken Â§ Ihre Entscheidung ob Sie es verwenden (aber wenn dann richtig) Â§ Diese Operatoren sind nicht so effizient dass wir dafÃ¼r die Klarheit eines Programmes opfern wollen. Weitere Kurzformen Â§ Erlauben Verwendung des Wertes einer Variable gefolgt von einer Modifikation (Zuweisung) Kurzform Ã„quivalente ausfÃ¼hrlichere Version variable += value; variable = variable + value; variable -= value; variable = variable - value; variable *= value; variable = variable * value; variable /= value; variable = variable / value; variable %= value; variable = variable % value; Â§ Modifikation mit beliebigen Werten (nicht nur 1) 102 Weitere Kurzformen Beispiele x += 3; // x = x + 3; note -= 0.5; // note = note - 0.5; number *= 2; // number = number * 2; Warnung: x += 1; // x = x + 1; x =+ 1; // x = + 1; 103 Weitere Kurzformen â€“ manchmal nÃ¼tzlich Â§ x++ und j-- heissen Post-Increment bzw. Post-Decrement Operator, da die VerÃ¤nderung (von x und j) gemacht wird nachdem der Wert (von x oder j) gelesen (Â«gebrauchtÂ») wurde. Â§ Es gibt auch Operatoren, die die VerÃ¤nderung (Increment oder Decrement) durchfÃ¼hren bevor der Wert gelesen wurde; dies sind der Pre-Increment bzw. Pre-Decrement Operator: ++j oder --x. Beispiele int x = 2; System.out.println(++x); // x = x + 1; x now stores 3 System.out.println(++x); // x = x + 1; x now stores 4 104 Output: 3 4 Weitere Kurzformen â€“ manchmal unnÃ¶tig Â§ x++ und j-- heissen Post-Increment bzw. Post-Decrement Operator, da die VerÃ¤nderung (von x und j) gemacht wird nachdem der Wert (von x oder j) gelesen (Â«gebrauchtÂ») wurde. Â§ Es gibt auch Operatoren, die die VerÃ¤nderung (Increment oder Decrement) durchfÃ¼hren bevor der Wert gelesen wurde; dies sind der Pre-Increment bzw. Pre-Decrement Operator: ++j oder --x. Beispiele int x = 2; System.out.println(++x); // x = x + 1; x now stores 3 System.out.println(++x); // x = x + 1; x now stores 4 105 Output: 3 4 2.8.2 Bedingte Auswertung und Kurzformen Â§ FÃ¼r && und || mÃ¼ssen nicht immer beide Operanden ausgewertet werden, um das Ergebnis zu ermitteln Â§ Java beendet die Auswertung eines booleschen Ausdrucks sobald das Ergebnis fest steht. Â§ && und || sind links-assoziativ Â§ AusdrÃ¼cke werden von links nach rechts, gemÃ¤ss PrÃ¤zedenz und AssoziativitÃ¤t ausgewertet Â§ && stoppt sobald ein Teil(ausdruck) false ist Â§ || stoppt sobald ein Teil(ausdruck) true ist 106 Bedingte Auswertung: Vorsicht Â§ Was ist der Wert von count am Ende des Codesegments? // look closely int count = 0; Scanner console = new Scanner(System.in); for (int i = 0; i<4; i++) { System.out.print(\"Eingabe Zahl: \"); int wert = console.nextInt(); if ((wert != 0) && (count++ < 9)) { System.out.println(\"Hit\"); } } // count: Anzahl Werte ungleich 0, nicht Iterationen Â§ Vorsicht bei ++/-- 107 Bedingte Auswertung: Vorsicht Â§ Die logischen Operatoren sind nicht kommutativ wenn die Auswertung den Zustand des Programms verÃ¤ndern kann. Â§ (expr1 && expr2) nicht immer gleich (expr2 && expr1) Â§ Vorsicht bei Operatoren mit Nebenwirkungen (Â«side effectsÂ») Â§ Offensichtliche Nebenwirkungen: z.B. int x,y; x++ y-- o. Ã¤. Â§ Nicht sofort offensichtlich: Â§ Methoden oder Funktionen, die Zustand des Programms Ã¤ndern (werden wir spÃ¤ter kennenlernen) Â§ Operationen die Zustand des Systems Ã¤ndern (wie z.B. x/0 â€“ Fehler!) 108 Kurzformen - Recap Â§ Unser Ziel ist es, verstÃ¤ndliche Programme zu schreiben. Â§ Vorsicht bei Kurzformen und bedingter Auswertung Â§ Oft sinnvoll um kompakt Laufzeitfehler zu vermeiden Â§ Gebrauch erlaubt, nicht erzwungen Â§ Was wird gedruckt? int x = 2; System.out.println(++x + x++ + \" \" + x + ++x + x); 109 2.8.3 Terminierung von Schleifen 113 Eine triviale Aufgabe ... Â§ Schreiben Sie eine Methode printNumbers die die Zahlen von 1 bis N durch Komma getrennt ausgibt. Beispiel: Obergrenze N eingeben: 5 sollte ergeben: 1, 2, 3, 4, 5 114 LÃ¶sungsansatz public static void printNumbers() { Scanner console = new Scanner(System.in); System.out.print(\"Obergrenze N eingeben: \"); int max = console.nextInt(); for (int i = 1; i <= max; i++) { System.out.print(i + \", \"); } System.out.println(); // to end the line of output } 115 Welche Schleifen liefern gewÃ¼nschten Output? public static void printNumbers() { Scanner console = new Scanner(System.in); System.out.print(\"Obergrenze N eingeben: \"); int max = console.nextInt(); // Option A for (int i = 1; i <= max; i++) { System.out.print(i + \", \"); } System.out.println(); // to end the line of output // Option B for (int i = 1; i <= max; i++) { System.out.print(\", \" + i); } System.out.println(); // to end the line of output } }// printNumbers Poll 116 Gartenzaun Analogie Â§ Wir geben n Zahlen aus aber brauchen nur n - 1 Kommas. Â§ Ã„hnlich dem Bau eines Weidezaunes mit Pfosten und Querstreben Â§ Wenn wir â€“ wie in der 1. fehlerhaften LÃ¶sung â€“ Pfosten und Streben installieren dann hat der letzte Pfosten in der Luft hÃ¤ngende Streben. for (LÃ¤nge des Zauns) { Betoniere Pfosten. Installiere Querstreben. } 121 Gartenzaun Analogie Â§ Wir geben n Zahlen aus aber brauchen nur n - 1 Kommas. Â§ Ã„hnlich dem Bau eines Weidezaunes mit Pfosten und Querstreben Â§ Wenn wir â€“ wie in der 2. fehlerhaften LÃ¶sung â€“ Streben und Pfosten installieren dann hat der erste Pfosten in der Luft hÃ¤ngende Streben. for (LÃ¤nge des Zauns) { Installiere Querstreben. Betoniere Pfosten. } 122 Schleife Â§ FÃ¼gen Sie eine Anweisung ausserhalb der Schleife hinzu um den ersten Â«PfostenÂ» zu plazieren Betoniere Pfosten. for (LÃ¤nge des Zauns - 1) { Installiere Querstreben. Betoniere Pfosten. } 123 LÃ¶sungen basierend auf dieser Idee System.out.print(1); for (int i = 2; i <= max; i++) { System.out.print(\", \" + i); } System.out.println(); // to end the line Alternative: 1. oder letzter Durchlauf durch die Schleife kann verÃ¤ndert werden: for (int i = 1; i <= max - 1; i++) { System.out.print(i + \", \"); } System.out.println(max); // to end the line 124 LÃ¶sung (eine MÃ¶glichkeit) public static void printNumbers() { Scanner console = new Scanner(System.in); System.out.print(\"Obergrenze N eingeben: \"); int max = console.nextInt(); System.out.print(1); for (int i = 2; i <= max; i++) { System.out.print(\", \" + i); } System.out.println(); // to end the line } 125 Â«off-by-oneÂ» Error (Um-Eins-Daneben-Fehler) Â§ Die Schleife wurde einmal zuviel (oder einmal zuwenig) durchlaufen. Â§ Â«ZaunpfahlproblemÂ» â€“ es gibt sogar eine D Wikipedia Seite (Inhalt ohne GewÃ¤hr) 126 Terminierung von Loops Â§ Verwandeln Sie die Methode printNumbers in eine neue Methode printPrimes die alle Primzahlen (durch Komma getrennt) bis zur Obergrenze max ausgibt (max â‰¥ 2). Â§ Beispiel: printPrimes mit Eingabe 50 ergibt: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 Â§ Eine Primzahl p kann in genau zwei Faktoren zerlegt werden: p und 1 127 import java.util.*; class PrintPrimes1 { public static void main (String[] args) { Scanner console = new Scanner(System.in); System.out.print(\"Input max: \"); int max = console.nextInt(); if (max >= 2) { printPrimes(max); } } public static void printPrimes(int limit) // Prints all prime numbers up to limit, limit >= 2 System.out.print(\"2\"); for (int candidate = 3; candidate <= limit; candidate++) { if ( /* isPrime(candidate) */ ) { System.out.print(\", \" + candidate); } } System.out.println(); // to end output } } 129 public static void printPrimes(int limit) { // Prints all prime numbers from 2 up to the given limit // limit >= 2 System.out.print(\"2\"); for (int candidate = 3; candidate <= limit; candidate++) { // Determine if candidate is prime // Count factors! 2: prime, >2 not prime int count = 0; for (int j = 1; j<=candidate; j++) { if (candidate % j == 0) { count++; } } if (count == 2) { System.out.print(\", \" + candidate); } } System.out.println(); // to end output } 131 2.8.4 Input Werte zur Schleifen Kontrolle Â§ Interessantes Beispiel eines unbestimmten Loops Â§ Kandidat fÃ¼r while-Schleife Â§ Wert wird nicht (nur) zur Berechnung verwendet sondern kontrolliert auch den Loop (d.h. die Terminierung) Â§ Wert ist (zusÃ¤tzlich) Hinweis 133 Â§ Hinweiszeichen (Sentinel) (Â«sentinelÂ»): Ein Wert der das Ende eine Reihe anzeigt Â§ sentinel loop: Schleife deren Rumpf ausgefÃ¼hrt wird bis ein Sentinel gesehen wurde Â§ Beispiel: Ein Programm soll Zahlen einlesen bis der Benutzer eine 0 eingibt; dann soll die Summe aller eingegebenen Zahlen ausgegeben werden. Â§ (In diesem Beispiel ist 0 das Hinweiszeichen/der Sentinel.) Werte die Hinweise sind â€¦ 134 Â§ Beispiel: Ein Programm soll Zahlen einlesen bis der Benutzer eine 0 eingibt; dann soll die Summe aller eingegebenen Zahlen ausgegeben werden. Â§ (In diesem Beispiel ist 0 das Hinweiszeichen/der Sentinel) Enter a number (0 to quit): 10 Enter a number (0 to quit): 20 Enter a number (0 to quit): 30 Enter a number (0 to quit): 0 The sum is 60 Werte die Hinweise sind â€¦ 135 Fehlerhafte LÃ¶sung Â§ Was ist an diesem Programm schlecht? Scanner console = new Scanner(System.in); int sum = 0; int number = 1; // \"dummy value\", anything but 0 while (number != 0) { System.out.print(\"Enter a number (0 to quit): \"); number = console.nextInt(); sum = sum + number; } System.out.println(\"The total is \" + sum); 136 Ein anderes Hinweiszeichen â€¦ Â§ Ã„ndern Sie das Programm so dass -1 der Sentinel ist. Scanner console = new Scanner(System.in); int sum = 0; int number = 1; // \"dummy value\", anything but 0 while (number != -1) { System.out.print(\"Enter a number (0 to quit): \"); number = console.nextInt(); sum = sum + number; } System.out.println(\"The total is \" + sum); 137 Ein anderes Hinweiszeichen â€¦ Â§ Ã„ndern Sie das Programm so dass -1 der Sentinel ist. Â§ Example log of execution: Enter a number (-1 to quit): 15 Enter a number (-1 to quit): 25 Enter a number (-1 to quit): 10 Enter a number (-1 to quit): 30 Enter a number (-1 to quit): -1 The total is 79 138 Ein anderes Hinweiszeichen â€¦ Â§ Setzen Sie den Sentinel auf -1: Scanner console = new Scanner(System.in); int sum = 0; int number = 1; // \"dummy value\", anything but -1 while (number != -1) { System.out.print(\"Enter a number (-1 to quit): \"); number = console.nextInt(); sum = sum + number; } System.out.println(\"The total is \" + sum); Â§ Jetzt ist das Result falsch. Warum? The total is 79 139 Fehlerhafte LÃ¶sung â€“ 0 Ã  -1 Â§ Was ist an diesem Programm falsch? Scanner console = new Scanner(System.in); int sum = 0; int number = 1; // \"dummy value\", anything but 0 while (number != 0) { System.out.print(\"Enter a number ( 0 to quit): \"); number = console.nextInt(); sum = sum + number; } System.out.println(\"The total is \" + sum); Â§ Was ist an diesem Programm falsch? Scanner console = new Scanner(System.in); int sum = 0; int number = 1; // \"dummy value\", anything but -1 while (number != -1) { System.out.print(\"Enter a number (-1 to quit): \"); number = console.nextInt(); sum = sum + number; } System.out.println(\"The total is \" + sum); 140 Das Problem mit diesem Programm Â§ Unser Programm folgt diesem Muster: summe = 0 while (input ist nicht der sentinel) { drucke prompt; lese input addiere input zu summe } Â§ Beim letzten Durchlauf durch den Rumpf wird der Sentinel -1 zur Summe addiert: 142 Das Problem mit diesem Programm Â§ Beim letzten Durchlauf durch den Rumpf wird der Sentinel -1 zur Summe addiert: drucke prompt; lese input (-1) addiere input (-1) zu summe Â§ Beispiel inkorrekter Terminierung (off-by-one error, Zaunpfahlproblem): Â§ MÃ¼ssen N Zahlen lesen aber nur die ersten N-1 addieren. 143 LÃ¶sung summe = 0 drucke prompt; lese input // setzen eines pfostens while (input ist nicht der sentinel) { addiere input zu summe // installation querstrebe drucke prompt; lese input // setzen eines pfostens } Â§ Schleifen mit einem Sentinel folgen oft diesem Muster. 144 Beispiel mit Sentinel Scanner console = new Scanner(System.in); int sum = 0; // pull one prompt/read (\"post\") out of the loop System.out.print(\"Enter a number (-1 to quit): \"); int number = console.nextInt(); while (number != -1) { sum = sum + number; // moved to top of loop System.out.print(\"Enter a number (-1 to quit): \"); number = console.nextInt(); } System.out.println(\"The total is \" + sum); 146 do-while-Schleife Â§ do-while-Schleife: FÃ¼hrt test am Ende des Schleifenrumpfes aus um zu entscheiden, ob ein weiterer Durchlauf nÃ¶tig ist Â§ Stellt sicher dass der Rumpf { â€¦ } mindestens einmal ausgefÃ¼hrt wird. do { statement(s); } while (test); // naechste Anweisung Anweisung(en) im Loop ausfÃ¼hren Ist test wahr? Anweisung nach Loop ausfÃ¼hren ja nein 147 do-while-Schleife Â§ Beispiel: // Example: prompt until correct PIN is typed int input; do { System.out.print(\"Type your PIN: \"); input = console.nextInt(); } while (input != userPinCode); Anweisung(en) im Loop ausfÃ¼hren Ist test wahr? Anweisung nach Loop ausfÃ¼hren ja nein 148","libVersion":"0.3.2","langs":""}