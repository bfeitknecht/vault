{"path":"sem3/EProg/PV/exams/program/HS23.pdf","text":"Herbst 2023 252-0027 – Einführung in die Programmierung Departement Informatik ETH Zürich 5. Februar 2024 – Programmieren Nachname: Vorname: Legi-Nummer: – – Computer: slab Sie dürfen diese Prüfung oder die schriftliche Prüfung erst öﬀnen nachdem die Aufsicht die Prüfung gestartet hat. Wenn Sie diese Dokumente vorher öﬀnen gilt dies als Täuschungsversuch. Mit Ihrer Unterschrift bestätigen Sie, dass Sie die hier aufgeführte Person sind, Sie die Hinweise zur Kenntnis genommen haben, Sie die Aufgaben selbständig bearbeitet haben, Sie Ihre eigene Lösung abgeben, Sie keine Kopie der Prüfung mitnehmen, Sie alle technischen Probleme und etwaige störende äussere Einﬂüsse gemeldet haben bzw. wissen, dass Sie diese melden sollen, und dass Sie keine gesundheitlichen Probleme hatten, die Ihre Leistungen in dieser Prüfung beeinträchtigten. Unterschrift: Bitte lassen Sie unbedingt die unterschriebene Aufgabenstellung mit der Nummer des Com- puters auf Ihrem Tisch - wir sammeln diese später ein. Hinweise 1. Bitte schreiben Sie Ihren Namen und Legi-Nummer sowie die Nummer ihres Computers (ﬁnden Sie auf dem Computer) auf diese Seite. Vergessen Sie nicht die Unterschrift am Ende der Prüfung. 2. Während der Programmierprüfung dürfen Sie nicht mehr an der schriftlichen Prüfung weiterarbeiten, auch wenn diese noch nicht eingezogen worden ist. Dies gilt als Täuschungsversuch. 3. Die Prüfung hat 14 Seiten. Vergewissern Sie sich dass Ihr Exemplar vollständig ist. Die letzten fünf Seiten können Sie für Skizzen o.ä. benutzen, aber diese werden nicht für die Benotung hinzugezogen. 4. Die Programmierprüfung dauert 2 Stunden (120 Minuten). Falls Sie sich durch irgendjemanden oder irgendetwas gestört fühlen, oder technische Probleme an Ihrem Computer auftreten, so melden Sie dies sofort der Aufsicht. (Falls es unerwartete Fehlermeldungen gibt: Lassen Sie solche Fehlermeldungen oder PopUp Nachrichten auf dem Bildschirm und informieren Sie die Aufsicht. Nur so verhindern Sie, dass durch Systemfehler Ihre Programme verändert werden.) Sollten Sie durch die Behandlung eines technischen Problems Zeit verlieren, so werden Sie die verlorene Zeit nachholen können. 5. Wir beantworten keine inhaltlichen Fragen während der Prüfung. 6. Die Benutzung elektronischer Geräte während der Prüfung ist nicht erlaubt; diese müssen während der Prüfung unerreichbar deponiert werden. 7. Lesen Sie die Aufgabenstellungen genau durch. Es ist wichtig, dass Ihre Antworten den Anforderungen der Aufgaben genau entsprechen. Wenn die Aufgabenstellung etwas nicht speziﬁert, dann können Sie frei entscheiden (wir testen nur was wir speziﬁzieren). Class.name() heisst Methode name() in Klasse Class. 8. Benutzen Sie die Anzahl der Sterne in der Programmierprüfung als Hinweis, der ungefähr den Aufwand und die erreichbare Punktzahl der Aufgabe widerspiegelt. Je mehr Sterne, desto aufwändiger. 9. Für jede Aufgabe gibt es ein separates Java-Projekt in Ihrem Eclipse-Workspace. Sie können die Aufgaben in beliebiger Reihenfolge lösen. 10. Die Programmieraufgaben werden vorwiegend automatisch getestet und bewertet. Programme, welche nicht mindestens teilweise ein korrektes Resultat zurückgeben (oder gar nicht erst kompilieren), erhalten keine Punkte. 11. Stellen Sie regelmässig sicher, dass Ihre Dateien im Workspace gespeichert sind. Nur diese Dateien werden von einem Backup-Prozess während der Prüfung gespeichert. Was nicht gespeichert ist, kann nicht bewertet werden. 12. Sollten Sie eine Ihrer Lösungsdateien überschreiben, so kann die Aufsicht Ihnen helfen! Melden Sie sich sofort. 13. Ändern Sie unter keinen Umständen die Signaturen der im Aufgabentext erwähnten Methoden (Name, Typ und Reihenfolge der Parameter), ihren Rückgabetyp, Modiﬁzierer wie static, public oder gegebenfalls die Liste der geworfenen Exceptions. Das gleiche gilt für Konstruktoren und Attribute. Auch die Namen der erwähnten Klassen dürfen Sie nicht ändern und auch nicht Interfaces in Klassen umwandeln. Solche Änderungen können dazu führen, dass Sie keine Punkte für die Aufgabe erhalten. Wenn nicht anders vermerkt, dürfen Sie Methoden, Attribute, Interfaces oder Klassen zu den vorhandenen hinzufügen oder Klassen und Interfaces importieren. Die Verwendung von Java Reﬂection ist nicht erlaubt (und auch nicht von Vorteil). Java Assertions sind per default nicht aktiviert (auch nicht während der Bewertung). 14. Das Verwenden von static-Attributen ist grundsätzlich falsch. Rechnen Sie damit, dass wir das abgegebene Programm mehrfach ausführen (und ein Test selber aus mehreren Methodenaufrufen bestehen kann), ohne dass static-Attribute neu initialisiert werden. Lösungen, welche static-Attribute verwenden, und nur funktionieren, wenn ein Programm/eine Methode nur ein Mal ausgeführt wird, können potenziell 0 Punkte bekommen. 15. In jedem Projekt gibt es neben dem “src”-Ordner einen “test”-Ordner mit einigen JUnit-Tests. Wir empfehlen, diese mit ihren eigenen Tests zu erweitern. Tests werden nicht bewertet. 16. Falls gewisse Tests beim Ausführen scheinbar keine Resultate liefern, könnte es daran liegen, dass Ihre Lösung eine Endlosschleife enthält. Stoppen Sie in diesem Fall die Tests von Hand (siehe Hinweise zu Eclipse). 17. https://exam-translate.ethz.ch/ ist ein Übersetzungsservice, den wir ohne Gewähr zur Verfügung stellen. 18. Als zusätzliche Sicherheitsmassnahme wird Ihr Bildschirm während der Prüfung aufgezeichnet. 19. Wenn Sie in der IDE Zeichen ersetzen statt einfügen, dann drücken Sie die Insert Taste (über der Delete Taste). 20. Auf einer Schweizer Tastatur schreiben Sie eckige und geschweifte Klammern durch die “Alt Gr” Taste + die entsprechende Taste links über oder neben der Enter Taste. 21. Wenn Sie zur Toilette müssen, melden Sie dies einer Aufsichtsperson durch Handzeichen. Es darf zur gleichen Zeit immer nur eine Person zur Toilette. 22. Wenn Sie früher abgeben wollen, sperren Sie bitte Ihren Computer (Windows+L) und melden Sie sich bitte lautlos bei der Aufsicht. Die Aufsicht wird Ihnen sagen, wann Sie Ihren Arbeitsplatz verlassen können. Vorzeitige Abgaben sind nur bis 20 Minuten vor Prüfungsende möglich. 23. Wenn die Aufsicht die Prüfung beendet, vergewissern Sie sich, dass alle Dateien gespeichert sind. Nach der Sperrung der Computer können Sie keine weiteren Änderungen mehr vornehmen. 24. Verlassen Sie bitte den Prüfungsraum leise nach der Prüfung; auch vor dem Prüfungsraum bitten wir um Ruhe.. Es kann sein, dass andere Studierende noch weiterarbeiten, da sie eine Zeitgutschrift bekommen haben. Auch diese Studierenden sollen in Ruhe arbeiten können. Bitte lassen Sie unbedingt die unterschriebene Aufgabenstellung mit der Nummer des Computers auf Ihrem Tisch - wir sammeln diese später ein. Page 2 of 14 Anmelden und Eclipse starten 1. Sobald die Programmierprüfung startet, können Sie sich an Ihrem Computer anmelden. Geben Sie zuerst Ihren vollen Namen und im nächsten Schritt Ihren NETHZ-Namen und Ihre Legi-Nummer ein. (Sie brauchen nicht Ihr NETHZ-Passwort.) Sie werden auch in einem weiteren Fenster darauf hingewiesen, dass Ihr Computer aufgezeichnet wird, und dass Sie technische Probleme sofort melden müssen. Sobald Sie angemeldet sind, erscheint ein Browsertab mit allgemeinen Hinweisen zur Computer-Prüfung. 2. Starten Sie Eclipse, indem Sie (1) oben links auf “Activities” (oder “Aktivitäten”) klicken und dann (2) im Suchfeld “Eclipse” eingeben. Wählen Sie (3) “Eclipse IDE” (nicht “Eclipse C/C++”). Warten Sie, bis Eclipse gestartet ist. Dies kann einige Minuten in Anspruch nehmen. 3. Wenn sich das Fenster “Eclipse IDE Launcher” öﬀnet, müssen Sie zuerst den Eclipse-Workspace Ordner im Feld “Workspace” anpassen (der Standardpfad, welcher im Fenster automatisch angegeben wird, ist inkorrekt): (1) klicken Sie auf “Browse...”, (2) wählen Sie dann im Auswahldialog den “questions”-Ordner aus, (3) klicken Sie oben rechts auf “Open” und (4) klicken Sie unten rechts auf “Launch”. Im Feld “Workspace” sollte folgender Pfad stehen, bevor Sie auf “Launch” klicken: /var/lib/exam/student/questions 4. Wenn Eclipse fertig gestartet ist, sehen Sie den Willkommens-Bildschirm. Klicken Sie wenn nötig oben rechts auf “Workbench”. Nun sollten Sie links die drei Projekte “Aufgabe 1”, “Aufgabe 2” und “Aufgabe 3” sehen. Es kann einige Minuten dauern bis Eclipse alles geladen hat. Warten Sie bis die Ladenachricht “Initializing Java Tooling” (unten rechts in Eclipse) nicht mehr sichtbar ist. Zusätzlich können Sie auf die Java Dokumentation zugreifen, indem Sie oben links auf die “Activities” gehen, dann unten auf das “Files” Icon klicken, dann auf “documentation” klicken und schlussendlich “index.html” öﬀnen, was die Dokumentation in einem Browser öﬀnet. Allgemeine Hinweise zur Computer-Prüfung können Sie lesen, indem Sie oben links auf die “Activities” gehen und auf das Informationsicon klicken. Viel Spass! Hinweise zu Eclipse Verhindern von Abstürzen Bevor Sie ein Programm oder einen Test ausführen, achten Sie darauf, dass alle anderen Programme und Tests korrekt terminiert wurden. Wenn zu viele Programme gleichzeitig laufen, dann wird Ihr Computer langsamer, manchmal einfrieren, und im schlimmsten Fall abstürzen. Auch verhält sich dann manchmal Eclipse oder der Debugger unnatürlich. Das geht von Ihrer Zeit ab. Ein Problem ist, dass, auch wenn die aktive Konsole mit terminiert wurde und somit ausgegraut ist ( ), es noch weitere Konsolen geben kann, welche immer noch laufen. Wenn das Icon vorhanden und nicht ausgegraut ist ( ), dann gibt es mehr als eine Konsole, was auch heisst, dass mehrere Programme oder Tests noch nicht terminiert sein können: Durch einen Klick auf den Pfeil von , wird eine Liste aller vorhandenen Konsolen angezeigt: Durch klicken von werden alle terminierten Konsolen geschlossen. Klicken Sie wiederholt und (oder ) bis ausgegraut oder verschwunden ist, um alle Programme und Tests zu terminieren und alle Konsolen zu schliessen. Javadoc Es gibt verschiedene Möglichkeiten die Javadoc Dokumentation zu öﬀnen. Eine komfortable Option ist den Javadoc View zu verwenden. Dieser sollte in einer der Tabs bei der Konsole zu sehen sein ( ). Falls der Tab nicht vorhanden ist, oder falls Sie den Tab einfach nicht ﬁnden, dann können Sie durch das drücken von Alt + Shift + Q und dann J den Tab öﬀnen. Alternativ können Sie auch im Quick Access Fenster (ganz oben rechts ) “Javadoc” eingeben und dann oder drücken. Wenn Sie den Javadoc View geöﬀnet haben, dann wird Ihnen die verfügbare Dokumentation von allem gezeigt das Sie anklicken. Zusätzlich, wenn Sie auf etwas zeigen, während Sie die Ctrl Taste gedrückt haben, dann können Sie sich die Declaration anzeigen lassen: Debugger Ob Sie den Debugger verwenden ist Ihre Entscheidung. Wir werden keine Fragen zum Debugger beantworten. Die Aufgaben sind auch gut ohne Debugger lösbar. Um in den Debugging Modus zu wechseln, klicken Sie den Debugger Knopf rechts neben dem Quick Access Fenster (ganz oben rechts ). Falls dieser Knopf nicht vorhanden ist, dann können Sie im Quick Access Fenster (ganz oben rechts ) “Debug” eingeben und dann drücken. Alternativ können Sie auch den Knopf direkt neben dem Quick Access Fenster drücken und dann “Debug” wählen . Page 4 of 14 Aufgabe 1 (⋆) In dieser Aufgabe geht es um Berechnungen mit Matrizen, welche aus ganzen Zahlen (repräsentiert durch int) bestehen. Für eine < × < Matrix , (< Zeilen und < Spalten) beschreibt ,8,9 den Wert von , bei Zeile 8 und Spalte 9 (wobei 0 ≤ 8 < < und 0 ≤ 9 < < gelten muss). Sei \u0016 eine (: · =) × (: · =) Matrix, wobei : ≥ 1 und = ≥ 1. Wir deﬁnieren die :−Reduktion der Matrix \u0016 als die = × = Matrix \u0017, wobei \u00178,9 wie folgt berechnet wird (wobei 0 ≤ 8 < = und 0 ≤ 9 < = gilt): Sei T (8, 9) die folgende Teilmatrix von \u0016 \u00168 ·:,9 ·: \u00168 ·:,( 9 ·:)+1 · · · \u00168 ·:,( 9 ·:)+:−1 \u0016 (8 ·:)+1,9 ·: \u0016 (8 ·:)+1,( 9 ·:)+1 · · · \u00168 ·:+1,( 9 ·:)+:−1 ... ... . . . ... \u0016 (8 ·:)+:−1,9 ·: \u0016 (8 ·:)+:−1,( 9 ·:)+1 · · · \u00168 ·:+:−1,( 9 ·:)+:−1 (Hinweis: wenn : = 1, dann enthält T (8, 9) genau einen Wert.) Sei S(8, 9) die Summe aller Werte in T (8, 9), sei Max (8, 9) der grösste Wert in T (8, 9), und sei Min(8, 9) der kleinste Wert in T (8, 9). Dann wird \u00178,9 wie folgt berechnet: \u00178,9 =    Max (8, 9) wenn S(8, 9) > 0 Min(8, 9) wenn S(8, 9) < 0 0 wenn S(8, 9) = 0 Die folgende Abbildung skizziert ein Beispiel für : = 2 und = = 3. Die linke Abbildung repräsentiert die Inputmatrix \u0016 und die rechte Abbildung repräsentiert die 2-Reduktion von \u0016. Die Indizes sind kursiv und die Werte sind fett gedruckt. 0, 0 0, 1 0, 2 0, 3 0, 4 0, 5 1, 0 1, 1 1, 2 1, 3 1, 4 1, 5 2, 0 2, 1 2, 2 2, 3 2, 4 2, 5 3, 0 3, 1 3, 2 3, 3 3, 4 3, 5 4, 0 4, 1 4, 2 4, 3 4, 4 4, 5 5, 0 5, 1 5, 2 5, 3 5, 4 5, 5 0, 0 0, 1 0, 2 1, 0 1, 1 1, 2 2, 0 2, 1 2, 2 2 3 -1 -1 3 -4 -1 0 2 0 1 -3 3 3 8 4 1 -3 3 4 2 0 2 -2 5 2 0 0 3 -1 2 5 0 0 4 0 3 0 -4 4 8 -3 5 0 4 Hier ist zum Beispiel ) (0, 2) gegeben durch die vier Werte \u00160,4, \u00160,5, \u00161,4, \u00161,5 (in grün links). Da S(0, 2) < 0 ist, ist ,0,2 rechts (in grün) durch den kleinsten Wert in ) (0, 2) gegeben (-4). Wir verwenden Arrays arr vom Typ int[][] für Matrizen. arr modelliert eine < × < Matrix \" genau dann, wenn arr.length = <, arr[i].length = < und \"8,9 = arr[i][j] (für alle 8, 9 mit 0 ≤ 8 < < und 0 ≤ 9 < <). Implementieren Sie die Methode Matrix.kReduce(int[][] input, int :). Sie dürfen annehmen, dass input nicht null ist, : > 0 gilt, und dass keine Teilsumme von Elementen in input zu Underﬂow oder Overﬂow führen kann. Wenn es keine positive ganze Zahl = > 0 gibt, so dass input eine (: · =) × (: · =) Matrix modelliert, dann muss eine IllegalArgumentException geworfen werden. Ansonsten muss die Methode die :-Reduktion \u0017 von der Matrix zurückgeben, welche von input modelliert wird. In diesem Fall muss der Rückgabewert vom Typ int[][] sein und \u0017 modellieren. Page 5 of 14 Aufgabe 2 (⋆⋆) In dieser Aufgabe betrachten wir einen azyklischen gerichteten Graphen ˝ = (+ , ˆ, B, ˙ ), wobei + die Menge der Knoten, ˆ die Menge der Kanten, B ∈ + der Startknoten und ˙ ⊆ + die Menge der Endknoten ist. Jede Kante in ˆ ist ein geordnetes Triplet (0, ;, 1), wobei 0, 1 ∈ + und ; ∈ \u0006 das Label der Kante ist. Das Alphabet \u0006 beschränkt sich auf die 26 Kleinbuchstaben des englischen Alphabets (a bis z, ohne Umlaute und ohne Sonderzeichen). Für jedes Label in \u0006 hat ein Knoten in + maximal eine ausgehende Kante. Für einen Pfad in einem Graphen ist die Pfadbeschriftung gegeben durch die Konkatenierung der Kantenlabels. Akzeptierte Worte Basierend auf einem Knoten 0 in einem solchen Graphen ˝ = (+ , ˆ, B, ˙ ) deﬁnieren wir ein Wort F als akzeptiert von Knoten 0 genau dann, wenn es einen Pfad von 0 zu einem Endknoten 5 ∈ ˙ gibt, dessen Pfadbeschriftung F ist: F wird von 0 akzeptiert ⇔ ∃(0, ;, 1) ∈ ˆ mit F = ;E ∧ ((1 ∈ ˙ ∧ E = n) ∨ E wird von 1 akzeptiert) Die folgende Abbildung zeigt ein Beispiel für einen Graphen mit Knoten + = {0, 1, 2, 3, 4, 5 , 6, \u0011}, Kanten ˆ = {(0, m, 1), (1, n, 2), (2, o, 3), (2, q, 5 ), (3, p, 4), (5 , r, 6), (5 , p, \u0011)}, Startknoten 0 und Endknoten ˙ = {4, 6, \u0011}. nm r p p o q a b c d f g h e In diesem Graphen werden nur die Wörter mnop, mnqr und mnqp von 0 akzeptiert. Keine anderen Wörter werden von 0 akzeptiert. mnop wird zum Beispiel von 0 akzeptiert, da der Pfad 0 → 1 → 2 → 3 → 4 die Pfadbeschriftung mnop hat und 4 ein Endknoten in ˝ ist. k-skip-akzeptierte Worte Zusätzlich zur regulären Akzeptanz, deﬁnieren wir für Graphen ˝ = (+ , ˆ, B, ˙ ), dass F k-skip-akzeptiert wird genau dann, wenn es einen Pfad vom Startknoten B zu einem Endknoten 5 ∈ ˙ gibt, dessen Pfadbeschriftung w ist, wenn beim Traversieren des Graphen jede k-te Kante übersprungen wird. Zum Beispiel gilt im oberen Graph, dass mnp k-skip-akzeptiert wird für : = 3: Für mn führt der Pfad 0 → 1 → 2 zu 2 und da dann (: = 3) die Kante (2, o, 3) übersprungen werden kann, führt p über den Pfad 3 → 4 zu 4 ∈ ˙ . Wenn man jede dritte Kante überspringt, dann ist die Beschriftung des Pfades mnp. (Analog könnte hier auch die Kante (2, q, 5 ) übersprungen werden). Im vorgegebenen Code ﬁnden Sie die Klasse Node, welche einen Knoten in einem solchen Graphen reprä- sentiert. Node.transitions repräsentiert alle ausgehenden Kanten vom Knoten als Map<Character, Node>. Für zwei Knoten repräsentiert durch Node-Objekte a und b (ungleich null) existiert eine Kante (a, l, b) genau dann, wenn a.transitions.get(l) = b gilt. Die Klasse Matcher enthält eine Referenz this.start auf den Startknoten des Graphen und eine Referenz this.accepting für die Menge der Endknoten. Die Hilfsmethode Node.addWord(String w) erlaubt die einfache Konstruktion eines Graphen, der den String w akzeptiert. Page 6 of 14 Lösen Sie nun die folgenden Aufgaben, bei denen Sie annehmen dürfen, dass der gegebene Graph keine Zyklen enthält und alle Input-Strings nur aus Buchstaben in \u0006 bestehen. (a) (⋆) Implementieren Sie die Methode Matcher.suffix(String w), welche bestimmt, ob Wörter v existie- ren, so dass die Konkatenierung v + w von this.start akzeptiert wird. Die Methode soll die Menge aller solchen Wörter v zurückgeben. Falls keine solchen Wörter existieren, soll die leere Menge zurückgegeben werden. (b) (⋆) Implementieren Sie die Methode Matcher.skipmatch(String w, int :). Wenn w :-skip-akzeptiert wird, dann muss diese Methode ein Wort I zurückgeben, welches demonstriert, dass w :-skip-akzeptiert wird. Das heisst, I muss vom Startknoten this.start akzeptiert werden und wenn man im zugehörigen Pfad für I jede :-te Kante überspringt, dann ist die Pfadbeschriftung F. Wenn es mehrere Möglichkeiten für I gibt, dann kann eine beliebige davon gewählt werden. Wenn w nicht :-skip-akzeptiert wird, dann muss die Methode null zurückgegeben. Sie können davon ausgehen, dass 2 ≤ : ≤ 10 gilt. Zum Beispiel muss im oberen Graph folgendes gelten: • skipmatch(\"mnp\", 3) muss entweder mnop oder mnqp zurückgeben, da mnp für : = 3 :-skip- akzeptiert wird und die einzigen zwei Pfade, welche die :-skip-Akzeptanz demonstrieren, Pfadbe- schriftungen mnop und mnqp haben. • skipmatch(\"mnp\", 4) muss null zurückgeben, da für mn zwar der Pfad 0 → 1 → 2 zu 2 führt, aber dann keine Kante mit Label p von 2 aus verfügbar ist. • skipmatch(\"mno\", 4) muss mnop zurückgeben, da für mno der Pfad 0 → 1 → 2 → 3 zu 3 führt und im vierten Schritt die Kante 3 → 4 übersprungen werden kann, so dass man zum Endknoten 4 kommt und somit mno für : = 4 :-skip-akzeptiert wird. • skipmatch(\"mg\", 2) muss null zurückgeben, da für m der Pfad 0 → 1 zu 1 führt, aber nach dem Überspringen der Kante 1 → 2 kein Pfad mit Kantenlabel g existiert. Für die Lösung dieser Aufgaben ist es Ihnen erlaubt, neue Methoden und Felder in der Klasse Matcher zu deﬁnieren. Versuchen Sie, erst Aufgabenteil (a) zu lösen, bevor Sie Aufgabenteil (b) angehen. Page 7 of 14 Aufgabe 3 (⋆⋆⋆) Sie implementieren in dieser Aufgabe Teile eines einfachen Spiels, in dem Teilnehmer verschiedene Aktionen durchführen können. Die Klasse Game repräsentiert ein Spiel und verwaltet die Teilnehmer (jeder Teilnehmer kann nur zu einem Spiel gehören). Alle Teilnehmer sind Humans und haben als Attribute einen Gesundsheitslevel (health) und eine Position (position); beides sind ganze Zahlen (int). Ein Human ist alive, wenn health > 0. Teilnehmer planen mittels Human.scheduleAction(Action) eine Aktion. Eine Aktion kann den Zustand des Humans verändern, für den scheduleAction aufgerufen wird (diesen Human nennen wir die Source), oder die Aktion verändert den Zustand anderer Humans des Spiels. Die zulässigen Aktionen sind Action.ATTACK und Action.SUMMON. Aktionen werden entweder am Ende der aktuellen Runde ausgeführt (delay ist 0), oder die Aktionen werden am Ende der Runde ausgeführt, nachdem delay weitere Runden gespielt wurden. Alle Aktionen (am Ende einer Runde) werden immer in der Reihenfolge ausgeführt, in der sie durch scheduleAction geplant wurden. Eine Aktion wird nur dann ausgeführt, wenn die Source zum Zeitpunkt der Ausführung noch immer alive ist. Dabei werden health und position zum Zeitpunkt der Ausführung verwendet. In der Welt des Spiels gibt es 1000 Positionen (0, 1, ..., 999). Auf jeder Position können beliebig viele Teilnehmer Platz nehmen. Für jeden Teilnehmer muss getPosition() die aktuelle Position und getHealth() den aktuellen Gesundsheits- level liefern. Die Position wird nur als Folge einer Aktion (siehe weiter unten) geändert. Wenn ein Teilnehmer = Einheiten Schaden erleidet, dann wird health um = reduziert. Sie können davon ausgehen, dass jeder Teilneh- mer mit health > 0 im Spiel anfängt. Ein Teilnehmer, der nicht mehr alive ist, kann keine weiteren Aktionen durchführen und Aktionen, die er geplant hat, aber die noch nicht ausgeführt wurden, werden nicht mehr ausgeführt. Es gibt vier Arten von Teilnehmern: Human, Warrior, Cleric und General. Die folgende Tabelle zeigt den delay, der bei den möglichen Aktionen (ATTACK und SUMMON) für die verschiedenen Arten von Teilnehmern angewendet wird. Source ATTACK SUMMON Human 0 0 Warrior 0 1 Cleric 0 2 General 0 0 Die nächste Tabelle gibt an, welchen Eﬀekt die Aktionen haben. Beachten Sie, dass für health und position der aktuelle Wert zur Zeit der Ausführung massgebend ist. \u00161B (G) ist der absolute Wert |G |, der durch Math.abs() berechnet werden kann. Für Task (a) werden Sie Human und Warrior implementieren und für Task (b) werden Sie Cleric und General implementieren. Page 8 of 14 Source ATTACK SUMMON Human nichts nichts Warrior Wenn die Source in Position 8 ist, dann sinkt der Gesundheitslevel aller Teilnehmer in der Nachbarschaft (also mit Position 9 mit 9 ∈ {8 + 1, 8 − 1}) um 10 Einheiten. (Delay = 1) Der Gesundheitslevel der Source sinkt um 5 Einheiten. Cleric Wenn die Source in Position 8 ist, dann sinkt der Gesundheitslevel aller Teilnehmer in der Nachbarschaft (also mit Position 9 mit 9 ∈ {8 + 1, 8 − 1}) um 3 Einheiten. (Delay = 2) Wenn die Source in Position 8 ist, dann werden alle Teilnehmer, die alive sind und sich in Position 9 mit 9 ∈ {8 + 3, 8 + 4, 8 + 5, 8 − 3, 8 − 4, 8 − 5} beﬁnden, nach Position 8 bewegt. General Wenn die Source in Position 8 ist, dann sinkt der Gesundheitslevel eines Teilnehmers in Position 9 wie folgt: Wenn es < Teilnehmer mit einer Position : gibt, so dass 8 < : < 9 oder 9 < : < 8 ist, dann sinkt der Gesund- heitslevel des Teilnehmers in Position 9 um <0G (0, 20 −\u00161B (8 − 9) −<). Der Gesundheitsle- vel sinkt also um 20 minus (Abstand zwischen Position 8 und Position 9) minus (Anzahl der Teilnehmer zwischen der Position der Source und dem Teilnehmer in Position 9) – wenn diese Diﬀerenz > 0 ist. Andernfalls bleibt der Gesundheitslevel unverändert. Wenn die Source in Position 8 ist, dann be- rechnen wir für jeden Teilnehmer in Position 9 mit Gesundheitslevel \u0011, der nicht die Source ist (die Source wird hier also nicht berücksich- tigt), ein Gewicht 6 = \u0011 − 10 × \u00161B (8 − 9). Unter den < vielen Teilnehmern mit einer Position 9, so dass \u00161B (8 − 9) ≤ 5 ist (ohne die Source), wird das Exemplar mit dem </2-höchsten Gewicht 6 ausgewählt und zur Position 8 be- wegt. Sollte es mehrere Teilnehmer geben, die alle das gleiche Gewicht haben und bewegt werden könnten, dann kann ein beliebiger Teilnehmer ausgewählt werden. Der Test GameTest.testGeneral2 zeigt ein Beispiel. Alle Teilnehmer haben die Methode scheduleAction(action), die das oben beschriebene Verhalten veranlassen soll (wobei die Aktion am Ende einer Runde ausgeführt wird). Sollte ein Teilnehmer, der nicht mehr alive ist, eine Aktion planen, so soll eine IllegalArgumentException geworfen werden. Sollte ein Teilnehmer - eine Aktion planen, wenn es noch eine Aktion gibt, welche den Teilnehmer - als Source hat und noch nicht ausgeführt wurde, dann soll ebenfalls eine IllegalArgumentException geworfen werden. Die Methode Game.advanceTurn() beendet eine Runde und führt, wie in der Tabelle beschrieben, die Aktionen aus, die für diese Runde geplant sind. Anschliessend beginnt die nächste Runde. Die Klasse Game hat zusätzlich Methoden, die Teilnehmer zum Spiel hinzufügen: Game.createHuman(health, position), Game.createWarrior(health, position), Game.createGeneral(health,position) und zuletzt Game.createCleric(health,position) erstellen und registrieren den entsprechenden Teilnehmer. Der Rück- gabewert (vom Typ Human) ist ein Verweis auf das erstellte Exemplar. Diese Methoden müssen von Ihnen implementiert werden. Sie können davon ausgehen, dass für position immer 5 < position < 995 gilt. Beachten Sie, dass Sie die Signaturen der vorgeschriebenen Methoden nicht ändern dürfen. Sie können aber neue Klassen deﬁnieren, Interfaces zu bestehenden Klassen hinzufügen oder Vererbungshierarchien deﬁnieren. (a) (⋆) Implementieren Sie die Methoden Game.advanceTurn(), Game.createHuman(health,position) und Game.createWarrior(health,position), so dass sich Human.scheduleAction(action) wie oben be- schrieben verhält. (b) (⋆⋆) Implementieren Sie die Methoden Game.advanceTurn(), Game.createCleric(health,position) und Game.createGeneral(health,position), so dass sich Human.scheduleAction(action) wie oben beschrieben verhält. Page 9 of 14 Notizen Page 10 of 14 Notizen Page 11 of 14 Notizen Page 12 of 14 Notizen Page 13 of 14 Notizen Page 14 of 14","libVersion":"0.5.0","langs":""}