{"path":"sem3/TI/VRL/extra/nwehrl/TI-nwehrl-w08.pdf","text":"Theoretische Informatik HS24 Nicolas Wehrli ¨Ubungsstunde 08 12. November 2024 ETH Z ¨urich nwehrl@ethz.ch 1 Heute 1 Feedback 2 Reduktion 3 How To Reduktion 4 Reduktion continued 5 Satz von Rice 2 FeedbackReduktion Things Reduktionen sind klassische Aufgaben an dem Endterm. Ein bisschen wie Nichtregularit¨atsbeweise. Ist aber auch nicht so schlimm. 3 R-Reduktion Definition 5.3 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. Wir sagen, dass L1 auf L2 rekursiv reduzierbar ist, L1 ≤R L2, falls L2 ∈ LR =⇒ L1 ∈ LR Bemerkung: Intuitiv bedeutet das ”L2 mindestens so schwer wie L1” (bzgl. algorithmischen L ¨osbarkeit). 4 EE-Reduktion Definition 5.4 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. Wir sagen, dass L1 auf L2 EE- reduzierbar ist, L1 ≤EE L2, wenn eine TM M existiert, die eine Abbildung fM : Σ∗ 1 → Σ∗ 2 mit der Eigenschaft x ∈ L1 ⇐⇒ fM(x) ∈ L2 f ¨ur alle x ∈ Σ∗ 1 berechnet. Wir sagen auch, dass die TM M die Sprache L1 auf die Sprache L2 reduziert. 5 EE-Reduktion Wir sagen, dass M eine Funktion F : Σ∗ → Γ∗ berechnet, falls f ¨ur alle x ∈ Σ∗: q0g x M ∗ qacceptg F(x). Abbildung 1: Abbildung 5.7 vom Buch 6 Verh¨altnis von EE-Reduktion und R-Reduktion Lemma 5.3 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. L1 ≤EE L2 =⇒ L1 ≤R L2 Beweis: L1 ≤EE L2 =⇒ ∃TM M. x ∈ L1 ⇐⇒ M(x) ∈ L2 Wir zeigen nun L1 ≤R L2, i.e. L2 ∈ LR =⇒ L1 ∈ LR. Sei L2 ∈ LR. Dann existiert ein Algorithmus A (TM, die immer h¨alt), der L2 entscheidet. 7 Verh¨altnis von EE-Reduktion und R-Reduktion Wir konstruieren eine TM B (die immer h¨alt) mit L(B) = L1 F ¨ur eine Eingabe x ∈ Σ∗ 1 arbeitet B wie folgt: (i) B simuliert die Arbeit von M auf x, bis auf dem Band das Wort M(x) steht. (ii) B simuliert die Arbeit von A auf M(x). Wenn A das Wort M(x) akzeptiert, dann akzeptiert B das Wort x. Wenn A das Wort M(x) verwirft, dann verwirft B das Wort x. A h¨alt immer =⇒ B h¨alt immer und somit gilt L1 ∈ LR ■ 8 L und L ∁ Lemma 5.4 Sei Σ ein Alphabet. F ¨ur jede Sprache L ⊆ Σ∗ gilt: L ≤R L∁ und L ∁ ≤R L Beweis: Es reicht L∁ ≤R L zu zeigen, da (L∁)∁ = L und somit dann (L∁)∁ = L ≤R L∁. Sei M′ ein Algorithmus f ¨ur L, der immer h¨alt (L ∈ LR). Dann beschreiben wir einen Algorithmus B, der L∁ entscheidet. B ¨ubernimmt die Eingaben und gibt sie an M′ weiter und invertiert dann die Entscheidung von M′. Weil M′ immer h¨alt, h¨alt auch B immer und wir haben offensichtlich L(B) = L. ■ 9 Anwendung vom Lemma 5.4 Korollar 5.2 (Ldiag) ∁ /∈ LR Beweis: Aus Lemma 5.4 haben wir Ldiag ≤R (Ldiag)∁. Daraus folgt Ldiag /∈ LR =⇒ (Ldiag)∁ /∈ LR. Da Ldiag /∈ LRE gilt auch Ldiag /∈ LR. Folglich gilt (Ldiag)∁ /∈ LR. ■ 10 Beispielaufgabe 17a HS22 Beweise LH ≤EE LU wobei LH = {Kod(M)#w | M h¨alt auf w ∧ w ∈ (Σbool) ∗} und LU = {Kod(M)#w | M akzeptiert w ∧ w ∈ (Σbool)∗} 11 Beispielaufgabe 17a HS22 Wir wollen LH ≤EE LU zeigen. Wir geben die Reduktion zuerst als Zeichnung an. Abbildung 2: EE-Reduktion von LH auf LU 12 Beispielaufgabe 17a HS22 Wir definieren eine Funktion M(x) f ¨ur ein x ∈ {0, 1, #}∗, so dass x ∈ LH ⇐⇒ M(x) ∈ LU (1) Falls x nicht die richtige Form hat, ist M(x) = λ, sonst ist M(x) = Kod(M′)#w wobei M′ gleich aufgebaut ist wie M, ausser dass alle Transitionen zu qreject zu qaccept umgeleitet werden. Wir sehen, dass M′ genau dann w akzeptiert, wenn M auf w h¨alt. Dieses M(x) ¨ubergeben wir dem Algorithmus f ¨ur LU. 13 Beispielaufgabe 17a HS22 Wir beweisen nun x ∈ LH ⇐⇒ M(x) ∈ LU: (i) x ∈ LH Dann ist x = Kod(M)#w von der richtigen Form, und M h¨alt auf w. Das heisst die Simulation von M auf w endet entweder in qreject oder in qaccept. Folglich wird M′ w immer akzeptieren, da alle Transitionen zu qreject zu qaccept umgeleitet wurden. x ∈ LH =⇒ M(x) ∈ LU (ii) x /∈ LH Dann unterscheiden wir zwischen zwei F¨allen: (a) x hat nicht die richtige Form, i.e. x ̸= Kod(M)#w. Dann ist M(x) = λ und da es keine Kodierung einer Turingmaschine M gibt, so dass Kod(M) = λ, gilt λ /∈ LU. 14 Beispielaufgabe 17a HS22 (i) x ∈ LH done above. (ii) x /∈ LH (a) falsche Form done above. (b) x = Kod(M)#w hat die richtige Form. Dann haben wir M(x) = Kod(M′)#w. Da aber x /∈ LH, h¨alt M nicht auf w. Da M nicht auf w h¨alt, erreicht es nie qreject oder qaccept in M und so wird w von M′ nicht akzeptiert. =⇒ M(x) /∈ LU So haben wir mit diesen F¨allen (a) und (b) x /∈ LH =⇒ M(x) /∈ LU bewiesen. Aus indirekter Implikation folgt M(x) ∈ LU =⇒ x ∈ LH 15 Beispielaufgabe 17a HS22 Aus (i) und (ii) folgt x ∈ LH ⇐⇒ M(x) ∈ LU (1) Somit ist die Reduktion korrekt. ■ 16 Beispielaufgabe 18b HS22 Sei Linfinite = {Kod(M) | M h¨alt auf keiner Eingabe} Zeige (Linfinite)C /∈ LR 17 Beispielaufgabe 18b HS22 Wir zeigen, dass (Linfinite)C /∈ LR mit einer geeigneten Reduktion. Wir beweisen LH ≤R (Linfinite)C Um dies zu zeigen nehmen wir an, dass wir einen Algorithmus A haben, der (Linfinite)C entscheidet. Wir konstruieren einen Algorithmus B, der mit Hilfe von A, die Sprache LH entscheidet. 18 Beispielaufgabe 18b HS22 Wir betrachten folgende Abbildung: Abbildung 3: R-Reduktion von LH auf (Linfinite) C 19 Beispielaufgabe 18b HS22 I. F ¨ur eine Eingabe x ∈ {0, 1, #}∗ berechnet das Teilprogramm C, ob x die richtige Form hat(i.e. ob x = Kod(M)#w f ¨ur eine TM M). II. Falls nicht, verwirft B die Eingabe x. III. Ansonsten, konstruiert C eine Turingmaschine M′, die Eingaben ignoriert und immer M auf w simuliert. Wir sehen, dass M′ genau dann h¨alt, wenn M auf w h¨alt. IV. Folglich h¨alt M′ entweder f ¨ur jede Eingabe (M h¨alt auf w) oder f ¨ur keine (M h¨alt nicht auf w). V. Da A genau dann akzeptiert, wenn die Eingabe keine g ¨ultige Kodierung ist(ausgeschlossen, da C das herausfiltert) oder wenn die Eingabe M(x) = Kod(M′) und M′ f ¨ur mindestens eine Eingabe h¨alt, akzeptiert A M(x) genau dann, wenn x = Kod(M)#w die richtige Form hat und M auf w h¨alt. 20 Beispielaufgabe 18b HS22 Folglich gilt x ∈ LH ⇐⇒ M(x) ∈ (Linfinite) C =⇒ LH ≤R (Linfinite)C Also folgt die Aussage (Linfinite)C ∈ LR =⇒ LH ∈ LR Da wir LH /∈ LR (Satz 5.8), folgt per indirekter Implikation: (Linfinite)C /∈ LR ■ 21 How To Reduktion L ∈ LR Wir kennen zwei Methoden um dies zu beweisen: I. Reduktion (a) Wir finden eine Sprache L′ ∈ LR (entweder schon in Vorlesung bewiesen oder selbst beweisen). (b) Zeige die Reduktion L ≤R L′ (folgt trivial aus Lemma 5.4 f ¨ur L′ = L∁). II. Direkter Beweis: TM Konstruktion (a) Beschreibung einer TM (bzw. ein Algorithmus) M mit L(M) = L. Dabei kann man eine schon bekannte TM A verwenden, die immer h¨alt (i.e. L(A) ∈ LR). (b) Beweise L(M) = L und dass die TM M immer h¨alt. 22 L /∈ LR Wir kennen hier auch 3 Arten: - Trivial Folgt sofort aus L /∈ LRE, da LR ⊂ LRE. - Reduktion (a) Finde eine Sprache L′, so dass L′ /∈ LR (muss bewiesen werden, falls nicht im Buch). (b) Beweise L′ ≤R/EE L. (c) Geeignete Sprachen als L′ sind: L∁ empty, L∁ diag, LH, LU, LH,λ. (Alle im Buch bewiesen) - Satz von Rice 23 Anwendung von Satz von Rice F ¨ur den Satz von Rice: - Wir k ¨onnen mit diesem Satz nur L /∈ LR beweisen! - Wir haben folgende Bedingungen: i. L ⊆ KodTM ii. ∃ TM M: Kod(M) ∈ L iii. ∃ TM M: Kod(M) /∈ L iv. ∀ TM M1, M2: L(M1) = L(M2) =⇒ (Kod(M1) ∈ L ⇐⇒ Kod(M2) ∈ L) F ¨ur den letzten Punkt (4) muss man ¨uberpr ¨ufen, ob in der Definition von L = {Kod(M) | M ist TM und ...} ¨uberall nur L(M) vorkommt und nirgends M direkt. Beziehungsweise reicht es, wenn man die Bedingung so umschreiben kann, dass sie nur noch durch L(M) beschrieben ist. 24 L ∈ LRE I. Wir beschreiben eine TM M mit L(M) = L, die nicht immer halten muss. II. Meistens muss die TM eine Eigenschaft, f ¨ur alle m ¨oglichen W ¨orter pr ¨ufen. III. Bsp: L = {Kod(M1) | Kod(M1) ∈ L∁ H}: Wir gehen alle W ¨orter durch, um dasjenige zu finden, f ¨ur das M1 h¨alt. IV. Wir verwenden oft einen von den folgenden 2 Tricks, um dies zu tun: - Da es f ¨ur jede NTM M′, eine TM M gibt, so dass L(M′) = L(M), k ¨onnen wir eine solche definieren, f ¨ur die L(M′) = L gilt. - Die andere Variante, ist die parallele Simulation von W ¨ortern, bei dem man das Diagonalisierungsverfahren aus dem Buch verwendet. (Bsp: Beweis Lempty ∈ LRE, S. 156 Buch) 25 L /∈ LRE Hier haben wir 2 m ¨ogliche (offizielle) Methoden: - Diagonalisierungsargument mit Widerspruch, wie beim Beweis von Ldiag /∈ LRE. - Widerspruchsbeweis mit der Aussage L ∈ LRE ∧ L∁ ∈ LRE =⇒ L ∈ LR (Aufgabe 5.22, muss begr ¨undet werden!). Inoffiziell k ¨onnten wir auch die EE-Reduktion verwenden, wird aber weder in der Vorlesung noch im Buch erw¨ahnt. 26 EE- und R-Reduktionen: Tipps und Tricks - Die vorgeschaltete TM A muss immer terminieren! I.e. sie muss ein Algorithmus sein. - Die Eingabe sollte immer zuerst auf die Richtige Form ¨uberpr ¨uft werden! Auch im Korrektsheitsbeweis, sollte dieser Fall als erstes abgehandelt werden. - F ¨ur Korrektheit m ¨ussen wir immer x ∈ L1 ⇐⇒ A(x) ∈ L2 beweisen. - Wir verwenden meistens folgende 2 Tricks: i. Transitionen nach qaccept oder qreject umleiten nach qreject/qaccept oder einer Endlosschleife. ii. TM M′ konstruieren, die ihre Eingabe ignoriert und immer dasselbe tut (z.B. eine TM dessen Kodierung gegeben ist, auf ein fixes Wort simuliern). - Die Kodierung einer TM generieren, dessen Sprache gewisse Eigenschaften hat(z.B. sie akzeptiert alle Eingaben, l¨auft immer unendlich etc.) 27 Klassifizierung verschiedener Sprachen LRE LR LEA {0n1n | n ∈ N} Ldiag LH LU Lempty (LH)C Lprim 28 Begrifflichkeiten F ¨ur eine Sprache L gilt folgendes L regul¨ar ⇐⇒ L ∈ LEA ⇐⇒ ∃ EA A mit L(A) = L L rekursiv ⇐⇒ L ∈ LR ⇐⇒ ∃ Alg. A mit L(A) = L L rekursiv aufz¨ahlbar ⇐⇒ L ∈ LRE ⇐⇒ ∃ TM M. L(M) = L ”Algorithmus” = TM, die immer h¨alt. L rekursiv = L entscheidbar L rekursiv aufz¨ahlbar = L erkennbar 29 Reduktion continued Lemma 5.5 L∁ diag ∈ LRE Beweis Direkter Beweis: Wir beschreiben eine TM A mit L(A) = L∁ diag. Eingabe: x ∈ (Σbool)∗ (i) Berechne i, so dass wi = x in kanonischer Ordnung (ii) Generiere Kod(Mi). (iii) Simuliere die Berechnung von Mi auf wi = x. 30 Lemma 5.5 Beweis continued - Falls wi ∈ L(Mi) akzeptiert, akzeptiert A die Eingabe x. - Falls Mi verwirft (h¨alt in qreject), dann h¨alt A und verwirft x = wi auch. - Falls Mi unendlich lange arbeitet, wird A auch nicht halten und dann folgt auch x /∈ L(A). Aus dem folgt L(A) = L∁ diag. ■ Korollar 5.3 L∁ diag ∈ LRE \\ LR und daher LR ⊊ LRE. 31 Universelle Sprache Sei LU := {Kod(M)#w | w ∈ (Σbool) ∗ und M akzeptiert w} Satz 5.6 Es gibt eine TM U, universelle TM genannt, so dass L(U) = LU Daher gilt LU ∈ LRE. Beweis Direkter Beweis: Konstruktion einer TM. Siehe Buch/Vorlesung. 32 Satz 5.7 Satz 5.7 LU /∈ LR Beweis Wir zeigen L∁ diag ≤R LU. Siehe Buch/Vorlesung. 33 Halteproblem Sei LH = {Kod(M)#w | M h¨alt auf w} Satz 5.8 LH /∈ LR Beweis Wir zeigen LU ≤R LH. Siehe Buch/Vorlesung. 34 Parallele Simulation vs Nichtdeterminismus Sei Lempty = {Kod(M) | L(M) = ∅} und L ∁ empty = {Kod(M) | L(M) ̸= ∅} ∪ {x ∈ {0, 1, #} | x /∈ KodTM} Lemma 5.6 L ∁ empty ∈ LRE 35 Nichtdeterminismus Beweis Da f ¨ur jede NTM M1 eine TM M2 existiert mit L(M1) = L(M2), reicht es eine NTM M1 mit L(M1) = L∁ empty zu finden. Eingabe: x ∈ {0, 1, #} (i) M1 pr ¨uft deterministisch, ob x = Kod(M) f ¨ur eine TM M. Falls x keine TM kodiert, wird x akzeptiert. (ii) Sonst gilt x = Kod(M) f ¨ur eine TM M und M1 w¨ahlt nichtdeterministisch ein Wort y ∈ (Σbool)∗. (iii) Dann simuliert M1 die TM M auf y deterministisch und ¨ubernimmt die Ausgabe. 36 Nichtdeterminismus Wir unterscheiden zwischen 3 F¨allen I x = Kod(M) und L(M) = ∅ Dann gilt x /∈ L∁ empty und da es keine akzeptierende Berechnung gibt, auch x /∈ L(M1). II x = Kod(M) und L(M) ̸= ∅ Dann gilt x ∈ L∁ empty und da es eine akzeptierende Berechnung gibt, auch x ∈ L(M1). III x kodiert keine TM Wir haben x ∈ L∁ empty und wegen Schritt (i) auch x ∈ L(M1). Somit gilt L(M1) = L∁ empty. ■ 37 Parallele Simulation Alternativer Beweis Wir konstruieren eine TM A mit L(A) = L direkt. Eingabe: x ∈ {0, 1, #} I. Falls x keine Kodierung einer TM ist, akzeptiert A die Eingabe. II. Falls x = Kod(M) f ¨ur eine TM M, arbeitet A wie folgt - Generiert systematisch alle Paare (i, j) ∈ (N \\ {0}) × (N \\ {0}). (Abz¨ahlbarkeit) - F ¨ur jedes Paar (i, j), generiert A das kanonisch i-te Wort wi und simuliert j Berechnungsschritte der TM M auf wi. - Falls M an ein Wort akzeptiert, akzeptiert A das Wort x. 38 Parallele Simulation Falls L(M) ̸= ∅ existiert ein y ∈ L(M). Dann ist y = wk f ¨ur ein k ∈ N \\ {0} und die akzeptierende Berechnung von M auf y hat eine endliche L¨ange l. Das Paar (k, l) wird in endlich vielen Schritten erreicht und somit akzeptiert A die Eingabe x, falls L(M) ̸= ∅. Somit folgt L(A) = L∁ diag. ■ 39 Aufgabe 5.22 Wir zeigen L ∈ LRE ∧ L ∁ ∈ LRE ⇐⇒ L ∈ LR ( =⇒ ) : Nehmen wir L ∈ LRE ∧ L∁ ∈ LRE an. Dann existiert eine TM M und MC mit L(M) = L und L(MC) = L∁. Wir konstruieren eine TM A, die f ¨ur eine Eingabe w die beiden TM’s M und MC parallel auf w simuliert. A akzeptiert w, falls M das Wort akzeptiert und verwirft, falls MC das Wort akzeptiert. 40 Aufgabe 5.22 Bemerke, dass L(M) ∩ L(MC) = ∅ und L(M) ∪ L(MC) = Σ∗. Da w ∈ L(M) oder w ∈ L(MC), h¨alt A immer. Da A genau dann akzeptiert, falls w ∈ L(M), folgt L(A) = L(M) = L. Demnach gilt L ∈ LR. ( ⇐= ) : Nehmen wir L ∈ LR an. Per Lemma 5.4 gilt L∁ ≤R L und daraus folgt auch L∁ ∈ LR. Da LR ⊂ LRE, folgt L ∈ LRE ∧ L∁ ∈ LRE. ■ 41 Weitere Erkenntnisse Lemma 5.7 L ∁ empty /∈ LR Beweis Wir zeigen LU ≤EE L∁ empty. Siehe Buch/Vorlesung. 42 Weitere Erkenntnisse Korollar 5.4 Lempty /∈ LR Korollar 5.5 LEQ /∈ LR f ¨ur LEQ = {Kod(M)#Kod(M) | L(M) = L(M)}. 43 Satz von Rice Spezialfall des Halteproblems Wir definieren LH,λ = {Kod(M) | M h¨alt auf λ}. Lemma 5.8 LH,λ /∈ LR Beweis: Wir zeigen LH ≤EE LH,λ. Wir beschreiben einen Algorithmus B, so dass x ∈ LH ⇐⇒ B(x) ∈ LH,λ. 44 Lemma 5.8 - Beweis continued F ¨ur jede Eingabe arbeitet B wie folgt: Falls x von der falschen Form, dann B(x) = Minf , wobei Minf unabh¨angig von der Eingabe immer unendlich l¨auft. Sonst x = Kod(M)#w: Dann B(x) = M′, wobei M′ die Eingabe ignoriert und immer M auf w simuliert. Wir sehen, dass M′ genau dann auf λ h¨alt, wenn x ∈ LH. Daraus folgt x ∈ LH ⇐⇒ B(x) ∈ LH,λ. ■ 45 Satz von Rice Satz 5.9 Jedes semantisch nichttriviale Entscheidungsproblem ¨uber Turingmaschinen ist unentscheidbar. ’ ¨uber Turingmaschinen’ = L ⊆ KodTM. ’nichttrivial’ = ∃M1 : Kod(M1) ∈ L und ∃M2 : Kod(M2) /∈ L ’semantisch’ = F ¨ur A, B mit L(A) = L(B) gilt Kod(A) ∈ L ⇐⇒ Kod(B) ∈ L. 46 Verwendung des Satz von Rice Wir definieren Lall = {Kod(M) | L(M) = (Σbool) ∗}. Zeige Lall /∈ LR. 47","libVersion":"0.3.2","langs":""}