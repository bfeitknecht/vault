{"path":"sem2/AuW/VRL/extra/slides/AuW-L05-satz-von-hall.pdf","text":"Kapitel 1.6 MatchingsMatching-Algorithmen Der Satz von Hall (Heiratssatz)Der Satz von Hall (Heiratssatz) Satz: (Hall, Heiratssatz)  Ein bipartiter graph G=(A⊎B, E) enthält ein  Matching M der Kardinalität |M|=|A| gdw  ∀ X⊆A : |X| ≤ |N(X)| Philip&Hall& (1904.1982)& X N(X) muss für jede Teilmenge gelten „ “⟹ „ “⟸ ! Der Satz von Hall (Heiratssatz) Satz: (Hall, Heiratssatz)  Ein bipartiter graph G=(A⊎B, E) enthält ein  Matching M der Kardinalität |M|=|A| gdw  ∀ X⊆A : |X| ≤ |N(X)| Philip&Hall& (1904.1982)& Beweis: Induktion über a = |A| a = 1:Induktionsverankerung: Induktionsschritt: Satz gilt für alle bipartiten Graphen mit |A| ≤ a-1 Satz gilt für alle bipartiten Graphen mit |A| = a “a-1 a“ Wir müssen zeigen: Der Satz von Hall (Heiratssatz) Satz: (Hall, Heiratssatz)  Ein bipartiter graph G=(A⊎B, E) enthält ein  Matching M der Kardinalität |M|=|A| gdw  ∀ X⊆A : |X| ≤ |N(X)| (*) Philip&Hall& (1904.1982)& Beweis: “a-1 a“ 1.Fall: ∀ ∅ ≠ X ⊊ A : |X| < |N(X)| 2.Fall: ∃ ∅ ≠ X0 ⊊ A : |X0| = |N(X0)| - Wähle beliebige Kante {x,y} und lösche x, y und alle inzidenten Kanten. - Zeige dass der verbleibende Graph die Bedingung (*) erfüllt. - Betrachte die beiden durch X0 ∪ N(X0) bzw A \\ X0 ∪ B\\ N(X0) induzierten Graphen - Zeige dass beide Graphen die Bedingung (*) erfüllen. Betrachte beliebigen Graphen mit |A|=a: Der Satz von Hall (Heiratssatz) Korollar: (Frobenius)  Für alle k gilt: jeder k-reguläre bipartite Graph  enthält ein perfektes Matching. Ferdinand(Georg(Frobenius( (1849(–(1917)( Philip&Hall& (1904.1982)& Satz: (Hall, Heiratssatz)  Ein bipartiter Graph G=(A⊎B, E) enthält ein  Matching M der Kardinalität |M|=|A| gdw  ∀ X⊆A : |X| ≤ |N(X)| Der Satz von Hall (Heiratssatz) Theorem: (Hall, 1935)  Ein bipartiter graph G=(A⊎B, E) enthält ein  Matching M der Kardinalität |M|=|A| gdw  ∀ A’⊆A : |A’| ≤ |N(A’)| Korollar: (Frobenius, 1917)  Für alle k gilt: jeder k-reguläre bipartite graph  enthält ein perfektes Matching. Philip&Hall& (1904.1982)& Ferdinand(Georg(Frobenius( (1849(–(1917)(Es gilt sogar: Graph ist Vereinigung von perfekten Matchings. Der Satz von Hall (Heiratssatz) Theorem: (Hall, 1935)  Ein bipartiter graph G=(A⊎B, E) enthält ein  Matching M der Kardinalität |M|=|A| gdw  ∀ A’⊆A : |A’| ≤ |N(A’)| Korollar: (Frobenius, 1917)  Für alle k gilt: jeder k-reguläre bipartite graph  enthält ein perfektes Matching. Philip&Hall& (1904.1982)& Ferdinand(Georg(Frobenius( (1849(–(1917)(Es gilt sogar: Graph ist Vereinigung von perfekten Matchings. Der Satz von Hall (Heiratssatz) Theorem: (Hall, 1935)  Ein bipartiter graph G=(A⊎B, E) enthält ein  Matching M der Kardinalität |M|=|A| gdw  ∀ A’⊆A : |A’| ≤ |N(A’)| Korollar: (Frobenius, 1917)  Für alle k gilt: jeder k-reguläre bipartite graph  enthält ein perfektes Matching. Philip&Hall& (1904.1982)& Ferdinand(Georg(Frobenius( (1849(–(1917)(Es gilt sogar: Graph ist Vereinigung von perfekten Matchings. Der Satz von Hall (Heiratssatz) Korollar: (Frobenius)  Für alle k gilt: jeder k-reguläre bipartite Graph  enthält ein perfektes Matching. Ferdinand(Georg(Frobenius( (1849(–(1917)( Philip&Hall& (1904.1982)& Satz: (Hall, Heiratssatz)  Ein bipartiter Graph G=(A⊎B, E) enthält ein  Matching M der Kardinalität |M|=|A| gdw  ∀ X⊆A : |X| ≤ |N(X)| Beachte: bipartit ist wichtig! Algorithmen für bipartite Graphen Satz: In 2k-regulären bipartiten Graphen kann man in Zeit O(|E|) ein perfektes Matching bestimmen. Man kann zeigen: Satz: In k-regulären bipartiten Graphen kann man in Zeit O(|E|) ein perfektes Matching bestimmen. Augmentierende Pfade: In bipartiten Graphen kann man in Zeit O( |V| |E| ) ein perfektes Matching bestimmen. Matching-Algorithmen für bipartite Graphen O(|V|1/2 ∙|E|) Hopcroft-Karp (ungewichtet) O(|E|1+o(1)) (mit polynominellen Gewichte): für allgemeine Graphen (mit polynominellen Gewichte) O(|V|1/2 ∙ |E|) Micali-Vazirani (ungewichtet) / Gabow-Tarjan O(|V|2.373) mit Matrix-Multiplikation - Mucha, Sankowski (ungewichtet) augmentierende Pfade Matching M Ein M-augmentierender Pfad P ist ein Pfad, der abwechselnd Kanten aus M und nicht aus M enthält und der in von M nicht überdeckten Knoten beginnt und endet. augmentierende Pfade Matching M Ein M-augmentierender Pfad P ist ein Pfad, der abwechselnd Kanten aus M und nicht aus M enthält und der in von M nicht überdeckten Knoten beginnt und endet. durch Tauschen entlang M können wir das Matching vergrössern: M’ := M ⊕ P Betrachte den Teilgraphen mit Kantenmenge M ⊕ M’. Beobachtungen: Jeder Knoten hat Grad ≤ 2. Kollektion von Pfaden und Kreisen. Jeder Pfad/Kreis wechselt ab zwischen Kanten aus M und M’. Falls |M| < |M’|, so gibt es mindestens einen Pfad mit Start- und Endkante in M’. augmentierende Pfade Seien M, M’ beliebige Matchings. Gedankenexperiment: M nicht-maximales Matching (schon bekannt) M’ maximales Matching (noch unbekannt) Dann besitzt M einen augmentierenden Pfad! augmentierende Pfade Algorithmus Input: Graph G = (V, E) Output: maximales Matching M Starte mit M = ∅. repeat Suche augmentierenden Pfad P. if kein solcher Pfad existiert then return M. else M := M ⊕ P. Satz (Berge, 1957): Jedes Matching, das nicht (kardinalitäts-) maximal ist, besitzt einen augmentierenden Pfad. Wie? Suchen/Finden eines augmentierenden Pfades: in bipartiten Graphen in Zeit O(|V|+|E|). Mit BFS, sehen wir gleich. in allgemeinen Graphen in Zeit O(|V|.|E|). Blossom-Algorithmus von Edmond, deutlich technischer, sehen wir nicht. augmentierende Pfade BFS für alternierende Pfade: Input: bipartiter Graph G = (A⊎B,E), Matching M Output: (kürzester) augmentierender Pfad, falls solche Pfade existieren L0 := {unüberdeckten Knoten aus A} Markiere Knoten aus L0 als besucht. for i = 1 to n if i ungerade then Li := {unbesuchte Nachbarn von Li-1 via Kanten in E \\ M} else (falls i gerade) Li := {unbesuchte Nachbarn von Li-1 via Kanten in M} Markiere Knoten aus Li als besucht. if ein Knoten v in Li ist nicht überdeckt then return Pfad zu v (backtracking)","libVersion":"0.3.2","langs":""}