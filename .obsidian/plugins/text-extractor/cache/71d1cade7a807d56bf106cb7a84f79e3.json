{"path":"sem4/FMFP/PV/exams/finals/FMFP-FS19.pdf","text":"Formal Methods and Functional Programming Exam, SS19 August 17, 2019, 9:00 – 12:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 34 pages; the back page of this booklet is page 34. After the exam begins, check that your exam papers are complete (4 assignments for the FP part, 4 assignments and 2 pages of background material for the FM part). 2. You may complete the assignments in any order. We recommend spending roughly half of your time on each of the two parts of the exam. 3. Only write on the exam paper and extra paper sheets which are given by the assistants. Do not take any of this paper out of the exam: submit it all. Write your ﬁrst and last name and your student number on every sheet of paper that you write on. 4. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 5. For the FP part of the exam, you may use any functions from the Haskell Prelude in your solutions (without giving their deﬁnitions), unless speciﬁed otherwise. You also may use any function from one subproblem to solve the subsequent subproblems, even if you have not provided a deﬁnition for the function itself. 6. Write clearly in the sense of logic, language, and readability. Label all rule applications in your derivation trees. The clarity of your arguments and explanations aﬀects your grade. 7. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 8 ∑ Max 10 10 10 10 6 14 10 10 80 Points Part I: Functional Programming Formal Methods and Functional Programming, Exam, SS19 3 Assignment 1: Typing (10 Points) Task 1.A (3 Points) Recall the following functions from the Haskell libraries. (+) :: Num a => a -> a -> a map :: (a -> b) -> [a] -> [b] fst :: (a, b) -> a Determine whether the following expressions are well-typed or not. If so, then state the most general type; otherwise justify informally why the expression is not typable. i) \\x y -> x y + y ii) \\x y -> x y + x iii) \\x -> map (\\y -> x fst y) [] Assignment 1 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 4 Task 1.B (7 Points) Recall the proof rules for the Mini-Haskell type system: Var . . . , x : τ, . . . ⊢ x :: τ Γ, x : σ ⊢ t :: τ Abs Γ ⊢ λx. t :: σ → τ Γ ⊢ t1 :: σ → τ Γ ⊢ t2 :: σ App Γ ⊢ t1 t2 :: τ Int Γ ⊢ n :: Int True Γ ⊢ True :: Bool False Γ ⊢ False :: Bool Γ ⊢ t :: Int iszero Γ ⊢ iszero t :: Bool Γ ⊢ t1 :: Int Γ ⊢ t2 :: Int BinOp Γ ⊢ (t1 op t2) :: Int for op ∈ {+, ∗} Γ ⊢ t0 :: Bool Γ ⊢ t1 :: τ Γ ⊢ t2 :: τ if Γ ⊢ if t0 then t1 else t2 :: τ Γ ⊢ t1 :: τ1 Γ ⊢ t2 :: τ2 Tuple Γ ⊢ (t1, t2) :: (τ1, τ2) Γ ⊢ t :: (τ1, τ2) fst Γ ⊢ fst t :: τ1 Γ ⊢ t :: (τ1, τ2) snd Γ ⊢ snd t :: τ2 Formally infer the most general type of the following expression using the Mini-Haskell typing rules. Label every proof step with the name of the used rule and list the arising constraints explicitly. ⊢ ( λy. λx. (fst y) (x (snd y)) ) ( (λx. x), iszero 42 ) :: . . . Formal Methods and Functional Programming, Exam, SS19 5 This page is intentionally left blank. Formal Methods and Functional Programming, Exam, SS19 6 This page is intentionally left blank. Formal Methods and Functional Programming, Exam, SS19 7 Assignment 2: Data Types and Proofs (10 Points) The following data type represents binary trees where leaves and internal nodes are labelled: data Tree a = Leaf a | Node a (Tree a) (Tree a) Task 2.A (3 Points) i) Give the type of the canonical fold function foldTree on Tree a. ii) Deﬁne the canonical fold function foldTree on Tree a. iii) Deﬁne the map function mapTree :: (a -> b) -> Tree a -> Tree b using foldTree. Do not use recursion in the deﬁnition of mapTree. Assignment 2 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 8 Task 2.B (7 Points) Consider the following Haskell declarations. mapT :: (a -> b) -> Tree a -> Tree b mapT f (Leaf x) = Leaf (f x) --mapT.1 mapT f (Node x t1 t2) = Node (f x) (mapT f t1) (mapT f t2) --mapT.2 sumT :: Tree Int -> Int sumT (Leaf x) = x --sumT.1 sumT (Node x t1 t2) = x + sumT t1 + sumT t2 --sumT.2 msumT :: (a -> Int) -> Tree a -> Int -> Int msumT f (Leaf x) z = f x + z --msumT.1 msumT f (Node x t1 t2) z = msumT f t1 (msumT f t2 (f x + z)) --msumT.2 Given a ﬁxed function f :: a -> Int, prove that for all ﬁnite trees t :: Tree a the equality msumT f t 0 = sumT (mapT f t) holds. Structure your proof clearly and justify every proof step. Formal Methods and Functional Programming, Exam, SS19 9 This page is intentionally left blank. Formal Methods and Functional Programming, Exam, SS19 10 This page is intentionally left blank. Formal Methods and Functional Programming, Exam, SS19 11 Assignment 3: Programming with Lists (10 Points) Task 3.A (4 Points) An association list of type [(k,v)] represents a mapping from keys to values. It consists of pairs (a,b), where a :: k is a key and b :: v is its value. We consider association lists that may assign multiple values to each key, that is, they may contain multiple pairs with the same key. i) Deﬁne a function select :: Eq k => k -> [(k,v)] -> [v] that returns all values associated with the given key, in the same order as they occur in the association list. If the key does not occur in the list, the function should return the empty list. ii) Deﬁne a function keys :: Eq k => [(k,v)] -> [k] that returns all keys in the association list. The result should contain every key only once. Assignment 3 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 12 Task 3.B (3 Points) Deﬁne a function merge :: [[a]] -> [a] that combines a ﬁnite list of (potentially inﬁnite) lists into a single list. Each element from each input list must appear in a ﬁnite preﬁx of the output list. One possible output of the function merge is illustrated in the following example: merge [[1,7,13,. . .],[0,6,12,. . .],[2,8,14,. . .]] = [1,0,2,7,6,8,13,12,14,. . .] Assignment 3 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 13 Task 3.C (3 Points) A time series is a sequence of values, which we represent as a list of type [Int]. Your task is to write a function slidingMax :: [Int] -> [Int] that computes a sliding maximum of a time series: For every position in the time series, the corresponding result is the maximum of the three values to the left of and including the position. (For the ﬁrst and second position, we consider only the ﬁrst and the ﬁrst two values, respectively.) An example is slidingMax [-1,2,3,1,0,0,0,5,0] = [-1,2,3,3,3,1,0,5,5] Hint: You may ﬁnd the function maximum :: Ord a => [a] -> a from the Prelude useful. Formal Methods and Functional Programming, Exam, SS19 14 This page is intentionally left blank. Formal Methods and Functional Programming, Exam, SS19 15 Assignment 4: A Simple Language (10 Points) In this assignment you will develop an interpreter and a parser for the simple language BF. Task 4.A (3 Points) The memory of a BF program consists of a single tape that extends to inﬁnity in both directions: · · · · · · left half right halfhead Each cell of the tape stores an integer of type Int. Initially, all cells are zero. The tape is equipped with a head pointing to the current cell. Only the current cell may be modiﬁed. The head can be moved left and right along the tape. We represent a tape by the following data type: data Tape = Tape [Int] Int [Int]. The two lists store the left and the right half of the tape adjacent to the current cell, respectively, as shown in the ﬁgure above. Your task is to deﬁne i) emptyTape :: Tape, the initial tape where all cells are zero; ii) updateTape :: (Int -> Int) -> Tape -> Tape, which applies the given function to the current cell ; and iii) moveLeft :: Tape -> Tape, which moves the head one step to the left. Assignment 4 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 16 Task 4.B (4 Points) BF’s syntax is described by the BNF grammar op ::= + | - | < | > | . | [ program ] program ::= ε | op program ε denotes the empty program. The operators + and - increment and decrement the current cell, respectively. The operators < and > move the head by one step to the left and to the right. The operator . (period) appends the value of the current cell to the program’s output, which is a list of integers. The construct [ p ] is a loop: while the value of the current cell is not zero, repeat p. We use the following types to represent BF programs, reﬂecting the grammar: data Op = Inc | Dec | GoLeft | GoRight | Out | Loop Program type Program = [Op] Deﬁne a function run :: Program -> [Int] that interprets a terminating BF program and returns its output. Note: You may use the functions moveRight :: Tape -> Tape, which moves the head one step to the right, and current :: Tape -> Int, which returns the integer in the current cell, in addition to the functions from the ﬁrst task. Assignment 4 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 17 Assignment 4 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 18 Task 4.C (3 Points) Deﬁne a function parse :: String -> Program that parses a well-formed BF program according to the grammar from the previous task. Note: You do not need parser combinators in this task. You may use the following function: simpleOp :: Char -> Op simpleOp ’+’ = Inc simpleOp ’-’ = Dec simpleOp ’<’ = GoLeft simpleOp ’>’ = GoRight simpleOp ’.’ = Out simpleOp _ = error \"not a simple operator\" Formal Methods and Functional Programming, Exam, SS19 19 This page is intentionally left blank. Part II: Formal Methods Formal Methods and Functional Programming, Exam, SS19 21 Assignment 5: Small-Step Execution (6 Points) Consider the statement s ≡ if x > y then r := 1 else r := −1 end; r := r ∗ (x − y) and a state σ with σ(x) = 3 and σ(y) = 5. Prove the following statement: ∃ σ′. ⟨s, σ⟩ → ∗ 1 σ′ ∧ σ′(r) = 2 Justify every step of the derivation sequence with a corresponding derivation tree. Formal Methods and Functional Programming, Exam, SS19 22 This page is intentionally left blank. Formal Methods and Functional Programming, Exam, SS19 23 Assignment 6: Angelic Choice (14 Points) Consider extending IMP with the statements guess x and assert b, where x is a variable and b is a boolean expression. The statement guess x implements an angelic choice, that is, non-deterministically assigns a value to x such that the rest of the program terminates successfully, if possible. The statement assert b checks whether the condition b holds and fails if it does not. The axiomatic semantics of these two new statements are given by the following derivation rules: (GuessAx) { ∃n. P[x ↦→ n] } guess x { P } (AssertAx) { b ∧ P } assert b { P } where, in the ﬁrst rule, n ranges over numerals and does not occur in P. Task 6.A (4 Points) The statements x := e and guess x; assert x = e are provably equivalent for all variables x and expressions e that satisfy x /∈ FV(e). Show that the condition x /∈ FV(e) is necessary by appropriately choosing a variable x, an expression e, and some predicates P and Q such that the Hoare triple { P } x := e { Q } is valid but the Hoare triple { P } guess x; assert x = e { Q } is not. It is suﬃcient to informally justify your answer; a formal proof is not required. Assignment 6 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 24 Task 6.B (10 Points) Prove that for all variables x and all expressions e with x /∈ FV(e) the statement ∀ P, Q. ⊢ { P } x := e { Q } ⇒ ⊢ { P } guess x; assert x = e { Q } holds. Note that this proves one direction of the aforementioned equivalence. You may use the following lemma without proof. Lemma 1. ∀ x, e, e′. x /∈ FV(e) ⇒ e[x ↦→ e ′] ≡ e. Formal Methods and Functional Programming, Exam, SS19 25 This page is intentionally left blank. Formal Methods and Functional Programming, Exam, SS19 26 This page is intentionally left blank. Formal Methods and Functional Programming, Exam, SS19 27 Assignment 7: Hoare Logic (10 Points) Consider the statement s ≡ while x < y do t := x; x := y; y := t end. Construct a proof outline that proves the Hoare triple { x = X ∧ y = Y } s { ⇓ x = max(X, Y ) }. Clearly state which loop invariant and loop variant you are using in your proof outline. Invariant: Variant: Proof Outline: Formal Methods and Functional Programming, Exam, SS19 28 This page is intentionally left blank. Formal Methods and Functional Programming, Exam, SS19 29 Assignment 8: Linear Temporal Logic (10 Points) Consider the transition system depicted below, which models an air conditioning system that is supposed to keep the temperature inside a building close to a speciﬁc target value. The labels on each state indicate which of the four atomic propositions a (above target temperature), b (below target temperature), c (cooling), h (heating) are true in the corresponding state. The system initially is in a neutral state s0. It is equipped with a temperature sensor and depending on whether the measured temperature is too high or too low, it moves to state s1 or state s3, respectively. If, after a short while, the temperature does not return to the desired value, the system moves to a cooling state s2 or heating state s4, respectively, until the target temperature is reached. s0 {} s1 {a} s2 {a, c} s3 {b} s4 {b, h} Task 8.A (2 Points) Write down an LTL formula for each of the following properties. i) It is never too hot and too cold at the same time. ii) At any point in time it will eventually be too hot or too cold. iii) It is guaranteed that the air conditioning system will be heating at some point in time. Assignment 8 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 30 Task 8.B (4 Points) For each of the following LTL formulas, state whether or not the formula deﬁnes a property that is valid in the given transition system. Justify your answer by either brieﬂy explaining why it is valid or providing a counter-example if it is not. i) ⃝(a ∨ b) ii) □(b ⇒ ♦h) iii) □(a ⇒ ⃝(a ⇒ c)) Assignment 8 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 31 Task 8.C (2 Points) Does the formula □(c ⇒ a) describe a safety property, a liveness property, neither, or both? Justify your answer. Assignment 8 continues on the next page. Formal Methods and Functional Programming, Exam, SS19 32 Task 8.D (2 Points) Is there an LTL formula ϕ such that the formulas ϕ and ¬ϕ are both not valid in the given transition system? Justify your answer by either giving such a formula or brieﬂy explaining why it cannot exist. Formal Methods and Functional Programming, Exam, SS19 33 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ::= skip | x := e | s;s | if b then s else s end | while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). Big-Step Semantics (SkipN S) ⟨skip, σ⟩ → σ (AssN S) ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ → σ′ ⟨s2, σ′⟩ → σ′′ (SeqN S) ⟨s1;s2, σ⟩ → σ′′ ⟨s1, σ⟩ → σ′ (IfTN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = tt ⟨s2, σ⟩ → σ′ (IfFN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = ﬀ ⟨s, σ⟩ → σ′ ⟨while b do s end, σ′⟩ → σ′′ (WhTN S) ⟨while b do s end, σ⟩ → σ′′ if B[[b]]σ = tt (WhFN S) ⟨while b do s end, σ⟩ → σ if B[[b]]σ = ﬀ Formal Methods and Functional Programming, Exam, SS19 34 Small-Step Semantics (SkipSOS) ⟨skip, σ⟩ →1 σ (AssSOS) ⟨x := e, σ⟩ →1 σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ →1 σ′ (Seq1SOS) ⟨s1;s2, σ⟩ →1 ⟨s2, σ′⟩ ⟨s1, σ⟩ →1 ⟨s′ 1, σ′⟩ (Seq2SOS) ⟨s1;s2, σ⟩ →1 ⟨s′ 1;s2, σ′⟩ (IfTSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s1, σ⟩ if B[[b]]σ = tt (IfFSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s2, σ⟩ if B[[b]]σ = ﬀ (WhileSOS) ⟨while b do s end, σ⟩ →1 ⟨if b then s; while b do s end else skip end, σ⟩ Axiomatic Semantics (Partial Correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ↦→ e] } x := e { P } { P } s1 { R } { R } s2 { Q } (SeqAx) { P } s1;s2 { Q } { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P′ } s { Q′ } (ConsAx) { P } s { Q } if P ⊨ P′ and Q′ ⊨ Q Axiomatic Semantics (Total Correctness) Rules are as for partial correctness above, except for the following rule, which replaces WhAx: { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ⊨ 0 ≤ e where Z is a fresh logical variable (not used in P).","libVersion":"0.5.0","langs":""}