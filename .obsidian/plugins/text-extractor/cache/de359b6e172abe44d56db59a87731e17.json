{"path":"sem5/VLSI1/VRL/extra/Top-Down-Digital-VLSI-Design/Chapter-6---The-Case-For-Synchronous-Design_2015_Top-Down-Digital-VLSI-Desig.pdf","text":"CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN 6.1 INTRODUCTION Experience tells us that many malfunctioning digital circuits and systems suffer from timing problems. Symptoms include • Bogus output data, • Erratic operation, typically combined with a • Pronounced sensitivity to all sorts of variabilities such as PTV and OCV. Erratic operation often indicates the circuit operates at the borderline of a timing violation. Searching for the underlying causes not only is a nightmare to engineers but also causes delays in delivery and undermines the manufacturer’s credibility.1 Observation 6.1. To warrant correct and strictly deterministic circuit operation, it is absolutely essential that all signals have settled to a valid state before they are being admitted into a storage element (such as a flip-flop, latch or RAM). This truism implies that all combinational operations and all propagation phenomena involved in computing and transporting some data item must have come to an end before that data item is being locked in a memory element. Data that are free to change their value at any time are dangerous because they may give rise to bogus results and/or may violate timing requirements imposed by the electronic components involved.2 Hence the need for regulating all state changes and data storage operations. Many schemes for doing so have been devised over the years, see fig.6.1. From a conceptual perspective, we must distinguish between two diametrically opposed alternatives, namely synchronous clocking and self-timed operation. A third category that includes all unstructured ad hoc clocking styles — occasionally referred to as “clock-as-clock-can” in this text — is not practical except for the smallest subcircuits perhaps. 1 Malfunctioning that occurs intermittently or that depends on minor variations of temperature, voltage, signal waveforms, and similar circumstances make debugging extremely painful. The fact that one can never be sure whether simulation accuracy suffices to predict transient waveforms, a subcircuit’s reactions to a marginal triggering condition, and other details with sufficient precision does not help either. 2 Timing requirements are meant to include set-up and hold conditions, minimum clock high and low times, and maximum clock rise and fall times. All these quantities are explained in section A.6. Top-Down Digital VLSI Design © 2015 Elsevier Inc. All rights reserved. 357 358 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN The present chapter first introduces and compares these approaches before commenting on why synchronous clocking is considered to be the best choice for staying clear of timing problems in the context of digital VLSI. Several general design rules are explained. Further details such as what bistables to use, how to clock them, and how to distribute the clock signal(s) over a circuit — or a clock domain — will be the subject of chapter 7. 6.2 THE GRAND ALTERNATIVES FOR REGULATING STATE CHANGES 3596.2THEGRANDALTERNATIVESFORREGULATINGSTATECHANGESIBM LSSDDEC Alphatime-borrowingsupportsunsymmetricclocking disciplineall state changestriggered by periodicglobal clock signal(s)synchronoussymmetricunsymmetricsingle-wiretwo-wiresymmetriclevel-sensitive(latches only)bistablesone-phasetwo-phasemulti-phasemixed (latches & flip-flops)clock netedge-triggered(flip-flops only)one-phasetwo-phasemulti-phasesingleedgedualedgearbitraryedge 1998, 2012 H. Kaeslin ETHZoccur aperiodicallyas regulated by local startand completion eventsstate changessignaling schemeasynchronousclock-as-clock-canself-timedbundled data(data & control pair)dual-railencodingfine grainad hoc, no consistentscheme for initiatingstate changescoarse grainmid grainunderlyingdelay assumptionsbounded delayall delays known and bounded,by a slow path delay modelcompletion detection fakeddelay-insensitiveon wire and gate delays,no assumptions made true completion detectionspeed-independentwire delays negligible,gate delays unbounded,true completion detectionquasi-delay-insensitiveto have similar wire delays,all branches of a fork assumedtrue completion detectionmicropipelinesby Ivan SutherlandLutoniumby Alain Martin et al.by Theseus Logicnull convention logicsingle-rail handshakeby Handshake Solutions(Ad Peeters)globally asynchronouslocally synchronousGALSby IIS@ETHsafe but inefficient!!!!SETFFsusesDETFFsusesstandardpracticeDDR!synchronous frameGSLAby Achronixislandslarge synchronousglobally synchronouslocally asynchronousbetween islandsself-timed data transfersself-timed pipelinesin coremid grain3333333mixFIGURE6.1Familytreeofclockingdisciplines(simpliﬁed).TickedarethoseoptionsthatthisauthorconsiderssafeandviableinthecontextofVLSIprovidedtheyareimplementedcorrectly. 360 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN 6.2.1 SYNCHRONOUS CLOCKING Deﬁnition 1. A circuit or subcircuit is said to operate synchronously iff all data storage operations and, hence, all state transitions, are restricted to occur periodically at precise moments of time that are determined by a special signal referred to as the clock. A single clock that drives a set of flip-flops is the most straightforward pattern, but the above definition is meant to include circuits where bistables are being driven by a pair of complementary clock signals, e.g. Clk and Clk. The same also applies to multi-phase clocks and even to multiple clocks of distinct frequencies provided those subclocks are all locked to one primary clock signal. State changes are effectively restricted to occur synchronously to the primary clock as long as all driving clocks maintain fixed frequency and phase relationships.3 Deﬁnition 2. A clock domain or, which is the same, a synchronous island is a (sub)circuit where all clock signals maintain fixed frequency and phase relationships because they are derived from a common source. A clock domain may be confined to one subblock on a chip or may extend over several chips or even printed circuit boards. Any line that separates two distinct clock domains is referred to as a clock boundary. As stated before, most designs do with a single clock signal per domain, but there are exceptions to this rule. 6.2.2 ASYNCHRONOUS CLOCKING Deﬁnition 3. A circuit or subcircuit works asynchronously when some or all of the memory elements therein are permitted to change their states independently from a global reference. Asynchronous circuits are easily identified by the presence of • Unclocked bistables (SR-seesaw, Muller-C, MUTEX, etc.), • Zero-latency feedback loops, e.g. as part of • Asynchronous state machines (ASM), • Logic gates other than buffers and inverters in clock nets,4 • Gated asynchronous (re)set signals, • Logically redundant circuitry for hazard suppression, • Imposed delays, ring oscillators, • One-shots, pulse shapers and similar subcircuits. Examples of such constructs that never appear in synchronous designs are given in fig. 6.2band discussed in more detail in section 6.4.3. A multitude of clock signals, clock domains, and clock boundaries is another indication of asynchronous circuit operation. 3 This is the case when some primary clock is being subdivided by way of some counter circuitry in order to derive one or more slower clocks. The converse, that is clock frequency multiplication with the aid of a phase locked loop (PLL), also results in multiple signals with fixed frequency and phase relationships. 4 Gated clocks are an exception, please refer to section 7.5 for advice. 6.2 THE GRAND ALTERNATIVES FOR REGULATING STATE CHANGES 361 6.2.3 SELF-TIMED CLOCKING A more recent addition to the category of asynchronous circuits relies on self-timing throughout. The output of a traditional logic circuit is valid only at certain moments of time, and it is impossible to tell from the output alone when that is the case. While a transiting voltage implies data are invalid, the inverse does not necessarily mean they have settled to a steady state. Rather, the window of validity (data-valid window) must be found by referring to a time scale, and the continuum of time gets structured by a periodic global clock. Self-timing, in contrast, introduces a signaling mechanism that conveys when data are valid and when not. This either requires the addition of flow control signals as shown in fig.6.2c or dual-rail encoding in combination with special data patterns reserved for the purpose. The guiding principle is that no storage register is allowed to accept any new data from its predecessor before its successor has safely acquired the data item presently stored in the register.5 5 Whether data items are subject to combinational operations while travelling from one register to the next or not, is immaterial. 362 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN clock tree reset tree datapath reset mess datapath clock mess datapath reset tree flow control full handshake Rst_R Clk_C Rst_R Clk_C Rst_R Ack_S Req_S control (ASM) control (ASM) control (ASM) (a) (b) (c) FIGURE 6.2 Toy examples intended to give a ﬂavor of the three grand alternatives for clocking. Synchronous clocking (a), clock-as-clock-can (b), and self-timed clocking (c). 6.2 THE GRAND ALTERNATIVES FOR REGULATING STATE CHANGES 363 Deﬁnition 4. An asynchronous circuit or subcircuit is said to operate in a self-timed manner when all state transitions get regulated by local start and completion events on a per case basis. As opposed to synchronous clocking, there is no global signal that would trigger operations which explains why this scheme is also known as “clockless logic”. Instead, the various building blocks in the circuit coordinate their activities by way of handshake protocols which necessitates an on-going mutual exchange of status information. There is no way for an external observer to tell when a given computational step or data transfer is to happen because everything occurs in an entirely data-driven and, therefore, aperiodic way. The operation of a self-timed circuit proceeds at its own speed and automatically adjusts to PTV conditions. Self-timed schemes come in numerous varieties [155] [156] [157] [158] that essentially differ in how status information are actually being conveyed and in the assumptions on circuit delays that underlie protocol and circuit design, see fig.6.1. 364 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN 6.3 WHY A RIGOROUS APPROACH TO CLOCKING IS ESSENTIAL IN VLSI The propagation of new data values through a digital network gives rise to transient phenomena within the network itself and at the output. Let us briefly review the impact of spurious events on the functioning of digital circuits to prepare the ground for a subsequent discussion of clocking schemes and circuit design styles. 6.3.1 THE PERILS OF HAZARDS Hazard and glitch are two names for unwanted transients on binary signals. How they originate is examined in appendix A.5, key findings are as follows: • Be prepared to observe glitching at the output of any combinational circuit with the sole exception of fanout trees. This is because hazards can originate (a) if two or more inputs change at a time — or almost so —, or (b) if the combinational logic includes reconvergent fanout paths. • Glitches are difficult to predict as their manifestation — in terms of waveform, amplitude and duration — depends on many low-level details unknown at synthesis time including placement, wiring, detailed layout, gate and interconnect delays, crosstalk, PTV conditions, and on-chip variations (OCV). A minute departure may decide on whether a hazard manifests itself as a rail-to-rail excursion, becomes visible as a runt pulse, or results in no tangible appearance at all. It is prudent to assume that any combinational network gives rise to hazards unless one has proof to the contrary. To determine whether a network actually develops glitches or not requires a detailed analysis of its transistor-level circuitry, timing parameters, layout parasitics, input waveforms, and the like. Manual elimination of hazards is a painful and unprofitable exercise as only small networks are amenable to analysis. Imposing narrow delay bounds on signal propagation paths is not compatible with automated synthesis and place-and-route (P&R) of VLSI circuits where interconnect delays often dominate over gate delays. We conclude: Observation 6.2. All clocks, all asynchronous reset and presets, all write lines of asynchronous RAMs plus any other signal that might trigger a state transition in a memorizing subcircuit must be kept free of hazards under all circumstances.6 There is an abundance of catastrophic failures that could result if this rule were violated: • Unwanted state transitions in any kind of finite state machine. • Multiple registration of a single event by a counter. • Erroneous activation of an edge-triggered interrupt request line of a microprocessor. • Unplanned for return of a sequential (sub)circuit to its start state. • Storage of bogus data in a register or a RAM. 6 Be warned that state-change-triggering inputs are not always identified as such in the documentation of commercially available components or library elements. They sometimes hide under inconspicuous names such as “chip enable” (CEB), “write enable” (WEB), “interrupt request” (IRQ) and “strobe”, just to name a few. 6.3 WHY A RIGOROUS APPROACH TO CLOCKING IS ESSENTIAL IN VLSI 365 • Data losses or duplications during data transfer operations. • Deadlocks in asynchronous communication protocols (such as handshaking). • Marginal triggering and, hence, metastable behavior of bistables.7 Data, address, status, control, and other signals not capable of sparking off a state change without the intervention of a clock are not concerned. Similarly, combinational subcircuits are not normally sensi- tive to hazards because all transient effects are reversible and eventually die out.8 Glitches also cause no problem when driving sluggish peripheral equipment such as indicator lamps, electromechanical relays, teletypes and the like. 6.3.2 THE PROS AND CONS OF SYNCHRONOUS CLOCKING There are ten essential benefits that are shared by all synchronous clocking disciplines. + Hazards do not compromise functionality. Clock and asynchronous reset are the only two signals that must be kept free of hazards under all circumstances. Doing so is easy, strictly limiting distribution networks to fanout trees suffices. + As no timing violations ever occur within a properly designed synchronous circuit, there is no chance for inconsistent data, marginal triggering, and metastability to develop. + Immunity to noise and coupling effects is maximum because all nodes are allowed to settle before any storage operations and state changes occur. + All timing constraints are one-sided. For a circuit to function correctly, any timing quantity is either bounded from above (such as the longest propagation delay, for instance) or from below (such as the contamination delays). Two-sided constraints do not exist.9 + Together, the above four properties warrant deterministic behavior of circuits independently from low-level details.10 Synchronous designs do not rely on delay tuning in any way. What matters for functional correctness are the data operations at the RTL level exclusively. This argument cannot be overestimated in view of • Automatic placement, routing, and physical design verification, • Automatic HDL synthesis, logic optimization, clock tree generation, and rebuffering, 7 The term “metastability” refers to an unpredictable behavior of a memory element that may or may not result from violating its timing conditions, see chapter 8 for details. 8 There are few exceptions, however, where hazards are unacceptable in spite of the memoryless nature of the subsystems involved. These include: • Digital modulators and other circuits where signals are required to follow a well-defined waveform or spectrum. • Output enable signals where hazards could occasion transient drive conflicts thereby leading to exaggerated crossover currents, needless power dissipation, and excessive ground bounce. • Electronically controlled power drives and power converters where unforeseen current spikes are likely to cause permanent damage. 9 With the exception of one-phase level-sensitive operation which is considered impractical, see section 7.2.7. 10 This is to say that buffer sizing, library changes, parameter variations (PTV and OCV), physical arrangement, layout parasitics, etc. are likely to impact maximum clock rate, I/O timing, power dissipation, and other quantitative figures of merit, but not a circuit’s functionality. 366 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN • Automatic insertion of test structures, • Reusing a HDL model or a netlist in multiple designs, and of • Retargeting a design from one cell library and/or fabrication process to another (e.g. from FPL to a mask-programmed IC, or vice versa). + Synchronous operation makes it possible to separate functional verification from timing analysis and to take advantage of automata theory and related concepts. + There is no need for any redundant circuitry to suppress hazards, a task not supported by standard synthesis tools. + The compute operations that are to be carried out in each clock cycle can be stated and collected at compile time, thereby opening a door for cycle-based simulation techniques that are more efficient when circuits grow large. Asynchronous circuits, in contrast, are entirely dependent on event-driven simulation. + Established methods for circuit testing (such as fault grading, test vector generation, and the insertion of test structures) start from the assumption of synchronous operation. What’s more, almost all test equipment is designed accordingly. + Synchronous clocking makes it possible to slow down and even to suspend circuit operation in any state and for an arbitrary lapse of time,11 which greatly facilitates the tracing of state transitions, data transfers, protocol sequences, and computation flow when debugging a malfunctioning circuit. The capability to operate synchronous circuits in speed-limited environments is often welcome for prototyping purposes. Undeniably, synchronous circuit operation also has its drawbacks. − Performance is determined by the worst rather than by the average delay over all data.12 − Circuits may consume more power than necessary as a register dissipates energy in each clock cycle regardless of the extent of state change. Yet, clock gating and other techniques have been developed specifically to lower clock-induced power dissipation while maintaining overall synchronous circuit operation. − Synchronous operation causes periodic surges in supply currents. This not only strains the power and ground nets but also entails electromagnetic radiation at the clock frequency and at higher harmonics. − Synchronization problems are unavoidable at the interface between any two clock domains.13 However, similar problems arise wherever an asynchronous subsystem interfaces with a clock-driven environment such as a sampled data source or data sink. 11 Unless capacitive data storage is involved such as in DRAMs or in dynamic CMOS logic. 12 A workaround is to be presented in footnote 18. 13 This is the subject of chapter 8. 6.3 WHY A RIGOROUS APPROACH TO CLOCKING IS ESSENTIAL IN VLSI 367 − Most synchronous clocking disciplines insist on tightly controlled delays within the clock distribution network. Special software tools that address this need during physical design make part of all major VLSI CAD suites. 6.3.3 CLOCK-AS-CLOCK-CAN IS NOT AN OPTION IN VLSI Unsafe circuits often emanate from obsolete or perfunctory design methodologies. This is particularly true for asynchronous circuits, the design of which is very demanding, both in terms of profound understanding and engineering effort. Sporadic timing violations and a pronounced sensitivity to delay variations are typical consequences. Although popular with digital pioneers, ad-hoc clocking schemes have become unacceptable because VLSI technology has changed the picture in the following way. − The operation of most asynchronous circuits critically depends on certain delay figures and, therefore, also on their layout arrangements. This makes it difficult to anticipate whether fabricated circuits will indeed behave as simulated as no simulation model is capable of rendering all effects that contribute to timing variations with perfect precision. − Finding and correcting timing problems is difficult enough on a board in spite of the fact that designers have access to almost all circuit nodes and can add extra components for tuning delays. It is next to impossible on a monolithic chip that offers no such possibilities. − Historically, emphasis was on doing with as few SSI/MSI packages as possible. The prime challenge today is first-time-right design, a few more logic gates do not normally matter. − Early logic MOS and TTL devices were so slow that wiring-induced delays could be neglected altogether. As opposed to this, interconnect delays due to wiring parasitics tend to dominate over gate delays in VLSI, making it impossible to predict delays from circuit diagrams and netlists. − VLSI designers cannot afford delay tuning of a vast collection of signals. For the sake of productivity, they must rely on design automation as much as possible for logic synthesis, optimization, placement, routing and verification. The higher productivity so obtained is at the expense of control over most implementation details. In conclusion, an industrial circuit designer concerned with design productivity, first-time-right design, and fabrication yield is well advised to follow the recommendations below. Observation 6.3. Ad-hoc approaches to clocking are just unfortunate leftovers from the early days of digital design that are incompatible with the requirements of VLSI. Instead, strive to do with as few clock domains as possible and strictly adhere to one synchronous clocking discipline within each such domain. Let us bring this matter to an end with two quotes from experts “Just say NO to asynchronous design!” [159] “KISS those asynchronous-logic problems good-bye, Keep It Strictly Synchronous!”14 [160] 14 K.I.S.S. originally was a slogan to improve the success rate of complex operations “Keep It Simple, Stupid”. 368 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN 6.3.4 FULLY SELF-TIMED CLOCKING IS NOT NORMALLY AN OPTION EITHER As opposed to unsophisticated asynchronous clocking schemes, self-timed clocking follows a strict discipline, holds the promise of achieving better performance, and provides valuable hooks for improving on energy efficiency [161]. When compared to synchronous clocking schemes, the notorious difficulty of domain-wide clock distribution is replaced by a multitude of local synchronization or arbitration problems which in turn asks for a specific design methodology. In spite of its theoretical benefits, − The hardware and energy overheads associated with implementing handshaking or related request-acknowledge protocols all the way down to the level of logic gates, − The difficulties of interfacing with clock-driven peripheries and test equipment, − The absence of self-timed components in commercial cell libraries,15 − The shortage of adequate EDA support, − The excruciating subtleties of the design process, and − The lack of widespread know-how, together with − The ensuing time to market penalty have prevented self-timed logic from becoming a practical alternative.16 6.3.5 HYBRID APPROACHES TO SYSTEM CLOCKING Current efforts are attempting to combine the best of both worlds into globally asynchronous locally synchronous (GALS) circuits where synchronous islands communicate via self-timed data exchange protocols. The usage of arbiters and pausable clocks is typical for GALS circuits. Such heterochronous architectures are being investigated as an alternative to overly large synchronous systems in search of improved energy efficiency, better performance, more manageable clock distribution, and facilitated design reuse [163] [164] [165] [166]. A different strategy termed mesochronous clocking is to distribute a global clock signal without much concern for skew. Specially designed local synchronizer circuits are then being used to sample data at multiple points in time, to detect synchronization failures, and to retain valid data only [167]. A related idea is to insert tunable delay lines within the clock distribution network and to calibrate them automatically at startup time such as to make all blocks work synchronously together [168]. For the time being, most of this must be considered research, however, as industry is reluctant to embrace unproven concepts and design flows [169]. 15 Such as the Muller-C and the mutual exclusion elements (MUTEX) explained in appendix A.4. Dual-rail encoding further necessitates special circuits for logic gates and bistables not found in regular cell libraries. 16 Industrial interest is documented by start-ups such as Theseus Logic Inc. and Handshake Solutions. The former has patented NULL Convention Logic (NCL) which, however, is penalized by an important overhead factor of 2 to 2.5 over traditional synchronous logic [162]. 6.3 WHY A RIGOROUS APPROACH TO CLOCKING IS ESSENTIAL IN VLSI 369 Table 6.1 The grand alternatives for clocking compared. Clocking discipline asynchronous synchronous Desirable characteristics ad hoc self-timed Fundamentals Immune to hazards no yes except for yes except for protocol signals clock and reset No need for hazard-suppression logic no yes yes One-sided timing constraints only no yes yes No marginal triggering maybe, yes yes within during circuit operation maybe not synchr. island Avoids timing problems at interfaces no no no Design process No particular library cells needed yes no yes Does without tightly controlled delays no yes except for yes except in logic and interconnect local subcircuits for clocka Circuit to function irrespective no yes yes of logic and layout details Functionality and timing separable no mostly yes yes Systematic and modular design no yes yes methodology, reuse facilitated Matches with prevalent ﬂows and tools no no yes Arbitrarily slow operation supported no no yesb for debugging purposes (step-by-step) Periodicity of circuit operation All signals to settle before clocking no no yes Non-periodic “random” supply current more or less yes no Supports cycle-based simulation no no yes Works with existing test equipment no no yes Figures of merit of ﬁnal circuit Good area efficiency sometimes yes, only if overhead yes more often no remains modest Better than worst-case performance more or less yes no Good performance in practice in particular debatable yes applications Good energy efficiency in particular yes if overhead yes if designed applications remains modest accordingly a Skew-tolerant schemes are available, see section 7.2. bUnless DRAMs or dynamic CMOS logic is being used. 370 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN 6.4 THE DOS AND DONTS OF SYNCHRONOUS CIRCUIT DESIGN Synchronous operation essentially rests on two guiding principles to be presented next. 6.4.1 FIRST GUIDING PRINCIPLE: DISSOCIATE SIGNAL CLASSES! While digital VLSI designers must devise circuits that function in a predictable and dependable way, they cannot afford to study the transient behavior of every single circuit node in detail. What is needed is a robust and well-understood clocking discipline that, when properly implemented, warrants correct circuit timing under all operating conditions. From the background of our findings on transients in digital circuits in section 6.3, there is a fairly obvious solution. Rather than attempting to suppress hazards here and there — which is symptomatic for clock-as-clock-can design — the set of acceptable circuit structures is voluntarily and consistently restricted to those that • do not let hazards originate in clock and in asynchronous (re)set nets, and that • tolerate hazards on all other signals with no impact on functionality whatsoever. The most efficient way to prevent dangerous hazards from coming into existence is to shut out all signals that might possibly prompt a state change from participating in logic operations. Table 6.2 begins by distinguishing between hazard-sensitive and hazard-tolerant signals before classifying signals further as a function of their respective roles in a circuit. Reset signals cause a sequential circuit to fall into some predetermined start state without the intervention of a clock. Their effect is immediate, unconditional and always the same. Practically speaking, this includes all asynchronous reset and set inputs present on many bistables, but none of the synchronous initialization signals. Clock signals are in charge of sparking off all regular transitions of a sequential circuit from one state to the next, but have no influence on what that next state will be. Information signals is a collective term for all those signals that contribute to deciding what state a circuit is to assume in response to an active clock edge and/or what output that circuit shall produce. We further distinguish between functional signals and test signals with the first subclass largely outnumbering the second. Functional signals comprise data, address, control and status signals, which together implement the desired functionality. Test signals get added on top during the design process to improve circuit testability. From this perspective, synchronous clear and load inputs are nothing else than particular control signals. We now stipulate Observation 6.4. Synchronous circuits boast a clear-cut separation into signals that decide on when state transitions and output changes are to take place, and into others that determine what data values to output and what state transitions to carry out, if any. As a consequence, (asynchronous) reset signals, clock signals, and information signals never mix. Combinational operations (other than unary negation) are strictly confined to information signals. 6.4 THE DOS AND DONTS OF SYNCHRONOUS CIRCUIT DESIGN 371 Table 6.2 Taxonomy of signals within a synchronous island. The bottom part suggests a naming convention for signals in HDL models, schematics and netlists detailed further in section 6.7. Elec tri cal s i gna ls Class Reset signal Clock signal(s) Information signals determines when to when to move what state to enter next (re)enter the from one state and/or start state to the next what output to produce Hazards inadmissible inadmissible harmless Role during general model general model evaluated at model activation time, simulation wake up wake up no wake up of memorizing models Subclass — — Functional signals Test signals implement improve ob- serves to the desired servability and functionality controllability Members Asynchronous Clock(s) Status, Data, Block isolation, (re)set control address scan path(s) Switching is Examples and their identiﬁcation by way of naming and color code synchronous Clk many many Tst, to local clock — a Scm, Sci, Sco Class char C S D T Color green blue black yellow asynchronous Rst, Set any input prior to local clock — to synchronization Class char R A A A Color red orange orange orange a Including synchronous clear and load signals Clr and Lod. 6.4.2 SECOND GUIDING PRINCIPLE: ALLOW FOR CIRCUITS TO SETTLE BEFORE CLOCKING! Another essential precondition for safe operation follows immediately from observation 6.1 which implies that any combinational network shall be allowed to settle to its steady-state condition before the emanating output signals are being clocked into some memory device. In the context of a (sub)circuit driven by a single clock, this amounts to the following requirement. Observation 6.5. Synchronous designs must be operated with a clock period long enough to make sure that all transient effects have died out before the next active clock edge instructs registers and other storage devices to accept new data.17 17 A more precise, quantitative formulation of this and other constraints will be given in section 7.2. 372 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN While this indeed prevents hazards on information signals from having any effect on the circuit’s [next] state, it comes at a cost. The length of the computation period, and hence also the clock period, are bounded from below by the slowest signal that travels between any two consecutive registers (longest propagation path, most penalizing set of data, slowest operating condition). The clock rate must be chosen such as to conform with the worst-case timing, thereby denying the possibility to take advantage of more favorable situations no matter how frequently these might occur.18 6.4.3 SYNCHRONOUS DESIGN RULES AT A MORE DETAILED LEVEL In a certain sense, observations 6.4 and 6.5 form the “constitution” of synchronous circuit design from which many “laws” of more specific nature can be easily derived given some particular situation. A couple of them will be explained and illustrated next, but we do not intend to explicit all such rules here as many of them have a rather narrow focus.19 HDL synthesis has greatly simplified things in that designers no longer need to manually assemble subfunctions from primitive gates and bistables. Yet, the responsibility of writing circuit models that properly synthesize to robust synchronous circuits is still that of the engineer. To do so, he must be capable of recognizing and correcting dangerous constructs. Unclocked bistables prohibited R S Q Q (a) (b) T (c) C B C A FIGURE 6.3 Examples of bistables that do not qualify for data storage in synchronous designs. Seesaw (a), snapper (b), and Muller-C element (c). Observation 6.6. As opposed to flip-flops and latches, unclocked bistables such as seesaws, snappers, and Muller-C elements do not qualify as storage elements in synchronous designs. 18 This is precisely the starting point for speculative completion that borrows from self-timed execution while preserving strictly synchronous circuit operation. The idea is based on the statistical observation that only few data vectors do indeed exercise the longest path in ripple-carry adders and related arithmetic circuits. The clock frequency is chosen such that the worst-case delay fits into two clock periods instead of one. A fast auxiliary circuit monitors carry generation and carry propagation signals in order to determine whether the current calculation involves a short or a long ripple-carry path. System operation is made to continue immediately if the adder is found to settle before the end of the first cycle. If not so, system operation is stalled for one extra clock cycle. Please refer to [170] for a more detailed account on this out-of-the-ordinary technique. 19 [171] is a valuable reference on safe digital design. The textbook gives a list of nine detailed rules but implicitly excludes all clocking disciplines other than edge-triggered one-phase clocking which is overly restrictive. 6.4 THE DOS AND DONTS OF SYNCHRONOUS CIRCUIT DESIGN 373 Unclocked bistables make no difference between reset, clock and information signals which renders them vulnerable to hazards and which is against the postulates of observation 6.4. The usage of naked SR-seesaws is strongly discouraged in spite of the fact that certain latch and flip-flop designs include them as subcircuits. Snappers are not for storing data, their sole legal usage is to prevent the voltage from drifting away while a three-state node waits in high-impedance condition. The Muller-C element is a building block of self-timed circuits. Zero-latency loops prohibited Zero-latency loop is just another name for a circular signal propagation path in a combinational network, see fig.6.4 for examples at the gate level. The problem with such circuits is that it is not possible to determine a logic value for the output even if all input values are known as some combinational function necessarily makes reference to its own result. Consider fig.6.4a and note that variable N can neither settle to 0 nor to 1 without causing a logic contradiction. A physical circuit may then either oscillate or assume a precarious equilibrium. Next consider fig.6.4b where the number of logic inversions along the loop is even. This circuit quickly locks into a one of two stable states of equilibrium with no contradictions, but there is no way to predict M without knowledge of its original value. N M E D Q P F G H . Mealy Mealy A Y X w w w B w Mealy ! ! (a) (b) (c) (d) (h)(e) (g)(f) FIGURE 6.4 A few examples of undesirable zero-latency loops. For a more substantial example consider the cross-coupled adders of fig.6.4e. Inputs A, B and outputs X, Y all have the same word width w ≥ 2 (carry bits are left aside for simplicity). X = B + YY = A + X (6.1) Behavior depends on the input values applied. If A + B = 0, equations reduce to X = X and Y = Y which implies that X and Y preserve their values. Although built from combinational gates exclusively, a physical circuit would lock into one of many possible states and remain there as long as the inputs are kept the same. Yet, a circuit with memory but no distinction between when and what signals does not conform with the dissociation principle of synchronous design. 374 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN Conversely, if A + B ∗= 0, one has X = (B + A) + X and Y = (A + B) + Y. A physical circuit would be bound to add and switch in a frenzy pace forever. Failure to settle to a steady state is against the second guiding principle of synchronous operation, however. In summary, none of the circuits shown behaves safely and predictably as one would hope. HDL code can include circular references without the author being aware of them. Examples often involve a Mealy machine plus a datapath, glue logic, or some other surrounding circuitry, see fig.6.4g. A feedback path in the logic can then combine with a through path in the finite state machine (FSM) to form a zero-latency loop. Note that not all FSM input and output bits need to participate in the loop, one each suffices. Another particularity is that such paths may open and close as a function of state and input value.20 While this is likely to confine malfunction to just a few situations, it also renders debugging particularly difficult. Observation 6.7. By prohibiting zero-latency loops, gate-level circuits are effectively prevented from oscillating, from locking into unwanted states, or from otherwise behaving in an unpredictable way. In synchronous designs, each circular path must include one or more registers.21 Monoﬂops, one-shots, edge detectors and clock chopping prohibited Monoflop, monostable multivibrator, one-shot, and edge detector are names for a variety of subcircuits that have one thing in common: they output multiple edges or even multiple pulses for a single transition at their input. A clock chopper does the same with a clock signal. Any of these can be built from a delay line in conjunction with reconvergent fanout, though other implementations also exist. See fig.6.5 for an example and observe that the exact nature of the contraption gets determined by the logic operation at the point of reconvergence. Unwary designers are sometimes tempted to resort to clock chopping when they have to incorporate blocks, e.g. unclocked RAMs, that impose timing constraints incompatible with normal synchronous circuit operation. Frequency multiplication is another usage. Once again, the requirements of observa- tion 6.4 are obviously violated. Major problems are testability, ill-defined pulse width, critical place and route, timing verification, and vulnerability to delay variations. Observation 6.8. Monoflops, one-shots, edge detectors, and especially clock choppers are absolute no-no’s in synchronous design. (a) Clk_C Clk2_C Del_C (b) Clk_C Clk2_C delay line Del_C FIGURE 6.5 Clock chopper circuit (a) with waveforms (b). 20 A perfidious example is given in appendix B.2.3. 21 Exceptions exist as the absence of zero-latency loops is a sufficient but not a necessary condition for memoryless behavior. A notable example of a circuit that settles to well-defined steady states for arbitrary stimuli in spite of a zero-latency loop is the end-around carry used in 1’s complement and sign-magnitude adders [172]. Proving that a feedback circuit predictably exhibits combinational behavior under all circumstances may be a major effort, though. 6.4 THE DOS AND DONTS OF SYNCHRONOUS CIRCUIT DESIGN 375 Clock and reset signals to be distributed by fanout trees Clock and asynchronous (re)set signals can trigger a state transition at any time. A hazard on a signal of either of these two classes is, therefore, very likely to lead to catastrophic failure. Observation 6.9. No clock and asynchronous (re)set signals shall ever participate in any logic operation other than the unary operation of taking the complement. Instead, any signal capable of inducing a state change must be distributed by a fanout tree exclusively. This is because fanout trees are a priori known not to generate hazards.22 Binary logic operations such as nor, and, xor, are strictly prohibited. Buffers and inverters are the sole logic gates that are acceptable in clock and in reset networks. Beware of unsafe clock gates Clock gating implies to enable and disable state transitions by suppressing part of the clock edges depending on the present value of some control signal. Doing so with the aid of an and or some other simple gate spliced into the clock net as shown in fig.6.6 has always been a poor technique because it is unsafe and against the principle of dissociation. However, as conditional clocking has seen a renaissance and has indeed become a necessity in the context of low-power design, safer ways of doing so will be studied in great detail in section 7.5. CLK D Q Q Ena_S Clk_C D_QD_D Q_DB FIGURE 6.6 Unsafe D-type ﬂip-ﬂop with enable resulting from malformed clock gating. No gating of reset signals Very much like a gated clock, we speak of a gated reset when the asynchronous reset or preset input of a latch, flip-flop, register, counter, or some other state-preserving subcircuit participated in combinational operation with some other signal. This anachronistic practice of using a reset signal for any other purpose than for overall circuit initialization is against the principles of synchronous design and holds serious dangers. 22 No hazard can arise in a single-input network that is free of reconvergence. Please refer back to section 6.3 or see section A.5 for a more complete rationale. 376 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN Warning example Specifications had asked for a modulo-15 counter, i.e. a counter that steps from state 0 to 14 before returning to 0. Counter slices were available from the standard cell library. The designer elected to start with a modulo-16 counter and to skip the unutilized state 15 by activating the asynchronous reset mechanism whenever the counter would enter that state. He devised the circuit of fig.6.7a which behaved as expected during logic simulation. When the IC was put into service, however, the circuit missed out state 14 and went from state 13 to 0 directly. Why? What the designer had overlooked was the transient behavior of the decode logic he had created. He implicitly started from the assumption that all inputs to the 4-input nand would switch at the same time. In reality, all sorts of imbalances contributed to make them arrive staggered in time. In the occurrence, the LSB was slightly delayed with respect to the other bits which made the 4-input nand temporarily see a 1111 during the transition from 1101 to 1110,see fig.6.7b.23 Further note that other delay patterns could as well have caused the counter to return to state 0 from states 7 or 11. The design might have developed yet another failure because the intended clearing of the counter slices in state 15 is by way of a feedback loop with latency zero. The reset condition comes to an end whenever the output of the fastest slice begins to flip. There is no guarantee that the impulse so generated is sufficiently long to clear all other bistables too. Some of the flip-flops might as well be subject to marginal triggering and eventually fall back to their previous states. transition unplanned 1111 1110 1111 1101 0000 ..... ..... state intended to be skipped transitory state unaccounted for Clk_C Rst_RB CntEn_S modulo-16 counter Q_D(0) delay unaccounted for Q_D(1)Q_D(3) Q_D(2) Q CICO CLK RST Q CICO CLK RST Q CICO CLK RST Q CICO CLK RST (a)(b) FIGURE 6.7 Unsafe modulo-15 counter subcircuit. Schematic (a) and state graph (b). \u0002 23 The phenomenon can be recognized as a function hazard. 6.4 THE DOS AND DONTS OF SYNCHRONOUS CIRCUIT DESIGN 377 Observation 6.10. The sole purpose of asynchronous (re)set inputs is to bring an entire circuit into its predefined start state. Do not gate them with information signals. It is interesting to study the motivations that lead people to expose themselves to the hazards of unsafe circuits such as the ones of figs.6.6 and 6.7. Two rationales are often heard: • Some desired functionality was unavailable in a synchronous implementation from the target cell library. In the occurrence of the above modulo-15 counter, the designer flatly preferred to misuse the asynchronous reset instead of figuring out how to add a synchronous clear/load to an elementary D-type flip-flop. The need for an enable/disable mechanism, for conditional clocking, and for data transfers across clock boundaries are further situations that tend to expose designers to the temptations of asynchronous design. HDL synthesis certainly has helped designers to stay away from such practices. • The asynchronous implementation was believed to result in a smaller circuit, faster speed, and/or better energy efficiency than a synchronous alternative. While this may be true in some cases, the contrary has been demonstrated in many others. Keep in mind that any redundant circuitry necessary to generate multiple auxiliary clocks, to stretch impulses, to suppress unwanted glitches, or to make sure local delay constraints are satisfied does not come for free either. In view of all the limitations cited in section 6.3.3, overall cost-effectiveness remains questionable to say the least.24 Bistables with both asynchronous reset and preset inputs prohibited Some component and cell libraries include flip-flops that feature both an asynchronous set and an asynchronous reset. Synchronous design knows of no useful application for such subcircuits. Also, behavior is unpredictable and resembles that of a seesaw when both S and R are deasserted simultaneously. Reset signals to be properly conditioned Note, to begin with, that the total load controlled by the global reset is in the same order of magnitude as that driven by the circuit’s clock signal. The same further applies to the scan mode signal. It typically takes a large buffer or a buffer tree to drive such nets with acceptable ramp times. 24 You may want to consult section A.10 where more details on how to construct safe flip-flops with enable, with synchronous clear, with scan facility, and the like are given. 378 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN (a) Clk_C Rst_RB clock buffer(s) reset buffer(s) ..... functional circuitry delay (c) DQ CLK ..... functional circuitry delay (b) DQ CLK ..... functional circuitry delay CLK RST CLK RST CLK RST CLK RST CLK RST CLK RST ! Clk_C Rst_RB Clk_C Rst_RB FIGURE 6.8 Conditioning of global asynchronous reset signal. Fully asynchronous (a), fully synchronized (b), and uncondi- tional application combined with synchronized removal (c). A more specific peril associated with the usage of asynchronous (re)sets exists in applications with a free-running clock, that is where a reset impulse may occur at any time with respect to the driving clock, see fig.6.8a. If the circuit’s asynchronous reset input gets deactivated near the active clock edge, then part of the bistables may be allowed to take up normal operation before the end of one clock cycle while others would remain locked until early in the next cycle. Going through the same efforts as with the clock distribution network to minimize reset skew, i.e. local delays differences within the reset distribution network, is a rather costly option. Incorporating the auxiliary subcircuit depicted in fig.6.8b solves the problem by synchronizing the reset signal to the on-chip clock before it gets distributed to the functional bistables. All bistables are so guaranteed to get properly (re)set during the same clock cycle. Any transitions on the internal reset occur shortly after the active clock edge which leaves the designer with ample time, i.e. almost one clock period, for distributing the signal across the chip. As a side-effect, the circuit responds to the external reset signal with a latency of one clock cycle. 6.4 THE DOS AND DONTS OF SYNCHRONOUS CIRCUIT DESIGN 379 Yet, a new difficulty has been introduced because the reset operation now depends on the functioning of the clock subsystem. In the absence of a clock or in the presence of specific hardware faults, the circuit would fail to settle to a defined start state. Drive conflicts, static power dissipation, inconsistent output data, destructive overwrite of nonvolatile memories and other operating conditions unsafe for the surrounding system may be the undesirable consequences. In the design of fig.6.8c, a simple combinational bypass makes sure that a reset is immediately and unconditionally brought to bear. Deactivation, in contrast, takes place at well defined moments of time. An equivalent circuit alternative does away with the and-gate by connecting the external reset input to a synchronizer flip-flop with an asynchronous reset terminal. Keep in mind that all three designs impose conditions on the relative timing of Rst_RB and Clk_C. Violating them may cause marginal triggering in one or more of the flip-flops. Also remember that asynchronous (re)set inputs are very sensitive to glitches and noise. Pay attention to portable design IC designers time and again face the problem of porting a design from one implementation platform to another, e.g. when they • Migrate a design from an FPGA to a cell-based ASIC, or vice versa, • Upgrade to a more up-to-date target process or library, • Incorporate a third-party circuit block into a larger design, or • Accept a heritage design for integration. While it is possible to fine-tune almost any design for some given technology, employing asynchronous techniques can be disastrous when it comes to porting a design to some other platform. Think ahead and design for portability in the first place. Observation 6.11. Accept that almost all VLSI designs are subject to porting during their lifetime and stick to the established rules of safe design and synchronous operation to render the porting smooth and cost-effective. Conversely, when being proposed an existing design, do not accept it unseen. Be prepared to distillate the necessary functionality and reimplement it using a clocking discipline that is compatible with VLSI or your target PLD. Heritage designs on the basis of standard parts such as microprocessors and LSI/MSI circuits notoriously include the worst examples of asynchronous design tricks. Also note that on-chip memories often are at the origin of portability problems because of the many varieties being offered. 380 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN 6.5 CONCLUSIONS • Among the three grand alternatives for clocking digital circuits, ad-hoc asynchronous operation has been found to be unsafe and inefficient in VLSI. • While safe if implemented correctly, self-timed operation at the gate level entails an unacceptable overhead in terms of hardware and energy, and necessitates out-of-the normal design methodologies, software tools, and library cells. • Synchronous operation of large system chunks does away with almost all timing problems, results in efficient circuits, and is compatible with today’s design automation flows and cell libraries. There hardly is a better choice for VLSI, especially when there is high pressure on tight schedules and high design productivity. • Synchronous circuits exhibit a strict dissociation of signals into ◦ One clock signal (or possibly more if of fixed frequency and phase relationship), ◦ One asynchronous reset signal (optional), ◦ An arbitrary number of information signals. • HDL synthesis does not dispense designers from deciding about clocking disciplines and clock domains as it is possible to express any clocking discipline in an RTL circuit model. 6.6 PROBLEMS 381 6.6 PROBLEMS 1. ∗∗ Fig.6.4c and d depict two feedback circuits each built from a few logic gates. Establish their respective truth tables and discuss your findings. 2. ∗ The circuit of fig.6.4c behaves much like a latch where D acts as data input and E as enable input. Explain why this construct does not qualify as a latch in synchronous designs. 3. ∗∗∗ Come up with a synchronous implementation for the modulo-15 counter of fig.6.7. Compare the relative sizes of the two alternatives based on the assumption that both counters are built from D-type flip-flops. 4. ∗∗ FireWire is the name of a serial bus for interconnecting computer and multimedia equipment. To facilitate the delimiting and recovering of individual bits from the data stream at the receiver end, data get conveyed one bit after the other coded using two peer signals (the fact that two differential signal pairs are actually being used does not matter in this context). The first signal termed “data” simply corresponds to the incoming data whereas its “companion” is to feature a transition at the boundary between any two adjacent bits iff the first signal does not. Thus, at either end of a FireWire link, a modulator circuit in the transmitter converts the incoming serial data stream into a data-plus-companion pair, while a demodulator on the receiving side is in charge of recovering the initial data from that signal pair. Design both a modulating and a demodulating circuit. What class is the automation you must use? ∗∗∗ Assuming that receiver and transmitter run from separate clocks is definitely more realistic but requires prior exposure to material from section 8.2 and also makes solving the problem more demanding. 382 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN 6.7 APPENDIX: ON IDENTIFYING SIGNALS with contributions by too many of the author’s colleagues to be named here Many mistakes in hardware design can be traced down to minor oversights in specifications, datasheets, truth tables, HDL code, schematics, and the like. Misinterpretations are particularly likely to occur at the interface between different subsystems, subcircuits and clock domains because correct operation implies mutual agreement on the meaning behind data formats, signal waveforms, and transmission protocols. What is needed is a clear and unambiguous, yet simple, scheme for naming signals and for drawing diagrams, especially when working in a team. A helpful notational convention must keep track of • Signal class, • Active level, • Signaling waveform, • Three-state capability, • Input, output or bidirectional, • Present state vs. next state, and • Clock domain. 6.7.1 SIGNAL CLASS A total of six signal subclasses have been identified in section 6.4 and catalogued in table 6.2.The same table suggests to append one of the characters below to make a signals’s role evident from its name. Ultimately, this will lead to a syntax detailed in section 6.7.7. ◦ R asynchronous (re)set, ◦ A any other signal subject to asynchronous switching, ◦ C clock, ◦ S status or control, ◦ D data, address or the like, ◦ T test. Colors in schematic diagrams and HDL source code Wires colored in a meaningful way expedite the understanding of large schematic diagrams and render many potential problems immediately visible.25 Let us cite five examples on the basis of the coloring scheme of table 6.2: • Any clock signal (green) routed through a logic gate or other combinational subcircuit with two or more inputs draws the attention to a potentially unsafe clock gating practice. • A register with neither an asynchronous (re)set wire (red) nor a synchronous clear (blue) attached indicates the subcircuit is in need of a special homing sequence for initialization. 25 The coloring scheme proposed in fig.6.2 is intended for usage in schematic diagrams that are drawn on light backgrounds. On dark backgrounds, white must be substituted for black. Also, swapping blue and yellow does re-establish the original idea of fading all test-related signals as they tend to distract from a circuit’s functionality. 6.7 APPENDIX: ON IDENTIFYING SIGNALS 383 • Any combinational logic that drives an asynchronous (re)set line (red) indicates (re)sets are exposed to hazards as a consequence from being misused for functional purposes. • Any signal emanating from a foreign clock domain (orange) that drives combinational logic points to a lack of synchronization. • The absence of any test signals (yellow) makes it obvious that no test structures have been incorporated in a functional block. Coloring signal names in HDL source code facilitates the interpretation of hardware models in much the same way as colored wires used to do in schematics. The Emacs editor has been extended by a special VHDL mode that checks and supports syntactical correctness [173]. Automatic coloring of signal names further assists authors and readers of code. Clock symbols and clock domains in schematic diagrams It is good engineering practice to identify the clock inputs by way of graphical symbols attached to icons, see fig.6.9a,b,c. Standard single-edge-triggering clocks are marked by a small triangle, the more unusual double-edge-triggering clocks by two dovetailed triangles, and level-sensitive clocks by a small rectangle. This rule is by no means restricted to gate-level diagrams as its application is beneficial to the clarity of schematics at any level of hierarchy. Any signal that crosses over from one clock domain to another deserves particular attention as it may switch at any time irrespective of the receiver’s clock. Making clock domains explicit in block diagrams and schematics is very important. All subcircuits that belong to one clock domain shall be placed closely together and all clock boundaries shall be made evident. CLK single-edge- triggered CLK double-edge- triggered CLKClk_C Clk_C Phi_C level- sensitive in contradiction DQ Q CLK ENA RST DQ Q CLK ENA Qux_D Rst_RB Foo_D Qux_DB Clk_CB Ena_SB Qux_D Rst_RB Foo_D Qux_DB Clk_CB Ena_SB RST (a) (b) (c) (e)(d) FIGURE 6.9 Notational conventions in schematic diagrams. Identiﬁcation of clock inputs (a,b,c) and two competing mindsets for reﬂecting signal polarities (d,e). 384 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN 6.7.2 ACTIVE LEVEL Naming of complementary signals As active-high and active-low signals coexist within the same circuit, it is important to make it clear in the identifier whether a given signal is to be understood in positive or in negative logic. Overlining the name is how negated terms are identified in mathematics, e.g. if Qux stands for an active-high signal, then its active-low counterpart is named Qux (pronounced “qux bar”). Since this notation does not yield character strings acceptable for processing with computers, many engineers prefix or postfix the basic identifier and resort to something like ~Qux, /Qux,or Qux$. However, the problem with most non-alphanumerical characters is that today’s EDA tools, HDLs, and standards disagree on which such symbols they support within node names and on where they are allowed to occur in the name’s character string. For reasons of cross-platform compatibility, we prefer to use the attribute B (for “bar”) in conjunction with the conventions to be given in section 6.7.7. In the occurrence, we do write Qux_B as shown in fig.6.9d and e. The popular practice of appending a simple B or N is not recommended because it may give rise to confusion in names such as Selb or OupEn. The same argument also holds for conditions and actions related to edges rather than to logic levels. By default, the rising edge is considered to be the active one for a non-inverted signal. Inversion symbols in schematic diagrams Signal polarities must also become clear from schematics and icons. In fact, cell icons often include small circles that are supposed to stand as a shorthand notation for regular gate-type inverter symbols. One would thus naturally expect to find such an inversion circle wherever a signal gets translated from active-high to active-low or vice versa, and wherever polarity changes from rising-edge- to falling-edge- triggering or back. This is the mindset behind fig.6.9d. Most industrial cell libraries follow the notation depicted in fig.6.9e, though. Please observe that signals Rst_RB and Clk_CB are not subject to any negation upon entering the flip-flop here, the small circles just reconfirm that the cell’s inputs RST and CLK are active-low and falling-edge-triggered respectively. Much the same observation applies to output Q. The reason for this departure from mathematical rigor is that a cell can so keep the same graphical icon independently from the context, a quality not shared by the notational convention of fig.6.9d. Hint: As there are no generally-adhered-to standards, designers are well advised to double-check the exact meaning of signal identifiers, terminal names, and inversion circles when working with third-party components, cell libraries, or HDL code. 6.7 APPENDIX: ON IDENTIFYING SIGNALS 385 6.7.3 SIGNALING WAVEFORMS In distinguishing between active-high and active-low signals, we have tacitly assumed that it was a signal’s level that conveyed information from a transmitter to the receiver(s). While this is often true, this is not the only way to code information into a signal waveform. Fig.6.10 shows a data signal along with three different interpretations of its waveform.26 Clock-qualified signaling means that the logic level, 1 or 0, of the signal at the instant of each active clock edge is what matters. Key characteristics of this scheme are as follows. • Qualifier-type signals are always meant relative to a specific clock. • They must remain stable throughout the data-call window (i.e. setup-hold interval) of the receiving circuit. • Each logic 1 gets counted as a relevant event of its own even if the signal does not change in between (and vice versa for an active-low signal). • Hazards between active clock edges have no effect. Examples: The enable input of a synchronous counter, the write line of a synchronous RAM, the zero flag from an ALU when followed by a flip-flop. Impulse signaling relies on the presence of an impulse (mark or pause) which implies that • Each rising edge or, alternatively, each falling edge is counted as a relevant event. • The signal must return to its initial, passive level before it can possibly become active for a second time. • The durations of marks and pauses are immaterial. • Static and dynamic hazards are unacceptable as they would cause erroneous registration of events where there are none. Examples: Write line of an asynchronous RAM, request and acknowledge signals in a RZ (four- phase) handshake protocol. Transition signaling does the signaling with the presence of an edge which means that • Each rising and falling edge is counted as a relevant event. • The signal must not restore its initial value between two consecutive events. • The durations of marks and pauses are immaterial. • Static and dynamic hazards are unacceptable as they would cause erroneous registration of events where there are none. Example: Request and acknowledge signals in an NRZ (two-phase) handshake protocol. 26 Three is by no means exhaustive. Calling upon pairs of complementary signals to improve on noise immunity (differential signaling) comes as a natural extension. Some schemes map data onto waveforms such as to allow for safe recovery of individual bits from a serial data stream at the receiving end (self-clocking), whereas others transmit two peer signals — none of which can be interpreted as a clock — for the same purpose (companion signaling). The FireWire bus, for instance, uses four wires and a waveform referred to as non-return to zero with data strobe (NRZ-DS) which is a combination of differential with companion signaling. We refrain from discussing such schemes here as they are mainly intended for communicating between more distant subsystems. 386 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN clock events clock signal data signal ✖✖ ✖clock- qualified Q 3☛☛☛☛impulse M 4 transition G 8 events counted with signaling format FIGURE 6.10 Three signaling waveforms in common use. Note from fig.6.10 that the event counts and the instants of registration differ as a function of the signaling scheme. It is thus absolutely essential that transmitter and receiver agree on this if a system is to function as intended. This is not normally a problem within a clock domain where information signals are clock-qualified by nature. For simplicity, we can omit an attribute in this case. However, care must be exercised where a signal traverses the boundary of a subsystem or clock domain. The signaling waveform shall thus be stated as follows: ◦ Q clock-qualified signaling, ◦ M impulse signaling (for “mark”), ◦ G transition signaling (for “grade”). 6.7.4 THREE-STATE CAPABILITY Signals with high-impedance capability shall be identified by a Z character. This is to remind designers of the various issues associated with a three-state circuit node such as resolution function, drive conflicts, floating potential, and testability. 6.7.5 INPUTS, OUTPUTS AND BIDIRECTIONAL PORTS HDL code is easier to understand when inputs and outputs are immediately discernible from an appended I or O.27 IO then obviously stands for a bidirectional signal. The same information is often conveyed by way of graphical symbols in schematic diagrams, see fig.6.11. 27 As an added benefit, this also circumvents a quirk of VHDL in that the language disallows reading back from an output terminal. That is, an interface signal declared as out in the port clause of some entity declaration is neither permitted on the right-hand side of a signal assignment in the pertaining architecture body nor in a relation operation (such as =, /=, <,etc.). Distinguishing between two signals does away with the problem: while Foo_D can be freely used within the architecture body, a copy named Foo_DO is to drive the output port. Some programmers prefer to declare the port to be of mode inout instead, yet, this is nothing else than a bad habit. After all, what one wants to model from an electrical point of view is just an output and not a bidirectional. No HDL language restriction should make us obscure our honest intentions. 6.7 APPENDIX: ON IDENTIFYING SIGNALS 387 input Foo_I output Bar_O bidirectional Qux_IO . other VDD FIGURE 6.11 Ports and other terminals in schematic diagrams. Observation 6.12. Hint to SystemVerilog users: I and O suffixes are incompatible with useful features of the language such as dot name and dot star port connections, interface, and modport. Designers may elect to use io_mode suffixes only where unproblematic or to omit them altogether. 6.7.6 PRESENT STATE VS. NEXT STATE Most state machines models operate with two signals for the state variable, namely a first one that holds its present value and a second one that predicts the value it is going to assume in response to the next active clock edge. It is imperative not only to identify such signals as being closely related, but also to make it clear which is which. While this is immediately obvious in schematics, identifiers are the sole means of conveying this kind of information in HDL models. We, therefore, suggest to tell present and next state apart with the aid of suffixes P and N. 6.7.7 SIGNAL NAMING CONVENTION SYNTAX We have now compiled a number of attributes for making a signal’s nature evident. A practical problem is how to permanently attach those attributes to a signal. About the only way that can be expected to work across different EDA platforms consists in blending them right into the signal’s identifier. To make a long story short, the underscore _ is the only non-alphanumerical character that universally qualifies for affixing a signal’s attribute to its name.28 This results in identifiers such as Foo_DB for an active-low data signal, for instance. In Backus Naur form: signal_identifier ::= signal_name \"_\" signal_attributes signal_name ::= letter { letter | digit } signal_attributes ::= class_char [ signal_waveform ] state_char three-state_mode active-low_char io_mode class_char ::= \"R\" | \"A\" | \"C\" | \"S\" | \"D\" | \"T\" signal_waveform ::= \"Q\" | \"M\" | \"G\" 28 The IEEE 1076.4 VITAL standard reserves the underscore as a delimiter in generics, e.g. in an identifier such as tpd_Foo_Bar for the propagation delay from an input Foo to some output Bar. As a consequence, VITAL models must not contain any underscore in a port name. While this seems to prevent the usage of the underscore as a separator between signal name and signal attribute, this is actually not so for the majority of people who are just simulating with VITAL models rather than writing their own ones. This is because any underscore in a user-defined port name always appears in the actual part of the port maps of VHDL component instantiation statements, and never in the formal part subject to VITAL ruling. The aforementioned reservations relating to the underscore character do not apply in this case. Together with the modest adoption of VITAL, this lead us to relax our naming conventions over those published in an earlier version of this text [146]. 388 CHAPTER 6 THE CASE FOR SYNCHRONOUS DESIGN state_char ::= \"N\" | \"P\" | \"\" three-state_mode ::= \"Z\" | \"\" active-low_char ::= \"B\" | \"\" io_mode ::= \"I\" | \"O\" | \"IO\" | \"\" Although no attribute character has been assigned more than one interpretation, we recommend to order attribute characters as stated above and, more particularly, to always make the mandatory class_char come first in the signal_attributes substring. Examples Foo_C identifies a clock signal. Bar_D indicates this is a regular data signal within some clock domain. As opposed to this, the name Bar_A refers to the same signal before being synchronized to the local clock and, hence, subject to toggle at any time. Qux_RB refers to some asynchronous active-low reset signal. AddrCnt_SN and addrcnt_SN are legal names for the next state of an address counter as long as the signal remains within the clock domain where it originates. Irq_AMI identifies an interrupt request input that emanates from a foreign clock domain and that is meant to be stored in a positive-edge triggered flip-flop until it is being serviced. Carry_DB denotes an active-low carry signal. Where a duplicate signal is required for the sole purpose of driving an output port, it shall be named Carry_DBO. GeigerCnt_DZO reflects an output-only data signal with high-impedance capability. ScanMode_T stands for an active-high scan enable signal within some clock domain. \u0002 For any programmer, it comes most naturally that each variable in a software module must be given its own unique identifier, and the same holds true for HDL code. It is important that the same principle also be enforced in schematic drawings and netlists because any two nodes that carry identical names in the same circuit block are considered by EDA tools as connected by name, i.e. as one and the same circuit node. Connections by name often help to render complex schematic diagrams easier to read. Hint: While you are encouraged to take advantage of connections by name to avoid cluttering your schematic diagrams with clocks, resets, and other signals that connect to a multitude of subcircuits, beware of shorts that will arise whenever a signal name gets reused for two electrically distinct nodes. Inadvertently or consciously doing so (“... but logically they are the same ...”) is a typical beginner’s mistake. 6.7.8 USAGE OF UPPER AND LOWER CASE LETTERS IN HDL SOURCE CODE Basically, VHDL is a case-insensitive language, whereas SystemVerilog is case-sensitive. While FooBar_DB, foobar_DB, FOOBAR_DB and foobar_db are all the same in VHDL, they are read as distinct identifiers by a SystemVerilog compiler. As some EDA programs have the side effect of mapping all 6.7 APPENDIX: ON IDENTIFYING SIGNALS 389 lower case letters to upper case ones — or vice versa — it is not a good idea to use casing to distinguish between otherwise identical names. For the sake of legibility, we nevertheless encourage HDL programmers to write their source code in the following way: ◦ Reserved words: lower case throughout, e.g. port, case, signed. ◦ Subprograms, i.e. functions, procedures, tasks: lower case throughout, e.g. foobar. ◦ Constants, generics/parameters: upper case throughout, e.g. FOOBAR or FOO_BAR. ◦ VHDL variables: PascalCaps or camelCaps, e.g. FooBar or fooBar. ◦ VHDL signals: as above with suffix added, e.g. FooBar_DB or fooBar_DB. ◦ SystemVerilog variables: PascalCaps or camelCaps, e.g. FooBar or fooBar, optional suffix for variables that convey information between concurrent processes.29 Warning: Do not use case variations of any reserved word of your HDL for user-defined identifiers as this will give rise to confusion at some point, if not with EDA tools, then with human readers. E.g. neither use WAIT nor wait for a state or signal. 6.7.9 A NOTE ON THE PORTABILITY OF NAMES ACROSS EDA PLATFORMS Porting netlists and schematics from one EDA platform to another is often painful as each has his own rules for the naming of circuit nodes. Translation steps are inevitable unless one finds a common subset accepted by all tools involved. Here are a few items to watch out for. Non-alphanumerical characters. Most EDA data interchange formats have specific rules as to what special characters they accept as part of a node name and in what position. The underscore is about the only non-alphanumerical character tolerated in node names across many formats and EDA tools. The naming conventions presented above have been devised with this in mind and, therefore, produce widely accepted signal and node names. Hierarchy delimiters. Slash /, period mark ., and dollar sign $ are commonly being used. For the sake of unlimited cross-platform portability, we recommend to spell node names with no special characters other than the underscore. Busses. One finds brackets [ ], parentheses ( ), and curly brackets { } in combination with a colon :,a to,or a downto for indicating the index range of a vector. Aliases. Although typically legal, multiple names for the same node should be avoided because many software tools are not able to handle them correctly and because of the confusion this practice tends to create with humans. 29 Take note of hint in section 6.7.5.","libVersion":"0.5.0","langs":""}