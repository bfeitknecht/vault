{"path":"sem4/FMFP/VRL/extra/slides/07-ModelChecking.pdf","text":"Formal Methods and Functional Programming Model Checking Peter M¨uller Programming Methodology Group ETH Zurich LTL Model Checking Problem Given a finite transition system TS and an LTL formula ϕ, decide whether t ⊧ ϕ for all t ∈ T (TS) We need to check inclusion of traces LTL formula ϕ describes a set of traces P(ϕ) We need to determine whether or not T (TS) ⊆ P(ϕ) Na¨ıvely searching all traces is not an option (infinite length) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 261 Checking Safety Properties Automatic checking of LTL formulas is non-trivial because traces are infinite For safety properties, recall that any violation can be observed after a finite prefix Idea Characterize all finite prefixes of the traces of a transition system using a finite automaton Check whether any of them violates the safety property For liveness properties, we will need other strategies David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 262 Finite Automaton for Finite Prefixes Reminder: an NFA is a tuple (Q, Σ, δ, Q0, F ) Q: a finite set of states Σ: a finite alphabet δ: a transition relation, δ ⊆ Q × Σ × Q Q0 ⊆ Q: a set of initial states F ⊆ Q: a set of accepting states Given a transition system TS = (Γ, σI , →), we define an NFA FATS characterizing all finite prefixes Tfin(TS) of the traces of TS The automaton FATS = (Q, Σ, δ, Q0, F ) Q = Γ ∪ {σ0}, where σ0 /∈ Γ Σ = P(AP) δ = {(σ, p, σ′) ∣ σ → σ′ and p = L(σ′)} ∪ {(σ0, p, σI ) ∣ p = L(σI )} Q0 = {σ0} F = Q (accept any prefix of a trace) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 263 Example: NFA for Promela Program Consider the Promela program (file handling example): o = o + 1; do :: o = o - 1; o = o + 1; :: break od; o = o + 1; L(σ) = ⎧⎪⎪⎪ ⎨ ⎪⎪⎪⎩ {open} if σ(o) = 1 {closed} if σ(o) = 0 {} otherwise Transition system Finite automaton{ closed}{ }{ open }{ closed}3{ closed}{ open }{ }{ open }{ closed}012{}{}{}4 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 264 Example: NFA for Promela Program Consider the Promela program (file handling example): o = o + 1; do :: o = o - 1; o = o + 1; :: break od; o = o + 1; L(σ) = ⎧⎪⎪⎪ ⎨ ⎪⎪⎪⎩ {open} if σ(o) = 1 {closed} if σ(o) = 0 {} otherwise Transition system Finite automaton{ closed}{ }{ open }{ closed}3{ closed}{ open }{ }{ open }{ closed}012{}{}{}4 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 264 Checking Safety Properties “by hand” Given an automaton, we can check simple LTL formulas manually3{ closed}{ open }{ }{ open }{ closed}012{}{}{}4 An LTL formula is valid in a transition system, if every trace of the transition system satisfies the formula ◻(open ∨ closed) is not valid for the transition system above (the automaton accepts a prefix that violates the property) ◻¬(open ∧ closed) is valid For slightly larger programs or properties, checking “by hand” quickly becomes unfeasible David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 265 Regular Safety Properties A safety property is regular if its bad prefixes are described by a regular language over the alphabet P(AP) Every invariant over AP is a regular safety property For the property defined by ◻p, all bad prefixes start with S ∗T where S describes any subset of P(AP) that contains p, and T any subset that does not contain p For example, bad prefixes for ◻open are described by ({open} ∣ {open, closed})∗({} ∣ {closed}) Non-regular safety properties also exist Vending machine: at least as many coins inserted as drinks dispensed Bad prefixes: regular languages “cannot count” David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 266 Checking Regular Safety Properties 1. Describe finite prefixes Tfin(TS) by finite automaton FATS 2. Describe bad prefixes of regular safety property P by finite automaton FA ¯P 3. Construct finite automaton for product of FATS and FA ¯P 4. Check if the resulting automaton has any reachable accepting states If not, the property P is never violated in traces of TS If yes, the property P is violated Moreover, each word in the accepted language of the product automaton is a counterexample (i.e., a bad prefix of P that is a prefix of a trace of TS) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 267 Finite Automaton for Bad Prefixes By definition, the bad prefixes of a regular safety property P can be described by a regular expression (over the alphabet P(AP)). Apply standard construction to obtain NFA FA ¯P from regular expression We say an NFA FA ¯P = (Q, Σ, δ, Q0, F ) is a bad-prefix automaton for a regular safety property P, if: Σ = P(AP) The NFA accepts a word w ∈ Σ∗ if and only if w is a bad prefix for P We do not present general algorithms for constructing bad-prefix automata in this course David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 268 Example: Finite Automaton for Bad Prefixes Example: ◻ ((open ∨ closed) ∧ ¬(open ∧ closed)) Bad prefixes start with ({open} ∣ {closed}) ∗({} ∣ {open, closed}){ }{ open }AB{ open, closed}{ld}all{ closed}Note: the states of the automaton do not correspond to program states; this automaton is defined purely in terms of the propositions and property of interest David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 269 Product Automaton Construct NFA FATS∩ ¯P that accepts the intersection of the languages accepted by FATS and FA ¯P Apply standard construction for product of two NFA: FATS∩ ¯P = FATS × FA ¯P = (Q, Σ, δ, Q0, F ), where: Q is the cartesian product of the states of FATS and FA ¯P (i.e., the set of all pairs (σ, A) where σ is a state of FATS and A is a state of FA ¯P ). Σ is the alphabet of FATS and FA ¯P (i.e., P(AP)) δ is defined by ((σ1, A1), p, (σ2, A2)) ∈ δ if and only if: 1. (σ1, p, σ2) is in the transition relation of FATS 2. (A1, p, A2) is in the transition relation of FA ¯P Q0 is the set of states (σ0, A0) where 1. σ0 is an initial state of FATS 2. A0 is an initial state of FA ¯P F is the set of states (σ, AF ) where AF is an accepting state of FA ¯P David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 270 Example: Product Automaton FATS FA ¯P3{ closed}{ open }{ }{ open }{ closed}012{}{}{}4{ }{ open }AB{ open, closed}{ld}all{ closed} Product automaton FATS × FA ¯P3AAAA{ closed}{ open }{ }{ open }{ closed}B0A1A2A{}{}{}4B Note: unreachable states (such as σ0B) are omitted in the diagram David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 271 Emptiness Check If product automaton FATS∩ ¯P accepts a word w then w ∈ Tfin(TS) because it is accepted by FATS and w is a bad prefix because it is accepted by FA ¯P Therefore, P is not satisfied, and w is a counterexample Apply standard algorithm to check emptiness of NFA Mark all states that are reachable from an initial state If at least one accepting state is marked, the language accepted by the automaton is non-empty David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 272 Example: Emptiness Check Product automaton FATS × FA ¯P3AAAA{ closed}{ open }{ }{ open }{ closed}B0A1A2A{}{}{}4B Accepting state σ4B is reachable from the initial state (but for instance σ0B is not) Automaton accepts {closed}{open}({closed}{open}) ∗{} Smallest counterexample: {closed}{open}{} Counterexample can be mapped back to transition system David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 273 LTL Model Checking Problem Revisited Given a finite transition system TS and an LTL formula ϕ, decide whether t ⊧ ϕ for all t ∈ T (TS) Technique described so far can check regular safety properties It cannot check non-regular safety properties Bad prefixes cannot be described by NFA It cannot check liveness properties A liveness property is violated in infinite time Checking for finite bad prefixes does not work David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 274 ω-Regular Languages Regular expressions denote languages of finite words ω-regular expressions denote languages of infinite words An ω-regular expression G has the form G = E1F ω 1 ∣ . . . ∣ EnF ω n (1 ≤ n) where Ei and Fi are regular expressions and ϵ /∈ L(Fi ) L(F ω) = {w1w2w3 . . . ∣ ∀i ⋅ wi ∈ L(F )} David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 275 B¨uchi Automata B¨uchi automata are similar to finite automata, but accept infinite words The class of languages accepted by non-deterministic B¨uchi automata agrees with the class of ω-regular languages A non-deterministic B¨uchi automaton (NBA) is a tuple (Q, Σ, δ, Q0, F ) Q: a finite set of states Σ: a finite alphabet δ: a transition relation, δ ⊆ Q × Σ × Q Q0 ⊆ Q: a set of initial states F ⊆ Q: a set of accepting states A run of an NBA accepts its input if it passes infinitely often through an accepting state NBA enjoy many of the properties of finite automata We can construct the product of two NBA Emptiness is decidable David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 276 ω-Regular Expression for Promela Program Traces T (TS) can be described as ω-regular expression Example o = o + 1; do :: o = o - 1; o = o + 1; :: break od; o = o + 1; L(σ) = ⎧⎪⎪⎪ ⎨ ⎪⎪⎪⎩ {open} if σ(o) = 1 {closed} if σ(o) = 0 {} otherwise Transition system{ closed}{ }{ open }{ closed} Traces {closed}{open}({closed}{open})ω ∣ {closed}{open}({closed}{open})∗{}ω David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 277 ω-Regular Expression for LTL Formulas The set of traces satisfying an LTL formula can be described as ω-regular expression Example: all opened files must be closed eventually LTL formula: ◻(open ⇒ ◇closed) ω-regular expression: (({} ∣ {op})∗ ({cl} ∣ {op, cl}) ∣ {}) ω Bad traces: ¬ ◻ (open ⇒ ◇closed) ω-regular expression: ({} ∣ {cl} ∣ {op} ∣ {op, cl})∗ {op} ({} ∣ {op})ω where op and cl abbreviate open and closed, resp. David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 278 LTL Model Checking 1. Describe traces T (TS) by NBA BATS 2. For an LTL formula ϕ, construct NBA BA¬ϕ that accepts the traces characterized by ¬ϕ (bad traces) 3. Construct NBA for product of BATS and BA¬ϕ 4. Check whether the language accepted by product NBA is empty If language is non-empty, property ϕ is violated Each word in the language is a counterexample David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 279 Complexity Results For a finite transition system TS and an LTL formula ϕ, the model checking problem TS ⊧ ϕ is solvable in O(∣ TS ∣ ×2 ∣ϕ∣) ∣ TS ∣ is the size of the transition system (which grows exponentially in the number of variables, processes, and channels) ∣ ϕ ∣ is the size of ϕ; exponential complexity comes from the construction of BA¬ϕ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 280 Advanced Model Checking Techniques On-the-fly model checking Often violation of a property can be detected without checking all possible states or traces (for instance, ◻p) Generate transition system and check property step-by-step Implemented in Spin Partial order reduction Remove redundancy from different interleavings of concurrent executions Code segments that operate only on local state are not affected by interleaving Implemented in Spin David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 281 Advanced Model Checking Techniques (cont’d) Bounded model checking Check only prefixes of traces up to a certain length Closer to testing than verification Very effective in practice Symbolic model checking Uses sets of states rather than individual states Sets of states are represented through boolean functions Very efficient data structure: binary decision diagram (BDDs) Typically used to check branching-time properties Can deal with larger models David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 282 Model Checking: Conclusions Model checking can verify sophisticated properties automatically Worst-case complexity is exponential, but can sometimes be mitigated by careful modeling The techniques shown are implemented, and are useful in practical applications Tool support is essential (just as for verification) Exploring models “by hand” is clearly impractical Some tools have reached maturity for industrial applications (especially for safety-critical systems) Model checking is applicable also to hardware verification David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 283","libVersion":"0.5.0","langs":""}