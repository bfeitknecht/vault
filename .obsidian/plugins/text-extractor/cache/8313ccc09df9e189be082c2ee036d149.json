{"path":"sem2a/PProg/VRL/extra/benji/PProg-w12-benji.pdf","text":"Parallel Programming Exercise Session 12 1 Outline 2 1. Feedback: Assignment 11 2. Skip lists 3. Assignment 12 Feedback: Assignment 11 3 Fine grained Locking 4 Optimistic Locking 5 Lazy Locking 6 Skip lists Practical implementation of sets Operations: add(), remove(), find() Assumptions: #find > #add > #remove Las Vegas: Solution always correct Run-time is a random variable depending on the problem instance and the algorithm Assignment 12 • Multisensor System. 8 Multisensor System 9 Multisensor System 10 Multisensor System 11 Implement two versions of the senor data set: a) One blocking version based on a readers-writers lock (LockedSensors.java). b) A lock-free version (LockFreeSensors.java) Hints: • Before you implement the readers-writers lock based version, start with a simple locked version in order to understand. Then try a readers-writers lock but be aware that the Java-implementation does not give fairness guarantees. What can this imply? In any case, you have the code from the lecture slides presenting a fair RW-Lock implementation. • The lock-free implementation solutions does NOT rely on mechanisms such as Double-Compare- And- Swap. Also it does not rely on a lazy update mechanism. Somehow you have to make sure that with a single reference update you change all data at once. How? Readers-writers lock 12 Readers-writers lock 13 Readers-writers lock 14 Readers-writers lock in Java double readSomething() { readerWriterLock.readLock().lock(); try { double value = retrieveDoubleValue(); return value; } finally { readerWriterLock.readLock().unlock(); } } Void writeSomething(double new_value) { readerWriterLock.writeLock().lock(); try { storeDoubleValue(new_value); } finally { readerWriterLock.writeLock().unlock(); } } 15 What’s the problem? Readers-writers lock in Java double readSomething() { readerWriterLock.readLock().lock(); try { double value = retrieveDoubleValue(); return value; } finally { readerWriterLock.readLock().unlock(); } } Void writeSomething(double new_value) { readerWriterLock.writeLock().lock(); try { storeDoubleValue(new_value); } finally { readerWriterLock.writeLock().unlock(); } } 16 No fairness guarantees! 17 Readers-writers lock with monitors What’s a potential problem? 18 Readers-writers lock with monitors Priority is given to the readers. As long as readers > 0, no writer will acquire the write-lock. If there is a continuous flow of readers, no write will be performed! 19 Readers-writers lock with monitors What happens here? 20 Readers-writers lock with monitors As soon as one writer wants to acquire, no reader is allowed to pass. This gives strong priority to the writers. 21 Readers-writers lock with monitors Possible definition of fairness: When a writer releases the write-lock a number of n readers will be waiting. Let n readers pass and then let the next writer (if any) acquire the lock. 22 Readers-writers lock with monitors Problems with locks 23 Lock free 24 Lock-free Object readSomething() { return atomicReference.get(); } Void writeSomething(Object new_object) { Object old_object; do { old_object = atomicReference.get(); // Check if we want to overwrite the latest data (i.e. only write newer or better data) if ( … ) { return; } } while (!atomicReference.compareAndSet(old_object, new_object)); } 25","libVersion":"0.3.2","langs":""}