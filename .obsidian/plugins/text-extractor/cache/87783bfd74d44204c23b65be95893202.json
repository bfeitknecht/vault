{"path":"sem3/EProg/PV/exams/program/FS24.pdf","text":"Frühjahr 2024 252-0027 – Einführung in die Programmierung Departement Informatik ETH Zürich 30. August 2024 – Programmieren Nachname: Vorname: Legi-Nummer: – – Computer: slab Sie dürfen diese Prüfung oder die schriftliche Prüfung erst öffnen nachdem die Aufsicht die Prüfung gestartet hat. Wenn Sie diese Dokumente vorher öffnen gilt dies als Täuschungsversuch. Mit Ihrer Unterschrift bestätigen Sie, dass Sie die hier aufgeführte Person sind, Sie die Hinweise zur Kenntnis genommen haben, Sie die Aufgaben selbständig bearbeitet haben, Sie Ihre eigene Lösung abgeben, Sie keine Kopie der Prüfung mitnehmen, Sie alle technischen Probleme und etwaige störende äussere Einflüsse gemeldet haben bzw. wissen, dass Sie diese melden sollen, und dass Sie keine gesundheitlichen Probleme hatten, die Ihre Leistungen in dieser Prüfung beeinträchtigten. Unterschrift: Bitte lassen Sie unbedingt die unterschriebene Aufgabenstellung mit der Nummer des Computers auf Ihrem Tisch - wir sammeln diese später ein. Hinweise 1. Bitte schreiben Sie Ihren Namen und Legi-Nummer sowie die Nummer ihres Computers (finden Sie auf dem Computer) auf diese Seite. Vergessen Sie nicht die Unterschrift am Ende der Prüfung. 2. Während der Programmierprüfung dürfen Sie nicht mehr an der schriftlichen Prüfung weiterarbeiten, auch wenn diese noch nicht eingezogen worden ist. Dies gilt als Täuschungsversuch. 3. Die Prüfung hat 14 Seiten. Vergewissern Sie sich dass Ihr Exemplar vollständig ist. Die letzten drei Seiten können Sie für Skizzen o.ä. benutzen, aber diese werden nicht für die Benotung hinzugezogen. 4. Die Programmierprüfung dauert 2 Stunden (120 Minuten). Falls Sie sich durch irgendjemanden oder irgendetwas gestört fühlen, oder technische Probleme an Ihrem Computer auftreten, so melden Sie dies sofort der Aufsicht. (Falls es unerwartete Fehlermeldungen gibt: Lassen Sie solche Fehlermeldungen oder PopUp Nachrichten auf dem Bildschirm und informieren Sie die Aufsicht. Nur so verhindern Sie, dass durch Systemfehler Ihre Programme verändert werden.) Sollten Sie durch die Behandlung eines technischen Problems Zeit verlieren, so werden Sie die verlorene Zeit nachholen können. 5. Wir beantworten keine inhaltlichen Fragen während der Prüfung. 6. Die Benutzung elektronischer Geräte während der Prüfung ist nicht erlaubt; diese müssen während der Prüfung unerreichbar deponiert werden. 7. Lesen Sie die Aufgabenstellungen genau durch. Es ist wichtig, dass Ihre Antworten den Anforderungen der Aufgaben genau entsprechen. Wenn die Aufgabenstellung etwas nicht spezifiert, dann können Sie frei entscheiden (wir testen nur was wir spezifizieren). Class.name() heisst Methode name() in Klasse Class. 8. Benutzen Sie die Anzahl der Sterne in der Programmierprüfung als Hinweis, der ungefähr den Aufwand und die erreichbare Punktzahl der Aufgabe widerspiegelt. Je mehr Sterne, desto aufwändiger. 9. Für jede Aufgabe gibt es ein separates Java-Projekt in Ihrem Eclipse-Workspace. Sie können die Aufgaben in beliebiger Reihenfolge lösen. 10. Die Programmieraufgaben werden vorwiegend automatisch getestet und bewertet. Programme, welche nicht mindestens teilweise ein korrektes Resultat zurückgeben (oder gar nicht erst kompilieren), erhalten keine Punkte. 11. Stellen Sie regelmässig sicher, dass Ihre Dateien im Workspace gespeichert sind. Nur diese Dateien werden von einem Backup-Prozess während der Prüfung gespeichert. Was nicht gespeichert ist, kann nicht bewertet werden. 12. Sollten Sie eine Ihrer Lösungsdateien überschreiben, so kann die Aufsicht Ihnen helfen! Melden Sie sich sofort. 13. Ändern Sie unter keinen Umständen die Signaturen der im Aufgabentext erwähnten Methoden (Name, Typ und Reihenfolge der Parameter), ihren Rückgabetyp, Modifizierer wie static, public oder gegebenfalls die Liste der geworfenen Exceptions. Das gleiche gilt für Konstruktoren und Attribute. Auch die Namen der erwähnten Klassen dürfen Sie nicht ändern und auch nicht Interfaces in Klassen umwandeln. Solche Änderungen können dazu führen, dass Sie keine Punkte für die Aufgabe erhalten. Wenn nicht anders vermerkt, dürfen Sie Methoden, Attribute, Interfaces oder Klassen zu den vorhandenen hinzufügen oder Klassen und Interfaces importieren. Die Verwendung von Java Reflection ist nicht erlaubt (und auch nicht von Vorteil). Java Assertions sind per default nicht aktiviert (auch nicht während der Bewertung). 14. Das Verwenden von static-Attributen ist grundsätzlich falsch. Rechnen Sie damit, dass wir das abgegebene Programm mehrfach ausführen (und ein Test selber aus mehreren Methodenaufrufen bestehen kann), ohne dass static-Attribute neu initialisiert werden. Lösungen, welche static-Attribute verwenden, und nur funktionieren, wenn ein Programm/eine Methode nur ein Mal ausgeführt wird, können potenziell 0 Punkte bekommen. 15. In jedem Projekt gibt es neben dem “src”-Ordner einen “test”-Ordner mit einigen JUnit-Tests. Wir empfehlen, diese mit ihren eigenen Tests zu erweitern. Tests werden nicht bewertet. 16. Falls gewisse Tests beim Ausführen scheinbar keine Resultate liefern, könnte es daran liegen, dass Ihre Lösung eine Endlosschleife enthält. Stoppen Sie in diesem Fall die Tests von Hand (siehe Hinweise zu Eclipse). 17. https://exam-translate.ethz.ch/ ist ein Übersetzungsservice, den wir ohne Gewähr zur Verfügung stellen. 18. Als zusätzliche Sicherheitsmassnahme wird Ihr Bildschirm während der Prüfung aufgezeichnet. 19. Wenn Sie in der IDE Zeichen ersetzen statt einfügen, dann drücken Sie die Insert Taste (über der Delete Taste). 20. Auf einer Schweizer Tastatur schreiben Sie eckige und geschweifte Klammern durch die “Alt Gr” Taste + die entsprechende Taste links über oder neben der Enter Taste. 21. Wenn Sie zur Toilette müssen, melden Sie dies einer Aufsichtsperson durch Handzeichen. Es darf zur gleichen Zeit immer nur eine Person zur Toilette. 22. Wenn Sie früher abgeben wollen, sperren Sie bitte Ihren Computer (Windows+L) und melden Sie sich bitte lautlos bei der Aufsicht. Die Aufsicht wird Ihnen sagen, wann Sie Ihren Arbeitsplatz verlassen können. Vorzeitige Abgaben sind nur bis 20 Minuten vor Prüfungsende möglich. 23. Wenn die Aufsicht die Prüfung beendet, vergewissern Sie sich, dass alle Dateien gespeichert sind. Nach der Sperrung der Computer können Sie keine weiteren Änderungen mehr vornehmen. 24. Verlassen Sie bitte den Prüfungsraum leise nach der Prüfung; auch vor dem Prüfungsraum bitten wir um Ruhe. Es kann sein, dass andere Studierende noch weiterarbeiten, da sie eine Zeitgutschrift bekommen haben. Auch diese Studierenden sollen in Ruhe arbeiten können. Bitte lassen Sie unbedingt die unterschriebene Aufgabenstellung mit der Nummer des Computers auf Ihrem Tisch - wir sammeln diese später ein. Page 2 of 14 Anmelden und Eclipse starten Bitte befolgen Sie diese vier Schritte um Eclipse zu starten: 1. Sobald die Programmierprüfung startet, können Sie sich an Ihrem Computer anmelden. Geben Sie zuerst Ihren vollen Namen und im nächsten Schritt Ihren NETHZ-Namen und Ihre Legi-Nummer ein. (Sie brauchen nicht Ihr NETHZ-Passwort.) Sie werden auch in einem weiteren Fenster darauf hingewiesen, dass Ihr Computer aufgezeichnet wird, und dass Sie technische Probleme sofort melden müssen. Sobald Sie angemeldet sind, erscheint ein Browsertab mit allgemeinen Hinweisen zur Computer-Prüfung. 2. Wichtig: Starten Sie Eclipse, indem Sie (1) oben links auf “Activities” klicken, dann (2) den Datei-Explorer öffnen. Navigieren Sie dann zu (3) “questions”. In diesem Ordner finden Sie ein Skript namens “start- eclipse.sh”. Führen Sie dieses Skript aus, indem Sie (4) darauf rechtsklicken und “Run as a Program” (oder ähnlich) auswählen. 1 3 4 2 Das Skript öffnet sowohl Eclipse als auch ein Terminal-Fenster, in dem Sie die Ausgabe von Eclipse sehen können. Schliessen Sie das Terminal-Fenster nicht, da Eclipse sonst ebenfalls beendet wird. Sollten Sie Eclipse versehentlich schliessen, können Sie es erneut starten, indem Sie das Skript erneut ausführen. 3. Wenn sich das Fenster “Eclipse IDE Launcher” öffnet, müssen Sie zuerst den Eclipse-Workspace Ordner im Feld “Workspace” anpassen (der Standardpfad, welcher im Fenster automatisch angegeben wird, ist inkorrekt): (1) klicken Sie auf “Browse...”, (2) wählen Sie dann im Auswahldialog den “questions”- Ordner aus, (3) klicken Sie oben rechts auf “Open” und (4) klicken Sie unten rechts auf “Launch”. Im Feld “Workspace” sollte folgender Pfad stehen, bevor Sie auf “Launch” klicken: /var/lib/exam/student/questions 4. Wenn Eclipse fertig gestartet ist, sehen Sie den Willkommens-Bildschirm. Klicken Sie wenn nötig oben rechts auf “Workbench”. Nun sollten Sie links die drei Projekte “Aufgabe 1”, “Aufgabe 2” und “Aufgabe 3” sehen. Es kann einige Minuten dauern bis Eclipse alles geladen hat. Warten Sie bis die Ladenachricht “Initializing Java Tooling” (unten rechts in Eclipse) nicht mehr sichtbar ist. Zusätzlich können Sie auf die Java Dokumentation zugreifen, indem Sie oben links auf die “Activities” gehen, dann unten auf das “Files” Icon klicken, dann auf “documentation” klicken und schlussendlich “index.html” öffnen, was die Dokumentation in einem Browser öffnet. Allgemeine Hinweise zur Computer- Prüfung können Sie lesen, indem Sie oben links auf die “Activities” gehen und auf das Informationsicon klicken. Viel Spass! Page 4 of 14 Hinweise zu Eclipse Verhindern von Abstürzen Bevor Sie ein Programm oder einen Test ausführen, achten Sie darauf, dass alle anderen Programme und Tests korrekt terminiert wurden. Wenn zu viele Programme gleichzeitig laufen, dann wird Ihr Computer langsamer, manchmal einfrieren, und im schlimmsten Fall abstürzen. Auch verhält sich dann manchmal Eclipse oder der Debugger unnatürlich. Das geht von Ihrer Zeit ab. Ein Problem ist, dass, auch wenn die aktive Konsole mit terminiert wurde und somit ausgegraut ist ( ), es noch weitere Konsolen geben kann, welche immer noch laufen. Wenn das Icon vorhanden und nicht ausgegraut ist ( ), dann gibt es mehr als eine Konsole, was auch heisst, dass mehrere Programme oder Tests noch nicht terminiert sein können: Durch einen Klick auf den Pfeil von , wird eine Liste aller vorhandenen Konsolen angezeigt: Durch klicken von werden alle terminierten Konsolen geschlossen. Klicken Sie wiederholt und (oder ) bis ausgegraut oder verschwunden ist, um alle Programme und Tests zu terminieren und alle Konsolen zu schliessen. Javadoc Es gibt verschiedene Möglichkeiten die Javadoc Dokumentation zu öffnen. Eine komfortable Option ist den Javadoc View zu verwenden. Dieser sollte in einer der Tabs bei der Konsole zu sehen sein ( ). Falls der Tab nicht vorhanden ist, oder falls Sie den Tab einfach nicht finden, dann können Sie durch das drücken von Alt + Shift + Q und dann J den Tab öffnen. Alternativ können Sie auch im Quick Access Fenster (ganz oben rechts ) “Javadoc” eingeben und dann oder drücken. Wenn Sie den Javadoc View geöffnet haben, dann wird Ihnen die verfügbare Dokumentation von allem gezeigt das Sie anklicken. Zusätzlich, wenn Sie auf etwas zeigen, während Sie die Ctrl Taste gedrückt haben, dann können Sie sich die Declaration anzeigen lassen: Debugger Ob Sie den Debugger verwenden ist Ihre Entscheidung. Wir werden keine Fragen zum Debugger beantworten. Die Aufgaben sind auch gut ohne Debugger lösbar. Um in den Debugging Modus zu wechseln, klicken Sie den Debugger Knopf rechts neben dem Quick Access Fenster (ganz oben rechts ). Falls dieser Knopf nicht vorhanden ist, dann können Sie im Quick Access Fenster (ganz oben rechts ) “Debug” eingeben und dann drücken. Alternativ können Sie auch den Knopf direkt neben dem Quick Access Fenster drücken und dann “Debug” wählen . Page 5 of 14 Notizen Page 6 of 14 Aufgabe 1 (⋆) Implementieren Sie die Methode countAssimilated in der Klasse Matrix, welche eine 𝑚 × 𝑛-Matrix 𝐴 (mit 𝑚 > 2, 𝑛 > 2) von int-Werten als Input akzeptiert und einen int-Wert zurückgibt. Für alle Elemente 𝑎𝑖,𝑗 von 𝐴 gilt 𝑎𝑖,𝑗 ≠ 0. Diese Methode soll die Anzahl der an ihre Umgebung angepassten Elemente in der Input-Matrix 𝐴 berechnen und zurückgeben. Ein Element 𝑎𝑖,𝑗 von 𝐴 gilt als angepasst, wenn die Summe seiner direkten Nachbarn (vertikal, horizontal und diagonal, soweit in der Matrix 𝐴 definiert) ohne Rest durch 𝑎𝑖,𝑗 teilbar ist. Das heisst, dass ein Element 𝑎𝑖,𝑗 genau dann angepasst ist, wenn (𝑎𝑖 −1,𝑗 −1 + 𝑎𝑖 −1,𝑗 + 𝑎𝑖 −1,𝑗+1 + 𝑎𝑖,𝑗 −1 + 𝑎𝑖,𝑗+1 + 𝑎𝑖+1,𝑗 −1 + 𝑎𝑖+1,𝑗 + 𝑎𝑖+1,𝑗+1)%𝑎𝑖,𝑗 == 0 gilt. Wenn das Element 𝑎𝑥,𝑦 nicht existiert (da 𝑥 < 0 oder 𝑥 ≥ 𝑚, 𝑦 < 0, 𝑦 ≥ 𝑛), dann wird der Wert in der Berechnung durch 0 ersetzt. Ihre Implementation von countAssimilated(int[][] matrix) soll eine IllegalArgumentException werfen, wenn der Parameter matrix den Wert null hat oder nicht auf eine 𝑚 × 𝑛 Matrix (mit 𝑚 > 2, 𝑛 > 2) verweist. Sie können davon ausgehen, dass die Summe der Nachbarn sich ohne Overflow oder Underflow berechnen lässt. Hier sind ein paar Beispielaufrufe der Methode sowie das erwartete Ergebnis (im “test”-Ordner finden Sie die entsprechenden JUnit-Tests): 1. countAssimilated([[10, 10, 10], [10, 10, 10], [10, 10, 10]]): 9 2. countAssimilated([[5, 10, 3], [6, 9, 6], [3, 3, 15]]): 4 3. countAssimilated([[4, 7, 13], [-2, -12, 32], [20, 15, -8], [17, 3, 1111]]): 3 4. countAssimilated([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30]]): 15 Page 7 of 14 Aufgabe 2 (⋆⋆⋆) Die Klasse Node modelliert einen Knoten in einem gerichteten Graphen, wobei die Kanten eine Beschriftung haben (ein einzelner Buchstabe im Alphabet repräsentiert durch einen String). Das Attribut Node.neighbors speichert die ausgehenden Kanten als Map<String, Node>, wobei ein vorhandener Schlüssel der Kantenbe- schriftung entspricht und der zugehörige Wert dem Zielknoten der Kante entspricht. Ein Pfad in einem Graphen entspricht einer Sequenz von Kanten (𝑒1, 𝑒2, ..., 𝑒𝑘 ), wobei der Zielknoten von 𝑒𝑖 gleich dem Ursprungsknoten von 𝑒𝑖+1 entspricht (für 𝑖 ∈ {1, 2, ..., 𝑘 − 1}). Die Pfadbeschriftung entspricht der Konkatenierung 𝑏1𝑏2...𝑏𝑘 der Kantenbeschriftungen, wobei 𝑏𝑖 der Beschriftung von 𝑒𝑖 entspricht. In dieser Aufgabe geht es um Berechnungen in gerichteten Graphen, welche gerichtete Bäume modellieren. Ein Graph 𝐺 definiert durch alle erreichbaren Knoten und Kanten von einem Wurzelknoten 𝑢 modelliert einen gerichteten Baum genau dann, wenn es zwischen zwei Knoten in 𝐺 maximal einen Pfad gibt. Der Wurzelpfad für einen Knoten 𝑣 in 𝐺 ist der (einzigartige) Pfad von 𝑢 nach 𝑣. Die zugehörige Pfadbeschriftung nennen wir die Wurzelbeschriftung von 𝑣. Die folgende Abbildung zeigt zwei Beispiele für gerichtete Bäume mit Wurzelknoten 𝑛0: n0 n1 n2 “c”“b” n4 n8 n5 “y” “a” “c” “a” “y” Graph.reverseLeaves(n0) n7 “b”“c” “z” n10 n3 n6 n0 n1 n2 “c”“b” n4 “y” “a” “c” “a” “y” “b”“c” “z” n3 n6 n8n10 n7 n5 n9 n9 Die Pfadbeschriftung des Wurzelpfades von 𝑛8 ist yac im linken Graph und cay im rechten Graph. (a) (⋆) Implementieren Sie die Methode Graph.reverseLeaves(Node n), wobei der vom Wurzelknoten n definierte Graph 𝐺 einen gerichteten Baum modelliert. Die Methode sollte 𝐺 ändern, so dass für jeden Blattknoten 𝑢 in 𝐺 (d.h. 𝑢 hat keine ausgehenden Kante) folgende Bedingung gilt: Sei 𝑠𝑢 die Wurzelbe- schriftung von 𝑢 vor dem Methodenaufruf. Wenn es vor dem Methodenaufruf einen Blattknoten 𝑣 in 𝐺 mit Wurzelbeschriftung 𝑠𝑣 gibt, wobei 𝑠𝑣 der Umkehrung von 𝑠𝑢 entspricht, dann müssen nach dem Methodenaufruf die Knoten 𝑢 und 𝑣 (bzw. die Node-Objekte) in 𝐺 vertauscht werden. Das heisst, nach dem Methodenaufruf muss Knoten 𝑢 die Wurzelbeschriftung 𝑠𝑣 haben und Knoten 𝑣 muss die Wurzelbe- schriftung 𝑠𝑢 haben. Wenn es keinen solchen Blattknoten 𝑣 gibt, dann muss nach dem Methodenaufruf die Wurzelbeschriftung von 𝑢 immer noch 𝑠𝑢 sein. Für alle Knoten 𝑤, welche nicht Blattknoten sind, muss die Wurzelbeschriftung nach dem Methodenaufruf gleich sein wie vor dem Methodenaufruf. Page 8 of 14 Die Abbildung oben zeigt ein Beispiel für den Effekt von Graph.reverseLeaves(𝑛0) (dieses Beispiel wird vom JUnit-Test GraphComputationTest.testExampleA() im “test”-Ordner getestet). Der linke Graph zeigt die Situation vor dem Methodenaufruf und der rechte Graph zeigt die Situation nach dem Metho- denaufruf. Vor dem Aufruf ist Wurzelbeschriftung vom Blattknoten 𝑛8 yac und die Wurzelbeschriftung vom Blattknoten 𝑛10 ist genau die Umkehrung cay. Deswegen werden 𝑛8 und 𝑛10 vertauscht, so dass nach dem Methodenaufruf, die Wurzelbeschriftung von 𝑛8 cay und die Wurzelbeschriftung von 𝑛10 yac ist. Die Blattknoten 𝑛5 (Wurzelbeschriftung bc vorher) und 𝑛7 (Wurzelbeschriftung cb vorher) werden auch vertauscht. Der Blattknoten 𝑛9 behält die gleiche Wurzelbeschriftung caz, da es vor dem Aufruf keinen Blattknoten mit Wurzelbeschriftung zac gibt. (b) (⋆) Implementieren Sie die Methode Graph.findPaths(Node [] roots), wobei Sie für alle 𝑖 mit 0 ≤ 𝑖 < roots.length annehmen dürfen, dass: (1) der von Wurzelknoten roots[𝑖] definierte Graph einen gerichteten Baum mit mindestens einer Kante modelliert und (2) für alle 𝑗 mit 𝑖 ≠ 𝑗 und 0 ≤ 𝑗 < roots.length gilt, dass die zwei von roots[𝑖] und roots[ 𝑗] definierten Graphen keine gemeinsamen Knoten haben. Die Methode muss eine bestimmte Menge von Strings zurückgeben. Ein String 𝑠 muss in der zurückgege- ben Menge genau dann enthalten sein, wenn folgende Bedingungen gelten: • 𝑠 muss eine Konkatenierung von 𝑛 Pfadbeschriftungen sein, wobei es zwischen zwei Pfadbe- schriftungen einen Spezialcharakter # geben muss. Das heisst, 𝑠 = 𝑠0#𝑠1# · · · #𝑠𝑛−1, wobei 𝑠𝑖 der Wurzelbeschriftung eines Blattknotens mit Wurzelknoten roots[𝑖] entspricht. • Für alle 𝑖 mit 2 ≤ 𝑖 < 𝑛 muss gelten, dass 𝑠𝑖 lexikographisch mindestens so gross ist wie 𝑠𝑖 −2 ist (in Java ist ein String a lexikographisch mindestens so gross wie b genau dann, wenn a.compareTo(b) >= 0 gilt). Als Beispiel betrachten wir den Aufruf Graph.findPaths(new Node [] {𝑚0,𝑛0,𝑟0}), wobei die fol- gende Abbildung die drei zugehörigen gerichteten Bäume zeigt (dieses Beispiel wird vom JUnit-Test GraphComputationTest.testExampleB() im “test”-Ordner getestet): m0 m1 m2 “e” “b” m3 “c” n0 n1 “a” r0 r1 “d” r2 “a” n2 “h” In diesem Fall sollte die Methode die Menge {bc#a#da,bc#h#da} zurückgeben. Beachten Sie, dass die Menge keinen String der Form e#... enthält, weil der einzige Pfad zu einem Blattknoten vom Wurzelknoten 𝑟0 die Pfadbeschriftung da hat, welche lexikographisch nicht mindestens so gross ist wie e (d.h. die zweite Bedingung oben würde nicht gelten). Page 9 of 14 Aufgabe 3 (⋆⋆⋆) Für diese Aufgabe sollen Sie ein Rechnungssystem für die Produktionslinie des ChronoCruiser 3000 entwickeln. Je nach Konfiguration des ChronoCruiser 3000 müssen verschiedene Fahrzeugkomponenten verbaut werden. Da verschiedene Komponenten jedoch durch verschiedene Zulieferungsunternehmen produziert werden, müssen sowohl deren Produktionskosten als auch die durch den Einbau entstehende Mehrwertsteuer berechnet werden. Im bereitgestellten Projekt finden Sie vier Klassen Cost, Component, Factory und Part. Cost ist eine einfache Klasse, welche sowohl die Produktionskosten (Attribut productionCost), die Mehrwert- steuer 1 (Attribut vat), als auch die Luxussteuer (Attribut luxuryTax, Teil (b)) eines Produkts speichert. Die Attribute sind alle vom Typ int. Component ist ein Interface, welches eine Methode process(Cost c) definiert. Die Methode process modifiziert das gegebene Cost-Objekt so, dass die Produktionskosten und Steuern nach der Verarbeitung der Komponente in c hinterlegt sind. Factory enthält eine statische Methode computeCost. Diese Methode erhält eine Liste von Component-Objekten und gibt ein Cost-Objekt zurück, welches die finalen Produktionskosten, die Mehrwertsteuer und (in Teil (b)) die Luxussteuer des Endprodukts speichert. Für die Berechnung dieses Objekts iteriert die Methode über die gegebenen Component-Objekte und ruft für jedes Objekt die Methode process auf. Die Luxussteuer ist nur relevant für Teil (b). Part ist eine Klasse für Component-Bauteile, welche als Basis für verschiedene Unterklassen dient. Jede dieser Unterklassen implementiert die Methode process so, dass die Produktionskosten und Steuern verschiedener Bauteile, wie in der folgenden Tabelle beschrieben, berechnet werden. Komponente Produktionskosten MWSt Flügeltüren 2000 3% Fluxkompensator Verdopplung der aktuellen Produktionskosten 7% Schwebeumwandlung 20% Erhöhung 10% Einklappbare Räder Erhöhung um 7000 bis zur Obergrenze 100000 7% Outatime-Kennzeichen Erhöhung um 100, aber mindestens auf 50000 10% Berechnungsbeispiel Die Gesamtkosten für einen ChronoCruiser werden kumulativ berechnet und dann in einem Cost-Objekt gespeichert, abhängig von den verbauten Komponenten. Nehmen wir zum Beispiel an, dass die aktuellen Produktionskosten 𝑥 und ein Mehrwertsteuerbetrag von 𝑡 schon berechnet wurden. Wird nun eine Schwebeumwandlung verbaut, dann werden die Produktionskosten um 20% auf 1.2 · 𝑥 erhöht. Zudem wird eine Mehrwertsteuer auf die Differenz der neuen und alten Produktionskosten berechnet, also (1.2 · 𝑥 − 𝑥) · 10% (siehe Mehrwertsteuersatz der Schwebeumwandlung). Der Gesamtbetrag der Mehrwertsteuer ensteht also aus diesem neuen Betrag und dem alten Mehrwertsteuerbetrag 𝑡 neu = (1.2 · 𝑥 − 𝑥) · 10% + 𝑡. Sie sollen in allen Teilaufgaben int-Arithmetik für die Berechnungen verwenden. 1MWSt, “value added tax” Page 10 of 14 Aufgaben Bearbeiten Sie nun die folgenden Teilaufgaben: (a) (⋆) Kostenberechnung Implementieren Sie die process-Methode für die gegebenen Part-Unterklassen aus der Tabelle oben, sodass die Produktionskosten und die Mehrwertsteuer der Komponente entspre- chend der angegebenen Werte in Cost gespeichert werden. Zur Berechnung der Gesamtkosten wird dabei die Methode Factory.computeCost verwendet, welche bereits gegeben ist. (b) (⋆) Luxussteuern Erweitern Sie Ihre Implementierung so, dass die Methode computeCost nach Berech- nung der gesamten Kosten eine zusätzliche Luxussteuer in Cost.luxuryTax speichert. Die Luxussteuer wird nur erhoben, wenn die folgenden zwei neuen Komponenten verbaut werden: Komponente Produktionskosten MWSt Luxussteuer First-Edition-Fluxkompensator wie ein regulärer “Fluxkompensator” in Teil (a) 5% Verchromte Räder wie reguläre “Einklappbare Räder” in Teil (a) 5% Die Luxussteuer berechnet sich als 5% der Gesamtkosten des Endprodukts, falls mindestens eine der beiden Luxuskomponenten verbaut wurde. Hierbei spielt die Reihenfolge der Luxuskomponenten keine Rolle. Beim Einbau mehrerer Luxuskomponenten wird trotzdem nur eine einmalige Luxussteuer auf die Gesamtkosten erhoben. (c) (⋆) Konfigurationsfehler Erweitern Sie die Methode computeCost so, dass eine IllegalArgumentException geworfen wird, falls die Liste an Komponenten einen der folgenden Konfigurationsfehler aufweist: • Es wurde mehr als ein Fluxkompensator verbaut. • Es wurde eine Schwebeumwandlung verbaut, nachdem bereits ein Fluxkompensator verbaut wurde. • Es wurde ein Outatime-Kennzeichen verbaut, nachdem bereits ein Fluxkompensator verbaut wurde. Beachten Sie, dass diese Konfigurationsfehler die Luxuskomponenten aus Teil (b) nicht betreffen. Zum Beispiel ist es erlaubt, sowohl einen First-Edition-Fluxkompensator als auch einen regulären Fluxkom- pensator zu verbauen, nur nicht mehr als einen reguläre Fluxkompensator. Sie finden einige Testfälle für die jeweiligen Teilaufgaben in der Klasse FactoryTest im “test”-Ordner, welche Sie für eine erste Überprüfung Ihrer Implementierung verwenden können. Beachten Sie allerdings, dass die Testfälle nicht vollständig sind. Page 11 of 14 Notizen Page 12 of 14 Notizen Page 13 of 14 Notizen Page 14 of 14","libVersion":"0.5.0","langs":""}