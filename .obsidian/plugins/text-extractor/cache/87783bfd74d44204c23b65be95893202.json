{"path":"sem3/EProg/PV/exams/program/FS24.pdf","text":"FrÃ¼hjahr 2024 252-0027 â€“ EinfÃ¼hrung in die Programmierung Departement Informatik ETH ZÃ¼rich 30. August 2024 â€“ Programmieren Nachname: Vorname: Legi-Nummer: â€“ â€“ Computer: slab Sie dÃ¼rfen diese PrÃ¼fung oder die schriftliche PrÃ¼fung erst Ã¶ffnen nachdem die Aufsicht die PrÃ¼fung gestartet hat. Wenn Sie diese Dokumente vorher Ã¶ffnen gilt dies als TÃ¤uschungsversuch. Mit Ihrer Unterschrift bestÃ¤tigen Sie, dass Sie die hier aufgefÃ¼hrte Person sind, Sie die Hinweise zur Kenntnis genommen haben, Sie die Aufgaben selbstÃ¤ndig bearbeitet haben, Sie Ihre eigene LÃ¶sung abgeben, Sie keine Kopie der PrÃ¼fung mitnehmen, Sie alle technischen Probleme und etwaige stÃ¶rende Ã¤ussere EinflÃ¼sse gemeldet haben bzw. wissen, dass Sie diese melden sollen, und dass Sie keine gesundheitlichen Probleme hatten, die Ihre Leistungen in dieser PrÃ¼fung beeintrÃ¤chtigten. Unterschrift: Bitte lassen Sie unbedingt die unterschriebene Aufgabenstellung mit der Nummer des Computers auf Ihrem Tisch - wir sammeln diese spÃ¤ter ein. Hinweise 1. Bitte schreiben Sie Ihren Namen und Legi-Nummer sowie die Nummer ihres Computers (finden Sie auf dem Computer) auf diese Seite. Vergessen Sie nicht die Unterschrift am Ende der PrÃ¼fung. 2. WÃ¤hrend der ProgrammierprÃ¼fung dÃ¼rfen Sie nicht mehr an der schriftlichen PrÃ¼fung weiterarbeiten, auch wenn diese noch nicht eingezogen worden ist. Dies gilt als TÃ¤uschungsversuch. 3. Die PrÃ¼fung hat 14 Seiten. Vergewissern Sie sich dass Ihr Exemplar vollstÃ¤ndig ist. Die letzten drei Seiten kÃ¶nnen Sie fÃ¼r Skizzen o.Ã¤. benutzen, aber diese werden nicht fÃ¼r die Benotung hinzugezogen. 4. Die ProgrammierprÃ¼fung dauert 2 Stunden (120 Minuten). Falls Sie sich durch irgendjemanden oder irgendetwas gestÃ¶rt fÃ¼hlen, oder technische Probleme an Ihrem Computer auftreten, so melden Sie dies sofort der Aufsicht. (Falls es unerwartete Fehlermeldungen gibt: Lassen Sie solche Fehlermeldungen oder PopUp Nachrichten auf dem Bildschirm und informieren Sie die Aufsicht. Nur so verhindern Sie, dass durch Systemfehler Ihre Programme verÃ¤ndert werden.) Sollten Sie durch die Behandlung eines technischen Problems Zeit verlieren, so werden Sie die verlorene Zeit nachholen kÃ¶nnen. 5. Wir beantworten keine inhaltlichen Fragen wÃ¤hrend der PrÃ¼fung. 6. Die Benutzung elektronischer GerÃ¤te wÃ¤hrend der PrÃ¼fung ist nicht erlaubt; diese mÃ¼ssen wÃ¤hrend der PrÃ¼fung unerreichbar deponiert werden. 7. Lesen Sie die Aufgabenstellungen genau durch. Es ist wichtig, dass Ihre Antworten den Anforderungen der Aufgaben genau entsprechen. Wenn die Aufgabenstellung etwas nicht spezifiert, dann kÃ¶nnen Sie frei entscheiden (wir testen nur was wir spezifizieren). Class.name() heisst Methode name() in Klasse Class. 8. Benutzen Sie die Anzahl der Sterne in der ProgrammierprÃ¼fung als Hinweis, der ungefÃ¤hr den Aufwand und die erreichbare Punktzahl der Aufgabe widerspiegelt. Je mehr Sterne, desto aufwÃ¤ndiger. 9. FÃ¼r jede Aufgabe gibt es ein separates Java-Projekt in Ihrem Eclipse-Workspace. Sie kÃ¶nnen die Aufgaben in beliebiger Reihenfolge lÃ¶sen. 10. Die Programmieraufgaben werden vorwiegend automatisch getestet und bewertet. Programme, welche nicht mindestens teilweise ein korrektes Resultat zurÃ¼ckgeben (oder gar nicht erst kompilieren), erhalten keine Punkte. 11. Stellen Sie regelmÃ¤ssig sicher, dass Ihre Dateien im Workspace gespeichert sind. Nur diese Dateien werden von einem Backup-Prozess wÃ¤hrend der PrÃ¼fung gespeichert. Was nicht gespeichert ist, kann nicht bewertet werden. 12. Sollten Sie eine Ihrer LÃ¶sungsdateien Ã¼berschreiben, so kann die Aufsicht Ihnen helfen! Melden Sie sich sofort. 13. Ã„ndern Sie unter keinen UmstÃ¤nden die Signaturen der im Aufgabentext erwÃ¤hnten Methoden (Name, Typ und Reihenfolge der Parameter), ihren RÃ¼ckgabetyp, Modifizierer wie static, public oder gegebenfalls die Liste der geworfenen Exceptions. Das gleiche gilt fÃ¼r Konstruktoren und Attribute. Auch die Namen der erwÃ¤hnten Klassen dÃ¼rfen Sie nicht Ã¤ndern und auch nicht Interfaces in Klassen umwandeln. Solche Ã„nderungen kÃ¶nnen dazu fÃ¼hren, dass Sie keine Punkte fÃ¼r die Aufgabe erhalten. Wenn nicht anders vermerkt, dÃ¼rfen Sie Methoden, Attribute, Interfaces oder Klassen zu den vorhandenen hinzufÃ¼gen oder Klassen und Interfaces importieren. Die Verwendung von Java Reflection ist nicht erlaubt (und auch nicht von Vorteil). Java Assertions sind per default nicht aktiviert (auch nicht wÃ¤hrend der Bewertung). 14. Das Verwenden von static-Attributen ist grundsÃ¤tzlich falsch. Rechnen Sie damit, dass wir das abgegebene Programm mehrfach ausfÃ¼hren (und ein Test selber aus mehreren Methodenaufrufen bestehen kann), ohne dass static-Attribute neu initialisiert werden. LÃ¶sungen, welche static-Attribute verwenden, und nur funktionieren, wenn ein Programm/eine Methode nur ein Mal ausgefÃ¼hrt wird, kÃ¶nnen potenziell 0 Punkte bekommen. 15. In jedem Projekt gibt es neben dem â€œsrcâ€-Ordner einen â€œtestâ€-Ordner mit einigen JUnit-Tests. Wir empfehlen, diese mit ihren eigenen Tests zu erweitern. Tests werden nicht bewertet. 16. Falls gewisse Tests beim AusfÃ¼hren scheinbar keine Resultate liefern, kÃ¶nnte es daran liegen, dass Ihre LÃ¶sung eine Endlosschleife enthÃ¤lt. Stoppen Sie in diesem Fall die Tests von Hand (siehe Hinweise zu Eclipse). 17. https://exam-translate.ethz.ch/ ist ein Ãœbersetzungsservice, den wir ohne GewÃ¤hr zur VerfÃ¼gung stellen. 18. Als zusÃ¤tzliche Sicherheitsmassnahme wird Ihr Bildschirm wÃ¤hrend der PrÃ¼fung aufgezeichnet. 19. Wenn Sie in der IDE Zeichen ersetzen statt einfÃ¼gen, dann drÃ¼cken Sie die Insert Taste (Ã¼ber der Delete Taste). 20. Auf einer Schweizer Tastatur schreiben Sie eckige und geschweifte Klammern durch die â€œAlt Grâ€ Taste + die entsprechende Taste links Ã¼ber oder neben der Enter Taste. 21. Wenn Sie zur Toilette mÃ¼ssen, melden Sie dies einer Aufsichtsperson durch Handzeichen. Es darf zur gleichen Zeit immer nur eine Person zur Toilette. 22. Wenn Sie frÃ¼her abgeben wollen, sperren Sie bitte Ihren Computer (Windows+L) und melden Sie sich bitte lautlos bei der Aufsicht. Die Aufsicht wird Ihnen sagen, wann Sie Ihren Arbeitsplatz verlassen kÃ¶nnen. Vorzeitige Abgaben sind nur bis 20 Minuten vor PrÃ¼fungsende mÃ¶glich. 23. Wenn die Aufsicht die PrÃ¼fung beendet, vergewissern Sie sich, dass alle Dateien gespeichert sind. Nach der Sperrung der Computer kÃ¶nnen Sie keine weiteren Ã„nderungen mehr vornehmen. 24. Verlassen Sie bitte den PrÃ¼fungsraum leise nach der PrÃ¼fung; auch vor dem PrÃ¼fungsraum bitten wir um Ruhe. Es kann sein, dass andere Studierende noch weiterarbeiten, da sie eine Zeitgutschrift bekommen haben. Auch diese Studierenden sollen in Ruhe arbeiten kÃ¶nnen. Bitte lassen Sie unbedingt die unterschriebene Aufgabenstellung mit der Nummer des Computers auf Ihrem Tisch - wir sammeln diese spÃ¤ter ein. Page 2 of 14 Anmelden und Eclipse starten Bitte befolgen Sie diese vier Schritte um Eclipse zu starten: 1. Sobald die ProgrammierprÃ¼fung startet, kÃ¶nnen Sie sich an Ihrem Computer anmelden. Geben Sie zuerst Ihren vollen Namen und im nÃ¤chsten Schritt Ihren NETHZ-Namen und Ihre Legi-Nummer ein. (Sie brauchen nicht Ihr NETHZ-Passwort.) Sie werden auch in einem weiteren Fenster darauf hingewiesen, dass Ihr Computer aufgezeichnet wird, und dass Sie technische Probleme sofort melden mÃ¼ssen. Sobald Sie angemeldet sind, erscheint ein Browsertab mit allgemeinen Hinweisen zur Computer-PrÃ¼fung. 2. Wichtig: Starten Sie Eclipse, indem Sie (1) oben links auf â€œActivitiesâ€ klicken, dann (2) den Datei-Explorer Ã¶ffnen. Navigieren Sie dann zu (3) â€œquestionsâ€. In diesem Ordner finden Sie ein Skript namens â€œstart- eclipse.shâ€. FÃ¼hren Sie dieses Skript aus, indem Sie (4) darauf rechtsklicken und â€œRun as a Programâ€ (oder Ã¤hnlich) auswÃ¤hlen. 1 3 4 2 Das Skript Ã¶ffnet sowohl Eclipse als auch ein Terminal-Fenster, in dem Sie die Ausgabe von Eclipse sehen kÃ¶nnen. Schliessen Sie das Terminal-Fenster nicht, da Eclipse sonst ebenfalls beendet wird. Sollten Sie Eclipse versehentlich schliessen, kÃ¶nnen Sie es erneut starten, indem Sie das Skript erneut ausfÃ¼hren. 3. Wenn sich das Fenster â€œEclipse IDE Launcherâ€ Ã¶ffnet, mÃ¼ssen Sie zuerst den Eclipse-Workspace Ordner im Feld â€œWorkspaceâ€ anpassen (der Standardpfad, welcher im Fenster automatisch angegeben wird, ist inkorrekt): (1) klicken Sie auf â€œBrowse...â€, (2) wÃ¤hlen Sie dann im Auswahldialog den â€œquestionsâ€- Ordner aus, (3) klicken Sie oben rechts auf â€œOpenâ€ und (4) klicken Sie unten rechts auf â€œLaunchâ€. Im Feld â€œWorkspaceâ€ sollte folgender Pfad stehen, bevor Sie auf â€œLaunchâ€ klicken: /var/lib/exam/student/questions 4. Wenn Eclipse fertig gestartet ist, sehen Sie den Willkommens-Bildschirm. Klicken Sie wenn nÃ¶tig oben rechts auf â€œWorkbenchâ€. Nun sollten Sie links die drei Projekte â€œAufgabe 1â€, â€œAufgabe 2â€ und â€œAufgabe 3â€ sehen. Es kann einige Minuten dauern bis Eclipse alles geladen hat. Warten Sie bis die Ladenachricht â€œInitializing Java Toolingâ€ (unten rechts in Eclipse) nicht mehr sichtbar ist. ZusÃ¤tzlich kÃ¶nnen Sie auf die Java Dokumentation zugreifen, indem Sie oben links auf die â€œActivitiesâ€ gehen, dann unten auf das â€œFilesâ€ Icon klicken, dann auf â€œdocumentationâ€ klicken und schlussendlich â€œindex.htmlâ€ Ã¶ffnen, was die Dokumentation in einem Browser Ã¶ffnet. Allgemeine Hinweise zur Computer- PrÃ¼fung kÃ¶nnen Sie lesen, indem Sie oben links auf die â€œActivitiesâ€ gehen und auf das Informationsicon klicken. Viel Spass! Page 4 of 14 Hinweise zu Eclipse Verhindern von AbstÃ¼rzen Bevor Sie ein Programm oder einen Test ausfÃ¼hren, achten Sie darauf, dass alle anderen Programme und Tests korrekt terminiert wurden. Wenn zu viele Programme gleichzeitig laufen, dann wird Ihr Computer langsamer, manchmal einfrieren, und im schlimmsten Fall abstÃ¼rzen. Auch verhÃ¤lt sich dann manchmal Eclipse oder der Debugger unnatÃ¼rlich. Das geht von Ihrer Zeit ab. Ein Problem ist, dass, auch wenn die aktive Konsole mit terminiert wurde und somit ausgegraut ist ( ), es noch weitere Konsolen geben kann, welche immer noch laufen. Wenn das Icon vorhanden und nicht ausgegraut ist ( ), dann gibt es mehr als eine Konsole, was auch heisst, dass mehrere Programme oder Tests noch nicht terminiert sein kÃ¶nnen: Durch einen Klick auf den Pfeil von , wird eine Liste aller vorhandenen Konsolen angezeigt: Durch klicken von werden alle terminierten Konsolen geschlossen. Klicken Sie wiederholt und (oder ) bis ausgegraut oder verschwunden ist, um alle Programme und Tests zu terminieren und alle Konsolen zu schliessen. Javadoc Es gibt verschiedene MÃ¶glichkeiten die Javadoc Dokumentation zu Ã¶ffnen. Eine komfortable Option ist den Javadoc View zu verwenden. Dieser sollte in einer der Tabs bei der Konsole zu sehen sein ( ). Falls der Tab nicht vorhanden ist, oder falls Sie den Tab einfach nicht finden, dann kÃ¶nnen Sie durch das drÃ¼cken von Alt + Shift + Q und dann J den Tab Ã¶ffnen. Alternativ kÃ¶nnen Sie auch im Quick Access Fenster (ganz oben rechts ) â€œJavadocâ€ eingeben und dann oder drÃ¼cken. Wenn Sie den Javadoc View geÃ¶ffnet haben, dann wird Ihnen die verfÃ¼gbare Dokumentation von allem gezeigt das Sie anklicken. ZusÃ¤tzlich, wenn Sie auf etwas zeigen, wÃ¤hrend Sie die Ctrl Taste gedrÃ¼ckt haben, dann kÃ¶nnen Sie sich die Declaration anzeigen lassen: Debugger Ob Sie den Debugger verwenden ist Ihre Entscheidung. Wir werden keine Fragen zum Debugger beantworten. Die Aufgaben sind auch gut ohne Debugger lÃ¶sbar. Um in den Debugging Modus zu wechseln, klicken Sie den Debugger Knopf rechts neben dem Quick Access Fenster (ganz oben rechts ). Falls dieser Knopf nicht vorhanden ist, dann kÃ¶nnen Sie im Quick Access Fenster (ganz oben rechts ) â€œDebugâ€ eingeben und dann drÃ¼cken. Alternativ kÃ¶nnen Sie auch den Knopf direkt neben dem Quick Access Fenster drÃ¼cken und dann â€œDebugâ€ wÃ¤hlen . Page 5 of 14 Notizen Page 6 of 14 Aufgabe 1 (â‹†) Implementieren Sie die Methode countAssimilated in der Klasse Matrix, welche eine ğ‘š Ã— ğ‘›-Matrix ğ´ (mit ğ‘š > 2, ğ‘› > 2) von int-Werten als Input akzeptiert und einen int-Wert zurÃ¼ckgibt. FÃ¼r alle Elemente ğ‘ğ‘–,ğ‘— von ğ´ gilt ğ‘ğ‘–,ğ‘— â‰  0. Diese Methode soll die Anzahl der an ihre Umgebung angepassten Elemente in der Input-Matrix ğ´ berechnen und zurÃ¼ckgeben. Ein Element ğ‘ğ‘–,ğ‘— von ğ´ gilt als angepasst, wenn die Summe seiner direkten Nachbarn (vertikal, horizontal und diagonal, soweit in der Matrix ğ´ definiert) ohne Rest durch ğ‘ğ‘–,ğ‘— teilbar ist. Das heisst, dass ein Element ğ‘ğ‘–,ğ‘— genau dann angepasst ist, wenn (ğ‘ğ‘– âˆ’1,ğ‘— âˆ’1 + ğ‘ğ‘– âˆ’1,ğ‘— + ğ‘ğ‘– âˆ’1,ğ‘—+1 + ğ‘ğ‘–,ğ‘— âˆ’1 + ğ‘ğ‘–,ğ‘—+1 + ğ‘ğ‘–+1,ğ‘— âˆ’1 + ğ‘ğ‘–+1,ğ‘— + ğ‘ğ‘–+1,ğ‘—+1)%ğ‘ğ‘–,ğ‘— == 0 gilt. Wenn das Element ğ‘ğ‘¥,ğ‘¦ nicht existiert (da ğ‘¥ < 0 oder ğ‘¥ â‰¥ ğ‘š, ğ‘¦ < 0, ğ‘¦ â‰¥ ğ‘›), dann wird der Wert in der Berechnung durch 0 ersetzt. Ihre Implementation von countAssimilated(int[][] matrix) soll eine IllegalArgumentException werfen, wenn der Parameter matrix den Wert null hat oder nicht auf eine ğ‘š Ã— ğ‘› Matrix (mit ğ‘š > 2, ğ‘› > 2) verweist. Sie kÃ¶nnen davon ausgehen, dass die Summe der Nachbarn sich ohne Overflow oder Underflow berechnen lÃ¤sst. Hier sind ein paar Beispielaufrufe der Methode sowie das erwartete Ergebnis (im â€œtestâ€-Ordner finden Sie die entsprechenden JUnit-Tests): 1. countAssimilated([[10, 10, 10], [10, 10, 10], [10, 10, 10]]): 9 2. countAssimilated([[5, 10, 3], [6, 9, 6], [3, 3, 15]]): 4 3. countAssimilated([[4, 7, 13], [-2, -12, 32], [20, 15, -8], [17, 3, 1111]]): 3 4. countAssimilated([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30]]): 15 Page 7 of 14 Aufgabe 2 (â‹†â‹†â‹†) Die Klasse Node modelliert einen Knoten in einem gerichteten Graphen, wobei die Kanten eine Beschriftung haben (ein einzelner Buchstabe im Alphabet reprÃ¤sentiert durch einen String). Das Attribut Node.neighbors speichert die ausgehenden Kanten als Map<String, Node>, wobei ein vorhandener SchlÃ¼ssel der Kantenbe- schriftung entspricht und der zugehÃ¶rige Wert dem Zielknoten der Kante entspricht. Ein Pfad in einem Graphen entspricht einer Sequenz von Kanten (ğ‘’1, ğ‘’2, ..., ğ‘’ğ‘˜ ), wobei der Zielknoten von ğ‘’ğ‘– gleich dem Ursprungsknoten von ğ‘’ğ‘–+1 entspricht (fÃ¼r ğ‘– âˆˆ {1, 2, ..., ğ‘˜ âˆ’ 1}). Die Pfadbeschriftung entspricht der Konkatenierung ğ‘1ğ‘2...ğ‘ğ‘˜ der Kantenbeschriftungen, wobei ğ‘ğ‘– der Beschriftung von ğ‘’ğ‘– entspricht. In dieser Aufgabe geht es um Berechnungen in gerichteten Graphen, welche gerichtete BÃ¤ume modellieren. Ein Graph ğº definiert durch alle erreichbaren Knoten und Kanten von einem Wurzelknoten ğ‘¢ modelliert einen gerichteten Baum genau dann, wenn es zwischen zwei Knoten in ğº maximal einen Pfad gibt. Der Wurzelpfad fÃ¼r einen Knoten ğ‘£ in ğº ist der (einzigartige) Pfad von ğ‘¢ nach ğ‘£. Die zugehÃ¶rige Pfadbeschriftung nennen wir die Wurzelbeschriftung von ğ‘£. Die folgende Abbildung zeigt zwei Beispiele fÃ¼r gerichtete BÃ¤ume mit Wurzelknoten ğ‘›0: n0 n1 n2 â€œcâ€â€œbâ€ n4 n8 n5 â€œyâ€ â€œaâ€ â€œcâ€ â€œaâ€ â€œyâ€ Graph.reverseLeaves(n0) n7 â€œbâ€â€œcâ€ â€œzâ€ n10 n3 n6 n0 n1 n2 â€œcâ€â€œbâ€ n4 â€œyâ€ â€œaâ€ â€œcâ€ â€œaâ€ â€œyâ€ â€œbâ€â€œcâ€ â€œzâ€ n3 n6 n8n10 n7 n5 n9 n9 Die Pfadbeschriftung des Wurzelpfades von ğ‘›8 ist yac im linken Graph und cay im rechten Graph. (a) (â‹†) Implementieren Sie die Methode Graph.reverseLeaves(Node n), wobei der vom Wurzelknoten n definierte Graph ğº einen gerichteten Baum modelliert. Die Methode sollte ğº Ã¤ndern, so dass fÃ¼r jeden Blattknoten ğ‘¢ in ğº (d.h. ğ‘¢ hat keine ausgehenden Kante) folgende Bedingung gilt: Sei ğ‘ ğ‘¢ die Wurzelbe- schriftung von ğ‘¢ vor dem Methodenaufruf. Wenn es vor dem Methodenaufruf einen Blattknoten ğ‘£ in ğº mit Wurzelbeschriftung ğ‘ ğ‘£ gibt, wobei ğ‘ ğ‘£ der Umkehrung von ğ‘ ğ‘¢ entspricht, dann mÃ¼ssen nach dem Methodenaufruf die Knoten ğ‘¢ und ğ‘£ (bzw. die Node-Objekte) in ğº vertauscht werden. Das heisst, nach dem Methodenaufruf muss Knoten ğ‘¢ die Wurzelbeschriftung ğ‘ ğ‘£ haben und Knoten ğ‘£ muss die Wurzelbe- schriftung ğ‘ ğ‘¢ haben. Wenn es keinen solchen Blattknoten ğ‘£ gibt, dann muss nach dem Methodenaufruf die Wurzelbeschriftung von ğ‘¢ immer noch ğ‘ ğ‘¢ sein. FÃ¼r alle Knoten ğ‘¤, welche nicht Blattknoten sind, muss die Wurzelbeschriftung nach dem Methodenaufruf gleich sein wie vor dem Methodenaufruf. Page 8 of 14 Die Abbildung oben zeigt ein Beispiel fÃ¼r den Effekt von Graph.reverseLeaves(ğ‘›0) (dieses Beispiel wird vom JUnit-Test GraphComputationTest.testExampleA() im â€œtestâ€-Ordner getestet). Der linke Graph zeigt die Situation vor dem Methodenaufruf und der rechte Graph zeigt die Situation nach dem Metho- denaufruf. Vor dem Aufruf ist Wurzelbeschriftung vom Blattknoten ğ‘›8 yac und die Wurzelbeschriftung vom Blattknoten ğ‘›10 ist genau die Umkehrung cay. Deswegen werden ğ‘›8 und ğ‘›10 vertauscht, so dass nach dem Methodenaufruf, die Wurzelbeschriftung von ğ‘›8 cay und die Wurzelbeschriftung von ğ‘›10 yac ist. Die Blattknoten ğ‘›5 (Wurzelbeschriftung bc vorher) und ğ‘›7 (Wurzelbeschriftung cb vorher) werden auch vertauscht. Der Blattknoten ğ‘›9 behÃ¤lt die gleiche Wurzelbeschriftung caz, da es vor dem Aufruf keinen Blattknoten mit Wurzelbeschriftung zac gibt. (b) (â‹†) Implementieren Sie die Methode Graph.findPaths(Node [] roots), wobei Sie fÃ¼r alle ğ‘– mit 0 â‰¤ ğ‘– < roots.length annehmen dÃ¼rfen, dass: (1) der von Wurzelknoten roots[ğ‘–] definierte Graph einen gerichteten Baum mit mindestens einer Kante modelliert und (2) fÃ¼r alle ğ‘— mit ğ‘– â‰  ğ‘— und 0 â‰¤ ğ‘— < roots.length gilt, dass die zwei von roots[ğ‘–] und roots[ ğ‘—] definierten Graphen keine gemeinsamen Knoten haben. Die Methode muss eine bestimmte Menge von Strings zurÃ¼ckgeben. Ein String ğ‘  muss in der zurÃ¼ckgege- ben Menge genau dann enthalten sein, wenn folgende Bedingungen gelten: â€¢ ğ‘  muss eine Konkatenierung von ğ‘› Pfadbeschriftungen sein, wobei es zwischen zwei Pfadbe- schriftungen einen Spezialcharakter # geben muss. Das heisst, ğ‘  = ğ‘ 0#ğ‘ 1# Â· Â· Â· #ğ‘ ğ‘›âˆ’1, wobei ğ‘ ğ‘– der Wurzelbeschriftung eines Blattknotens mit Wurzelknoten roots[ğ‘–] entspricht. â€¢ FÃ¼r alle ğ‘– mit 2 â‰¤ ğ‘– < ğ‘› muss gelten, dass ğ‘ ğ‘– lexikographisch mindestens so gross ist wie ğ‘ ğ‘– âˆ’2 ist (in Java ist ein String a lexikographisch mindestens so gross wie b genau dann, wenn a.compareTo(b) >= 0 gilt). Als Beispiel betrachten wir den Aufruf Graph.findPaths(new Node [] {ğ‘š0,ğ‘›0,ğ‘Ÿ0}), wobei die fol- gende Abbildung die drei zugehÃ¶rigen gerichteten BÃ¤ume zeigt (dieses Beispiel wird vom JUnit-Test GraphComputationTest.testExampleB() im â€œtestâ€-Ordner getestet): m0 m1 m2 â€œeâ€ â€œbâ€ m3 â€œcâ€ n0 n1 â€œaâ€ r0 r1 â€œdâ€ r2 â€œaâ€ n2 â€œhâ€ In diesem Fall sollte die Methode die Menge {bc#a#da,bc#h#da} zurÃ¼ckgeben. Beachten Sie, dass die Menge keinen String der Form e#... enthÃ¤lt, weil der einzige Pfad zu einem Blattknoten vom Wurzelknoten ğ‘Ÿ0 die Pfadbeschriftung da hat, welche lexikographisch nicht mindestens so gross ist wie e (d.h. die zweite Bedingung oben wÃ¼rde nicht gelten). Page 9 of 14 Aufgabe 3 (â‹†â‹†â‹†) FÃ¼r diese Aufgabe sollen Sie ein Rechnungssystem fÃ¼r die Produktionslinie des ChronoCruiser 3000 entwickeln. Je nach Konfiguration des ChronoCruiser 3000 mÃ¼ssen verschiedene Fahrzeugkomponenten verbaut werden. Da verschiedene Komponenten jedoch durch verschiedene Zulieferungsunternehmen produziert werden, mÃ¼ssen sowohl deren Produktionskosten als auch die durch den Einbau entstehende Mehrwertsteuer berechnet werden. Im bereitgestellten Projekt finden Sie vier Klassen Cost, Component, Factory und Part. Cost ist eine einfache Klasse, welche sowohl die Produktionskosten (Attribut productionCost), die Mehrwert- steuer 1 (Attribut vat), als auch die Luxussteuer (Attribut luxuryTax, Teil (b)) eines Produkts speichert. Die Attribute sind alle vom Typ int. Component ist ein Interface, welches eine Methode process(Cost c) definiert. Die Methode process modifiziert das gegebene Cost-Objekt so, dass die Produktionskosten und Steuern nach der Verarbeitung der Komponente in c hinterlegt sind. Factory enthÃ¤lt eine statische Methode computeCost. Diese Methode erhÃ¤lt eine Liste von Component-Objekten und gibt ein Cost-Objekt zurÃ¼ck, welches die finalen Produktionskosten, die Mehrwertsteuer und (in Teil (b)) die Luxussteuer des Endprodukts speichert. FÃ¼r die Berechnung dieses Objekts iteriert die Methode Ã¼ber die gegebenen Component-Objekte und ruft fÃ¼r jedes Objekt die Methode process auf. Die Luxussteuer ist nur relevant fÃ¼r Teil (b). Part ist eine Klasse fÃ¼r Component-Bauteile, welche als Basis fÃ¼r verschiedene Unterklassen dient. Jede dieser Unterklassen implementiert die Methode process so, dass die Produktionskosten und Steuern verschiedener Bauteile, wie in der folgenden Tabelle beschrieben, berechnet werden. Komponente Produktionskosten MWSt FlÃ¼geltÃ¼ren 2000 3% Fluxkompensator Verdopplung der aktuellen Produktionskosten 7% Schwebeumwandlung 20% ErhÃ¶hung 10% Einklappbare RÃ¤der ErhÃ¶hung um 7000 bis zur Obergrenze 100000 7% Outatime-Kennzeichen ErhÃ¶hung um 100, aber mindestens auf 50000 10% Berechnungsbeispiel Die Gesamtkosten fÃ¼r einen ChronoCruiser werden kumulativ berechnet und dann in einem Cost-Objekt gespeichert, abhÃ¤ngig von den verbauten Komponenten. Nehmen wir zum Beispiel an, dass die aktuellen Produktionskosten ğ‘¥ und ein Mehrwertsteuerbetrag von ğ‘¡ schon berechnet wurden. Wird nun eine Schwebeumwandlung verbaut, dann werden die Produktionskosten um 20% auf 1.2 Â· ğ‘¥ erhÃ¶ht. Zudem wird eine Mehrwertsteuer auf die Differenz der neuen und alten Produktionskosten berechnet, also (1.2 Â· ğ‘¥ âˆ’ ğ‘¥) Â· 10% (siehe Mehrwertsteuersatz der Schwebeumwandlung). Der Gesamtbetrag der Mehrwertsteuer ensteht also aus diesem neuen Betrag und dem alten Mehrwertsteuerbetrag ğ‘¡ neu = (1.2 Â· ğ‘¥ âˆ’ ğ‘¥) Â· 10% + ğ‘¡. Sie sollen in allen Teilaufgaben int-Arithmetik fÃ¼r die Berechnungen verwenden. 1MWSt, â€œvalue added taxâ€ Page 10 of 14 Aufgaben Bearbeiten Sie nun die folgenden Teilaufgaben: (a) (â‹†) Kostenberechnung Implementieren Sie die process-Methode fÃ¼r die gegebenen Part-Unterklassen aus der Tabelle oben, sodass die Produktionskosten und die Mehrwertsteuer der Komponente entspre- chend der angegebenen Werte in Cost gespeichert werden. Zur Berechnung der Gesamtkosten wird dabei die Methode Factory.computeCost verwendet, welche bereits gegeben ist. (b) (â‹†) Luxussteuern Erweitern Sie Ihre Implementierung so, dass die Methode computeCost nach Berech- nung der gesamten Kosten eine zusÃ¤tzliche Luxussteuer in Cost.luxuryTax speichert. Die Luxussteuer wird nur erhoben, wenn die folgenden zwei neuen Komponenten verbaut werden: Komponente Produktionskosten MWSt Luxussteuer First-Edition-Fluxkompensator wie ein regulÃ¤rer â€œFluxkompensatorâ€ in Teil (a) 5% Verchromte RÃ¤der wie regulÃ¤re â€œEinklappbare RÃ¤derâ€ in Teil (a) 5% Die Luxussteuer berechnet sich als 5% der Gesamtkosten des Endprodukts, falls mindestens eine der beiden Luxuskomponenten verbaut wurde. Hierbei spielt die Reihenfolge der Luxuskomponenten keine Rolle. Beim Einbau mehrerer Luxuskomponenten wird trotzdem nur eine einmalige Luxussteuer auf die Gesamtkosten erhoben. (c) (â‹†) Konfigurationsfehler Erweitern Sie die Methode computeCost so, dass eine IllegalArgumentException geworfen wird, falls die Liste an Komponenten einen der folgenden Konfigurationsfehler aufweist: â€¢ Es wurde mehr als ein Fluxkompensator verbaut. â€¢ Es wurde eine Schwebeumwandlung verbaut, nachdem bereits ein Fluxkompensator verbaut wurde. â€¢ Es wurde ein Outatime-Kennzeichen verbaut, nachdem bereits ein Fluxkompensator verbaut wurde. Beachten Sie, dass diese Konfigurationsfehler die Luxuskomponenten aus Teil (b) nicht betreffen. Zum Beispiel ist es erlaubt, sowohl einen First-Edition-Fluxkompensator als auch einen regulÃ¤ren Fluxkom- pensator zu verbauen, nur nicht mehr als einen regulÃ¤re Fluxkompensator. Sie finden einige TestfÃ¤lle fÃ¼r die jeweiligen Teilaufgaben in der Klasse FactoryTest im â€œtestâ€-Ordner, welche Sie fÃ¼r eine erste ÃœberprÃ¼fung Ihrer Implementierung verwenden kÃ¶nnen. Beachten Sie allerdings, dass die TestfÃ¤lle nicht vollstÃ¤ndig sind. Page 11 of 14 Notizen Page 12 of 14 Notizen Page 13 of 14 Notizen Page 14 of 14","libVersion":"0.5.0","langs":""}