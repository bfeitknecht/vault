{"path":"sem3/A&D/VRL/extra/summaries/AuD-summary-graphs-kenji.pdf","text":"Graph Cheatsheet f¨ur Algorithmen und Datenstrukturen Kenji Nakano, HS23, Stand 17.12.2023 Keine Garantie f¨ur Vollst¨andigkeit oder Korrektheit Definition Graph Ein Graph ist ein Tupel G = (V, E) wobei • V := Knotenmenge (vertices) • E := Kantenmenge (edges) jede Kante ist ein ungeordnetes Paar zweier Knoten u ̸= v, e = {u, v} ∈ E (Kurzform: uv) Weg, Pfad, Zyklus • Weg: Folge von benachbarten Knoten (engl. walk) • Pfad: Weg ohne wiederholte Knoten • Zyklus: Weg mit v0 = vl, l ≥ 2 (engl. closed walk) Die L¨ange eines Wegs bzw. Pfads ist die Anzahl an Kanten, nicht die Anzahl an Knoten Begriffe • u, v adjazent/benachbart ⇔ e = {u, v} ∈ E • e ∈ E inzident/anliegend zu v ⇔ ∃u ∈ V , so dass e = {u, v} • deg(u) = Knotengrad von u (Anzahl Nachbarn) • u erreicht v ⇔ ∃ Weg zwischen u und v (engl. reachable) ¨Aquivalenzrelation (symmetrisch, reflexiv, transitiv) • Zusammenhangskomponente (ZHK): ¨Aquivalenzklasse der ”erreichbar”-relation (engl. connected component) • Graph ist zusammenh¨angend ⇔ es gibt gibt genau eine ZHK Handschlag Lemma: ∑ v∈V deg(v) = 2 · |E| Eulerweg, Hamiltonpfad, Eulerzyklus • Eulerweg: Weg welcher jede Kante genau einmal enth¨alt (engl. Eulerian walk) • Hamiltonpfad: Pfad der jeden Knoten genau einmal enth¨alt • Eulerzyklus: Zyklus welcher jede Kante genau einmal enth¨alt ∃ Eulerzyklus ⇔ alle Knotengrade gerade und alle Kanten in einer ZHK 1 Algorithmus Eulertour / Eulerwalk Euler(G): • Input: Graph G = (V, E) • Output: Liste Z mit Eulerzyklus, falls existiert. • Laufzeit: O(m) EulerWalk(u): • Input: Knoten u ∈ V • Output: Keiner • Laufzeit: O(m) Algorithm 1 Euler(G) Require: Alle Kanten unmarkiert 1: Z ← Leere Liste 2: EulerWalk(u0) ▷ f¨ur u0 ∈ V beliebig 3: return Z Algorithm 2 EulerWalk(u) 1: for uv ∈ E, nicht markiert do 2: markiere Kante uv 3: EulerWalk(v) 4: Z ← Z ∪ {u} 2 Begriffe gerichtete Graphen Der Graph G = (V, E) ist definiert wie beim ungerichteten ausser Kanten sind geordnete Paare e = (u, v) ∈ E • v ist Nachfolger von u • u ist Vorg¨anger von v • degin(u) = Eingangsgrad • degout(u) = Ausgangsgrad • Quelle u: degin(u) = 0 • Senke v: degout(v) = 0 DFS (Depth-First-Search) DFS(G) (und Visit(u): • Input: Graph G = (V, E) • Output: Implementationsabh¨angig (kann f¨ur sehr viel verwendet werden) • Laufzeit: O(n + m) (f¨ur Adjazenzlisten) Algorithm 3 Visit(u) 1: pre[u] ← T ; T ← T + 1 2: markiere u 3: for Nachvolger v von u, unmarkiert do 4: Visit(v) 5: post[u] ← T ; T ← T + 1 Algorithm 4 DFS(G) 1: T ← 1 2: alle Knoten unmarkiert 3: for u0 ∈ V , unmarkiert do 4: Visit(u0) 3 BFS (Breadth-First-Search) BFS(s): • Input: Knoten s ∈ V • Output: Implementationsabh¨angig (kann f¨ur sehr viel verwendet werden, ¨ahnlich wie DFS) • Laufzeit: O(n + m) Algorithm 5 BFS(s) 1: Q ← {s} ▷ Q ist eine Queue 2: enter[s] ← 0; T ← 1 3: while Q ̸= ∅ do 4: u ← dequeue(Q) 5: leave[u] ← T ; T ← T + 1 6: for (u, v) ∈ E, enter[v] nicht zugewiesen do 7: enqueue(Q, v) 8: enter[v] ← T ; T ← T + 1 4 Shortest-Path Algorithmen Dijkstra(s): • Input: Knoten s ∈ V – Graph darf nur nicht-negative Kantenkosten haben • Output: dist(s, v) f¨ur alle v ∈ V • Laufzeit: O((m + n) · log(n)) Algorithm 6 Dijkstra(s) 1: d[s] ← 0; d[v] ← ∞ ∀v ∈ V \\ {s} 2: S ← ∅ 3: H ← make-heap(V ); decrease-key(H, s, 0) 4: while S ̸= V do 5: v∗ ← extract-min(H) 6: S ← S ∪ {v∗} 7: for (v∗, v) ∈ E, v /∈ S do 8: d[v] ← min{d[v], d[v∗] + c(v∗, v)} 9: decrease-key(H, v, d[v]) Bellman-Ford(s): • Input: Knoten s ∈ V – Graph darf auch negative Kanten (und negative Zyklen) enthalten. • Output: dist(s, v) f¨ur alle v ∈ V • Laufzeit: O(m · n) • Wenn man nach der (n − 1)-ten Iteration nochmals eine weitere Iteration durchf¨uhrt und die Werte sich nochmals ver¨andern existiert ein gerichteter Zyklus mit negativem Totalgewicht Algorithm 7 Bellman-Ford(s) 1: d[s] ← 0; d[v] ← ∞ ∀v ∈ V \\ {s} ▷ 0-gute Schranken 2: for i ∈ {1, . . . n − 1} do ▷ Verbessere Schranken (n − 1)-mal 3: for (u, v) ∈ E do 4: d[v] ← min{d[v], d[u] + c(u, v)} 5 MST Algorithmen Boruvka(G): • Input: Graph G = (V, E) • Output: Minimaler Spannbaum F • Laufzeit: O((m + n) · log(n)) (wie Dijkstra) Algorithm 8 Boruvka(G) 1: F ← ∅ ▷ sichere Kanten 2: while F nicht Spannbaum do ▷ ≤ log(n) Iterationen, O(m + n) pro Iteration 3: (S1, . . . , Sk) ← ZHKs von F 4: (e1, . . . , ek) ← minimale Kanten an S1, . . . , Sk 5: F ← F ∪ {e1, . . . , ek} Idee: Konzentrieren uns auf eine ZHK Prim(G, s): • Input: Graph G = (V, E) und s ∈ V • Output: Minimaler Spannbaum F • Laufzeit: O((m + n) · log(n)) (wie Dijkstra und Boruvka) Algorithm 9 Prim(G, s) (allgemeine Form) 1: F ← ∅ 2: S ← {s} ▷ ZHK von s in F 3: while F nicht Spannbaum do 4: u∗v∗ ← minimale Kante an S (u ∗ ∈ S, v∗ /∈ S) 5: F ← F ∪ {u ∗v∗} 6: S ← S ∪ {v∗} Algorithm 10 Prim(G, s) (mit min-heap) 1: H ← make-heap(V, ∞), S ← ∅ 2: d[s] ← 0; d[v] ← ∞ ∀v ∈ V \\ {s} 3: decrease-key(H, s, 0) 4: while H ̸= ∅ do 5: v∗ ← extract-min(H) 6: S ← S ∪ {v∗} 7: for v∗v ∈ E, v /∈ S do 8: d[v] ← min{d[v], c(v∗, v)} ▷ Unterschied zu Dijkstra 9: decrease-key(H, v, d[v]) 6 Union-Find Datenstruktur Idee: verwalte alle Knoten einer ZHK als Liste Algorithm 11 Union-Find(G) 1: Implementierung: 2: make(V): rep[v] ← v ∀v ∈ V ▷ O(n) 3: 4: same(u,v): teste ob rep[u] = rep[v] ▷ O(1) 5: 6: union(u,v): ▷ O(|ZHK(u)|) 7: for x ∈ members[rep[u]] do 8: rep[x] ← rep[v] 9: members[rep[v]] ← members[rep[v]] ∪ {x} Idee: sichere Kanten sortiert nach Gewicht Kruskal(G): • Input: Graph G = (V, E) und s ∈ V • Output: Minimaler Spannbaum F • Brauchen eine Union-Find Datenstruktur f¨ur effiziente Laufzeit • Laufzeit: O(m · log(m) ︸ ︷︷ ︸ Sortieren + n · log(n) ︸ ︷︷ ︸ Union-Find ) Algorithm 12 Kruskal(G) (mit UF-Datenstruktur) 1: F ← ∅ 2: U F ← make(V ) ▷ UF-Datenstruktur initialisieren 3: sort(E) ▷ Sortiere Kanten nach Gewicht 4: for uv ∈ E, aufsteigend sortiert do 5: if same(u,v) = false then ▷ u, v in verschiedenen ZHKs von F 6: F ← F ∪ {uv} 7: union(u,v) 7 All pairs Shortest Path Floyd-Warshall(G): • Input: Graph G = (V, E) • Output: L¨ange von beliebigem k¨urzestem Pfad. • Laufzeit: O(n3) • Teilproblem: d i uv = L¨ange von k¨urzestem u − v-Weg, der nur Zwischenknoten aus {1, . . . , i} benutzen darf Algorithm 13 Floyd-Warshall(G) 1: for u ∈ V do 2: d0 uu ← 0 ▷ falls keine negativen Schleifen 3: for v ∈ V \\ {u} do 4: if (u, v) ∈ E then 5: d0 uv ← c(u, v) 6: else 7: d0 uv ← ∞ 8: for i = 1 . . . n do 9: for u = 1 . . . n do 10: for v = 1 . . . n do 11: di uv ← min{d i−1 uv , d i−1 ui + di−1 iv } return d n ▷ n × n Resulatmatrix 8","libVersion":"0.3.2","langs":""}