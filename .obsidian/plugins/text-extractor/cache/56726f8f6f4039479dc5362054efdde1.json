{"path":"sem2/PProg/VRL/extra/kuhn/PProg-w05-kuhn.pdf","text":"Parallel Programming Session 5 Spring 2024 Schedule Task about wait/notify/synchronized etc. basically everything Assignment 4 post-discussion Theory/lecture recap Exam tasks Pre-Discussion Assignment 5 Quiz Update an atomic code SOLA Stafette public class RunnerThread extends Thread { private AtomicInteger y; private int id; public RunnerThread(int id, AtomicInteger y) { this.id = id; this.y = y; } public void run(){ while (y.get() != this.id) { // warten bis ich an der Reihe bin / wait until it is my turn } // laufen / do running y.incrementAndGet(); } } ● 14 runners (numbered from 0 to 13) ● each runner can start after the previous runner finished (except the first one). Under which assumption does the following code work? Initial value of y? Reference to object y? 0 needs to be the same object shared across all the threads SOLA Stafette public class RunnerThread extends Thread { private AtomicInteger y; private int id; public RunnerThread(int id, AtomicInteger y) { this.id = id; this.y = y; } public void run(){ while (y.get() != this.id) { // warten bis ich an der Reihe bin / wait until it is my turn } // laufen / do running y.incrementAndGet(); } } ● 14 runners (numbered from 0 to 13) ● each runner can start after the previous runner finished (except the first one). Under which assumption does the following code work? Initial value of y? Reference to object y? 0 needs to be the same object shared across all the threads Ensures that y.get() returns the updated value after calling y.incrementAndGet(); SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ ................................................... ................................................... ................................................... ................................................... ................................................... ................................................... ................................................... Complete the implementation using wait/notify SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { ................................................... ................................................... ................................................... ................................................... ................................................... ................................................... Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { while (condition) { ?.wait(); } ................................................... ................................................... ................................................... ................................................... Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { while (condition) { ?.wait(); } // laufen / do running ................................................... ................................................... ................................................... } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { while (condition) { ?.wait(); } // laufen / do running // update the condition ................................................... ................................................... } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { while (condition) { ?.wait(); } // laufen / do running // update the condition ?.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads This is a basic pattern that you will see in many tasks. Now, let’s fill in the details. essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (?) { while (condition) { ?.wait(); } // laufen / do running // update the condition ?.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (condition) { x.wait(); } // laufen / do running // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (condition) { x.wait(); } // laufen / do running // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private .................. x; private int id; public WaitNotifyRunnerThread(int id, .................. x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (condition) { x.wait(); } // laufen / do running // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads while (y.get() != this.id) { original condition can we reuse it? Yes! essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notify(); // or notifyAll() } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Should we use notify or notifyAll? essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Should we use notify or notifyAll? notifyAll because multiple threads can be waiting essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Can we replace synchronized (x) with synchronizing the method? essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public ................. void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Can we replace synchronized (x) with synchronizing the method? No essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private AtomicInteger x; private int id; public WaitNotifyRunnerThread(int id, AtomicInteger x) { this.id = id; this.x = x; } public void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x.incrementAndGet(); // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Can we replace AtomicInteger x With Integer x ? essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private Integer x; private int id; public WaitNotifyRunnerThread(int id, Integer x) { this.id = id; this.x = x; } public void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x += 1; // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify 1. We’ll definitely need synchronization 2. What to synchronize on? 3. Check that it’s our turn, wait otherwise 4. Do work (run) 5. Update the condition 6. Notify waiting threads Can we replace AtomicInteger x With Integer x ? essentials SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private Integer x; private int id; public WaitNotifyRunnerThread(int id, Integer x) { this.id = id; this.x = x; } public void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x += 1; // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify Can we replace AtomicInteger x With Integer x ? Do these assumptions still hold? Reference to object x? needs to be the same object shared across all the threads details SOLA Stafette public class WaitNotifyRunnerThread extends Thread { private Integer x; private int id; public WaitNotifyRunnerThread(int id, Integer x) { this.id = id; this.x = x; } public void run(){ synchronized (x) { while (x.get() != this.id) { x.wait(); } // laufen / do running x += 1; // update the condition x.notifyAll(); } } } Complete the implementation using wait/notify Can we replace AtomicInteger x With Integer x ? Do these assumptions still hold? Reference to object x? needs to be the same object shared across all the threads No, because x += 1 in Java creates a new Object! details Post-Discussion Ex.4 Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task a) total time if strictly sequential order? Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task a) total time if strictly sequential order? 50 + 90 + 15 155 Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task a) total time if strictly sequential order? 155 155+ Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task a) total time if strictly sequential order? 155 155 155 155+ + + = 620 Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? Pipeline it !!! Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? Throughput? Lead-in/lead-out vs. “infinite” Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? Throughput? 1 person per 106.25 min (425 min / 4) With lead in & lead out (fixed number of students) Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? Throughput? 1 person per 90 min Full utilization (indefinite number of students) Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task b) what would be a better (faster) strategy? 1 person per 90 min Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Latency? 50 min 305 min Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Throughput?Latency? 155 min per load 305 min for all 50 min 305 min Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Throughput?Latency? 155 min per load 305 min for all 1 person per 50 min (full utilization) 1 person per 76.25 min (with lead in & lead out) 50 min 305 min Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Is the pipeline balanced ? Pipelining Washing - 50 min, Dryer - 90 min, Iron - 15 min Task c) what if they bought another dryer? Is the pipeline balanced, it has no gaps ? No because… first stage is not longest. not all stages take same amount of time Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } Assumptions: ● Only one instruction can be issued per cycle. ● Loop body computation must be fully finished before next iteration starts ● Consider only arithmetic expressions in loop body and ignore all other operations (i.e., loads, stores, loop counter increment, etc.) ● Consider only execute step of an instruction (e.g., ignore fetch, decode, etc.) How many cycles does the processor need to execute the following loops? ● Addition takes 3 cycles to execute ● Multiplication takes 6 cycles to execute Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } Assumptions: ● Only one instruction can be issued per cycle. ● Loop body computation must be fully finished before next iteration starts ● Consider only arithmetic expressions in loop body and ignore all other operations (i.e., loads, stores, loop counter increment, etc.) ● Consider only execute step of an instruction (e.g., ignore fetch, decode, etc.) How many cycles does the processor need to execute the following loops? ● Addition takes 3 cycles to execute ● Multiplication takes 6 cycles to execute Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } 1 2 3i-1 loop iteration i+1 loop iteration 4 5 6 essentials Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } 1 2 3i-1 loop iteration i+1 loop iteration 4 5 6 essentials need ”size” iterations -> 6 * size Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } 1 2 3i-1 loop iteration i+1 loop iteration 4 5 6 essentials need ”size” iterations -> 6 * size Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } 1 2 3 4 5 6 7 8 9 i-2 loop iteration i+2 loop iteration 1 2 3i-1 loop iteration i+1 loop iteration 4 5 6 essentials Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } 1 2 3 4 5 6 7 8 9 i-2 loop iteration i+2 loop iteration 1 2 3i-1 loop iteration i+1 loop iteration 4 5 6 essentials need ceil (size/2) iterations -> ceil (size/2) *9 Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } 1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6 7 8 9 1 2 3i-1 loop iteration i+1 loop iteration i-2 loop iteration i-4 loop iteration i+2 loop iteration i+4 loop iteration 4 5 6 essentials Pipelining II for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < size; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } 1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6 7 8 9 1 2 3i-1 loop iteration i+1 loop iteration i-2 loop iteration i-4 loop iteration i+2 loop iteration i+4 loop iteration 4 5 6 essentials need ceil (size/4) iterations -> ceil (size/4) *12 Task 2cLoop Parallelism for (int i=1; i<size; i++) { // for loop: i from 1 to (size-1) if (data[i-1] > 0) // If the previous value is positive data[i] = (-1)*data[i]; // change the sign of this value } // end for loop Can we parallelize the following loop? for (int i = 0; i < size; i++) { // for loop: i from 0 to (size-1) data[i] = Math.sin(data[i]); // calculate sin() of the value } // end for loop essentials Task 3aPipelining Properties: 1.) N-elements or indefinite Pipelining Properties: 1.) N-elements or indefinite 2.) Latency Coorect it here aka the bracjets Pipelining Properties: 1.) N-elements or indefinite 2.) Latency 3.)Throughput (with lead-in /lead-out) Pipelining Properties: 4.) Balanced/ Unbalanced ILP Exam Task 3 cycles latency only operations inside the loop ILP Exam Task 3 cycles latency 8 integer additions in parallel aka vector operation ILP Exam Task 3 cycles latency 8 integer additions in parallel ILP Exam Task 3 cycles latency 8 integer additions in parallel hack formula: time = latency + (iterations-1)*throughput Theory Recap Speed Up Amdahl Gustafson p=1 p=4 Amdahl's Law Gustafson's Law Time p=1 p1 p2 p3 p4p1 p2 p3 p4 p=4 p1p1 Key Points Amdahl: fixed work size Key Points Amdahl: fixed work size shows that sequential part drastically limits speed up Key Points Amdahl: fixed work size shows that sequential part drastically limits speed up conclusion according to Amdahl: make sense to invest into reducing sequential part of program. f. eg. only lock code when necessary ! Key Points Gustafson more optimistic than Amdahl Key Points Gustafson more optimistic than Amdahl fixed time, but can increase problem size: «work done in an time interval» Key Points Gustafson more optimistic than Amdahl fixed time, but can increase problem size: «work done in an time interval» with more processors can do more of parallel part of the work Conclusion Amdahl and Gustafons aren’t different views on the same problem Make different assumptions about the problem ( fixed work or fixed time ) Conclusion Amdahl and Gustafons aren’t diffrent views on the same problem Make different assumptions about the problem ( fixed work or fixed time ) F. eg. Sorting an array -> Amdahl Rendering 3D picture -> Gustafson cannot have more detail can have more detail Derivation ? Gustafson Amdahl Old Exam Task (HS20 – Task 1)Old Exam Task (HS20 – Task 1) Gustafson: From the text: Old Exam Task (HS20 – Task 1) Gustafson: From the text: ⟺ ⟺ ⟺ Exam TaskExam TaskExam TaskExam TaskTask Parallelism Model Create Parallel Task -> wait for it to finish Task Parallelism Model Create Parallel Task -> wait for it to finish Create Task and divide it into subtask -> wait for compute -> combine the results Divide& Conquer Divide: Break into subproblems Conquer: Solve those subproblems Combine results Seem naturally perfect for parallelizing ++++++++ ++++ ++ + Divide and Conquer essentials ++++++++ ++++ ++ + base case no further split Divide and Conquer essentials ++++++++ ++++ ++ + Tasks at different levels of granularity Divide and Conquer essentials ++++++++ ++++ ++ + Tasks at different levels of granularity What determines a task? Divide and Conquer essentials Divide& Conquer Divide: Break into subproblems Conquer: Solve those subproblems Combine results Seems naturally perfect for parallelizing How do we asses performance of those algorithms & how do we implement them ? Divide& Conquer Divide: Break into subproblems Conquer: Solve those subproblems Combine results Seems naturally perfect for parallelizing How do we asses performance of those algorithms & how do we implement them ? Divide& Conquer Divide: Break into subproblems Conquer: Solve those subproblems Combine results Seems naturally perfect for parallelizing How do we asses performance of those algorithms & how do we implement them ? Task Graphs Executor Service Fork/Join Task Graphs Way to model program execution DAG : directed acyclic graph Task Graphs Way to model program execution DAG : directed acyclic graph Nodes are tasks/work labelled with execution time Task Graphs Way to model program execution DAG : directed acyclic graph Nodes are tasks/work labelled with execution time Edges show dependencies -> data dependency along the edge Task Graphs: Take-Away Used to calculate speed up Task Graphs: Take-Away Used to calculate speed up T1: work -> sum of all nodes aka their time cost Tp: span -> sum of all nodes on critical ( = longest) path Task Graphs: Take-Away Used to calculate speed up T1: work -> sum of all nodes aka their time cost Tp: span -> sum of all nodes on critical ( = longest) path Span = T infinity : fastest we can get Why ? Can calculate fastest speed up possible for this program with T1 an Tp Why ? Can calculate fastest speed up possible for this program How many processors needed to achieve this maximal speed up ? Let’s test Critical path and total work ? What is the maximum overall achievable speedup ? Implementation Executor Service or Fork/Join dependent on structure Executor Service Executor Service Limited thread pool, thus can run forever ->deadlock not well for deep recursive tasks Executor Service Executor Service Limited thread pool, thus can run forever not well for deep recursive tasks Task: find the maximum element of an array (using Executor) :: Demo ? Fork/Join Library suited for divide& conquer algorithms Implemented like Java Threads but with different names and interfaces Java Threads vs. ForkJoin: Fork/Join Library suited for divide& conquer algorithms Implemented like Java Threads but with different names and interfaces Java Threads vs. ForkJoin: Extend Thread à Extend RecursiveTask<T> (with return value) RecursiveTask<T> (without return value) Fork/Join Library suited for divide& conquer algorithms Implemented like Java Threads but with different names and interfaces Java Threads vs. ForkJoin: Extend Thread à Extend RecursiveTask<T> (with return value) RecursiveTask<T> (without return value) Override run à Override compute Fork/Join Library suited for divide& conquer algorithms Implemented like Java Threads but with different names and interfaces Java Threads vs. ForkJoin: Extend Thread à Extend RecursiveTask<T> (with return value) RecursiveTask<T> (without return value) Override run à Override compute Calling start à call fork Fork/Join Library suited for divide& conquer algorithms Implemented like Java Threads but with different names and interfaces Java Threads vs. ForkJoin: Extend Thread à Extend RecursiveTask<T> (with return value) RecursiveTask<T> (without return value) Override run à Override compute Calling start à call fork Main thread à create ForkJoinPool and call invoke Fork/Join Library suited for divide& conquer algorithms Implemented like Java Threads but with different names and interfaces Java Threads vs. ForkJoin: Extend Thread à Extend RecursiveTask<T> (with return value) RecursiveTask<T> (without return value) Override run à Override compute Calling start à call fork Main thread à create ForkJoinPool and call invoke DEMO ? Pre-Discussion Ex.5 Assignment 5 1. Parallel Search and Count Search an array of integers for a certain feature and count integers that have this feature. ● Light workload: count number of non-zero values. ● Heavy workload: count how many integers are prime numbers. We will study single threaded and multi-threaded implementation of the problem. Explanation of given code Assignment 5 1. Parallel Search and Count Search an array of integers for a certain feature and count integers that have this feature. ● Light workload: count number of non-zero values. ● Heavy workload: count how many integers are prime numbers. We will study single threaded and multi-threaded implementation of the problem. 3. Amdahl’s and Gustafson’s Law II 4. Amdahl’s and Gustafson’s Law 5. Task Graph Amdal’s & Gustavson’s Law Assuming a program consists of 50% non-parallelizable code. a) Compute the speed-up when using 2 and 4 processors according to Amdahl’s law. b) Now assume that the parallel work per processor is fixed. Compute the speed-up when using 2 and 4 processors according to Gustafson’s law. Time is constant à More work overall See you next week J","libVersion":"0.3.2","langs":""}