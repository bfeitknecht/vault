{"path":"sem5/VLSI1/VRL/extra/Top-Down-Digital-VLSI-Design/Chapter-4---Circuit-Modeling-with-Hardware-Descri_2015_Top-Down-Digital-VLSI.pdf","text":"CHAPTER 4 CIRCUIT MODELING WITH HARDWARE DESCRIPTION LANGUAGES 4.1 MOTIVATION AND BACKGROUND 4.1.1 WHY HARDWARE SYNTHESIS? VLSI designers find themselves in a difficult situation. On the one hand, buyers ask for microelectronic products that integrate more and more functions on a single chip. Following Moore’s law, fabrication technology has always supported this aspiration by quadrupling the achievable circuit complexity every three years or so. Market pressure, on the other hand, vetoes a proportional dilation of product development times. Worse than this, time to market is even expected to shrink. As a consequence, design productivity must constantly improve. Hardware description languages (HDL) and design automation come to the rescue in four ways: • Exonerate designers from low-level details by moving design entry to more abstract levels. • Allow designers to focus on functionality as automatic synthesis tools generate circuits. • Facilitate design reuse by capturing a circuit description in a parametrized technology- and platform-independent form (as opposed to schematic diagrams, for instance). • Making functional verification more efficient by supporting stimuli generation, automatic response checking, assertion-based verification, and related techniques. The transition from structural to physical is largely automated in digital VLSI design today. The transition from behavioral to structural has not yet reached the same maturity, but HDL synthesis is routinely used for turning register transfer level (RTL) descriptions into gate-level networks that are then processed further with the aid of cell-based design automation software. 4.1.2 AGENDA After an overview on the HDLs currently available, section 4.1.6 introduces the key concepts that set HDLs apart from software languages. The text then bifurcates. Section 4.2 discusses VHDL language constructs and explains how they relate to the underlying concepts while section 4.3 does the same for SystemVerilog. Readers are free to chose one or the other depending on their needs. Both threads reconverge in section 4.4 that focusses on circuit synthesis. How to organize and code simulation testbenches will have to wait until section 5.5. Appendix 4.7 provides side-by-side comparisons of the Top-Down Digital VLSI Design © 2015 Elsevier Inc. All rights reserved. 179 180 CHAPTER 4 CIRCUIT MODELING WITH HDLs two HDLs and lists textbooks and syntax references. Appendix 4.8 is about various VHDL language extensions. Last but not least, the book’s companion website includes more substantial code examples than those printed in the text. 4.1.3 ALTERNATIVES FOR MODELING DIGITAL HARDWARE SystemVerilog shares most key concepts with VHDL. To a somewhat lesser extent this also applies to Verilog the precursor of SystemVerilog, making the differences between RTL synthesis models captured using those three languages largely a matter of syntax and coding style. Beyond that, SystemVerilog offers a better support for functional verification as it has inherited various mechanisms from specialized languages. It is, therefore, sometimes dubbed the first hardware description and verification language (HDVL). That said, VHDL and SystemVerilog have their pros and cons, see below and have a look at table 4.12 for technical details. Criterion VHDL Verilog SystemVerilog Synthesis support yes yes growing Parametrization & abstract modeling good poor good Type checking & scoping rules strong none loose Deterministic event queue mechanism yes not really not really Modeling of electric phenomena 9-valued 4-valued 4-valued High-level verification support limited poor excellent Many companies currently use VHDL for synthesis and SystemVerilog for system-level verification. The future will tell whether SystemVerilog will one day supersede Verilog and VHDL, reconcile their user communities, and so bring an unfortunate schism to an end. SystemC is not really a language but a C++ class library that includes the necessary extensions for hardware modeling plus a simulation kernel. This means that a model written in SystemC can be executed with only a standard GNU compiler. SystemC is intended for use in software/hardware co- design and co-simulation, but does not qualify for gate-level simulation and timing verification because of its inaptitude for modeling detailed timing behavior.1 4.1.4 THE GENESIS OF VHDL AND SYSTEMVERILOG Providing spare parts over many years for industrial products that include ASICs and other custom- designed state-of-the-art electronic components proves painful as technology evolves and as companies restructure. In search of a standard format for documenting digital ICs and for exchanging design data other than layout polygons, the US Department of Defense (DoD) in 1983 commissioned IBM, Intermetrics and Texas Instruments to define an HDL. Ada was taken as a starting point. As the project 1 While SystemC adds clocking information to C++ functions, it does not support any timing finer than one clock cycle. Synthesis path is via translation to RTL VHDL or [System]Verilog by way of automatic allocation, scheduling and binding, which makes RTL expertise unavoidable for VLSI designers. 4.1 MOTIVATION AND BACKGROUND 181 behavioral perspective structural perspective back-end design front-end design physical perspective behavioral perspective structural perspective electrical logic (aka gate-level) architecture system register transfer levels of abstraction FINISH START logic synthesis logic optimization RTL synthesis architecture design transfer functions subtasks truth tables, state graphs data moves and operations standard cells, macrocells detailed layout mask polygons, chip or board placement and routing floorplan, partitioning algorithm and I/O top blocks physical perspective scope of VHDL and SystemVerilog scope of SystemC analog and mixed- signal extensions transistors, wires gates, latches, flip-flops ALUs, registers, memories subblocks FIGURE 4.1 HDLs shown in the Y-chart. had originated from DoD’s Very High Speed Integrated Circuits (VHSIC) program, the new language was given the acronym VHDL. After a number of revisions and after military restrictions had been lifted, the proposal was accepted as IEEE 1076[-87] standard in 1987. IEEE bylaws require any standard to be revised on a periodical basis and a first re-examination led to the IEEE 1076-93 revision which found wide adoption. Approximately at the same time IEEE also passed the IEEE 1164 standard, a nine-valued logic system used in conjunction with VHDL. Following a series of relatively minor improvements and clarifications over the subsequent years, the latest release IEEE 1076-2008 has brought about a wider set of modifications as documented in [96]. The first software tools built around HDLs were compilers and simulators. Around 1984, Gateway Design Automation had in fact developed a logic simulator along with a proprietary language for capturing the circuits to be simulated. That language was Verilog, and its syntax was very much inspired by the C programming language. It became more prevalent in the early 1990s when Cadence acquired Gateway, made the language an open standard, and ultimately pushed it through the IEEE standardization process in 1995. 182 CHAPTER 4 CIRCUIT MODELING WITH HDLs Only later did people want to come up with automatic synthesis tools that would accept behavioral specifications stated using an HDL and churn out gate-level netlists implementing them. Synopsys pioneered synthesis technology, supporting both VHDL and Verilog for design entry. As will become evident later in this chapter, current language versions continue to suffer from the fact that synthesis issues were ignored when the languages were originally defined. Verilog had not much to offer in terms of abstract data types, model parametrization, and functional verification. As these limitations became obvious, the Accellera industry consortium set out to create a successor, incorporating useful constructs from VHDL, powerful assertions for verification purposes, plus other features that have proven highly effective for writing advanced testbenches, notably from languages such as OpenVera, PSL, and Superlog.2 The result essentially collects three languages under the SystemVerilog brand and was accepted as IEEE 1800[-05] standard. On the other hand, the consortium chose not to clean up the messier parts of the Verilog language for reasons of backward code compatibility.3 SystemVerilog and Verilog officially co-existed until 2009 when Verilog got absorbed into the IEEE 1800-09 standard that brought further enhancements, mostly for verification. [98] is the 1315-page language reference manual for the current IEEE 1800-12 SystemVerilog release. 4.1.5 WHY BOTHER LEARNING HARDWARE DESCRIPTION LANGUAGES? As shown in fig.4.1, VHDL and SystemVerilog encompass behavioral and structural views but not physical ones. The levels of abstraction covered range from purely algorithmic descriptions down to logic design.4 That said, it seems a tempting idea to view HDLs as nothing more than intermediate formats for exchanging data between electronic system-level (ESL) tools and VLSI CAE/CAD suites. “Why not skip learning hardware description languages and have electronic system-level tools generate HDL code from specifications automatically?” There indeed exists a variety of software packages that deal with systems at levels of abstraction well above those addressed during actual VLSI design, see fig. 1.12. Many of them deal with transformatorial systems as found in signal processing and telecommunications that typically get pieced together from high-level function blocks such as oscillators, modulators, filters, phase shifters, delay lines, frequency dividers, phase locked loops (PLL), synchronizers, etc. Other high-level tools model system behavior on the basis of condition/action pairs captured as state graphs, state charts, Petri nets, and the like. The graphical design capture and animation facilities provided are intuitive and very helpful for defining, checking, debugging, and improving the functionality of reactive systems. 2 Dynamic data structures, object-oriented programming (classes), constrained random stimuli generation, and functional coverage metering, plus a new programming language interface (DPI). 3 Such as the byzantine syntax, the overly indulgent typing scheme, and the perplexing scheduler. You may want to see [97] for a collection of language misfeatures that tend to breed bugs. 4 The inability to model time-continuous phenomena and in terms of electrical quantities confines both languages to digital circuits. Extensions for analog and mixed-signal circuits have been standardized as VHDL-AMS and Verilog-AMS respectively. The basic ideas will be briefly reviewed in section 4.8.2. 4.1 MOTIVATION AND BACKGROUND 183 More EDA packages are geared towards some field of application such as the analysis of communi- cation channels, source and channel coders, data transfer networks, image and video processing, pattern recognition, optimization of instruction set computers, and so forth. The common theme is that EDA tools working above the HDL level tend to focus on fairly specific problem classes. Though probably unavoidable, this fragmentation is unfortunate in the context of VLSI design where building blocks of transformatorial and reactive nature coexist on the same chip. ESL tools typically include code generators that produce software code for popular microcomputers or DSPs. Many of them are also capable of producing HDL code. All too often, this code is or was nothing else than a translation of the processor code, however. While this may have allowed for simulation under certain conditions, it is clearly not acceptable for synthesis, and the results so obtained remained unsatisfactory. Genuine high-level synthesis tools, on the other hand, typically work on the basis of resource allocation, scheduling, and binding.5 Finding a good overall solution implies exploring a vast solution space that involves both algorithmic and architectural issues. Yet, today’s tool suites are often restricted to a few predefined hardware patterns with limited optimization capabilities. As a result, it will take a couple of years before true system-level synthesis pervades the industrial production environment [99]. Developing a circuit model actually goes more like this: A behavioral model established early on serves to validate the intended functionality. Software languages, Matlab, and other general purpose tools qualify as little attention needs to be paid to architectural issues and to limitations of synthesis technology at this point. Later in the design cycle, a more detailed model is written — mostly at the RTL level — as a starting point for synthesis. Simulation here serves to make sure this complex piece of HDL code is correct before it gets synthesized into a gate-level netlist. A third simulation round is then carried out on the netlist so obtained, and a fourth round with the same netlist following place and route (P&R), layout extraction, and back-annotation. In the end, four circuit models have been used to capture the identical functionality at distinct levels of detail as summarized in table 4.1. 5 The tools essentially accept an algorithmic description in C and a series of pragmas or other human input that outlines the hardware resources to be made available. The output is RTL code that describes a VLIW ASIP operating under control of either a stored microprogram or a hardwired finite state machine. Final implementation is with FPGAs or as a cell-based ASIC. Catapult C by Mentor Graphics is a commercial example. 184 CHAPTER 4 CIRCUIT MODELING WITH HDLs Table 4.1 Circuit models and HDLs encountered during a typical VLSI design flow. Design stage Main Level of Predominant &model purpose abstraction Timing languages 1. Algorithmic system-level behavioral none C, Matlab model simulation tentative VHDL, SysVer 2. RTL simulation register optional fake delays VHDL, SysVer model synthesis transfer constraints in Tcl 3. Post-synthesis simulation, gate level estimated with Verilog, netlist timing analysis wire load models (VHDL&VITAL ) place & route 4. Post-layout simulation, gate level extracted from Verilog, netlist timing analysis, layout and (VHDL&VITAL ) sign-off back-annotated Even where ESL tools do generate a useful HDL (sub)model, manual interventions in the source code may be required to parametrize, adapt, interface, or optimize the circuit or the model. Finally, HDLs are indispensable for modeling library cells and virtual components. Observation 4.1. For the foreseeable future, hardware description languages such as VHDL and SystemVerilog are bound to remain prominent hubs for all VLSI design activities. 4.1.6 A FIRST LOOK AT VHDL AND SYSTEMVERILOG In sections 4.2 and 4.3, we shall study the VHDL and SystemVerilog languages respectively by asking ourselves “What features are required to model digital electronic circuits for simulation and synthesis?” In anticipation of our findings, we will identify a multitude of needs that can be collected into the six broad categories listed below. The language concepts addressing those needs will be introduced accordingly. The discussion of basic concepts that HDLs share with modern programming languages has been postponed to the end of our presentations based on the assumption that readers have had some exposure to software engineering. Observation 4.2. In a nutshell, HDLs can be characterized as follows: VHDL SystemVerilog HDL = structured programming language 4.2.6 4.3.6 + circuit hierarchy and connectivity 4.2.1 4.3.1 + interacting concurrent processes 4.2.2 4.3.2 + a discrete replacement for electrical signals 4.2.3 4.3.3 + an event-driven scheme of execution 4.2.4 4.3.4 + model parametrization facilities 4.2.5 4.3.5 + verification aids chapter 5 4.1 MOTIVATION AND BACKGROUND 185 A few more remarks are due before we start with our discussions. • The entire chapter puts emphasis on the concepts behind HDLs and on applying them to hardware modeling. There will be no comprehensive exposure to syntax or grammar. To become proficient in writing circuit models of your own, you will need a more detailed documentation on your preferred HDL. See table 4.13 for an annotated bibliography. • A look at table 4.10 will facilitate the understanding of the upcoming code examples. • More substantial VHDL and SystemVerilog code examples have been collected on the book’s companion website to show the usage of important language constructs in context. Newcomers are strongly encouraged to go through the listings there as well to develop an understanding of HDL coding styles and options. • This text discusses two HDLs as defined by various international standards. Commercial EDA tools occasionally deviate in terminology and implementation. Some recent additions may not be supported by all tools. • Our discussion of HDL concepts is accompanied by a series of illustrations that include figs.4.2, 4.3, 4.6, 4.8, and that culminates with the full picture in fig.4.12. Refer back to these synoptical drawings when in danger of getting lost in minor details. • Throughout this text, we will use “process” as a broad and generic term for any kind of concurrent activity, i.e. as a shorthand for “concurrent process”, “parallel process”, or “thread of execution”.6 • Please observe a linguistic ambiguity in the context of hardware modeling: Meaning of “sequential” with reference to Synonym Antonyms ◦ program execution during simulation step-by-step concurrent, parallel ◦ nature of circuit being modeled memorizing combinational, memoryless 6 And as a translation of the German “nebenläufiger Prozess”. 186 CHAPTER 4 CIRCUIT MODELING WITH HDLs 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 4.2.1 CIRCUIT HIERARCHY AND CONNECTIVITY The need for supporting modularity and hierarchical composition Consider a motherboard from a personal computer, for instance. At the top level, you will discern a CPU, a graphics processor, a ROM or two, and several memory modules composed of multiple RAM chips. Then there are all sorts of peripheral circuits plus a variety of passive components. If you could look into the ICs, you would find datapaths, controllers, storage arrays, and the like. And each such block consists of thousands of logic gates and bistables, that are in turn assembled from the most elementary devices, from transistors. Electronic systems are organized into multiple layers of hierarchy because it is entirely impractical to specify, understand, design, fabricate, test, and document circuits with millions of gates as flat collections of transistors. Instead, larger entities are hierarchically composed from subordinate entities that are interconnected with the aid of busses and individual wires. Abstraction, modularity, and repetition further help to arrive at manageable circuit descriptions. Any HDL that wants itself useful must support these techniques, see fig.4.2 for a first impression. u82 u39 u18 u11 deemph filter sobel filter coeff comp deemph filter video processor u1 u101 line memory port entity design component instantiated (hierarchy) port module instance module (hierarchy) VHDL SystemVerilog same subcircuit instantiated twice FIGURE 4.2 HDL capabilities (I): Hierarchical composition ... 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 187 Design entity The entity is the basic building block of a VHDL design. Its primary purpose is to encapsulate the data, functionality and timing of a circuit or subcircuit. VHDL makes a strict distinction between a (sub)circuit’s external and internal views. The interface is specified in the entity declaration whereas the details of its implementation are captured in a language element called architecture body, or architecture for short. Entity declaration and ports The entity declaration specifies the external interface of an entity. Its most important part is the port clause that enumerates those circuit nodes that are visible from outside. Put differently, each signal that is part of the port clause corresponds to a connector on the icon of that subcircuit as illustrated in fig.4.13. An example of an entity declaration is given below. -- entity declaration entity lfsr4 is port ( Clk_CI : in std_logic; Rst_RBI : in std_logic; -- reset is active low Ena_SI : in std_logic; Oup_DO : out std_logic ); end lfsr4; Hint: VHDL is case-insensitive, e.g. clk_ci = CLK_CI. An exception are the so-called “extended identifiers” written between two backslashes, e.g. \\clk_ci\\ ∗= \\CLK_CI\\. Hint: Naming a signal or a port In or Out is all too tempting, yet these are reserved words in VHDL. We recommend the use of Inp and Oup instead. Architecture body, structural view An architecture body is the place where the internal technicalities of a design entity are being described. Any entity is permitted to contain instances of other design entities, thereby creating hierarchy. A code example follows in listing 4.1. Although you are probably not yet in a position to understand everything, it should become clear that the circuit is composed of five logic gates and four flip-flops. As an exercise, draw a schematic diagram for the circuit. LISTING 4.1 Structural view of a linear feedback shift register (LFSR) of length 4. -- architecture body architecture structural of lfsr4 is -- declare the components to be used component GTECH_FD2 -- D-type flip-flop with reset port ( 188 CHAPTER 4 CIRCUIT MODELING WITH HDLs D, CP, CD : in std_logic; Q: out std_logic ); end component; component GTECH_FD4 -- D-type flip-flop with set port ( D, CP, SD : in std_logic; Q: out std_logic ); end component; component GTECH_MUX2 -- 2-input multiplexer port ( A, B, S : in std_logic; Z: out std_logic ); end component; component GTECH_XOR2 -- 2-input XOR gate port ( A, B: in std_logic; Z: out std_logic ); end component; -- declare a signal for each inner node signal State_DP : std_logic_vector(1 to 4); signal n11, n21, n31, n41, n42 : std_logic; begin -- instantiate components and connect them by listing port maps u10 : GTECH_FD2 port map( D => n11, CP => Clk_CI, CD => Rst_RBI, Q => State_DP(1) ); u20 : GTECH_FD2 port map( D => n21, CP => Clk_CI, CD => Rst_RBI, Q => State_DP(2) ); u30 : GTECH_FD2 port map( D => n31, CP => Clk_CI, CD => Rst_RBI, Q => State_DP(3) ); u40 : GTECH_FD4 port map( D => n41, CP => Clk_CI, SD => Rst_RBI, Q => State_DP(4) ); u11 : GTECH_MUX2 port map( A => State_DP(1), B => n42, S => Ena_SI, Z => n11 ); u21 : GTECH_MUX2 port map( A => State_DP(2), B => State_DP(1), S => Ena_SI, Z => n21 ); u31 : GTECH_MUX2 port map( A => State_DP(3), B => State_DP(2), S => Ena_SI, Z => n31 ); u41 : GTECH_MUX2 port map( A => State_DP(4), B => State_DP(3), S => Ena_SI, Z => n41 ); 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 189 u42 : GTECH_XOR2 port map( A => State_DP(3), B => State_DP(4), Z => n42 ); -- connect state bit of rightmost flip-flop to output port Oup_DO <= State_DP(4); end structural; How to compose a circuit from components How do you proceed when asked to fit a circuit board with components? You think of the exact name of a part required, go and fetch a copy of it, and solder the terminals of that one copy in a well-defined manner to metal pads interconnected by narrow lines on the board. The component instantiation statement of VHDL does exactly this, albeit with virtual components and signals instead of physical parts and wires. In the above code example, nine components get instantiated following the keyword begin. As multiple copies of the same component must be told apart, each instance is assigned a unique identifier; u10, u20, ... , u42, in the occurrence. Further observe that the operator => in the port map clauses does not indicate any assignment. Rather, it is an association between two signals that stands for an electrical connection made between the instance terminal to its left and a node in the superordinate circuit the name of which is indicated to the right. The first four statements in the lfsr4 architecture body are component declarations. VHDL requires that the names and ports of all component models be known prior to instantiation.7 Signals running back and forth between instances must be declared as well. Those connecting to the outside world are automatically known from the port clause and need not be declared a second time. Inner nodes, in contrast, must be defined in a series of signal declarations just before the keyword begin.More on signals is to follow shortly. 7 There are essentially two ways for declaring a subcircuit model, yet the difference is a subtlety that can be skipped for a first reading. Assume you are describing a circuit by way of hierarchical composition in a top-down fashion, that is, beginning with the top-level design entity. In doing so, you must anticipate what subcircuits you will need. All that is really required for the moment are the complete port lists of those subcircuits-to-be that you are going to instantiate. Their implementations can wait until work proceeds to the next lower level of hierarchy. Declaring the external interfaces of such prospective subcircuits locally, that is within the current architecture body, is exactly what the component declaration statement is intended for. Now consider the opposite bottom-up approach. You begin with the lowest-level subcircuits by capturing the interface in an entity declaration and the implementation in an architecture body for each subcircuit. These models are then instantiated at the next-higher level of the design hierarchy, and so on. Instantiation always refers to an existing design entity which explains why this type of instantiation is said to be direct. No component declarations are required in this case, yet the component instantiation statement are complemented with the extra keyword entity and with an optional architecture identifier as follows. u6756 : entity lfsr4 (behavioral) port map( Clk_CI => n18, Rst_RBI => n8, Ena_SI => n199, Oup_DO => n4 ); For direct instantiation to work, design entities must be made visible with a use work.all clause. use clauses and configuration specification statements are to be introduced in sections 4.2.5 and 4.2.6 respectively. 190 CHAPTER 4 CIRCUIT MODELING WITH HDLs Observation 4.3. VHDL can describe the hierarchical composition of a digital circuit by instantiating components or entities and by interconnecting them with the aid of signals. A model that describes a circuit as a bunch of interconnected components is qualified as structural.It essentially holds the same information as the circuit netlist does. Manually coding architecture bodies in this way is not particularly attractive. Indeed, most structural models are obtained from register- transfer-level (RTL) models by automatic synthesis. 4.2.2 INTERACTING CONCURRENT PROCESSES The need for modeling concurrent activities While we have learned how to capture a circuit’s hierarchical composition, our model remains devoid of life up to this point as we have no means for expressing circuit behavior, precluding both simulation and synthesis. So there must be more to VHDL. The most salient feature of any electronic system is the concurrent operation of its subcircuits, just think of all those ICs on a typical circuit board, or of the many thousands of logic gates and storage cells within each such chip. This inherent parallelism contrasts sharply with the line-by-line execution of program code on a computer. Another innate trait is the extensive communication that permanently takes place between subcircuits and that is physically manifest in the multitude of wires that run across signal variable (continuous assignment or procedural block) process variable signal assignm. or process statement) process (conc./cond./sel. variable (or wire under certain circumstances) u82 u39 u18 u11 deemph filter sobel filter coeff comp deemph filter video processor u1 u101 line memory port entity design component instantiated (hierarchy) port module instance module (hierarchy) VHDL SystemVerilog FIGURE 4.3 HDL capabilities (II): ... plus behavior emulated by concurrent processes ... 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 191 chips and boards. This is simply because there can be no cooperation between subcircuits without on- going exchange of data. Now assume you wanted to write a software model that imitates the behavior of a substantial circuit using some traditional programming language such as Pascal or C. You would soon get frustrated because of the absence of constructs and mechanisms to handle simultaneous operation and interaction. Hardware description languages extend the expressive power of software languages by supporting concurrent processes and means for exchanging information between them, see fig.4.3 for a first idea. This bears some resemblance to real-time languages and, in fact, Ada has been taken as a starting point for defining VHDL. Signal The vehicle for exchanging dynamic information between concurrent processes is the signal,there exists no other mechanism in VHDL for this purpose.8 Any signal declared within an architecture body is strictly confined to that body and remains inaccessible from outside. A signal declaration must specify the name and the data type of the signal; an optional argument can be used to assign an initial value.9 Example of a signal declaration signal ThisMonth_D : month; Second example signal Error_D, Actual_D, Wanted_D : integer := 0; Hint: HDL code is easier to read when signals canbe toldfrom variables by their visual appearance. As part of an elaborate naming convention to be presented in section 6.7, we make it a habit to append an underscore followed by an informative suffix of a few upper-case letters to signals (but not to variables).10 How to describe combinational logic behaviorally Many arithmetic and logic computations are straightforward and can be expressed in one instruction with no need for branching. These are best captured in a concurrent signal assignment,the most simple VHDL construct for defining the value of a signal. Example with no operation ThisMonth_D <= AUGUST; Example with logic operations Oup_D <= Aa_D xor (Bb_D and not Cc_D); Example with an arithmetic operation Error_D <= Actual_D - Wanted_D; A concurrent signal assignment is nothing else than a process in a single statement. Whenever an operand on the right-hand side changes value, the expression is (re-)evaluated and the signal on the left-hand side gets updated accordingly. The assignment operator for signals is <= which choice is somewhat unfortunate because the same symbol also serves as relational operator (in lieu of ≤). 8 “Dynamic” means that the data are free to evolve over time, i.e. to change value as simulation progresses. The purpose of protected shared variables is a totally different one, see section 4.8.1. 9 Why this is inadequate for modeling a hardware reset will be explained in observation 4.17. 10 Attentive readers may notice that certain listings and schematic diagrams in this text feature identifiers that do not adhere to this scheme, e.g. CP instead of Cp_CI. This applies to standard cell connectors where the naming gets decided by the library vendor rather than by VLSI designers and HDL code writers. 192 CHAPTER 4 CIRCUIT MODELING WITH HDLs Situations abound where concurrent signal assignments do not suffice to express the desired func- tionality, e.g. because conditional execution is required. This is where two more elaborate constructs enter the picture. The selected signal assignment is reminiscent of a multiplexer (mux) or data switch: One out of multiple possible values gets assigned to a signal under control of a selecting expression. with ThisMonth_D select ThisQuarter_D <= Q1ST when JANUARY | FEBRUARY | MARCH, Q2ND when APRIL | MAY | JUNE, Q3RD when JULY | AUGUST | SEPTEMBER, Q4TH when others; The conditional signal assignment is very similar to the selected signal assignment but a bit more liberal in formulating the branching condition. An example follows. Spring_D <= true when (ThisMonth_D=MARCH and ThisDay_D>=21) or ThisMonth_D=APRIL or ThisMonth_D=MAY or (ThisMonth_D=JUNE and ThisDay_D<=20) else false; Where this is still insufficient to capture a desired input-to-output mapping in an adequate way, designers can recur to the process statement, a more powerful — but also rather tricky — construct for expressing a concurrent process. What sets it apart from the three signal assignment statements discussed above are essentially • Its capability to update two or more signals at a time, • The fact that the instructions for doing so are captured in a sequence of statements that are going to be executed one after the other, • The liberty to make use of variables for temporary storage, plus • A more detailed control over the conditions for activating the process.11 The process statement is best summed up as being concurrent outside and sequential inside.12 Process statements cannot be nested but may call subprograms. The example given next is semantically and functionally identical to the conditional signal assignment given before.13 11 Several of these items will be clarified in section 4.2.4. 12 “Sequential” here refers to code execution during simulation, not to the nature of the circuit being modeled. 13 The (all) term is an enhancement introduced with the VHDL-2008 standard revision. It saves programmers from having to enumerate all signals that appear on the right-hand side of assignments in the body of the process statement. For those who must work with earlier language revisions, the VHDL mode of the Emacs editor offers an “auto-update sensitivity list” function to help with this. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 193 LISTING 4.2 Code example of a combinational operation captured in a process statement. memless1: process (all) begin Spring_D <= false; -- execution begins here if ThisMonth_D=MARCH and ThisDay_D>=21 then Spring_D <= true; end if; if ThisMonth_D=APRIL then Spring_D <= true; end if; if ThisMonth_D=MAY then Spring_D <= true; end if; if ThisMonth_D=JUNE and ThisDay_D<=20 then Spring_D <= true; end if; end process memless1; -- process suspends here You can think of process statement used to model a combinational (sub)circuit as a container for a small program that generates the truth table. Interestingly, a process statement may as well model sequential circuit behavior. This depends on how the code is organized and the criteria will be detailed later, in observation 4.15. In the above code example, the identifier memless1 serves to express the designers’s intention. Note, however, this is just an optional free-choice label that has no impact on simulation or synthesis whatsoever. How to describe a register behaviorally As there exists no particular VHDL language element for modeling storage functions such as flip-flops, latches, registers, and the like, this must be achieved by organizing the process statement in a different way, see listing 4.3. Note that the present state of the process is kept from one activation to the next in a signal-type vector named State_DP. LISTING 4.3 Code example for an edge-triggered register that features an asynchronous reset, a synchronous load, and an enable. Actual designs are unlikely to combine all three mechanisms in a single register, so a subset of the clauses shown will most often do. p_memzing : process (Clk_C,Rst_RB) begin -- activities triggered by asynchronous reset if Rst_RB=’0’ then State_DP <= (others => ’0’); -- shorthand for all bits zero -- activities triggered by rising edge of clock elsif Clk_C’event and Clk_C=’1’ then -- when synchronous load is asserted if Lod_S=’1’ then State_DP <= (others => ’1’); -- shorthand for all bits one -- else assume new value iff enable is asserted elsif Ena_S=’1’ then State_DP <= State_DN; -- admit next state into state register end if; end if; end process p_memzing; 194 CHAPTER 4 CIRCUIT MODELING WITH HDLs Architecture body, behavioral view Most architecture bodies include a collection of concurrent processes that together make up the entity’s overall functionality. Such models are called behavioral because they specify how a design entity is to react in response to changing inputs. Potential reactions include the updating of outputs, the updating of the entity’s current state, the checking of compliance with some predefined timing conditions, or simply ignoring the new input. Listing 4.4 shows a behavioral architecture body for the LFSR circuit of listing 4.1. Taking fig.4.3 as a pattern, make a small drawing that illustrates the processes and the signals being exchanged. Find out what hardware item each process stands for and compare the drawing to that established earlier. What liberties do you have in coming up with a schematic diagram? LISTING 4.4 Behavioral view of a linear feedback shift register (LFSR) of length 4. -- architecture body architecture behavioral of lfsr4 is signal State_DP, State_DN : std_logic_vector(1 to 4); -- for present and next state respectively begin -- computation of next state using concatenation of bits State_DN <= (State_DP(3) xor State_DP(4)) & State_DP(1 to 3); -- updating of state process (Clk_CI,Rst_RBI) begin -- activities triggered by asynchronous reset if Rst_RBI=’0’ then State_DP <= \"0001\"; -- activities triggered by rising edge of clock elsif Clk_CI’event and Clk_CI=’1’ then if Ena_SI=’1’ then State_DP <= State_DN; -- admit next state into state register end if; end if; end process; -- updating of output Oup_DO <= State_DP(4); end behavioral; 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 195 Observation 4.4. In VHDL, the behavior of a digital circuit typically gets described by a collection of concurrent processes that execute simultaneously, that communicate via signals, and where each such process represents some subfunction. Hardware modeling styles compared Except for physical descriptions, VHDL supports various circuit modeling styles. A procedural model essentially describes functionality in a sequence of steps much as a piece of conventional software code. A circuit is captured in one process statement and its behavior gets implemented with the aid of sequential statements there.14 A dataflow model describes the behavior as a collection of concurrent signal assignments that get executed under the coordination of the signals exchanged. A structural model describes the composition of a circuit by way of component instantiation statements along with the interconnections in between. It is equivalent to a netlist. Listing 4.5 juxtaposes three architecture bodies, each coded from a different perspective while fig. 4.5 illustrates their differences and commonalities.15 Make sure you understand the profound difference between the procedural and dataflow models in spite of their apparent similarity. Observation 4.5. VHDL allows for procedural, dataflow, and structural modeling styles to be freely combined, and circuit models almost always take advantage of this. behavioral physical design view dataflowprocedural may all be combined in one HDL model concurrent processesof instructions sequence structural components interconnected (netlist) geometric shapes (layout) neither captured by VHDL nor by SystemVerilog, use GDS II, CIF, or the like FIGURE 4.4 Modeling styles and their relationships to HDLs and other EDA languages. 14 Procedural, dataflow, and structural are just user-defined terms, not reserved words of the language. 15 A full-adder has been chosen in this example for its simplicity and obviousness. Adders are normally synthesized from algebraic expressions that include a + operator. 196 CHAPTER 4 CIRCUIT MODELING WITH HDLs LISTING 4.5 Procedural, dataﬂow, and structural modeling styles compared. entity fulladd is port ( Aa_DI, Bb_DI, Cc_DI : in std_logic; Sum_DO, Carry_DO : out std_logic ); end fulladd; ------------------------------------------------------------------------------- -- compute result in a series of sequential steps architecture procedural1 of fulladd is begin process (Aa_DI,Bb_DI,Cc_DI) variable loc1, loc3, loc4 : std_logic; begin loc1 := Aa_DI xor Bb_DI; Sum_DO <= Cc_DI xor loc1; loc3 := Cc_DI nand loc1; loc4 := Aa_DI nand Bb_DI; Carry_DO <= loc3 nand loc4; end process; end procedural1; ------------------------------------------------------------------------------- -- spawn a concurrent signal assignment for each logic operation architecture dataflow1 of fulladd is signal Loc1_D, Loc3_D, Loc4_D : std_logic; begin Loc1_D <= Aa_DI xor Bb_DI; Sum_DO <= Cc_DI xor Loc1_D; Loc3_D <= Cc_DI nand Loc1_D; Loc4_D <= Aa_DI nand Bb_DI; Carry_DO <= Loc3_D nand Loc4_D; end dataflow1; ------------------------------------------------------------------------------- -- describe circuit network as a bunch of interconnected std cells -- note: cells from Synopsys’ generic library are used here architecture structuralgtech of fulladd is component GTECH_XOR2 port (A,B: in std_logic; Z: out std_logic ); end component; component GTECH_NAND2 port (A,B: in std_logic; 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 197 Z: out std_logic ); end component; signal Loc1_D, Loc3_D, Loc4_D : std_logic; begin u1: GTECH_XOR2 port map ( A=>Bb_DI, B=>Aa_DI, Z=>Loc1_D ); u2: GTECH_XOR2 port map ( A=>Cc_DI, B=>Loc1_D, Z=>Sum_DO ); u3: GTECH_NAND2 port map ( A=>Cc_DI, B=>Loc1_D, Z=>Loc3_D ); u4: GTECH_NAND2 port map ( A=>Aa_DI, B=>Bb_DI, Z=>Loc4_D ); u5: GTECH_NAND2 port map ( A=>Loc3_D, B=>Loc4_D, Z=>Carry_DO ); end structuralgtech; Loc1_D Loc3_D Loc4_D Aa_DI Bb_DI Cc_DI Sum_DO Carry_DO process port entity design component instantiated (hierarchy) signal variable operation combi- national sensitivity list nd xor nd Aa_DI Bb_DI Cc_DI Sum_DO Carry_DO nd xor loc1 loc3 loc4 nd nd nd xor xor Loc1_D Loc3_D Loc4_D Aa_DI Bb_DI Cc_DI Sum_DO Carry_DO procedural structural dataflow FIGURE 4.5 The modeling styles of listing 4.5 illustrated. 198 CHAPTER 4 CIRCUIT MODELING WITH HDLs 4.2.3 A DISCRETE REPLACEMENT FOR ELECTRICAL SIGNALS The need for multiple logic values to describe a circuit node An innocent approach to hardware modeling would be to use one binary digit per circuit node. VHDL actually provides two predefined data types for describing 2-valued data: bit which can take on value 0 or 1. boolean which can take on value false or true. Digital circuits exhibit traits that cannot be captured with a 2-valued abstraction, however. Just think of transients, indeterminate states following power-up, three-state outputs, multiple buffers driving a common node with an inherent potential for conflicts, and the like. Observation 4.6. Distinguishing between logic 0 and 1 is inadequate for modeling the binary signals found in digital circuits. A more elaborate multi-valued logic system must be sought that is capable of capturing the effects of both node voltage and source impedance. u82 u39 u18 u11 deemph filter sobel filter coeff comp deemph filter video processor u1 u101 line memory port entity design component instantiated (hierarchy) port module instance module (hierarchy) VHDL SystemVerilog resolved type electrical type electrical type net type (e.g. wire) (e.g. logic)(e.g. std_ulogic) (e.g. std_logic) signal variable (continuous assignment or procedural block) process variable signal assignm. or process statement) process (conc./cond./sel. variable (or wire under certain circumstances) FIGURE 4.6 HDL capabilities (III): ... plus data types for modeling electrical phenomena ... VHDL offers two more sophisticated and closely related data types named std_ulogic and std_logic respectively. Using either of these data types, the electrical conditions of a circuit node are condensed into one logic value at any time as shown in table 4.2 and fig.4.7a. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 199 A number of clarifications are due at this point. • Node voltage is quantized into three logic states: low logic low, that is below Ul. high logic high, that is above Uh. unknown may be either “low”, “high”, or anywhere in the forbidden interval in between, e.g. as a result from a short between two conflicting drivers. Table 4.2 The IEEE 1164 standard MVL-9 (multiple value logic) system. logic value → logic state ↓ low unknown high uninitialized U strong strength weak high-impedance 0X 1 LW H ZZ Z don’t care - No difference is made between a drive conflict, the outcome of which is truly unknown, and a ramping node, the voltage of which is known to assume values between thresholds Ul and Uh for some time. Either condition is modeled as “unknown”. • The amount of current that a subcircuit can sink or source — which is inversely related to the source impedance — gets mapped onto three discrete drive strengths: strong the low impedance value commonly exhibited by a driving output. high-impedance the almost infinite impedance exhibited by a disabled three-state output. weak an impedance somewhere between “strong” and “high-impedance”, e.g. as exhibited by a passive pull-up/-down resistor or a snapper. No difference is made between “charged high” and “charged low”. All high-impedance conditions are merged into a single condition of undetermined state or voltage. • Two extra values have been added, namely: uninitialized has never been assigned any value, e.g. the internal state of a storage element immediately after power-up, distinguished from “unknown\" as the latter can arise from causes other than failed initialization (applicable to simulation only). don’t care whether the node is “low” or “high” is considered immaterial, used by designers to leave the choice to the logic optimization tool (applicable to synthesis only). • Data types std_ulogic and std_logic are not part of the VHDL language IEEE 1076 itself, but have been defined in separate standard IEEE 1164 and made available in a package named ieee.std_logic_1164.16 The difference is to be explained shortly. 16 Incorporating a logic system into VHDL would have biased the language towards a specific circuit technology such as CMOS, TTL, ECL or GaAs, and would preclude its evolution towards unforeseen technologies in the future. Keeping the MVL-9 system apart makes it is possible to replace it by some user-defined alternative at any time should the necessity occur. 200 CHAPTER 4 CIRCUIT MODELING WITH HDLs Some logic values get collapsed during synthesis Not all nine options make sense from a synthesis point of view. The semantics of 0 and 1 are obvious. A don’t care symbol - on the right hand-side of an assignment implies the outcome is of no importance in which case logic optimization is free to select either a 0 or a 1 such as to minimize gate count, path delay, and/or power. Z calls for a driver with built-in three-state capability. Values U, X and W capture situations that may occur during simulation, but have no sensible interpretation for synthesis. L and H are not honored either. Most synthesis tools collapse meaningless (to them) values to more sensible ones, e.g. L to 0, H to 1,and X or W to -. Hint: For the sake of clarity and portability, do not use logic values other than 0, 1, Z and - in VHDL source code that is intended for synthesis. 0 1 X drive conflict Z− 0 no drive, high-impedance W weak drive weak drive L H strong drive 10 01 UU at = 0 t input does not matter single-driver signals Pp_DZ Qq_DZand no difference between may assume distinct logic values, std_ulogic std_logicand if multi-driver signal Com_DZ is of type then an error message gets issued then the conflict is resolved to Com_DZ = 1 std_ulogic std_logic ZX 0 10 1 SelA_S SelB_S X 0 0 1 Aa_D Qq_DZ Aa_D Bb_D Pp_DZ Bb_D SelA_S SelB_S Com_DZ (a) (b) FIGURE 4.7 The IEEE 1164 MVL-9 illustrated (a), type std_logic vs. std_ulogic (b). 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 201 How to model three-state outputs and busses How do we tell we want a node to be released, i.e. reverted to an undriven condition? With the aid of the MVL-9 system, the answer is straightforward: just assign logic value Z. Example Oup_DZ <= Inp_D when Ena_S=’1’ else ’Z’; As illustrated in fig.4.6, many digital circuits include multi-driver nodes that operate under control of multiple processes. How to model them is now obvious. In the code fragment below, the common node Com_DZ is left floating, that is in a high-impedance condition, when neither of the two drivers is enabled. In the occurrence of a parallel bus, assigning the shorthand form {(others = > ’Z’)} will do so for all bits, no matter how wide the bus is. signal Com_DZ, Aa_D, Bb_D, SelA_S, SelB_S : std_logic; ..... Com_DZ <= not Aa_D when SelA_S=’1’ else ’Z’; ..... Com_DZ <= not Bb_D when SelB_S=’1’ else ’Z’; ..... A multi-driver node may give rise to drive conflicts when something goes wrong, however.17 It is, therefore, important to know how such situations are dealt with during simulation. Built on top of std_ulogic sits a subtype called std_logic that shares the same set of nine values. As shown in fig.4.7b, the difference matters in the presence of multiple drivers. If the signal is of type std_ulogic, some form of error message will be generated during compilation or simulation.18 On a std_logic-type signal, in contrast, any conflict between diverging values is tacitly solved at simulation time by calling a resolution function that determines the most plausible outcome. One such function is part of the IEEE 1164 standard, its name is resolved,see listing 4.6.As an example, this function specifies that simulation is to continue with a 1 should an attempt be made to drive a node to Z, W and 1 at the same time. Observation 4.7. Signals of type std_logic can accommodate multiple drivers whereas those of type std_ulogic cannot. In more general terms, a signal is allowed to be driven from multiple processes iff a resolution function is defined that determines the outcome. The IEEE 1076 standard insists that a resolution function be available for any signal that is being driven from multiple sources but places the details under the designer’s control. Function resolved is fine for fully complementary static CMOS logic.19 Make sure to understand that there can be no such thing as a resolution function for variables. Thesameapplies to bit, bit_vector, integer, real,and similar data types. 17 A drive conflict implies that two or more processes attempt to drive a signal to incompatible logic values. 18 The details depend on the product being used. ModelSim categorically rejects any unresolved signals that are driven from multiple processes whereas Synopsys DesignCompiler accepts them with warnings issued at elaboration time. 19 By programming his own resolution functions, the designer can indicate how to solve driver conflicts in other situations, e.g. for open-collector and open-drain outputs with their wired-and operations. 202 CHAPTER 4 CIRCUIT MODELING WITH HDLs LISTING 4.6 IEEE 1164 standard resolution function. ------------------------------------------------------------------- -- resolution function \"resolved\" ------------------------------------------------------------------- constant resolution_table : stdlogic_table := ( -- --------------------------------------------------------- -- | UX01ZWLH- | | -- --------------------------------------------------------- ( ’U’, ’U’, ’U’, ’U’, ’U’, ’U’, ’U’, ’U’, ’U’ ), --|U| ( ’U’, ’X’, ’X’, ’X’, ’X’, ’X’, ’X’, ’X’, ’X’ ), --|X| ( ’U’, ’X’, ’0’, ’X’, ’0’, ’0’, ’0’, ’0’, ’X’ ), --|0| ( ’U’, ’X’, ’X’, ’1’, ’1’, ’1’, ’1’, ’1’, ’X’ ), --|1| ( ’U’, ’X’, ’0’, ’1’, ’Z’, ’W’, ’L’, ’H’, ’X’ ), --|Z| ( ’U’, ’X’, ’0’, ’1’, ’W’, ’W’, ’W’, ’W’, ’X’ ), --|W| ( ’U’, ’X’, ’0’, ’1’, ’L’, ’W’, ’L’, ’W’, ’X’ ), --|L| ( ’U’, ’X’, ’0’, ’1’, ’H’, ’W’, ’W’, ’H’, ’X’ ), --|H| ( ’U’, ’X’, ’X’, ’X’, ’X’, ’X’, ’X’, ’X’, ’X’ ) --|-| ); Selecting adequate data types Data types std_ulogic and std_logic emulate the electrical behavior of digital circuits in a much more realistic way than type bit does, and should be used whenever one wants to model an actual circuit node (as opposed to an auxiliary variable in a process statement, for instance).20 Usually std_logic prevails.21 20 In theory, any multi-valued data type occupies more memory space than its two-valued equivalent does, demands a higher computational effort and, hence, slows down simulation. In practice, everything depends on how the simulator software actually stores the bit, bit_vector, std_logic,and std_logic_vector types. It is, therefore, difficult to give general and qualified advice on whether it pays to begin with architecture-level simulations on the basis of bit types before upgrading to std_logic types during RTL design. What is for sure, however, is that you will not want to use MVL-9 data types for items other than actual circuit nodes. 21 Simulating with unresolved std_ulogic and std_ulogic_vector types is more conservative than simulating with their resolved counterparts because an error message will tell should any of those accidentally get involved in a drive or naming conflict. Yet, the IEEE 1164 standard recommends: “For scalar ports and signals, the developer may use either std_ulogic or std_logic type. For vector ports and signals, the developer should use std_logic_vector type.” Two reasons are given for this surprising advice: Concerns expressed by EDA vendors that they might not be able to optimize simulator performance for both data types, and interoperability of circuit and testbench models from different sources. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 203 data type bit std_ulogic std_logic deﬁned in VHDL ieee.std_logic_1164 value set per binary digit 2 9 for simulation purposes modeling of power-up phase no yes yes modelingofweakly drivennodes no yes yes modeling of multi-driver nodes no yes yes handling of drive conﬂicts n.a. reported resolved for synthesis purposes three-state drivers no yes yes don’t care conditions no yes yes Data types for modeling multi-bit signals It goes by itself that scalars of the same type can be collected into a vector, known as bit_vector, std_ulogic_vector,and std_logic_vector respectively. Unfortunately, the original standards did not support arithmetic operations on them. To fill the gap, two packages have been accepted as IEEE standard 1076.3. Both define two extra data types called unsigned and signed that are overloaded for standard VHDL arithmetic operators as much as possible. Objects of type unsigned are interpreted as unsigned integer numbers, and objects of type signed as signed integer numbers coded in 2’s complement (2’C) format. The table below compares the various types available that comprise multiple data bits. data type(s) deﬁned in VHDL VHDL value set per binary digit 2 2 9 2 9 word width 32 bit at the programmer’s discretion arithmetic operations yes no no yes yes logic operations no yes yes yes yes access to subwords or bits no yes yes yes yes modeling of electrical effects no no yes no yes integer, natural, positive bit_ vector std_logic _vector signed, unsigned signed, unsigned ieee.nu- meric_std ieee.nu- meric_bit ieee.std_ logic_1164 The difference between the two packages is that ieee.numeric_bit is composed of bit-type elements, whereas ieee.numeric_std operates on std_logic elements. As they otherwise define identical data types and functions, only one of the two packages can be used at a time. 204 CHAPTER 4 CIRCUIT MODELING WITH HDLs LISTING 4.7 Examples of VHDL multi-bit data types. integer -- 32 bit, signed, 2-valued natural -- 32 bit, range 0...(2ˆ31)-1, 2-valued positive -- 32 bit, range 1...(2ˆ31)-1, 2-valued bit_vector(11 downto 0) -- 12 bit, no numerical interpretation, 2-valued std_logic_vector(5 downto 0) -- 6 bit, no numerical interpretation, 9-valued unsigned(11 downto 0) -- 12 bit, unsigned, from ieee.numeric_bit -> 2-valued signed(5 downto 0) -- 6 bit, signed, from ieee.numeric_bit -> 2-valued unsigned(11 downto 0) -- 12 bit, unsigned, from ieee.numeric_std -> 9-valued signed(5 downto 0) -- 6 bit, signed, from ieee.numeric_std -> 9-valued VHDL is a strongly typed language, which implies that every object has a type and that extensive type checking is performed. Types must be converted before an assignment or a comparison becomes possible across distinct types, see section 4.8.6 for conversion functions. Orientation of binary vectors When encoding a number using a positional number system, there is a choice between spelling the data word with the MSB or the LSB first. In VHDL, this primarily applies to data types unsigned and signed.22 Any misinterpretation will cause severe malfunctions. Hint: Any vector that contains a data item coded in some positional number system should consistently be declared as (iMSB downto iLSB)where 2i is the weight of the binary digit with index i. The MSB will so have the highest index assigned to it and will appear in the customary leftmost position because iMSB ≥ iLSB. Example signal Hour_D : unsigned(4 downto 0) := \"10111\"; Data types unsigned and signed are intended to represent integer numbers with the radix point immediately following the LSB. We can thus illustrate their formats as ii...i\u0002 and si...i\u0002 respectively, where s stands for the sign bit and each i for one binary digit. Data types for modeling fractional and ﬂoating point numbers The IEEE 1076-2008 revision saw the arrival of data types for representing fixed and floating point numbers. Note that each of those types comes in a resolved and an unresolved variety. 22 bit_vector, std_logic_vector and std_ulogic_vector are concerned as well if used to encode numbers. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 205 type preﬁx unresolved_ unresolved data type ufixed sfixed float resolved deﬁned in fixed_ float_ generic_ generic_ pkg pkg arithmetics ﬁxed point ﬂoating point unsigned signed word width at the programmer’s discretion arithmetic operations yes logic operations yes access to subwords or bits yes modeling of electrical effects yes (resolved) Example of a fractional number signal HourWithQuarter_D : ufixed(4 downto -2) := \"1011111\"; ( iiiii \u0002 ff iMSB = 4, iLSB =−2, w = iMSB − iLSB + 1 = 7 with a range from 0 to 11111.112 = 31.7510 in increments of 1 4 and an initial value of 10111.112 = 23.7510) Second example variable JustIntegers : ufixed(7 downto 2) := \"010110\"; ( iiiiii 00\u0002 iMSB = 7, iLSB = 2, w = 6 assumes integer values from 4 to 1020 in steps of 4) Third example variable JustFractions : ufixed(-4 downto -7) := \"1000\"; ( \u0002000 ffff iMSB =−4, iLSB =−7, w = 4 with a range from 1 128 to 15 128 and initialized to 1 16 ) It goes by itself that the 2’C format is applied to represented fractional numbers with a sign. Example signal HourWithQuarter_D : sfixed(4 downto -2) := \"1011111\"; ( siiii \u0002 ff iMSB = 4, iLSB =−2, w = 7 with a range from 10000.002 =−16.0010 to 01111.112 = 15.7510 in increments of 1 4 and with an initial value of 10111.112 =−9.7510) Floating point numbers include a sign bit and an exponent by definition. Their formats adhere to the principles of the IEEE 754 standard see...e \u0002 ff...f except that the number of bits reserved to accommodate exponent and mantissa, #e and # f respectively, are not fixed but can be defined by the user in a type declaration.23 The mantissa is a fractional number normalized to the interval [1...2) and coded in 2’C format.24 The exponent is coded in offset-binary (O-B) format with an offset of 2#e−1 −1. Example signal ToyFloat_D : float(5 downto -8); ( seeeee \u0002 ffffffff #e = 5and # f = 8 with an offset of +15 which implies that the true unbiased exponent is calculated by subtracting 15 from eeeee ) 23 The default widths are #e = 8and # f = 23 respectively for a total word width of w = 32 bit. 24 As a consequence of the normalization, the binary digit of the mantissa immediately preceding the radix point is always 1 and, hence, devoid of information. The mantissa field is thus limited to the fractional bits to the right of the radix point with an (invisible) 1 implied to its left. See section A.1.2 for further details. 206 CHAPTER 4 CIRCUIT MODELING WITH HDLs To render the fixed and floating point packages as versatile as possible, several aspects relating to arithmetic behavior are kept user-adjustable with the aid of generics. • Rounding behavior (round ≈ vs. truncate ↓) • Overflow behavior (saturate vs. wrap around ⧸|⧸|⧸ ) • Number of guard bits for division operation25 4.2.4 AN EVENT-DRIVEN SCHEME OF EXECUTION The need for a mechanism that schedules process execution Recall the concurrent VHDL constructs introduced in section 4.2.2. ◦ Concurrent signal assignment (simplest). ◦ Selected signal assignment. ◦ Conditional signal assignment. ◦ The process statement (most powerful). current events invoke sensitive processes schedule future transactions processes being executed u82 u39 u18 u11 deemph filter sobel filter coeff comp deemph filter video processor u1 u101 line memory event queue mechanism port entity design component instantiated (hierarchy) port module instance module (hierarchy) VHDL SystemVerilog event transaction queue event event queue event scheduled event resolved type electrical type electrical type net type (e.g. wire) (e.g. logic)(e.g. std_ulogic) (e.g. std_logic) signal variable (continuous assignment or procedural block) process variable signal assignm. or process statement) process (conc./cond./sel. variable (or wire under certain circumstances) FIGURE 4.8 HDL capabilities (IV): ... plus an event queue mechanism that governs process activation ... 25 Calculating a result to a certain precision wr may require carrying out intermediate steps at some higher precision wi as roundoff errors can accumulate. Guard bits is the name for the extra wr − wi binary digits. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 207 Simulation must, of course, yield the same result as if the many processes present in a circuit model were operating simultaneously, although no more than a few processor cores are normally available for running the simulation code. What is obviously required then is a mechanism that schedules processes for sequential execution and that combines their effects such as to perfectly mimic concurrency. This mechanism that always sits in the background of HDL models is the central theme of this section. A good comprehension of how a model’s concurrent processes are being scheduled during simulation is essential for writing synthesis code. Simulation time versus execution time Simulation time is to an HDL model what physical time is to the hardware described by that model. The simulator software maintains a counter that is set to zero when a new simulation run begins and that registers the progress of simulation time from then on. This counter can be likened to a stopwatch, and any event that occurs during simulation can be thought of being stamped with the time currently displayed by that clock. Execution time, aka wall clock, refers to the time a computer takes to execute statements from the HDL code during simulation. It is of little interest to circuit designers as long as their simulation runs complete within an acceptable lapse of time. The beneﬁts of a discretized model of time Assume you wanted to model a digital circuit using some software language. Capturing the functionality of gates and registers poses no major problem, but how about taking into account their respective propagation delays? How would you organize a simulation run? You would find that no computations are required unless a circuit node switches. For the sake of efficiency, you would consider time as being discrete and devise some data structure that activates the relevant circuit models when they have to (re-)evaluate their inputs. These are precisely the ideas underlying event-driven simulation. Observation 4.8. In VHDL simulation, the continuum of time gets subdivided by events each of which occurs at a precise moment of simulation time. An event is said to happen whenever the value of a signal changes. Event-driven simulation The key element that handles events and that invokes processes is called event queue and can be thought of as a list where entries are arranged according to their time of occurrence, see fig.4.9.An entry is referred to as a transaction. Event-driven simulation works in cycles where three stages alternate: 1. Advance simulation time to the next transaction in the event queue thereby making it the current one.26 2. Set all signals that are to be updated at the present moment of time to the target value associated with the current transaction. 26 Multiple entries may be present for the same moment of time, but the general procedure remains the same. 208 CHAPTER 4 CIRCUIT MODELING WITH HDLs 3. Invoke all processes that need to respond to the new situation and have them (re-)evaluate their inputs. Every signal assignment supposed to modify a signal’s value causes a transaction to be entered into the event queue at that point in the future when that signal is anticipated to take on its new value. This stage comes to an end when all processes invoked suspend after having finished to schedule signal updates in response to their current input changes. After completing the third stage, a new simulation cycle is started. Simulation stops when the event queue becomes empty or when simulation time reaches some predefined final value. As nothing happens between transactions, an event-driven simulator essentially skips from one transaction to the next. No computational resources are wasted while models sit idle. Parallel processes and event-queue together form a powerful mechanism for modeling the behavior of discrete-time systems.27 Refer to fig.4.14 for a wider perspective on the simulation cycle. past events future transactions present moment of time event queue δ transaction can be inserted into the queue earliest moment of time at which a new (infinitesimal) cycles simulation simulation time event queue processes signals current events invoke sensitive processes executed schedule future transactions processes being process process gets invoked by events on signal B and schedules transactions on signals C and D sensitive input input signals output signals tpdpropagation delays CDA B (b)(a) FIGURE 4.9 Event-driven simulation in VHDL. Interactions between the event queue and a process (a), actions that repeat during every simulation cycle (b). Transaction versus event It is important to note that any signal update actually occurs in two steps. Execution of the assignment statement causes a transaction to be entered into the event queue but has no immediate impact. The update is to become effective only later when simulation time has reached the scheduled time for that transaction. 27 Incidentally, note that the event queue mechanism is by no means confined to electronic hardware but is also being used for simulating land, air and data traffic, for evaluating communication protocols, for planning fabrication and logistic processes, and in many other discrete-time applications. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 209 By the same token, not every signal assignment that is being carried out necessarily causes a signal to toggle. All too often, a process gets evaluated in response to some event on one of the wake-up signals just to find out that the result is the same as before. Consider a four-input nand gate or an E-type flip- flop, for instance. Also, the effect of a first transaction may get nullified by a second transaction inserted into the event queue afterwards. This is why transactions and events are not the same. A transaction that does not alter the value of a signal is still a transaction but it does not give rise to an event.28 Observation 4.9. Events are observable from the past evolution of a signal’s value up to the present moment of simulation time whereas transactions merely reflect future plans that may or may not materialize. Delay modeling In the context of simulation, the lapse of time between an event at the input of a process and the ensuing transaction at the output reflects the delay of the piece of hardware being modeled. Circuit delays are typically expressed as part of the signal assignment statement with an after clause.29 The first statement below models the propagation delay of an adder, by scheduling a transaction on its output tpd after an event at either input. The second statement also accounts for contamination delay tcd. Example Oup_D <= InpA_D + InpB_D after TPD; Second example Oup_D <= ’X’ after TCD, InpA_D + InpB_D after TPD; The δ delay For obvious reasons, a process cannot be allowed to schedule signal updates for past or present moments of time. It is, therefore, natural to ask “What is the earliest point in time at which a new transaction can be entered into the queue?” In the occurrence of VHDL, the answer is δ time later where δ does not advance simulation time but requires going through another simulation cycle. Put differently, δ can be thought of as an infinitesimally small lapse of time greater than zero. This refinement to the basic event queue mechanism serves to maintain a consistent order of transactions when the simulation involves models that are supposed to respond with delay zero. Without the δ time step, there would be no way to order zero-delay transactions and simulation could, therefore, not be guaranteed to yield meaningful and reproducible results. Although simulation time does not progress in regular intervals, δ may, in some sense, be interpreted as the timewise resolution of the simulator. 28 An event queue resembles very much an agenda in everyday life. Transactions are analogous to entries there. Signals reflect the evolution of the state of our affairs such as current location and occupation, health condition, social relations, material possessions, and much more. An entry in the agenda stands for some specific intention as anticipated today. At any time, an event, such as a phone call, may force us to alter our plans, i.e. to add, cancel or modify intended activities to adapt to a new situation. Some of our activities remain in vain and do not advance the state of affairs, very much as part of the transactions do not turn into events. Finally, in retrospect, an agenda also serves as a record of past events and bygone states. 29 Related language constructs that also express time intervals are wait for and reject.A wait for statement causes a process to suspend for the time indicated before being reactivated. The reject clause helps to describe rejection phenomena on narrow pulses in a more concise way. 210 CHAPTER 4 CIRCUIT MODELING WITH HDLs “How does a simulator handle signal assignments with no after clause?” The answer is that delay is assumed to be zero exactly as if the code would read ... after 0 ns ... . The transaction is then scheduled for the next simulation cycle or, which is the same, one δ delay later. Omitting the after clauses is typical in RTL synthesis models because physically meaningful delay data are unavailable at the time when such models are being established. Much the same applies to behavioral models at the algorithmic level. Hint: When simulating models with no delays other than the infinitesimally small δs, it becomes difficult to tell apart cause and effect in the output waveforms as the respective events appear to coincide. A trick is to artificially postpone transactions by a tiny amount of time in otherwise delayless signal assignments. To allow for quick adjustments, a constant of type time is best declared in a package and referenced throughout a model hierarchy. Note that the largest sum of fake delays must not exceed one clock period, though. Example Oup_D <= InpA_D + InpB_D after FAKEDELAY; Signal versus variable We now are in a good position to understand what separates signals from variables. While the difference in terms of scope has already been illustrated in fig.4.3, fig.4.10 exposes those partic- ularities that relate to time. A variable has no time dimension attached which is to say that it merely holds a present value. Neither transactions nor events are involved. The effect of a variable assignment is thus felt immediately, in the next statement, exactly as with any software programming language. simulation time changes scheduled to occur at later moments of time earliest moment of time a signal is allowed to change in response to an assignment at present moment of time kept on record waveforms so farobject’s value signalobject’s value variable future waveforms at present moment of time as planned and foreseen no plans known discarded immediately past events future transactions changes that have occurred δ minimum time step present event in response to an assignment at present moment of time only moment of time a variable is allowed to change (infinitesimal) FIGURE 4.10 The past, present and future of VHDL variables and signals. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 211 A signal, in contrast, is a typical element of VHDL. It is defined over time, which implies that a signal not only holds a present value, but also past values, plus those values that are anticipated to become manifest in the future. The effect of a signal assignment is not felt before the delay specified in the after clause has expired. Minimum delay, and default value in the absence of an after clause, is δ. As another particularity, it is possible to schedule multiple transactions in a single signal assignment statement. Example ThisMonth_D <= AUGUST, SEPTEMBER after 744 hr, OCTOBER after 1464 hr; Observation 4.10. VHDL signals convey time-varying information between processes via the event queue. They are instrumental in process invocation which is directed by the same mechanism. Variables, in contrast, are confined to within a process statement or a subprogram and do not interact with the event queue in any way. Ignoring the observation below is the cause of frequent misconceptions. Observation 4.11. A signal assignment does not become effective before the delay specified in the after clause has expired. In the absence of an explicit indication, there is a delay of one simulation cycle, so the effect can never be felt in the next statement. This sharply contrasts with a variable assignment the effect of which is felt immediately. To constantly remind programmers of this vital difference, two distinct symbols have been set aside in the VHDL syntax for the variable assignment := and for the signal assignment <= . Event-driven simulation revisited A process is either active or suspended at any time. Simulation time is stopped while the code of the processes presently active is being carried out which implies that (a) all active processes are executed concurrently with respect to simulation time, and (b) all sequential statements inside a process statement are executed in zero simulation time. The order of process invocation with respect to execution time is undetermined. Observation 4.12. As opposed to software languages where execution strictly follows the order of statements in the source code, there is no fixed ordering for carrying out processes (including concurrent signal assignments and assertion statements) in VHDL. When to invoke a process gets determined solely by events on the signals that run back and forth between processes. Sensitivity list Each process has its own set of signals that cause it to get (re-)activated whenever an event occurs on one or more of them. The entirety of such signals are aptly qualified as its wake-up or trigger signals although this is not official VHDL terminology. What are the wake-up signals of a given process? The answer depends on the type of process. In concurrent, selected, and conditional signal assignments, specifying wake-up signals is neither necessary nor legal as these are sensitive to any signal that appears on the right-hand side of the assignment operator <= by definition. In the example below, ThisMonth_D and ThisDay_D act as wake- up signals. 212 CHAPTER 4 CIRCUIT MODELING WITH HDLs Spring_D <= true when (ThisMonth_D=MARCH and ThisDay_D>=21) or ThisMonth_D=APRIL or ThisMonth_D=may or (ThisMonth_D=JUNE and ThisDay_D<=20) else false; The process statement is more liberal in that it accepts a special clause that collects the wake-up signals. This sensitivity list is included within parentheses to the right of the keyword process. Upon activation by any of the signals there, instructions get executed one after the other until the end process statement is reached. The process then reverts to its suspended state. The example below is semantically identical to the conditional signal assignment above. memless2: process (ThisMonth_D, ThisDay_D) -- an event on any signal listed activates the process begin Spring_D <= false; -- execution begins here if ThisMonth_D=MARCH and ThisDay_D>=21 then Spring_D <= true; end if; if ThisMonth_D=APRIL then Spring_D <= true; end if; if ThisMonth_D=may then Spring_D <= true; end if; if ThisMonth_D=JUNE and ThisDay_D<=20 then Spring_D <= true; end if; end process memless2; -- process suspends here This feature gives the engineer more freedom but also more responsibility as including or omitting a signal from a sensitivity list profoundly modifies process behavior. Imagine ThisDay_D is dropped. What does that change? Events on ThisDay_D are unable to activate the process and, hence, no longer update signal Spring_D. Only an event on signal ThisMonth_D causes the logic value of ThisDay_D to get (re-)evaluated. The state of Spring_D thus depends on past values of ThisDay_D — rather than just on the present one — which implies memory! Observation 4.13. Depending on its sensitivity list, the same process statement may or may not model sequential circuit behavior. Wait statement30 An alternative syntax for indicating where execution of a process statement is to suspend and when it is to resume, is to include a wait statement. Note that the two forms are mutually exclusive. That is, no process statement is allowed to include both a sensitivity list and waits. As the name suggests, process execution suspends when a wait statement is reached. It resumes with the subsequent instruction as soon as a condition specified is met and continues until a next wait is 30 Note to the reader: For a first reading, you may want to skip this paragraph and continue with “How to safely code sequential circuits for synthesis”. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 213 encountered, and so on. The wait statement comes in four flavors that differ in the nature of the condition for process reactivation: Statement Wake-up condition wait on ... an event (value change) on any of the signals listed here wait until ... idem plus the logic conditions specified here wait for ... a predetermined lapse of time as specified here wait none, sleep forever as no wake-up condition is given The code below is functionally interchangeable with process memless2 shown above but uses a wait on statement instead of a sensitivity list. memless3: process -- no sensitivity list because a wait statement is used begin Spring_D <= false; -- execution begins here if ThisMonth_D=MARCH and ThisDay_D>=21 then Spring_D <= true end if; if ThisMonth_D=APRIL then Spring_D <= true end if; if ThisMonth_D=MAY then Spring_D <= true end if; if ThisMonth_D=JUNE and ThisDay_D<=20 then Spring_D <= true end if; wait on ThisMonth_D, ThisDay_D; -- process suspends here until reactivated -- by an event on any of these signals end process memless3; -- execution continues with first statement Execution does not terminate with the end process statement but resumes at the top of the process body. In a process statement with a single wait, execution thus necessarily makes a full turn through the code each time the process gets (re-)activated.31 As opposed to this, only a fragment of the code gets executed in a process with multiple waits, which also implies that there can be no equivalent process with a sensitivity list in this case. Last but not least, take note of the limitation below. As they are of general nature, the reasons behind are going to be explained in section 4.4.3 jointly for VHDL and SystemVerilog. Observation 4.14. Process statements that include multiple waits are not amenable to synthesis. Only process statements with a single wait or with a sensitivity list are. What exactly is it that makes a process statement exhibit sequential behavior? The criteria relate to the organization of the source code and are as follows: Observation 4.15. A process statement implies memory whenever one or more of the conditions below apply. Conversely, memoryless behavior is being modeled iff none of them holds. ◦ The process statement includes multiple wait on or wait until statements. ◦ The process statement evaluates input signals that have no wake-up capability. ◦ The process statement includes variables that get assigned no value before being used. ◦ The process statement fails to assign a value to its output signals for every possible combination of values of its inputs. 31 The reason why the wait is placed at the end — rather than at the beginning — in the memless3 code is that all processes get activated once until they suspend as part of the initialization phase at simulation time zero. 214 CHAPTER 4 CIRCUIT MODELING WITH HDLs Observation 4.16. VHDL knows of no specific language construct that could tell a sequential model from a combinational one. Similarly, there are no reserved words to indicate whether a piece of code is intended to model a synchronous or an asynchronous circuit, or whether a finite state machine is of Mealy, Moore or Medvedev type. What makes the difference is the detailed construction of the source code. Hint: If a process statement is to model combinational logic, use the (all) notation introduced in listing 4.2. Further make sure to assign a value to each output for all possible combinations of input values. Failure to assign a don’t care to a signal —ortoa variable declared within a process statement — in situations where the object’s value does not seem to matter is a frequent mistake. After all, not assigning anything means that the object’s present value shall be maintained and, as a consequence, implies memory. Hint: As it is not immediately obvious whether a given process statement actually models memorizing or memoryless behavior, it is a good idea to make this information explicit in the source code, either by adding a comment or by choosing some meaningful name for the optional process label. This habit not only makes code easier to understand, but also helps to check the presence, nature, and number of bistables that are obtained from synthesis against the code writer’s intentions. This is important because a minor oversight during VHDL coding may turn a memoryless process statement into a memorizing one, and hence the associated circuit as well. How to safely code sequential circuits for synthesis As we have just learned, coding a process statement can be tricky as sensitivity list, wait statement(s), and wake-up condition(s) must be kept consistent. Listing 4.8 shows a proven template for any (sub)circuit with memory that is supposed to exhibit edge-triggered behavior, such as a register or counter, for instance. A clock signal in the sensitivity list is mandatory. One optional signal is accepted for implementing an asynchronous reset function. No other signals are permitted to (re-)activate the process. LISTING 4.8 Skeleton of a safe and synthesizable process statement with memory. process (Clk_C, Rst_R) <--------- sensitivity list, no more signals accepted! begin <--------- no other statement allowed here! -- activities triggered by asynchronous active-high reset if Rst_R=’1’ then PresentState_DP <= STARTSTATE; ..... 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 215 -- activities triggered by rising edge of clock elsif Clk_C’event and Clk_C=’1’ then <--------- no more term allowed here! <--------- extra subconditions, if any, accepted here. PresentState_DP <= NextState_DN; -- admit next state into state register ..... <--------- no further elsif or else clause allowed here! end if; <--------- no statement allowed here! end process; The reason for marking various items as disallowed is that their presence would render the model’s behavior inconsistent with single-edge-triggered clocking. Safe and predictable behavior are not the only merits of this scheme, it also ensures that the code is universally accepted for synthesis. An actual example has been given in listing 4.3. Depending on how the code is written, a process statement can be made to capture almost anything from a humble piece of wire up to an entire image compression circuit, for instance. Hint: For the sake of modularity, legibility, and smooth synthesis, do not cram too much functionality into a concurrent process. As a rule, prefer concurrent, selected and conditional signal assignments for describing combinational operations while packing any kind of data storage into separate process statements. Initial values cannot replace a reset mechanism As discussed earlier, the VHDL syntax supports assigning an initial value to a signal as part of its declaration statement, and the same applies for variables. Observation 4.17. The initial value given to a signal or variable defines the objects’s state at t = 0, just before the simulator enters the first cycle. A hardware reset, in contrast, remains ready to reconduct the circuit into a predetermined start state at any time t ≥ 0. This asks for distributing a dedicated signal to the bistables, both in the circuit and in its HDL model. Make sure you understand these are two totally different things. An initialized signal or variable does not model a hardware reset facility and will, therefore, not synthesize into one. This explains the presence of a reset clause in listings 4.3 and 4.8. Detecting clock edges and other signal events In listing 4.8, note that a signal attribute termed ’event ... is used to trigger action on rising clock edges. During automatic circuit synthesis, this will instruct the software to instantiate (edge-triggered) flip-flops when the netlist is being built. Alternatively, you may prefer to call upon function rising_edge(...) defined in the IEEE 1164 standard along with its counterpart falling_edge(...). Both functions work for signals of type std_logic and std_ulogic and make use on the ’event attribute internally. Example of clock edge detection if Clk_C’event and Clk_C=’1’ then ... endif; Alternative syntax32 if rising_edge(Clk_C) then ... endif; 32 Behavior would differ in the occurrence of a Z condition, but clocks typically have no three-state capability. 216 CHAPTER 4 CIRCUIT MODELING WITH HDLs Signal attributes Broadly speaking, a signal attribute is a named characteristic of a signal. The most important signal attribute is ’event, a boolean that is true iff an event has occurred during the current simulation cycle. In addition, VHDL knows of ’transaction, ’driving, ’last_value, ’delayed(), ’stable(),and five more. Users are free to declare their own signal attributes on top of those predefined in the IEEE 1076 standard. Not all signal attributes are supported by synthesis, though. In fact, ’event typically is the only one. As we will see shortly, ’stable is most useful in simulation models. How to check timing conditions Latches, flip-flops, RAMs, and all other sequential subcircuits impose specific timing requirements such as setup and hold times on data, and minimum pulse widths on clock inputs. Should any of these timing conditions get violated, their behavior becomes unpredictable. Checking for compliance is thus absolutely essential for meaningful simulations. Observation 4.18. The simulation model of a (sub)circuit is in charge of two things: 1. Check whether input waveforms indeed conform with its timing requirements (if any). 2. Evaluate input data and (re-)compute the equations to update outputs and state (if any). Actually, timing checks must be completed before logic evaluation can begin. They are essentially carried out by having the simulator inspect the event queue for events on the relevant signals. A timing condition is considered as respected if no events are found within the time span during which a given signal is required to remain stable. VHDL supports this idea with signal attributes such as ’stable and with concurrent assertion statements. Concurrent assertion statements Much like a concurrent signal assignment, a concurrent assertion statement is a process that gets (re-)activated by an event on any signal present in the assert expression. The difference is that an assertion is neither intended to schedule any new transaction nor capable of doing so. As they cannot update any signal values, concurrent assertion statements are qualified as passive processes.They are allowed at any level of abstraction in a design hierarchy and typically used to check user-defined properties and for collecting statistical data during simulation runs. The assert keyword is followed by a boolean expression. Upon activation, the process checks the value of that expression and takes no further action if it evaluates to true. If not so, the string following the keyword report is sent to the output device. The severity level — one of note, warning, error or failure — is reported to the simulator and defines where to send that message and whether to proceed or to abort the current simulation run. Listing 4.9 shows an example.33 33 The assertion statements are located in the architecture body here along with other concurrent processes. They might as well be included in the entity declaration, however, following the port clause and preceded by a begin keyword. Further note that the assertion statement also comes in a sequential version for inclusion in process statements and subprograms. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 217 LISTING 4.9 Setup and hold time checks in a D-type ﬂip-ﬂop model -- simulation model of a single-edge-triggered flip-flop with hardcoded timing entity setff is port ( Clk_CI : in std_logic; Rst_RBI : in std_logic; Dd_DI : in std_logic; Qq_DO : out std_logic ); end setff; architecture behavioral of setff is signal State_DP : std_logic; -- state signal begin assert (not (Clk_CI’event and Clk_CI=’1’ and not Dd_DI’stable(1.09 ns))) report \"setup time violation\" severity warning; assert (not (Dd_DI’event and Clk_CI=’1’ and not Clk_CI’stable(0.60 ns))) report \"hold time violation\" severity warning; memzing: process (Clk_CI, Rst_RBI) begin if Rst_RBI=’0’ then State_DP <= ’0’; elsif Clk_CI’event and Clk_CI=’1’ then State_DP <= Dd_DI; end if; end process memzing; Qq_DO <= State_DP after 0.92 ns; end behavioral; 218 CHAPTER 4 CIRCUIT MODELING WITH HDLs Dd_Di Clk_CI setup time hold time active clock edge check for no event on data at rising clock edge Dd_Di Clk_CI check for no event on clock if clock high at data change Dd_Di Clk_CI FIGURE 4.11 Checking setup and hold conditions by searching the event queue for past events.34 Observation 4.19. Any inspection of the event queue for compliance with timing requirements must necessarily look backward in time as forthcoming transactions might be added at any time and change the anticipated future evolution of the signal being examined. 4.2.5 FACILITIES FOR MODEL PARAMETRIZATION The need for supporting parametrized circuit models Imagine you have devised a synthesis model for some datapath unit that includes 16 data registers and that is capable of carrying out seventeen distinct arithmetic and logic operations on data words of 32 bit. While continuing on your project, you find out that you need a similar unit for address computations. There are significant differences, however. Addresses are just 24 bit wide, no more than five registers are required, and a subset of eight ALU operations suffices for the purpose. How do you handle such a situation? It would be fairly easy to derive a separate model by pruning the existing HDL code and by downsizing certain index ranges there. But what if you later needed a third and a fourth model? What if new requirements asked for substantial extensions to the existing model? The problem lies not so much in the initial effort of creating yet another model. Rather, it is the maintenance of a multitude of largely identical source codes that renders this approach so onerous. A truly reusable model, in contrast, should be written in a parametrized form such as to accommodate distinct choices and parameter settings within a single piece of code. The most salient features of VHDL towards this goal are generic parameters, configurations,and the generate statement that allows for conditional or repeated spawning of processes and that does the same for instantiation. Fig.4.12 shows how these fit into the general picture. 34 Setup and hold times are assumed to be positive in the figure. The modeling of sequential subcircuits that feature a negative timing condition becomes possible by adding fictitious input delays and by adjusting their values such as to make both setup and hold times positive. In order to preserve the original delay figures, all delays added at the input must be compensated for at the output. This is how negative timing condition are to be handled according to the IEEE 1076.4 VITAL standard, at any rate. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 219 u82 u39 u18 u11 deemph filter sobel filter coeff comp deemph filter video processor u1 u101 line memory event queue mechanism (parameter) generic items conditional parameter items conditional port entity design component instantiated (hierarchy) port module instance module (hierarchy) VHDL SystemVerilog resolved type electrical type electrical type net type (e.g. wire) (e.g. logic)(e.g. std_ulogic) (e.g. std_logic) event transaction queue event event queue event scheduled event signal variable (continuous assignment or procedural block) process variable signal assignm. or process statement) process (conc./cond./sel. variable (or wire under certain circumstances) FIGURE 4.12 HDL capabilities (V): ... plus parametrization with adjustable quantities and conditional items. Generics As stated earlier, signals carry dynamic, i.e. time-varying, information between processes and indirectly also between design entities. Generics, in contrast, serve to disseminate static, i.e. time- invariant, details to design entities. Just think of ◦ Word width, ◦ Active-low or -high signaling on inputs and outputs, ◦ Output drive capability, ◦ Functional options (e.g. details about an instruction set), ◦ Timing quantities (propagation and contamination delay, setup and hold time), and ◦ Capacitive load figures. A generic’s name is made part of the entity declaration in a so-called generic clause in much the same way as signals in a port clause. Indicating a default value is optional. As opposed to ports, generics do not have any direct hardware counterpart. An example follows. 220 CHAPTER 4 CIRCUIT MODELING WITH HDLs component parityoddw -- w-input odd parity gate generic ( WIDTH : natural range 2 to 32; -- number of inputs with supported range TCD : time := 0 ns, -- contamination delay with default value TPD : time := 1.0 ns ); -- propagation delay with default value port ( Inp_DI : in std_logic_vector(WIDTH-1 downto 0); Oup_DO : out std_logic ); end component; The values of the generics get naileddownwhenthe component is instantiated, overriding any defaults specified in the entity declaration. The syntax of this generic map roughly follows that of the port map. Note that no semicolon separates the two. constant NUMBITS : natural = 12; ..... -- component instantiation statement u173: parityoddw generic map ( WIDTH => NUMBITS, TCD => 0.05 ns, TPD => (NUMBITS * 0.1 ns) ) port map ( Inp_DI => DataVec_D , Oup_DO => Parbit_D ); ..... The generate statement used to conditionally spawn concurrent processes Situations exist where it is impossible to know and freeze the number of processes at the time when the source code is being written. Consider a datapath organized into multiple slices or other array-type circuits where some elemental subfunction is repeated along one or more dimensions. When each such subfunction is captured in a concurrent process of its own, the total number of processes is bound to vary as a function of array size. Now, it is just not possible to write a parametrized behavioral model in such a situation using the constructs of a software programming language that govern execution at run time. HDLs, therefore, provide the generate statement, a mechanism for producing processes under control of constants and generics. The code fragment below implements the Game of Life.35 35 Game of Life by John Horton Conway dates back to 1970. It is not really a game, in fact it is a 2-dimensional cellular automaton where each cell has eight neighbors. Each cell is either dead or alive, and its birth, survival and death depend on how many living neighbors the cell has. A living cell survives if it has two or three live neighbors, and a dead cell is turned into a living one if exactly three of its neighbors are alive (S23/B3). 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 221 ..... -- spawn a process for each cell in the array row : for ih in HEIGHT-1 downto 0 generate -- repetitive generation cell : for iw in WIDTH-1 downto 0 generate -- repetitive generation memzing: process(Clk_C) subtype live_neighbors_type is integer range 0 to 8; variable live_neighbors : live_neighbors_type; begin if Clk_C’event and Clk_C=’1’ then live_neighbors := live_neighbors_at(ih,iw); if State_DP(ih,iw)=’0’ and live_neighbors=3 then State_DP(ih,iw) <= ’1’; -- birth elsif State_DP(ih,iw)=’1’ and live_neighbors<=1 then State_DP(ih,iw) <= ’0’; -- death from isolation elsif State_DP(ih,iw)=’1’ and live_neighbors>=4 then State_DP(ih,iw) <= ’0’; -- death from overcrowding end if; end if; end process memzing; end generate cell; end generate row; ..... Note that the generate statement not only comes in a for form but also in an if form. Example if i=WIDTH-1 generate ... end generate; The generate statement used to conditionally instantiate components Many circuits are obtained by replicating subcircuits in a more or less regular way. It then makes sense to come up with an algorithm that instantiates and connects components such as to obtain the desired circuit pattern, effectively writing a parametrized netlist generator. Straight component instantiation cannot cope with such situations; what is needed is a controllable mechanism. The for ... generate and if ... generate statements indeed fill this role too. The major difference is that instantiation statements rather than concurrent processes are placed between the generate and end generate keywords this time. 222 CHAPTER 4 CIRCUIT MODELING WITH HDLs -- architecture body architecture structural of binary2gray is -- component declarations component xnor2_gate port (A1, A2 : in bit; ZN : out bit); end component; component inverter_gate port (I : in bit; ZN : out bit); end component; -- signal declarations signal Inode_D : bit_vector(WIDTH-1 downto 0); begin -- assemble logic network by instantiating and interconnecting components any_slice : for i in 0 to WIDTH-1 generate -- replicative generate -- a row of eqvs except for the MSB which requires an inverter less_significant : if i<WIDTH-1 generate -- conditional generate uxn : xnor2_gate -- component instantiation port map (A1=>Inp_D(i), A2=>Inp_D(i+1), ZN=>Inode_D(i)); end generate; most_significant : if i=WIDTH-1 generate -- conditional generate uin : inverter_gate -- component instantiation port map (I=>Inp_D(i), ZN=>Inode_D(i)); end generate; -- a final row of inverters uin : inverter_gate -- component instantiation port map (I=>Inode_D(i), ZN=>Oup_D(i)); end generate; end structural; Observation 4.20. Generate statements get interpreted as part of the so-called elaboration phase36 that precedes actual circuit simulation and synthesis. variables and signals are obviously not acceptable as conditions or as loop boundaries since they are subject to vary at run time, only constants and generics are. 36 To be explained shortly, see fig.4.14 for a first idea. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 223 The need to accommodate multiple models for one circuit block Please recall from table 4.1 that up to four HDL models may occur during a VLSI design cycle to capture a circuit-to-be at distinct levels of detail. Designers also experiment with alternative circuit architectures to compare them in terms of gate count, longest path delay, energy efficiency, and other figures of merit. VHDL accommodates all this need by allowing a design entity to have more than one architecture body, see fig.4.13. one entity declaration one or more architecture bodies behavioral structural architecture behavioral of binary2gray is begin end behavioral; Oup_DO <= bintogray(Inp_DI) after TPD; begin if scrapa(i+1)=’1’ then end if; end bintogray; variable scrapa : bit_vector(arg’length-1 downto 0); end loop; scrapa(i) := not scrapa(i); for i in 0 to arg’length-2 loop scrapa := arg; function bintogray (arg : bit_vector) return bit_vector is return scrapa; external view internal view higher level of abstraction next lower level of abstraction binary2gray Oup_DO(WIDTH-1 downto 0) bit_vector TPDtime natural WIDTH Inp_DI(WIDTH-1 downto 0) bit_vector time-invariant information generics convey static i.e. type of information conveyeditalic ports convey dynamic i.e. time-varying information identifier, i.e. name of entity or architecturebold as the design progresses typically used for synthesis typically used for place & route Inp_DI(WIDTH-1) ..... ..... ..... ..... ..... Oup_DO(WIDTH-1) Inp_DI(WIDTH-2) Oup_DO(WIDTH-2) Inp_DI(1) Inp_DI(0) Oup_DO(1) Oup_DO(0) FIGURE 4.13 Entity declaration versus architecture body and port versus generic. Warning: Do not pack two functionally distinct behaviors into two architecture bodies that belong to the same entity declaration as this is extremely confusing! Conﬁguration speciﬁcation and binding In the presence of multiple architecture bodies for one entity declaration, there must be a way to indicate which architecture to consider during simulation and synthesis. This is the configuration specification statement. The mechanism is more general, however, in that it makes it possible to specify a binding between any one instance of a component and some entity-architecture pair. Put differently, a component instantiated under one name can be bound to an entity with a different name, and this 224 CHAPTER 4 CIRCUIT MODELING WITH HDLs binding does not need to be the same for all instances drawn from that component. Configuration specification statements must appear in the design unit where the components concerned are being instantiated. Prior to simulation and synthesis, the VHDL code must be analyzed for configuration specification statements and the architecture bodies indicated must be brought to bear. This preparatory step is also referred to as binding. The code fragment below specifies that instance u113 of entity or component binary2gray is to be implemented by the architecture body behavioral of entity binary2gray whereas the body structural is to be used in the occurrence of u188. ..... for u113: binary2gray use entity binary2gray(behavioral); for u188: binary2gray use entity binary2gray(structural); ..... The code fragment below specifies that all instances of eqv gates and inverters that have been instantiated in the previous example are to be modeled by the respective entity-architecture pairs indicated. ..... for all: xnor2_gate use entity GTECH_XNOR2(behavioral); for all: inverter_gate use entity GTECH_NOT(behavioral); ..... Hint: Whenever you have multiple architecture bodies for one entity declaration, explicitly indicate which one to use as different EDA tools may otherwise pick different architecture bodies. Observation 4.21. VHDL provides a range of complementary constructs that are instrumental in writing parametrized circuit models. More particularly, it is possible to establish a model without committing the code to any specific number of processes and/or instantiated components. Elaboration The fact that the numbers of instances, processes and signals in an HDL model are not a priori fixed but obtained under control of the code itself necessitates a preparatory step before simulation or synthesis can begin, see fig.4.14. During that phase, termed elaboration, multiple instantiations get expanded and generate statements unrolled so that the final inventory of instances, processes and signals can be established. No new instances, processes or signals can be created after elaboration is completed. In preparation to simulating a design, all lowest-level design entities (leaf cells) must become available as behavioral models, either as part of the current VHDL design file itself or from a separate components library. Once elaboration is completed, the memory space necessary to hold the entirety of signals can be reserved. As processes work concurrently, memory space also needs to be set aside for the variables associated with every single process. In preparation to synthesizing a design, the software has to find out where to resort to actual synthesis and where to simply assemble a netlist from library components. Any elemental component instantiated 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 225 as part of a structural model must be available from the cell library targeted. The numbers of occurrences for all elemental and non-elemental components are frozen when elaboration completes. (every component instantiated must have a behavioral model) all signals (variables) initialized , all processes executed until suspended for the first time simulation time set to zero, initialization simulation time set to next transaction sensitive processes executed new transactions scheduled until they suspended again, actual or estimated delay data (SDF) progress in time executable program delay calculation cells and interconnect timing models for PTV situation of target library inventory and data SynopsysDC commands analyze elaborate compile / design optimization HDL simulation flow • full language supported • circuit models plus testbench RTL synthesis flow • subset of language only • circuit models exclusively default overwritten delay values code generation (every component instantiated be available from target library) but not detailed any further must gate-level netlist for target library functionally correct network of generic logic components minimized logic network state encoding state reduction and combinat. logic synthesis of registers and state machines specified with minimum states and near-optimum encoding Boolean optimization technology mapping constraints timing & circuit layout gate-level netlist layout extraction source code all generate statements unrolled, all instantiation statements honored, all processes and signals (variables) known all components bound , elaboration and binding parsed model syntax analysis actual capacitance and resistance values Delay calculation from layout • outside the scope of VHDL or SystemVerilog back-annotation (optional) signal updating process execution signal waveforms updated accordingly signals (variables) pending trans- actions carried out, FIGURE 4.14 Major steps in HDL simulation and synthesis (simpliﬁed).37 38 Simulation and synthesis essentially follow the same course outlined in fig.4.14 for SystemVerilog and for VHDL, except for the syntax analysis step which is most obviously language-specific. The conceptual commonalities underlying the two HDLs has enabled industry to develop EDA tools that support VHDL-SystemVerilog co-simulation. 37 It may seem counterintuitive that stimuli and expected responses appear nowhere in the simulation part of the drawing. The reason is that the testbench that feeds the event queue with the necessary transactions is itself being described using an HDL and thus enters the processing chain from the left much as the source code of the model under test (MUT). 38 Organization and vocabulary of commercial products may deviate considerably from our generic figure, take DesignCom- piler by Synopsys, for instance. While the “analyze” command does what its name suggests, the subsequent “elaborate” encompasses elaboration, binding, parts of synthesis, plus a preliminary mapping to logic gates from the GTECH generic library. Completing synthesis, timing-driven logic optimization, and technology mapping are then handled by another command named “compile”. 226 CHAPTER 4 CIRCUIT MODELING WITH HDLs 4.2.6 CONCEPTS BORROWED FROM PROGRAMMING LANGUAGES Structured ﬂow control statements Structured programming is universally accepted by the programming community. The IEEE 1076 standard defines a set of flow control statements that is consistent with this discipline and that supports exception handling in nested loops. Constructs include if...then...else, case, loop, exit, next the semantics of which are self-explanatory. Object A data object, or simply an object, is either a constant,a variable,a signal,or a file. Constant A constant holds a fixed value that gets assigned where the constant is declared. Example of a constant declaration constant FERMAT_PRIME_4 : integer := 65537; Variable A variable holds a changeable value. The scope is limited to the subprogram or process where the variable is declared, global variables do not exist.39 As an option, an initial value may be indicated where the variable is declared. Variables declared in a subprogram are (re-)initialized whenever the subprogram is called, whereas variables declared in a process retain their value from one process activation to the next, that is until they are assigned a new value. The assignment operator for variables is := whereas <= must be used when assigning to a signal.40 Example of a variable declaration variable Brd : real := 2.48678E5; Example of a variable assignment Brd := Brd + Ddr; User-deﬁned data types In VHDL, type is synonym for data type. Basically, a data type defines a set of values and a set of operations that can be performed on them. Types real, integer,and time are part of the IEEE 1076 standard itself, additional types for modeling electrical signals have been introduced in section 4.2.3. Users may declare their own data types or use predefined ones. Enumerated types are supported, and the predefined types character, boolean,and bit are in fact enumerated types. More data types added on top of the VHDL language for the modeling of various electrical phenomena have been discussed in section 4.2.3. Example of a type declaration type audiosample is signed(23 downto 0); Enumerated type declaration type month is (JANUARY, FEBRUARY, ... , DECEMBER); 39 So-called protected shared variables have been added later, please refer to section 4.8.1 for their usage. 40 Further insight on how variables relate to signals and time can be obtained from section 4.2.4. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 227 Subtypes A subtype shares the operations with its parent type, but differs in that it takes on a subset of data values only.41 Example of a subtype declaration subtype day is integer range 1 to 31; Hint: It is good engineering practice to indicate an upper and a lower bound when using integers for the purpose of hardware modeling. A simulation tool can then incorporate on-line checks to ascertain that data values indeed remain within their legal range, while synthesis is put in a position to selectively cut down the number of hardware bits rather than using the default word width of 32 bit. Arrays and records Scalar, i.e. atomic, data types can be lumped together to form composite data types. An array is a collection of elements all of which are of the same type. Example of an array type declaration type byte is bit_vector(7 downto 0); As opposed to the homogeneous composition of an array, a record may be assembled from elements of different types which is why it is qualified as heterogeneous. Another difference is that each element is identified by a name unique within the record. An example follows. type date is record date_year : integer; date_month : month; date_day : day; end record; Hint: Records come in handy when a set of signals connects to many entities or traverses multiple levels of hierarchy. Leaving clock and reset out, use a record to collect the entire set into one wholesale quantity that can be referenced as such. Adding or dropping a signal or changing the cardinality of a vector then becomes just a matter of modifying one record declaration in one package. Designers are so dispensed from rewriting the port clauses in all entity declarations. Type attributes and array attributes A type attribute is a named characteristic of a data type or data value. Type attributes make it possible to recover information such as the range of a type or subtype, the position number, the successor, or the predecessor of a given value in an enumerated type, and the like. An example for the usage of type attributes ’left and ’right is given further down in function nextmonth. Array attributes operate in a similar way on array types and array objects to obtain their bounds and cardinalities. In the example below, dateandtime’range returns 0to5 whereas asking for dateandtime’length yields a value of 6. type sixtupel is array (0 to 5) of integer; -- type declaration variable dateandtime : sixtupel; -- variable declaration 41 It is perfectly legal to declare a subtype with an improper subset, i.e. with a data set identical to that of its parent type. 228 CHAPTER 4 CIRCUIT MODELING WITH HDLs Subprogram, function, and procedure A subprogram is either a function or a procedure. A function returns a value and has no side effects, whereas the opposite is true for a procedure. Any subprogram is dynamic, which is to say that it does not persist beyond its current invocation. A first example of a function, named nextmonth,isgiven below, two more follow in listing 4.10. -- package declaration package calendar is type month is (JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER); subtype day is integer range 1 to 31; function nextmonth (given_month : month) return month; function nextday (given_day : day) return day; end calendar; -- package body package body calendar is function nextmonth (given_month : month) return month is begin if given_month=month’right then return month’left; else return month’rightof(given_month); end if; end nextmonth; function nextday (given_day : day) return day is ..... end nextday; end calendar; Package A package is a named collection of widely used constants, types, subprograms, and/or component declarations. Packages make it possible to sidestep the waste and perils of repeating supposedly identical declarations at multiple places. The contents of a package must be referenced in a use clause to make them accessible from some other design unit. This is shown in listings 4.10 and 4.21, the former of which defines two functions that are being called in the latter. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 229 LISTING 4.10 Package holding a pair of Gray code ↔ binary conversion functions. -- Mission: illustrate the use of a package in VHDL. -- Functionality: Gray code <-> binary code conversion functions. -- Author: H.Kaeslin. ------------------------------------------------------------------------------- library ieee; use ieee.std_logic_1164.all; ------------------------------------------------------------------------------- -- package declaration package grayconv is function bintogray (arg : std_logic_vector) return std_logic_vector; function graytobin (arg : std_logic_vector) return std_logic_vector; end grayconv; ------------------------------------------------------------------------------- -- -- ||||| -- binary to Gray |--. |--. |--. |--. | # of X-ops on -- conversion | ‘--X ‘--X ‘--X ‘--X longest paths -- for GRAYWIDTH=5 ||||| = 1 -- vvvvv -- bit positions 43210 X = XOR -- ||||| -- Gray to binary | ,--X ,--X ,--X ,--X # of X-ops on -- conversion |--’ |--’ |--’ |--’ | longest path -- for GRAYWIDTH=5 ||||| = GRAYWIDTH-1 -- vvvvv -- ------------------------------------------------------------------------------- -- package body package body grayconv is -- purpose: converts binary code into Gray code -- by way of in-place computation on a scratchpad variable function bintogray (arg : std_logic_vector) return std_logic_vector is variable scrapa : std_logic_vector(arg’length-1 downto 0); begin scrapa := arg; for i in 0 to arg’length-2 loop -- MSB remains unchanged 230 CHAPTER 4 CIRCUIT MODELING WITH HDLs if scrapa(i+1)=’1’ then scrapa(i) := not scrapa(i); end if; end loop; return scrapa; end bintogray; -- purpose: converts Gray code into binary code -- by way of in-place computation on a scratchpad variable function graytobin (arg : std_logic_vector) return std_logic_vector is variable scrapa : std_logic_vector(arg’length-1 downto 0); begin scrapa := arg; for i in arg’length-2 downto 0 loop -- MSB remains unchanged if scrapa(i+1)=’1’ then scrapa(i) := not scrapa(i); end if; end loop; return scrapa; end graytobin; end grayconv; VHDL applies the principles of information hiding to packages by separating package declaration from package body.42 Predeﬁned package standard All data types and subtypes of VHDL are actually defined in this package along with the pertaining logic and arithmetic operations and a few more features. As package standard comes with the language, always gets precompiled into design library std, and is made available there by default, users do not normally need to care much about it. Predeﬁned package textio There is no point in circuit simulation unless designers can document results and control simulation flow. To facilitate the coding of testbenches and other programs that interface with text files, type declarations and subprograms related to the reading and writing of ASCII files are collected in a special 42 Information hiding is an established principle in software engineering whereby a piece of software is divided into a declaration module or interface that must be made accessible to the caller, and a separate implementation module or body that is deliberately withheld. It is based on the observation that the interactions between software entities remain the same regardless of their implementation details, as long as their interfaces and overall functionalities do not change. Note the similarity with the black box concept from electrical engineering. 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 231 package named textio. Obviously, file I/O code is not for synthesis. Package textio routinely gets precompiled into library std as well. Yet, to make its definitions immediately available within a design unit, the pertaining source code must include the line use std.textio.all;. Design unit and design ﬁle Incremental compilation is based on the separate processing of individual program modules. The VHDL term for a language construct that is amenable to successful compilation43 independently from others is design unit. VHDL provides five kinds of design units, namelyn • package declaration, • package body, • entity declaration (see section 4.2.2), • architecture body (see sections 4.2.1 and 4.2.2), and • configuration declaration. One or more design units are stored in a design file.44 VHDL compilers, aka VHDL analyzers, accept one design file at a time and store the output in a design library, see fig.4.15. Observation 4.22. VHDL supports information hiding and incremental compilation. Design library A design library is a named repository for a collection of design units after compilation on a host computer, which has two major implications. Firstly a design library is not normally portable but specific for a platform. That is, the result depends on the computer for which it has been compiled and on the software tool being used (manufacturer, product, simulator or synthesizer). Secondly, a design library can accommodate many design files and design units. As a consequence, a library is typically referenced under a logical name that differs from the original name(s) of the design file(s) included. Also note that a VHDL design library can hold a program library, a component library, or both. 43 Compilation here loosely refers to the early processing steps that are necessary to simulate and/or synthesize a circuit from VHDL source code, also see fig.4.14. Incidentally, one can distinguish three operating principles in VHDL simulation. A first category translates the original VHDL source into some pseudo code which then gets interpreted by a simulation kernel. A second category begins by translating VHDL into C. This C code is then translated into the host’s machine code by the local C compiler before being linked with the simulation kernel. Simulation is by executing this machine code. The third category avoids the detour and compiles from VHDL to machine code directly which is why the approach is termed native compiled code. As we focus on the language itself, we will not differentiate between such software implementation issues in this text. 44 Incidentally, note that design_file serves as start symbol in formal definitions of VHDL. 232 CHAPTER 4 CIRCUIT MODELING WITH HDLs package body grayconv package body textio package body standard compile step VHDL source code platform-specific descriptions compile step compile step compile step design file entity declaration graycnt design units architecture body behavioral of graycnt design file entity graycnt_tb design units architecture body behavioral of graycnt_tb design file package declaration standard design units design file package declaration textio design units architecture body structural of graycnt design unit design file compile step simulation run results from synthesis design file package declaration grayconv design units design libraries compile step design library this library default destination for compiler and visible by default work design library this library visible by default std design library testbench report file results from simulation signal waveforms synthesis step (re)optimization step design database gate-level netlist conversion step final design library established by the user FIGURE 4.15 Organization of VHDL source code and intermediate data (simpliﬁed). Library and use clauses As most designs make use of VHDL code that is distributed over several design libraries, a mechanism is needed for importing outside subprograms, types, entities,and components. VHDL provides the library statement and the use clause for that. In the code fragment below, the first statement makes the design library testbench visible. That is, subprogram PutSimulationReportLine from package graycnt_tb, for instance, could then be referenced as testbench.graycnt_tb.PutSimulationReportLine provided the package had been 4.2 KEY CONCEPTS AND CONSTRUCTS OF VHDL 233 previously compiled into that very design library. Much the same holds for other items declared in the package. The subsequent use clause goes one step further in that it dispenses with the need of writing the full library and package names each time an item from package graycnt_tb is being referenced. In the occurrence, a simple PutSimulationReportLine suffices.45 A second example is shown in listings 4.10 and 4.21 where the code of a Gray counter has been distributed over two design units to illustrate the idea of separate compilation. -- library and use clauses library testbench; use testbench.graycnt_tb.all; ..... Special libraries work and std The design library named work differs from all other libraries in that VHDL compilers direct their output to that particular library unless explicitly instructed to do otherwise. Another special library termed std accommodates the compilation results from the two packages standard and textio that come along with VHDL. In addition, libraries work and std are universally visible because the two statements below are tacitly included in any design unit. library std, work; use std.standard.all; Note that standard is the only package that is immediately available by default, all others ask for an explicit use clause. In the example of fig.4.15, the programmer has to include a statement such as use work.grayconv.all; in the source code of graycnt in order to make the code of package grayconv available for reference there. 45 The improved convenience also opens the door for ambiguous references, however, if the same name happens to exist more than once across the various design libraries being made visible in this way. 234 CHAPTER 4 CIRCUIT MODELING WITH HDLs 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG with contributions by Beat Muheim and Frank Gürkaynak 4.3.1 CIRCUIT HIERARCHY AND CONNECTIVITY The need for supporting modularity and hierarchical composition Consider a motherboard from a personal computer, for instance. At the top level, you will discern a CPU, a graphics processor, a ROM or two, and several memory modules composed of multiple RAM chips. Then there are all sorts of peripheral circuits plus a variety of passive components. If you could look into the ICs, you would find datapaths, controllers, storage arrays, and the like. And each such block consists of thousands of logic gates and bistables, that are in turn assembled from the most elementary devices, from transistors. Electronic systems are organized into multiple layers of hierarchy because it is entirely impractical to specify, understand, design, fabricate, test, and document circuits with millions of gates as flat collections of transistors. Instead, larger entities are hierarchically composed from subordinate entities that are interconnected with the aid of busses and individual wires. Abstraction, modularity, and repetition further help to arrive at manageable circuit descriptions. Any HDL that wants itself useful must support these techniques, see fig.4.2 for a first impression. Module, structural view The module construct is the basic building block of a SystemVerilog design. Its primary purpose is to encapsulate the data, functionality and timing of a circuit or subcircuit. Each module consists of header and body that describe the circuit’s external and internal views respectively. The most important part of the header is the port list that enumerates those circuit nodes that are visible from outside between parentheses. Put differently, each signal that is part of the port list corresponds to a connector on the icon of the circuit. Fig.4.13 illustrates this with VHDL code, but you get the idea. The circuit’s internal technicalities are being detailed in the body, syntactically separated from the header by a semicolon. A module is permitted to contain instances of other modules, thereby creating hierarchy. A code example follows in listing 4.11. Although you are probably not yet in a position to understand everything, it should become clear that the circuit is composed of five logic gates and four flip-flops. As an exercise, draw a schematic diagram for the circuit. LISTING 4.11 Structural view of a linear feedback shift register (LFSR) of length 4. // module header with external interface module lfsr4 ( output logic Oup_DO, input logic Clk_CI, Rst_RBI, Ena_SI ) ; // reset is active low // module body with circuit structure 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 235 // declare a variable for each inner node logic [1:4] State_DP; logic n11, n21, n31, n41, n42; // instantiate cells and connect them by listing port maps // (cells are from Synopsys’ generic library in this example) GTECH_FD2 u10 ( .D(n11), .CP(Clk_CI), .CD(Rst_RBI), .Q(State_DP[1]) ); GTECH_FD2 u20 ( .D(n21), .CP(Clk_CI), .CD(Rst_RBI), .Q(State_DP[2]) ); GTECH_FD2 u30 ( .D(n31), .CP(Clk_CI), .CD(Rst_RBI), .Q(State_DP[3]) ); GTECH_FD4 u40 ( .D(n41), .CP(Clk_CI), .SD(Rst_RBI), .Q(State_DP[4]) ); GTECH_MUX2 u11 ( .A(State_DP[1]), .B(n42), .S(Ena_SI), .Z(n11) ); GTECH_MUX2 u21 ( .A(State_DP[2]), .B(State_DP[1]), .S(Ena_SI), .Z(n21) ); GTECH_MUX2 u31 ( .A(State_DP[3]), .B(State_DP[2]), .S(Ena_SI), .Z(n31) ); GTECH_MUX2 u41 ( .A(State_DP[4]), .B(State_DP[3]), .S(Ena_SI), .Z(n41) ); GTECH_XOR2 u42 ( .A(State_DP[3]), .B(State_DP[4]), .Z(n42) ); // connect state bit of rightmost flip-flop to output port assign Oup_DO = State_DP[4]; endmodule Hint: SystemVerilog is case-sensitive, e.g. clk_ci ∗= CLK_CI.46 Hint: Naming a signal input and output is all too tempting, yet these are reserved words in SystemVerilog, We recommend the use of Inp and Oup instead. How to compose a circuit from components How do you proceed when asked to fit a circuit board with components? You think of the exact name of a part required, go and fetch a copy of it, and solder the terminals of that one copy in a well-defined manner to metal pads interconnected by narrow lines on the board. The module instantiation statement of SystemVerilog does exactly this, albeit with virtual modules and variables47 instead of physical parts and wires. In the above code example, nine components get instantiated. As multiple copies of the same component must be told apart, each instance is assigned a unique identifier; u10, u20, ... , u42, in the occurrence. 46 No rule without exceptions. The letters d, h, o and b that indicate the base in decimal, hexadecimal, octal and binary numbers, the hex digits A through F, and the logic values X and Z are all case-insensitive. As an example, the casing 16’hFE39 for a 16-bit hexadecimal number takes advantage of this for maximum legibility. 47 Verilog traditionally required that modules be connected by wires but this is no longer mandatory. Generally speaking, SystemVerilog variables can assume many roles that necessitated a wire in classic Verilog. For simplicity, we prefer to work with variables in this text without emphasizing where wires might do the same job. wires continue to be compulsory for multi-driver nodes and for bidirectional inout ports, though. 236 CHAPTER 4 CIRCUIT MODELING WITH HDLs Each instantiation statement includes a port map, i.e. a series of associations where an electrical connection is indicated between an instance terminal (preceded by a dot .) and a node in the superordinate circuit the name of which is given in parentheses. Named port connections become overly verbose, however, when the instance ports and the connecting circuit nodes carry identical names anyway. Tedious example of named port connections .InpA(InpA), .InpB(InpB), .InpC(InpC) SystemVerilog comes to rescue with two shorthand notations for port mapping.48 A first construct does a name-based association for the port(s) specified, while the second does so for all ports of matching names (and leaves the others, if any, for regular named port connections). Example of dot name port connections .InpA, .InpB, .InpC Example of dot star port connections .* SystemVerilog requires that the signals running back and forth between instances be declared. Those connecting to the outside world are automatically known from the port list and need not be declared a second time. Inner nodes, in contrast, are defined in a series of variable declaration statements that precede the module instantiation statements. Observation 4.23. SystemVerilog can describe the hierarchical composition of a digital circuit by instantiating modules and by interconnecting them with the aid of wires that are normally modeled as variables. Special constructs for modeling busses Larger systems often make use of busses to connect multiple circuits. Using ports to describe a bus typically leads to duplication of code, making the code cumbersome to maintain and prone to error. The interface construct unique to SystemVerilog collects a set of signals into a single port without indicating a direction like input or output; bidirectional lines are also supported. In real life, not all signals will necessarily connect to each bus partner, however. Also, a bus master will very likely impose other signal directions than a slave. And a clock signal, if part of the bus, is driven from a single place. The modport command is here to capture such individual details, allowing engineers to differentiate between the description of the actual interface and the corresponding module connections. As an interface must get instantiated like a module, it is best thought of as a cable with multiple wires, and each modport as a specific type of connector for that cable. While both constructs are highly useful, giving syntax details and meaningful examples is well beyond this text, please refer to [100] [101] [98]. A model that describes a circuit as a bunch of interconnected components is qualified as structural. It essentially holds the same information as the circuit netlist does. Manually coding module bodies in this way is not particularly attractive. Indeed, most structural models are obtained from register-transfer- level (RTL) models by automatic synthesis. 48 For reasons of backward code compatibility, SystemVerilog continues to support a fourth scheme whereby ports get mapped according to their positions in the list, but this is not a recommended practice. 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 237 4.3.2 INTERACTING CONCURRENT PROCESSES The need for modeling concurrent activities While we have learned how to capture a circuit’s hierarchical composition, our model remains devoid of life up to this point as we have no means for expressing circuit behavior, precluding both simulation and synthesis. So there must be more to SystemVerilog. The most salient feature of any electronic system is the concurrent operation of its subcircuits, just think of all those ICs on a typical circuit board, or of the many thousands of logic gates and storage cells within each such chip. This inherent parallelism contrasts sharply with the line-by-line execution of program code on a computer. Another innate trait is the extensive communication that permanently takes place between subcircuits and that is physically manifest in the multitude of wires that run across chips and boards. This is simply because there can be no cooperation between subcircuits without on- going exchange of data. Now assume you wanted to write a software model that imitates the behavior of a substantial circuit using some traditional programming language such as Pascal or C. You would soon get frustrated because of the absence of constructs and mechanisms to handle simultaneous operation and interaction. Hardware description languages extend the expressive power of software languages by supporting concurrent processes and means for exchanging information between them, see fig.4.3 for a first idea. How to describe combinational logic behaviorally Many arithmetic and logic computations are straightforward and can be expressed in one instruction with no need for branching. These are best captured in a continuous assignment, the most simple SystemVerilog construct for defining the value of a variable (or of a wire). Example with no operation assign ThisMonth_D = AUGUST; Example with logic operations assign Oup_D = Aa_Dˆ(Bb_D &~Cc_D); Example with an arithmetic operation assign Error_D = Actual_D - Wanted_D; A continuous assignment is nothing else than a process in a single statement. Whenever an operand on the right-hand side changes value, the expression is (re-)evaluated and the variable on the left-hand side gets updated accordingly. Continuous assignments may call functions but no tasks.49 Situations abound where continuous assignments do not suffice to express the desired functionality, e.g. because conditional execution is required. A condition operator can then be included. The syntax goes “conditional_expression ? then_expression : else_expression”. Example with a condition assign Oup_D = Add_S ? (Aa_D + Bb_D) : (Aa_D - Bb_D); Where this is still inadequate for capturing the desired input-to-output mapping, designers can recur to a procedural block, a more powerful construct for expressing a concurrent process that comes in several varieties: always_comb, always_ff, always_latch, always, initial,and final. What sets all of them apart from the continuous assignment is this: 49 The difference will be explained in section 4.3.6. 238 CHAPTER 4 CIRCUIT MODELING WITH HDLs • The capability to update two or more variables at a time, • The fact that the instructions for doing so are captured in a sequence of statements that are going to be executed one after the other, • The liberty to make use of [local] variables for temporary storage, • A more detailed control over the conditions for activating the process.50 Procedural blocks are best summed up as being concurrent outside and sequential inside.51 The SystemVerilog construct for capturing combinational behavior in a sequence of statements is the always_comb block. You can think of an always_comb block as a container for a small program that generates the truth table for the (sub)circuit being modeled. always_comb begin Spring_D = 0; // execution begins here if (ThisMonth_D==MARCH & ThisDay>=21) Spring_D = 1; if (ThisMonth_D==APRIL) Spring_D = 1; if (ThisMonth_D==MAY) Spring_D = 1; if (ThisMonth_D==JUNE & ThisDay<=20) Spring_D = 1; end // process suspends here Note that the keywords begin and end are mandatory here because the always_comb block includes more than one statement; this will be different in the subsequent example. How to describe a register behaviorally SystemVerilog provides designers with another procedural block specifically for modeling flip-flops and other edge-triggered circuits. This is the always_ff block, see listing 4.12. Note that the present state of the process is kept from one activation to the next in a vector named State_DP. LISTING 4.12 Code example for an edge-triggered register that features an asynchronous reset, a synchronous load, and an enable. Actual designs are unlikely to combine all three mechanisms in a single register, so a subset of the clauses shown will most often do. always_ff @(posedge Clk_C, negedge Rst_RB) // sensitivity list // activities triggered by asynchronous reset if (~Rst_RB) State_DP <= ’0; // shorthand for all bits zero // activities triggered by rising edge of clock else 50 Several of these items will be clarified in section 4.3.4. 51 “Sequential” here refers to code execution during simulation, not to the nature of the circuit being modeled. 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 239 // when synchronous load is asserted if (Lod_S) State_DP <= ’1; // shorthand for all bits one // otherwise assume new value iff enable is asserted else if (Ena_S) State_DP <= State_DN; // admit next state into state register The always_comb and always_ff blocks are the most useful procedural blocks for circuit modeling. For brevity, we will not discuss the always_latch block that occupies an intermediate position between the two. The initial block is ill-suited for describing a piece of hardware as it executes only once and then suspends forever, and so is the final block. Section 4.3.4 will justify why the plain always block is not generally recommended either. Local versus shared variables During a simulation run, it is the totality of variables that together hold the current state of execution. A variable’s value can be altered by a continuous assignment or by an assignment instruction that is part of a procedural block (“procedural assignment”). A variable declaration must specify the data type and the name of the variable. An optional var keyword may be added to clarify the intention,52 and an initial value can also be assigned as part of the declaration.53 Example of a variable declaration var real Brd = 2.48678E5; Example of a procedural variable assignment Brd = Brd + Ddr; Example of a continuous variable assignment assign Brd = Brd + Ddr; As shown in fig.4.3, variables can be used in two distinct ways. Those declared within a procedural block are local and not visible from outside. Others participate in exchanging dynamic information between concurrent processes and/or between modules and must be declared at a higher level.54 VHDL provides programmers with a special language element, aptly named signal, for this purpose. SystemVerilog knows of no such construct, yet it helps to distinguish between local intra-process variables and shared inter-process variables mentally. Example of a variable declaration (for local use) month ThisMonth; Second example (for use as “signals”) real Error_D = -1.7, Actual_D = 4.3, Wanted_D = 6.0; Hint: HDL code is easier to read when “signals” can be told from local variables by their visual appearance. As part of an elaborate naming convention to be presented in section 6.7, we make it a habit to append an underscore followed by an informative suffix of a few upper-case letters to those variables that are shared between concurrent processes and serve to convey information from one to another.55 52 This is a feature introduced with SystemVerilog, var was not a reserved word in classic Verilog. 53 Why this is inadequate for modeling a hardware reset will be explained in observation 4.31. 54 “Dynamic” means that the data are free to evolve over time, i.e. to change value as simulation progresses. 55 Attentive readers may notice that certain listings and schematic diagrams in this text feature identifiers that do not adhere to this scheme, e.g. CP instead of Cp_CI. This applies to standard cell connectors where the naming gets decided by the library vendor rather than by VLSI designers and HDL code writers. 240 CHAPTER 4 CIRCUIT MODELING WITH HDLs Module, behavioral view Most modules include a collection of concurrent processes that together make up the module’s overall functionality. Such models are called behavioral because they specify how the module is to react in response to changing inputs. Potential reactions include the updating of outputs, the updating of the module’s current state, the checking of compliance with some predefined timing conditions, or simply ignoring the new input. Listing 4.13 shows a behavioral module for the LFSR circuit of listing 4.11. Taking fig.4.3 as a pattern, make a small drawing that illustrates the processes and the variables being exchanged. Find out what hardware item each process stands for and compare the drawing to that established earlier. What liberties do you have in coming up with a schematic diagram? LISTING 4.13 Behavioral view of a linear feedback shift register (LFSR) of length 4. // external interface of module module lfsr4 ( input logic Clk_CI, Rst_RBI, Ena_SI, // reset is active low output logic Oup_DO ); // behavioral model for module // declare internal variables logic [1:4] State_DP, State_DN; // for present and next state // computation of next state using concatenation of bits assign State_DN = {(State_DP[3] State_DP[4]), State_DP[1:3]}; // updating of state always_ff @(posedge Clk_CI, negedge Rst_RBI) // activities triggered by asynchronous reset if ( Rst_RBI) State_DP <= 4’b0001; // activities triggered by rising edge of clock else if (Ena_SI) State_DP <= State_DN; // admit next state into state register // updating of output assign Oup_DO = State_DP[4]; endmodule 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 241 Observation 4.24. In SystemVerilog, the behavior of a digital circuit typically gets described by a collection of concurrent processes that execute simultaneously, that communicate via variables, and where each such process represents some subfunction. Hardware modeling styles compared Except for physical descriptions, SystemVerilog supports various circuit modeling style. A procedural model essentially describes functionality in a sequence of steps much as a piece of conventional software code. A circuit is captured in one procedural block and its behavior gets implemented with the aid of sequential statements there.56 A dataflow model describes the behavior as a collection of continuous assignments that get executed under the coordination of the variables exchanged, and where each such variable stands for a signal. A structural model describes the composition of a circuit by way of module instantiation statements along with the interconnections in between. It is equivalent to a netlist. Listing 4.14 juxtaposes three modules, each coded from a different perspective while fig.4.16 illustrates their differences and commonalities.57 Make sure you understand the profound difference between the procedural and dataflow models in spite of their apparent similarity. Observation 4.25. SystemVerilog allows for procedural, dataflow, and structural modeling styles to be freely combined, see fig.4.4. Circuit models almost always take advantage of this. LISTING 4.14 Procedural, dataﬂow, and structural modeling styles compared. // compute result in a series of sequential steps module fulladd_procedural ( input logic Aa_DI, Bb_DI, Cc_DI, output logic Sum_DO, Carry_DO ); always_comb begin logic loc1, loc3, loc4; loc1 = Aa_DI ˆ Bb_DI; Sum_DO = Cc_DI ˆ loc1; loc3 = ~(Cc_DI & loc1); loc4 = ~(Aa_DI & Bb_DI); Carry_DO = ~(loc3 & loc4); end endmodule //----------------------------------------------------------------------------- // spawn a continuous assignment for each logic operation 56 Procedural, dataflow, and structural are just user-defined terms, not reserved words of the language. 57 A full-adder has been chosen in this example for its simplicity and obviousness. Adders are normally synthesized from algebraic expressions that include a + operator. 242 CHAPTER 4 CIRCUIT MODELING WITH HDLs module fulladd_dataflow ( input logic Aa_DI, Bb_DI, Cc_DI, output logic Sum_DO, Carry_DO ); logic Loc1_D, Loc3_D, Loc4_D; assign Loc1_D = Aa_DI ˆ Bb_DI; assign Sum_DO = Cc_DI ˆ Loc1_D; assign Loc3_D = ~(Cc_DI & Loc1_D); assign Loc4_D = ~(Aa_DI & Bb_DI); assign Carry_DO = ~(Loc3_D & Loc4_D); endmodule //----------------------------------------------------------------------------- // describe circuit network as a bunch of interconnected std cells // note: cells from Synopsys’ generic library are used here module fulladd_structuralgtech ( input logic Aa_DI, Bb_DI, Cc_DI, output logic Sum_DO, Carry_DO ); logic Loc1_D, Loc3_D, Loc4_D; GTECH_XOR2 u1 ( .A(Bb_DI), .B(Aa_DI), .Z(Loc1_D) ); GTECH_XOR2 u2 ( .A(Cc_DI), .B(Loc1_D), .Z(Sum_DO) ); GTECH_NAND2 u3 ( .A(Cc_DI), .B(Loc1_D), .Z(Loc3_D) ); GTECH_NAND2 u4 ( .A(Aa_DI), .B(Bb_DI), .Z(Loc4_D) ); GTECH_NAND2 u5 ( .A(Loc3_D), .B(Loc4_D), .Z(Carry_DO) ); endmodule 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 243 nd nd nd xor xor nd xor nd nd xor loc1 loc3 loc4 process port module instance module (hierarchy) or wire variable operation combi- national sensitivity list variable Loc1_D Loc3_D Loc4_D Loc1_D Loc3_D Loc4_D Aa_DI Bb_DI Cc_DI Sum_DO Carry_DO Aa_DI Bb_DI Cc_DI Sum_DO Carry_DO Aa_DI Bb_DI Cc_DI Sum_DO Carry_DO procedural structural dataflow FIGURE 4.16 The modeling styles of listing 4.14 illustrated. 4.3.3 A DISCRETE REPLACEMENT FOR ELECTRICAL SIGNALS The need for multiple logic values to describe a circuit node An innocent approach to hardware modeling would be to use one binary digit per circuit node. In SystemVerilog, the standard 2-valued data type is bit which can take on value 0 or 1. Digital circuits exhibit traits that cannot be captured with a 2-valued abstraction, however. Just think of transients, indeterminate states following power-up, three-state outputs, multiple buffers driving a common node with an inherent potential for conflicts, and the like. You may want to refer to fig.4.6 for the larger picture. Observation 4.26. Distinguishing between logic 0 and 1 is inadequate for modeling the binary signals found in digital circuits. A more elaborate multi-valued logic system must be sought that is capable of capturing the effects of both node voltage and source impedance. SystemVerilog offers two more sophisticated data types named logic and wire respectively.58 Using either of these data types, the electrical conditions of a circuit node are condensed into one logic value at any time as shown in table 4.3 and fig.4.17a. 58 Verilog adepts will notice that this is not the full story. For one thing, logic was named reg in Verilog, a misleading choice. reg continues to be supported in SystemVerilog for compatibility with legacy code, but its use is discouraged. For another thing, there exist multi-valued data types other than logic and wire. As their intended purpose — switch- level simulation of transistor networks — is irrelevant to synthesis-based VLSI design, introducing them here would cause unnecessary confusion. 244 CHAPTER 4 CIRCUIT MODELING WITH HDLs Table 4.3 The SystemVerilog 4-valued logic system MVL-4. Symbol X here stands for any condition of ambiguity. No distinction is made between uninitialized, unknown and don’t care. logic value → logic state ↓ low unknown high uninitialized X strength driven high-impedance 0X 1 ZZ Z don’t care X A number of clarifications are due at this point. • Node voltage is quantized into three logic states: low logic low, that is below Ul. high logic high, that is above Uh. unknown may be either “low”, “high”, or anywhere in the forbidden interval in between, e.g. as a result from a short between two conflicting drivers. No difference is made between a drive conflict, the outcome of which is truly unknown, and a ramping node, the voltage of which is known to assume values between thresholds Ul and Uh for a brief moment of time. Either condition is modeled as “unknown”. • The amount of current that a subcircuit can sink or source — which is inversely related to the source impedance — gets mapped onto just two discrete drive strengths:59 strong the low impedance value commonly exhibited by a driving output. high-impedance the almost infinite impedance exhibited by a disabled three-state output. No difference is made between “charged high” and “charged low”. All high-impedance conditions are merged into a single condition of undetermined state or voltage. • One extra value has been added, namely: don’t care whether the node is “low” or “high” is considered immaterial, used by designers to leave the choice to the logic optimization tool (applicable to synthesis only). The same symbol X is indeed being used as for “unknown\", an oddity of the language. • SystemVerilog knows of no particular value to describe a circuit node that has never been assigned any value following power-up. No attempt is made to distinguish between “unknown\" and “uninitialized”. Again, the X serves to denote either condition. 59 Note the absence of drive strength “weak” as exhibited by a passive pull-up/-down resistor or a snapper. 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 245 0 1 X drive conflict strong drive 10 01 XX at = 0 t no difference between logic wireand ZX 0 10 1 X 0 0 1 Z− 0 no drive, high-impedance input does not matter SelA_S SelbB_S Aa_D Qq_DZ Aa_D Bb_D Pp_DZ Bb_ D SelA_S SelB_S Com_DZ single-driver signals Pp_DZ Qq_DZand may assume distinct logic values, then an error message gets issued then the conflict is resolved to Com_DZ = 1 logic wire if multi-driver signal Com_DZ is of type (a) (b) FIGURE 4.17 The SystemVerilog MVL-4 illustrated (a), types logic and wire compared (b). How to model three-state outputs and busses How do we tell we want a node to be released, i.e. reverted to an undriven condition? With the aid of the MVL-4 system, the answer is straightforward: just assign logic value Z. Example assign Oup_DZ = Ena_S ? Inp_D : 1’bZ; As illustrated in fig.4.6, many digital circuits include multi-driver nodes that operate under control of multiple processes. How to model them is now obvious. In the code fragment below, the common node Com_DZ is left floating, that is in a high-impedance condition, when neither of the two drivers is enabled. In the occurrence of a parallel bus, assigning ’{default:1’bZ} or the shorthand form ’Z will do so for all bits, no matter how wide the bus is. 246 CHAPTER 4 CIRCUIT MODELING WITH HDLs wire Com_DZ; logic Aa_D, Bb_D, SelA_S, SelB_S; ..... assign Com_DZ = SelA_S ? ~Aa_D : 1’bZ; ..... assign Com_DZ = SelB_S ? ~Bb_D : 1’bZ; ..... A multi-driver node may give rise to drive conflicts when something goes wrong, however.60 It is, therefore, important to know how such situations are dealt with during simulation. If the node is modeled using a variable of type logic, some form of error message will be generated during compilation or simulation. On a wire-type node, in contrast, any conflict between diverging values is tacitly solved at simulation time by calling a resolution function that determines the most plausible outcome, see table 4.4. As an example, this function specifies that simulation is to continue with a 1 should an attempt be made to drive a node to Z and 1 at the same time. The difference is illustrated in fig.4.17b. Table 4.4 The SystemVerilog built-in resolution function for data type wire. X01 Z X XXX X 0 X0X 0 1 XX1 1 Z X01 Z Observation 4.27. Nodes modeled using data type wire can accommodate multiple drivers whereas those modeled using logic — or any other type of variable for that matter — cannot. Selecting adequate data types Data type logic emulates the electrical behavior of digital circuits in a much more realistic way than type bit does and should be used whenever one wants to model an actual circuit node (as opposed to a local variable in a procedural block, for instance).61 60 A drive conflict implies that two or more processes attempt to drive a signal to incompatible logic values. 61 For efficiency considerations see footnote 20. 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 247 data type bit logic wire value set per binary digit 2 4 4 for simulation purposes modeling of power-up phase no passable passable modeling of weakly driven nodes no no no modeling of multi-driver nodes no no yes handling of drive conﬂicts n.a. n.a. resolved for synthesis purposes three-state drivers no yes yes don’t care conditions no yes yes Data types for modeling multi-bit signals It goes by itself that scalars of the same type can be collected into a vector. The table below compares such vectors with various other types that comprise multiple data bits. bit [23:0] // 24 bit, 2-valued -> no electrical modeling capability logic [7:0] // 8 bit, 4-valued -> elec. modeling capab., single driver wire [24:11] // 14 bit, 4-valued -> elec. modeling capab., multiple drivers data type(s) byte, integer bit logic wire shortint, vector vector vector int, longint value set per binary digit 2 4 2 4 4 word width 8/16/32/64 32 at the programmer’s discretion arithmetic operations yes yes yes yes yes default signed/unsigned signed signed unsign. unsign. unsign. logic operations yes yes yes yes yes access to subwords or bits yes yes yes yes yes modeling of electrical effects no passablea no passablea passable a Except that multiple drivers that are not allowed with this data type. SystemVerilog is much more relaxed on data types than VHDL. It is perfectly legal to perform arithmetic operations on bit vectors and to carry out logic operations with numerical data types, for instance. Accessing just one bit or just a few bits in an integer is also supported. What’s more, data words get tacitly extended or slashed to make things fit in assignments between items of unlike widths. This latitude often comes handy as there is almost no obligation to include type conversions in the code. The down side is that it makes it impossible for EDA tools to find suspect code fragments during compilation. And type-related issues are indeed common and sometimes subtle [97]. 248 CHAPTER 4 CIRCUIT MODELING WITH HDLs Numerical data types can be explicitly declared as unsigned or signed with the aid of a modifier. unsigned indicates an unsigned integer number, and signed a signed integer number coded in 2’s complement (2’C) format.62 In the absence of a modifier, the number representation scheme defaults to signed for byte, shortint, int, longint,and integer, and to unsigned for other data types, but it is always a good idea to make the programmer’s intention explicit. LISTING 4.15 Examples of SystemVerilog multi-bit data types. byte // 8 bit, signed, 2-valued, single driver bit [7:0] // 8 bit, unsigned, 2-valued, single driver shortint signed // 16 bit, signed, 2-valued, single driver int unsigned // 32 bit, unsigned, 2-valued, single driver integer // 32 bit, signed, 4-valued, single driver logic unsigned [11:0] // 12 bit, unsigned, 4-valued, single driver logic signed [5:0] // 6 bit, signed, 4-valued, single driver wire [6:1] // 6 bit, unsigned, 4-valued, multiple drivers Orientation of binary vectors When encoding a number using a positional number system, there is a choice between spelling the data word with the MSB or the LSB first. In SystemVerilog, this primarily applies to logic-and wire-type vectors. Any misinterpretation will cause severe malfunctions. Hint: Any vector that contains a data item coded in some positional number system should consistently be declared as [iMSB :iLSB] where 2i is the weight of the binary digit with index i. The MSB will so have the highest index assigned to it and will appear in the customary leftmost position because iMSB ≥ iLSB. Example logic [4:0] Hour_D = 5’b10111; All multi-bit data types introduced so far are intended to represent integer numbers with the radix point immediately following the LSB. We can thus illustrate their formats as ii...i\u0002 and si...i\u0002 respectively, where s stands for the sign bit and each i for one binary digit. Let us conclude our overview on data types with a word of advice. Hint: Rather than silently relying on defaults to keep the code as terse as possible, make your intentions reasonably explicit in the code as this will not only improve code quality but also accelerate debugging and code maintenance. This is particularly important in SystemVerilog where defaults are irregular, where little type checking is performed, where data words get tacitly extended or slashed in width to make things fit, and where there is almost no obligation to include type conversions. 62 No provisions are made to support other schemes such as 1’s complement (1’C) or sign-and-magnitude (S&M). Please check section A.1.1 if not familiar with the number representation schemes used in computing. 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 249 4.3.4 AN EVENT-DRIVEN SCHEME OF EXECUTION The need for a mechanism that schedules process execution Recall the concurrent SystemVerilog constructs introduced in section 4.3.2. ◦ Continuous assignment. ◦ Procedural blocks always_comb, always_ff,and always_latch (for circuit modeling). ◦ Procedural blocks always, initial,and final (for testbenches). Simulation must, of course, yield the same result as if the many processes present in a circuit model were operating simultaneously, although no more than a few processor cores are normally available for running the simulation code. What is obviously required then is a mechanism that schedules processes for sequential execution and that combines their effects such as to perfectly mimic concurrency. SystemVerilog and VHDL share the same model of communicating concurrent processes. The princi- ples of event-driven simulation, explained in section 4.2.4, are also much the same. What follows here are just the SystemVerilog particularities. This, together with a general understanding of event-driven simulation as obtained from section 4.2.4 up to observation 4.9 and from fig.4.18, should suffice as a background for coding RTL circuit models.63 Please remember that further RTL code examples are given in section 4.3.2 and on the book’s companion website. Event-driven simulation Observation 4.28. In SystemVerilog simulation, the continuum of time gets subdivided by events each of which occurs at a precise moment of simulation time. An update event is said to happen whenever the value of a variable (or wire) changes. The term “transaction” for an event scheduled for execution does not exist in SystemVerilog. Fig.4.18 is labeled accordingly. The SystemVerilog syntax also supports no distinction between signals and variables, which means that fig.4.10 does not apply. The dual role of variables has been discussed in section 4.3.2. How variables interact with the event queue depends on how exactly the assignment is coded and will be explained shortly, table 4.5 gives a summary. Observation 4.29. As opposed to software languages where execution strictly follows the order of statements in the source code, there is no fixed ordering for carrying out processes (includ- ing continuous assignments and assertion statements) in SystemVerilog. When to invoke a process gets determined solely by events on the variables (and wires) that run back and forth between processes. 63 The exact operation of the SystemVerilog process scheduler, advertized as “stratified event queue”, is rather convoluted and beyond the scope of an introductory text on VLSI. A simulation cycle is actually organized into 17 ordered simulation regions, 9 reserved for executing SystemVerilog statements and 8 for programming language interface (PLI) code. Different types of statements (e.g. blocking assignments, system tasks, assertions) and even parts of such statements (e.g. right- and left-hand sides of nonblocking assignments) get executed in different regions as suggested in fig.4.18. Note that the drawing is just a first order approximation as the actual scheduler includes regions not shown and even feedback loops. The fine details matter primarily in the context of assertion-based verification and for certain testbench designs. Readers interested in full-depth discussions are referred to the specialized literature such as [98] [102] [100] [103]. 250 CHAPTER 4 CIRCUIT MODELING WITH HDLs past events scheduled events present moment of time event queue simulation time event queue processes current update events invoke sensitive processes executed schedule events in the future processes being process sensitive input input variables output variables tpdpropagation delays CDA B process gets invoked by update events on variable B and schedules events on variables C and D process variables \"signals\" inter- regions simulation 1. Active: 2. Inactive: 3. NBA: 5. Postponed: 4. Observed: #0 blocking assignments LHS of non-blocking assignments $monitor, $strobe Concurrent assertions Blocking assigns, RHS of non-blocking assigns, continuous assigns, $display FIGURE 4.18 Event-driven simulation in SystemVerilog. Interactions between the event queue and a process (a), actions that repeat during every simulation cycle (b) (simpliﬁed). Sensitivity list, process suspension and reactivation With a background in event-driven simulation, we are now in a position to better understand the functioning of procedural blocks. As an example, reconsider the always_ff block of listing 4.12 and specifically the @(posedge Clk_C, negedge Rst_RB) parenthesis on the first line. A matching event on either signal — both actually variables in SystemVerilog — (re-)activates code execution, which is why they are said to form the sensitivity list of that process. Constructs for temporarily suspending a process and for stating when it is to resume include: Statement Wake-up condition @(...) an update event (value change) on any of the signals listed here wait (...) idem plus the logic conditions specified here #... a predetermined lapse of time as specified here Continuous assignments, in contrast, need and have no sensitivity list. By definition, any update event of a variable on the right-hand side of the assignment operator (re-)activates the process. Example assign Oup_D = InpA_D + InpB_D; Delay modeling In the context of simulation, the lapse of time between an update event at the input of a process and the ensuing event scheduled at the output reflects the delay of the piece of hardware being modeled. Circuit delays are typically conveyed by a # expression which forms an optional part of the various assignment statements. The continuous assignment below, for instance, models the propagation delay of an adder by scheduling an update event on its output tpd after an event at either input. Example assign #TPD Oup_D = InpA_D + InpB_D; 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 251 The next simulation model uses a procedural block to also account for contamination delay tcd. always_comb begin Oup_D <= #TCD ’{default:1’bX}; // revert all bits to unknown after tcd Oup_D <= #TPD InpA_D + InpB_D; // propagate result to output after tpd end Hint: SystemVerilog accepts time values in multiples of some time unit previously defined with a timeunit statement or a ‘timescale compiler directive, e.g. #2.8. To avoid surprises, always specify the measurement unit, i.e. write #2.8ns instead. Hint: When simulating models with zero delays it becomes difficult to tell apart cause and effect in the output waveforms as the respective update events appear to coincide. A trick is to artificially postpone future events by a tiny amount of time in otherwise delayless variable assignments. To allow for quick adjustments, a constant is best declared in a package and referenced throughout a model hierarchy. Note that the largest sum of fake delays must not exceed one clock period, though. Example assign #FAKEDELAY Oup_D = InpA_D + InpB_D; Blocking versus nonblocking assignments Within a procedural block, a variable may be assigned a value in either of two ways, both of which may or may not carry a delay, and both of which involve the process scheduler. A blocking assignment is identified by = as operator symbol. If the statement includes a non-zero delay expression, execution of the current process is suspended until that amount of simulation time has elapsed. If no delay is specified, the effect is felt immediately, that is, in the next statement exactly as with any software programming language. Nonblocking assignments are recognized by the <= operator. While the right-hand side is executed instantly, the updating of the variable on the left-hand side is deferred until after the completion of all blocking assignments scheduled for the same simulation time, or even longer if a non-zero delay expression stipulates so. Meanwhile, program execution procedes with the subsequent instruction(s) in the procedural block. Table 4.5 summarizes the effects of the various SystemVerilog assignment statements. Always blocks The general purpose always block inherited from Verilog is the equivalent of the process statement in VHDL: versatile but not always easy to code properly. The always_comb, always_ff,and always_latch blocks that came with SystemVerilog obviate numerous potential coding errors related to misadjusted sensitivity lists, wait statements, and wake-up conditions. As an example, an always_comb block is not only sensitive to all signals that appear on the right-hand side of assignment operators within that block, but also to those read by any function called. 252 CHAPTER 4 CIRCUIT MODELING WITH HDLs Observation 4.30. As a net progress over Verilog and VHDL, SystemVerilog provides specific and synthesizable constructs for combinational logic, for flip-flop-, and for latch-like behavior. Not only are the specialized always_... blocks safer and more convenient to write, they also make HDL code easier to understand as the designer’s intent is immediately apparent. Table 4.5 The SystemVerilog constructs for updating variables compared. Assignment Continuous Procedural Operator assign ... = = (blocking) <= (nonblocking) Delay term none non-zero none non-zero none non-zero Execution suspends until continues suspends continues of process next update event on for delay aright-handoperand speciﬁed Effect immediate deferred immediate deferred following deferred on variable by delay by delay simultan. by delay speciﬁed speciﬁed blocking speciﬁed assignm.a a That is, with zero delay in terms of simulation time, but only after all blocking assignments scheduled for the same moment of time have been executed. Depending on how the code is written, a procedural block can be made to capture almost anything from a humble piece of wire up to an entire image compression circuit, for instance. This is particularly true for the general purpose always block. Hint: For the sake of modularity, legibility, and smooth synthesis, do not cram too much functionality into a procedural block. As a rule, use continuous assignment statements and always_comb blocks to describe combinational operations while packing any kind of data storage into a separate always_ff (or _latch)block. No binding order of execution for simultaneous events Referring to fig.4.18, a SystemVerilog simulator is free to execute processes scheduled for the same simulation time in arbitrary order. As opposed to VHDL, SystemVerilog knows of no δ delay. To make a long story short, designers wanting to write RTL code for synthesis are advised to stick to the rules below to avoid nondeterminism, race conditions, and misinterpretation. Hint: 1. Prefer continuous assigns for uncomplicated combinational functions. 2. Do not use procedural blocks other than always_comb, always_ff and always_latch.64 3. In an always_comb block, always use blocking assignments (=). 4. In always_ff and always_latch blocks, use nonblocking assignments (<=) only. 5. Do not make #0 (zero delay expression) procedural assignments. 64 The general purpose always block should be strictly limited to code not intended for synthesis. Before using that construct or the @* wildcard event notation, for that matter, check [102] for more detailed advice. 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 253 Initial values cannot replace a reset mechanism As discussed earlier, the SystemVerilog syntax supports assigning an initial value to a variable as part of its declaration statement. Observation 4.31. The initial value given to a variable defines the objects’s state at t = 0, just before the simulator enters the first cycle. A hardware reset, in contrast, remains ready to reconduct the circuit into a predetermined start state at any time t ≥ 0. This asks for distributing a dedicated signal to the bistables, both in the circuit and in its HDL model. Make sure you understand these are two totally different things. An initialized variable does not model a hardware reset facility and will, therefore, not synthesize into one. How to code a working reset has been demonstrated in listing 4.12. How to check timing conditions Latches, flip-flops, RAMs, and all other sequential subcircuits impose specific timing requirements such as setup and hold times on data, and minimum pulse widths on clock inputs. Should any of these timing conditions get violated, their behavior becomes unpredictable. Checking for compliance is thus absolutely essential for meaningful simulations, see observation 4.18. Timing checks operate by searching the event queue for past events as explained in fig.4.11. SystemVer- ilog provides a total of twelve specialized constructs for various timing and waveform checks, among which $setup, $hold, $width and $period. Upon detecting a violation, each of them produces a specific message without interrupting simulation. Syntax rules require that timing checks be placed in a so-called specify block. Listing 4.16 shows an example. LISTING 4.16 Setup and hold time checks in a D-type ﬂip-ﬂop model // simulation model of a single-edge-triggered flip-flop with hardcoded timing module setff ( input logic Clk_CI, logic Rst_RBI, logic Dd_DI, output logic Qq_DO ); logic State_DP; // state variable specify $setup ( Dd_DI, posedge Clk_CI, 1.09ns ); // data evt, clock evt, min. sep. $hold ( posedge Clk_CI, Dd_DI, 0.60ns ); // clock evt, data evt, min. sep. endspecify always_ff @(posedge Clk_CI, negedge Rst_RBI) if (~Rst_RBI) 254 CHAPTER 4 CIRCUIT MODELING WITH HDLs State_DP <= 1’b0; else State_DP <= Dd_DI; assign #0.92ns Qq_DO = State_DP; endmodule 4.3.5 FACILITIES FOR MODEL PARAMETRIZATION As explained in section 4.2.5, a big plus of HDL models over schematic diagrams and netlists is that they can be parametrized such as to fit multiple needs. The most salient features of SystemVerilog towards making hardware models reusable are parameters and the generate statement. Fig.4.12 shows how these fit into the general picture. Parameters As stated earlier, variables can carry dynamic, i.e. time-varying, information between processes and indirectly also between modules. parameters, in contrast, serve to disseminate static, i.e. time-invariant, details to modules. Just think of ◦ Word width, ◦ Active-low or -high signaling on inputs and outputs, ◦ Output drive capability, ◦ Functional options (e.g. details about an instruction set), ◦ Timing quantities (propagation and contamination delay, setup and hold time), and ◦ Capacitive load figures. A parameter’s name must be included in the module header prior to the ports between a pair of parentheses identified by a hash sign #. Indicating a default value is optional. As opposed to ports, parameters do not have any direct hardware counterpart. An example follows. // w-input odd parity gate module parityoddw #( parameter WIDTH, // number of inputs parameter real TCD = 0ns, // contamination delay with default value parameter real TPD = 1.0ns ) // propagation delay with default value ( input logic [WIDTH-1:0] Inp_DI, output logic Oup_DO ); ... endmodule 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 255 The values of the parameters get nailed down when the module is instantiated, overriding any defaults specified in the module header. This again occurs between a pair of parentheses identified by a hash sign # with the syntax otherwise roughly following that of the port map. Then follows the customary instance identifier and next the port map. parameter NUMBITS = 12; ..... // module instantiation statement parityoddw #( .WIDTH(NUMBITS), .TCD(0.05ns), .TPD(NUMBITS * 0.1ns) ) u173 ( .Inp_DI(DataVec_D) , .Oup_DO(Parbit_D) ); ..... specparam, finally, is a reserved word for declaring a special type of parameter the value of which is intended to be overwritten during back-annotation. The generate statement Similarly to what has been said in section 4.2.5, SystemVerilog provides a generate statement that can be used to spawn processes and/or to instantiate and connect modules under control of a user-defined algorithm. The use of the generate and endgenerate keywords is optional, yet strongly recommended for the sake of clarity. A special type genvar helps to distinguish those variables that steer a generate procedure from ordinary simulation-time variables. The code fragment below implements the Game of Life.65 ..... // spawn a process for each cell in the array generate for (genvar ih = 0; ih<HEIGHT; ih++) for (genvar iw = 0; iw<WIDTH; iw++) always_ff @(posedge Clk_C) begin // sensitivity list integer live_neighbors; live_neighbors = live_neighbors_at(ih,iw); if (State_DP[ih][iw]==’b0 && live_neighbors==3) State_DP[ih][iw] <= ’b1; // birth else if (State_DP[ih][iw]==’b1 && live_neighbors<=1) State_DP[ih][iw] <= ’b0; // death from isolation else if (State_DP[ih][iw]==’b1 && live_neighbors>=4) State_DP[ih][iw] <= ’b0; // death from overcrowding end // always_ff endgenerate ..... 65 A 2-dimensional cellular automaton rather than a game; for details see footnote 35. 256 CHAPTER 4 CIRCUIT MODELING WITH HDLs Note that the generate statement not only comes in a for form but also in an if form. Example generate if (i==WIDTH-1) ... endgenerate Observation 4.32. Generate statements get interpreted as part of the so-called elaboration phase that precedes actual circuit simulation and synthesis. Variables are obviously not acceptable as conditions or as loop boundaries since they are subject to vary at run time, only parameters are. The need to accommodate multiple models for one circuit block Please recall from table 4.1 that up to four HDL models may occur during a VLSI design cycle to capture a circuit-to-be at distinct levels of detail. Designers also experiment with alternative circuit architectures to compare them in terms of gate count, longest path delay, energy efficiency, and other figures of merit. SystemVerilog accommodates this need by allowing multiple modules for the same subcircuit, a slightly different approach than illustrated in fig.4.13. Warning: Do not give two modules with functionally distinct behaviors identical names as this is extremely confusing! Conditional compilation of source code In the presence of multiple module bodies for one circuit, there must be a way to indicate which one to include during simulation and synthesis. SystemVerilog provides roughly twenty compiler directives, identified by a backtick character (‘), aka grave accent. The ‘include directive simply inserts the entire contents of the source file named in the argument into the calling file during compilation. For selective compilation, directive ‘ifdef must be used. // parametrized binary to Gray code converter module binary2gray #( parameter ...) // parameters (.....); // inputs and outputs ‘ifdef usebehavioral // module body with behavioral model follows here ..... ‘else // module body with structural model follows here ..... ‘endif endmodule Which of the two bodies gets evaluated depends on whether the free-choice identifier immediately to the right of the ‘ifdef keyword, named usebehavioral in this example, is defined or not at compile time. Compiler directives such as ‘define and ‘undef serve to do so. Example ‘define usebehavioral Counterexample ‘undef usebehavioral Similarly, ‘define can be used to specify a number for compilation as shown in listing 4.17. 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 257 LISTING 4.17 Source ﬁle graydefs.sv referenced in listings 4.18 and 5.1 // Mission: Illustrate the usage of compiler directives ‘define and ‘include. //----------------------------------------------------------------------------- ‘define GRAYWIDTH 5 // set a word width parameter for later use As a more general comment, simulation and synthesis essentially follow the same course outlined in fig.4.14 for SystemVerilog and for VHDL, except for the syntax analysis step which is most obviously language-specific. The conceptual commonalities underlying the two HDLs has enabled industry to develop EDA tools that support VHDL-SystemVerilog co-simulation. 4.3.6 CONCEPTS BORROWED FROM PROGRAMMING LANGUAGES For all its procedural aspects, SystemVerilog draws heavily on the software language C. Due to the popularity of that language, we will refrain from re-iterating those concepts here and just point out a few SystemVerilog particularities.66 User-deﬁned data types Basically, a data type defines a set of values and a set of operations that can be performed on them. Users may declare their own data types or use predefined ones. Data types for modeling electrical signals have been discussed in section 4.3.3. Enumerated types — which did not exist in traditional Verilog, by the way — are by default implemented as named constants of type int, occupying 32 bit. Example of a type declaration typedef logic signed [23:0] audiosample; Enumerated type declaration typedef enum {JANUARY, FEBRUARY, ... , DECEMBER} month; Subroutine, function, and task A subroutine is either a function or a task. The primary purpose of a function is to return a value for use in an expression. functions have restrictions that make sure they return in zero simulation time without suspending the process that invokes them. Constructs that involve the event queue, including @(...), wait,and #... are, therefore, not admitted. A first example of a function, named nextmonth, is given below, two more follow in listing 4.18. 66 Incidentally, note that source_text serves as start symbol in formal definitions of SystemVerilog. 258 CHAPTER 4 CIRCUIT MODELING WITH HDLs package calendar; typedef enum {JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER} month; typedef logic unsigned [4:0] day; function month nextmonth (month given_month); return given_month.next; // wraps around at the end endfunction function day nextday (day given_day); ..... endfunction endpackage: calendar As opposed to functions, tasks are allowed to include timing control statements that cause them to suspend, to resume, and/or to schedule events. A task may also call further tasks. Tasks are primarily used in testbenches, see listing 5.2 for examples. Package This instrument for sharing constants, user-defined data types, and subroutines across modules has been adopted from VHDL. Packages make it possible to sidestep the waste and perils of repeating supposedly identical declarations at multiple places. The contents of a package must be referenced in a import clause to make them accessible from some other source file. This is shown in listings 4.18 and 5.1, the former of which defines two functions that are being called in the latter. LISTING 4.18 Package holding a pair of Gray code ↔ binary conversion functions. // Mission: illustrate the use of packages in SystemVerilog. // Functionality: Gray code <-> binary code conversion functions. // Author: H.Kaeslin. //----------------------------------------------------------------------------- ‘include \"../sourcecode/graydefs.sv\" // the word width to be used package grayconvPkg; ‘ifndef GRAYWIDTH ‘define GRAYWIDTH 2 // default word width for input and output ‘endif 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 259 //----------------------------------------------------------------------------- // // ||||| // binary to Gray |--. |--. |--. |--. | # of X-ops on // conversion | ‘--X ‘--X ‘--X ‘--X longest paths // for GRAYWIDTH=5 ||||| = 1 // vvvvv // bit positions 43210 X = XOR // ||||| // Gray to binary | ,--X ,--X ,--X ,--X # of X-ops on // conversion |--’ |--’ |--’ |--’ | longest path // for GRAYWIDTH=5 ||||| = GRAYWIDTH-1 // vvvvv // //----------------------------------------------------------------------------- function automatic logic [‘GRAYWIDTH-1:0] bin2gray (input [‘GRAYWIDTH-1:0] arg); bin2gray=arg; // initial assignment for (int i=0; i <=$size(arg)-2; i++) // from 0 to GRAYWIDTH-2 if (bin2gray[i+1]) // if bit at [i+1] is 1 bin2gray[i] = ~bin2gray[i]; // invert bit at [i] endfunction function automatic logic [‘GRAYWIDTH-1:0] gray2bin (input [‘GRAYWIDTH-1:0] arg); gray2bin=arg; // initial assignment for (int i=$size(arg)-2; i >=0; i--) // from GRAYWIDTH-2 downto 0 if (gray2bin[i+1]) // if bit at [i+1] is 1 gray2bin[i] = ~gray2bin[i]; // invert bit at [i] endfunction endpackage : grayconvPkg Classes, semaphores, mailboxes, etc. Classes are a concept from object-oriented programming that encapsulates data and binds them together with the subroutines that operate on those data. While this approach is useful for automating code generation of complex testbenches, it is currently not applicable to hardware modeling and synthesis. Much the same applies to semaphores, mailboxes, and named events, all of which are process synchronization and communication mechanisms admitted into SystemVerilog to better support system- level testbench design. 260 CHAPTER 4 CIRCUIT MODELING WITH HDLs System tasks A notorious difficulty with VHDL simulation is the formatted input and output to data files. The SystemVerilog language includes many helpful commands, collectively named “system tasks”, for these and other duties. Table 4.6 gives an idea, but the multitude of commands and options means the reader will have to consult a comprehensive reference manual such as [98] for details. System tasks are commands to the simulator and, most obviously, not for synthesis. $write, $display, $strobe,and $monitor come in four flavors, each having a different default base. $display assumes decimal integers, $displayb binary data, $displayh hex data, and $displayo octal data, and so on. The same applies to their $f... file-writing counterparts. Examples $display(\"Simulation ended after %4d checks and with %4d error(s).\", checkcnt, errorcnt); int simvectorfile = $fopen(\"../simvectors/moore6st_simvector.asc\", \"r\"); $fclose(simvectorfile); while(!$feof(simvectorfile)) begin void’($fgets(readstr, simvectorfile)); fmatch = $sscanf(readstr, \"%b %b %b\", StimuliRec.Clr_S, StimuliRec.Inp_D, ExpRespRec.Oup_D ); ... end $readmemh(\"../sim/vectors/stim.txt\", stimuli); $error(\"Expected ’b%b does not match actual ’b%b\", expresp, ActResp_D); assert (simvectorfile) else $fatal(\"Could not open simvector file.\"); RandomSample = $random % 32768; // interval [-32767,+32767] RandomMonth = $urandom_range(12,1); // interval [1,12] RandomBit = (($urandom_range(100,0) < percentzero) ? 1’b0 : 1’b1); \u0002 4.3 KEY CONCEPTS AND CONSTRUCTS OF SYSTEMVERILOG 261 Table 4.6 Selected SystemVerilog system tasks. Command Action Formatted text output $write write line to standard output immediately with no newline character $display write line to standard output immediately preceded by a newline character $strobe idem at the end of current time slot, i.e. before advancing simulation time $monitor idem when speciﬁed events occur File operations $fopen open a ﬁle $fclose close a ﬁle $fread read from a ﬁle $fscanf parse formatted text from a ﬁle $fgets read characters from a ﬁle and assembles them into a string $sscanf parse formatted text from a string $feof return a non-zero value when end of ﬁle found and 0 if not so $fwrite same as $write for writing to a ﬁle $fdisplay same as $display for writing to a ﬁle $fstrobe same as $strobe for writing to a ﬁle $fmonitor same as $monitor for writing to a ﬁle Memory load and dump $readmemb/h load memory from a text ﬁle in binary/hex format $writememb/h dump memory to a text ﬁle in binary/hex format Simulation control $time return current simulation time $reset reset simulation so it can restart from the beginning $stop suspend simulation $finish terminate simulation Run time information with severity levels (standalone and for use in assertions) $info print argument to simulator window and continue $warning print argument to simulator window, count as warning, and continue $error print argument to simulator window, count as error, and continue $fatal print argument to simulator window and terminate simulation Random number generation (for use in stimuli preparation) $random return a random signed integer $urandom return a random unsigned integer $dist_uniform return a uniformly distributed random number $dist_normal return a normally distributed random number Enquiries about the event queue (for use in properties and assertions) $rose return 1 iffargument has changed to 1 $fell return 1 iffargument has changed to 0 $stable return 1 iffargument had not changed value $past return argument’s value a speciﬁed number of clock cycles earlier 262 CHAPTER 4 CIRCUIT MODELING WITH HDLs 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 4.4.1 SYNTHESIS OVERVIEW Automatic synthesis aims at turning some sort of behavioral description into a gate-level netlist with as little human intervention as possible. Using the standard cells available from a target library, synthesis software attempts to come up with a gate-level circuit that meets all user-defined performance targets at the lowest possible hardware costs, see fig.4.21. Starting from an RTL model, the synthesis process is outlined in the lower part of fig.4.14. Syntax analysis is obviously different for VHDL and for SystemVerilog models. After that, processing becomes essentially the same. Elaboration and binding have been discussed earlier in this chapter. State reduction eliminates redundant states, if any, while state encoding assigns a unique binary code to each state.67 The subsequent synthesis step builds all necessary state registers and specifies the combinational subfunctions in between. The result is a preliminary network described at an intermediate level of detail, that is in terms of logic equations and generic components rather than actual logic gates. Boolean optimization reworks the logic networks in an attempt to bring their longest signal propagation paths below the relevant user-defined timing constraint while, at the same time, minimizing hardware complexity. Finding an optimal or near-optimal circuit depends on numerous characteristics of the library cells available, so simplifying and reorganizing logic equations and networks is closely intertwined with the subsequent technology mapping phase [104] where the generic gates in the netlist get replaced by components that are actually available from the target library.68 More sophisticated tools also address energy efficiency. As stated in section 4.1.4, VHDL and Verilog were not originally intended for synthesis; and SystemVerilog is a superset of Verilog. So, while almost all VHDL simulators support the full IEEE 1076 and 1164 standards, only a subset of the legal language constructs is amenable to synthesis; and the same holds for SystemVerilog and the IEEE 1800 standard. Observation 4.33. As good HDL code must be portable across simulation and synthesis plat- form, model writers must confine themselves to safe, unambiguous, and universally accepted constructs. The remainder of this section is devoted to discussing the existing limitations and to presenting workable solutions for synthesis code. 67 Please refer to appendix B for more details. 68 Much of today’s logic optimization software descends from programs such as espresso (two-level logic) and MIS (multi- level logic). A major challenge in coming up with adequate algorithms is to achieve a low asymptotic complexity in order to cope with complex functions and large networks. 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 263 4.4.2 DATA TYPES Only a subset of the data types is amenable to hardware synthesis. Support covers the types listed next along with the pertaining array and record data types. VHDL SystemVerilog + integer + integer, shortint, int,and longint + boolean and bit + bit + std_logic and std_ulogic + logic and wire + unsigned and signed + byte + enumerated types + enumerated types + ufixed, sfixed and float69 + array and record of fixed size + array and struct of fixed size Unlike the above items, the types below are not normally supported. VHDL SystemVerilog − real − real − time − time-related data types − character − string, queue, and other dynamic data types − file − file-related data types As for the synthesizability of data operators, please refer to table 4.10. 4.4.3 FINITE STATE MACHINES AND SEQUENTIAL SUBCIRCUITS IN GENERAL Hardware-compatible wake-up conditions for all processes While HDLs allow the modeling of arbitrary behavior (as long as it is causal, discrete in value, and discrete in time), automatic synthesis only supports synchronous clock-driven subcircuits and — at a higher level — conglomerates of such subcircuits. Synchronous circuit operation means that state transitions are restricted to occur exclusively at precise moments of time as defined by a clock signal.70 Not all code that is syntactically correct and that works during simulation is thus acceptable for synthesis. More particularly: Observation 4.34. Any process that is supposed to model a piece of hardware must execute upon activation, return to the same instruction, and suspend there. The reason is that each wait or similar statement that may cause a process to suspend is allowed to carry its own wake-up condition. Depending on the details postulated there, the source code may imply synchronous or asynchronous behavior. While the former readily maps to a clock-driven circuit assembled from flip-flops and logic gates, the latter is likely to express a behavior that depends on a haphazard collection of events on various signals in a delicate way. Coming up with a physical circuit 69 Introduced with the IEEE 1076-2008 revision, not necessarily supported by all EDA tools as yet. 70 An in-depth discussion is to follow in section 6.2.1. 264 CHAPTER 4 CIRCUIT MODELING WITH HDLs that is safe and functionally equivalent to the source code may then prove extremely difficult, if not impossible. Before casting this into practical coding guidelines in observations 4.35 and 4.36, let us have a closer look at finite state machines. Explicit versus implicit state models Explicit state models conform with the above. Program execution always returns to the same line of code and suspends there after having completed one full turn. signals or variables preserve the current state from one process activation to the next. Explicit state models are intuitive to hardware designers who are accustomed to think in terms of finite state machines (FSM) along with visual formalisms such as schematics, state graphs, and the like. Implicit state models, in contrast, are related to Nassi-Shneiderman diagrams, aka structograms, and flowcharts. They tend to come more natural to software programmers who code algorithms and are immediately recognized by the presence of multiple synchronization points per process. Upon activation, the simulator executes instructions until the next suspend statement encountered puts the process to sleep. Suspension may thus occur at distinct lines of code, and each such place represents one specific state of the model. There is no tangible state variable. Rather, it is the return address to the suspended process that assumes this role during simulation, hence the name implicit state. See fig.4.19 and table 4.7 for a comparison. 00 01 1011 by3 by4 dis by3by4 by3 by4 by4 by3 dis dis dis f g o(k) oup i(k) cntrl s(k) present state s(k+1) next state state register next state function output function combinational operations o(k) = g( i(k),s(k) ) s(k+1) = f( i(k),s(k) ) wait on event on clock wait on event on clock wait on event on clock 43 wait on event on clock oup := \"00\" forever repeat until clock is high and counting is enabled oup := \"01\" repeat until clock is high and counting is enabled oup := \"10\" repeat until clock is high and counting is enabled oup := \"11\" divide by repeat until clock is high and counting is enabled output := \"00\" . (b) (a) (c) FIGURE 4.19 Three formalisms that affect the writing of software models for FSMs. Data dependency graph (a), state chart (b), Nassi-Shneiderman diagram (c). Note the programmable divide-by-3/divide-by-4 counter chosen for illustration is a Medvedev machine. 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 265 It should be clear from what has been said before that implicit state models must be translated into explicit state models before RTL synthesis can begin. Still, they occasionally find applications in the context of purely behavioral simulations in early stages of the design cycle. Code examples in this text refer to explicit state models exclusively. How to capture a ﬁnite state machine The restriction to explicit state models notwithstanding, one still has the choice of packing an FSM into one concurrent process (VHDL process statement or SystemVerilog always block), or of distributing it over two or more such processes. Table 4.7 Explicit and implicit state models compared. modeling style explicit state implicit state computed state enumerated state inspired from data dependency graph state chart, state Nassi-Shneiderman or schematic diagram graph, or state table diagram synchronization sensitivity list or single wait statement multiple mechanism (semantically equivalent) wait statements state declared explicitly as signal or variable hidden in pointer variable and thus of user-deﬁned type to current statement states (subrange of) integer enumerated type multiple captured by or vector of bits wait statements state transitions arithmetic and/or one-to-one translation control ﬂow captured by logic operations from state table output function arithmetic and/or one-to-one translation assignment captured by logic operations from state table statements immediate hard- yes depending on ware equivalent wait conditions synchronous yes idem synthesizable yes no Packing an entire FSM into a single process statement The code is organized as illustrated by fig.4.20 a) through c) for Mealy, Moore, and Medvedev automata respectively.71 Evaluation begins with the asynchronous reset and clock inputs to find out whether the machine’s state must be updated. The remaining inputs are processed further down in the code. The process must be made sensitive to events on clock and reset and, in the occurrence of a Mealy machine, to events on other input signals as well. 71 The three classes of automata essentially differ in the nature of their output functions. Please refer to sections B.1 and B.2 if you have doubts about the characteristics and equivalence relations among those classes. 266 CHAPTER 4 CIRCUIT MODELING WITH HDLs Although this coding style is legal syntax and perfectly acceptable for simulation, its general adoption is discouraged because it is not supported by many synthesis tools and because it may result in inefficient gate-level networks. Distributing an FSM over two (or more) concurrent processes As depicted in fig.4.20 d) through f), a memorizing process is essentially in charge of maintaining the current state from one activation to the next. A second process of memoryless nature computes the next state and the present output value. In VHDL, both present state and next state must be modeled as signals that go back and forth between the two processes. Capturing sequential and combinational behavior in separate processes is universally accepted and tends to lead to more economic circuit structures during synthesis. As an additional benefit, the type of automaton (Mealy, Moore, Medvedev) can be changed at any time without having to reorganize the source code too much. In conclusion, the rules below ensure trouble-free synthesis and portability across platforms. clk rst clk rst Moore machine Medvedev machineMealy machine memorizing process o(k) s(k+1) s(k) i(k) f memorizing process o(k) s(k+1) s(k) i(k) f g memorizing process i(k) f g clk rst s(k+1) s(k) not supported by all synthesizers (a) (b) (c) (d) (e) (f) not supported by all synthesizers produce duplicate flip-flops some synthesizers unnecessarily coded in one process coded in one process clk rst clk rst clk rst s(k+1) memoryless process o(k)i(k) f g s(k) memorizing process s(k+1) memoryless process o(k)i(k) f s(k) memorizing process s(k+1) memoryless process o(k)i(k) f g s(k) memorizing process widely supported by synthesizers widely supported by synthesizers widely supported by synthesizers coded in two (or more) processes coded in two (or more) processes operation combi- national state register process variable list sensitivity input edge- triggered VHDL SystemVerilog variable signal FIGURE 4.20 Coding schemes for synchronous Mealy, Moore and Medvedev machines. Note that the programmer is free to distribute the combinational operations subsumed here as “memoryless process” over two or more concurrent processes, including concurrent signal assignments (VHDL) or continuous assignments (SysVer). 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 267 Observation 4.35. Good VHDL synthesis code shall a) model circuits at the register transfer level (RTL) throughout, b) collect combinational and sequential logic in separate processes, c) have all memorizing process statements conform with the skeleton of listing 4.8, d) prefer concurrent, conditional and selected signal assignments for combinational logic, and e) have all memoryless process statements coded according to observation 4.15. Observation 4.36. Good SystemVerilog synthesis code shall a) model circuits at the register transfer level (RTL) throughout, b) collect combinational and sequential logic in separate processes, c) use always_ff blocks exclusively for memorizing behavior,72 and d) use continuous assignments or always_comb blocks for combinational logic. Warning: The emergence of unplanned for latches or other bistables during synthesis must alert the HDL designer that his code is badly wrong. For each subcircuit, check the number of flip-flops and latches obtained from synthesis against your expectations. As a general rule, do not ignore warnings and error messages from the synthesizer unless you understand what they mean. Hint: In applications where state transitions depend on an enable signal, you have two options: a) include a subcondition in the memorizing process, as in listing 4.3, or b) add an extra conditional branch in the memoryless process that determines the next state. Though the two approaches are functionally identical, we recommend a) because the synthesizer may otherwise be unable to map to E-type flip-flops and, hence, to ultimately apply clock gating. LISTING 4.19 VHDL code for a simple Mealy machine. -- Mission: Illustrate how to model a Mealy machine with two processes. -- Example designed to include an asynchronous reset, three-state outputs, -- self loops, symbolic encoding of states and outputs, plus handling of -- parasitic states and inputs so as to eliminate any chance for lockup. -- Functionality: See state graph below. -- Author: H.Kaeslin. ------------------------------------------------------------------------------- library ieee; use ieee.std_logic_1164.all; ------------------------------------------------------------------------------- entity mealy5st is port (Clk_CI : in std_logic; Rst_RBI : in std_logic; Inp_DI : in std_logic_vector(1 downto 0); 72 Or, alternatively, always_latch blocks in the occurrence of level-sensitive clocking. 268 CHAPTER 4 CIRCUIT MODELING WITH HDLs Oup_DO : out std_logic_vector(1 downto 0) ); -- ternary, 11 not used end mealy5st; ------------------------------------------------------------------------------- -- Inp_DI / Oup_DO (State_DP) -- -- 00 / 00 / 00 / 00 / 00 / -- EMPTY IBTW IBTW IBTW FULL -- _____ -- || 01/ || 01/ || 01/ || 01/ || -- | | IBTW | | IBTW | | IBTW | | FULL | | -- ---> v / ------> v / ------> v / ------> v / ------> v / ---- -- 10 / | (0) (1) (2) (3) (4) | 01 / -- EMPTY ----- <-------- <-------- ˆ <-------- <-------- <---- FULL -- 10 / 10 / | 10 / 10 / -- EMPTY IBTW | IBTW IBTW -- o ------------------------------------------------------------------------------- architecture enumerated_state of mealy5st is type state is (ST0, ST1, ST2, ST3, ST4); -- enumerated state type signal State_DP, State_DN : state; -- present state and next state -- symbolic encodings of output constant EMPTY : std_logic_vector(1 downto 0) := \"10\"; -- empty constant IBTW : std_logic_vector(1 downto 0) := \"00\"; -- in between constant FULL : std_logic_vector(1 downto 0) := \"01\"; -- full constant HIMP : std_logic_vector(1 downto 0) := \"ZZ\"; -- high-impedance begin ---- computation of next state and present outputs --------------------------------------------------------------------------- p_memless : process (Inp_DI, State_DP) begin -- default assignments State_DN <= State_DP; -- remain in present state Oup_DO <= IBTW; -- output \"in between\" -- nondefault transitions and outputs case State_DP is when ST0 => if Inp_DI=\"00\" then Oup_DO <= EMPTY; elsif Inp_DI=\"10\" then Oup_DO <= EMPTY; elsif Inp_DI=\"01\" then State_DN <= ST1; 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 269 else Oup_DO <= EMPTY; -- parasitic input 11, treat as 00 end if; when ST1 => if Inp_DI=\"10\" then Oup_DO <= EMPTY; State_DN <= ST0; elsif Inp_DI=\"01\" then State_DN <= ST2; end if; when ST2 => if Inp_DI=\"10\" then State_DN <= ST1; elsif Inp_DI=\"01\" then State_DN <= ST3; end if; when ST3 => if Inp_DI=\"10\" then State_DN <= ST2; elsif Inp_DI=\"01\" then Oup_DO <= FULL; State_DN <= ST4; end if; when ST4 => if Inp_DI=\"10\" then State_DN <= ST3; else Oup_DO <= FULL; -- 01, 00 or parasitic input 11 end if; when others => -- tie up parasitic states for synthesis Oup_DO <= HIMP; State_DN <= ST2; end case; end process p_memless; ---- updating of state ---------------------------------------------------------------------------- p_memzing : process (Clk_CI, Rst_RBI) begin -- activities triggered by asynchronous reset (active low) if Rst_RBI = ’0’ then State_DP <= ST2; -- activities triggered by rising edge of clock elsif Clk_CI’event and Clk_CI = ’1’ then State_DP <= State_DN; end if; end process p_memzing; end enumerated_state; 270 CHAPTER 4 CIRCUIT MODELING WITH HDLs LISTING 4.20 SystemVerilog code for a simple Mealy machine. // Mission: Illustrate how to model a Mealy machine with two processes. // Example designed to include an asynchronous reset, three-state outputs, // self loops, symbolic encoding of states and outputs, plus handling of // parasitic states and inputs so as to eliminate any chance for lockup. // Functionality: See state graph below. // Author: B.Muheim. // ---------------------------------------------------------------------------- module mealy5st ( input logic Clk_CI, input logic Rst_RBI, input logic [1:0] Inp_DI, output logic [1:0] Oup_DO ); // ternary, 11 not used //----------------------------------------------------------------------------- // Inp_DI / Oup_DO (State_DP) // // 00 / 00 / 00 / 00 / 00 / // EMPTY IBTW IBTW IBTW FULL // _____ // || 01/ || 01/ || 01/ || 01/ || // | | IBTW | | IBTW | | IBTW | | FULL | | // ---> v / ------> v / ------> v / ------> v / ------> v / ---- // 10 / | (0) (1) (2) (3) (4) | 01 / // EMPTY ----- <-------- <-------- ˆ <-------- <-------- <---- FULL // 10 / 10 / | 10 / 10 / // EMPTY IBTW | IBTW IBTW // o //----------------------------------------------------------------------------- typedef enum integer {ST0, ST1, ST2, ST3, ST4} state_type; // symbolic encodings of output const logic [1:0] EMPTY = ’b10; // empty const logic [1:0] IBTW = ’b00; // in between const logic [1:0] FULL = ’b01; // full const logic [1:0] HIMP = ’bZZ; // high-impedance // present state and next state state_type State_DP, State_DN; 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 271 // computation of next state and present outputs // ------------------------------------------------------------------------ always_comb begin // default assignments State_DN = State_DP; // remain in present state Oup_DO = IBTW; // output \"in between\" // nondefault transitions and outputs case (State_DP) ST0 : if (Inp_DI==’b00) Oup_DO = EMPTY; else if (Inp_DI==’b10) Oup_DO = EMPTY; else if (Inp_DI==’b01) State_DN = ST1; else Oup_DO = EMPTY; // parasitic input 11, treat as 00 ST1 : if (Inp_DI==’b10) begin Oup_DO = EMPTY; State_DN = ST0; end else if (Inp_DI==’b01) State_DN = ST2; ST2 : if (Inp_DI==’b10) State_DN = ST1; else if (Inp_DI==’b01) State_DN = ST3; ST3 : if (Inp_DI==’b10) State_DN = ST2; else if (Inp_DI==’b01) begin Oup_DO = FULL; State_DN = ST4; end ST4 : if (Inp_DI==’b10) State_DN = ST3; else Oup_DO = FULL; default : begin Oup_DO = HIMP; State_DN = ST2; end endcase end // updating of state // ------------------------------------------------------------------------ always_ff @(posedge Clk_CI, negedge Rst_RBI) // sensitivity list // activities triggered by asynchronous reset (active low) 272 CHAPTER 4 CIRCUIT MODELING WITH HDLs if (~Rst_RBI) State_DP <= ST2; // activities triggered by rising edge of clock else State_DP <= State_DN; endmodule Listings 4.19 and 4.20 show a small Mealy machine coded for synthesis in VHDL and SystemVerilog respectively. Listings 4.21 and 5.1 do the same for a Medvedev machine. The coding of a Moore machine is left to the reader as an exercise, see problem 10. What follows next are further comments on FSM coding. Observation 4.37. To facilitate code readability, always try to decompose large state machines into a bunch of smaller ones that cooperate with each other. Adhere to hierarchical and modular design, consider using counters instead of long state chains, for instance. Observation 4.38. The various processes that make up for an FSMs are best included into one architecture body (VHDL) or module (SysVer) along with the datapath they command. Shutting the FSM into an entity of its own just inflates the code and the effort for coding and maintenance. FSM optimization ignored in the language standards As explained in section B.1.6, state machine design involves solving two optimization problems, namely state reduction and state encoding. Some synthesis tools are designed to automatically recognize FSMs in the HDL code and to carry out those optimization steps. Others must be instructed to do so using proprietary compiler directives that identify those signals or variables that act as a repository for the current state. 4.4.4 RAM AND ROM MACROCELLS On-chip RAMs are being used to temporarily store all sorts of intermediate data whereas on-chip ROMs serve as repositories for program code, lookup tables (LUT), and other permanent information. This section will discuss how to incorporate RAM and ROM macrocells in VHDL models in a way that is acceptable for synthesis. The most innocent approach is to declare a storage array as if the code were intended for simulation purposes and to assume the synthesizer will take care of all the rest with no human interaction. As an example, consider a 4bit-binary-to-seven-segment display decoder. The content of an adequate LUT can be captured as an array of constants as shown below. While a workable solution, this piece of code will not synthesize into a ROM, but into random logic as any other RTL model of combinational nature. 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 273 -- unsupported VHDL coding style ..... -- address of array must be of type integer or natural p_memless : process (Binary4Code_D) variable address : natural range 0 to 15; type array16by7 is array(0 to 15) of std_logic_vector(1 to 7) constant SEGMENT_LOOKUP_TABLE : array16by7 := -- segments ordered a...g (\"1111110\",\"0110000\",\"1101101\",\"1111001\", -- digits 0,1,2,3, \"0110011\",\"1011011\",\"0011111\",\"1110000\", -- 4,5,6,7, \"1111111\",\"1110011\",\"1110111\",\"0011111\", -- 8,9,A,b, \"1001110\",\"0111101\",\"1001111\",\"1000111\"); -- C,d,E,F; begin -- use binary input as index, look up in table, and assign to segment output address := to_integer(unsigned(Binary4Code_D)); Segment7Code_D <= SEGMENT_LOOKUP_TABLE(address); end process p_memless; ..... Trying to do the same in the occurrence of a 64 byte RAM, for instance, would mean to include the code fragment below into the declaration section of the superordinate architecture body. Reading and writing one byte at a time would involve assignment statements and an address pointer that selects one out of the 64 storage vectors from the array of signals. -- unsupported VHDL coding style ..... type array64by8 is array(0 to 63) of std_logic_vector(7 downto 0); signal Storage_D : array64by8; ..... The idea is impractical, however, because the behavior so defined is a far cry from actual RAM macrocells and their interfaces. Worse than this, automated synthesis would hardly churn out a safe and synchronous gate-level circuit either. From a more general perspective, whether to implement a storage array in a RAM, from flip-flops, or otherwise is a decision that has far-reaching consequences both on the final circuit and on the design process. Observation 4.39. Spontaneous incorporation of macrocells is neither a practical nor really a desirable proposition for RTL synthesis because it would deprive designers of control over a circuit’s architecture and performance. A more realistic approach would be to instantiate a RAM stating the macrocell generator to be used and to pass on all further specifications in a generic map (VHDL) or as parameters (SysVer). With cmosram01 the name of some fictive generator for clocked SRAMs, for instance, this would ask for a code fragment similar to the one below. 274 CHAPTER 4 CIRCUIT MODELING WITH HDLs -- unsupported VHDL coding style ..... u39: cmosram01 generic map ( NUMBER_OF_WORDS => 64, WORD_WIDTH => 8, DATA_INPUT_OUTPUT_SEPARATE => false ) port map ( CLK => Clk_C, WRENA => RamWrite_S, ADDR => RamAddress_D, DATIO => RamData_D ); ..... Regrettably, this approach is not currently feasible due to the lack of standardization and the absence of interfaces between HDL synthesis and all those proprietary macrocell generators in existence. For the time being, a macrocell must get instantiated like any other component. -- supported VHDL coding style ..... u39: myram64by8 port map ( CLK => Clk_C, WRENA => RamWrite_S, ADDR => RamAddress_D, DATIO => RamData_D ); ..... // supported SystemVerilog coding style ..... myram64by8 u39 ( .CLK(Clk_C), .WRENA(RamWrite_S), .ADDR(RamAddress_D), .DATIO(RamData_D) ); ..... Observation 4.40. The necessary design views of a macrocell (simulation model, schematic icon, detailed layout, etc.) must all be obtained from outside the HDL environment. To that end, the IC designer must either gain access to the process-specific macrocell generator software and run it with an appropriate parameter setting, or he must commission the silicon foundry do so for him. The choice is typically determined by commercial considerations. Table 4.8 shows how a synthesis model must be organized in order to obtain various read-only and read-write storage functions.73 73 Note that the market offers functional replacements for RAMs that are built on the basis of individual bistables. Such models are amenable to HDL synthesis in the normal way, that is they ultimately map to standard cells much as the designer’s own code. Of course, such cell-based implementations cannot compete with true RAMs in terms of layout density. Also, many of them combine mix of gates, latches, and flip-flops into a circuit that does not adhere to a pure and unconditionally safe synchronous clocking discipline. 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 275 Table 4.8 The desired circuit type determines how its synthesis model must be organized. Look up table (LUT) (memoryless) Desired hardware organization Random logic ROM (tiled layout) Function must be modeled as an array-type constant by instantiating a ROM or with logic equations macrocell as a component Storage array (memorizing) Desired hardware organization register ﬁle built from RAM (tiled layout) ﬂip-ﬂops or latches Function must be modeled as an array of (clocked) by instantiating a RAM storage registers macrocell as a component Common traits of implemented circuit Area-effcient when data quantity is small large Technology-speciﬁc software required no macrocell generator HDL code amenable to retargeting yes manual rework needed Pre-synthesis simulation works from RTL source code extra behavioral model Post-synthesis simulation works from gate-level model idem 4.4.5 TIMING CONSTRAINTS A timing constraint is a user-defined target for some timing quantity that the final circuit must meet. Fig.4.21 illustrates a common situation where the propagation delay through a circuit has been bounded from above. The concept is very general in that a synthesis constraint can as well refer to a circuit’s longest clock period, to its maximum acceptable input or output delay (all upper bounds), or even specify a minimum contamination delay (lower bound). Any difference between the target value specified in a timing constraint and the actual delay exhibited by the circuit after synthesis is termed slack. For a combinational circuit this simply amounts to tsl = tlp max − tlp where tlp stands for the propagation delay on the longest path. In the occurrence of a sequential circuit, the designer typically indicates a target clock period Tclk that serves as upper bound for all register-to-register paths. Slack then becomes tsl = Tclk − tss. A negative slack indicates the synthesis and optimization process has failed to meet its timing target. Unless synthesizer directives suffice to correct the situation, the design will then need to be reworked at the RTL or architecture level. 276 CHAPTER 4 CIRCUIT MODELING WITH HDLs Synthesis constraints are not part of the HDL standards The timing-related constructs in the IEEE 1076 and 1800 standards have been defined exclusively with simulation in mind. Inertial effects of physical circuits are typically being modeled with after clauses (VHDL) or #... expressions (SysVer). These language constructs are meaningless in the context of synthesis. After all, it is not possible to stipulate some arbitrary timing and then to come up with a circuit that exactly meets those predefined numbers.74 Synthesis tools thus simply ignore after and reject clauses (#... expressions). The same applies to wait for statements and to timing-related assertion statements. Example of timing a spec ignored by VHDL synthesis Oup_D <= Aa_D + Bb_D after 1.7 ns; Example of timing a spec ignored by SysVer synthesis assign #1.7ns Oup_D = Aa_D + Bb_D; Observation 4.41. Timing-related HDL constructs are for simulation purposes exclusively and get ignored during synthesis. They serve to model the behavior of existing circuits, not to impose target requirements for the synthesis process. complexity A propagation delayT user-defined timing constraintslack result from constrained optimization result from unconstrained optimization available no solutions available solutions fastest but largest unacceptable solutions smallest but slowest most efficient bound of acceptable solutions bound of feasible solutions memory bound of algorithm AT producthyperbola of minimum the constraint imposed optimal solution under Pareto-optimal solution suboptimal solution FIGURE 4.21 Trade-offs between size and performance for a hypothetical circuit. 74 This is because the exact timing of a circuit not only depends on the gate-level network, but also on load capacitances, wiring parasitics, PTV and OCV, cross-coupling effects, and more. Also, the timing of library cells is not continuously adjustable. In the occurrence of a 2-input and function, the target library would provide a few standard cells that differ in terms of transistor sizing, drive strength, and layout. Each such cell has its proper delay vs. load characteristics. Synthesis software just picks one or the other depending on the current requirements, but there is no sensible way to fashion an arbitrary delay at will. 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 277 A more sensible goal is to define bounds that could guide synthesis and logic optimization. Such timing constraints have never been adopted in the language standards, though. VHDL and SystemVerilog are, therefore, not capable of expressing any upper bound for a long path such as the one illustrated in fig.4.21. Unsupported VHDL construct Oup_D <= Aa_D + Bb_D with_TPD_no_more_than 1.7 ns; Unsupported SystemVerilog construct assign #max#1.7ns OUP_D = Aa_D + Bb_D; As a workaround, timing and other synthesis directives must be expressed with the aid of proprietary language extensions or with scripting languages such as Tcl. Portable formulations are important as the same timing constraints are to be reused during timing verification to check whether a design indeed meets its specifications before being sent to fabrication. How to formulate timing constraints75 As stated before, an upper bound for the delay from one register to the next gets imposed by the clock period in single-edge-triggered one-phase circuits.Indicating a target clock period is thus mandatory and straightforward, see fig.4.22a. Formulating constraints for input- and output paths is more tricky because of ambiguous naming habits in commercial synthesis and timing verification tools. In fact, it is possible to define input/output timing from either of two perspectives: ◦ Indicate how much time is available to the circuit under construction (egocentric view). ◦ Quantify the amount of time that must be set aside for the surrounding circuitry (altruistic view). As specifying the circuit under construction itself comes most naturally, the first perspective is normally adopted in this text. Yet, most EDA tools adopt the altruistic view, mainly because it permits to alter the target clock period without having to numerically readjust all I/O timing constraints. Unfortunately, the names typically being used, such as input and output delay, are inexpressive and give rise to confusion. The material below, including table 4.9 and fig.4.22, attempts to reconcile the two views. 75 Note to the reader: For your first encounter with RTL synthesis, you may skip this section and come back later after having learned more about the operation and timing of synchronous circuits in sections 7.2 and 7.4. 278 CHAPTER 4 CIRCUIT MODELING WITH HDLs Table 4.9 Cross reference for input and output timing constraints. Event Symbol Quantity (egocentr. above, altruist. below) Synopsys term relating to the interface with the upstream circuitry 3 tsu inp setup time data-valid ≤ Tclk − tpd upst of circuit under construction window tpd upst = tidel max clock-to-output propagation delay maximum begins of upstream circuitry input delay 2 tho inp hold time data-valid ≤ tcd upst of circuit under construction window tcd upst = tidel min clock-to-output contamination delay minimum ends of upstream circuitry input delay relating to the interface with the downstream circuitry 4 tpd oup clock-to-output propagation delay data-call ≤ Tclk − tsu dnst of circuit under construction window tsu dnst = todel max setup time maximum begins of downstream circuitry output delay 1 tcd oup clock-to-output contamination delay data-call ≥ tho dnst of circuit under construction window tho dnst = − todel min hold time minus minimum ends of downstream circuitry output delay You will typically want to give upper bounds for the long path delays by specifying:76 tidel max = tpd upst = tpd ff upst + tpd a − tdi ⇐ tpd b + tsu ff ≤ Tclk − tpd ff upst − tpd a + tdi (4.1) todel max = tsu dnst = tpd e + tsu ff dnst + tdi ⇐ tpd ff + tpd d ≤ Tclk − tpd e − tsu ff dnst − tdi (4.2) If you make no distinction between tidel max and tidel min, EDA tools will assume they are the same which implies that input data get updated once per clock period at time ⃝3 and then remain valid for one entire period. If not so, the short path delay must be constrained as well. Use a separate Tcl statement where you indicate a lower bound of tidel min = tcd upst = tcd ff upst + tcd a − tdi ⇐ tcd b − tho ff ≥−tcd ff upst − tcd a + tdi (4.3) while observing that any physical circuit must satisfy tidel min < tidel max ⇐ tvalid upst = tpd upst − tcd upst = tidel max − tidel min > 0 (4.4) Similarly, if you do not distinguish between todel max and todel min, the synthesizer will try his best to meet the setup condition of the downstream circuitry, but will do nothing particular about the hold 76 While (4.1), (4.2), (4.3)and (4.5) correctly reflect the interrelations, you may have to drop the tdi terms there when entering numerical data into a synthesis tool. Check the documentation to find out what your tool requires. Also make sure to understand whether your tool will automatically adjust timing targets as a function of the actual tdi value, or whether the designer is expected to take care of that manually. 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 279 condition there. In the extreme case, a circuit that just flashes valid output data at time ⃝4 might pass as acceptable because todel max = todel min is the same as tsu dnst =−tho dnst which indeed stands for a downstream circuit that is capable of picking up data in zero time. To prevent this from happening, you can either bank on automatic hold time fixing or explicitly constrain the short path from below by specifying todel min =−tho dnst = tcd e − tho ff dnst + tdi ⇐ tcd ff + tcd d ≥ tho ff dnst − tcd e − tdi (4.5) while observing todel min < todel max ⇐ tcall dnst = tsu dnst + tho dnst = todel max − todel min > 0 (4.6) How to partition a circuit in view of synthesis and optimization Timing constraints on propagation paths that extend across multiple circuit blocks render synthesis unnecessarily difficult and are likely to result in suboptimal circuits. This is because logic optimization and technology mapping are carried out in chunks to avoid excessive computer run times and memory requirements on large designs. Most tools accept proprietary directives for merging and segregating circuit logic into synthesis chunks. However, the better the initial architecture and the various design entities (VHDL) and modules (SysVer) in the RTL source code reflect a sensible hardware organization, the less effort will have to be wasted in repartitioning at synthesis time. Hint: Synthesis and optimization work much better if a design is organized such that • related or tightly connected subcircuits belong to the same design entity, • all outputs from a synthesis chunk are registered, and • critical paths are confined to within one synthesis chunk. Registered outputs further preclude the unwanted emergence of zero-latency loops and hazards. create_clock -period Tclk [get_ports Clk_CI] Clk_CI Inp_DI 2 data-valid window ends 3 data-valid window begins (propagation through input logic plus register set-up) time span left for input circuit under construction to settle circuit under construction must catch data at its input data-valid window of upstream circuitry during which active clock edge time 2 3 tidel max tidel min set_input_delay tidel -clock Clk_CI [get_ports Inp_DI] set_input_delay -max tidel max -clock Clk_CI [get_ports Inp_DI] set_input_delay -min tidel min -clock Clk_CI [get_ports Inp_DI] unknown data valid unknown tidel max 23 Tclk tidel min upper bound for long path delay lower bound for short path delay of circuit under construction 1 data-call window ends 4 data-call window begins Clk_CI Oup_DO (propagation delay through register and output logic) time span left for output circuit under construction to settle circuit under construction must provide valid output data data-call window of downstream circuitry during which set_output_delay todel -clock Clk_CI [get_ports Oup_DO] todel max -clock Clk_CI [get_ports Oup_DO]set_output_delay -max set_output_delay -min todel min -clock Clk_CI [get_ports Oup_DO] time active clock edge 4 1 todel max todel min todel max don’t care data called don’t care 14 Tclk todel min upper bound for long path delay lower bound for short path delay of circuit under construction Oup_DOInp_DI AB C D E tidel todel Tclk Tclk Tclk upstream circuitry downstream circuitry Clk_CI circuit under construction tdi clock distribution delay FF st FF up FF st FF dn delay (a) (b) (c) FIGURE 4.22 Timing constraints as understood by synthesis tools. Circuit overview with clock period (a), input timing (b), and output timing (c). 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 281 4.4.6 LIMITATIONS AND CAVEATS Some circuits essentially need to be deﬁned as gate-level netlists Designers cannot always afford to leave decisions on a circuit’s organization to the discretion of automatic synthesis, they sometimes need to exactingly control the outcome at the gate level. Arithmetic units are typical examples. Assume you had to implement a high-performance multiplier for sign- magnitude numbers, a format not really supported by HDL synthesis tools. While schematic entry offers full control over a circuit’s structure and produces highly suggestive diagrams, it is always tied to specific components and to particular circumstances in terms of word widths, pipeline depth, output format, and the like. Chances of ever reusing such a rigid circuit description are extremely low. HDLs make it possible to write synthesis models that are structural and parametrized at a time. Such models make extensive use of generics and of conditional component instantiation statements, see architecture structural of binary2gray in section 4.2.5 for a simple example. The role of synthesis in the processing of HDL source code of this kind is essentially limited to elaboration, technology mapping, and timing optimization with the overall organization of the original network being preserved. The procedure as a whole can be viewed as HDL-controlled netlist generation.77 In addition to that, all VLSI chips include subcircuits where designers explicitly stipulate a well defined connectivity. Padframe, clock distribution network, clock gating circuitry, synchronizers, scan paths, and leakage suppression circuits are common examples. While their functionality is trivial, their structural, electrical and/or timing characteristics must conform to precise specifications. A loose collection of inverters is no valid substitute for a clock tree, for instance, nor does a simple and operation qualify as clock gate. Similarly, scan testing implies the presence of a shift register in the actual circuit hardware as illustrated in fig.7.6, not just another way of transiting from one state to the next. Observation 4.42. Boolean optimization algorithms and general purpose synthesis tools are not designed to handle padfames, clock gates, synchronizers, clock distribution networks, scan paths, high- performance arithmetic circuits, and other “non-logic” portions of a design that must comply with structural rather than just with behavioral specifications. What are the options when tight control over a subcircuit’s gate-level construction is sought? ◦ Use dedicated design automation tools,78 ◦ fall back on schematic entry, or ◦ write a parametrized structural HDL model. As for arithmetic units, take advantage of proven synthesis models (DesignWare) where possible. 77 Predesigned, preverified and optimized, yet configurable and technology-independent circuit models are being marketed by Synopsys under the product name DesignWare. They range from fairly simple arithmetic units and register files to an entire video decoder. VHDL models of adders, multipliers, dividers, square root and trigonometric functions are available from [105] along with extraordinarily vivid explanations. 78 Generating balanced clock trees, for instance, is postponed to the physical design phase and handled by specialized EDA software there. 282 CHAPTER 4 CIRCUIT MODELING WITH HDLs Hint: Do not reoptimize subcircuits so obtained as critical properties may deteriorate. Most synthesis tools accept “don’t touch” directives to prevent them from altering critical subcircuits while attempting to optimize the main body of a design. In summary, it is important to understand that only a subset of the VHDL language defined in the IEEE 1076 standard is supported for synthesis. This is even more pronounced for SystemVerilog and the IEEE 1800 standard. The synthesizable subsets need not be exactly the same for all commercial products. Tool builders have added proprietary directives, constraints, and sometimes extra data types to fill gaps that were left open in the standards. 4.4.7 HOW TO ESTABLISH A REGISTER TRANSFER LEVEL MODEL STEP BY STEP VHDL and SystemVerilog are perfectly suitable for coding a data processing algorithm. Yet, do not expect an EDA tool to accept a purely behavioral model and to turn that into a circuit design of acceptable performance, size, and energy efficiency. Exceptions are limited to circuits of fairly modest or fairly specific functionality. Rather, the fun and the burden of architecture design rests with the hardware developer. Only after an architecture has been worked out by human engineers does it make sense to describe the hardware organization at an intermediate level of detail, typically RTL, and to submit the HDL code so obtained to a synthesis tool. RTL modeling is best carried out in a procedure of successive refinement: 1. Begin by drawing a fairly detailed block diagram of the architecture to be implemented. 2. Check where you can take advantage of off-the-shelf synthesis models (DesignWare). 3. Organize the circuit such as confine critical propagation paths to within circuit blocks. Make your design entities (modules) match with those circuit blocks. 4. Identify macrocells such as RAMs and ROMs and prepare for generating the necessary design views outside the HDL environment. 5. Identify all registers (data, I/O, pipeline, address, control, status, mode, test etc.) and loosely collect the combinational operations in between into clouds. 6. For each combinational cloud, specify the operations in mathematical terms (equations, truth tables, structograms, pseudo code, etc.) and figure out how to compute the desired outputs in an efficient and — where meaningful — also parametrizable way. 7. Establish a schedule that specifies what is to happen during each clock cycle. This is a table with one line per computation period and an entry for each relevant building block that expresses the following items: • ALU or arithmetic unit: operation being carried out, data set being processed. • Other major combinational block: data set being processed. • Finite state machine: present state, present output. • Register: present datum, being cleared or not, being enabled or not. • Important signal: present datum. • Output pin or connector: present datum, being driven or not. 4.4 AUTOMATIC CIRCUIT SYNTHESIS FROM HDL MODELS 283 • Input pin or connector: datum that must be available. • Bidirectional pin or on-chip bus: present datum, being driven or not. 8. Identify all finite state machines and find out what type is most appropriate.79 9. Capture each register in a memoryzing process statement (always_ff block). 10. For each combinational cloud, decide on the number of processes you want to use. Prefer concurrent, selected, and conditional signal assignments (continuous assignments) for simpler operations. Plan to use process statements (always_comb blocks) for more convoluted computations exclusively. Give a meaningful name to each process. 11. Note that all data items that run back and forth between the various processes must be declared as signals (variables) and decide on the most appropriate data type for each. 12. Only now begin with translating your draft into actual HDL code. • Organize finite state machines as suggested by fig.4.20 and pattern the code of registers after listing 4.3 (4.12). Take care to handle special signals such as clock, asynchronous reset, synchronous initialization, and enable properly. • Use the schedule previously established to specify the various subfunctions in full detail. • Fill in don’t care entries wherever possible. • Follow the recommendations of section 4.2 (4.3) and observation 4.35 (4.36). Observation 4.43. Writing code for HDL synthesis is not the same as writing software for a program- controlled computer. Always think in terms of circuit hierarchies and simultaneous activities (i.e. concurrent processes) rather than in terms of instruction sequences. Golden rule: Establish a block diagram of your architecture first, then code what you see! 79 Table B.5 may help in doing so. 284 CHAPTER 4 CIRCUIT MODELING WITH HDLs INP2 OUP2 INP1 OUP1 f g h ij ROM combinational subfunction continuous assignment or always_comb block register block always_ff macrocell instantiation module statementROM RAM VHDL SystemVerilog combinational subfunction concurrent conditional selected or signal assignment memoryless process statement register process memorizing statement after skeleton to be patterned macrocell instantiation component statementROM RAM FIGURE 4.23 Translating an RTL diagram into HDL code. 4.5 CONCLUSIONS The universal adoption of VHDL and SystemVerilog is due to their many paying benefits: + They support a top-down design methodology of successive refinements from behavioral simulations down to gate-level netlists using a single standard language. + RTL synthesis does away with all lower-level schematic drawings in a typical VLSI design hierarchy, saving significant time and effort. + HDLs enable sharing, reusing and porting of subfunctions and -circuits in a parametrized and therefore more useful form than schematic diagrams. + Automatic technology mapping makes it unnecessary to commit an HDL-based design to some specific cell library or fabrication process until late in the design cycle, even allowing for retargeting between field- and mask-programmable ASICs. + VHDL and SystemVerilog also support the coding of simulation testbenches, albeit not to the same degree, see fig.4.24. More on this is to follow in chapter 5. − Learning to master VHDL or SystemVerilog may be daunting. 4.5 CONCLUSIONS 285 • While the IEEE 1076 and IEEE 1800 standards are fully supported for simulation, only a subset is amenable to synthesis because the languages have not originally been developed with synthesis in mind. This is not a problem for informed designers, however. − Timing constraints and synthesis directives are not part of VHDL and SystemVerilog and must be captured using proprietary languages. There also is a lack of agreement between tool vendors on what constructs the synthesis subset ought to include and when to support new constructs introduced with past standard revisions. − A gap remains between system design, which focuses on overall circuit behavior and transactions on high-level data, and actual hardware design, which involves many structural and implementation-specific issues. The necessary manual translation from a purely behavioral model to RTL synthesis code and the ensuing re-entry of design data are inefficient and lead to errors and misinterpretations. • The impact of coding style on combinational random logic tends to be overstated. Also, do not expect timing-wise synthesis constraints to do away with architectural bottlenecks. All too often, their effects are limited to buying moderate performance gains at the expense of substantially larger circuits. • The most important engineering decisions that set efficient designs apart from inefficient ones do not relate to HDLs, but to architectural issues. Algorithmic and architectural questions must be answered before the first line of synthesis code is written. • HDL synthesis does not do away with architecture design! V H D L hardware description language verification language V e r i l o g S y s t e m V e r i l o g general programming for RTL synthesis hardware modeling cosimulation verification aids coverage analysis undirected directed random stimuli generation testbench codingbasic sophis- ticated classes mailboxes semaphoresassertions shared variables interacting concurrent processes electrical data types event-based concept of time parametrization and abstraction circuit hierarchy and connectivity sophisticated busses & interfaces SVA propertiesconcurrent assertions FIGURE 4.24 The capabilities of the three predominant HDLs at a glance. 286 CHAPTER 4 CIRCUIT MODELING WITH HDLs 4.6 PROBLEMS 1. ∗∗ Locate listings 4.1 and 4.4 (VHDL) or 4.11 and 4.13 (SystemVerilog). Note that each listing is accompanied in the text by a short assignment that consists in reverse engineering the code and in representing the findings graphically. If you haven’t done so, catch up now. 2. ∗ Section 4.2.2 includes examples of conditional and non-conditional signal assignments. For each such example, state the conditions that cause the code to get re-evaluated during simulation. 3. ∗ Consider process statement memless1 from section 4.2.2 and note that signal Spring_D is unconditionally set false before being assigned its actual value in a series of conditional statements. That value will thus evolve from true to false and back again when the process is invoked during springtime, e.g. at midnight of May 18. Do you think this trait will become visible as a brief transient during simulation? Would a circuit synthesized from this model exhibit a hazard? Explain your reasoning. 4. ∗∗ Listing 4.5 includes a procedural model, a dataflow model, and a structural model for a small subcircuit in VHDL (listing 4.14 does the same for SystemVerilog). (a) For each of the three models, find out in what way it is possible to reorder the statements without affecting the model’s functionality. (b) Although the three models describe exactly the same functionality at exactly the same level of abstraction, they greatly differ in the total count of signals, variables, design entities, instances, processes, and statements involved. Determine the respective numbers. (c) Establish three schedules that list what is happening simulation cycle after simulation cycle in response of an event on any of the inputs. Think about the impact on computational efficiency when the entity gets simulated. 5. ∗∗ The book’s companion website includes synthesis code for a so-called (4,3)-counter, a logic network that tells how many of its inputs are at logic 1. Notice that the model assumes fixed input and output widths of 4 and 3 bits respectively. Examine how the various architecture bodies would scale if the model were to be parametrized in order to handle an arbitrary word width at the input. Add the necessary generic interface constant(s) in the entity declaration and rewrite a few architectures such as to obtain a scalable model. You may further want to synthesize and to compare the resulting networks. 6. ∗ Explain the differences between these conditional constructs: if ... then ... end if; and if ... generate ... end generate; (VHDL). if ... and generate if ... endgenerate (SystemVerilog). Are there any other VHDL (SystemVerilog) statements that are related to each other in the same way? 7. ∗∗∗ Using your preferred HDL, write a model for a binary-coded-decimal (BCD) counter that is amenable to simulation and synthesis. A control input of two bits is to decide between count-up (01), count-down (10), and hold (00) condition. Input-to-output latency shall not exceed one clock cycle. Under no circumstance are hazards tolerated on any of the output signals. Also, do not forget to address parasitic inputs and parasitic states. 4.6 PROBLEMS 287 8. ∗ Consider the VHDL code below where the output of a linear feedback state register (LFSR) and of a counter are combined into a four-bit random output. What’s wrong with this design? Hint: Actually, there is one obvious and one more subtle problem. Both are related to the same clause in the process statement. entity partres is port ( Clk_CI : in std_logic; Rst_RBI : in std_logic; Oup_DO : out std_logic_vector(3 downto 0) ); end partres; -------------------------------------------------------------------------- architecture behavioral of partres is signal StateA_DP, StateA_DN : std_logic_vector(1 to 4); signal StateB_DP, StateB_DN : unsigned(3 downto 0); begin -- computation of next state StateA_DN <= (StateA_DP(3) xor StateA_DP(4)) & StateA_DP(1 to 3); StateB_DN <= StateB_DP + \"1001\"; -- updating of state process (Clk_CI,Rst_RBI) begin -- activities triggered by asynchronous reset if Rst_RBI=’0’ then StateA_DP <= \"0001\"; -- activities triggered by rising edge of clock elsif Clk_CI’event and Clk_CI=’1’ then StateA_DP <= StateA_DN; StateB_DP <= StateB_DN; end if; end process; -- updating of output combine: for i in 3 downto 0 generate Oup_DO(i) <= StateA_DP(4-i) xor StateB_DP(i); end generate combine; end behavioral; 288 CHAPTER 4 CIRCUIT MODELING WITH HDLs 9. ∗ SystemVerilog knows of no built-in construct for computing the absolute value of integers. Write a function for that. 10. ∗∗ Write a synthesis model for the finite state machine of fig.B.4. A synchronous clear shall be provided for initializing the circuit. Explain how your code reflects the fact that this is a Moore automaton. 11. ∗∗∗ Consider a shaft equipped with an angle encoder that indicates the shaft’s current position using a two-bit unit-distance code, see fig.4.25. Design a state machine that accepts this code and tells whether the shaft is currently rotating clockwise or counterclockwise. The former sense of rotation shall be indicated when the shaft is at standstill. Establish a synthesis model. You may want to extend the functionality such as to indicate the angular position of the shaft and the number of turns it has made since time zero. 00 01 10 11 FIGURE 4.25 Unit distance encoding of shaft angle. 12. ∗∗∗ Design a synchronous first-in first-out (FIFO) queue with the features below. a) Separate read and write ports (“data” plus “read” or “write” respectively). b) A pair of outputs that flag “full” and “empty” conditions respectively. c) Two more outputs that indicate “almost full” and “almost empty” conditions. d) Parametrized queue depth, data width, and “almost full/empty” thresholds. e) Show-ahead capability, aka first-word-fall-through property.80 Use a register file for data storage and code your RTL synthesis model in either VHDL or SystemVerilog. Chose meaningful port and signal names and observe the naming conventions of section 6.7. Note: Verifying the HDL model developed here will be the subject of problem 5 in chapter 5. 80 To keep FIFO latency minimal, the oldest data item stored is made immediately available at the output with no need to activate the “read” input beforehand and/or to wait for a clock cycle or a clock edge. The situation where the output is invalid because there are no data left is flagged via the “empty” output in the normal way. Note that the meaning of the “read” input is not the same as with a standard FIFO. Whereas it means “bring me data” there, it says “I just fetched a data word, get the next one ready, if any” in a show-ahead FIFO. 4.7 APPENDIX I: VHDL AND SYSTEMVERILOG SIDE BY SIDE 289 4.7 APPENDIX I: VHDL AND SYSTEMVERILOG SIDE BY SIDE Table 4.10 The most common operators in VHDL and SystemVerilog. Details may differ between the two languages and even from one EDA tool to another. VHDL SysVer amenable to synthesis Bitwise operators a inversion not a ~a yes a ∨ b or aor b a| b yes a ∧ b and aandb a& b yes a a ⊕ b b xor axorb a^ b yes String operator concatenation a& b { a, b } yes Arithmetic operators |a| absolute value abs a n.a. yes a + b addition a+ b a+ b yes a − b subtraction a- b a- b yes a ⋅ b multiplication a* b a* b for most tools a : b division a/ b a/ b if b =const . or b =2 n where n ∈ a mod b modulo amodb a% b idem ab exponentiation a** b a** b if a =2 and b ∈ Relation operators a = b equal to a= b a== b yes a = b not equal to a/= b a!= b yes a<b less than a< b a< b yes a>b greater than a> b a> b yes a ≤ b less or equal a<= b a<= b yes a ≥ b greater or equal a>= b a>= b yes Shift operators shift a left logic by b positions asllb a<< b yes shift right logic (no sign extension) asrlb a>> b yes shift left arithm. (same as logic) aslab a <<< b yes shift right arithm. (sign extension) asrab a>>> b yes 290 CHAPTER 4 CIRCUIT MODELING WITH HDLs Table 4.11 Corresponding terms and constructs in VHDL and SystemVerilog. Concept VHDL SystemVerilog Data record record struct Subroutine subprogram subroutine with no side effects function function with side effects procedure task Circuit or subcircuit [design] entity module Connector port port Circuit parameter a generic parameter (#) Circuit instance instance module instance Circuit node aka net signal (any data type allowed, wire (MVL-4 only, no value retains the last value assigned) retention, must stay driven) Node with multiple drivers resolved signal wire Independent thread of execution [concurrent] process [concurrent] process Concurrent assignment b concurr. signal assignment (<=) continous assignment (assign) Conditional assignment cond’al/selected signal ass. (<=) idem plus cond’al operator (?) Procedural descr. of ckt behav. c process statement procedural block (always) memoryless idem (no dedicated constr.) always_comb block memoryzing idem always_ff/_latch blocks Procedural descr. in general idem always, initial, final Wake up condition sensitivity list sensitivity list Time-varying data item that retains its value until explicitely assigned a new value conﬁned to within one process variabled (:=) [local] variable (var) shared between processes signale (<=) variable (var) change of value event update event time at which this happens simulation time time slot Assignment executed sequentially variable assignment blocking assignment (=) in a process statement concurrently concurrent signal assignment continuous assignment (assign) or signal assignment or nonblocking assignment (<=) in a process statement in an always block in an always block or blocking assignment (=) in a fork-join parallel block Waiting on an event wait on ... @(...) until a condition holds wait until ... wait (...) for a lapse of time (ex.) wait for 5 ns #5ns (no space allowed) a number clock cycles (ex.) (no dedicated construct) ##17 (in SVAs only) forever wait use initial block Propagation delay after clause delayed assignment example Oup <= Inp after 3 ns; assign #3ns Oup = Inp; Timing conditions via concurrent assertions timing checks (setup, hold,etc.) a Such as a timing quantity, a word width, or some other option. bThis is the simplemost kind of process. c Concurrent outside, sequential inside. d No interaction with the event queue. e Does interact with the event queue. 4.7 APPENDIX I: VHDL AND SYSTEMVERILOG SIDE BY SIDE 291 Table 4.12 Key features of the predominant HDLs compared. See [106] [107] for more. Feature VHDL Verilog SystemVerilog Background and underlying concepts Industry standard IEEE 1076 IEEE 1364 IEEE 1800 Initially accepted / current revision 1987 / 2008 (1984)1995 / 2005 2005 / 2012 Originator DoD Gateway Accellera Roots Ada C & VHDL, PSL, Vera Overall character safe, verbose terse, precarious powerful, bloated Concurrent processes yes yes yes Event-based concept of time yes yes yes Circuit hierarchy and structure (netlist) yes yes yes Source code encryption mechanism since 2008 yes yes Discretization of electrical signals adjunct package part of language part of language Logic system 9-valued IEEE 1164 4-valued 4-valued Switch-level capability no yes (8 strengths) yes (8 strengths) Language features and software engineering Separate interface decl. and implem. module yes no no Type checking strong none very limited Type conversion functions adjunct package none few required Enumerated & other user-deﬁned data types supported no supported Data types acceptable at block boundaries any binary only any Function arguments of variable word width supported no supported Data object with / without time attached signal/variable no distinction no distinction Signal attributes (named signal properties) yes n.a. n.a. Timing and word size parametrization generic supported parameter Conditional/repeate d process generation generate since 2001 generate Conditional/repeated component instantiation generate since 2001 generate Circuit block to instance binding control configuration since 2001 ‘ifdef Simulation and testbench design Stringent event order in the absence of delay yes (via d delay) no no Event queue inspection (e.g. for timing checks) part of language via system tasks via system tasks Text and ﬁle I/O adjunct package via system tasks via system tasks Back-annotation from SDF ﬁles IEEE 1076.4 yes yes Acceleration of gate-level primitives IEEE 1076.4 yes yes Acceptance for sign-off simulation yes yes yes Assertion-based veriﬁcation limited no supported Constrained random pattern generation no no supported Coverage metering no no supported Object-oriented (not for use in circuit models) no no yes with multiple inheritance since 2012 Queues, mailboxes, semaphores (idem) no no supported Foreign programming lang. interface (idem) VHPI PLI DPI Synthesis Amenable to hardware synthesis subset only subset only subset only Timing constraints not p.o.l. (SDF) not p.o.l. (SDF) not p.o.l. (SDF) Other synthesis directives not p.o.l. not p.o.l. not p.o.l. Analog and mixed-signal extension Designation VHDL-AMS Verilog-AMS Industry standard IEEE 1076.1 Accellera 2.2 292 CHAPTER 4 CIRCUIT MODELING WITH HDLs Table 4.13 References on VHDL and SystemVerilog. Subjects covered VHDL IEEE IEEE circuit test- syn- Reference Year 1076 1164 model. bench thesis Comments / special topics Speciﬁcations of language and syntax IEEE [108] -08 no no no no language reference manual IEEE [109] -02 no no no no language reference manual Zimmermann [110] .1 no no no no AMS syntax on www Zimmermann [111] -93 no no no no syntax in EBNF on www Bhasker [112] -93 no no no no syntax diagrams, + Textbooks Volnei Pedroni [113] -08 yes yes yes yes many examples, FPL Reichardt Schwarz [114] -02 yes yes (yes) yes synthesis, ﬁlter, German, + Ashenden [115] -08 yes yes yes yes pointers, std versions, + Ashenden Lewis [96] -08 (yes) (yes) (yes) no -08 language updates only Chu [116] -02 yes yes (yes) yes focus on circuits, + Molitor Ritter [117] -93 yes yes yes (yes) examples, German Ashenden et al. [118] -93 yes yes yes no VHDL-AMS Yalamanchili [119] -93 yes yes (yes) yes FPL, memory model Heinkel [120] -93 yes yes (yes) yes VHDL-AMS Zwolinski [121] -93 yes yes (yes) yes asynchronous circuits Chang [122] -93 no yes no yes based on [? ], examples Navabi [124] -93 yes yes yes (yes) small CPU example Chang [123] -93 yes yes yes yes testbenches, project, + Bhasker [125] -93 yes yes (yes) yes code to circuit mappings References with a speciﬁc focus and other resources Bergeron [126] -93 no no yes no functional veriﬁcation, + Hamburg Archive [127] n.a. free models, FAQ, links Subjects covered SystemVerilog IEEE logic circuit test- syn- Reference Year 1800 syst. model. bench thesis Comments / special topics Speciﬁcations of language and syntax IEEE [98] -12 yes no no no language reference manual Textbooks Zwolinski [100] -05 (yes) yes yes yes digital design, + Sutherland et al. [101] -05 (yes) yes (yes) (yes) language, syntax in EBNF References with a speciﬁc focus and other resources Spear [103] -09 no no yes no object-oriented testbenches Salemi [128] -05 yes (yes) (yes) no for VHDL converts, + Bergeron [129] -05 no no yes no functional veriﬁcation Alabama Tutorial [130] -09 (yes) yes (yes) (yes) quick intro for designers, + Doulos Tutorials [131] ’09 ’02 ’02 ’97 ’95 ’10 ’09 ’08 ’08 ’06 ’04 ’03 ’01 ’00 ’00 ’99 ’98 ’97 ’96 ’00 ’06 ’13 ’10 ’06 ’10 ’09 ’06 ’13 ’13 -05 (yes) yes yes (yes) upgrades over Verilog ( ) = light coverage only, + = personal preference. 4.8 APPENDIX II: VHDL EXTENSIONS AND STANDARDS 293 4.8 APPENDIX II: VHDL EXTENSIONS AND STANDARDS 4.8.1 PROTECTED SHARED VARIABLES IEEE 1076a The normal way of exchanging time-varying data between processes in VHDL is via signals. Signals essentially stand for electrical wires running between subcircuits and the non-zero delays of those subcircuits are expressed as part of signal assignment statements. As opposed to this, shared variables are intended to support inter-process communication for bookkeeping and supervision tasks during simulation runs, e.g. counting the number of process invocations, keeping track of exceptions or other special events, coordinating activities among the different processes in a testbench, or collecting statistical data. Zero-delay communication is fine in this context. Were it not for shared variables, programmers would be forced to employ signals thereby obscuring their original intention and unnecessarily inflating execution time. To stay clear of problems that might result from simultaneous read or write operations to a global variable by distinct processes, the access must be controlled. Protected shared variables provide a means for synchronization. Access to a protected shared variable is exclusive and must always occur by calling one of the functions or procedures written for that purpose. That is, when a first process gains access to a protected variable by calling one such subprogram to work on it, any further process attempting to read or modify the same variable by invoking the same or another subprogram must wait until the current access has terminated. Declaring a protected shared variable of an existing data type could hardly be simpler. Example shared variable event_counter : shared_counter; Obviously, the variable’s type is to be declared beforehand along with all functions and/or procedures necessary for access. Consistent with VHDL’s guiding principles, the declara- tion of a protected type is separated from its implementation as shown in the subsequent example [132]. -- protected type declaration type shared_counter is protected procedure : reset; procedure : increment ( by : integer :=1); impure function value return integer; end protected; 294 CHAPTER 4 CIRCUIT MODELING WITH HDLs -- protected type body type shared_counter is protected body variable count : integer := 0; procedure reset is begin count := 0; end procedure reset; procedure increment ( by : integer :=1) is begin count := count+by; end procedure increment; impure function value return integer is begin return count; end function value; end protected body shared_counter; Another code fragment shows that subprograms for reading or modifying a protected shared variable get invoked by prefixing their names with that of the variable meant to be accessed. ... event_counter.reset; event_counter.increment (3); assert event_counter.value > 0; ... Protected variables are part of the 2002 revision of the IEEE 1076 standard. Shared but unprotected variables had been introduced in VHDL’93 as a result from controversial debates in the standard committee, using them is discouraged as no access control mechanism was provided. 4.8.2 THE ANALOG AND MIXED-SIGNAL EXTENSION IEEE 1076.1 This standard is informally known as VHDL-AMS and extends the capabilities of the original language towards describing and simulating lumped analog and mixed-signal circuits. It has been a guiding principle to augment the existing VHDL constructs and to add new ones such as to make the new IEEE 1076.1 language a proper superset of VHDL which has obvious benefits. 4.8 APPENDIX II: VHDL EXTENSIONS AND STANDARDS 295 To capture continuous quantities such as voltages, currents and charges, a new kind of object has been introduced that complements the constants, variables and signals defined in the IEEE 1076 standard. This class is termed quantity and any object that belongs to it takes on floating point values exclusively. The supplemented language supports the modeling of time-continuous behavior by accommodating (possibly nonlinear) differential and algebraic equations in the time domain such as F(˙x(t), x(t), t) = 0. So-called implicit quantities have been included to denote derivatives and integrals over time. If x has been declared as a quantity, for instance, then x’dot automatically refers to d dt x. Elaboration of a VHDL-AMS model yields a digital part (made up of signals and processes)and an analog part (consisting of quantities and differential algebraic equations). Simulation begins with determining the model’s initial condition at time zero. The standard further defines how to synchronize the traditional event-driven simulation cycle with a solver for a system of simultaneous differential and algebraic equations. Observation 4.44. In a nutshell, VHDL’s analog and mixed-signal extensions are as follows: standard VHDL-AMS = VHDL IEEE 1076 + continuous-value objects IEEE 1076.1 + simultaneous differential algebraic equations idem + coupled continuous and discrete models of time idem + transistor compact models (open) It is worthwhile to note that VHDL-AMS extends the modeling capabilities in many ways. The significance of nonlinear and/or differential and algebraic equations in stating the static and continuous- time characteristics of electrical components and circuits is immediately evident. Entire subsystems from data transmission, signal processing, control systems, etc. can be condensed into abstract high- level mathematical models. What further sets VHDL-AMS apart from SPICE is the absence of built-in transistor models in the simulator kernel. Model writers are no longer confined to a structural view that describes how more complex (sub)circuits are pieced together from a few built-in primitives (such as resistors, capacitors, and transistors). Rather, they are put in a position to describe opamps, active filters, phase locked loops (PLL), etc. from a purely behavioral perspective using mathematical equations as building blocks and combining them with event-driven submodels where appropriate. This also enables them to create their own primitive models and to include them in circuit simulation at any time with no need for assistance from the software vendor. Lastly, there is nothing that would confine quantities to be of electrical nature which opens the door for modeling thermal, micromechanical, optoelectronic, magnetic and other effects. Yet, we will not elaborate on VHDL-AMS as analog, mixed-signal and multi-domain models are beyond the scope of this text. Please refer to [133] [118] [134]. 296 CHAPTER 4 CIRCUIT MODELING WITH HDLs 4.8.3 MATHEMATICAL PACKAGES FOR REAL AND COMPLEX NUMBERS IEEE 1076.2 While VHDL provides the floating point data type real, it does not support operations other than basic arithmetic operators.81 To overcome this limitation, two new packages have been defined and accepted as IEEE standard 1076.2. Package math_real includes • Definitions of constants including e and π. • Sign, floor, ceiling, round, truncate, min and max functions. • Square root, cubic root, power (xy), exponential (ex) and logarithm (ln(x)) functions. • Trigonometric functions (sin, cos, tan, arcsin, etc.). • Hyperbolic functions (sinh, cosh, tanh, arcsinh, etc.). • A pseudo-random number generator for reals uniformly distributed in the interval [0,1]. Package math_complex includes • Definitions of complex number types (in Cartesian and polar form). • Absolute value, angle, (argument), negate, and conjugate functions. • Square and exponential (ez) functions. • Overloaded versions of basic arithmetic operators (for Cartesian and polar operands). • Type conversion functions. Both packages have been added to the existing design library ieee. Clearly, they are intended for modeling system behavior at higher levels of abstraction and for auxiliary functions in testbenches, not for synthesis. 4.8.4 THE ARITHMETIC PACKAGES IEEE 1076.3 As no single IEEE 1076 or IEEE 1164 data type supports computer arithmetics with adequate precision and convenience, two new packages numeric_bit and numeric_std have been developed and accepted as IEEE standard 1076.3. They include • The definition of data types unsigned and signed (discussed in section 4.2.3) for unsigned and two’s-complement arithmetic respectively, • Overloaded versions of IEEE 1076 arithmetic, logical and relational operators. • Arithmetic shift and rotate functions. • Resizing functions with sign extension and reduction. • Type conversion functions (see appendix 4.8.6). In addition, the IEEE 1076.3 standard indicates how to interpret for the purpose of VHDL synthesis logical values, such as “L”, “X”and “U”, that have a physical meaning as outcomes from simulation but not as specifications for a circuit to be. This is also why the two packages are sometimes referred to as synthesis packages. 81 Addition +, subtraction -,sign inversion -, multiplication *, division /, integer power (xn, n ∈ N) **, and absolute value abs. 4.8 APPENDIX II: VHDL EXTENSIONS AND STANDARDS 297 4.8.5 THE STANDARD DELAY FORMAT (SDF) IEEE 1497 The SDF was originally developed by Open Verilog International (OVI) and later modified to become SDF version 4.0 which has been accepted as IEEE 1497 standard in 2001. SDF files are written in ASCII-readable form and store timing data in a non-proprietary format for later use during the VLSI design and verification process. SDF makes it possible to share gate delays, timing conditions, and interconnect delays between cell libraries, delay calculators, HDL simulators, and static timing analysis software. More particularly, SDF supports back-annotating existing netlists with numerical timing data obtained from layout extraction as illustrated in figs.4.14. The language also includes constructs for forward-annotation, that is for specifying timing constraints that are to guide the synthesis process of prospective circuits shown in figs.4.14 and 4.21. Further provisions allow for documenting the PTV conditions for which the timing data stored in an SDF file apply. 298 CHAPTER 4 CIRCUIT MODELING WITH HDLs 4.8.6 A HANDY COMPILATION OF TYPE CONVERSION FUNCTIONS with contributions by Reto Zimmermann and Jürgen Wassner The table below and fig.4.26 summarize type conversion functions between the most important VHDL data types. Note that proprietary types, functions,and packages render source code awkward to port from one EDA platform to another. They should, therefore, be dismissed in favor of vendor-independent international standards. Table 4.14 Type conversion functions. according to IEEE 1076 as deﬁned in package std.standard Conversion real integer integer(arg) integer real real(arg) according to IEEE 1076.3 Synopsys proprietary as deﬁned in package ieee.numeric_std ieee.std_logic_arith Conversion std logic vector unsigned unsigned(arg) unsigned(arg) std logic vector signed signed(arg) signed(arg) unsigned std logic vector std logic vector(arg) std logic vector(arg) signed std logic vector std logic vector(arg) std logic vector(arg) integer unsigned to unsigned(arg,size) conv unsigned(arg,size) integer signed to signed(arg,size) conv signed(arg,size) unsigned integer to integer(arg) conv integer(arg) signed integer to integer(arg) conv integer(arg) integer std logic vector integer unsigned|signed std logic vector std logic vector integer std logic vector unsigned|signed integer Resizing unsigned resize(arg,size) conv unsigned(arg,size) signed resize(arg,size) conv signed(arg,size) LISTING 4.21 A Gray counter that makes use of type conversions. See listing 4.10 for the package referenced here. -- Mission: Illustrate how to model a Medvedev machine in two processes. -- Example designed to demonstrate the usage of functions from a package, -- of IEEE numeric_std, type conversions, and a parametrized word width. -- Functionality: w-bit Gray counter with enable and asynchronous reset. -- Operates with double conversion: Gray->binary, increment, binary->Gray, -- which is not necessarily the most economic nor the fastest solution. -- Author: H.Kaeslin. ------------------------------------------------------------------------------- 4.8 APPENDIX II: VHDL EXTENSIONS AND STANDARDS 299 library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; use work.grayconv.all; -- my own set of Gray code converter functions ------------------------------------------------------------------------------- entity graycnt is generic ( GRAYWIDTH : integer :=5); -- default value for number of state bits port ( Clk_CI : in std_logic; Rst_RBI : in std_logic; Ena_SI : in std_logic; Count_DO : out std_logic_vector((GRAYWIDTH-1) downto 0) ); end graycnt; ------------------------------------------------------------------------------- architecture computed_state of graycnt is -- present state and next state signal Count_DP, Count_DN : std_logic_vector(GRAYWIDTH-1 downto 0); begin ---- computation of next state Count_DN <= bintogray(std_logic_vector( unsigned(graytobin(Count_DP))+1)); ---- updating of state p_memzing : process (Clk_CI,Rst_RBI) begin -- activities triggered by asynchronous reset if Rst_RBI=’0’ then Count_DP <= (others => ’0’); -- width-independent shorthand -- activities triggered by rising edge of clock elsif Clk_CI’event and Clk_CI=’1’ then -- proceed to next state only if enable is asserted if Ena_SI=’1’ then Count_DP <= Count_DN; end if; end if; end process p_memzing; 300 CHAPTER 4 CIRCUIT MODELING WITH HDLs ---- assignment of state to output only signal Count_DO <= Count_DP; end computed_state; Scalar Array unsigned(V) to_integer(U) to_integer(S) to_unsigned(I,U′length) to_signed(I,S′length) Type castConversion function std_logic_vector(U) signed(V) std_logic_vector(S) U unsigned I integer V std_logic_vector S signed IEEE,numeric_std IEEE,numeric_std std. standard IEEE.std_logic_1164 FIGURE 4.26 VHDL type conversion paths (chart courtesy of Dr. Jürgen Wassner). 4.8.7 CODING GUIDELINES Third-party HDL code can be very painful to adopt and adapt if its style significantly differs from that of other HDL components and from the practice of the system integrators. An early book with advice on how to write reusable HDL code was [135], but most of it is part of good design practice anyway. While many companies and organisations have developed coding and reuse guidelines for internal usage, ESA was among the first to make theirs widely accessible [136]. A naming convention for VHDL signals developed by the author and his colleagues is to be introduced in section 6.7. In 2008, NXP has published their reuse standards under the label CoReUse [137]. Unfortunately, an industry- wide consensus is nowhere in sight.","libVersion":"0.5.0","langs":""}