{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s06-parsers.pdf","text":"Case Studies David Basin Department of Computer Science ETH Z¨urich Functional Programming David Basin 1 Overview • Present interpreters for arithmetic and for mini-Haskell Important: Interpreters are everywhere! Programming languages, database systems, text processors, hardware description languages, search engines, . . . Conceptually simple: read, evaluate, print Concretization less trivial: elegant application for higher-order programming and lazy evaluation • An interpreter for mini-Haskell illustrates Haskell itself • Source code available from Code Expert. Try it! Functional Programming Spring Semester, 2025 David Basin 2 Interpreter skeleton Abstract Syntax Tree Read Evaluate Print Text Lexical Analysis Text Functional Programming Spring Semester, 2025 David Basin 3 Overview — lexical analysis • Convert source code to tokens position := initial + rate + 60 • Code translated to: 1. Identifier position 2. Assignment symbol := 3. Identifier initial 4. Addition symbol + 5. Identifier rate 6. Addition symbol + 7. Number 60 • White-spaces and comments are removed Functional Programming Spring Semester, 2025 David Basin 4 Overview — parsing • Syntax specified by a grammar Expr ::= Identifier | Number | Expr ‘+’ Expr Assign ::= Identifier ‘:=’ Expr • Corresponds to a data type in Haskell data Expr = Identifier Ident | Number Num | Plus Expr Expr data Assign = Assignment Ident Expr type Ident = String type Num = Int • Parser constructs an “abstract syntax tree” \u0011 In Haskell: element of data type Assign Identifier position NumberIdentifier rate 60 Identifier initial Expr:= Expr Expr Expr Expr + + parse tree for position := initial + rate + 60 Functional Programming Spring Semester, 2025 David Basin 5 Overview — other phases • Further processing depends on application In general: conversion between data types, e.g., Compiler: AST → CODE Calculator: AST → Int Mini-Haskell: AST → AST • For example, in ghci there are additional phases such as: Dependency analysis, type checking, ... Functional Programming Spring Semester, 2025 David Basin 6 Case Study 1: Arithmetic Interpretation Functional Programming Spring Semester, 2025 David Basin 7 Interpreter #1 • A calculator for arithmetic expressions Expr ::= Int | Expr ‘+’ Expr | Expr ‘−’ Expr • Lexical analysis: recognition of integers, ‘+’, and ‘−’ As well as parentheses and white space. • Parsing: convert tokens into abstract syntax tree data Expr = Lit Int | Add Expr Expr | Sub Expr Expr 5 Lit Sub\"2+(3−5)\" Lit Lit Add 2 3 Functional Programming Spring Semester, 2025 David Basin 8 Example (cont.) • Evaluation functions already given earlier eval :: Expr -> Int eval (Lit n) = n eval (Add e1 e2) = (eval e1) + (eval e2) eval (Sub e1 e2) = (eval e1) - (eval e2) • Pretty printer as instance of type class Show instance Show Expr where show (Lit n) = show n show (Add e1 e2) = \"(\" ++ show e1 ++ \"+\" ++ show e2 ++ \")\" show (Sub e1 e2) = \"(\" ++ show e1 ++ \"-\" ++ show e2 ++ \")\" Alternative: just use the standard show by adding deriving Show to the data-type definition Functional Programming Spring Semester, 2025 David Basin 9 Lexical analysis and parsing • Problem important: necessary for all systems with nontrivial input • Interesting too from computer science perspective Formal language theory Relationship between different language classes and recognizers Software engineering Interpreters built from subsystems with well-defined interfaces Computer linguistics Analysis and classification of human languages • Motivation for many software tools, e.g. LEX, YACC, . . . For Haskell: Alex and Happy Functional Programming Spring Semester, 2025 David Basin 10 Combinatory parsing — overview • Idea: modular construction and composition of parser functions first parse this and afterwards that • Result is powerful, e.g., can handle ambiguous grammars • Approach elegantly uses lazy & higher-order programming Also uses monads (new!) to package “higher-order plumbing” Functional Programming Spring Semester, 2025 David Basin 11 Parser type • A parser is a function taking a string as input • Result is an element of type a (typically a data type like Expr) • A parser may process only part of input, leaving a remainder This supports composition: p parses first part and q continues • Allow multiple results from parsing via list of successes [(result1,remainder1), . . ., (resultn,remaindern)] • Hence: data Parser a = Prs (String -> [(a,String)]) Functional Programming Spring Semester, 2025 David Basin 12 Parser application data Parser a = Prs (String -> [(a,String)]) • Apply a parser to an input string: parse :: Parser a -> String -> [(a,String)] parse (Prs p) inp = p inp • So parse p inp = [(result1,remainder1), . . ., (resultn,remaindern)] A pair with the remainder \"\" is a complete parse of the input. • We are interested in the result of the first complete parse: completeParse :: Parser a -> String -> a completeParse p inp | results == [] = error \"Parse unsuccessful\" | otherwise = head results where results = [res | (res,\"\") <- parse p inp] Functional Programming Spring Semester, 2025 David Basin 13 Primitive parsers data Parser a = Prs (String -> [(a,String)]) • Primitive parsers serve as basic building blocks. • Fails trivially ([] signifies ‘unsuccessful parse’): failure :: Parser a failure = Prs (\\inp -> []) • Succeeds trivially without progress: return :: a -> Parser a return x = Prs (\\inp -> [(x,inp)]) • Succeeds trivially with progress: item :: Parser Char item = Prs (\\inp -> case inp of \"\" -> [] (x:xs) -> [(x,xs)]) Functional Programming Spring Semester, 2025 David Basin 14 Primitive parser (cont.) • Parse a single character with property p sat :: (Char -> Bool) -> Parser Char sat p = Prs (\\inp -> case inp of \"\" -> [] (x:xs) -> if p x then [(x,xs)] else []) • Examples (also showing types) ? parse (return \"foo\") \"3+5\" [(\"foo\",\"3+5\")] :: [([Char],String)] ? parse failure \"3+5\" [] :: [(a,String)] ? parse item \"3+5\" [(’3’,\"+5\")] :: [(Char,String)] ? parse (sat (\\x -> ’0’<=x && x<=’9’)) \"3+5\" -- (sat isDigit) \"3+5\" [(’3’,\"+5\")] :: [(Char,String)] ? parse (sat (\\x -> x==’+’ || x==’-’)) \"3+5\" [] :: [(Char,String)] Functional Programming Spring Semester, 2025 David Basin 15 Gluing parsers together • Mutual selection: Apply both first and second parser (|||) :: Parser a -> Parser a -> Parser a p ||| q = Prs (\\s -> parse p s ++ parse q s) • Alternative selection: If first parser fails, apply second parser (+++) :: Parser a -> Parser a -> Parser a p +++ q = Prs (\\s -> case parse p s of [] -> parse q s res -> res) • Examples ? parse (return ’!’ ||| sat isDigit) \"3+5\" [(’!’,\"3+5\"), (’3’,\"+5\")] ? parse (return ’!’ +++ sat isDigit) \"3+5\" [(’!’,\"3+5\")] Functional Programming Spring Semester, 2025 David Basin 16 Gluing parsers together (cont.) • Sequencing: first parser p then parser q to results (>>) :: Parser a -> Parser b -> Parser b p >> q = Prs (\\s -> [ (u,s’’) | (t,s’) <- parse p s, (u,s’’) <- parse q s’ ]) • A schematic example: parse p s ↪→ [. . . (t, s ′) . . . ] and parse q s ′ ↪→ [. . . (u, s ′′) . . . ] =⇒ parse (p >> q) s ↪→ [. . . (u, s ′′) . . . ] • Problem: the result of first parser (t above) is lost ? parse (sat isDigit >> sat (==’+’)) \"3+5\" [(’+’,\"5\")] :: [(Char,String)] ? parse (sat isDigit >> sat isDigit) \"31+5\" [(’1’,\"+5\")] :: [(Char,String)] Functional Programming Spring Semester, 2025 David Basin 17 Sequencing • Solution: use as second argument a “parser generator” that takes as input the result of the first parser (>>=) :: Parser a -> (a -> Parser b) -> Parser b p >>= g = Prs (\\s -> [ (u,s’’) | (t,s’ ) <- parse p s, (u,s’’) <- parse (g t) s’ ]) • Examples ? parse (sat isDigit >>= \\t -> sat isDigit >>= \\u -> return (t:u:[])) \"31+5\" [(\"31\",\"+5\")] ? parse (sat isDigit >>= \\t -> sat isDigit >>= \\u -> return (t:u:[])) \"3+5\" [] • Reimplementation of >> using >>= (>>) :: Parser a -> Parser b -> Parser b p >> q = p >>= \\_ -> q Functional Programming Spring Semester, 2025 David Basin 18 More basic parsers and combinators • Chars and Strings (including simpler definition of sat) sat :: (Char -> Bool) -> Parser Char sat p = item >>= \\x -> if p x then return x else failure char :: Char -> Parser Char char x = sat (==x) string :: String -> Parser String string \"\" = return \"\" string (x:xs) = char x >> string xs >> return (x:xs) • Repetition many :: Parser a -> Parser [a] -- 0 or more repetitions of p many p = many1 p ||| return [] many1 :: Parser a -> Parser [a] -- 1 or more repetitions of p many1 p = p >>= \\t -> many p >>= \\ts -> return (t:ts) • What is the result of the following parse? ? parse (many1 (sat isDigit)) \"31+5\" Functional Programming Spring Semester, 2025 David Basin 19 Improving readability • Haskell supports a more readable use of >>= many1 p = do t <- p ts <- many p return (t:ts) This looks like an imperative program! • Syntactic sugar do t1 <- p1 t2 <- p2 : tn <- pn return (f t1 t2 ... tn) abbreviates p1 >>= \\t1 -> p2 >>= \\t2 -> : pn >>= \\tn -> return (f t1 t2 ... tn) • More sugar, when ti unimportant do t1 <- p1 : pi : abbreviates p1 >>= \\t1 -> : pi >>= \\_ -> : Functional Programming Spring Semester, 2025 David Basin 20 Improving readability (cont.) many1 p = do t <- p ts <- many p return (t:ts) • To use this sugar, we must put Parser into the class Monad instance Monad Parser where return v = ... p >>= g = ... • We will have an another look at monads later in the course Functional Programming Spring Semester, 2025 David Basin 21 Slightly more complex parsers numPos :: Parser Int numPos = do ts <- many1 (sat isDigit) return (read ts) --- read maps numeric string to number numNeg :: Parser Int numNeg = do char ’-’ t <- numPos return (-t) num :: Parser Int num = numPos ||| numNeg -- or: numPos +++ numNeg ? parse num \"123\" [(123,\"\"), (12,\"3\"), (1,\"23\")] :: [(Int,String)] ? parse num \"-123\" [(-123,\"\"), (-12,\"3\"), (-1,\"23\")] :: [(Int,String)] Functional Programming Spring Semester, 2025 David Basin 22 Combinators — overview data Parser a = Prs (String -> [(a,String)]) return :: a -> Parser a (>>=) :: Parser a -> (a -> Parser b) -> Parser b (>>) :: Parser a -> Parser b -> Parser b (|||) :: Parser a -> Parser a -> Parser a (+++) :: Parser a -> Parser a -> Parser a failure :: Parser a item :: Parser Char sat :: (Char -> Bool) -> Parser Char char :: Char -> Parser Char string :: String -> Parser String many :: Parser a -> Parser [a] many1 :: Parser a -> Parser [a] num :: Parser Int -- parse an integer Functional Programming Spring Semester, 2025 David Basin 23 Parsing with combinators • Combinators express general operations Sequence, selection, repetition, recognition of tokens, . . . • It is now easy to recognize languages Result is pair (t, [ ]) • We shall demonstrate this idea with Expr ::= Int | Expr ‘+’ Expr | Expr ‘−’ Expr But we must first solve a few small problems Functional Programming Spring Semester, 2025 David Basin 24 Problem: ambiguous grammars Expr ::= Int | Expr ‘+’ Expr | Expr ‘−’ Expr • How should 2 − 3 + 4 be parsed? − 2 3 4 + +2 4− • Solution is to \u0011 disambiguate grammar using associativity and precedence, \u0011 give the user a means to override defaults using parentheses. • Also: left-recursive grammars lead to non-terminating recursion! Functional Programming Spring Semester, 2025 David Basin 25 Solution #1: disambiguated grammar Expr ::= Atom | Atom ‘+’ Expr | Atom ‘−’ Expr Atom ::= Int | ‘(’ Expr ‘)’ Key to solution • Each Expr begins with an atom, i.e., Int or a ’(’ • Disambiguates grammar and eliminates left-recursion Problem • Both operations are wrongly interpreted as right-associative • Leads to wrong results, for example: ”2 − 3 + 4” is parsed as 2 − (3 + 4) and evaluated to −5. • Could write ”(2 − 3) + 4”, but we want left associativity! Functional Programming Spring Semester, 2025 David Basin 26 Solution #2: left asssociativity Expr ::= Atom ((‘+’ | ‘–’) Atom) ∗ Atom ::= Int | ‘(’ Expr ‘)’ Key to solution • Parse repeated operation/atom pairs after initial atom • Obtain left associativity using fold-left over list of these pairs • Use concrete grammar to build abstract syntax tree of type data Expr = Lit Int | Add Expr Expr | Sub Expr Expr David Basin 26 Solution #2: left asssociativity Expr ::= Atom ((‘+’ | ‘–’) Atom)⇤ Atom ::= Int | ‘(’ Expr ‘)’ Key to solution • Parse repeated operation/atom pairs after initial atom • Obtain left associativity using fold-left over list of these pairs • Use concrete grammar to build abstract syntax tree of type data Expr = Lit Int | Add Expr Expr | Sub Expr Expr Parser constructs   foldl     (\\x (f, y) -> f x y)     (Lit 2)     [(Sub, Lit 3), (Add, Lit 4)] Add Sub Lit 2 Lit 4 Lit 3 Input   \"2 - 3 + 4\" foldl [] (:) (:) (Add, Lit 4) (Sub, Lit 3) Functional Programming Spring Semester, 2022 David Basin 26 Solution #2: left asssociativity Expr ::= Atom ((‘+’ | ‘–’) Atom)⇤ Atom ::= Int | ‘(’ Expr ‘)’ Key to solution • Parse repeated operation/atom pairs after initial atom • Obtain left associativity using fold-left over list of these pairs • Use concrete grammar to build abstract syntax tree of type data Expr = Lit Int | Add Expr Expr | Sub Expr Expr Parser constructs   foldl     (\\x (f, y) -> f x y)     (Lit 2)     [(Sub, Lit 3), (Add, Lit 4)] Add Sub Lit 2 Lit 4 Lit 3 Input   \"2 - 3 + 4\" foldl [] (:) (:) (Add, Lit 4) (Sub, Lit 3) Functional Programming Spring Semester, 2022 David Basin 26 Solution #2: left asssociativity Expr ::= Atom ((‘+’ | ‘–’) Atom)⇤ Atom ::= Int | ‘(’ Expr ‘)’ Key to solution • Parse repeated operation/atom pairs after initial atom • Obtain left associativity using fold-left over list of these pairs • Use concrete grammar to build abstract syntax tree of type data Expr = Lit Int | Add Expr Expr | Sub Expr Expr Parser constructs   foldl     (\\x (f, y) -> f x y)     (Lit 2)     [(Sub, Lit 3), (Add, Lit 4)] Add Sub Lit 2 Lit 4 Lit 3 Input   \"2 - 3 + 4\" foldl [] (:) (:) (Add, Lit 4) (Sub, Lit 3) Functional Programming Spring Semester, 2022 David Basin 9 An example with fold • foldr: right-associative fold foldr (\u0000) e [l1,l2,. .., ln]= l1 \u0000 (l2 \u0000 ·· · \u0000 (ln \u0000 e)) foldr :: (a -> b -> b) -> b -> [a] -> b foldr f e [] = e foldr f e (x:xs) = f x (foldr f e xs) • foldl: left-associative fold foldl (\u0000) e [l1,l2,. .., ln]= ((e \u0000 l1) \u0000 l2) \u0000 ·· · \u0000 ln foldl :: (b -> a -> b) -> b -> [a] -> b foldl f e [] = e foldl f e (x:xs) = foldl f (f e x) xs Functional Programming Spring Semester, 2022 David Basin 26 Solution #2: left asssociativity Expr ::= Atom ((‘+’ | ‘–’) Atom)⇤ Atom ::= Int | ‘(’ Expr ‘)’ Key to solution • Parse repeated operation/atom pairs after initial atom • Obtain left associativity using fold-left over list of these pairs • Use concrete grammar to build abstract syntax tree of type data Expr = Lit Int | Add Expr Expr | Sub Expr Expr Parser constructs   foldl     (\\x (f, y) -> f x y)     (Lit 2)     [(Sub, Lit 3), (Add, Lit 4)] Add Sub Lit 2 Lit 4 Lit 3 Input   \"2 - 3 + 4\" foldl [] (:) (:) (Add, Lit 4) (Sub, Lit 3) Functional Programming Spring Semester, 2022 (\\x (op, y) -> x `op` y Functional Programming Spring Semester, 2025 David Basin 27 The parser Concrete grammar Expr ::= Atom ((‘+’ | ‘–’) Atom) ∗ Atom ::= Int | ‘(’ Expr ‘)’ Parser data Expr = Lit Int | Add Expr Expr | Sub Expr Expr deriving (Show,Eq) expr = do a <- atom fs <- oatoms return (foldl (\\x (op, y) -> x ‘op‘ y) a fs) atom = lit ||| pexpr lit = do x <- num return (Lit x) pexpr = do string \"(\" e <- expr string \")\" return e oatoms = many oatom oatom = do o <- op a <- atom return (o, a) op = (char ’+’ >> return Add) ||| (char ’-’ >> return Sub) Functional Programming Spring Semester, 2025 David Basin 28 Examples • Parse with success ? parse expr \"3+4\" [(Add (Lit 3) (Lit 4),\"\"),(Lit 3,\"+4\")] :: [(Expr,String)] ? parse expr \"2-3+4\" [(Add (Sub (Lit 2) (Lit 3)) (Lit 4),\"\"), ...] ? parse expr \"21+(2--4)\" [(Add (Lit 21) (Sub (Lit 2) (Lit -4)),\"\"), ...] • Failure ? parse expr \"--5\" [] :: [(Expr,String)] ? parse expr \"3 + 4\" [(Lit 3,\" + 4\")] :: [(Expr,String)] • Exercise: extend parser to handle unary minus and white space Functional Programming Spring Semester, 2025 David Basin 29 A (mini-)calculator • Program str2expr :: String -> Expr str2expr s = completeParse expr s eval :: Expr -> Int eval (Lit n) = n eval (Add x y) = eval x + eval y eval (Sub x y) = eval x - eval y calculate = eval . str2expr • Examples ? str2expr \"2+(5--2)\" Add (Lit 2) (Sub (Lit 5) (Lit -2)) :: Expr ? calculate \"2+(5--2)\" 9 :: Int Functional Programming Spring Semester, 2025 David Basin 30 Summary • Writing interpreters and compilers is fundamental \u0011 read, evaluate, print \u0011 Interpreters are everywhere! • Many languages offer “program-generation tools” Opinion: None are so simple, elegant, and understandable as this Fact: Substantial time and code-savings • Lazy evaluation plays an important role in (relatively) efficient generate and test ? parse num \"123\" [(123,\"\"), (12,\"3\"), (1,\"23\")] :: [(Int,String)] Functional Programming Spring Semester, 2025 David Basin 31 Case Study 2: Mini-Haskell Functional Programming Spring Semester, 2025 David Basin 32 Overview • We have seen parsing combinators and a simple application • Now, the λ-calculus \u0011 The same parsing combinators, but another language \u0011 Moreover, an interpreter for the λ-calculus • Goals \u0011 A small but nontrivial example \u0011 A deeper understanding of Haskell itself Functional Programming Spring Semester, 2025 David Basin 33 The λ-calculus • Programs are terms (given a set of variable V and integers Z) t ::= V | (λx. t) | (t1 t2) | Z | (t1 + t2) | (t1 × t2) | True | False | (iszero t) | (if t0 then t1 else t2) | (t1, t2) | (fst t) | (snd t) • Here we formalize the core t ::= V | λx. t | t t′ plus some syntactic sugar • Theorem (Church 1930s): All computable functions can be represented within the (core) λ-calculus. Functional Programming Spring Semester, 2025 David Basin 34 Overview Abstract Syntax Tree Read Evaluate Print Text Lexical Analysis Text Read: parser for the λ-calculus. Syntax trivial. We must however eliminate ambiguity and left-recursion. Deal with white-spaces, etc. Evaluate: function from Term to Term (λx. x) (λx y. x) ↪→ λx y. x Print: simple recursion over data type This is different than in ghci. How? Functional Programming Spring Semester, 2025 David Basin 35 Parsing • Same parser combinators as before data Parser a = Prs (String -> [(a,String)]) return :: a -> Parser a (>>=) :: Parser a -> (a -> Parser b) -> Parser b (|||) :: Parser a -> Parser a -> Parser a many :: Parser a -> Parser [a] many1 :: Parser a -> Parser [a] sat :: (Char -> Bool) -> Parser Char char :: Char -> Parser Char string :: String -> Parser String • Recall that parsers carry out complex operations by composing simple ones, like p ||| q Functional Programming Spring Semester, 2025 David Basin 36 Auxiliary simple parsers • Consuming spaces spaces :: Parser String spaces = many (char ’ ’) • Reading an identifier identifier :: Parser String identifier = do spaces id <- many1 (sat isLetter) spaces return id • Reading a token token :: String -> Parser String token s = do spaces t <- string s spaces return t -- (i.e., s) Functional Programming Spring Semester, 2025 David Basin 37 Parsing λ-terms • Data type for λ-calculus terms data Term = Id String | Ap Term Term | Lam String Term deriving Show • Application t1 t2 produces left recursion (prefix-syntax simpler!) • Syntax without left-recursion Atom ::= Ident | Lamb | Paren Term ::= Atom Atom ∗ Lamb ::= ‘%’ Ident + ‘.’ Term Paren ::= ‘(’ Term ‘)’ \u0011 We use ‘%’ and ‘.’ instead of ‘\\’ and ‘->’, respectively \u0011 Explicit parentheses \u0011 Every parsing starts with an identifier, or symbols ‘%’ or ‘(’ Functional Programming Spring Semester, 2025 David Basin 38 The parser data Term = Id String | Ap Term Term | Lam String Term Atom ::= Ident | Lamb | Paren Term ::= Atom Atom ∗ Lamb ::= ‘%’ Ident + ‘.’ Term Paren ::= ‘(’ Term ‘)’ atom = ident ||| lamb ||| paren ident = do id <- identifier return (Id id) term = do t <- atom -- t ts <- many atom -- [t1 t2 ... tn] return (foldl Ap t ts) -- Ap(Ap(Ap(t t1) t2) ... tn) lamb = do token \"%\" ids <- many1 identifier -- [x1, x2, ..., xn] token \".\" t <- term -- t return (foldr Lam t ids) -- Lam x1 (Lam x2 (...(Lam xn t))) paren = do token \"(\" t <- term token \")\" return t str2term s = completeParse term s Functional Programming Spring Semester, 2025 David Basin 39 Examples ? parse atom \"x y z\" [(Id \"x\",\"y z\"), (Id \"x\",\" y z\")] :: [(Term,String)] ? parse term \"x y z\" -- note left-associated output [(Ap (Ap (Id \"x\") (Id \"y\")) (Id \"z\"),\"\"), ...] ? parse term \"(%x y. x y)\" [(Lam \"x\" (Lam \"y\" (Ap (Id \"x\") (Id \"y\"))),\"\"), ...] ? parse term \"(%x y. x y) z\" [(Ap (Lam \"x\" (Lam \"y\" (Ap (Id \"x\") (Id \"y\")))) (Id \"z\"),\"\"), ...] Functional Programming Spring Semester, 2025 David Basin 40 The pretty printer prettyPrint (Id s) = s prettyPrint (Lam s t) = \"(%\" ++ s ++ \". \" ++ (prettyPrint t) ++ \")\" prettyPrint (Ap s t) = \"(\" ++ (prettyPrint s) ++ \" \" ++ (prettyPrint t) ++ \")\" • Could also use type class Show for pretty printing • Examples ? (prettyPrint . str2term) \"%x y z. x z (y z)\" \"(%x. (%y. (%z. ((x z) (y z)))))\" :: String ? (prettyPrint . str2term) \"%x y z. x (%r. r) (y ((z)))\" \"(%x. (%y. (%z. ((x (%r. r)) (y z)))))\" :: String • Syntactic sugar supported in parsing (not pretty printing): nested abstraction and left-associative application (λx. (λy. (λz. ((x z) (y z))))) ≡ (λx y z. ((x z) (y z))) ≡ λx y z. x z (y z) Functional Programming Spring Semester, 2025 David Basin 41 Evaluation in the λ-calculus standard λ-calculus Declaration: f (x) = g(x, 3) ⇝ f = λx. g x 3 Application: f (5) (λx. g x 3)(5) Reduction: g(x, 3)[x ↦→ 5] (g x 3)[x ↦→ 5] Result: g(5, 3) g 5 3 To formalize evaluation, we must: 1. Formalize reduction based on substitution, i.e., t[x ↦→ s]. 2. Fix an evaluation strategy, e.g., given (λx. x) ((λy. y) 2), what do we reduce first? Functional Programming Spring Semester, 2025 David Basin 42 λ-calculus — substitution • Evaluation is based on substitution (λx. g x 3) 5 = (g x 3)[x ↦→ 5] = g 5 3 • But not all variables have the same role. \u0011 In λy. x y, the variable y is bound and x is free \u0011 Analog from mathematics: x2 + ∫ d c x · y dy or ∑5 i=0 x · i • Renaming and substitution are tricky: must avoid capture! Correct: ∫ b a [x2 + ∫ d c xy dy] dx = ∫ b a [y2 + ∫ d c yz dz] dy Wrong: ∫ b a [x2 + ∫ d c xy dy] dx = ∫ b a [y2 + ∫ d c yy dy] dy Functional Programming Spring Semester, 2025 David Basin 43 Substitution (cont.) • Substitution must respect free and bound variables λx. (x (y x)) λ•. (• (y •)) free (x) = { x } free (M N ) = free (M ) ∪ free (N ) free (λx. M ) = free (M ) \\ { x } • Examples free (λx y. x z) = { z } free (x y (λy z. x y z)) = { x, y } Functional Programming Spring Semester, 2025 David Basin 44 Haskell implementation free (x) = { x } free (M N ) = free(M ) ∪ free(N ) free (λx. M ) = free(M ) \\ { x } Alternative: use Haskell library Data.Set to implement free free :: Term -> [String] free (Id v) = sing v free (Ap s t) = union (free s) (free t) free (Lam v t) = diff (free t) (sing v) empty = [] sing a = [a] member [] _ = False member (x:xs) a | x < a = member xs a | x == a = True | otherwise = False union [] ys = ys diff [] _ = [] union xs [] = xs diff xs [] = xs union (x:xs) (y:ys) diff (x:xs) (y:ys) | x < y = x : union xs (y:ys) | x < y = x : diff xs (y:ys) | x == y = x : union xs ys | x == y = diff xs ys | otherwise = y : union (x:xs) ys | otherwise = diff (x:xs) ys Functional Programming Spring Semester, 2025 David Basin 45 Free variables (cont.) • Incremental testing supported by function composition ? str2term \"%x y. x z\" Lam \"x\" (Lam \"y\" (Ap (Id \"x\") (Id \"z\"))) :: Term ? (free . str2term) \"%x y. x z\" [\"z\"] :: [String] ? (free . str2term) \"x y (%y z. x y z)\" [\"x\", \"y\"] :: [String] • Now we can properly implement substitution Rename bound variables as needed to avoid free variable capture Functional Programming Spring Semester, 2025 David Basin 46 λ-calculus — substitution M [x ↦→ N ] means all free occurrences of x in M are replaced by N 1. x[x ↦→ N ] = N 2. y[x ↦→ N ] = y if y ̸= x 3. (P Q)[x ↦→ N ] = (P [x ↦→ N ]) (Q[x ↦→ N ]) 4. (λx. P )[x ↦→ N ] = λx. P 5. (λy. P )[x ↦→ N ] = λy. (P [x ↦→ N ]) if y ̸= x and y ̸∈ free(N ) 6. (λy. P )[x ↦→ N ] = λz. ((P [y ↦→ z])[x ↦→ N ]) if y ̸= x and y ∈ free(N ), where z ̸∈ free(N P ) Intuitive but easy to get wrong! Functional Programming Spring Semester, 2025 David Basin 47 Substitution (cont.) 1. x[x ↦→ N ] = N 2. y[x ↦→ N ] = y, if y ̸= x 3. (P Q)[x ↦→ N ] = (P [x ↦→ N ]) (Q[x ↦→ N ]) 4. (λx. P )[x ↦→ N ] = λx. P 5. (λy. P )[x ↦→ N ] = λy. (P [x ↦→ N ]), if y ̸= x and y ̸∈ free(N ) 6. (λy. P )[x ↦→ N ] = λz. ((P [y ↦→ z])[x ↦→ N ]) if y ̸= x and y ∈ free(N ), where z ̸∈ free(N P ) • An example (x (λx. x y))[x ↦→ λz. z] = (x[x ↦→ λz. z]) ((λx. x y)[x ↦→ λz. z]) = (λz. z) (λx. x y) • An example with renaming (λy. y x)[x ↦→ y] = λz. (((y x)[y ↦→ z])[x ↦→ y]) = λz. ((z x)[x ↦→ y]) = λz. z y Case 6 avoids variable capture, i.e., λy. y y Functional Programming Spring Semester, 2025 David Basin 48 Implementation 1. x[x ↦→ N ] = N 2. y[x ↦→ N ] = y, if y ̸= x 3. (P Q)[x ↦→ N ] = (P [x ↦→ N ]) (Q[x ↦→ N ]) 4. (λx. P )[x ↦→ N ] = λx. P 5. (λy. P )[x ↦→ N ] = λy. (P [x ↦→ N ]), if y ̸= x and y ̸∈ free(N ) 6. (λy. P )[x ↦→ N ] = λz. ((P [y ↦→ z])[x ↦→ N ]) if y ̸= x and y ∈ free(N ), where z ̸∈ free(N P ) -- subst t v s = t[v -> s] subst :: Term -> String -> Term -> Term subst (Id x) v s = if x == v then s else Id x subst (Ap t1 t2) v s = Ap (subst t1 v s) (subst t2 v s) subst (Lam x t) v s | x == v = Lam x t | not (member (free s) x) = Lam x (subst t v s) | otherwise = Lam z (subst (subst t x (Id z)) v s) where z = fresh (union (free t) (free s)) fresh m = (foldr max \"\" m) ++ \"’\" -- returns id not in m ? prettyPrint (subst (str2term \"x (%x. x y)\") \"x\" (str2term \"%z. z\")) \"((%z. z) (%x. (x y)))\" :: String ? prettyPrint (subst (str2term \"x (%x. x y)\") \"y\" (str2term \"f x\")) \"(x (%y’. (y’ (f x))))\" :: String Functional Programming Spring Semester, 2025 David Basin 49 The essence of evaluation is β-reduction • A term (λx. M ) N is called a redex • β-reduction is the rule for simplifying redexes (λx. M ) N ↪→ M [x ↦→ N ] • The result M [x ↦→ N ] is called the contractum • Example (λx. f (x x)) N ↪→ f (N N ) • Evaluation fixes a strategy for reducing redexes Functional Programming Spring Semester, 2025 David Basin 50 Evaluation strategy (t ↪→ r) • t1 t2 represents the first application of a function to an argument \u0011 First evaluate t1: t1 ↪→ r1 If r1 ̸= λx. r then throw an exception (or return application) • Evaluation strategy 1: Eager \u0011 Also evaluate t2 prior to β-reduction: t2 ↪→ r2 (λx. r) r2 ↪→ r[x ↦→ r2] \u0011 Evaluation also carried out under an abstraction (λx. t) • Evaluation strategy 2: Lazy \u0011 Apply β-reduction to r1 t2, i.e., substitute t2 without evaluation (λx. r) t2 ↪→ r[x ↦→ t2] \u0011 No evaluation under an abstraction • The result of the β-reduction is then further evaluated. Functional Programming Spring Semester, 2025 David Basin 51 Implementing eager and lazy evaluation beta (Lam x t) t’ = subst t x t’ eager :: Term -> Term eager (Id x) = (Id x) eager (Ap t t’) = case r of (Lam _ _) -> eager (beta r r’) _ -> Ap r r’ where r = eager t r’ = eager t’ eager (Lam x t) = Lam x (eager t) lazy :: Term -> Term lazy (Id x) = (Id x) lazy (Ap t t’) = case r of (Lam _ _) -> lazy (beta r t’) _ -> Ap r t’ where r = lazy t lazy t = t -- no evaluation under a lambda abstraction Functional Programming Spring Semester, 2025 David Basin 52 Two interpreters for the λ-calculus evalE = prettyPrint . eager . str2term evalL = prettyPrint . lazy . str2term Functional Programming Spring Semester, 2025 David Basin 53 Examples ? evalE \"(%x y. x) a b\" \"a\" :: String ? evalL \"(%x y. x) a b\" \"a\" :: String ? evalE \"(%x. (%y. y) x)\" \"(%x. x)\" :: String ? evalL \"(%x. (%y. y) x)\" \"(%x. ((%y. y) x))\" :: String ? evalL \"(%x y. x y) (x y z)\" \"(%z’. (((x y) z) z’))\" :: String Functional Programming Spring Semester, 2025 David Basin 54 Examples (cont.) Moses Sch¨onfinkel s = \"(%x y z. x z (y z))\" k = \"(%x y. x)\" i = \"(%x. x)\" ? evalE (s ++ k ++ k) \"(%z. z)\" :: String ? evalL (s ++ k ++ k) \"(%z. (((%x. (%y. x)) z) ((%x. (%y. x)) z)))\" :: String ? evalL (s ++ k ++ k ++ \" a\") \"a\" :: String omega = \"((%x. x x) (%x. x x))\" ? evalL omega \"{Interrupted!} Functional Programming Spring Semester, 2025 David Basin 55 Full story: eager evaluation in a lazy language omega = \"((%x. x x) (%x. x x))\" ? evalE \"(%z. y)\" ++ omega -- wrong result, should loop! \"y\" Problem: Haskell is lazy and it does not fully evaluate omega, since it is not needed to produce the result. Solution: Use strict function application ($!): f $! x is like f x, but forces the evaluation of its argument x (up to first constructor). eager :: Term -> Term eager (Id x) = (Id x) eager (Ap t t’) = case r of (Lam _ _) -> eager ((beta $! r) $! r’) _ -> (Ap $! r) $! r’ where r = eager t r’ = eager t’ eager (Lam x t) = Lam x $! (eager t) Functional Programming Spring Semester, 2025 David Basin 56 Coding in the λ-calculus • Despite its simplicity, we can represent arithmetic functions in the λ-calculus. • To do this, we first give a total, computable, injective function ·, mapping N to λ-terms. For example, n = λs z. sn(z) e.g. 2 = λs z. s(sz) This representation is called the Church numerals. • A λ-term f represents a function f : N k → N iff for all n1, . . . , nk ∈ N f n1, . . . , nk = f (n1, . . . , nk) Functional Programming Spring Semester, 2025 David Basin 57 Coding in the λ-calculus (cont.) • Representing the natural numbers (here n represents n) n = λs z. sn(z) e.g. 2 = λs z. s (s z) • Representing addition: add = λx y s z. x s (y s z) add n m = (λx y s z. x s (y s z)) (λs z. sn(z)) (λs z. sm(z)) ↪→ λs z. ((λs z. sn(z)) s) ((λs z. sm(z)) s z)) ↪→ λs z. ((λz. s n(z)) (sm(z))) ↪→ λs z. sn(sm(z)) ↪→ λs z. sn+m(z) = n + m • Idea can be extended to all (partial recursive) functions Functional Programming Spring Semester, 2025 David Basin 58 Coding (with interpreter) • Addition with our interpreter add = \"(%x y s z. x s (y s z))\" ? evalE (add ++ \"(%s z. s z)\" ++ \"(%s z. s (s z))\") \"(%s. (%z. (s (s (s z)))))\" :: String • Addition in Haskell hadd = \\x y s z -> x s (y s z) ? hadd (\\s z -> s (s z)) (\\s z -> s z) <<function>> :: (a -> a) -> a -> a data Nat = Zero | Succ Nat deriving (Show,Ord,Eq) ? hadd (\\s z -> s (s z)) (\\s z -> s z) Succ Zero Succ (Succ (Succ Zero)) :: Nat Functional Programming Spring Semester, 2025 David Basin 59 Relationship to Haskell • Haskell interpreter extends evalL \u0011 Constructors like ‘:’ are interpreted lazily. Friedman and Wise, Cons should not evaluate its arguments, ICALP 1976 \u0011 Considerably more syntactic sugar • Functions are not printed (show) ? \\x y -> x y <<function>> :: (a -> b) -> a -> b • Types protect against runtime errors • But evalL is the basis! Functional Programming Spring Semester, 2025 David Basin 60 Summary • Complicated concepts can be simply formalized \u0011 Parsing using primitive parsers + combinators \u0011 Evaluation strategies • Haskell supports a clean modeling \u0011 Data types for abstract syntax trees \u0011 Higher-order functions for combinators \u0011 Lazy evaluation for efficiency • Interpreter provides considerable insight into Haskell itself Functional Programming Spring Semester, 2025","libVersion":"0.5.0","langs":""}