{"path":"sem4/DMDB/UE/slides/DMDB-s10-recovery.pdf","text":"• Eugenie Kwak & Anıl Eren Göçer Data Modelling & Databases eukwak@student.ethz.ch Exercise 10: Recovery Spring 25 agoecer@student.ethz.ch ▪ Theory review ▪ Quiz review ContentsWhy Recovery? • Last week: • DBMS may be accessed concurrently • programmers do not have to care too much about concurrency • Concurrency • We may need a recovery system in case of “bad” scheduling • Data safety guarantee Question 1 ▪ If a transaction is aborted, we apply all the changes before the abort took place to not loose data • NO! ▪ True/False: ABORT/ROLLBACK can be initiated by a user or the DBMS • YES. Question 1 - Recoverable (RC) Schedule ▪ Textbook definition: A schedule is recoverable if each transaction commits only after each transaction from which it has read has committed. ▪ Logically: Q1: If Ti reads from Tj and commits, then cj<ci → No need to undo a committed transaction -- T1 -- BEGIN Read(X) Commit -- T2 -- BEGIN Write(X) Commit Recoverable? Yes -- T1 -- BEGIN Read(X) Commit -- T2 -- BEGIN Write(X) Commit Recoverable? No Need to undo T1. 5 Question 1 - Avoids Cascading Aborts (ACA) Schedule ▪ Textbook Definition: A schedule avoids cascading rollback if transactions may read only values written by committed transactions. ▪ Logically: Q1: If Ti reads X from Tj, then cj<ri[X] →Aborting a transaction does not cause aborting others →Transactions only read from already committed transactions -- T1 -- BEGIN Read(X) -- T2 -- BEGIN Write(X) Commit ACA? Yes -- T1 -- BEGIN Read(X) -- T2 -- BEGIN Write(X) Commit ACA? No Need to abort T1. 6 Question 1 - Avoids Cascading Aborts (ACA) Schedule ▪ True/False: If a history is not ACA, we may have performance loss. ▪ True ▪ We need to abort many transactions 7 Question 1 - Strict (ST) Schedule ▪ Strict Locking: A transaction must not release any exclusive locks until the transaction has either committed or aborted, and the commit or abort log record has been flushed to disk. ▪ A schedule of transactions that follow the strict-locking rule is called a strict schedule. ▪ Logically: Q1: If Ti reads from or overwrites a value written by Tj, then (cj<ri[X] AND cj<wi[X]) or (aj<ri[X] AND aj<wi[X]). → Undoing a transaction does not undo the changes of other transaction. -- T1 -- BEGIN Write(X) -- T2 -- BEGIN Write(X) Commit Strict? Yes -- T1 -- BEGIN Write(X) -- T2 -- BEGIN Write(X) Commit Strict? No Need to undo T1’s change. 8 Question 1 ▪ Assume that you run a program getting data from a database which is not RC. Then: • The read data is always trustworthy. • The data read could be removed due to an ABORT and shouldn‘t have been seen in the first place. Question 1 ▪ Assume that you run a program getting data from a database which is not RC. Then: • The read data is always trustworthy. • The data read could be removed due to an ABORT and shouldn‘t have been seen in the first place. Question 2 (1) w2(A), r1(A), c1, c2 11 w2(A) r1(A) c1 c2 T1 T2 • T1 reads from T2, but c1 < c2=> Not recoverable. • Conflict Serializable Question 2 (2) w2(A), r1(A), c1, a2 12 • T1 reads from T2, but T2 doesn’t even commit => Not recoverable. • Conflict Serializable (3) w2(A), r1(A), a1, a2 • No commit is made=> Recoverable. • Conflict Serializable Question 2 (4) w2(A),c2,r1(A),c1 ▪ T1 reads from T2, and c2< r1(A). => Strict. ▪ CS (T2, T1) 13 (5) w1(A),w2(A),c2,c1 ▪ No read; T2 overwrites T1 but w2(A) < c1 – T1 does not commit before T2 writes => Not strict => ACA ▪ CS (T2, T1) Question 2 (6) r2(A),w1(A),w2(A),c2,c1 14 T1 T2 ▪ T2 does not read from T2 (nor T1); the same reason in (5) about why it is not Strict. => ACA. ▪ Not CS (r2(A) < w1(A) and w1(A) < w2(A) => cyclic dependency) r2(A) w1(A) w2(A) c1 c2 Question 2 (7) w2(A),w3(A),a3,r1(A),c2,c1 ▪ T1 reads from T2 (the write from T3 is not visible because T3 has already aborted) and commits after T2. The read happens before the commit of T2, so not ACA. => Recoverable. ▪ CS (T2, T1, T3 abort, any place is fine for it) 15 (8) w1(A),r2(B),c1,w2(A),c2 ▪ T2 overwrites A from T1, w2(A) happens after the T1 commit. => Strict. ▪ CS (T1, T2.) Question 2 (9) w1(A),r2(B),w1(B),c1,w2(A),c2 16 T1 T2 ▪ T2 overwrites A from T1, w2(A) happens after the T1 commit. => Strict. ▪ Not CS (r2(B)< w1(B) and w1(A)<w2(A) form a cyclic dependency.) r2(B) w1(A) w1(B) c1 c2 w2(A) Question 3 (1) r2(A),r1(A),w1(A),r1(B),w1(B),w2(A),c1,c2 17 T1 T2 ▪ No transaction reads from the other one, so ACA; T2 overwrites A from T1 and c1≮w2 (A), so it is not strict. => ACA ▪ Not CS (r2(A)<w1(A) and r1(A)<w2(A) form a cycle) r2(A) r1(A) w1(A) r1(B) w1(B) w2(A) c1 c2 Question 3 18 (2) w2(B),w1(A),r2(A),w2(A),c2,c1 ▪ T2 reads from T1, but T1 does not commit before T2. => Not recoverable. ▪ CS (T1,T2.) (3) w3(A),w2(A),c3,w1(A),r1(B),w2(A),c2,w1(B),c1 ▪ No transaction reads from the other one, so the ACA; T2 overwrites A from T3 and c3≮w2(A), so it is not strict. => ACA. ▪ Not CS (w2(A)<w1(A) and w1(A) < w2(A) form a cycle) Question 3 (4) w2(A),w1(A),r2(A),w2(A),c1,c2 ▪ T2 reads from T1, c1<c2 (Recoverable); c1≮r2(A) (Not ACA). => Recoverable. ▪ Not CS (w2(A)<w1(A) and w1(A) < r2(A) form a cycle) 19 (5) w1(A),w2(A),r2(A),w2(A),c2,r1(A),c1 ▪ T1 reads from T2, c2 < r1(A) (ACA); Notice T2 reads its own value of A, not the previous one of T1. => ACA. ▪ Not CS (w1(A)<w2(A) and w2(A) < r1(A) form a cycle) (6) w2(A),r1(A),w3(A),a3,c2,c1 ▪ T1 reads from T2, c2<c1 (Recoverable); c2≮r2(A) (Not ACA). => Recoverable ▪ CS (T2, T1, T3 aborts, any place is fine for T3.) Question 3 (7) r2(C),w1(A),r2(B),w1(B),c1,w2(C),c2 20 T1 T2 ▪ No transaction reads or overwrites values from other transactions, so the history is strictly recoverable. => Strict. ▪ CS (T2, T1) r2(C) w1(A) w1(B) r2(B) c1 c2 w2(C) Concurrency control ▪ Concurrency control happens a lot through locks → as seen in Parallel Programming ▪ There are multiple types of locks (Shared locks, exclusive locks, …), some of which like a shared lock can be acquired multiple times e.g. for reading, while others like exclusive locks (for writing) can’t ▪ There are multiple algorithms for locking: You’ve focused on Two phase locking ▪ Locks are not the only way for concurrency control: see e.g., Snapshot isolation 2PL: Two Phase Locking ▪ Phase 1: Growing ➢ Each transaction requests the locks that it needs from the DBMS's lock manager ➢ It cannot release locks in Phase 1. ▪ Phase 2: Shrinking ➢ The transaction is only allowed to release locks that it previously required. It cannot acquire new locks. EOT = End of transaction. All locks are released here at latest Lock Unlock 22 Strict 2PL: Strict Two Phase Locking Strict 2PL ▪ Phase 1: Growing ➢ Each transaction requests the locks that it needs from the DBMS's lock manager ➢ It cannot release locks ▪ Phase 2: ➢ All locks are kept until the end of transaction (commit or abort) and then released all at once (Q6, (3)) Unlock all Lock 23 Q4: Strict 2PL and strict histories S2PL ensures strict histories? Unlock all Lock Ti can only start reading X from here Tj Def strict: If Ti reads from or overwrites a value written by Tj, then (cj<ri[X] AND cj<wi[X]) or (aj<ri[X] AND aj<wi[X]). → Yes, S2PL ensures strict histories 24 Snapshot Isolation ▪ Main idea: Have an own copy of the database content from when the transaction starts. ▪ When a transaction T starts it receives a timestamp TS(T) ▪ All reads are carried out as of the DB version of TS(T) (= The start time of T) ▪ All writes are carried out in a separate buffer (Q4) ▪ When a transaction commits, DBMS checks for conflicts - Abort T1 if exists T2 such that T2 committed after TS(T1) and before T1 commits, and T1 and T2 updated the same object. → first committer wins rule (Q4) ▪ Writes and reads do not block each other. T1 T2 T1 T2 A B 25 Snapshot Isolation ▪ Extreme Case: If a transaction is read-only, it always has access to a consistent DB snapshot without acquiring (exclusive) locks. T1 T2 T1 T2 A B R(X) R(X) R(Y) R(Y) Which transaction can commit here? Both can commit. There are only reads! 26 Question 4 b1 r1(A) w1(B) b2 w2(A) r2(B) b3 c2 r3(A) c1 c3 Possible under SI/S2PL? 27 Question 4 b1 r1(A) w1(B) b2 w2(A) r2(B) b3 c2 r3(A) c1 c3 28 -- T1 -- BEGIN S-LOCK(A) Read(A) X-LOCK(B) Write(B) UNLOCK(A) UNLOCK(B) COMMIT -- T2 -- BEGIN X-LOCK(A) Write(A) S-LOCK(B) Read(B) UNLOCK(A) UNLOCK(B) COMMIT -- T3 -- BEGIN S-LOCK(A) Read(A) UNLOCK(A) COMMIT T2 cannot write to A, while T1 has a read lock on A (op 5 vs op 2). It is not possible in S2PL; TS(T1)=1; TS(T2)=2; TS(T3)=3. You can think of SI by using the timestamps or draw it as on the left Possible under SI: We don‘t overwrite the same objects in any of the three Transactions Question 4 b1 r1(A) b2 r2(A) w2(B) c2 w1(A) c1. 29 -- T1 -- BEGIN S-LOCK(A) Read(A) X-LOCK(A) Write(A) UNLOCK(A) COMMIT -- T2 -- BEGIN S-LOCK(A) Read(A) X-LOCK(B) Write(B) UNLOCK(A) UNLOCK(B) COMMIT It is possible for SI since T1 and T2 writes different objects. It is possible for S2PL. TS(T1)=1; TS(T2)=2. Question 4 b1 w1(B) r1(A) b2 w2(B) c1 a2 30 -- T1 -- BEGIN X-LOCK(B) Write(B) S-LOCK(A) Read(A) COMMIT -- T2 -- BEGIN X-LOCK(B) Write(B) UNLOCK(B) ABORT T2 cannot write B (w2(B)), while T1 has a write lock on B (from w1(B)). It is not possible in S2PL; SI possible (even though it looks like T2 overwrites B, we abort T2 → that’s what the DBMS should do if it detected a conflict) TS(T1)=1; TS(T2)=2. Question 4 b1 w1(A) b2 r1(B) r2(B) c1 w2(A) c2 . 31 -- T1 -- BEGIN X-LOCK(A) Write(A) S-LOCK(B) Read(B) UNLOCK(A) UNLOCK(B) COMMIT -- T2 -- BEGIN S-LOCK(B) Read(B) X-LOCK(A) Write(A) UNLOCK(B) UNLOCK(A) COMMIT It is possible for S2PL. It is not possible for SI. T2 cannot successfully commit because both transactions write on A (w1(A) and w2(A)) and it started while the other transaction was running. TS(T1)=1; TS(T2)=2. SQL „phenomena“ ▪ Dirty reads: Read uncommitted („dirty“) data • Dirty reads result in non ACA schedules. Since for ACA (by def.) we need to be sure that the read is from committed transactions only ▪ Non repeatable reads: If a transaction reads the same item at different times and the value is different as „someone else“ updated the object • Non serializable (a serial schedule will never read something different from the same object since we don‘t see concurrency in a serial schedule) ▪ Phantom reads: Read an intermediate tuple which disappers/gets added due to a concurrent insert/delete Question 5: Isolation levelQuestion 5: Isolation levelQuestion 6 ▪ 1. Can phantoms occur in snapshot isolation? ➢ No. In snapshot isolation (on a table), a transaction does not see any updates performed after it has started and, thus, phantoms cannot occur. ▪ 2. In Two Phase Locking (2PL), one can release all locks at the point when the transaction has finished but has not issued a commit. ➢ (1) Are histories generated by this approach always serializable? • Yes. The 2PL property is preserved → lecture saw conflict serializability proof. CS is subset of serializability, so this holds. ➢ (2) Are histories generated by this approach always recoverable? • No. Histories can be non-recoverable because of accessing uncommitted data. Question 6 ▪ 3. In practice deadlocks are “resolved” by aborting very long running transactions/queries ➢ Yes. This is in fact true and a tradeoff between correctness and speed. Deadlocks are considered rare enough, so even though aborting a long running transaction may be a mistake, it’s less costly than calculating the wait for graph to find the actual deadlock. ▪ 4. Can concurrent access only happen in distributed databases? ➢ No. Concurrent access is perfectly fine to happen on just one machine e.g. by having a multithreaded application. However, concurrency and recoverability is much more difficult in the distributed setting where you need to coordinate between multiple DBs. Question 6 ▪ 5. Consider the following two conflicting transactions: T1: r1(A) w1(B) c1 T2:r2(B) w2(A) c2 ▪ (1) Which history corresponds to the serial execution T2, T1 and has c1<c2 ? ➢ w2(A),r2(B),r1(A),w1(B),c1,c2 ➢ w1(B),r2(B),w2(A),r1(A),c1,c2 ➢ r2(B),w2(A),r1(A),w1(B),c1,c2 ➢ r2(B),r1(A),w1(B),w2(A),c1,c2 Question 6 ▪ 5. Consider the following two conflicting transactions: T1: r1(A) w1(B) c1 T2:r2(B) w2(A) c2 ▪ (1) Which history corresponds to the serial execution T2, T1 and has c1<c2 ? ➢ w2(A),r2(B),r1(A),w1(B),c1,c2 ➢ w1(B),r2(B),w2(A),r1(A),c1,c2 ➢ r2(B),w2(A),r1(A),w1(B),c1,c2 ➢ r2(B),r1(A),w1(B),w2(A),c1,c2 ▪ Is this history possible under Two Phase Locking (2PL)? ➢ Yes. In 2PL, the lock on A could be released directly after the write because T2 does not need to acquire any other locks after that point. A similar argument applies to the lock on B. ▪ Is this history possible under Strict Two Phase Locking (S2PL)? ➢ No. In S2PL, the locks can only be released after the transaction holding it has been committed, so T2 would still hold the lock on A at the point where T2 accesses it, which is not possible. Question 6: Serial history -- T1 -- BEGIN S-LOCK(B) Read(B) X-LOCK(A) Write(A) UNLOCK(B) UNLOCK(A) COMMIT -- T2 -- BEGIN S-LOCK(A) Read(A) W-LOCK(A) Write(A) UNLOCK(A) UNLOCK(B) COMMIT T1: r1(A) w1(B) c1 T2: r2(B) w2(A) c2 r2(B),w2(A),r1(A),w1(B),c1,c2 COMMIT too late for S2PL but ok for 2PL Thank you.","libVersion":"0.5.0","langs":""}