{"path":"sem4/FMFP/UE/s/FMFP-u01-s.pdf","text":"Formal Methods and Functional Programming Solutions Sheet 1 252-0058-00L February 24, 2025 1. Evaluation strategies (a) Solution fibLouis 4 = fibLouis (4-1) + fibLouis (4-2) = fibLouis 3 + fibLouis (4-2) = (fibLouis (3-1) + fibLouis (3-2)) + fibLouis (4-2) = (fibLouis 2 + fibLouis (3-2)) + fibLouis (4-2) = ((fibLouis (2-1) + fibLouis (2-2)) + fibLouis (3-2)) + fibLouis (4-2) = ((fibLouis 1 + fibLouis (2-2)) + fibLouis (3-2)) + fibLouis (4-2) = ((1 + fibLouis (2-2)) + fibLouis (3-2)) + fibLouis (4-2) = ((1 + fibLouis 0) + fibLouis (3-2)) + fibLouis (4-2) = ((1 + 0) + fibLouis (3-2)) + fibLouis (4-2) = (1 + fibLouis (3-2)) + fibLouis (4-2) = (1 + fibLouis 1) + fibLouis (4-2) = (1 + 1) + fibLouis (4-2) = 2 + fibLouis (4-2) = 2 + fibLouis 2 = 2 + (fibLouis (2-1) + fibLouis (2-2)) = 2 + (fibLouis 1 + fibLouis (2-2)) = 2 + (1 + fibLouis (2-2)) = 2 + (1 + fibLouis 0) = 2 + (1 + 0) = 2 + 1 = 3 (b) Solution fibEva 4 = fst (aux 4) = fst (next (aux (4-1))) = fst (next (aux 3)) = fst (next (next (aux (3-1)))) = fst (next (next (aux 2))) = fst (next (next (next (aux (2-1))))) = fst (next (next (next (aux 1)))) = fst (next (next (next (next (aux (1-1)))))) = fst (next (next (next (next (aux 0))))) = fst (next (next (next (next (0, 1))))) = fst (next (next (next (1, 0+1)))) = fst (next (next (0+1, 1+(0+1)))) = fst (next (1+(0+1), (0+1)+(1+(0+1)))) = 1 Formal Methods and Functional Programming Solutions Sheet 1 252-0058-00L February 24, 2025 fst ((0+1)+(1+(0+1)), (1+(0+1))+((0+1)+(1+(0+1)))) = (0+1)+(1+(0+1)) = 1 + (1 + 1) = 1 + 2 = 3 Note that the running times of fibEva and fibLouis are quite different. Try to evaluate fibEva 30 and fibLouis 30 in GHCi! The difference in running times can be explained best when you write the evaluation of fibLouis as a tree: fibL 8 | \\ fibL 7 fibL 6 | \\ | \\ fibL 6 fibL 5 ... ... | \\ ... ... The entire subtree for fibLouis 6 is calculated twice, the subtree for fibLouis 5 is calculated three times, the subtree for fibLouis 4 is calculated 5 times, and so forth. This leads to a blow-up in running times compared to fibEva, where aux is evalu- ated only once for every value. In summary, fibLouis has a running time that is exponential in n, i.e., O(2n). The running time of fibEva is linear in n, i.e., O(n). 2 Formal Methods and Functional Programming Solutions Sheet 1 252-0058-00L February 24, 2025 2. Natural Deduction (a) Solution (i) (A ∨ B) → (C → ((A ∧ C) ∨ (B ∧ C))) (ii) (A → (B → C)) → ((A ∧ B) → C) (b) Solution The proof trees are as follows: 3 Formal Methods and Functional Programming Solutions Sheet 1 252-0058-00L February 24, 2025 (c) Solution 4 Formal Methods and Functional Programming Solutions Sheet 1 252-0058-00L February 24, 2025 Headache of the week 5","libVersion":"0.5.0","langs":""}