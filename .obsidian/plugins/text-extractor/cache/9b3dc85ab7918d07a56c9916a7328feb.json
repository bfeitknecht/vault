{"path":"HS23/AuD/UE/s/AuD-u03-s.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 9 October 2023 Johannes Lengler, David Steurer Lucas Slot, Manuel Wiedmer, Hongjie Chen, Ding Jingqiu Algorithms & Data Structures Exercise sheet 3 HS 23 The solutions for this sheet are submitted at the beginning of the exercise class on 16 October 2023. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. Asymptotic Notation The following two definitions are closely related to the O-notation and are also useful in the running time analysis of algorithms. Let N be again a set of possible inputs. Definition 1 (Ω-Notation). For f : N → R+, Ω(f ) := {g : N → R+ | f ≤ O(g)}. We write g ≥ Ω(f ) instead of g ∈ Ω(f ). Definition 2 (Θ-Notation). For f : N → R+, Θ(f ) := {g : N → R+ | g ≤ O(f ) and f ≤ O(g)}. We write g = Θ(f ) instead of g ∈ Θ(f ). In other words, for two functions f, g : N → R+ we have g ≥ Ω(f ) ⇔ f ≤ O(g) and g = Θ(f ) ⇔ g ≤ O(f ) and f ≤ O(g). We can restate Theorem 1 from exercise sheet 2 as follows. Theorem 1 (Theorem 1.1 from the script). Let N be an infinite subset of N and f : N → R+ and g : N → R+. • If lim n→∞ f (n) g(n) = 0, then f ≤ O(g), but f ̸= Θ(g). • If lim n→∞ f (n) g(n) = C ∈ R+, then f = Θ(g). • If lim n→∞ f (n) g(n) = ∞, then f ≥ Ω(g), but f ̸= Θ(g). Exercise 3.1 Asymptotic growth (2 points). For all the following functions the variable n ranges over N. (a) Prove or disprove the following statements. Justify your answer. (1) 1 5 n3 ≥ Ω(10n2) Solution: True by Theorem 1, since lim n→∞ 1 5 n3 10n2 = lim n→∞ 1 50 n = ∞. (2) n2 + 3n = Θ(n2 log(n)) Solution: False, by Theorem 1, since lim n→∞ n2 + 3n n2 log(n) = lim n→∞ 1 log(n) + lim n→∞ 3 n log(n) = 0 + 0 = 0. (3) 5n4 + 3n2 + n + 8 = Θ(n4) Solution: True by Theorem 1, since lim n→∞ 5n4 + 3n2 + n + 8 n4 = lim n→∞ 5 + 3 n2 + 1 n3 + 8 n4 = 5. (4) 3n ≥ Ω(2n) Solution: True by Theorem 1, since lim n→∞ 3n 2n = lim n→∞ ( 3 2 )n = ∞. (b) Prove the following statements. Hint: For these examples, computing the limits as in Theorem 1 is hard or the limits do not even exist. Try to prove the statements directly with inequalities as in the definition of the O-notation. (1) (sin(n) + 2)n = Θ(n) Hint: For any x ∈ R we have −1 ≤ sin(x) ≤ 1. Solution: Using the hint we get that 1 ≤ sin(n) + 2 ≤ 3 and thus n ≤ (sin(n) + 2)n ≤ 3n. The first inequality shows that n ≤ O((sin(n) + 2)n) whereas the second one shows (sin(n) + 2)n ≤ O(n). Together we get (sin(n) + 2)n = Θ(n). (2) ∑n i=1 ∑i j=1 j = Θ(n3) Hint: In order to show n3 ≤ O(∑n i=1 ∑i j=1 j), you can use exercise 1.3. Solution: 2 To show that ∑n i=1 ∑i j=1 j ≤ O(n3) we can compute n∑ i=1 i∑ j=1 j ≤ n∑ i=1 i∑ j=1 n = n∑ i=1 i · n ≤ n∑ i=1 n2 = n3. To show that n3 ≤ O(∑n i=1 ∑i j=1 j) we use exercise 1.3b, which states that i∑ j=1 j ≥ 1 4 i 2 and n∑ i=1 i 2 ≥ 1 8 n3. Combining these we get n∑ i=1 i∑ j=1 j ≥ n∑ i=1 1 4 i 2 ≥ 1 4 · 1 8 n3, which is equivalent to n3 ≤ 32 n∑ i=1 i∑ j=1 j. This shows that indeed n3 ≤ O(∑n i=1 ∑i j=1 j) and we get that ∑n i=1 ∑i j=1 j = Θ(n3). (3) log(n4 + n3 + n2) ≤ O(log(n3 + n2 + n)) Solution: As log is monotone and n4 + n3 + n2 ≤ 3n4, we have log(n4 + n3 + n2) ≤ log(3n4) = log(3) + 4 log(n). Now, 3 ≤ n3 + n2 + n and n3 ≤ n3 + n2 + n, so we get log(3) ≤ log(n3 + n2 + n) and 4 log(n) = 4 3 log(n3) ≤ 4 3 log(n3 + n2 + n). So we can conclude that log(n4 + n3 + n2) ≤ log(3) + 4 log(n) ≤ 7 3 log(n3 + n2 + n), which means that log(n4 + n3 + n2) ≤ O(log(n3 + n2 + n)). (4)* ∑n i=1 √i = Θ(n√n) Hint: Recall again exercise 1.3 and try to do an analogous computation here. Solution: We first show ∑n i=1 √i ≤ O(n√n). For all i ∈ N with 1 ≤ i ≤ n we have √ i ≤ √n and thus n∑ i=1 √i ≤ n∑ i=1 √n = n√n, 3 which shows that ∑n i=1 √i ≤ O(n√n). Second, we show that n√n ≤ O( ∑n i=1 √i). We have, similar to exercise 1.3, n∑ i=1 √i ≥ n∑ i=⌈ n 2 ⌉ √i ≥ n 2 √ n 2 , since the sum has n − ⌈ n 2 ⌉ + 1 ≥ n − ( n 2 + 1) + 1 = n 2 terms and every term is at least √ n 2 because i ≥ ⌈ n 2 ⌉ ≥ n 2 . Thus, n∑ i=1 √i ≥ 1 2√ 2 n√ n or equivalently n√n ≤ 2 √2 n∑ i=1 √i, which shows n√n ≤ O( ∑n i=1 √i) and thus completes the proof. Exercise 3.2 Substring counting. Given a n-bit bitstring S (an array over {0, 1} of size n ∈ N), and an integer k ≥ 0, we would like to count the number of nonempty substrings of S with exactly k ones. For example, when S = “0110” and k = 2, there are 4 such substrings: “011”, “11”, “110”, and “0110”. (a) Design a “naive” algorithm that solves this problem with a runtime of O(n3). Justify its runtime and correctness. Solution: We can for example use the following algorithm: Algorithm 1 Naive substring counting c ← 0 ▷ Initialize counter of substrings with k ones for i ← 0, . . . , n − 1 do ▷ Enumerate all nonempty substrings S[i..j] for j ← i, . . . , n − 1 do x ← 0 ▷ Initialize counter of ones for ℓ ← i, . . . , j do ▷ Count ones in substring if S[ℓ] = 1 then x ← x + 1 if x = k then ▷ If there are k ones in substring, increment c c ← c + 1 return c ▷ Return number of substrings with k ones We perform at most n iterations of each loop, leading to a total runtime is O(n3). The correctness directly follows from the description of the algorithm (see comments above). (b) We say that a bitstring S′ is a (non-empty) prefix of a bitstring S if S′ is of the form S[0..i] where 0 ≤ i < length(S). For example, the prefixes of S = “0110” are “0”, “01”, “011” and “0110”. Given a n-bit bitstring S, we would like to compute a table T indexed by 0..n such that for all i, T [i] contains the number of prefixes of S with exactly i ones. 4 For example, for S = “0110”, the desired table is T = [1, 1, 2, 0, 0], since, of the 4 prefixes of S, 1 prefix contains zero “1”, 1 prefix contains one “1”, 2 prefixes contain two “1”, and 0 prefix contains three “1” or four “1”. Describe an algorithm prefixtable that computes T from S in time O(n), assuming S has size n. Solution: Algorithm 2 function prefixtable(S) T ← int[n + 1] ▷ Initialize array s ← 0 for i ← 0, . . . , n − 1 do ▷ Enumerate all prefixes S[0..i] s ← s + S[i] ▷ s saves the number of “1” in S[0..i] T [s] ← T [s] + 1 ▷ S[0..i] is a prefix with s “1” return T The for loop has n iterations, so the total runtime is O(n). The correctness directly follows from the description of the algorithm (see comments above). Remark: This algorithm can also be applied on a reversed bitstring to compute the same table for all suffixes of S. In the following, you can assume an algorithm suffixtable that does exactly this. (c) Let S be a n-bit bitstring. Consider an integer m ∈ {0, . . . , n − 2}, and divide the bitstring S into two substrings S[0..m] and S[m + 1..n − 1]. Using prefixtable and suffixtable, describe an algorithm spanning(m, k, S) that returns the number of substrings S[i..j] of S that have exactly k ones and such that i ≤ m < j. What is its complexity? For example, if S = “0110”, k = 2, and m = 0, there exist exactly two such strings: “011” and “0110”. Hence, spanning(m, k, S) = 2. Hint: Each substring S[i..j] with i ≤ m < j can be obtained by concatenating a string S[i..m] that is a suffix of S[0..m] and a string S[m + 1..j] that is a prefix of S[m + 1..n − 1]. Solution: Each substring S[i..j] with i ≤ m < j is obtained by concatenating a string S[i..m] that is a suffix of S[0..m] and a string S[m + 1..j] that is a prefix of S[m + 1..n − 1], such that the numbers of “1” in S[i..m] and S[m + 1..j] sum up to k. Moreover, from each S[i..m] that contains p ≤ k ones, we can build as many different sequences S[i..j] with k ones as there are substrings S[m + 1..j] with k − p ones. We obtain the following algorithm: Algorithm 3 function spanning(m, k, S) T1 ← suffixtable(S[0..m]) T2 ← prefixtable(S[m + 1..n − 1]) return ∑min(k,m+1) p=max(0,k−(n−m−1))(T1[p] · T2[k − p]) The complexity of this algorithm is O(n). (d)* Using spanning, design an algorithm with a runtime1 of at most O(n log n) that counts the number 1For this running time bound, we let n range over natural numbers that are at least 2 so that n log(n) > 0. 5 of nonempty substrings of a n-bit bitstring S with exactly k ones. (You can assume that n is a power of two.) Hint: Use the recursive idea from the lecture. Solution: Whenever n ≥ 2, we can distinguish between: • Substrings with k ones located entirely in the first half of the bitstring, which we compute recursively; • Substrings with k ones located entirely in the second half of the bitstring, which we also compute recursively; • Substrings with k ones that span the two halves, which we can count using (c). We obtain the following algorithm: Algorithm 4 Clever substring counting function countsubstr(S, k, i = 0, j = n − 1) if i = j then if k = 1 and S[i] = 1 then return 1 else if k = 0 and S[i] = 0 then return 1 else return 0 else m ← ⌊(i + j)/2⌋ return countsubstr(S, k, i, m) + countsubstr(S, k, m + 1, j) + spanning(m, k, S) The complexity of this algorithm is given by a recursive expression of the form A(n) = 2A( n 2 ) + O(n), which, as in the lecture, yields a total complexity of O(n log n). Exercise 3.3 Counting function calls in loops (1 point). For each of the following code snippets, compute the number of calls to f as a function of n ∈ N. Provide both the exact number of calls and a maximally simplified asymptotic bound in Θ notation. Algorithm 5 (a) i ← 0 while i ≤ n do f () f () i ← i + 1 j ← 0 while j ≤ 2n do f () j ← j + 1 6 Solution: This algorithm performs ∑n i=0 2 + ∑2n j=0 1 = 2(n + 1) + (2n + 1) = 4n + 3 = Θ(n) calls to f . Algorithm 6 (b) i ← 1 while i ≤ n do j ← 1 while j ≤ i3 do f () j ← j + 1 i ← i + 1 Hint: See Exercise 1.4. Solution: This algorithm performs ∑n i=1 i3 = n2(n+1)2 4 = Θ(n4) calls to f . Exercise 3.4 Fibonacci numbers. There are a lot of neat properties of the Fibonacci numbers that can be proved by induction. Recall that the Fibonacci numbers are defined by f0 = 0, f1 = 1 and the recursion relation fn+1 = fn + fn−1 for all n ≥ 1. For example, f2 = 1, f5 = 5, f10 = 55, f15 = 610. (a) Prove that fn ≥ 1 3 · 1.5n for n ≥ 1. Solution: • Base Case. We prove that the inequality holds for n = 1 and n = 2. For n = 1: f1 = 1 ≥ 0.5 = 1 3 · 1.5, which is true. For n = 2: f2 = 1 ≥ 0.75 = 1 3 · 1.52, which is true. • Induction Hypothesis. We assume that it is true for n = k and n = k + 1, i.e., fk ≥ 1 3 1.5 k fk+1 ≥ 1 3 1.5 k+1 7 • Inductive Step. We must show that the property holds for n = k + 2, k ≥ 1. We have: fk+2 = fk+1 + fk ≥ 1 3 1.5 k+1 + 1 3 1.5 k = 1 3 1.5 k · (1.5 + 1) = 1 3 1.5 k · 2.5 ≥ 1 3 1.5 k · 2.25 = 1 3 1.5 k · 1.5 2 = 1 3 1.5 k+2 By the principle of mathematical induction, this is true for every integer n ≥ 1. Remark: In a similar way to the proof above, one can also show that fn+1 ≤ 1.75n for n ≥ 0. (b) Write an O(n) algorithm that computes the nth Fibonacci number fn for n ∈ N. Remark: As shown in part (a), fn grows exponentially (e.g., at least as fast as Ω(1.5n)). On a physical computer, working with these numbers often causes overflow issues as they exceed variables’ value limits. However, for this exercise, you can freely ignore any such issue and assume we can safely do arithmetic on these numbers. Solution: Algorithm 7 F ← int[n + 1] F [0] ← 0 F [1] ← 1 for i ← 2, . . . , n do F [i] ← F [i − 2] + F [i − 1] return F [n] At the end of iteration i of this algorithm, we have F [j] = fj for all 0 ≤ j ≤ i. Hence, at the end of the last iteration, F [n] contains fn. Each of the n iterations has complexity O(1), yielding a total complexity in O(n). (c) Given an integer k ≥ 2, design an algorithm that computes the largest Fibonacci number fn such that fn ≤ k. The algorithm should have complexity O(log k). Prove this. Remark: Typically we express runtime in terms of the size of the input n. In this exercise, the runtime will be expressed in terms of the input value k. Hint: Use the bound proved in part (a). Solution: Consider the following algorithm, where we can just assume for now that K is ‘large enough’ so that no access outside of the valid index range of the array is performed. 8 Algorithm 8 F ← int[K] F [0] ← 0 F [1] ← 1 i = 1 while F [i] ≤ k do i ← i + 1 F [i] ← F [i − 2] + F [i − 1] return F [i − 1] After the ith iteration, we have F [j] = fj for all 0 ≤ j ≤ i. The loop exists when the condition F [i] = fi > k is satisfied for the first time, and, in this case, F [i − 1] = fi−1 is the largest Fibonacci number smaller or equal to k. Using part (a), we have k ≥ fi ≥ 1 3 ·1.5i. We can rewrite k ≥ 1 3 ·1.5i as i ≤ log1.5(3k) = ln 3+ln k ln 1.5 ≤ 3(2 + ln k) = O(log k). Note that ln x denotes the natural logarithm; we do not need to specify the base of the logarithm within O-notation since different bases are equivalent up to constants (and get hidden in the O-notation). Therefore, the inner while loop can only execute O(log k) iterations. We can choose K = 3(2 + ln k). Since every iteration of the while-loop has complexity O(1), we get an overall complexity of O(log k). Exercise 3.5 Iterative squaring. In this exercise you are going to develop an algorithm to compute powers an, with a ∈ Z and n ∈ N, efficiently. For this exercise, we will treat multiplication of two integers as a single elementary operation, i.e., for a, b ∈ Z you can compute a · b using one operation. (a) Assume that n is even, and that you already know an algorithm An/2(a) that efficiently computes an/2, i.e., An/2(a) = an/2. Given the algorithm An/2, design an efficient algorithm An(a) that computes an. Solution: Algorithm 9 An(a) x ← An/2(a) return x · x (b) Let n = 2k, for k ∈ N0. Find an algorithm that computes an efficiently. Describe your algorithm using pseudo-code. Solution: Algorithm 10 Power(a, n) if n = 1 then return a else x ← Power(a, n/2) return x · x 9 (c) Determine the number of elementary operations (i.e., integer multiplications) required by your algorithm for part b) in O-notation. You may assume that bookkeeping operations don’t cost any- thing. This includes handling of counters, computing n/2 from n, etc. Solution: Let T (n) be the number of elementary operations that the algorithm from part b) performs on input a, n. Then T (n) ≤ T (n/2) + 1 ≤ T (n/4) + 2 ≤ T (n/8) + 3 ≤ . . . ≤ T (1) + log2 n ≤ O(log n) .2 (d) Let Power(a, n) denote your algorithm for the computation of an from part b). Prove the correctness of your algorithm via mathematical induction for all n ∈ N that are powers of two. In other words: show that Power(a, n) = an for all n ∈ N of the form n = 2k for some k ∈ N0. Solution: • Base Case. Let k = 0. Then n = 1 and Power(a, n) = a = a1. • Induction Hypothesis. Assume that the property holds for some positive integer k. That is, Power(a, 2k) = a2k . • Inductive Step. We must show that the property holds for k + 1. Power(a, 2k+1) = Power(a, 2k) · Power(a, 2k) I.H. = a2k · a 2k = a2k+1. By the principle of mathematical induction, this is true for any integer k ≥ 0 and n = 2k. (e)* Design an algorithm that can compute an for a general n ∈ N, i.e., n does not need to be a power of two. Hint: Generalize the idea from part (a) to the case where n is odd, i.e., there exists k ∈ N such that n = 2k + 1. Solution: Algorithm 11 Power(a, n) if n = 1 then return a else if n is odd then x ← Power(a, (n − 1)/2) return x · x · a else x ← Power(a, n/2) return x · x 2For this asymptotic bound, we let n range over natural numbers that are at least 2 so that log(n) > 0. 10","libVersion":"0.3.2","langs":""}