{"path":"sem2/PProg/VRL/extra/kuhn/PProg-w13-kuhn.pdf","text":"Parallel Programming Session 13 Spring 2024, Sarah Kuhn Schedule Post-Discussion Assignment 12 Plan for next week ? Theory Recap Pre-Discussion Assignment 13 Kahoot Next week big Kahoot in the 2nd hour on Friday. Wednesday we will do it in the small class (probably) Next week big Kahoot in the 2nd hour on Friday. HG e3 Wednesday we will do it in the small class (probably) I will choose some topics to cover in the first hour, are there any wishes ? send me an email ! Next week big Kahoot in the 2nd hour on Friday. Wednesday we will do it in the small class (probably) I will choose some topics to cover in the first hour, are there any wishes ? send me an email ! Do you guys wanna solve an exam ? Some exam task together from 2019/2020 ? Post-Discussion Ex.12 Sensor DataExercise 12 Solve a task using blocking and non-blocking algorithms Refresher with locks, thread can delay/bock all other threads without locks, Refresher with locks, thread can delay/bock all other threads without locks, Refresher with locks, thread can delay/bock all other threads without locks, Implications Wait-free -> Lock-free ? Wait-free -> starvation-free ? Starvation-free -> deadlock-free ? Lock-free -> deadlock-free ? How many hold? Which ones do not hold ? Implications Wait-free -> Lock-free ? Wait-free -> starvation-free ? Starvation-free -> deadlock-free ? Lock-free -> deadlock-free ? All hold J Multisensor-SystemMultisensor-System Implement the class once using RW Locks-> blocking non-blocking -> CAS Locked Sensors As always: Locked Sensors As always: 1.) add the fields, create the lock instance Fields: references to RW locks Locked Sensors As always: 1.) add the fields, create the lock instance Fields: references to RW locks Constructor: create Java RW Lock Locked Sensors As always: 1.) add the fields, create the lock instance Fields: references to RW locks Constructor: create Java RW Lock Extract the reader and the writer lock Locked Sensors As always: 2.) get-method() -> add the calls to lock Locked Sensors As always: 3.) update-method Lock ImplementationLock ImplementationLock ImplementationLock ImplementationLock ImplementationLock Implementation Volatile/ not ? Lock ImplementationLock ImplementationLock-free idea Atomically move the pointer reference as we cannot CAS multiple fields at once Lock-free idea Atomically move the pointer reference as we cannot CAS multiple fields at once new object () Lock-free atomic reference on the pointer Lock-free create new data object &prepare it CAS the pointer ! Lock-free create new data object &prepare it CAS the pointer ! Lock-free create new data object &prepare it CAS the pointer ! Questions ?Exam…Exam… ???? Exam… ???? SPINLOCK Take Away Don’t get biased just because you see CAS or TAS Always check: is there a… use of lock “implicit” (CAS/TAS lock implementation) or “explicit” ( external locks) Exam QuestionExam Question Theory Recap Orientation We saw: Threads& Locks how to build locks -> N-thread locks, Semaphores, Barriers different synchronization strategies -> parallel data structures non-blocking algorithms Orientation We saw: Threads& Locks how to build locks -> N-thread locks, Semaphores, Barriers different synchronization strategies -> parallel data structures non-blocking algorithms NOW: formally define a correct parallel execution notions of correctness Approach Safety & liveness: correctness (now) & progress (last week) Approach Safety & liveness: correctness (now) & progress (last week) with locks its easier -> holds lock -> execute on after another -> sequential Map it to sequential Intuition: Correct if we can map it to a sequential execution Approach Safety & liveness: correctness (now) & progress (last week) with locks its easier -> holds lock -> execute on after another -> sequential But how do we do it with CAS, TAS etc? Approach Safety & liveness: correctness (now) & progress (last week) with locks its easier -> holds lock -> execute on after another -> sequential Correctness is based on correctness in a sequential world . How is it in a sequential world? Program correctness in a sequential world Objects encapsulate some representation of state Program correctness in a sequential world Objects encapsulate some representation of state • We don’t reason about the representation directly, but about its visibility from outside (via public methods) (e.g. stack.top()==3) Program correctness in a sequential world Objects encapsulate some representation of state • We don’t reason about the representation directly, but about its visibility from outside (via public methods) (e.g. stack.top()==3) • State must be consistent, i.e., according to the public class invariant (e.g., forall x. stack.push(x).pop()==x) Program correctness in a sequential world Objects encapsulate some representation of state • We don’t reason about the representation directly, but about its visibility from outside (via public methods) (e.g. stack.top()==3) • State must be consistent, i.e., according to the public class invariant (e.g., forall x. stack.push(x).pop()==x) • Each method satisfies its post-condition, given its pre-condition Program correctness in a sequential worldProgram correctness in a sequential world What about the parallel world ? Program correctness in a concurrent worldProgram correctness in a concurrent worldProgram correctness in a concurrent worldIn a concurrent world ? Now we look at a lot of formal definitions In a concurrent world ? Now we look at a lot of formal definitions keep in mind the ”goal”: Look at certain executions and reason if they correspond to a “ correct parallel execution” -> similar as in JMM In a concurrent world ? Now we look at a lot of formal definitions keep in mind the ”goal”: Look at certain executions and reason if they correspond to a “ correct parallel execution” -> similar as in JMM principle: can we somehow map the concurrent executions to sequential ones In a concurrent world ? Now we look at a lot of formal definitions keep in mind the ”goal”: Look at certain executions and reason if they correspond to a “ correct parallel execution” -> similar as in JMM principle: can we somehow map the concurrent executions to sequential ones How much freedom do we have for the mapping = difference between these definitions Method CallExecutionExecutionNotationDefinition 1 can involve multiple threads Method call = invocation + response Definition 1 can involve multiple threads Method call = invocation + response How do we call… invocation without response/ no matching response : Definition 1 can involve multiple threads Method call = invocation + response How do we call… invocation without response/ no matching response : pending Definition 1 can involve multiple threads Method call = invocation + response How do we call… invocation without response/ no matching response : pending History = finite sequence of invocation and responses Sub history = subsequence of invocation and responses Definition 1 can involve multiple threads Method call = invocation + response How do we call… invocation without response/ no matching response : pending History = finite sequence of invocation and responses Sub history = subsequence of invocation and responses Is it still a history if not every invocation has a response ? Definition 2 Complete ( H ) ? Definition 2 Complete ( H ) ? subsequence with all matching response and invocations Longest SequenceDefinition 2 Complete ( H ) ? subsequence with all matching response and invocations sequential history ? Definition 2 Complete ( H ) ? subsequence with all matching response and invocations sequential history ? after every invocation follows directly a response à NO overlapping method calls “one after another” Exampel finally pending is ok Definition 2 Complete ( H ) ? subsequence with all matching response and invocations sequential history ? after every invocation follows directly a response (finally pending is ok) à NO overlapping method calls Proceed: m0 à m1 iff m0 finishes before m1 start ProjectionsProjections “All actions in Thread H on object q/ by thread B” Equivalence?Equivalence? Histories H1 and H2 are equivalent if their per-thread projections are the same. EquivalenceEquivalence Does someone see a case where this is useful ? When would we check this ? Example TO DO A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 What can we say? How do we approach such problems ? History ? Complete ? Sequential ? Example A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 What can we say? How do we approach such problems ? History ? Yes Example A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 What can we say? How do we approach such problems ? History ? Yes Complete H ? Yes Example A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 What can we say? How do we approach such problems ? History ? Yes Complete H ? Yes Sequential H ? No, overlap But what would be sequential here ? Example A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 What can we say? How do we approach such problems ? History ? Yes Complete H ? Yes Sequential H ? No, overlap But what would be sequential here ? Per thread projection Different histories: legalDifferent histories: legal Legal: sequential specification tells us Sequential specification f.Eg Java documentation -> tells us what a method does in every state Pre-/Postcondition Really powerful: doc linear in number of methods “intuition: if the things happened in correct order f.eg pop won’t return anything before I pushed” Different histories: well-formed Well-formed history per thread projection is sequential Different histories: well-formed Well-formed history per thread projection is sequential If sequential also well-formed? Different histories Well-formed history per thread projection is sequential Now: review examples of concurrent computations Now: review examples of concurrent computations Decide whether the behavior agrees with our intuition about how a concurrent object should behave. Now: review examples of concurrent computations Decide whether the behavior agrees with our intuition about how a concurrent object should behave. Look the different principles (different strength) Now: review examples of concurrent computations Decide whether the behavior agrees with our intuition about how a concurrent object should behave. Look the different principles (different strength) Always keep in mind: should implement such a guarantee, should hardware guarantee it ? Sequential Consistency 2 requirements: Sequential Consistency 2 requirements: every thread sub-history is a sequential history ”inside a thread a method only starts if the one before has finished” “no overlapping calls inside a thread” Sequential Consistency 2 requirements: every thread sub-history is a sequential history ”inside a thread a method only starts if the one before has finished” “no overlapping calls inside a thread” method calls should appear in program order (PO -> intra-thread) &meet objects specification Sequential Consistency order the method calls sequentially such that they 1.) respect PO -> only says something intra-thread Sequential Consistency order the method calls sequentially such that they 1.) respect PO -> only says something intra-thread 2.) meet object specification Exampel Stack: A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 What can we say? How do we approach such problems ? History ? yes Complete ? Yes Sequential ? Nop overlap Sequential consistent ? Sequential Sub-histories ? Stack: A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 H | A and H | B Projections Sequential Sub-histories ? Stack: A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 H | A and H | B A : s.push(2) A: void A: s.pop() A: 2 Sequential Sub-histories ? Stack: A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 H | A and H | B A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 PO + Meets object specification ? Stack: A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 H | A and H | B A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 Can you arrange them such that it behaves like a stack ? PO + Meets object specification ? Stack: A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 H | A and H | B s.push(1) -> s.push(2) -> s.pop()2 -> s.pop()1 PO + Meets object specification ? Stack: A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 H | A and H | B s.push(1) -> s.push(2) -> s.pop()2 -> s.pop()1 2nd version ? PO + Meets object specification ? Stack: A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 H | A and H | B s.push(1) -> s.push(2) -> s.pop()2 -> s.pop()1 2nd version ? s.push(2) -> s.push(1) -> s.pop()1 -> s.pop()2 Both respect thread sub-history + definition of stack ! Exampel Stack: A : s.push(2) B: s.push(1) A: void B: void A: s.pop() B: s.pop() A: 2 B: 1 What can we say? How do we approach such problems ? History ? yes Complete ? Yes Sequential ? Nop overlap Sequential consistent ? Yes NOT UNIQUE Sequential Consistency Good but good enough ? What kind of freedom do we still have ? Sequential Consistency Good but good enough ? What kind of freedom do we still have ? we check: PO & meets object specification BUT we lose the notion of “timing” & relation to other threads Example: «no inter-thread order» Sequential consistency only looks at the order intra-thread and not inter-thread ! Sequential Consistency Good but good enough ? What kind of freedom do we still have ? we check: PO & meets object specification BUT we lose the notion of “timing” & relation to other threads Not composable Seq. Consistent Not composable ! Seq. Consistent Not composable ! forms a cycle ! LinearizabilityLinearizability Replace PO requirement with a stronger one ! method has to take effect between real-time invocation& response Linearizability Replace PO requirement with a stronger one ! method has to take effect between real-time invocation& response Not this: Consistency model: Linearizability • Linearizability provides the illusion that each operation applied by concurrent processes takes effect instantaneously between its invocation and its response. Is this linearizable? q.enq(x) q.enq(y) q.deq() -> x q.deq() -> y Example with FIFO Queue (1) 134time Is this linearizable? q.enq(x) q.enq(y) q.deq() -> x time q.deq() -> y Yes! Example with FIFO Queue (1) 135 Is this linearizable? q.enq(x) q.deq() -> y q.enq(y) Example (2) 136time Is this linearizable? q.enq(x) q.deq() -> y time q.enq(y) No! Example (2) 137 Question Is it sequential consistent ?Is this linearizable? q.enq(x) q.enq(y) q.deq() -> y q.deq() -> x Example (3) time Is this linearizable? q.enq(x) q.enq(y) q.deq() -> y time q.deq() -> x Here we got multiple orders! Yes! Example (3) Example 4 Is this linearizable? Example 4 Is this linearizable? Example 4.5 Is this linearizable? Example 4.5 Is this linearizable? Linearizability “Can we associate it to a sequential behaviour respecting real execution time” Linearizability “Can we associate it to a sequential behaviour respecting real execution time” Linearizability Complete (H’ ) is equivalent to legal sequential history S If m0 -> m1 in H then also m0 -> m1 in S “Can we associate it to a sequential behaviour respecting real execution time” Linearizability Complete (H’ ) is equivalent to legal sequential history S If m0 -> m1 in H then also m0 -> m1 in S “Can we associate it to a sequential behaviour respecting real execution time” Linearizability Complete (H’ ) is equivalent to legal sequential history S If m0 -> m1 in H then also m0 -> m1 in S “Can we associate it to a sequential behaviour respecting real execution time” “Like sequential consistency without the moving between threads” ExamplesExampleExampleExampleLinearizability Theorem Linearizable if and only if for every object X H | X is linearizable. Linearizability Theorem Linearizable if and only if for every object X H | X is linearizable. What is H | X ? Linearizability Theorem Linearizable if and only if for every object X H | X is linearizable. What is H | X ? projection onto the object !! Linearizability Theorem Linearizable if and only if for every object X H | X is linearizable. What is H | X ? projection onto the object !! Implies composability: Can proof it for one object and then put it together Linearizability Theorem Linearizable if and only if for every object X H | X is linearizable. What is H | X ? projection onto the object !! Implies composability: Can proof it for one object and then put it together DON’T have that with sequential consistency Question Can someone give me a history that is linearizable but not sequential consistent ? Does it exist ? Is it unique ? Question Can someone give me a history that is linearizable but not sequential consistent ? Does it exist ? Is it unique ? History sequential consistent but not linearizable ? QuestionIntuition Sequential consistency: order between thread local events must be preserved + must ”make sense = specification” Intuition Sequential consistency: order between thread local events must be preserved + must ”make sense = specification” Linearizability: order between thread local events must be preserved +”make sense = specification” + order between events across threads must be preserved Intuition This means: when doing mapping seq. consistent -> can move around between threads linearizability -> cannot move around between threads Sequential consistency: order between thread local events must be preserved + must ”make sense = specification” Linearizability: order between thread local events must be preserved +”make sense = specification” + order between events across threads must be preserved IntuitionQuiescent Consistancy Your program should respect real-time order of algorithms separated by a period of quiescence. Quiescent Consistancy Your program should respect real-time order of algorithms separated by a period of quiescence. Non-overlapping methods take place in real-time order Quiescent Consistancy Your program should respect real-time order of algorithms separated by a period of quiescence. Non-overlapping methods take place in real-time order They all do something and we can’t say about order etc. but if we stop, It must look like it was sequential Question Does quiescent consistency imply sequential consistency ? Approach Always think of their difference quiescent vs sequential consistent Can move inter-threads aka between threadsCan only move if overlapping but can move intra thread ! Approach Always think of their difference quiescent vs sequential consistent Can move inter-threads aka between threadsCan only move if overlapping but can move intra thread ! -> Find one that only works when we move inter-thread Approach Always think of their difference quiescent vs sequential consistent Can move inter-threads aka between threadsCan only move if overlapping but can move intra thread ! T1 T2 q.enq(x) q.enq(y) q.deq() -> y Approach T1 T2 q.enq(x) q.enq(y) q.deq() -> y Sequentially consistent (can move T1!) NOT quiescentially consistent : there is a quiescent period between these operations which should “synchronize” operations Approach Always think of their difference quiescent vs sequential consistent Can move inter-threads aka between threadsCan only move if overlapping but can move intra thread ! T1 T2 q.deq() -> y q.enq(z) q.enq(x) q.enq(y) Approach T1 T2 q.deq() -> y q.enq(z) q.enq(x) q.enq(y) NOT sequentially consistent (T1 has reordered operations) Quiescentially consistent (no quiescent period between these operations, all is good) Question What is this ? T1 T2 q.enq(x) q.enq(y) q.deq() -> y Question What is this ? T1 T2 q.enq(x) q.enq(y) q.deq() -> y Sequentially consistent (can move T1) Question What is this ? T1 T2 q.enq(x) q.enq(y) q.deq() -> y Sequentially consistent (can move T1) Quiescentially consistent (no quiescent period between these operations, can move T1) Question T1 q.deq() -> yq.enq(x) q.enq(y) And this ? Question T1 q.deq() -> yq.enq(x) q.enq(y) And this ? NOT sequentially consistent (T1 has reordered operations) NOT sequentially consistent (T1 has reordered operations) Exam Task Overall tip: I always check linearizability first, can I arrange it without reordering between threads. linearizable& thus sequential consistent If not, then check if it’s possible with reordering. sequential consistent Exam TaskExam TaskExam TaskExam TaskExam TaskExam TaskExam TaskExam TaskExam Task Sequential consistent ? Linearizable ? Exam TaskLet’s startLinearization Points Points/instructions in your code where the effect of the method gets visible to other threads/outside Linearization Points Points/instructions in your code where the effect of the method gets visible to other threads/outside Method takes effect -> may the others see what happened during this method Is the point unique ? Is it the same for every execution ? Linearization Points Points/instructions in your code where the effect of the method gets visible to other threads/outside Method takes effect -> may the others see what happened during this method Is the point unique ? Is it the same for every execution ? Linearization Points “where does the method take effect & where does this effect influence the behaviour of the others”“ Points/instructions in your code where the effect of the method gets visible to other threads/outside Method takes effect -> may the others see what happened during this method Is the point unique ? Is it the same for every execution ? Linearization Points Where is/are the linearization point(s) ? Linearization Points The linearization point is the point where the method takes effect. Linearization Points Where is/are the linearization point(s) ? Linearization Points Where is/are the linearization point(s) ? Method takes effect Linearization Points Where is/are the linearization point(s) ? Where does my updated variable effect Influence behaviour of other threads/decision Linearization Points Think of it as : every execution can have various outcomes dependent on whether empty or not etc. Linearization Points Think of it as : every execution can have various outcomes dependent on whether empty or not etc. every method call at the end will have one linearization point Linearization Points Think of it as : every execution can have various outcomes dependent on whether empty or not etc. every method call at the end will have one linearization point but because we do not know how the execution will be we mark all possible points. Linearization Points Where is/are the linearization point(s) ? Where does my updated variable effect Influence behaviour of other threads/decision Linearization PointsLinearization PointsLinearization PointsLinearization Points Mostly its atomics + where their variable effect our decision Pre-Discussion Ex.13 Pen& PaperPen& Paper reason if its sequential consistent or not Pen& Paper Given an examples, decide if sequential consistent and/or linearizable Give an example of equivalent histories etc. Overall rather short exercise sheet this week: I recommend it as such task often appeared in old exams. Personal exam tip: make sure you can easily come up with an example/ counterexample Let’s start See you next week J","libVersion":"0.3.2","langs":""}