{"path":"sem4/FMFP/UE/e/FMFP-u14-e.pdf","text":"P. M¨uller, D. Basin and R. Jung Formal Methods and Functional Programming Exercise Sheet 14: LTL and Model Checking Submission deadline: June 3rd/4th, 2025 Assignment 1 (Dining Philosophers) This assginment is a conutination of Assignment 1 from Exercise Sheet 13. The problem of the dining philosophers illustrates common issues for concurrent programs: We consider n philosophers sitting around a circular table. Each philosopher spends their life thinking and eating. In the center of the table is a large platter of spaghetti. Because the spaghetti are long and tangled a philosopher must use two forks to eat them. Since the philosophers can only afford n forks, a single fork is placed between each pair of philosophers, which they have to share. Each philosopher can only reach the forks to their immediate left and right with their left or right hand, respectively. Note: For this exercise, you may not submit handwritten models. Only Promela files will be ac- cepted. While model checking you may use the fairness flag -f, but, if you do, be sure to mention it in your solution. The fairness flag causes spin to only explore traces which schedule the individ- ual processes in a weakly-fair manner; in particular, it cannot be the case that a process that is continually enabled (could make another step) is never scheduled. In the GUIs, this can be chosen by choosing “With Weak Fairness” in the Verification Options. Task 1.1. See Task 1.1 from Exercise Sheet 13. Task 1.2. See Task 1.2 from Exercise Sheet 13. 1 Task 1.3. Check whether your solution to Task 1.2 is starvation free, i.e., whether there are no paths in which a philosopher never eats. You must modify the model accordingly, add an LTL formula, and model-check it with Spin. Note: To model check a Promela file against an LTL formula f with Spin, you may express the LTL formula in an LTL block in the file (ltl {f }). The LTL formula is expressed us- ing: • [] <> ! && || -> U for operators □ ♢ ¬ ∧ ∨ ⇒ U resp. • The equality operator as a primitive propositional formula. For example, to express p, one should write (p==true). Spin should be executed (if running from the command-line) with the analysis option -a. Further- more, the final executable must also be executed with the -a option. For example: spin -a file.pml gcc -o ts.exe pan.c ./ts.exe -a In the GUIs (e.g. xspin), you can achieve the same thing by choosing (in Verification Parameters) Liveness, acceptance cycles and “Apply Never Claim”/”use claim” (ignore the warnings in xspin - these are because the gui doesn’t understand the ltl block syntax (but the underlying version of spin does)). Task 1.4. Modify the solution to make it starvation free. Model-check the new model with your old LTL formula. You may introduce any restrictions you find appropriate to the behaviour of the philosophers. Note: This exercise is a bit more involved. Assignment 2 (Linear Temporal Logic) Consider the transition system T over the set of atomic propositions P = {p, q, r}: s 1 s 3 s 4 s 2 s 5 { }q, r { }p, q, r { } { }rp { }q 2 That is, T is the transition system (Γ, s1, →, L) with Γ = {s1, s2, s3, s4, s5} → = {(s1, s3), (s1, s4), (s2, s4), (s3, s4), (s4, s2), (s4, s3), (s4, s5), (s5, s4), (s5, s5) } L(si) =    {p} if i = 1 {r} if i = 2 {q, r} if i = 3 {q} if i = 4 {p, q, r} if i = 5. Task 2.1. Which of the following LTL formulas are satisfied in T , i.e., T |= φi? φ1 = ♢ □ r φ2 = □ ♢ r φ3 = ⃝¬r ⇒ ⃝ ⃝ r φ4 = □ p φ5 = p U □ (q ∨ r) φ6 = (⃝ ⃝ q) U (q ∨ r) φ7 = ♢ □ ⃝ q φ8 = (♢ □p) ⇒ (♢ □r) Justify your answer. If T ̸|= φi, provide a computation γ of T such that for the corresponding trace t, t ̸|= φi. Task 2.2. Formalize the following properties in LTL: i. Eventually, it will not be possible for the system to go to state s1. ii. Whenever the system is in a state that satisfies r, then the next state satisfies q. iii. p always implies r except perhaps in the initial state. iv. Whenever the system is in state s5, it will remain there until r becomes false. v. q will be true at least twice. vi. q will be true infinitely often. vii. If p is true only at the initial state of a trace, then r is false infinitely many times in that trace. viii. s4 can never be repeated (there is no transition from s4 to itself). 3 Task 2.3. A Promela model for the transition system above is given in ts.pml. Use Spin to model-check all the properties φi that do not contain the ⃝ operator. Inspect ts.pml and answer the following question: Why are atomic statements used? Assignment 3 (Liveness and Safety Properties) Task 3.1. Let A be a set of atomic propositions. Prove that a property is both a safety and liveness property if and only if it is equal to P(A)ω. Task 3.2. Is ∅ a safety property, a liveness property, both, or neither? Task 3.3. Is pUq a safety property, a liveness property, both, or neither? 4","libVersion":"0.5.0","langs":""}