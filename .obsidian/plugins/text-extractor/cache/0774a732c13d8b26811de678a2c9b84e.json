{"path":"var/export/TI-bf-u08.pdf","text":"Basil Feitknecht, 23-922-099, Camil Schmid, 23-944-234, Dennis Küenzi, 21-559-315 22 Prove that the language below is not recursive by providing an explicit mapping reduction and proving its correctness. Let |M(x)|q denote the number of times a TM M reaches the state q during the computation on x. Lreach = {Kod(M)#0i ∣ i ∈ N, |QM | > i, ∃x ∈ Σ∗ M : |M(x)|qi ≥ 1} To prove is that Lreach ∉ LR. To do so, let's construct an explicit reduction LH ≤ EE Lreach. Let A be an algorithm, i.e. TM that always halts which decides Lreach. Then we construct a TM B that, given A decides LH. For some input x ∈ {0, 1, #}∗ a preprocessing TM C decides if it isn't of the right form, i.e. if x ∉ KodTM ⋅ {#} ⋅ Σ∗ B, B rejects immediately. Else it holds that x = Kod(M)#w, for some w ∈ Σ∗ B. Then C constructs a TM M ′ that simulates M(w) with the modiﬁcation that any state that transitions to the rejecting state, instead goes to the accepting state. Additionally, C deﬁnes i as the index of the accepting state in M ′ and passes y = Kod(M ′)#0i to the algorithm A. It's evident that C always halts, since we only check an input and modify a given TM. Proof of correctness. Let's show that the following holds. x ∈ LH ⟺ B(x) ∈ Lreach First, let's cover the forward implication. Assume x = Kod(M)#w ∈ LH, then M halts on w by deﬁnition 5.6. Per construction, M ′ transitions to the state i-th state qi = q✓ which is the accepting state. Thus B(x) ∈ Lreach. Secondly, let's cover the backwards implication. Assume B(x) ∈ Lreach, where x = Kod(M)#w. Then the i-th state of M ′ is reached. By construction this happens only if M halts on w. Thus we have x ∈ LH. Hence, B always halts and accepts if and only x ∈ LH, otherwise it rejects. □ 23 We consider an alphabet Σ and the following language. Show that it is not recursive by applying rice's theorem. Lall = {Kod(M) ∣ L(M) = Σ∗} First, we show that the language Lall is a semantically non-trivial decision problem about TMs. We prove this by showing it fulﬁlls the requirements (i) − (iii) of deﬁnition 5.7. Hence we have shown that Lall is a semantically non-trivial decision problem about TMs. By theorem 5.9 (rice's theorem) this proves that Lall is undecidable and thus not recursive, i.e. Lall ∉ LR. A formal proof is given below. Since M∅ ∉ Lall, with L(M∅) = ∅ we construct a TM S that realizes the reduction LH,λ ≤ EE Lall. By lemma 5.8 we have LH,λ ∉ LR. Per non-triviality of Lall, let ˜M be a TM such that Kod(˜M) ∈ Lall, which exists per deﬁnition 5.7. Then for an input x ∈ Σ∗ B the TM S ﬁrst checks if it's a valid encoding of a TM. If this isn't the case, i.e. x ∉ KodTM, it outputs S(x) = Kod(M∅). Otherwise, x = Kod(M) ∈ KodTM and we have S(x) = Kod(A), where A is deﬁned as follows. The input alphabet of A is equal to that of ˜M, speciﬁcally ΣA = Σ ˜M . For an arbitrary input word y ∈ Σ∗ ˜M , the TM A then ﬁrst simulates M on the empty word λ, without overwriting the input y. Then A simulates ˜M on the word y. Thus S accepts y if and only if ˜M accepts y. We prove the correctness, below. x ∈ LH,λ ⟺ S(x) ∈ Lall First, let's prove the forward implication, i.e. the \"if\". Assume x ∈ LH,λ. Then we show that S(x) ∈ Lall. Per assumption, the TM M encoded in x halts on λ, hence A will simulate ˜M on y which means L(A) = L(˜M). Because Lall is a semantic decision problem, it then holds that Kod(˜M) ∈ Lall ⟹ Kod(A) ∈ Lall. Per deﬁnition of ˜M, the LHS is true and thus we have S(x) = Kod(A) ∈ Lall. Then, let's cover the \"only if\". Assume x ∉ LH,λ. Then we show that S(x) ∉ Lall. Contraposition results in the desired backward implication. Case distinction. If x ∉ KodTM is not a valid encoding of a TM, per deﬁnition S(x) = Kod(M∅) ∉ Lall. Else, if x = Kod(M) ∈ KodTM is a valid encoding of a TM, per assumption it doesn't halt on λ and so A never halts. Thus L(A) = L(M∅). By semantic properties and the fact that Kod(M∅) ∉ Lall it follows that S(x) = Kod(A) ∉ Lall. Thus we have proven the correctness of our reduction which directly implies that the language is not recursive, i.e. Lall ∉ LR. □ (i) Lall ≠ ∅ We need to show that the language is not the empty set. Consider a TM M1 such that any state q ∈ QM1 transitions to the accepting state q✓ on all input. Thus L(M1) = Σ∗ ⟹ Kod(M1) ∈ Lall. (ii) Lall ≠ KodTM The language cannot contain every TM encoding. Consider the TM M2 that never accepts, i.e. every state q ∈ QM2 transitions to the rejecting state qx on all inputs. Thus we have L(M2) = ∅ ≠ Σ∗ ⟹ Kod(M2) ∉ Lall. (iii) L(A) = L(B) : Kod(A) ∈ Lall ⟺ Kod(B) ∈ Lall for two TMs A, B Two TMs accepting the same language implies that their encodings are either both elements of Lall or both aren't. To prove this, we assume there are two TMs A, B such that L(A) = L(B), however, one's encoding is in Lall while the other's isn't. Then we show that this leads to a contradiction. Let L(A) = L(B) ⊆ Σ∗. Then, without loss of generality, let Kod(A) ∈ Lall. Per deﬁnition of Lall this means L(A) = Σ∗. Since we assume L(A) = L(B), this implies Kod(B) ∈ Lall. But by assumption we have Kod(B) ∉ Lall. Contradiction. Thus, for two TMs, A, B with L(A) = L(B) we have Kod(A) ∈ Lall ⟺ Kod(B) ∈ Lall. 24 Let M be a 1-tape TM that always halts. Prove that there exists an equivalent 2-tape TM A such that the following holds for some constant c and for all n. We deﬁne the 2-tape TM A as follows. This can be understood as one symbol of a larger alphabet ΓA. Then the ﬁrst working tape has ⌈ n 12 ⌉ entries. Writing these takes n + 1 computation steps. Then A returns to the starting entry, which takes ⌈ n 12 ⌉ steps. The number of steps taken so far is given below. n + 1 + ⌈ n 12 ⌉ = 1 + ⌈ 13n 12 ⌉ ≤ 2 + 13n 12 Now we use the ﬁrst working tape as modiﬁed input tape. The second working tape is used as actual working tape over the working alphabet of 12-tuples. Then, in every step A computes the following. Every computation step in A takes 4 + 2 = 6 elementary steps. In the original TM M this corresponds to twelve steps. Thus the time taken for the simulation is given as follows. 6 ⋅ ⌈ TimeM (n) 12 ⌉ ≤ TimeM (n) 2 + 6 Hence the inequality to show holds. TimeA(n) ≤ TimeM (n) 2 + 6 + 2 + 13n 2 = TimeM (n) 2 + 13n 2 + c □ TimeA(n) ≤ TimeA(n) 2 + 13n 12 + c Its input tape is identical to that of M. Every step, A reads 12 entries of the input tape and writes it on its ﬁrst working tape as 12-tuple. The TM A stores the 3 ⋅ 12 = 36 entries of the current entry, the one left to it and the one to its right. To do this, we take one step right, then one to the left and ﬁnally one to the right again. This takes four steps. Every 12 steps in M can at most aﬀect 2 entries of A, since they must occur sequentially. According to these steps in M, the MTM A then modiﬁes the current entry and the one to its left (exclusive) or right. This includes moving the read/write head and in total takes two steps.","libVersion":"0.5.0","langs":""}