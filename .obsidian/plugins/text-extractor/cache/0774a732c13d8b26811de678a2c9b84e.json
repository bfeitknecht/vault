{"path":"var/export/TI-bf-u08.pdf","text":"Basil Feitknecht, 23-922-099, Camil Schmid, 23-944-234, Dennis Küenzi, 21-559-315 22 Prove that the language below is not recursive by providing an explicit mapping reduction and proving its correctness. Lreach = {Kod(M)#0i ∣ i ∈ N, |QM | ≥ i + 1, ∃x ∈ Σ∗ M } 23 We consider an alphabet Σ and the following language. Show that it is not recursive by applying rice's theorem. Lall = {Kod(M) ∣ L(M) = Σ∗} First, we show that the language Lall is a semantically non-trivial decision problem about TMs. We prove this by showing it fulﬁlls the requirements (i) − (iii) of deﬁnition 5.7. Hence we have proven that Lall is a semantically non-trivial decision problem of TMs. Since M∅ ∉ Lall, with L(M∅) = ∅ we construct a TM S that realizes the reduction LH,λ ≤ EE Lall. Per non-triviality of Lall, let ˜M be a TM such that Kod(˜M) ∈ Lall, which exists per deﬁnition 5.7. Then for an input x ∈ Σ∗ B the TM S ﬁrst checks if it's a valid encoding of a TM. If this isn't the case, i.e. x ∉ KodTM, it outputs S(x) = Kod(M∅). Otherwise, x = Kod(M) ∈ KodTM and we have S(x) = Kod(A), where A is deﬁned as follows. The input alphabet of A is equal to that of ˜M, speciﬁcally ΣA = Σ ˜M . For an arbitrary input word y ∈ Σ∗ ˜M , the TM A then ﬁrst simulates M on the empty word λ, without overwriting the input y. Then A simulates ˜M on the word y. Thus S accepts y if and only if ˜M accepts y. We prove the correctness, below. x ∈ LH,λ ⟺ S(x) ∈ Lall First, let's prove the forward implication, i.e. the \"if\". Assume x ∈ LH,λ. Then we show that S(x) ∈ Lall. Per assumption, the TM M encoded in x halts on λ, hence A will simulate ˜M on y which means L(A) = L(˜M). Because Lall is a semantic decision problem, it then holds that Kod(˜M) ∈ Lall ⟹ Kod(A) ∈ Lall. Per deﬁnition of ˜M, the LHS is true and thus we have S(x) = Kod(A) ∈ Lall. Then, let's cover the \"only if\". Assume x ∉ LH,λ. Then we show that S(x) ∉ Lall. Contraposition results in the desired backward implication. Case distinction. If x ∉ KodTM is not a valid encoding of a TM, per deﬁnition S(x) = Kod(M∅) ∉ Lall. Else, if x = Kod(M) ∈ KodTM is a valid encoding of a TM, per assumption it doesn't halt on λ and so A never halts. Thus L(A) = L(M∅). By semantic properties and the fact that Kod(M∅) ∉ Lall it follows that S(x) = Kod(A) ∉ Lall. Thus we have proven the correctness of our reduction which directly implies that the language is not recursive, i.e. Lall ∉ LR. □ (i) Lall ≠ ∅ We need to show that the language is not the empty set. Consider a TM M1 such that any state q ∈ QM1 transitions to the accepting state q✓ on all input. Thus L(M1) = Σ∗ ⟹ Kod(M1) ∈ Lall. (ii) Lall ≠ KodTM The language cannot contain every TM encoding. Consider the TM M2 that never accepts, i.e. every state q ∈ QM2 transitions to the rejecting state qx on all inputs. Thus we have L(M2) = ∅ ≠ Σ∗ ⟹ Kod(M2) ∉ Lall. (iii) L(A) = L(B) : Kod(A) ∈ Lall ⟺ Kod(B) ∈ Lall for two TMs A, B Two TMs accepting the same language implies that their encodings are either both elements of Lall or both aren't. To prove this, we assume there are two TMs A, B such that L(A) = L(B), however, one's encoding is in Lall while the other's isn't. Then we show that this leads to a contradiction. Let L(A) = L(B) ⊆ Σ∗. Then, without loss of generality, let Kod(A) ∈ Lall. Per deﬁnition of Lall this means L(A) = Σ∗. Since we assume L(A) = L(B), this implies Kod(B) ∈ Lall. But by assumption we have Kod(B) ∉ Lall. Contradiction. Thus, for two TMs, A, B with L(A) = L(B) we have Kod(A) ∈ Lall ⟺ Kod(B) ∈ Lall. 24 Let M be a 1-tape TM that always halts. Prove that there exists an equivalent 2-tape TM A such that the following holds for some constant c and for all n. TimeA(n) ≤ TimeA(n) 2 + 13n 12 + c","libVersion":"0.3.2","langs":""}