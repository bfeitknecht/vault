{"path":"sem4/FMFP/UE/s/FMFP-u10-s.pdf","text":"P. M¨uller, D. Basin and R. Jung Formal Methods and Functional Programming Exercise Sheet 10: Big-Step Semantics Submission deadline: May 6th/7th, 2025 Assignment 1 (Applying Big-Step Semantics) Consider the following IMP statement s: while n # 0 do (a := a + n; b := b * n); n := n - 1 end Task. Let σ be a state such that σ(a) = 0, σ(b) = 1, and σ(n) = 2. Prove using the natural semantics that there is some state σ′ with σ′(a) = 3, σ′(b) = 2, and σ′(n) = 0 such that ⟨s, σ⟩ → σ′. Provide the complete derivation tree. Do not forget to explicitly write the names of the rules you apply at each derivation step. Solution. We use the following abbreviations: l is the statement (a := a+n; b := b*n); n := n-1 and w is the statement while n # 0 do l end. To save space, we also introduce the following abbreviation: The notation [v1, v2, v3], where v1, v2, v3 are integer values, stands for the state σ[a ↦→ v1][b ↦→ v2][n ↦→ v3], where σ is the initial state mentioned in the exercise. We construct the derivation tree shown in the following page. 1(AssNS)⟨a:=a+n,[0,1,2]⟩→[2,1,2](AssNS)⟨b:=b*n,[2,1,2]⟩→[2,2,2](SeqNS)⟨a:=a+n;b:=b*n,[0,1,2]⟩→[2,2,2](AssNS)⟨n:=n-1,[2,2,2]⟩→[2,2,1](SeqNS)⟨(a:=a+n;b:=b*n);n:=n-1,[0,1,2]⟩→[2,2,1]AAA\u0001\u0001\u0001T1⟨whilen#0dolend,[2,2,1]⟩→[3,2,0](WhTNS)⟨whilen#0dolend,[0,1,2]⟩→[3,2,0]whereT1isthefollowingderivationtree:(AssNS)⟨a:=a+n,[2,2,1]⟩→[3,2,1](AssNS)⟨b:=b*n,[3,2,1]⟩→[3,2,1](SeqNS)⟨a:=a+n;b:=b*n,[2,2,1]⟩→[3,2,1](AssNS)⟨n:=n-1,[3,2,1]⟩→[3,2,0](SeqNS)⟨(a:=a+n;b:=b*n);n:=n-1,[2,2,1]⟩→[3,2,0](WhFNS)⟨w,[3,2,0]⟩→[3,2,0](WhTNS)⟨whilen#0dolend,[2,2,1]⟩→[3,2,0] 2 Assignment 2 (Reversing Loop-Unrolling) Task. Prove the following statement: ∀σ, σ′, b, s · ( ⊢ ⟨if b then s; while b do s end else skip end, σ⟩ → σ′ =⇒ ⊢ ⟨while b do s end, σ⟩ → σ′) Note: In the lectures, you have seen the proof of this result in the other direction. Solution. The proof is direct, that is we do not need induction here. Let σ, σ′, b, s be arbitrary. To prove the implication, we assume ⊢ ⟨if b then s; while b do s end else skip end, σ⟩ → σ′ and we just need to prove ⊢ ⟨while b do s end, σ⟩ → σ′, which we will do by providing a suitable derivation tree. From our assumption, it follows that there is some derivation tree T such that root(T ) ≡ ⟨if b then s; while b do s end else skip end, σ⟩ → σ′. We consider two cases with respect to the last rule applied in the derivation tree T : • Case IfTNS: Then T has the form: A AAA \u0001 \u0001 \u0001\u0001 T ′ ⟨s; while b do s end, σ⟩ → σ′ (IfTNS) ⟨if b then s; while b do s end else skip end, σ⟩ → σ′ for some derivation tree T ′. From the side condition we learn B[[b]]σ = tt. In the sub- derivation T ′, the last rule applied must be the rule for sequential composition. Thus, we learn further that T has the form: A A AA \u0001 \u0001 \u0001\u0001 T1 ⟨s, σ⟩ → σ′′ AA AA \u0001 \u0001 \u0001\u0001 T2 ⟨while b do s end, σ′′⟩ → σ′ (SeqNS) ⟨s; while b do s end, σ⟩ → σ′ (IfTNS) ⟨if b then s; while b do s end else skip end, σ⟩ → σ′ for some derivation trees T1, T2 and state σ′′. Using this information, including the fact that B[[b]]σ = tt, we can construct the following derivation tree (with the desired root): AA AA \u0001 \u0001 \u0001\u0001 T1 ⟨s, σ⟩ → σ′′ A AAA \u0001 \u0001 \u0001\u0001 T2 ⟨while b do s end, σ′′⟩ → σ′ (WhTNS) ⟨while b do s end, σ⟩ → σ′ 3 • Case IfFNS: Then T has the form: A AAA \u0001 \u0001 \u0001\u0001 T ′ ⟨skip, σ⟩ → σ′ (IfFNS) ⟨if b then s; while b do s end else skip end, σ⟩ → σ′ for some derivation tree T ′. From the side condition we learn B[[b]]σ = ff . Since the last rule applied in T ′ must be SkipNS, we conclude that in fact σ = σ′. Thus the following derivation tree actually has the desired root: (WhFNS) ⟨while b do s end, σ⟩ → σ Assignment 3 (Execution only Affects Free Variables) Task. Prove that ∀s, σ, σ′, x · ( ⊢ ⟨s, σ⟩ → σ′ ∧ x ̸∈ FV(s) =⇒ σ′(x) = σ(x) ) . Hint: The statement to prove is equivalent to ∀T, s, σ, σ′, x · ( (root(T ) ≡ ⟨s, σ⟩ → σ′) ∧ x ̸∈ FV(s) =⇒ σ′(x) = σ(x) ), where T ranges over derivation trees. Solution. Define P (T ) to be the statement: ∀s, σ, σ′, x · ( root(T ) ≡ ⟨s, σ⟩ → σ′) ∧ x ̸∈ FV(s) =⇒ σ′(x) = σ(x) ) We prove ∀T · P (T ) (which is equivalent to the statement to be proved) by induction on the shape of the derivation tree T . Thus, for an arbitrary tree T , we get as the induction hypothesis ∀T ′ ⊏ T · P (T ′), and need to prove P (T ). Let s, σ, σ′, x be arbitrary, and assume root(T ) ≡ ⟨s, σ⟩ → σ′ and x ̸∈ FV(s). Then, we need to prove σ′(x) = σ(x). We consider all the cases with respect to the last rule applied in the derivation tree T : • Case SkipNS: Then T must be of the form: (SkipNS) ⟨skip, σ⟩ → σ i.e., we must have s ≡ skip and σ′ = σ. Thus, σ′(x) = σ(x) trivially follows. 4 • Case AssNS: Then T must be of the form: (AssNS) ⟨y := e, σ⟩ → σ[y ↦→ A[[e]]σ] for some y and e, and thus we must have s ≡ y := e and σ′ = σ[y ↦→ A[[e]]σ]. Since FV(s) = {y} ∪ FV(e) and we assumed x ̸∈ FV(s), we must have x ̸≡ y. Thus, by the definition of state update, σ′(x) = σ[y ↦→ A[[e]]σ](x) = σ(x) as required. • Case IfTNS: Then T must be of the form: A AAA \u0001 \u0001 \u0001\u0001 T1 ⟨s′, σ⟩ → σ′ (IfTNS) ⟨if b then s′ else s′′ end, σ⟩ → σ′ for some derivation tree T1 and some b, s ′, s ′′ such that s ≡ if b then s′ else s′′ end. Since T1 ⊏ T , we can obtain P (T1) from our I.H., i.e., we know (renaming quantified variables to avoid confusion): ∀s1, σ1, σ′ 1, x1 · ( (root(T1) ≡ ⟨s1, σ1⟩ → σ′ 1) ∧ x1 ̸∈ FV(s1) =⇒ σ′ 1(x1) = σ1(x1) ) To get something useful from this statement, we need to instantiate the quantified variables so that the left-hand side of the implication is true. Given that we know the root of T1 already, we instantiate s1 to be s′, and σ1 to be σ, and σ′ 1 to be σ′. Additionally, we instantiate x1 to be x, since this is the only variable about which we have useful information (in particular, from our assumption x ̸∈ FV(s), we can obtain x ̸∈ FV(s′), since FV(s′) ⊆ FV(s)). From these instantiations, we obtain (root(T1) ≡ ⟨s′, σ⟩ → σ′) ∧ x ̸∈ FV(s′) =⇒ σ′(x) = σ(x)) Since the left-hand side of the implication holds, we conclude that σ′(x) = σ(x), which is what we needed to prove. • Case IfFNS: Analogous to the case IfTNS. • Case WhTNS: Then T must be of the form: AA AA \u0001 \u0001 \u0001\u0001 T1 ⟨s′, σ⟩ → σ′′ A A AA \u0001 \u0001 \u0001\u0001 T2 ⟨while b do s′ end, σ′′⟩ → σ′ (WhTNS) ⟨while b do s′ end, σ⟩ → σ′ for some derivation trees T1, T2, some b, s ′, σ′′, and we must have s ≡ while b do s′ end. From our I.H. (since T1 ⊏ T ), instantiating the quantified variables to match the known root of T1, we can obtain (root(T1) ≡ ⟨s′, σ⟩ → σ′′)∧x ̸∈ FV(s′) =⇒ σ′′(x) = σ(x). The left- hand side of this implication holds (in particular, we have x ̸∈ FV(s′) since FV(s′) ⊆ FV(s)), and thus we conclude the right-hand side σ′′(x) = σ(x). 5 Next, we can similarly apply the induction hypothesis to the derivation tree T2 in order to obtain that (root(T2) ≡ ⟨s′′, σ′′⟩ → σ′) ∧ x ̸∈ FV(s′′) =⇒ σ′(x) = σ′′(x), where s′′ ≡ while b do s′ end, and thus (since the left-hand side of the implication holds), we conclude σ′(x) = σ′′(x). Combining the two equalities, we have σ′(x) = σ(x), as required. • Case WhFNS: Analogous to the case SkipNS. • Case SeqNS: Analogous to the case WhTNS. 6","libVersion":"0.5.0","langs":""}