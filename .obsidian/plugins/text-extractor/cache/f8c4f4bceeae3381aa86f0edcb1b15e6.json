{"path":"sem2/PProg/VRL/extra/benji/PProw-w04-benji.pdf","text":"Parallel Programming Exercise Session 4 Spring 2024 Schedule Post-Discussion Ex. 3 25’ Pipelining Recap 15’ Break Pre-Discussion Ex. 4 10’ Quiz 10’ 2 Post-Discussion Exercise 3 3 Counter Let’s count number of times a given event occurs 4 public interface Counter { public void increment(); public int value(); } // background threads for (int i = 0; i < numIterations; i++) { // perform some work counter.increment(); } // progress thread while (isWorking) { System.out.println(counter.value()); } essentials 5 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 10 iterations each number of times increment() is called value of the shared Counter essentials 6 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 number of times increment() is called value of the shared Counter essentials 7 0 Counter 1 Thread 1 0 Thread 2 0 Thread 3 number of times increment() is called value of the shared Counter essentials 8 1 Counter 1 Thread 1 0 Thread 2 0 Thread 3 increment() number of times increment() is called value of the shared Counter essentials 9 10 Counter 10 Thread 1 0 Thread 2 0 Thread 3 increment() number of times increment() is called value of the shared Counter essentials 10 15 Counter 10 Thread 1 0 Thread 2 5 Thread 3 increment() number of times increment() is called value of the shared Counter essentials 11 25 Counter 10 Thread 1 10 Thread 2 5 Thread 3 increment() number of times increment() is called value of the shared Counter essentials 12 30 Counter 10 Thread 1 10 Thread 2 10 Thread 3 increment() number of times increment() is called value of the shared Counter essentials 13 30 Counter 10 Thread 1 10 Thread 2 10 Thread 3 Print 30 Main value() number of times increment() is called value of the shared Counter read the Counter value essentials 14 Task A: SequentialCounter public class SequentialCounter implements Counter { public void increment() { ?? } public int value() { ?? } } essentials 15 Task A: SequentialCounter public class SequentialCounter implements Counter { private int c = 0; public void increment() { c++; } public int value() { return c; } } essentials 16 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 Task A: SequentialCounter public void increment() { c++; } essentials Task A: SequentialCounter 17 1 Counter 1 Thread 1 Thread 2 0 Thread 3 1 conflicting access! How is this possible? public void increment() { c++; } essentials Task A: SequentialCounter 18 1 Counter 1 Thread 1 Thread 2 0 Thread 3 1 conflicting access! How is this possible? public void increment() { c++; } public void increment() { c = c + 1; } essentials Task A: SequentialCounter 19 1 Counter 1 Thread 1 Thread 2 0 Thread 3 1 conflicting access! How is this possible? public void increment() { c++; } public void increment() { c = c + 1; } 1. load c → 0 assume c is initialized to value 0 essentials Task A: SequentialCounter 20 1 Counter 1 Thread 1 Thread 2 0 Thread 3 1 conflicting access! How is this possible? public void increment() { c++; } public void increment() { c = c + 1; } 1. load c → 0 2. load c → 0 assume c is initialized to value 0 essentials Task A: SequentialCounter 21 1 Counter 1 Thread 1 Thread 2 0 Thread 3 1 conflicting access! How is this possible? public void increment() { c++; } public void increment() { c = c + 1; } 2. load c → 0 1. load c → 0 3. c + 1 → 1 4. store c ← 1 assume c is initialized to value 0 essentials Task A: SequentialCounter 22 1 Counter 1 Thread 1 Thread 2 0 Thread 3 1 conflicting access! How is this possible? public void increment() { c++; } public void increment() { c = c + 1; } 1. load c → 0 3. c + 1 → 1 4. store c ← 1 2. load c → 0 5. c + 1 → 1 6. store c ← 1 assume c is initialized to value 0 essentials Task A: SequentialCounter 23 1 Counter 1 Thread 1 Thread 2 0 Thread 3 1 conflicting access! How is this possible? public void increment() { c++; } public void increment() { c = c + 1; } 1. load c → 0 3. c + 1 → 1 4. store c ← 1 2. load c → 0 5. c + 1 → 1 6. store c ← 1 note that increment is not atomic! assume c is initialized to value 0 essentials 24 Task B: SynchronizedCounter public class SynchronizedCounter implements Counter { public void increment() { ?? } public int value() { ?? } } essentials 25 Task B: SynchronizedCounter public class SynchronizedCounter implements Counter { private int c = 0; public synchronized void increment() { c++; } public synchronized int value() { return c; } } essentials 26 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 Task B: SynchronizedCounter synchronized void increment() { c++; } essentials 27 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 Task B: SynchronizedCounter synchronized void increment() { c++; } thread 1 synchronized void increment() { c++; } Thread 2 tries to acquire lock on counter. As the lock is already acquired by thread 1 the thread 2 suspends its execution. essentials 28 1 Counter 1 Thread 1 0 Thread 2 0 Thread 3 Task B: SynchronizedCounter synchronized void increment() { c++; } thread 1 synchronized void increment() { c++; } Thread 2 tries to acquire lock on counter. As the lock is already acquired by thread 1 the thread 2 suspends its execution. essentials 29 1 Counter 1 Thread 1 0 Thread 2 0 Thread 3 Task B: SynchronizedCounter synchronized void increment() { c++; } synchronized void increment() { c++; } releases lock upon method exit essentials 30 1 Counter 1 Thread 1 0 Thread 2 0 Thread 3 Task B: SynchronizedCounter synchronized void increment() { c++; } synchronized void increment() { c++; } thread 2 essentials Task D ● Implement a FairThreadCounter that ensures that different threads increment the Counter in a round-robin fashion. That is, two threads with ids 1 and 2 would increment the value in the following order 1, 2, 1, 2, 1, 2, etc. You should implement the scheduling using the wait and notify methods. ● (Optional) Extend your implementation to work with arbitrary number of threads (instead of only 2) that increment the counter in round-robin fashion. 31 essentials Wait and Notify Recap 32 Object (lock) provides wait and notify methods (any object is a lock) wait: Thread must own object’s lock to call wait thread releases lock and is added to “waiting list” for that object thread waits until notify is called on the object notify: Thread must own object’s lock to call notify notify: Wake one (arbitrary) thread from object’s “waiting list” notifyAll: Wake all threads essentials Wait and Notify Recap 33 Spurious wake-ups and notifyAll()  wait has to be in a while loop essentials 34 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 Thread 1 must increment first! essentials 35 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 lockthread 2 essentials 36 0 Counter 0 Thread 1 Thread 2 0 Thread 3 lock failed Suspended: Thread 3 thread 2 0 essentials 37 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 lock check thread 2 Blocked: Thread 3 essentials 38 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 lock check wait Waiting: Thread 2 Blocked: Thread 3 essentials 39 0 Counter 0 Thread 1 Thread 2 0 Thread 3lock thread 3 0 Waiting: Thread 2 essentials 40 0 Counter 0 Thread 1 Thread 2 0 Thread 3lock check thread 3 0 Waiting: Thread 2 essentials 41 0 Counter 0 Thread 1 Thread 2 0 Thread 3lock check wait 0 Waiting: Thread 2 Thread 3 essentials 42 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 lock Waiting: Thread 2 Thread 3 thread 1 essentials 43 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 lock check Waiting: Thread 2 Thread 3 thread 1 essentials 44 1 Counter 1 Thread 1 0 Thread 2 0 Thread 3 lock check increment Waiting: Thread 2 Thread 3 thread 1 essentials 45 1 Counter 1 Thread 1 0 Thread 2 0 Thread 3 lock check increment notify or notifyAll? thread 1 Waiting: Thread 2 Thread 3 essentials 46 1 Counter 1 Thread 1 0 Thread 2 0 Thread 3 lock check increment notifyAll unlock Waiting: Thread 2 Thread 3 essentials 47 1 Counter 1 Thread 1 0 Thread 2 0 Thread 3 lock check increment notifyAll unlock Waiting: Thread 2 Thread 3 Which thread will be woken up and acquire the lock? Which thread will be woken up if we use notify instead of notifyAll? essentials How to find the difference between notify vs notifyAll? 48 https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html essentials 49 Task E: AtomicCounter public class AtomicCounter implements Counter { public void increment() { ?? } public int value() { ?? } } essentials 50 Task E: AtomicCounter public class AtomicCounter implements Counter { private AtomicInteger c = new AtomicInteger(0); public void increment() { c.incrementAndGet(); } public int value() { return c.get(); } } essentials 51 Task E: AtomicCounter public class AtomicCounter implements Counter { private AtomicInteger c = new AtomicInteger(0); public void increment() { c.incrementAndGet(); } public int value() { return c.get(); } } What is the difference? int c++; AtomicInteger c.incrementAndGet(); essentials 52 Task E: AtomicCounter public class AtomicCounter implements Counter { private AtomicInteger c = new AtomicInteger(0); public void increment() { c.incrementAndGet(); } public int value() { return c.get(); } } What is the difference? int c++; AtomicInteger c.getAndIncrement(); 1. load c → 0 2. c + 1 → 1 3. store c ← 1 not atomic atomic An operation is atomic if no other thread can see it partly executed. Atomic as in “appears indivisible”. However, does not mean it’s implemented as single instruction. essentials Post- vs Pre-Increment 53 details Post-Increment int i = 0; AtomicInteger c = new AtomicInteger(0); System.out.println(i++); System.out.println(c.getAndIncrement()); int i = 0; AtomicInteger c = new AtomicInteger(0); System.out.println(++i); System.out.println(c.incrementAndGet()); Pre-Increment Exercise 4: Pipelining Recap 54 essentials Pipelining: Main Concepts Recap Latency Throughput Balanced/Unbalanced Pipeline 55 essentials Pipelining: Main Concepts Recap Latency time needed to perform a given computation (e.g., process a customer) Throughput Balanced/Unbalanced Pipeline 56 essentials Pipelining: Main Concepts Recap Latency time needed to perform a given computation (e.g., process a customer) Throughput amount of work that can be done by a system in a given period of time (e.g., how many customers can be processed in one minute) Balanced/Unbalanced Pipeline 57 essentials Pipelining: Main Concepts Recap Latency time needed to perform a given computation (e.g., process a customer) Throughput amount of work that can be done by a system in a given period of time (e.g., how many customers can be processed in one minute) Balanced/Unbalanced Pipeline a pipeline is balanced if each stage takes the same length of time 58 essentials Library 59 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes At UZH the law students have been tasked with writing a legal essay about the philosophy of Swiss law. In order to write the essay, each student needs to read four different books on the subject, denoted as A, B, C and D (in this order). This exercise is created by Lasse Meinen and is part of the unofficial VIS Prüfungsvorbereitungsworkshop Scripts available at: https://vis.ethz.ch/de/services/pvw-scripts/ essentials Library 60 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes Question 1: Let’s assume all law students are a bit too competitive and don’t return any books before they’re done reading all of them. How long will it take for 4 students until all of them have started writing their essays? Over at UZH the law students have been tasked with writing a legal essay about the philosophy of Swiss law. In order to write the essay, each student needs to read four different books on the subject, denoted as A, B, C and D (in this order). essentials Library 61 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes Question 1: Let’s assume all law students are a bit too competitive and don’t return any books before they’re done reading all of them. How long will it take for 4 students until all of them have started writing their essays? student 1 student 2 student 3 student 4 Total: 4 * 280 min Latency: 280 min Throughput: 1 per 280 min essentials Library 62 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes Question 2: The library introduces a ”one book at a time” policy, i.e., the students have to return a book before they can start on the next one. How long will it now take for 4 students until all of them have started writing their essays? Draw diagrams, as seen before essentials Library 63 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes Question 2: The library introduces a ”one book at a time” policy, i.e., the students have to return a book before they can start on the next one. How long will it now take for 4 students until all of them have started writing their essays? student 1 student 2 student 3 student 4 Latency? essentials Library 64 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes Question 2: The library introduces a ”one book at a time” policy, i.e., the students have to return a book before they can start on the next one. How long will it now take for 4 students until all of them have started writing their essays? student 1 student 2 student 3 student 4 Latency? 280 min 320 min 360 min 400 min essentials Library 65 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes Question 2: The library introduces a ”one book at a time” policy, i.e., the students have to return a book before they can start on the next one. How long will it now take for 4 students until all of them have started writing their essays? student 1 student 2 student 3 student 4 Latency? 280 min 320 min 360 min 400 min For this pipeline, latency makes sense only if asked for a particular student, not for the whole pipeline. essentials Library 66 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes Question 2: The library introduces a ”one book at a time” policy, i.e., the students have to return a book before they can start on the next one. How long will it now take for 4 students until all of them have started writing their essays? student 1 student 2 student 3 student 4 Latency? 280 min 320 min 360 min 400 min Throughput?Balanced? essentials Library 67 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes Question 2: The library introduces a ”one book at a time” policy, i.e., the students have to return a book before they can start on the next one. How long will it now take for 4 students until all of them have started writing their essays? student 1 student 2 student 3 student 4 Latency? 280 min 320 min 360 min 400 min Throughput? 1 student per 160 minutes Balanced? With lead in (fixed number of students) essentials Library 68 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes Question 2: The library introduces a ”one book at a time” policy, i.e., the students have to return a book before they can start on the next one. How long will it now take for 4 students until all of them have started writing their essays? student 1 student 2 student 3 student 4 Latency? 280 min 320 min 360 min 400 min Throughput? 1 student per 120 minutes Balanced? Without lead in (indefinite number of students) essentials Library 69 Every student takes the exact same amount of time to read a book, concretely: 1) Reading book A takes 80 minutes 3) Reading book C takes 120 minutes 2) Reading book B takes 40 minutes 4) Reading book D takes 40 minutes student 1 student 2 student 3 student 4 Latency? 280 min 320 min 360 min 400 min Throughput? 1 student per 160 minutes Balanced? No The pipeline is not balanced since the stages have different length essentials Exercise 4 70 essentials Bob, Mary, John and Alice Task 1 - Pipelining 71 50 min 90 min 15 min a) Laundry time using sequential order b) Design a strategy with better laundry time c) How would the laundry time improve if they bought a new dryer? essentials Task 2 - Pipelining II Assume a processor that can each cycle issue either: ● one multiplication instruction with latency 6 cycles ● one addition instruction with latency 3 cycles How many cycles are required to execute following loops? 72 for (int i = 0; i < data.length; i += 4) { j = i + 1; k = i + 2; l = i + 3; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; data[k] = data[k] * data[k]; data[l] = data[l] * data[l]; } for (int i = 0; i < data.length; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } for (int i = 0; i < data.length; i++) { data[i] = data[i] * data[i]; } essentials Task 3 - Identify Potential Parallelization Can we parallelize following two loops using parallel for construct? 73 for (int i=1; i<size; i++) { // for loop: i from 1 to (size-1) if (data[i-1] > 0) // If the previous value is positive data[i] = (-1)*data[i]; // change the sign of this value } // end for loop for (int i=0; i<size; i++) { // for loop: i from 0 to (size-1) data[i] = Math.sin(data[i]); // calculate sin() of the value } // end for loop essentials https://quizizz.com/admin/quiz/62265bf968631b001e4acbde Replace link with link to quiz","libVersion":"0.3.1","langs":""}