{"path":"sem4/FMFP/VRL/extra/cyp.pdf","text":"P. M¨uller and D. Traytel Formal Methods and Functional Programming The CYP1 Proof Checker CYP accepts induction proofs written in a similar style compared to the one used in the lecture. We start with a concrete example and list some important aspects below. You can play with this example on Code Expert: expert.ethz.ch/solve/o3rYzwq6nsad34fJA. Lemma: length (xs ++ ys) .=. length xs + length ys Proof by induction on List xs Case [] -- Base case Show: length ([] ++ ys) .=. length [] + length ys Proof length ([] ++ ys) ( by def ++) .=. length ys length [] + length ys ( by def length) .=. 0 + length ys ( by arith) .=. length ys QED Case z:zs -- Induction step Fix z, zs Assume IH: length (zs ++ ys) .=. length zs + length ys Then Show: length ((z : zs) ++ ys) .=. length (z : zs) + length ys Proof length ((z:zs) ++ ys) ( by def ++) .=. length (z : (zs ++ ys)) ( by def length) .=. 1 + length (zs ++ ys) ( by IH) .=. 1 + (length zs + length ys) length (z:zs) + length ys ( by def length) .=. (1 + length zs) + length ys ( by arith) .=. 1 + (length zs + length ys) QED QED 1CYP (Check Your Proof) is a tool developed at TU M¨unchen by Lars Noschinski and Lars Hupel. It checks induction proofs for correctness. In our course, we use a slightly modiﬁed/extended version of CYP (available on github.com/dtraytel/cyp). 1 • On Code Expert, you should put your induction proof, such as the above, in the ﬁle proof.txt. Use the Run button ▶ to invoke CYP. • The gray boxes visualize reserved keywords of CYP. • A proof ﬁle consists of one or several (optionally named) lemmas, written Lemma <name>: <statement> <proof> • Statements are equations between Haskell expressions; the symbol .=. denotes equality. • Comments can be added using Haskell syntax. • Capitalization matters: capitalize keywords, and lemma and axiom names as shown (spec- iﬁed on the exercise sheet). • Indentation matters: indent subproofs; do not use tabs. • There are several kinds of proofs: 1. Equational reasoning As used for the proof of the base case length ([] ++ ys) .=. length [] + length ys Proof length ([] ++ ys) ( by def ++) .=. length ys length [] + length ys ( by def length) .=. 0 + length ys ( by arith) .=. length ys QED – Allowed are either a single chain of equations rewriting the left hand side into the right hand side, or two chains rewriting the left hand side and the right hand side to the same expression. – Every step belongs to its own line. – Every step must be justiﬁed with a ( by <rule>) annotation at the beginning of the line. Rules are either deﬁnition of functions def <function>, the induction hypothesis IH, or certain additional axioms given on the exercise sheet. In this case, arith stands for both 0 + a = a and a + (b + c) = (a + b) + c; the tool picks the right rule automatically. 2. Induction As above for length (xs ++ ys) .=. length xs + length ys Proof by induction on List xs Case [] -- Base case Show: length ([] ++ ys) .=. length [] + length ys <proof> 2 Case z:zs -- Induction step Fix z, zs Assume IH: length (zs ++ ys) .=. length zs + length ys Then Show: length ((z : zs) ++ ys) .=. length (z : zs) + length ys <proof> QED – The variables used by the constructor must be explicitly quantiﬁed using the Fix keyword. Multiple variables are separated using commas. – IH may be used in the <proof> below it. Diﬀerent names are allowed for IH. – Types diﬀerent from lists are also supported (everything deﬁned with data is). They adhere to diﬀerent induction schemes: there must be one Case for each constructor. The Case keyword is followed by a constructor pattern, e.g. z:zs for the non-empty list, or Node x l r for an internal tree node. – If there are multiple induction hypotheses (e.g. when proving a lemma about binary trees), each induction hypothesis is listed on a single line inside the Assume ... Then block. They should have distinct names, e.g. IH1, IH2, . . . – Sometimes induction requires generalization (universal quantiﬁcation of free vari- ables that are not the one on which the induction happens). The syntax for such generalization is shown in red below. The dark red boxes represent CYP keywords, while the light red boxes represent the generalized variables. Multiple generalized variables must be separated by commas. Proof by induction on List xs generalizing ys Case [] -- Base case For fixed ys Show: length ([] ++ ys) .=. length [] + length ys <proof> Case z:zs -- Induction step Fix z, zs Assume IH: forall ys: length (zs ++ ys) .=. length zs + length ys Then for fixed ys Show: length ((z : zs) ++ ys) .=. length (z : zs) + length ys <proof> QED 3. Case distinction Similar to induction, but of course weaker (does not provide an induction hypothesis). Proof by case analysis on List xs Case [] -- the case that list is empty 3 empty: xs .=. [] <proof> Case z : zs -- the case that list is not empty Fix z, zs nonempty: xs .=. z : zs <proof> QED 4. Extensionality Proving equality of functions works by extensionality Lemma: f = g Proof by extensionality with x Show: f x .=. g x <proof> QED • CYP syntax diﬀers in the following aspects from the notation used in the lecture. For the exam, both syntaxes are ﬁne provided that you pay careful attention to the quantiﬁers. 1. Variables in lemmas are quantiﬁed implicitly in CYP and explicitly in the lecture. 2. Generalisation over variables is expressed in CYP at the induction proof step and using a universal quantiﬁer in the lemma in the lecture. Both demand the universal quantiﬁer for stating the induction hypothesis. 3. Arithmetic transformations in CYP must be proven using the arithmetic identities provided (lemma arith in the example) in small steps. In the lecture, several steps may be collapsed into one. 4","libVersion":"0.5.0","langs":""}