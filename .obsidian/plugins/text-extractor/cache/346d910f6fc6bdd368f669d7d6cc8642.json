{"path":"sem3/A&D/UE/s/A&D-s-u09.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 18 November 2024 Johannes Lengler, David Steurer Kasper Lindberg, Lucas Slot, Hongjie Chen, Manuel Wiedmer Algorithms & Data Structures Exercise sheet 9 HS 24 The solutions for this sheet are submitted on Moodle until 24 November 2024, 23:59. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. The solutions are intended to help you understand how to solve the exercises and are thus more detailed than what would be expected at the exam. All parts that contain explanation that you would not need to include in an exam are in grey. Exercise 9.1 Transitive graphs. Let G = (V, E) be an undirected graph. We say that G is • transitive when for any two edges {u, v} and {v, w} in E, the edge {u, w} is also in E; • complete when its set of edges is {{u, v} | u, v ∈ V, u ̸= v}; • the disjoint union of G1 = (V1, E1), . . . , Gk = (Vk, Ek) iff V = V1∪· · ·∪Vk, E = E1∪· · ·∪Ek, and V1, . . . , Vk are pairwise disjoint. Show that an undirected graph G is transitive if and only if it is a disjoint union of complete graphs. Solution: We first show that disjoint unions of complete graphs are transitive (⇐), and then that any transitive graph is a disjoint union of complete graphs (⇒). ⇐: Let G = (V, E) be a disjoint union of complete graphs G1 = (V1, E1), . . . , Gk = (Vk, Ek). Let {u, v}, {v, w} ∈ E. Since G is a disjoint union, there exists i ∈ [k] such that v ∈ Vi, {u, v} ∈ Ei, and {v, w} ∈ Ei. Then we get u ∈ Vi and w ∈ Vi. From the assumption that Gi is complete, we finally get {u, w} ∈ Ei ⊆ E. ⇒: Let G = (V, E) be a transitive graph. We can decompose G into its connected components G1 = (V1, E1), . . . , Gk = (Vk, Ek). Clearly, G is the disjoint union of its connected components. Let us now show that each connected component is complete. Let i ∈ [k]. Consider u, v ∈ Vi with u ̸= v. As u and v are in the same connected component of G, there exists a path (w1, w2, . . . , wp) from u to v in Gi, where w1 = u and wp = v. We will now show that {w1, wj} ∈ Ei for j = 2, 3, . . . , p by induction on j. Base case: j = 2. As (w1, w2, . . . , wp) forms a path in Gi, we have {w1, w2} ∈ Ei by the definition of paths. Induction step: Assume {w1, wj} ∈ Ei for some j ∈ {2, 3, . . . , p − 1}. As (w1, w2, . . . , wp) forms a path in Gi, we have {wj, wj+1} ∈ Ei by the definition of paths. As both {w1, wj} ∈ Ei and {wj, wj+1} ∈ Ei and Ei ⊆ E, using the transitive property of G, we obtain {w1, wj+1} ∈ E. Since G is a disjoint union, we also have {w1, wj+1} ∈ Ei. Conclusion: {w1, wj} ∈ Ei for j = 2, 3, . . . , p. This implies {w1, wp} ∈ Ei, i.e. {u, v} ∈ Ei. Therefore, for every pair of distinct vertices u, v ∈ Vi, we can show {u, v} ∈ Ei, which means Gi = (Vi, Ei) is complete. Exercise 9.2 Short statements about directed graphs (1 point). In the following, let G = (V, E) be a directed graph. For each of the following statements, decide whether the statement is true or false. If the statement is true, provide a proof; if it is false, provide a counterexample. (a) If G has no sources, it must have a directed cycle1 (a source is a vertex with in-degree 0). Solution: This statement is true. Consider the graph ←− G obtained from G by flipping all edges. That is, ←− G = (V, ←− E ), with ←− E := {(w, v) : (v, w) ∈ E}. Note that in-degrees in ←− G correspond to out-degrees in G and vice versa. Therefore, ←− G has no sinks. From the lecture, we thus know that ←− G must have a directed cycle (v1, v2, . . . , vk, v1). But then the inverse (v1, vk, . . . , v2, v1) of this cycle is a directed cycle in G. (b) If both the in-degree and out-degree of each vertex in G are even, then G contains a directed Eulerian walk (i.e., a directed walk which uses each edge exactly once). Solution: This is false. For a counterexample, consider the following directed graph: A B C D (c) The following graph has a topological sorting. If so, give a topological sorting; if not, prove why no topological sorting can exist. 1A directed cycle is a closed directed walk of length at least 2 for which all vertices are pairwise distinct except the endpoints. 2 A B C D E F G H I Solution: This statement is true. I, E, G, A, D, H, B, C, F is a topological sorting of G. We construct a topological sorting with the strategy that was discussed in the lecture, that is, we find a sink v in the graph, remove v (and all incident edges) from the graph and iterate. Since the graph is small, we find a sink “by hand”, but we could as well do it with the algorithm that was discussed in the lecture. All graphs that occur in the process are described below, where the cur- rect sinks are marked in blue. Note that there are different possible topological sortings, the one described here is just an example. A B C D E F G H I A B C D E G H I A B D E G H I A D E G H I A D E G I A E G I E G I E IG E IG So, I, E, G, A, D, H, B, C, F is a topological sorting of G. 3 Guidelines for correction: For awarding the bonus points, each subexercise should be split into two parts, namely one part is giving the correct answer and the other part is giving a correct proof or counterexample. If at least 3 parts are solved correctly, 1/2 points should be awarded. If all 6 parts are solved correctly, 1 point should be awarded. Exercise 9.3 Data structures for graphs. Consider the following three types of data structures for storing an undirected graph G = (V, E) with V = [n] and |E| = m: (the following three instances of data structures are for a graph with n = 6 and m = 7) 1) Adjacency matrix: 0 1 1 1 1 0 1 0 0 1 0 1 1 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 0 0 0 1 0 0 0 0 2) Adjacency lists: For each vertex v, we store its neighbors in a singly linked list Adj[v]. Given a vertex v ∈ V , we can access the head of Adj[v] in constant time. 11111222233444455566 3) Improved adjacency lists: For each vertex, we store its neighbors in a doubly linked list Adj[v]. Given a vertex v ∈ V , we can access the head of Adj[v] in constant time. We also store the degree of each vertex v ∈ V in the head of Adj[v]. Additionally, for each edge {u, v}, there are pointers between the element corresponding to v in Adj[u] and the element corresponding to u in Adj[v]. Question: For each of the above data structures, what is the required memory in Θ-notation? Solution: 4 Θ(n2) for adjacency matrix, Θ(n + m) for adjacency list and improved adjacency list. Question: Which worst-case runtime do we have for the following queries? Give your answer in Θ-notation depending on n, m, and/or deg(u) and deg(v) (if applicable). (a) Input: A vertex v ∈ V . Find deg(v). Solution: Θ(n) in adjacency matrix, Θ(1 + deg(v)) in adjacency list, Θ(1) in improved adjacency list. The reason why we write Θ(1 + deg(v)) instead of Θ(deg(v)) is that when deg(v) = 0, we still need Θ(1) time. (b) Input: A vertex v ∈ V . Find a neighbor of v (if a neighbor exists). Solution: Θ(n) in adjacency matrix, Θ(1) in adjacency list and in improved adjacency list. (c) Input: Two vertices u, v ∈ V . Decide whether u and v are adjacent. Solution: Θ(1) in adjacency matrix, Θ(1+min{deg(v), deg(u)}) in adjacency list and in improved adjacency list. For (improved) adjacency list, we can search u in Adj[v] and v in Adj[u] simultaneously. (d) Input: An edge {u, v} ∈ E. Delete the edge {u, v} from the graph. Solution: Θ(1) in adjacency matrix, Θ(deg(v) + deg(u)) in adjacency list and, Θ(min{deg(v), deg(u)}) in improved adjacency list. Say deg(u) ≤ deg(v). For improved adjacency list, we can locate v in Adj[u] in Θ(deg(u)) time. Then we can use the pointer to delete u in Adj[v] in Θ(1) time. (e) Input: A vertex u ∈ V . Find a neighbor v ∈ V of u and delete the edge {u, v} from the graph. Solution: Θ(n) in the adjacency matrix. Θ(n) for finding a neighbor and Θ(1) for the edge deletion. Θ(1+ max w:{u,w}∈E deg(w)) for the adjacency list. Θ(1) for finding a neighbor and Θ( max w:{u,w}∈E deg(w)) for the edge deletion. Θ(1) for the improved adjacency list. Θ(1) for finding a neighbor and Θ(1) for the edge deletion. (f) Input: Two vertices u, v ∈ V with u ̸= v. Insert an edge {u, v} into the graph if it does not exist yet. Otherwise do nothing. Solution: Θ(1) in adjacency matrix, Θ(1+min{deg(v), deg(u)}) in adjacency list and in improved adjacency list. (g) Input: A vertex v ∈ V . Delete all edges incident to v from the graph. Solution: Θ(n) in adjacency matrix, Θ(1+deg(v)+∑ u:{u,v}∈E deg(u)) in adjacency list, and Θ(1+deg(v)) in improved adjacency list. 5 Question: For the last two queries, describe your algorithm. Solution: Query (f): We check whether the edge {u, v} does not exist. In adjacency matrix this information is directly stored in the u-v-entry. For adjacency lists we iterate over the neighbors of u and the neigh- bors of v in parallel and stop either when one of the lists is traversed or when we find v among the neighbors of u or when we find u among the neighbors of v. If we didn’t find this edge, we add it: in the adjacency matrix we just fill two entries with ones, in the adjacency lists we add vertices to two lists that correspond to u and v. In the improved adjacency lists, we also need to set pointers between those two vertices, and we need to increase the degree for u and v by one. Query (g): In the adjacency matrix, we fill every entry in v-th row and column with zero. In the adjacency lists we remove v from every list of its neighbors, and then we remove all elements in the list Adj[v] except the head. In the improved adjacency lists we iterate over the neighbors of v and for every neighbor u we remove v from Adj[u] (notice that for each u we can do it in Θ(1) time since we have a pointer between two occurrences of {u, v}) and decrease deg(u) by one. Then we remove all elements in the list Adj[v] except the head and set deg(v) to zero. What if we also want to delete the vertex v itself? The answer will depend on the details of how we want to manage the space/memory. For example, in the adjacency matrix we can copy the complete matrix, but leave out the row and column that correspond to v. This takes time Θ(n2). There is an alternative solution if we are allowed to rename vertices: In this case we can just rename the vertex n as v, and copy the n-th row and column into the v-th row and column. Then the (n − 1) × (n − 1) submatrix of the first n − 1 rows and columns will be the new adjacency matrix. Then the runtime is Θ(n). Whether it is allowed to rename vertices depends on the context. For example, this is not possible if other programs use the same graph. Exercise 9.4 Longest path in a DAG (1 point). Let G = (V, E) be a directed graph without directed cycles (i.e., a directed acyclic graph or short DAG). Assume that V = {v1, . . . , vn} (for n = |V | ∈ N) and that the sorting v1, v2, . . . , vn of the vertices is a topological sorting. The goal of this exercise is to find the longest path in G. (a) Let P be a path in G. Prove that if P = (vi1, vi2, . . . , vik ), then i1 < i2 < · · · < ik. Solution: In a topological sorting of a graph, for any edge (v, w), we have that v comes before w in the sorting. Since v1, v2, . . . , vn is a topological sorting of G, we thus get that for any edge (vi, vj) we have i < j. In particular, if we have a path P = (vi1, vi2, . . . , vik ), then (vi1, vi2), . . . , (vik−1, vik ) are edges of G and thus i1 < i2 < · · · < ik. (b) Describe a bottom-up dynamic programming algorithm that, given a graph G with the property that v1, . . . , vn is a topological sorting, returns the length of the longest path in G in O(|V | + |E|) time. You can assume that the graph is provided to you as a pair (n, Adj) of the integer n = |V | and the adjacency lists Adj. Your algorithm can access Adj[u], which is a list of vertices to which u has a direct edge, in constant time. Formally, Adj[u] := {v ∈ V | (u, v) ∈ E}. In your solution, address the following aspects: 1. Dimensions of the DP table: What are the dimensions of the DP table? 2. Subproblems: What is the meaning of each entry? 6 3. Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others. 4. Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps? Describe the calculation order in pseudocode. 5. Extracting the solution: How can the solution be extracted once the table has been filled? 6. Running time: What is the running time of your solution? Hint: Define the entry of the DP table as DP [i] = length of longest path in G ending at vertex vi. Solution: 1. Dimensions of the DP table: DP [1 . . . n] 2. Subproblems: DP [i] is the length of the longest path ending at vi. 3. Recursion: We initialize DP [1] = 0. DP can then be computed recursively as follows for i > 1 DP [i] = { 0 if vi is a source 1 + maxj∈{1,...,i−1}: (vj ,vi)∈E DP [j] otherwise To see why this holds, first notice that if vi is a source, then only the trivial path P = (vi) ends at vi. Hence, the longest path ending at a source has length 0. Otherwise, vi has in-degree at least one. Let k = DP [i]. Let P = (vj0, . . . , vjk ) be a longest path ending at vi (i.e. vjk = vi). By part (a), we have that j0 < · · · < jk meaning that the jk−1 is already computed in the DP array so we know that what the length of the longest path ending at vjk−1 is. Removing vjk from the end of P gives us a path (vj0, . . . , vjk−1) ending at vjk−1. We claim (vj0, . . . , vjk−1) is a longest path ending at vjk−1 and DP [jk−1] = maxj∈{1,...,i−1}: (vj ,vi)∈E DP [j]. The reason is, if our claim were false, then adding back vi to this path would contradict the fact that P is a longest path ending at vi. Thus DP [jk−1] = k − 1 and then 1 + max j∈{1,...,i−1}: (vj ,vi)∈E DP [j] = 1 + DP [jk−1] = 1 + (k − 1) = k . Therefore DP [i] = 1 + maxj∈{1,...,i−1}: (vj ,vi)∈E DP [j]. 4. Calculation order: For i = 1, 2, . . . , n, compute DP [i]. 5. Extracting the solution: The solution can be found as maxi∈[n] DP [i]. The longest path in the graph must end at some vertex. 6. Running time: Computing the ith entry of DP uses time O(degin(vi) + 1), where the 1 comes from the extra operations. To compute DP [i], we need to access DP [j] for all in-neighbors vj of vi. Since the given adjacency list consists of out-neighbors for each vertex, before filling in the DP table we need to compute a reversed adjacency list which consists of in-neighbors for each vertex. This process takes O(|V | + |E|) time. Summing this over all vertices, we get that the total running time is O(|V | + |E|) as wanted (using that ∑n i=1 degin(vi) = |E|). There is an alternative solution where we define DP [i] to be the length of the longest path starting (rather than ending) at vi. Then to compute DP [i] we only need to access the out-neighbors (rather than in-neighbors) of vi. So with this definition of the DP entries, we do not need to compute a reversed adjacency list in the beginning. 7 Guidelines for correction: If (b) is incorrect award 0 points. If either (a) is correct and (b) is partially correct, or (a) is incorrect and (b) is correct award 1/2 point. Award 1 point if both parts are correct. Exercise 9.5 DFS does not solve closed Eulerian walk (1 point). Consider the following algorithm which takes as input an Eulerian graph G with n vertices V and an edge set E and outputs a walk: Algorithm 1 ’Supposed closed Eulerian walk’-finding algorithm Run DFS on G starting from a vertex v1 ∈ V ▷ First step (v1, v2, . . . , vn) ← DFS pre-order u ← v1 ▷ Second step P ← (v1) while u has at least one neighbor do w ← neighbor of u which has the largest index in the DFS pre-order Append w to P Remove {u, w} from E u ← w return P Remark. Given the DFS pre-order (v1, v2, . . . , vn), we say vi has larger index in this pre-order than vj if i > j. (a) In this part we will see an example of when the algorithm does in fact produce a closed Eulerian walk. Consider the following graph b d a c e Execute the algorithm on this graph using a as the starting vertex and lexicographic ordering for the DFS subroutine. This means that if we start at vertex b for example, then the DFS subroutine prioritizes going to a first. Show the pre-order generated by the DFS, the final DFS tree and the walk outputted by the algo- rithm. Confirm that this walk is indeed a closed Eulerian walk. Solution: The DFS tree will look like 8 b d a c e the pre-order is (a, b, d, c, e) and the walk is (a, e, c, a, d, b, a). (b) However, this algorithm does not always produce a closed Eulerian walk. Consider the graph below. Find a starting vertex and a pre-order of the vertices of the graph below such that running the second step of the algorithm with that pre-order produces a walk which is not a closed Eulerian walk. Note that this pre-order can be generated by any possible DFS tree, meaning the lexicographic ordering of the vertices should not be taken into account. The labeling of the vertices are purely to help with writing out the answers. a b c d e f g h i Show the starting vertex, the pre-order you chose, the DFS tree which would generate this pre-order and the walk outputted by the algorithm. Solution: One solution is to start at a, with pre-order (a, c, b, d, f, g, h, i, e), the DFS tree will look like a b c d e f g h i and the walk is (a, d, f, g, e, c, d, b, c, a), missing out on edges (g, h), (g, i) and (h, i) thus making it not a closed Eulerian walk. 9 Guidelines for correction: (a) is worth 1/2 point. (b) is worth 1/2 point. 10","libVersion":"0.5.0","langs":""}