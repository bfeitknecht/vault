{"path":"sem2a/PProg/UE/e/PProg-u11-e.pdf","text":"Parallel Programming Assignment 11: Advanced synchronization mechanisms Spring Semester 2024 Assigned on: 07.05.2024 Due by: 14.05.2024 Overview In this exercise, we take a closer look on how to implement efficient parallel data-structures. We simulate a common scenario in data processing, a parallel producer consumer queue 1. Based on your knowledge about locks, you will implement the queue using different lock strategies, (e.g., coarse and fine grained locking, optimistic locking, lazy locking) and measure the performance of your implementation. Getting Prepared • Download the ZIP file named assignment11.zip from the course Moodle page. • Import the project in Eclipse: Click on File in the top-menu, then select Import. In the dialog, select Existing Projects into Workspace under the General directory, then click on Next. In the new dialog, select the radiobox in front of Select archive file to import a ZIP file. Then, click Browse on the right side of the text-box to select the ZIP file you just downloaded from the website (assignment11.zip). After that, you should see assignment11 as a project under Projects. Click Finish. • If you have done everything correctly, you should now have a project named assignment11 in your Package Explorer. Look at the two source files SortedListInterface and SequentialList in the assignment10 pack- age. The SequentialList is a simple and non thread-safe implementation of SortedListInterface which specifies an API for a list that keeps it’s elements always in sorted order. The tests in BenchmarkTest simulate a producer/consumer scenario with different threads that produce items (by adding them to the list) and consume items (by removing them from the list) as well as doing many read-only accesses to the list by checking if an item is in the list. Note that for the purpose of this exercise you are not supposed to rely on existing List, Map implemen- tations from the Java standard library for your implementation, but rather you are supposed to implement your own. However, you are of course allowed to study and re-use ideas from the source code of those implementations. Your task is to implement four thread-safe versions of SortedListInterface using different lock strate- gies: 1http://en.wikipedia.org/wiki/Producer- consumer problem Coarse Grained Locking The first implementation is supposed to be a simple and thread-safe version of the SortedListInterface, using a single, global lock to make sure update operations do not interfere with each other. Implement the provided template class CoarseGrainedLockList. Coarse grained locking method locks the whole list when a thread requires to add, remove or check if the list contains the method. This is the simplest way of implementing the thread safe linked list, but gives the worst performance. Fine Grained Locking As you know, having a big global lock that locks the whole data-structure is simple to implement, but usually tends to hurt performance. In your next implementation of SortedListInterface, you will address this by using individual locks for each queue element. Implement the class FineGrainedLockList that uses an individual lock per list element. For your im- plementation, you should be careful to lock any nodes that you need in order to update the list, but not too many! You need to be sure that between comparison of the list values and changing the list content no other threads can access the data. Therefore, hand-over-hand locking is a good choice. Optimistic Locking One way to reduce synchronization costs further is to take a chance: search without acquiring locks, lock the nodes found, and then confirm that the locked nodes are correct. If a synchronization conflict causes the wrong nodes to be locked, then release the locks and start over. Normally, this kind of conflict is rare, which is why we call this technique optimistic synchronization. Implement the class OptimisticLockList that still uses an individual lock per list element. This method typically requires a re-validation if the data-structure has been modified after the lock was acquired. Think about what could go wrong here. Hint: What can happen between value comparison and locking of the nodes? How can you check if the data was modified? Lazy Locking The OptimisticLockList implementation works best if the cost of traversing the list twice without locking is significantly less than the cost of traversing the list once with locking. One drawback of this particular algorithm is that contains() acquires locks, which is unattractive if contains() calls are much more common than calls to other methods. Implement LazyLockList so that contains() calls are wait-free, and add() and remove() methods, while still blocking, traverse the list only once (in the absence of contention). The trick to implementing lazy locking is to keep track of deleted nodes by adding a Boolean marked field to each node. We maintain the invariant that every unmarked node is reachable which allows us to avoid re-traversing the whole list. If a node is marked, then that node is considered not reachable and therefore considered as not contained in the list. To remove an element, we take two steps: First, logically remove the target node by marking it as removed, and second, physically remove it by redirecting the reference in the predecessor’s next field. 2 Implementation performance Once you are confident that your implementations are correct, run the Main method of the BenchmarkTest class, which will benchmark the amount of operations per second for each of your implementations by run- ning a pre-defined workload. In your report, list the numbers you achieve for each of the implementations and briefly discuss your results. You can also play with the initial parameters numOps, initialElems, insertPercentage in BenchmarkTest to see if they impact your results. It is very difficult to write a JUnit test which detects all possible race conditions with a high probability. SortedLinkedListTest tries to detect some errors by adding and removing elements to and from the list with many threads in parallel. You can use the test to find bugs in your implementation but you should not rely on it to find all errors. Feel free to adjust the parameters of the JUnit test or modify it if you have a good idea on how to test your implementation. Submission In order to receive feedback for your exercises, you need to submit your code to the Git repository. You will find detailed instructions on how to install and set-up Eclipse for use with Git in Exercise 1. Once you have completed the skeleton, commit it to Git by following the steps described below. For the questions that require written answers, please write them on paper and bring them to the next exercise session where the solutions will be discussed. • Check-in your project for the first time – Right click your created project called assignment11. – In the menu go to Team, then click Share Project. – You should see a dialog ”Configure Git Repository”. Here, next to the Repository input field click on Create... – Select a root git directory or your projects that you have created in Execise 1. Note for all your assignments you should use the same directory. – click Finish. • Commit changes in your project – Now that your project is connected to your git repository, you need to make sure that every time you change your code or your report, at the end you commit your changes and send (push) them to the git server. – Right click your project called assignment11. – In the menu go to Team, then click Commit... – In the Comment field, enter a comment that summarizes your changes. – In the Files list, select all the files that you changed and want them to be committed. This typically includes all the Java files but not necessarily all the files (e.g., you dont have to commit setting files of our eclipse installation). – Then, click on Commit to store the changes locally or Commit and Push to also upload them to the server. Note that in order to submit your solution you need to both commit and push your changes to the server. • Push changes to the git server 3 – Right click your project called assignment11. – In the menu go to Team, then click Push Branch ’master’. Note if this is not your fist push you can also use Push to Upstream to speed up the process. – A new dialog appears, now fill in for the URL field: https://gitlab.inf.ethz.ch/COURSE-PPROG24/<nethz-username>.git – Click Next – Keep the default values and click Next – An authentication dialog should appear. Fill in your nethz username and password and click OK. – Click Finish to confirm your changes. Note that eclipse might ask for authentication again. • Browse your repository online – you can access and browse the files in your repository online on GitLab at: https://gitlab.inf.ethz.ch/COURSE-PPROG23/<nethz-username> 4","libVersion":"0.3.2","langs":""}