{"path":"sem4/FMFP/PV/exams/finals/FMFP-FS14.pdf","text":"Computer Science Department A. Lochbihler P. M¨uller Formal Methods and Functional Programming Exam August 19th, 2014, 9:00 – 12:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 36 pages; the back page of this booklet is page 36. After the exam begins, check that your exam papers are complete (5 assignments for the FP part, 5 assignments and 2 pages of background material for the FM part). 2. Only write on the exam paper and extra paper sheets which are given by the assis- tants. Do not take any of this paper out of the exam: submit it all. Write your ﬁrst and last name and your student number on every sheet of paper that you write on. 3. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no prepared notes. Do not use pencil and do not use red. 4. For the FP part of the exam, you may use any functions from the Haskell Prelude and Data.List in your solutions (without giving their deﬁnitions). 5. Write clearly in the sense of logic, language, and readability. Label all rule applica- tions in your derivation trees. The clarity of your arguments and explanations a↵ects your grade. 6. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 8 9 10 ∑ Max. points 10 8 7 9 11 3 11 13 6 12 90 Your points Part I: Functional Programming Formal Methods and Functional Programming, Exam, SS14 4 Assignment 1: Typing (10 points) Recall the types of the following functions and constants deﬁned in the Haskell Prelude: 1:: Num a => a (<) :: Ord a => a -> a -> Bool (+) :: Num a => a -> a -> a [] :: [a] filter :: (a -> Bool) -> [a] -> [a] (,) :: a -> b -> (a, b) (a) Give the most general type for the following expressions. You do not need to provide aformal derivation. i. \\x z -> z x ii. \\x y -> (x + 1) < y [] x (b) For each type given below, ﬁnd an expression with exactly the same most general type. i. (a, b) -> (a -> c) -> (c, b) ii. (Num a, Ord b) => ([b] -> a) -> b -> a Hint: Lambda abstractions, applications, and the above library functions su\u0000ce to build such expressions. Your solution may nevertheless use other functions from the Haskell Prelude. Your expression must not contain any type constraints. Formal Methods and Functional Programming, Exam, SS14 6 (c) Recall the following typing rules for Mini-Haskell. ..., x ∶ ⌧, . . . ￿ x ∶∶ ⌧ Var \u0000,x ∶ \u0000 ￿ t ∶∶ ⌧ \u0000 ￿ \u0000x. t ∶∶ \u0000 → ⌧ Abs∗ \u0000 ￿ t1 ∶∶ \u0000 → ⌧ \u0000 ￿ t2 ∶∶ \u0000 \u0000 ￿ t1 t2 ∶∶ ⌧ App \u0000 ￿ t ∶∶ Int \u0000 ￿ iszero t ∶∶ Bool iszero \u0000 ￿ n ∶∶ Int Int \u0000 ￿ True ∶∶ Bool True \u0000 ￿ F alse ∶∶ Bool False \u0000 ￿ t1 ∶∶ Int \u0000 ￿ t1 ∶∶ Int \u0000 ￿ t1 op t2 ∶∶ Int BinOp for op ∈ {+, ∗} \u0000 ￿ t0 ∶∶ Bool \u0000 ￿ t1 ∶∶ ⌧ \u0000 ￿ t2 ∶∶ ⌧ \u0000 ￿ if t0 then t1 else t2 ∶∶ ⌧ if \u0000 ￿ t1 ∶∶ ⌧1 \u0000 ￿ t2 ∶∶ ⌧2 \u0000 ￿ (t1,t2) ∶∶ (⌧1, ⌧2) Tuple \u0000 ￿ t ∶∶ (⌧1, ⌧2) \u0000 ￿ fst t ∶∶ ⌧1 fst \u0000 ￿ t ∶∶ (⌧1, ⌧2) \u0000 ￿ snd t ∶∶ ⌧2 snd ∗ where x ∉ \u0000 Use these to formally infer the type of the expression below. Write out the derivation tree and the generated constraint system. \u0000x. x (snd (x 0)) Formal Methods and Functional Programming, Exam, SS14 8 Assignment 2: Proof by Induction (8 points) Consider the following functions. zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys -- zipWith.1 zipWith _ _ _ = [] -- zipWith.2 flip :: (a -> b -> c) -> b -> a -> c flip f x y = f y x -- flip Prove by induction that for all functions f and all ﬁnite lists xs and ys the equality zipWith (flip f ) xs ys = zipWith f ys xs holds. Structure your proof clearly and justify every proof step. Hint: you do not need to use induction twice (but you might need to do a case distinction). Formal Methods and Functional Programming, Exam, SS14 10 Assignment 3: Haskell Lists (7 points) (a) Deﬁne a Haskell function dvdNxt :: [Int] -> [Int] that gets a list of (non-zero) integers as input. For the result list, the function keeps each element that divides the number immediately following it in the input list, and removes all other elements. It always keeps the last element if there is any. For example, dvdNxt [1,2,3,6,12,15] = [1,3,6,15] (b) Deﬁne a Haskell function stableDN :: [Int] -> [Int] that applies the function dvdNxt repeatedly until the list does not change any more. For example, stableDN [1,2,3,6,12,15] = [1,3,15] (c) Deﬁne a function prepend :: String -> [[String]] -> [String] that prepends a string to each element in a list of lists of strings, and ﬂattens the result into a single list of strings. For example, prepend \"anti\" [[\"hero\",\"body\"],[\"virus\"]] =[\"antihero\",\"antibody\", \"antivirus\"] Make sure your deﬁnition works with inﬁnite lists, too. (Hint: List comprehensions may be helpful.) Formal Methods and Functional Programming, Exam, SS14 12 Assignment 4: Haskell Intervals (9 points) Aclosedinterval overan orderedtyperepresentsthe set ofallvalues between two bounds (inclusively). The datatype data Interval a = V a a represents intervals by the lower and upper bound. An interval Vl u is legal if and only if l<= u. Over the integers, e.g., V2 5 represents the set {2, 3, 4, 5}. (a) Deﬁne a Haskell function make :: Ord a => a -> a -> Interval a that creates a legal interval from any two given parameters. For example, make 321 6 = V 6 321 -- wrong order fixed make 4 4 = V 4 4 make 5.0 8.0 = V 5.0 8.0 (b) Deﬁne an instance of Show for this datatype, so that the intervals are printed in the usual manner as exempliﬁed below show (V 2 5) = \"[2,5]\" show (V 5 8.5) = \"[5.0,8.5]\" For this question, ﬁll in the missing parts of the following code fragment: instance Show (Interval a) where show (Hint: The show function has type show :: Show a => a -> String) (c) Deﬁne a Haskell function intersect :: Ord a => [Interval a] -> Maybe (Interval a) that computes the intersection of a list of intervals. If the input list is empty, or if there is no overlap, it returns Nothing.For example, intersect [V 2 5, V 1 3] = Just (V 2 3) intersect [V 2 5, V 6 7] = Nothing (Hint: Recall the Maybe type: data Maybe a = Nothing | Just a.) (d) Sketch how you could ensure that a user of your datatype can construct only legal intervals. A brief textual description su\u0000ces. (Hint: You may want to make use of Haskell’s module system.) Formal Methods and Functional Programming, Exam, SS14 16 Assignment 5: File System Entries (11 points) Consider the following algebraic data type representing a ﬁle system entry. data FSEntry = Folder String [FSEntry] | File String String Aﬁlesystem entry iseither a folder consisting ofa nameand a (possibly empty) list of ﬁle system entries, or a single ﬁle consisting of a name and some text. For example, test = Folder \"Home\" [Folder \"Work\" [File \"students.txt\" \"Alice, Bob\", File \"hint\" \"You can use fFSE!\"], File \"Fun\" \"FMFP\"] represents a folder Home that contains a subfolder and a ﬁle. (a) Deﬁne the Haskell function fFSE :: (String -> [a] -> a) -> (String -> String -> a) -> FSEntry -> a for folding values of type FSEntry. Hint: You may ﬁnd the function map :: (a -> b) -> [a] -> [b] useful. (b) Deﬁne the following Haskell functions: i. number :: FSEntry -> Int such that number fs returns the number of ﬁles and folders in fs,including fs. For example, number test = 5. ii. count :: Char -> FSEntry -> Int such that count ch fs returns the total number of occurrences of the character ch in the text of all ﬁles in fs (and its subfolders). For example count ’a’ test = 2. Hint: You may ﬁnd the function fFSE useful here. (c) Write the Haskell function paths :: FSEntry -> [String] such that paths fs returns the list of paths to all ﬁles in fs and its subfolders. For example: paths test = [\"Home/Work/students.txt\",\"Home/Work/hint\",\"Home/Fun\"] More precisely, a path to a ﬁle f in a ﬁle system entry fs consists of the names of parent folders of f and the name of f,separated by /, in the order of the tree hierarchy of fs. Hint: You may ﬁnd the function prepend from Assignment 3 useful, and you may use it even if you did not solve the assignment. Part II: Formal Methods Formal Methods and Functional Programming, Exam, SS14 21 Assignment 6 (3 points) Consider the following IMP program s: while x < y do x:= x+ 1; y:= y- 1 end Let \u0000 be a state such that \u0000(x) = 2and \u0000(y) = 3. Prove using the natural semantics (big-step semantics - see page 35) that there is some state \u0000′ with \u0000′(x) = 3and \u0000′(y) = 2 such that ￿ ￿s, \u0000￿ → \u0000′. Provide the complete derivation tree. Don’t forget to write the names of the rules as part of your derivation tree. If you use any abbreviations in your solution, don’t forget to deﬁne them clearly. Formal Methods and Functional Programming, Exam, SS14 22 Assignment 7 (11 points) Consider the following IMP program s: while r >= 0 do r:= r- d; q:= q+ 1 end; (r := r + d; q:= q- 1) The program s computes the quotient q and remainder r resulting from the division of a given non-negative integer N (initially stored in the variable r) by a given positive integer D (stored in the variable d). (a) Find an appropriate loop invariant and loop variant for the while loop. The loop invariant must be strong enough to allow you to prove the Hoare triple in part (b) of the question. (b) Construct a (total correctness) proof outline (see page 36) to show that: ￿ {N ≥ 0 ∧ D > 0 ∧ d = D ∧ r = N ∧ q = 0} s {⇓ N = q × D + r ∧ r ≥ 0 ∧ r < D} Formal Methods and Functional Programming, Exam, SS14 25 Assignment 8 (13 points) The following lemma (that you may recall seeing in your exercise sessions) can be un- derstood informally as stating that the execution of a statement can only modify its free variables (see page 35): ∀s, \u0000, \u0000′,x.( ￿ ￿s, \u0000￿ → \u0000′ ∧ x ∉ FV(s) ⇒ \u0000(x) = \u0000′(x)) However, we cannot apply this lemma in situations in which the variable x is only read from in the program s. For example, from ￿y:=z, \u0000￿ → \u0000′ we cannot deduce \u0000(z) = \u0000′(z) using the lemma directly, because z ∈ FV(y:=z). (a) Deﬁne a reﬁnement of FV(s),called wr(s),that represents the set of variables poten- tially written to by the statement s.For example, it should be the case that: wr(if x > 0 then y ∶= xelse z ∶= xend) = {y, z} (b) Prove that the correspondingly-reﬁned lemma holds: ∀s, \u0000, \u0000′,x.( ￿ ￿s, \u0000￿ → \u0000′ ∧ x ∉ wr(s) ⇒ \u0000(x) = \u0000′(x)) Formal Methods and Functional Programming, Exam, SS14 28 Assignment 9 (6 points) Consider the transition system described by the following diagram, in which circles deﬁne states, and each state is labelled with an abstract state: a set of atomic propositions which holds in that state (in this example, exactly one atomic proposition is true in each state; e.g. p in state s1,whichisalsothe initial state). s1 {p} s2 {q} s3{r} s4 {s} s6 {u}s5{t} For each of the following LTL formulas, state whether or not the formula deﬁnes a property which is satisﬁed by the given transition system and justify your answer: if the property is satisﬁed then brieﬂy explain why; if it is not satisﬁed then provide a counterexample. (a) (￿￿ (p ∨ r)) ∨ (￿￿ u) (b) ¬u U (s ∨ t) Formal Methods and Functional Programming, Exam, SS14 29 (c) ¬(u U (s ∨ t)) (d) (￿s) ⇒ ￿¬p (e) ￿((￿(p ∨ q)) U (s ∨ t)) Formal Methods and Functional Programming, Exam, SS14 30 Assignment 10 (12 points) Recall that a (partial correctness) Hoare triple {P} s {Q} is said to be valid if the following condition holds: ∀\u0000, \u0000′. (BJPK\u0000 = tt ∧ ￿ ￿s, \u0000￿ → \u0000′ ⇒ BJQK\u0000′ = tt) In axiomatic semantics, we deﬁne a derivation rule to be sound if: for every instance of the rule, if all of the rule premises are valid triples and the rule side-condition (if any) is true, then the rule conclusion is also a valid triple. The assignment rule (AssAx) used in the course (page 36) is convenient for construct- ing proof outlines backwards:that is, when we already know the assertion to use after an assignment statement, and need to ﬁnd a corresponding assertion to use before it. Here, we attempt to formulate an alternative rule (AssFwAx) that could be more conve- nient for constructing proof outlines forwards: {P} x:=e {x = e ∧ P} (AssFwAx) (a) Show that the proposed rule (AssFwAx) is not sound: that is, ﬁnd a P,x,e, \u0000 and \u0000′ such that the following is not true: BJPK\u0000 = tt ∧ ￿ ￿x:=e, \u0000￿ → \u0000′ ⇒ BJx=e ∧ PK\u0000′ = tt (b) Write down a side condition which can be added to the proposed rule (AssFwAx),so that the modiﬁed version of the rule (with your side condition) is sound. The following derivation should be a possible instance of your modiﬁed version of the rule: (AssFwAx) {y > 0} x:=y {x = y ∧ y > 0} Formal Methods and Functional Programming, Exam, SS14 31 (c) Prove that your modiﬁed rule is sound. That is, prove that: For all P, x, e,ifyour side condition(chosenin part(b))holdsfor P, x, e,then: ∀\u0000, \u0000′.( BJPK\u0000 = tt ∧ ￿ ￿x:=e, \u0000￿ → \u0000′ ⇒ BJx=e ∧ PK\u0000′ = tt) You can use the following lemmas (without proving them) in your proof: L1: ∀\u0000, x, v, P. (BJPK\u0000 = tt ∧ x ∉ FV(P) ⇒ BJPK(\u0000[x ￿ v]) = tt) L2: ∀\u0000, x, e. (x ∉ FV(e) ⇒ AJeK\u0000 = AJeK(\u0000[x ￿ v]) ) Formal Methods and Functional Programming, Exam, SS14 35 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ∶∶= skip ￿ x:=e ￿ s; s ￿ if b then s else s end ￿ while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). Free variables of a statement The free variables of a statement s,written FV (s) are deﬁned as follows: FV(skip) = ￿ FV(x:=e) = {x} ∪ FV(e) FV(s1;s2) = FV(s1) ∪ FV(s2) FV(if b then s1 else s2 end) = FV(b) ∪ FV(s1) ∪ FV(s2) FV(while b do s end) = FV(b) ∪ FV(s) Note: the analogous deﬁnitions for the free variables of boolean expressions FV(b),arith- metic expressions FV(e),and assertions FV(P) are similar, and not provided here. Natural Semantics (Big-Step Semantics) (SkipNS) ￿skip, \u0000￿ → \u0000 (AssNS) ￿x:=e, \u0000￿ → \u0000[x ￿ A[[e]]\u0000] ￿s1, \u0000￿ → \u0000′ ￿s2, \u0000′￿ → \u0000′′ (SeqNS) ￿s1;s2, \u0000￿ → \u0000′′ ￿s1, \u0000￿ → \u0000′ (IfTNS) ∗ ￿if b then s1 else s2 end, \u0000￿ → \u0000′ ∗if B[[b]]\u0000 = tt ￿s2, \u0000￿ → \u0000′ (IfFNS) ∗ ￿if b then s1 else s2 end, \u0000￿ → \u0000′ ∗if B[[b]]\u0000 = ↵ ￿s, \u0000￿ → \u0000′ ￿while b do s end, \u0000′￿ → \u0000′′ (WhTNS) ∗ ￿while b do s end, \u0000￿ → \u0000′′ ∗if B[[b]]\u0000 = tt (WhFNS) ∗ ￿while b do s end, \u0000￿ → \u0000 ∗if B[[b]]\u0000 = ↵ Formal Methods and Functional Programming, Exam, SS14 36 Axiomatic Semantics (partial correctness) (SkipAx) {P} skip {P} (AssAx) {P[x ￿ e]} x:=e {P} {P} s1 {Q}{Q} s2 {R} (SeqAx) {P} s1;s2 {R} {b ∧ P} s1 {Q}{¬b ∧ P} s2 {Q} (IfAx) {P} if b then s1 else s2 end {Q} {b ∧ P} s {P} (WhAx) {P} while b do s end {¬b ∧ P} {P′} s {Q′} (ConsAx) ∗ {P} s {Q} ∗if P ￿ P′ and Q′ ￿ Q Axiomatic Semantics (total correctness) As for partial correctness above, except for the following rule, which replaces (WhAx) : {b ∧ P ∧ e = Z} s {⇓ P ∧ e < Z} (WhTotAx) ∗ {P} while b do s end {⇓ ¬b ∧ P} ∗if b ∧ P ￿ 0 ≤ e","libVersion":"0.5.0","langs":""}