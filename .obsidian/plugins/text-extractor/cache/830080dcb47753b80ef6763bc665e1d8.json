{"path":"sem2/PProg/VRL/extra/benji/PProg-03-benji.pdf","text":"Parallel Programming Exercise Session 3 Spring 2024 Plan für heute 2 Nachbesprechung Übung 2 Vorbesprechung Übung 3 Theorie Demo Alte Prüfungsaufgaben Quiz Nachbesprechung Übung 2 Nachbesprechung Übung 2 • Task A: Hello Thread • Task B: Single Thread computePrimeFactors() • Task C: Overhead von Thread messen • Task D: PartitionData() implementieren • Task E: computePrimeFactors() parallelisieren • Task F: Über Speedup nachdenken • Task G: Messung für versch. Anz. Threads und Längen 4 Task E: Teilen von Daten zwischen Threads Idee: Übergebt jedem Thread eine Referenz auf das geteilte Objekt. Aufpassen: Bad Interleavings möglich, wenn mehrere Threads das Objekt gleichzeitig modifizieren. Gleichzeitiges lesen geht immer. -> Musterlösung von Task E anschauen 5 Vorbesprechung Übung 3 Counter Wir wollen zählen, wie oft ein Ereignis eingetreten ist. 7 public interface Counter { public void increment(); public int value(); } Counter Let’s count the number of times a given event occurs 8 public interface Counter { public void increment(); public int value(); } // background threads for (int i = 0; i < numIterations; i++) { // perform some work counter.increment(); } // progress thread while (isWorking) { System.out.println(counter.value()); } 9 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 10 iterations each number of times increment() is called value of the shared Counter 10 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 number of times increment() is called value of the shared Counter 11 0 Counter 1 Thread 1 0 Thread 2 0 Thread 3 number of times increment() is called value of the shared Counter 12 1 Counter 1 Thread 1 0 Thread 2 0 Thread 3 increment() number of times increment() is called value of the shared Counter 13 10 Counter 10 Thread 1 0 Thread 2 0 Thread 3 increment() number of times increment() is called value of the shared Counter 14 15 Counter 10 Thread 1 0 Thread 2 5 Thread 3 increment() number of times increment() is called value of the shared Counter 15 25 Counter 10 Thread 1 10 Thread 2 5 Thread 3 increment() number of times increment() is called value of the shared Counter 16 30 Counter 10 Thread 1 10 Thread 2 10 Thread 3 increment() number of times increment() is called value of the shared Counter 17 30 Counter 10 Thread 1 10 Thread 2 10 Thread 3 Print 30 Main value() number of times increment() is called value of the shared Counter read the Counter value Counter Warum wird das wahrscheinlich nicht funktionieren? Lösung: Bad Interleavings 18 essentials Counter Mehrere Threads greifen gleichzeitig auf den Counter zu. Wie wollen wir dieses Problem beheben? Ihr werdet verschiedene Lösungen implementieren. ➔Task A: SequentialCounter ➔Task B: SynchronizedCounter ➔Task E (optional): AtomicCounter 19 Task A – Sequential counter ➔ Implementiert eine sequentielle Version des Counters, die keine Synchronisierung benutzt. ➔ Die taskASequential() Methode benötigt eure sequentielle Version. Stellt sicher, dass ihr die Methode versteht. ➔ Verifiziert die Korrektheit in dem ihr die Tests laufen lässt. testSequentialCounter sollte bestehen. 20 Task A – Parallel counter ➔ Führt taskAParallel() aus. Diese Methode erstellt mehrere Threads, die auf euren sequentiellen Counter zugreifen. ➔ Wird diese Methode korrekt sein und warum ja/nein? 21 essentials Task B – Synchronized counter ➔ Implementiert eine Thread-sichere (thread-safe) Version des Counters. Benutzt dafür sychronized. ➔ Führt den Code von taskB() aus. 22 Synchronization 23 • Ziel: Bad Interleavings verhindern • Jedes Java Object hat ein Schloss (Lock/Monitor), dass von der Object class vererbt wird. • Ein Lock wird beim eintreten in einen synchronized Block automatisch erworben und am Schluss auch wieder released. essentials 24 Shared Object public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: niemand 25 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: niemand 26 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: niemand Ich will foo() ausführen 27 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: niemand Ich will foo() ausführen Zuerst muss T1 das Schloss bekommen! 28 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 Ich will foo() ausführen Zuerst muss T1 das Schloss bekommen! 29 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 Ich will foo() ausführen T1 kann nun foo() ausführen 30 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 T1 ist foo() am ausführen 31 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 T1 ist foo() am ausführen T2 will nun bar() ausführen 32 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 T1 ist foo() am ausführen T2 will nun bar() ausführen Geht nicht, da T1 das Schloss besitzt 33 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 T1 ist foo() am ausführen T2 will nun bar() ausführen T2 kommt in die Wartschlange Warteschlange für • T2 34 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 T1 ist foo() am ausführen T3 will nun foo() ausführen Warteschlange für • T2 35 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 T1 ist foo() am ausführen T3 will nun foo() ausführen Geht auch nicht, da T1 das Schloss besitzt Warteschlange für • T2 36 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 T1 ist foo() am ausführen T3 will nun foo() ausführen T3 kommt in die Warteschlange Warteschlange für • T2 • T3 37 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 T1 ist foo() am ausführen T4 will auch foo() ausführen Warteschlange für • T2 • T3 38 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 T1 ist foo() am ausführen T4 will auch foo() ausführen T4 kommt ebenfalls in die Warteschlange Warteschlange für • T2 • T3 • T4 39 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T1 T1 ist fertig mit foo() Warteschlange für • T2 • T3 • T4 40 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: niemand T1 ist fertig mit foo() Am Ende des synchronized Blocks/Methode wird das Schloss freigegeben Warteschlange für • T2 • T3 • T4 41 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: niemand Warteschlange für • T2 • T3 • T4 42 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: niemand Warteschlange für • T2 • T3 • T4 Ein anderer Thread kann nun das Schloss erwerben 43 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T4 Warteschlange für • T2 • T3Ein anderer Thread kann nun das Schloss erwerben, z.B T4 44 Shared Object T1 T2 T3 T4 public synchronized void foo() { … } public synchronized void bar() { … } Besitzer: T4 Warteschlange für • T2 • T3T4 kann nun die foo() Methode ausführen, etc… Synchronization: Wichtig 45 Threads synchronisieren immer in Bezug auf ein Objekt! D.h. Es werden keine Threads gelocked, sondern Objekte werden von den Threads gelocked! essentials Synchronization: Zusatz 46 • Primitive types haben kein Lock, dafür aber ihre Wrapper-Classes • Das Locken eines Arrays locked nicht die einzelnen Elemente • Locks werden wir später in der Vorlesung genauer analysieren. essentials Synchronization 47 • Synchronized Methode locked das “this” Objekt auf dem die Methode aufgerufen wird. • Synchronized Block erwirbt das Lock des Objekts in Klammern. • Ein Thread kann mehrere Locks gleichzeitig erwerben (z.B. durch verschachteln von synchronized Blocks). essentials 48 10 Counter 10 Thread 1 0 Thread 2 0 Thread 3 49 11 Counter 11 Thread 1 0 Thread 2 0 Thread 3 lock increment() unlock essentials 50 11 Counter 11 Thread 1 0 Thread 2 0 Thread 3 lock Lock: Thread 1 essentials 51 11 Counter 11 Thread 1 0 Thread 2 0 Thread 3 lock failed Blocked: Thread 3 Lock: Thread 1 essentials 52 11 Counter 11 Thread 1 0 Thread 2 0 Thread 3 lock failed Blocked: Thread 3 Thread 2 Lock: Thread 1 essentials 53 11 Counter 11 Thread 1 0 Thread 2 0 Thread 3 lock Blocked: Thread 3 Thread 2 Lock: Thread 1 essentials 54 12 Counter 12 Thread 1 0 Thread 2 0 Thread 3 lock increment() unlock Blocked: Thread 3 Thread 2 essentials Task C Analysiert die Reihenfolge, in der der Counter erhöht wird (printed die Thread-ID). Könnt ihr ein Muster erkennen? Was könnten mögliche Gründe für dieses Verhalten sein? 55 essentials Task D • Implementiert einen “FairThreadCounter”, der die Threads nacheinander (im Kreis) den Counter erhöhen lässt. • Für 4 Threads: 1,2,3,4,1,2,3,4,… Englisch: Round-Robin • Braucht dafür wait und notify. • Überlegt euch auch, wie ihr das ohne wait und notify lösen würdet. 56 essentials Wait and Notify 57 Ziel: Koordination zwischen Threads Alle Java Objekte besitzen wait() und notify() Methoden (vererbt von Object Class) Ein Thread muss das Lock des Objektes besitzen, um wait() oder notify() aufzurufen. essentials Wait and Notify 58 wait: Der Thread gibt das Lock wieder ab und wird zum “waiting set” für dieses Objekt hinzugefügt. Der Thread wartet, bis notify auf dem Objekt aufgerufen wird. notify: Weckt einen zufälligen Thread aus dem «waiting set» für dieses Objekt auf. notifyAll: Weckt alle Threads aus dem “waiting set” auf. essentials Wait and Notify Recap 59 Was ist der Unterschied? Gibt es Probleme? essentials Wait and Notify Recap 60 Problem: “Spurious Wakeups” und der Fall, dass notifyAll() aufgerufen wird. essentials Thread State Model 61 details 62 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 Thread 1 muss als erstes den Counter erhöhen. essentials 63 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 lock Thread 1 muss als erstes den Counter erhöhen. essentials 64 Counter 0 Thread 1 Thread 2 0 Thread 3 lock failed Blocked: Thread 3 Thread 1 muss als erstes den Counter erhöhen. 0 lock 0 essentials 65 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 lock check Blocked: Thread 3 Thread 1 muss als erstes den Counter erhöhen. essentials 66 0 Counter 0 Thread 1 0 Thread 2 Thread 3 lock check wait Waiting: Thread 2 Thread 1 muss als erstes den Counter erhöhen. Blocked: Thread 3 0 essentials 67 0 Counter 0 Thread 1 0 Thread 2 Thread 3 Waiting: Thread 2 lockThread 1 muss als erstes den Counter erhöhen. Blocked: Thread 3 0 Mal angenommen Thread 1 erhält das Lock essentials 68 0 Counter 0 Thread 1 0 Thread 2 Thread 3 Waiting: Thread 2 lock check Thread 1 muss als erstes den Counter erhöhen. Blocked: Thread 3 0 essentials 69 1 Counter 1 Thread 1 0 Thread 2 Thread 3 Waiting: Thread 2 lock check increment Thread 1 muss als erstes den Counter erhöhen. Blocked: Thread 3 0 essentials 70 1 Counter 1 Thread 1 0 Thread 2 Thread 3 lock check increment notify Thread 1 muss als erstes den Counter erhöhen. Blocked: Thread 3 0 essentials 71 1 Counter 1 Thread 1 0 Thread 2 Thread 3 lock check increment notifyAll unlock Thread 1 muss als erstes den Counter erhöhen. Blocked: Thread 3 0 essentials Task E – Atomic counter Implementiert eine weitere Thread-sichere Version. Benutzt dafür einen AtomicCounter. Dieser kann sicher von mehreren Threads gleichzeitig gebraucht werden. 72 Atomic Variables 73 ➔ Eine Menge von Java Klassen z.B. AtomicInteger, AtomicLong, ... ➔ Eine Operation ist atomic, wenn sie von den anderen Threads als untrennbar wahrgenommen wird. ➔ Wird durch spezielle Hardware Instruktionen implementiert. Mehr dazu später in der Vorlesung. ➔ Mehr Infos in der Dokumentation details Task F – Atomic vs Synchronized counter Vergleicht den AtomicCounter mit dem Synchronized Counter durch Messungen der Laufzeit. - Variiert die Arbeit pro Thread - Variiert die Anzahl an Threads 74 essentials Task G Implementiert einen Thread, der den Fortschritt des Counters misst. Dieser Thread soll den Counter beobachten und den aktuellen Stand in der Konsole darstellen. Der Thread soll am Schluss richtig beendet werden (thread.interrupt()). 7576 10 Counter 10 Thread 1 0 Thread 2 0 Thread 3 increment() Printer essentials 77 10 Counter 10 Thread 1 0 Thread 2 0 Thread 3 Print 10! Printer value() essentials 78 15 Counter 10 Thread 1 0 Thread 2 5 Thread 3 increment() Printer essentials 79 25 Counter 10 Thread 1 10 Thread 2 5 Thread 3 increment() Printer essentials 80 25 Counter 10 Thread 1 10 Thread 2 5 Thread 3 Print 25! Printer value() essentials 81 30 Counter 10 Thread 1 10 Thread 2 10 Thread 3 increment() Printer essentials 82 30 Counter 10 Thread 1 10 Thread 2 10 Thread 3 Print 30! Printer value() essentials Theorie Recap Reentrant Java locks sind “reentrant”. D.h. wenn ein Thread das Lock besitzt kann er in andere synchronized Blöcke des gleichen Objekts gelangen. Ein Thread kann in Besitz von verschiedenen Locks gleichzeitig sein. Sollte diese dann auch alle wieder freigeben. 84 details Parallelism vs. Concurrency? Parallelism: Mehrere Aufgaben zur gleichen Zeit erledigen Concurrency: Mehrere Aufgaben gleichzeitig bewältigen. D.h. aber nicht, dass zu einem Zeitpunkt mehrere Aufgaben gleichzeitig bearbeitet werden. Concurrency vs Parallelism 86 Thread A Thread B Thread C Thread A Thread B Thread C Thread A Concurrent, not parallel Concurrent, parallel Not concurrent, not parallel Time essentials Concurrency vs Parallelism 87 McDonalds McDonalds Burger King Concurrency No parallelism Concurrency Parallelism essentials Demo 89 Alte Prüfungsaufgaben Past Exam Task 90 essentials Rep. Exam, FS 2023 Past Exam Task 91 essentials Rep. Exam, FS 2023 Past Exam Task 92 essentials Rep. Exam, FS 2023 Past Exam Task 93 essentials Rep. Exam, FS 2023 https://quizizz.com/admin/quiz/6225327b387927001df6b1f5?source=quiz_share Replace link with link to quiz","libVersion":"0.3.1","langs":""}