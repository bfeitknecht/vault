{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s01a-introduction.pdf","text":"Introduction David Basin Department of Computer Science ETH Z¨urich Functional Programming David Basin 1 About me • ETHZ since 2003: Information Security Group www.infsec.ethz.ch • Research and teaching • I enjoy working with students excited by the above topics. • I appreciate questions and feedback. Functional Programming Spring Semester, 2025 David Basin 2 About the team • Exercises taught by 1 post-doctoral researcher, 5 doctoral students, 4 MSc students • For any organizational issues regarding the FP part of the course, feel free to reach out to our head TA: Fran¸cois Hublet at francois.hublet@inf.ethz.ch • They also appreciate questions and feedback! Functional Programming Spring Semester, 2025 David Basin 3 Course setup • Course in two parts 1. Functional Programming: David Basin and Ralf Jung 2. Formal Methods: Peter M¨uller and Ralf Jung • Instruction in English. You may use German on assignments. • Course times: Tuesday 10–12 and Thursday 10–12 \u0011 10 minute break, roughly in the middle of each class • Course homepage as main platform for the course (for course material etc.) Functional Programming Spring Semester, 2025 David Basin 4 Exercise sessions and homework • Choose your exercise group (time/language) on CodeExpert: https://expert.ethz.ch/enroll/SS25/fmfp (login with your ETH credentials) Please enroll in an exercise group! • It is important that you attend the same exercise group in which you are enrolled in CodeExpert! Functional Programming Spring Semester, 2025 David Basin 5 Exercise sessions and homework • Weekly homework released on the course homepage (theory exercises) and expert.ethz.ch (programming exercises) each Monday. Please check both platforms! • Each week you may submit your solution to one marked exercise to get feedback from your TA. \u0011 Submit the solution to your TA on paper or by e-mail before the next exercise session (TAs may require paper submissions!) \u0011 Except in case of, e.g., sickness, we accept theory submissions only by students who show up \u0011 Starts this week Functional Programming Spring Semester, 2025 David Basin 6 Should you do homework? • Homework is optional but very strongly encouraged • Some statistics (from 2011) \u0011 Students who did not regularly submit exercises, but took exam Average mark: 15.57 out of 28 This corresponds to a grade 4 22.4% of these students failed the course \u0011 Students who regularly submitted exercises Average mark: 19.9 out of 28 (27.8% better) This corresponds to a grade 4.75 None of these students failed Functional Programming Spring Semester, 2025 David Basin 7 Haskell exercises • Via web-based editor on expert.ethz.ch • Separate project for each assignment with a Haskell template file • Automatically runs test cases • More details in this week’s exercise session Functional Programming Spring Semester, 2025 David Basin 8 Grading • 2 graded quizzes: March 13 and TBA (in 2nd part) Each quiz is 30 minutes ⇒ percentage q1, percentage q2 • Final exam, in exam session ⇒ percentage e • Overall percentage (later converted into grade) max(0.8e + 0.1q1 + 0.1q2, 0.9e + 0.1q1, 0.9e + 0.1q2, e) • Setup designed to give you feedback during the semester \u0011 E.g., see results of doing homework. Functional Programming Spring Semester, 2025 David Basin 9 Additional resources • Course homepage contains numerous resources \u0011 Course announcements \u0011 Literature \u0011 Lots of helpful links, e.g., www.haskell.org • Us! Functional Programming Spring Semester, 2025 David Basin 10 Recommended books • “Learn You a Haskell for Great Good” (M. Lipovaˇca) Freely available beginner’s guide to programming in Haskell • “Programming in Haskell” (G. Hutton) Concise introduction to programming in Haskell • “Haskell – the craft of functional programming” (S. Thompson) Beginners text book with a focus on testing and some induction proofs • “Purely Functional Data Structures” (C. Okasaki) Advanced topics in functional programming Functional Programming Spring Semester, 2025 David Basin 11 Why formal methods and functional programming? • Apples and Oranges? Yes but ... Studies program groups topics together in modules when this makes sense • Combination FM+FP is somewhat unusual, but sensible \u0011 Both focus on how to formalize & reason about programs \u0011 I.e., programs as mathematical objects • Fundamental topic in computer science Functional Programming Spring Semester, 2025 David Basin 12 What else should you know? Both parts start out slow, but become increasingly abstract. Some ideas presented first informally and later formally. Material will be new to most of you and hopefully exciting. But it takes work, too. Be prepared for new ways of thinking! Functional Programming Spring Semester, 2025 David Basin 13 Overview to part I 1. Introduction, Haskell syntax 2. Logic, proofs, correctness 3. Lists 4. Abstraction, higher-order programming 5. Type classes and polymorphism 6. Algebraic data types 7. Lazy evaluation and efficiency 8. Monads, conclusions How are algorithms and data represented? How do we develop programs and understand their behavior? Functional Programming Spring Semester, 2025 David Basin 14 Correctness Ariane 5: $500+ million development, 1 arithmetic overflow Functional Programming Spring Semester, 2025 David Basin 15 This week and next • Introduction: basic concepts and some history • Syntax and base types \u0011 Boring but necessary. Explained only in parts \u0011 Read manuals outside of lectures EXCITING! • Proofs and correctness. Exciting essential material \u0011 The advantage of functional languages is not just that you can write clear, concise programs, but that you can easily understand and demonstrate what your programs actually do. \u0011 Requires some logic. Brief refresher coming up. Functional Programming Spring Semester, 2025 David Basin 16 Does language make a difference? • Algorithm: a precise recipe describing computation steps. • Can be presented as: \u0011 a Turing machine \u0011 assembly code for a register machine \u0011 a Java program \u0011 an executable function description • Difference #1: level of abstraction Which operations are available to model and solve problems? • Difference #2: whether reasoning is stateful Compute values versus update memory Functional Programming Spring Semester, 2025 David Basin 17 Example: GCD • The problem Compute the greatest common divisor of two natural numbers • Specification Let x, y ∈ N be given. The number z is the greatest common divisor of x and y iff z|x and z|y and there is no z′, with z′ > z, such that z′|x and z′|y. Here z|x ≡ ∃a ∈ N . a · z = x • The problem specification is not constructive \u0011 It does not describe how GCD should be computed \u0011 Euclid gave an algorithm to solve this, ca. 300 BC Functional Programming Spring Semester, 2025 David Basin 18 Imperative GCD public static int gcd (int x, int y) { while (x != y) { if (x > y) x = x - y; else y = y - x; } return x; } • Consists of control flow and assignment Assignment changes computer’s state • To understand gcd, one must understand how its state changes \u0011 Poor man’s reasoning: simulate and track memory content \u0011 Better: Hoare logic: {P} prog {Q} \u0011 Formal reasoning possible, but not so easy! See part II Functional Programming Spring Semester, 2025 David Basin 19 Functional GCD gcd x y | x == y = x | x > y = gcd (x - y) y | otherwise = gcd x (y - x) • Formalizes what should be computed, rather than how • Is this an algorithm? Yes, provided we have also specified how functions are executed • Examples \u0011 3 + (7 − 2) ; 3 + 5 ; 8 \u0011 gcd 4 6 ; gcd 4 2 ; gcd 2 2 ; 2 Functional Programming Spring Semester, 2025 David Basin 20 Basic concepts in functional programming • Functions and values \u0011 Functions compute values \u0011 Functions are values: can compute and return them • No side effects: f (x) always returns the same value. Compare: class Test { static int y = 0; /* class variable: shared by all objects */ static int f(int x) { y = y + 1; return y; } public static void main(String[] args) { System.out.println(f(0)); System.out.println(f(0)); } } Functional Programming Spring Semester, 2025 David Basin 21 Basic concepts (cont.) • Since no side effects, can reason as in mathematics Example: if f (0) = 2 then f (0) + f (0) = 2 + 2 = 4 • This property is called referential transparency: an expression evaluates to the same value in every context. \u0011 No assignments \u0011 No global variables \u0011 . . . • Easy to parallelize as computations cannot interfere. Functional Programming Spring Semester, 2025 David Basin 22 More basic concepts • Recursion instead of iteration gcd x y | x == y = x | x > y = gcd (x-y) y | otherwise = gcd x (y-x) public static int gcd (int x, int y) { while (x != y) { if (x > y) x = x - y; else y = y - x; } return x; } • Flexible type system \u0011 Avoids many kinds of programming errors (e.g., no runtime errors: 3 + True) \u0011 Polymorphism supports reusability sort [5,3,4] sort [\"hello\", \"there\", \"world\"] Functional Programming Spring Semester, 2025 David Basin 23 Functional programming: a short history • Lambda calculus: Church, 1930s \u0011 Provides a theoretical framework for describing functions and their evaluation \u0011 Equivalent to Turing machines in terms of computational power \u0011 Church-Turing thesis • LISP: McCarthy, 1960s \u0011 LISP = List processor. Lists as basic data structure Example: (”+”, 3, (”–”, 7, 2)) \u0011 Developed for symbolic computing/AI applications \u0011 Untyped \u0011 Although primitive, still actively used by AI programmers \u0011 Basis for OS, hardware, . . . (e.g. Symbolics Inc.) Functional Programming Spring Semester, 2025 David Basin 24 Short history (cont.) • FP: Backus 1978 (Turing Award Winning Lecture) \u0011 “Can Programming Be Liberated From the von Neumann Style?” \u0011 Programming based on building blocks and combinators \u0011 Ideas still relevant! How does one construct reusable software libraries? • ML: Milner 1980s \u0011 Powerful (polymorphic, static) type system \u0011 Sophisticated module system, for structuring “in the large” \u0011 Serious applications in industry and research using successor languages SML and OCaml. Competitive with OO-approach for complex software-engineering tasks. Functional Programming Spring Semester, 2025 David Basin 25 Short history (cont.) • Miranda: Turner 1985 Similar to ML but features lazy evaluation. Can compute with representations of \u0011 finite data, like [1,2,3,4,5] or [1 .. 5] \u0011 infinite data [1 ..] • Haskell: 1992 – present \u0011 State-of-art in functional PLs with lazy evaluation. \u0011 Many features, e.g., an advanced type system, efficient interpreters and compilers, huge library, . . . \u0011 Influenced other PLs, e.g., Rust, Java, Python, C#, F#, Scala \u0011 Can be naturally parallelized, good for multicore \u0011 In demand in industry! Functional Programming Spring Semester, 2025 David Basin 26 Using Haskell • We will use GHC, the Glasgow Haskell Compiler, version 9.2.5 • Features \u0011 Open source \u0011 Easy to install on many systems \u0011 Has an interactive interpreter: ghci \u0011 Has a compiler producing optimized code • Actively supported and used in many real-world projects • See www.haskell.org for binaries, libraries, documentation, ... Functional Programming Spring Semester, 2025 David Basin 27 Introduction to functional programming • Idea based on computing with expressions 3 + (7 − 2) ; 8 The computer functions like an ordinary calculator • Functions can be defined ? :load gcd.hs • and executed ? gcd 4 6 2 Functional Programming Spring Semester, 2025 David Basin 28 ghci — demo ? 3 + (7 - 2) 8 ? 2 + 4 == 1 + 2 + 3 True ? 2 + True ERROR: ... ? head [1,2,3] 1 ? tail [1,2,3] [2,3] ? :load gcd.hs ? gcd 10 15 5 Functional Programming Spring Semester, 2025 David Basin 29 Expression evaluation • In mathematics, e.g., f (x, y) = x − y. Compute f (5, 7) by substituting 5 for x and 7 for y and continue evaluation. f (5, 7) = 5 − 7 = −2 gcd x y | x == y = x | x > y = gcd (x-y) y | otherwise = gcd x (y-x) • Same holds for Haskell: gcd 10 15 = gcd 10 (15 − 10) case 3 (otherwise) = gcd 10 5 as 5 = 15 − 10 = gcd (10 − 5) 5 case 2 (10 > 5) = gcd 5 5 as 5 = 10 − 5 = 5 case 1 (5 == 5) Functional Programming Spring Semester, 2025 David Basin 30 Evaluation: strategies For the program: diff x y = x - y diff (1 + 2) (3 + 4) diff 3 (3 + 4) diff (1 + 2) 7 (1 + 2) − (3 + 4) diff 3 7 3 − (3 + 4) (1 + 2) − 7 3 − 7 −4 • Eager evaluation: evaluate arguments first \u0011 Also called “call-by-value” \u0011 Corresponds to left path in picture • Lazy evaluation: evaluate arguments only when needed (Haskell) \u0011 Also called “call-by-need” or “left-most/outermost” \u0011 Certain functions force evaluation, e.g., arithmetic \u0011 We will study this in detail later Functional Programming Spring Semester, 2025 David Basin 31 Syntax and Types Functional Programming Spring Semester, 2025 David Basin 32 Introduction to syntax gcd x y -- functions and arguments start with lower-case letter | x == y = x | x > y = gcd (x-y) y -- arguments written in sequence & | otherwise = gcd x (y-x) -- separated by whitespace • Function consists of different cases: functionName x1 ... xn | guard1 = expr1 : | guardm = exprm • Program consists of several definitions: myConstant = 5 aFunction y1 ... ym | guard1 = expr1 | guard2 = expr2 anotherFunction z1 ... zk = ... Functional Programming Spring Semester, 2025 David Basin 33 2D layout • Indentation determines separation of definitions: \u0011 All function definitions must start at same indentation level. \u0011 If a definition requires n > 1 lines, indent lines 2 to n further. • Recommended layout: f1 x1 x2 | a long guard which may go over a number of lines = a long expression that also can go over several lines | g2 = e2 f2 x1 x2 x3 = ... • Erroneous layout: square x = x * x cube x = x * x * x -- parse error on input ‘=’ • Spaces are important. Do not use TABs! Functional Programming Spring Semester, 2025 David Basin 34 Types • Haskell is a strongly typed language • Types avoid runtime errors, like 3 + True • Either programmer provides types along with function definition gcd :: Int -> Int -> Int or system computes types itself • Function/argument types must “match” (formal account later) ? gcd 3 True <interactive>:1:1: error: • No instance for (Integral Bool) arising from a use of ‘gcd’ • In the expression: gcd True 3 In an equation for ‘it’: it = gcd True 3 Functional Programming Spring Semester, 2025 David Basin 35 Type Int • Values: 0, 1, 2, . . . , −1, −2, . . . Int type with at least the range {−229, . . . , 229 − 1} Support for unbounded integers and arithmetic: Integer • Functions: +, *, ^, -, div, mod, abs ? mod 7 2 1 • An infix binary function is also called an “operator” ? 7 ‘mod‘ 2 1 • Operators can also be written in prefix notation ? + 3 4 <interactive>:1:1: parse error on input ‘+’ ? (+) 3 4 7 Functional Programming Spring Semester, 2025 David Basin 36 Type Int (cont.) • Operators have different binding strength ? 2 + 3 ^ 4 -- ^ binds stronger than + 83 ? (2 + 3) ^ 4 625 • Order and equality return True or False of type Bool > greater than >= greater than or equal == equal /= unequal <= less than or equal < less than Functional Programming Spring Semester, 2025 David Basin 37 Type Bool • Values: True, False • Binary operators &&, ||, and unary function not as expected ? True && False False ? (10 < 1) || (10 == 1) || (10 > 1) True ? not (9 >= 7) || (3 /= 3) -- not binds stronger than && and || False ? (3 > 5) == (7 < 6) -- (==) on Bool is \"if and only if\" True Functional Programming Spring Semester, 2025 David Basin 38 Examples of function definition — XOR • xor defined using other operators: xor x y = (x || y) && not (x && y) • xor defined using guards: xor x y | x = not y | otherwise = y • xor defined using multiple cases (new): xor True True = False xor True False = True xor False True = True xor False False = False • Cases can contain variables (“patterns”): xor True y = not y xor False y = y Functional Programming Spring Semester, 2025 David Basin 39 Types Char, String, and Double Char: ’a’, ’b’, ..., ’0’, ’1’, ..., ’\\t’, ’\\n’. ? ord ’a’ --- requires Char module loaded with :module Data.Char 97 ? chr 97 ’a’ String: \"hello\", \"123\", \"a\". ? \"Hello \" ++ \"there\" \"Hello there\" Double: 0.3456, -2.85e03 = −2.85 ∗ 103, . . . Functions like +, -, *, /, abs, acos, asin, ceiling, ... For documentation see: https://hackage.haskell.org https://hackage.haskell.org/package/base/docs/Prelude.html Functional Programming Spring Semester, 2025 David Basin 40 Type tuple • Name reflects: pair, triple, 4-tuple, ... \u0011 Used to model composite objects (“records”) • Example: Student has name, ID number, starting year Type (String, Int, Int) with element (\"Ueli Naef\", 1234, 2015) • First example of a type constructor \u0011 if T1, . . . , Tn are types, then (T1, . . . , Tn) is a (tuple) type. e.g., (Int, String, Bool) \u0011 if v1 :: T1, . . . , vn :: Tn then (v1, . . . , vn) :: (T1, . . . , Tn) e.g., (3, \"hi\", True) :: (Int, String, Bool) \u0011 N.B.: n ≥ 2, i.e., (\"foo\") is not a tuple. \u0011 We can nest tuples: (3, (\"hi\", True)) :: (Int, (String, Bool)) Functional Programming Spring Semester, 2025 David Basin 41 Tuples • Functions can take tuples as arguments or return tupled values addPair :: (Int, Int) -> Int addPair (x, y) = x + y ? addPair (3, 4) 7 • Patterns can be nested shift :: ((Int, Int), Int) -> (Int, (Int, Int)) shift ((x, y), z) = (x, (y, z)) • Pattern matching can be used to decompose tuples name (s, id, y) = s studentNumber (s, id, y) = id year (s, id, y) = y or (probably not sensible) silly (s, id, y) = id + 2 * y Functional Programming Spring Semester, 2025 David Basin 42 Patterns and function definition • Function definition built from both patterns mi and guards gi fun m1 m2 ... mn | g1 = e1 : | gm = em | otherwise = e -- optional! \u0011 Patterns mi are variables, constants, or built from data constructors (like tuples) \u0011 Guards gi are Boolean expressions • Example: silly b (x, y) pair = (4, 2) | b = x + y silly (not True) pair | otherwise = x * y Functional Programming Spring Semester, 2025 David Basin 43 Functions: scope • Global scope: a function can be called from any other f x y = ... g x = ... h ... h z = ... f ... g ... • Local scope with “let” and “where” let x1 = e1 : xn = en in e • let builds one expression from others: \u0011 xi can bind a variable or a (local) function \u0011 Local definitions may refer to each other Functional Programming Spring Semester, 2025 David Basin 44 Functions: scope (cont.) • Example: f x = let sq y = y * y in sq x + sq x We can evaluate f 10, but not sq 10 let y = a * b f x = (x + y) / 2 in f c + f d Functional Programming Spring Semester, 2025 David Basin 45 Local scope after a function definition: where f p1 p2 ... pm | g1 = e1 | g2 = e2 : | gk = ek where v1 a1 ... an = r1 v2 = r2 : N.B. • “where” comes directly after a function definition • Bindings defined over all guards and expressions Functional Programming Spring Semester, 2025 David Basin 46 Program definition with local definitions • Let’s define a function that takes three numbers and returns the largest and how often it occurs maxThreeOccurs :: Int -> Int -> Int -> (Int, Int) • Top-down development maxThreeOccurs n m p = (maxVal, maxCount) where maxVal = max3 n m p maxCount = count maxVal n m p • Then write the new subroutines max3 a b c = max a (max b c) count val n m p = isval n + isval m + isval p where isval x | x == val = 1 | otherwise = 0 Functional Programming Spring Semester, 2025 David Basin 47 Example (cont.) • Alternative structure where all definitions are local maxThreeOccurs n m p = (maxVal, maxCount) where maxVal = max3 n m p maxCount = count maxVal n m p count val n m p = ... max3 a b c = max a (max b c) • Which program is better? \u0011 No general answer \u0011 Depends on how general the defined functions are Functional Programming Spring Semester, 2025 David Basin 48 2D layout for let and where • let and where open blocks for local definitions. Layout rule applies here, too. \u0011 First definition determines indentation for all definitions in block. \u0011 Multi-line definitions must indent more. \u0011 Less indentation closes block. maxThreeOccurs n m p = (maxVal, maxCount) where maxVal = max3 n m p maxCount = count maxVal n m p count val n m p = isval n + isval m + isval p where isval n -- isval local to count | n == val = 1 | otherwise = 0 max3 a b c = max a (max b c) • Spaces are important. Do not use TABs! Functional Programming Spring Semester, 2025","libVersion":"0.5.0","langs":""}