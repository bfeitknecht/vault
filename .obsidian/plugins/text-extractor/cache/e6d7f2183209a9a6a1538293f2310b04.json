{"path":"sem2a/AuW/UE/u/s/AuW-u05-s.pdf","text":"ETH Z¨urich Institute of Theoretical Computer Science Prof. Rasmus Kyng Prof. Angelika Steger FS 2024 Algorithmen und Wahrscheinlichkeit Theorie-Aufgaben 5 L¨osung zu Aufgabe 1 Wir erinnern uns an den Algorithmus LocalRepair aus der Vorlesung. Die Punkte werden in LocalRepair zuerst sortiert, und dann werden die unteren und oberen konvexen H¨ullen berech- net. Die Laufzeit von LocalRepair ist O(n log n), inklusive dem Sortieren. In dieser ¨Ubung sehen wir Beispiele von Punktemengen, f¨ur die wir die konvexe H¨ulle in Zeit O(n) berechnen k¨onnen. (a) Wir bekommen Punkte s1, s2, . . . sn, sortiert nach ihrer x-Koordinate. Wir k¨onnen den Teil des Algorithmus LocalRepair nach dem sortieren direkt auf s1, s2, . . . sn anwenden um die konvexe H¨ulle zu bekommen. Die Korrektheit wurde in der Vorlesung gezeigt. Die Laufzeit ist nur O(n), da wir die Punkte nicht sortieren m¨ussen. (b) Die entscheidende Annahme die wir hier ausnutzen ist, dass der Streckenzug, der von den Punkten c1, c2, . . . , cn gebildet wird, sich nicht selbst schneidet. Wir bemerken zuerst, dass der Algorithmus aus (a) nicht mehr funktioniert, da er neue ¨Uberschneidungen produzieren kann, diese jedoch nicht entfernt: c1c7c2c3c4c5c1c7c2c3c4c5Iteration 1: Point c2 is discardedc1c7c2c3c4c5Iteration 2: Point c4 is added,c1c7c2c3c4c5Iteration 3: Point c5 is added,c1c7c2c3c4c5Iteration 3: Point c6 is added,c6c6c6c6c6c1c7c2c3c4c5Iteration 3: Point c7 is added,c6no point discardedno point discardedno point discardedno point discardedPoint set CThe ﬁnal lower convex hull isc1, c3, c4, c5, c6, c7which intersects itself,and is a wrong solution. L¨osung: Wir betrachten das Liniensegment cn, c1 und nehmen zun¨achst an, dass alle anderen Punkte sich links davon beﬁnden. Wir ﬁnden nun der Reihe nach f¨ur alle i zwischen 1 und n − 1 jeweils eine Teilfolge Hi der Punkte cn, c1, c2, . . . , ci, so dass Hi ein konvexes Polygon beschreibt (jeder Punkt von Hi liegt also links des Liniensegments, welches von den beiden vorherigen Punkten gebildet wird), und alle Punkte cn, c1, . . . , ci in/auf einem der Polygone Hi oder Hi, ci+1, ci+2, . . . , cn−1 liegen. F¨ur cn, c1 w¨ahlen wir H1 einfach als cn, c1, und sowohl cn wie auch c1 werden in jedem Schritt Teil von Hi bleiben, da sie extremale x-Koordinaten haben. F¨ur i = 2, . . . , n−1 wollen wir Hi−1 jeweils um einen weiteren Punkt ci erweitern. Falls der neue Punkt ci nicht im Inneren von Hi−1 ist, dann machen wir ci Teil von Hi. Sei p der zweitletzte Punkt von Hi−1 und q der letzte Punkt von Hi−1. Da sich der Streckenzug cn, c1, c2, . . . , ci nicht selbst schneidet, liegt ci in diesem Fall entweder rechts von p, q oder rechts von q, cn. Daher reicht es aus, diese beiden Liniensegmente zu ¨uberpr¨ufen: Ist ci links von beiden davon, so liegt ci bereits im Inneren von Hi−1, dann haben wir einfach Hi = Hi−1. Andernfalls entfernen wir so lange Punkte am Ende von Hi−1, bis ci links des Liniensegmentes vom zweitletzten zum letzten Punkt der erhaltenen Folge H ′ i−1 ist. Wir k¨onnen dann ci am Ende von H ′ i−1 einf¨ugen. Die so erhaltene Folge ist Hi. Alle Punkte im Polygon Hi−1, ci, ci+1, . . . , cn−1 liegen auch im Polygon Hi, ci+1, . . . , cn−1, da sich der Streckenzug cn, c1, c2, . . . , ci nicht selbst schneidet. Es kann allerdings Punkte in c2, c3, . . . , ci−1 geben, die in Hi−1 sind aber nicht in Hi, jedoch werden diese von Hi, ci+1, . . . , cn−1 noch einmal umschlossen. Daher bleibt unsere Invariante erhalten. Nach einigen Iterationen erhalten wir so Hn−1, ein konvexes Polygon das alle gegebenen Punk- te enth¨alt und dessen Ecken eine Teilfolge von cn, c1, c2, . . . , cn−1 sind. Daher ist Hn−1 die konvexe H¨ulle dieser Punkte. Falls es nun aber doch Punkte gibt, die rechts des Liniensegments cn, c1 liegen, so werden diese von diesem Algorithmus einfach verworfen. In diesem Fall berechnet er also nur die konvexe H¨ulle der Punktemenge geschnitten mit der Halbebene links des Liniensegments cn, c1. Wir k¨onnen den Algorithmus also einfach zweimal anwenden, einmal auf die Folge cn, c1, c2, . . . , cn−1 und einmal auf die Folge c1, cn, cn−1, . . . , c2 und die beiden Resultate ent- lang c1, cn aneinanderf¨ugen, indem wir jeweils den ersten Punkt der beiden konvexen H¨ullen entfernen und die Resultate konkatenieren. Mithilfe von Stacks l¨asst sich dieser Algorithmus in Zeit O(n) implementieren, ¨ahnlich wie wir das bei LocalRepair bereits gesehen haben. (c) Algorithmus: Wir iterieren ¨uber die Punkte p1, p2, . . . , pn und ﬁnden die Punkte pℓ und pr mit der kleinsten und gr¨ossten x-Koordinate. Wir verschieben die Punkte p1, p2, . . . , pn dann zirkul¨ar, um die Folge pℓ, pℓ+1, . . . , pr, pr+1 . . . , pℓ−1 zu erhalten. Wir lassen den ent- sprechenden Teil des Algorithmus von (b) mit Eingabe pℓ, pℓ+1, . . . , pr laufen, um die untere konvexe H¨ulle von P zu berechnen, sowie mit pr, pr+1 . . . , pℓ um die obere konvexe H¨ulle von P zu berechnen. Wir f¨ugen die beiden Teile dann zusammen. (Gibt es mehrere Punkte mit minimalen bzw. maximalen x-Koordinaten, so k¨onnen wir f¨ur die untere konvexe H¨ulle die x-extremalen Punkte mit minimalen y-Koordinaten w¨ahlen und f¨ur die obere konvexe H¨ulle die mit maximalen y-Koordinaten.) Laufzeit: Die Berechnung der Punkte pℓ und pr ben¨otigt Zeit O(n). Wir lassen dann den Al- gorithmus von (b) zweimal laufen, was Zeit O(n) braucht. Insgesamt ist die Laufzeit also O(n). Korrektheit: Wir zerteilen das Polygon in zwei Streckenz¨uge und berechnen die untere und obere konvexe H¨ulle separat. Die Korrektheit unseres Algorithmus folgt aus der Korrektheit des Algorithmus aus (b), sowie daraus, dass sich P nicht selbst ¨uberschneidet und daher der untere Streckenzug sich nie komplett ¨uber dem oberen Streckenzug beﬁnden kann.","libVersion":"0.3.2","langs":""}