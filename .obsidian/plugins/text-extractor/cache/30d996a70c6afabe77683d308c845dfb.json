{"path":"sem4/FMFP/pvw/FMFP-pvw-s02.pdf","text":"Formal Methods and Functional Programming PVW July 14-19, 2025 Wochenplan Dienstag Heute auf dem Programm ▶ Natural Deduction ▶ Induction ▶ Mathematic ▶ Structural First Order Logic (FOL) ▶ FOL wird gebrauch um Formeln zu schreiben (∧, ∨, ¬, ∀, ∃) ▶ Wir unterscheiden zwischen free variables und captured variables. ∃x . p(x, y ) =⇒ q(x) ▶ Structures besteht aus: ▶ Universe für die Variablen ▶ Definition von Prädikaten und Funktionen. ▶ Eine Formel, welche für jede Structure wahr ist, nennen wir eine tautologie oder valid. Eine Formel, welche nie wahr ist, nennen wir unerfüllbar. ▶ (∀x . p(x)) ∨ (∃y . ¬p(y )) ▶ A ∧ ¬A ▶ (∀x .p(x)) ∧ (∃y .p(y ) ∧ q(y )) First Order Logic (FOL) ▶ FOL wird gebrauch um Formeln zu schreiben (∧, ∨, ¬, ∀, ∃) ▶ Wir unterscheiden zwischen free variables und captured variables. ∃x . p(x, y ) =⇒ q(x) ▶ Structures besteht aus: ▶ Universe für die Variablen ▶ Definition von Prädikaten und Funktionen. ▶ Eine Formel, welche für jede Structure wahr ist, nennen wir eine tautologie oder valid. Eine Formel, welche nie wahr ist, nennen wir unerfüllbar. ▶ (∀x . p(x)) ∨ (∃y . ¬p(y )) ▶ A ∧ ¬A ▶ (∀x .p(x)) ∧ (∃y .p(y ) ∧ q(y )) First Order Logic (FOL) ▶ FOL wird gebrauch um Formeln zu schreiben (∧, ∨, ¬, ∀, ∃) ▶ Wir unterscheiden zwischen free variables und captured variables. ∃x . p(x, y ) =⇒ q(x) ▶ Structures besteht aus: ▶ Universe für die Variablen ▶ Definition von Prädikaten und Funktionen. ▶ Eine Formel, welche für jede Structure wahr ist, nennen wir eine tautologie oder valid. Eine Formel, welche nie wahr ist, nennen wir unerfüllbar. ▶ (∀x . p(x)) ∨ (∃y . ¬p(y )) ▶ A ∧ ¬A ▶ (∀x .p(x)) ∧ (∃y .p(y ) ∧ q(y )) First Order Logic (FOL) ▶ FOL wird gebrauch um Formeln zu schreiben (∧, ∨, ¬, ∀, ∃) ▶ Wir unterscheiden zwischen free variables und captured variables. ∃x . p(x, y ) =⇒ q(x) ▶ Structures besteht aus: ▶ Universe für die Variablen ▶ Definition von Prädikaten und Funktionen. ▶ Eine Formel, welche für jede Structure wahr ist, nennen wir eine tautologie oder valid. Eine Formel, welche nie wahr ist, nennen wir unerfüllbar. ▶ (∀x . p(x)) ∨ (∃y . ¬p(y )) ▶ A ∧ ¬A ▶ (∀x .p(x)) ∧ (∃y .p(y ) ∧ q(y )) First Order Logic (FOL) ▶ FOL wird gebrauch um Formeln zu schreiben (∧, ∨, ¬, ∀, ∃) ▶ Wir unterscheiden zwischen free variables und captured variables. ∃x . p(x, y ) =⇒ q(x) ▶ Structures besteht aus: ▶ Universe für die Variablen ▶ Definition von Prädikaten und Funktionen. ▶ Eine Formel, welche für jede Structure wahr ist, nennen wir eine tautologie oder valid. Eine Formel, welche nie wahr ist, nennen wir unerfüllbar. ▶ (∀x . p(x)) ∨ (∃y . ¬p(y )) ▶ A ∧ ¬A ▶ (∀x .p(x)) ∧ (∃y .p(y ) ∧ q(y )) Natural Deduction ▶ ∧ binds stronger than ∨ stronger than →. ▶ → associates to the right; ∧ and ∨ to the left. ▶ Negation binds stronger than binary operators. ▶ Quantifiers extend to the right as far as possible. Example: ∀x.P → Q → A ∧ B ∧ ¬C Solution: ∀x.(P → (Q → ((A ∧ B) ∧ (¬C)))) Es kann jeweils nur auf den äussersten Operator eine Regel angewendet werden. ∀x. P → Q (∀x. P) → Q Γ ⊢ ∀x → P Q vs. Γ ⊢ → ∀x P Q Natural Deduction ▶ ∧ binds stronger than ∨ stronger than →. ▶ → associates to the right; ∧ and ∨ to the left. ▶ Negation binds stronger than binary operators. ▶ Quantifiers extend to the right as far as possible. Example: ∀x.P → Q → A ∧ B ∧ ¬C Solution: ∀x.(P → (Q → ((A ∧ B) ∧ (¬C)))) Es kann jeweils nur auf den äussersten Operator eine Regel angewendet werden. ∀x. P → Q (∀x. P) → Q Γ ⊢ ∀x → P Q vs. Γ ⊢ → ∀x P Q Natural Deduction ▶ ∧ binds stronger than ∨ stronger than →. ▶ → associates to the right; ∧ and ∨ to the left. ▶ Negation binds stronger than binary operators. ▶ Quantifiers extend to the right as far as possible. Example: ∀x.P → Q → A ∧ B ∧ ¬C Solution: ∀x.(P → (Q → ((A ∧ B) ∧ (¬C)))) Es kann jeweils nur auf den äussersten Operator eine Regel angewendet werden. ∀x. P → Q (∀x. P) → Q Γ ⊢ ∀x → P Q vs. Γ ⊢ → ∀x P Q Natural Deduction ▶ ∧ binds stronger than ∨ stronger than →. ▶ → associates to the right; ∧ and ∨ to the left. ▶ Negation binds stronger than binary operators. ▶ Quantifiers extend to the right as far as possible. Example: ∀x.P → Q → A ∧ B ∧ ¬C Solution: ∀x.(P → (Q → ((A ∧ B) ∧ (¬C)))) Es kann jeweils nur auf den äussersten Operator eine Regel angewendet werden. ∀x. P → Q (∀x. P) → Q Γ ⊢ ∀x → P Q vs. Γ ⊢ → ∀x P Q Natural Deduction ▶ ∧ binds stronger than ∨ stronger than →. ▶ → associates to the right; ∧ and ∨ to the left. ▶ Negation binds stronger than binary operators. ▶ Quantifiers extend to the right as far as possible. Example: ∀x.P → Q → A ∧ B ∧ ¬C Solution: ∀x.(P → (Q → ((A ∧ B) ∧ (¬C)))) Es kann jeweils nur auf den äussersten Operator eine Regel angewendet werden. ∀x. P → Q (∀x. P) → Q Γ ⊢ ∀x → P Q vs. Γ ⊢ → ∀x P Q Natural Deduction ▶ ∧ binds stronger than ∨ stronger than →. ▶ → associates to the right; ∧ and ∨ to the left. ▶ Negation binds stronger than binary operators. ▶ Quantifiers extend to the right as far as possible. Example: ∀x.P → Q → A ∧ B ∧ ¬C Solution: ∀x.(P → (Q → ((A ∧ B) ∧ (¬C)))) Es kann jeweils nur auf den äussersten Operator eine Regel angewendet werden. ∀x. P → Q (∀x. P) → Q Γ ⊢ ∀x → P Q vs. Γ ⊢ → ∀x P Q Natural Deduction RulesND Üben ▶ (∀x y . p(x, y )) → (∀b a. p(a, b)) ▶ ∃x. P ⊢ ¬(∀x. ¬P) ▶ (∃x. P ∧ Q) → ∃x.P ▶ ∀x y z. p(x, y )∧p(y , z) → p(x, z), p(a, b), p(b, c) ⊢ p(a, c) Online tool fmfp.ramonwick.ch (macht die, welche likes haben) Induction Zwei Arten von Induktion: ▶ Mathematical Induction. Die Aussage wird über Zahlen gemacht. Für jede Zahl gibt es eine primzahl die grösser ist. ▶ Structural Induction. Die Aussage wird über eine Struktur gemacht. Jeder Liste ... oder jeder Tree... Induktion Es gibt zwei Strategien: Structural Induction (weak) Figure: Die genaue Regel hängt vom ADT ab. ▶ Welche sind Base Cases? ▶ Welche sind Induction Steps? Strong Structural Induction Schema L e t P := ∀vars [ Statement we want t o prove ] We prove ∀e.P by weak s t r u c t u r a l i n d u c t i o n L e t e be a r b i t r a r y b u t f i x e d Base Case 1 : e = Var s f o r some s We show t h a t P [ t −> Var s ] h o l d s . [ L e t v a r s be a r b i t r a r y ] [ P r o o f ] Step Cases : e = Add e1 e2 f o r some e1 e2 We assume t h a t P [ e −> e1 ] and P [ e −> e2 ] ( I .H) and show P [ t −> Add e1 e2 ] [ L e t v a r s be a r b i t r a r y ] [ P r o o f ] Example ExerciseÜben ▶ Exercise Sheet 4, 1 ▶ PVW Script: HandsOn 5 Language Semantics ▶ Grosses Thema (Big + Small Step Semantics) ▶ Definiert formal wie eine Programmiersprache funktioniert. ▶ An Beispielsprache IMP IMP Was wir haben: ▶ Expressions (Boolean, Arithmetic) ▶ Variables (only Integers, always defined) Was wir nicht haben: ▶ Heap allocation and pointers ▶ Variable declarations ▶ Procedures ▶ Concurrency Bei Aufgaben wird IMP oft ergänzt. IMP Was wir haben: ▶ Expressions (Boolean, Arithmetic) ▶ Variables (only Integers, always defined) Was wir nicht haben: ▶ Heap allocation and pointers ▶ Variable declarations ▶ Procedures ▶ Concurrency Bei Aufgaben wird IMP oft ergänzt. Syntax von IMP Expressions Aexp = ′( ′ Aexp Op Aexp ′) ′ | Var | Numeral Op = ′+ ′ | ′− ′ | ′∗ ′ Bexp = ′( ′ Bexp or Bexp ′)′ | ′( ′ Bexp and Bexp ′) ′ | ’not’ Bexp | Aexp Rop Aexp Rop = ′ = ′ | ′# ′ | ′ < ′ | ′ <= ′ | ′ > ′ | ′ >= ′ Syntax von IMP Statements Stm = ’skip’ | Var ′:= ′ Aexp | ′(′Stm ′; ′ Stm ′) ′ | ’if’ Bexp ’then’ Stm ’else’ Stm ’end’ | ’while’ Bexp ’do’ Stm ’end’ Hint: \"We omit parentheses if permitted by the usual operator precedence\" Meta VariablesSemantics ▶ Bis jetzt haben wir den Syntax (was man schreiben darf) ▶ Mit der Semantics definieren wir was das geschriebene bedeutet. ▶ Dafür haben wir funktionen, welche expressions und statements in die logik welt bringen. Semantics Numerals N : Numeral → Val nimmt ein numeral n und mapt es zu N [[n]] Beispiel ▶ N [[’123’]] = 123 ▶ N [[’012’]] = 12 Semantics State σ : Var → Val Der Programm State σ mappt alle variablen zu einem value (natürliche Zahl). Wir können States auch updaten: (σ[x → y ])(z) = { y if x = z σ(z) else Zwei States können gleich sein.: σ1 = σ2 ⇐⇒ ∀x.σ1(x) = σ2(x) ▶ σ[x → 1] = σ[x → 0][x → 1]? ▶ σ[x → 1][y → 2](x) = ? Semantics State σ : Var → Val Der Programm State σ mappt alle variablen zu einem value (natürliche Zahl). Wir können States auch updaten: (σ[x → y ])(z) = { y if x = z σ(z) else Zwei States können gleich sein.: σ1 = σ2 ⇐⇒ ∀x.σ1(x) = σ2(x) ▶ σ[x → 1] = σ[x → 0][x → 1]? ▶ σ[x → 1][y → 2](x) = ? Semantics State σ : Var → Val Der Programm State σ mappt alle variablen zu einem value (natürliche Zahl). Wir können States auch updaten: (σ[x → y ])(z) = { y if x = z σ(z) else Zwei States können gleich sein.: σ1 = σ2 ⇐⇒ ∀x.σ1(x) = σ2(x) ▶ σ[x → 1] = σ[x → 0][x → 1]? ▶ σ[x → 1][y → 2](x) = ? Semantics State σ : Var → Val Der Programm State σ mappt alle variablen zu einem value (natürliche Zahl). Wir können States auch updaten: (σ[x → y ])(z) = { y if x = z σ(z) else Zwei States können gleich sein.: σ1 = σ2 ⇐⇒ ∀x.σ1(x) = σ2(x) ▶ σ[x → 1] = σ[x → 0][x → 1]? ▶ σ[x → 1][y → 2](x) = ? Semantics Expression A : Aexp → State → Val maps an arithmetische Expression und einen State zum Wert A[[e]]σ Rekursiv definiert: 1. Variable: A[[x]]σ = σ(x) 2. Numberal: A[[n]]σ = N [[n]] 3. Operation: A[[e1 op e2]]σ = A[[e1]]σ ¯op A[[e2]]σ Beispiel: σ1 = σzero[x → 3][y → 9] A[[(x + 1) ∗ y ]]σ1 =? Semantics Expression A : Aexp → State → Val maps an arithmetische Expression und einen State zum Wert A[[e]]σ Rekursiv definiert: 1. Variable: A[[x]]σ = σ(x) 2. Numberal: A[[n]]σ = N [[n]] 3. Operation: A[[e1 op e2]]σ = A[[e1]]σ ¯op A[[e2]]σ Beispiel: σ1 = σzero[x → 3][y → 9] A[[(x + 1) ∗ y ]]σ1 =? Semantics Expression A : Aexp → State → Val maps an arithmetische Expression und einen State zum Wert A[[e]]σ Rekursiv definiert: 1. Variable: A[[x]]σ = σ(x) 2. Numberal: A[[n]]σ = N [[n]] 3. Operation: A[[e1 op e2]]σ = A[[e1]]σ ¯op A[[e2]]σ Beispiel: σ1 = σzero[x → 3][y → 9] A[[(x + 1) ∗ y ]]σ1 =? Semantics Expression A : Aexp → State → Val maps an arithmetische Expression und einen State zum Wert A[[e]]σ Rekursiv definiert: 1. Variable: A[[x]]σ = σ(x) 2. Numberal: A[[n]]σ = N [[n]] 3. Operation: A[[e1 op e2]]σ = A[[e1]]σ ¯op A[[e2]]σ Beispiel: σ1 = σzero[x → 3][y → 9] A[[(x + 1) ∗ y ]]σ1 =? Semantics Expression A : Aexp → State → Val maps an arithmetische Expression und einen State zum Wert A[[e]]σ Rekursiv definiert: 1. Variable: A[[x]]σ = σ(x) 2. Numberal: A[[n]]σ = N [[n]] 3. Operation: A[[e1 op e2]]σ = A[[e1]]σ ¯op A[[e2]]σ Beispiel: σ1 = σzero[x → 3][y → 9] A[[(x + 1) ∗ y ]]σ1 =? Semantics Expression A : Aexp → State → Val maps an arithmetische Expression und einen State zum Wert A[[e]]σ Rekursiv definiert: 1. Variable: A[[x]]σ = σ(x) 2. Numberal: A[[n]]σ = N [[n]] 3. Operation: A[[e1 op e2]]σ = A[[e1]]σ ¯op A[[e2]]σ Beispiel: σ1 = σzero[x → 3][y → 9] A[[(x + 1) ∗ y ]]σ1 =? Semantics Expression A : Aexp → State → Val maps an arithmetische Expression und einen State zum Wert A[[e]]σ Rekursiv definiert: 1. Variable: A[[x]]σ = σ(x) 2. Numberal: A[[n]]σ = N [[n]] 3. Operation: A[[e1 op e2]]σ = A[[e1]]σ ¯op A[[e2]]σ Beispiel: σ1 = σzero[x → 3][y → 9] A[[(x + 1) ∗ y ]]σ1 =? Free Variables Arithmetic Expressions: Boolean Expressions: Statements: Substitution Wir brauchen noch eine Schreibweise um Terme zu ersetzten. Die Schreibweise ist nichts Neues: “[x → e]” replaces each free occurrence of variable x by e Arithmetic expressions: Boolean expressions: Exercise ▶ (x + 1)[x → y ] = ? ▶ A[[(x + 1) + (y − 1)]](σzero[x → 2]) = ? ▶ σzero[x → A[[(y + 1)[y → 3]]]σzero](x) = ? ÜbungÜben ▶ Session Sheet 9 ▶ Exercise Sheet 9","libVersion":"0.5.0","langs":""}