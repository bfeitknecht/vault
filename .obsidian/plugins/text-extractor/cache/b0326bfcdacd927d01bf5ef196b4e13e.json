{"path":"sem3/AuD/UE/e/AuD-u03-e.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 9 October 2023 Johannes Lengler, David Steurer Lucas Slot, Manuel Wiedmer, Hongjie Chen, Ding Jingqiu Algorithms & Data Structures Exercise sheet 3 HS 23 The solutions for this sheet are submitted at the beginning of the exercise class on 16 October 2023. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. Asymptotic Notation The following two definitions are closely related to the O-notation and are also useful in the running time analysis of algorithms. Let N be again a set of possible inputs. Definition 1 (Ω-Notation). For f : N → R+, Ω(f ) := {g : N → R+ | f ≤ O(g)}. We write g ≥ Ω(f ) instead of g ∈ Ω(f ). Definition 2 (Θ-Notation). For f : N → R+, Θ(f ) := {g : N → R+ | g ≤ O(f ) and f ≤ O(g)}. We write g = Θ(f ) instead of g ∈ Θ(f ). In other words, for two functions f, g : N → R+ we have g ≥ Ω(f ) ⇔ f ≤ O(g) and g = Θ(f ) ⇔ g ≤ O(f ) and f ≤ O(g). We can restate Theorem 1 from exercise sheet 2 as follows. Theorem 1 (Theorem 1.1 from the script). Let N be an infinite subset of N and f : N → R+ and g : N → R+. • If lim n→∞ f (n) g(n) = 0, then f ≤ O(g), but f ̸= Θ(g). • If lim n→∞ f (n) g(n) = C ∈ R+, then f = Θ(g). • If lim n→∞ f (n) g(n) = ∞, then f ≥ Ω(g), but f ̸= Θ(g). Exercise 3.1 Asymptotic growth (2 points). For all the following functions the variable n ranges over N. (a) Prove or disprove the following statements. Justify your answer. (1) 1 5 n3 ≥ Ω(10n2) (2) n2 + 3n = Θ(n2 log(n)) (3) 5n4 + 3n2 + n + 8 = Θ(n4) (4) 3n ≥ Ω(2n) (b) Prove the following statements. Hint: For these examples, computing the limits as in Theorem 1 is hard or the limits do not even exist. Try to prove the statements directly with inequalities as in the definition of the O-notation. (1) (sin(n) + 2)n = Θ(n) Hint: For any x ∈ R we have −1 ≤ sin(x) ≤ 1. (2) ∑n i=1 ∑i j=1 j = Θ(n3) Hint: In order to show n3 ≤ O(∑n i=1 ∑i j=1 j), you can use exercise 1.3. (3) log(n4 + n3 + n2) ≤ O(log(n3 + n2 + n)) (4)* ∑n i=1 √ i = Θ(n√n) Hint: Recall again exercise 1.3 and try to do an analogous computation here. Exercise 3.2 Substring counting. Given a n-bit bitstring S (an array over {0, 1} of size n ∈ N), and an integer k ≥ 0, we would like to count the number of nonempty substrings of S with exactly k ones. For example, when S = “0110” and k = 2, there are 4 such substrings: “011”, “11”, “110”, and “0110”. (a) Design a “naive” algorithm that solves this problem with a runtime of O(n3). Justify its runtime and correctness. (b) We say that a bitstring S′ is a (non-empty) prefix of a bitstring S if S′ is of the form S[0..i] where 0 ≤ i < length(S). For example, the prefixes of S = “0110” are “0”, “01”, “011” and “0110”. Given a n-bit bitstring S, we would like to compute a table T indexed by 0..n such that for all i, T [i] contains the number of prefixes of S with exactly i ones. For example, for S = “0110”, the desired table is T = [1, 1, 2, 0, 0], since, of the 4 prefixes of S, 1 prefix contains zero “1”, 1 prefix contains one “1”, 2 prefixes contain two “1”, and 0 prefix contains three “1” or four “1”. Describe an algorithm prefixtable that computes T from S in time O(n), assuming S has size n. Remark: This algorithm can also be applied on a reversed bitstring to compute the same table for all suffixes of S. In the following, you can assume an algorithm suffixtable that does exactly this. (c) Let S be a n-bit bitstring. Consider an integer m ∈ {0, . . . , n − 1}, and divide the bitstring S into two substrings S[0..m] and S[m + 1..n − 1]. Using prefixtable and suffixtable, describe an algorithm spanning(m, k, S) that returns the number of substrings S[i..j] of S that have exactly k ones and such that i ≤ m < j. What is its complexity? 2 For example, if S = “0110”, k = 2, and m = 0, there exist exactly two such strings: “011” and “0110”. Hence, spanning(m, k, S) = 2. Hint: Each substring S[i..j] with i ≤ m < j can be obtained by concatenating a string S[i..m] that is a suffix of S[0..m] and a string S[m + 1..j] that is a prefix of S[m + 1..n − 1]. (d)* Using spanning, design an algorithm with a runtime1 of at most O(n log n) that counts the number of nonempty substrings of a n-bit bitstring S with exactly k ones. (You can assume that n is a power of two.) Hint: Use the recursive idea from the lecture. Exercise 3.3 Counting function calls in loops (1 point). For each of the following code snippets, compute the number of calls to f as a function of n ∈ N. Provide both the exact number of calls and a maximally simplified asymptotic bound in Θ notation. Algorithm 1 (a) i ← 0 while i ≤ n do f () f () i ← i + 1 j ← 0 while j ≤ 2n do f () j ← j + 1 Algorithm 2 (b) i ← 1 while i ≤ n do j ← 1 while j ≤ i3 do f () j ← j + 1 i ← i + 1 Hint: See Exercise 1.4. Exercise 3.4 Fibonacci numbers. There are a lot of neat properties of the Fibonacci numbers that can be proved by induction. Recall that the Fibonacci numbers are defined by f0 = 0, f1 = 1 and the recursion relation fn+1 = fn + fn−1 for all n ≥ 1. For example, f2 = 1, f5 = 5, f10 = 55, f15 = 610. (a) Prove that fn ≥ 1 3 · 1.5n for n ≥ 1. 1For this running time bound, we let n range over natural numbers that are at least 2 so that n log(n) > 0. 3 (b) Write an O(n) algorithm that computes the nth Fibonacci number fn for n ∈ N. Remark: As shown in part (a), fn grows exponentially (e.g., at least as fast as Ω(1.5n)). On a physical computer, working with these numbers often causes overflow issues as they exceed variables’ value limits. However, for this exercise, you can freely ignore any such issue and assume we can safely do arithmetic on these numbers. (c) Given an integer k ≥ 2, design an algorithm that computes the largest Fibonacci number fn such that fn ≤ k. The algorithm should have complexity O(log k). Prove this. Remark: Typically we express runtime in terms of the size of the input n. In this exercise, the runtime will be expressed in terms of the input value k. Hint: Use the bound proved in part (a). Exercise 3.5 Iterative squaring. In this exercise you are going to develop an algorithm to compute powers an, with a ∈ Z and n ∈ N, efficiently. For this exercise, we will treat multiplication of two integers as a single elementary operation, i.e., for a, b ∈ Z you can compute a · b using one operation. (a) Assume that n is even, and that you already know an algorithm An/2(a) that efficiently computes an/2, i.e., An/2(a) = an/2. Given the algorithm An/2, design an efficient algorithm An(a) that computes an. (b) Let n = 2k, for k ∈ N0. Find an algorithm that computes an efficiently. Describe your algorithm using pseudo-code. (c) Determine the number of elementary operations (i.e., integer multiplications) required by your algorithm for part b) in O-notation. You may assume that bookkeeping operations don’t cost any- thing. This includes handling of counters, computing n/2 from n, etc. (d) Let Power(a, n) denote your algorithm for the computation of an from part b). Prove the correctness of your algorithm via mathematical induction for all n ∈ N that are powers of two. In other words: show that Power(a, n) = an for all n ∈ N of the form n = 2k for some k ∈ N0. (e)* Design an algorithm that can compute an for a general n ∈ N, i.e., n does not need to be a power of two. Hint: Generalize the idea from part (a) to the case where n is odd, i.e., there exists k ∈ N such that n = 2k + 1. 4","libVersion":"0.3.2","langs":""}