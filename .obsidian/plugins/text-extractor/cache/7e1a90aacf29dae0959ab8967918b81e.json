{"path":"sem2a/DDCA/VRL/slides/DDCA-L13-memory.pdf","text":"Carnegie Mellon 1 Digital Design and Computer Architecture Mohammad Sadrosadati Frank K. Gürkaynak Adapted from Digital Design and Computer Architecture, David Money Harris & Sarah L. Harris ©2007 Elsevier http://safari.ethz.ch/ddca Memories Carnegie Mellon 2 What will we learn today? ¢ One more common sequential building block § Counters ¢ How can we store data? ¢ Array organization of memories Carnegie Mellon 3 Counters ¢ Increments on each clock edge. § Used to cycle through numbers. For example, § 000, 001, 010, 011, 100, 101, 110, 111, 000, 001… ¢ Example uses: § Digital clock displays § Program counter: keeps track of current instruction executing Q CLK Reset N+N 1 CLK Reset N N Q N r Symbol Implementation Carnegie Mellon 6 Motivation: Memory Elements ¢ Memories are large blocks § A significant portion of a modern circuit is memory. ¢ Memories are practical tools for system design § Programmability, reconfigurability all require memory ¢ Allows you to store data and work on stored data § Not all algorithms are designed to process data as it comes, some require data to be stored. § Data type determines required storage § SMS: 160 bytes § 1 second normal audio: 64 kbytes § 1 HD picture: 7.32 Mbytes Carnegie Mellon 7 Die photograph of an Intel processor in 45nm Carnegie Mellon 8 Larger Memory Blocks Carnegie Mellon 9 How can we store data ¢ Flip-Flops (or Latches) § Very fast, parallel access § Expensive (one bit costs 20+ transistors) Carnegie Mellon 10 How can we store data ¢ Flip-Flops (or Latches) § Very fast, parallel access § Expensive (one bit costs 20+ transistors) ¢ Static RAM (we will describe them in a moment) § Relatively fast, only one data word at a time § Less expensive (one bit costs 6 transistors) Carnegie Mellon 11 How can we store data ¢ Flip-Flops (or Latches) § Very fast, parallel access § Expensive (one bit costs 20+ transistors) ¢ Static RAM (we will describe them in a moment) § Relatively fast, only one data word at a time § Less expensive (one bit costs 6 transistors) ¢ Dynamic RAM (we will describe them a bit later) § Slower, reading destroys content (refresh), one data word at a time, needs special process § Cheaper (one bit is only a transistor) Carnegie Mellon 12 How can we store data ¢ Flip-Flops (or Latches) § Very fast, parallel access § Expensive (one bit costs 20+ transistors) ¢ Static RAM (we will describe them in a moment) § Relatively fast, only one data word at a time § Less expensive (one bit costs 6 transistors) ¢ Dynamic RAM (we will describe them a bit later) § Slower, reading destroys content (refresh), one data word at a time, needs special process § Cheaper (one bit is only a transistor) ¢ Other storage technology (hard disk, flash) § Much slower, access takes a long time, non-volatile § Per bit cost is lower (no transistors directly involved) Carnegie Mellon 13 Array Organization of Memories ¢ Efficiently store large amounts of data § Consists of a memory array (stores data) § Address selection logic (selects one row of the array) § Readout circuitry (reads data out) ¢ An M-bit value can be read or written at each unique N-bit address § All values can be accessed, but only M-bits at a time § Access restriction allows more compact organization Address Data Array N M Carnegie Mellon 14 Memory Arrays ¢ Two-dimensional array of bit cells § Each bit cell stores one bit ¢ An array with N address bits and M data bits: § 2N rows and M columns § Depth: number of rows (number of words) § Width: number of columns (size of word) § Array size: depth × width = 2N × M Address Data Array N M Address Data 11 10 01 00 depth 0 1 0 1 0 0 1 1 0 0 1 1 width Address Data Array 2 3 Carnegie Mellon 15 Memory Array: Example ¢ 22 × 3-bit array ¢ Number of words: 4 ¢ Word size: 3-bits ¢ For example, the 3-bit word stored at address 10 is 100 Address Data 11 10 01 00 depth 0 1 0 1 0 0 1 1 0 0 1 1 width Address Data Array 2 3 Carnegie Mellon 16 Memory Arrays Address Data 1024-word x 32-bit Array 10 32 Carnegie Mellon 17 Types of Memories ¢ Volatile memories (loses data when power is off) § Static Random Access Memory (SRAM) § Dynamic Random Access Memory (DRAM) ¢ Non-volatile memories (keeps data even without power) § Read Only Memory (ROM) § Various forms of flash memory (i.e. EEPROM) Carnegie Mellon 18 Static Random Access Memory ¢ Volatile: Stores data by cross coupled inverters, once data is stored the inverters keep the value (therefore static) ¢ Historically called Random Access Memory, because data can be accessed in any order (unlike magnetic tapes which allowed only serial access) Carnegie Mellon 19 Dynamic Random Access Memory ¢ Volatile: Stores data by charging a (small) capacitor ¢ Problem is that the charge on the capacitor will slowly discharge (memory will forget the value) with time. ¢ It is called Dynamic, because we have to refresh the contents before memory forgets what it stored. ¢ The larger the capacitor, the longer it takes to forget § This costs area, ingenious methods are used to increase capacitance wordline bitline wordline bitline + +stored bit = 1 stored bit = 0 Carnegie Mellon 20 Memory Array Organization ¢ Storage nodes in one column connected to one bitline ¢ Address decoder activates only ONE wordline ¢ Content of one line of storage available at output wordline311 10 2:4 Decoder Address 01 00 stored bit = 0 wordline 2 wordline 1 wordline 0 stored bit = 1 stored bit = 0 stored bit = 1 stored bit = 0 stored bit = 0 stored bit = 1 stored bit = 1 stored bit = 0 stored bit = 0 stored bit = 1 stored bit = 1 bitline2 bitline1 bitline0 Data 2 Data1 Data0 2 Carnegie Mellon 21 Memory Array Organization ¢ Storage nodes in one column connected to one bitline ¢ Address decoder activates only ONE wordline ¢ Content of one line of storage available at output wordline311 10 2:4 Decoder Address 01 00 stored bit = 0 wordline 2 wordline 1 wordline 0 stored bit = 1 stored bit = 0 stored bit = 1 stored bit = 0 stored bit = 0 stored bit = 1 stored bit = 1 stored bit = 0 stored bit = 0 stored bit = 1 stored bit = 1 bitline2 bitline1 bitline0 Data 2 Data1 Data0 2 10 1 0 0 Active wordline Carnegie Mellon 22 How is Access Controlled ? ¢ Access transistors configured as switches connect the bit storage to the bitline. ¢ Access controlled by the wordline stored bit wordline bitline wordline bitline bitlinewordline bitline DRAM SRAM Carnegie Mellon 23 Read Only Memories ¢ Non Volatile: Read Only Memories (ROM) can be made much denser § No need to change the content (no storage transistors) § Denser array ¢ Used for keeping content that will not change § Program of an embedded system § Configuration data § Look up tables ¢ Re-writable (flash) memories are commonly used § These are actually programmable, but writing is very slow § From an application point of view identical to ROMs Carnegie Mellon 24 ROMs: Dot Notation wordline bitline wordline bitline bit cell containing 0 bit cell containing 1 11 10 2:4 Decoder Address Data0Data1Data2 01 00 2 Carnegie Mellon 25 ROM Storage 11 10 2:4 Decoder Address Data0Data1Data2 01 00 2 Address Data 11 10 01 00 depth 0 1 0 1 0 0 1 1 0 0 1 1 width Carnegie Mellon 26 ROM Logic Data2 = A1 Å A0 Data1 = A1 + A0 Data0 = A1A0 11 10 2:4 Decoder Address Data0Data1Data2 01 00 2 Carnegie Mellon 27 Logic with Memory Arrays ¢ Implement the following logic functions using a 22 × 3-bit memory array: § X = AB § Y = A + B § Z = A B wordline311 10 2:4 Decoder A, B 01 00 stored bit = 1 wordline 2 wordline 1 wordline0 stored bit = 1 stored bit = 0 stored bit = 0 stored bit = 1 stored bit = 1 stored bit = 0 stored bit = 1 stored bit = 0 stored bit = 0 stored bit = 0 stored bit = 0 bitline 2 bitline 1 bitline 0 X Y Z 2 Carnegie Mellon 28 Logic with Memory Arrays ¢ Called lookup tables (LUTs): look up output at each input combination (address) stored bit = 1 stored bit = 0 00 01 2:4 Decoder A stored bit = 0 bitline stored bit = 0 Y B 10 11 4-word x 1-bit Array A B Y 0 0 0 1 1 0 1 1 0 0 0 1 Truth Table A1 A0 Carnegie Mellon 29 Multi-ported Memories ¢ Port: address/data pair ¢ 3-ported memory: § 2 read ports (A1/RD1, A2/RD2) § 1 write port (A3/WD3, WE3 enables writing) ¢ Small multi-ported memories are called register files A1 A3 WD3 WE3 A2 CLK Array RD2 RD1 M M N N N M Carnegie Mellon 30 Memory Arrays in Verilog // 256 x 3 memory module with one read/write port module dmem( input clk, // clock input we, // write enable input [7:0] a // 8-bit address input [2:0] wd, // 3-bit write data output [2:0] rd); // 3-bit read data reg [2:0] RAM[255:0]; // Memory array, holds // 256 entries each 3 bits wide assign rd = RAM[a]; // Read access always @(posedge clk) // with rising clock if (we) // if write enable RAM[a] <= wd; // write data is stored in array endmodule Carnegie Mellon 31 What have we learned? ¢ Different ways of storing data § Registers § Static Memory § Dynamic Memory ¢ Array organization § Compact form § One row active at a time","libVersion":"0.3.2","langs":""}