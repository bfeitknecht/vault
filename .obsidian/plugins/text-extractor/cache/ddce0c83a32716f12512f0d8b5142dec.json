{"path":"sem3/EProg/VRL/extra/slides/EProg_sx.pdf","text":"252-0027 Einführung in die Programmierung Herbstsemester 2022/23 Thomas R. Gross Department Informatik ETH Zürich ©Thomas Gross 2020 - 2022 Vorlesung Logistik § Im Hörsaal Präsensvorlesung Mit Übertragung in ML E12 Mit Übertragung im LiveStream § LiveStream Übertragung § Übungen Präsenzveranstaltung § Online Gruppe(n) bei genügendem Interesse 2 Vorlesung+ § Im Hörsaal Präsensvorlesung § Stellen Sie Fragen! § Bitte keine persönlichen Gespräche § Remote Übertragung (ML E12 und LiveStream) § Stellen Sie Fragen, melden Sie Probleme § Fragen & Kommentare via EduApp Course Channel 3 Eine (persönliche) Bitte § Eingeschriebene Studierende: 576 (18.9., 21:00) § Videoübertragung § Aufzeichnung § Im D 28/E 12 keine Gespräche! § Wenn Sie SMS/Omlet/Threema/WhatsApp/Messenger nutzen: § Leise o.k. 4 Diese Veranstaltung § Vorlesungen (ML D 28) § Dienstag 10 – 12 § Freitag 8 – 10 (ausserdem Do 29. 9. & 6. 10., 14 – 15, ETF F5) § Übungen (diverse Räume) § Mittwoch 8 – 10 5 Informationen § Web Seiten der Gruppe (Laboratory for Software Technology) www.lst.inf.ethz.ch § Im ETH Corporate Design – nicht immer sofort online § Manchmal auch gar nicht erreichbar 6 Auf unserer Web Seite finden Sie § Folien (wenn möglich vor der Vorlesung aber keine Garantie) § Achtung: 1 Seite/Slide § Drucken Sie 2, 4, 6 Seiten pro Blatt A4 Papier § Besser: drucken Sie nicht … § In der Vorlesung geschriebene Folien (Auswahl) § Vielleicht 24h-48h nach der Vorlesung § Diverse Links (zu Video Portal, Material der Übungsgruppen, Aufgabenstellungen) 7 Informationen § Auf dem Videoportal der ETH § Aufzeichnung des übertragenen Livestreams § Nur Hauptprojektor § Die Vorlesung wird aufgezeichnet § Daher … 8 Das Programm für heute 9 «Educators, generals, dieticians, psychologists, and parents program. Armies, students, and some societies are programmed.» Alan Perlis (Foreword to «Structure and Interpretation of Computer Programs», H. Abelson and G. J. Sussman, 1985) Für uns: Allgemeinste Form des Programmieren: «Computer Programming» Das Programm für heute 10 § Warum Programmieren lernen? § Bezug zum Informatikstudium an der ETH § Praktische Aspekte § Übungen § Computer(räume) § Wie wir die Lernziele erreichen ... Warum Programmieren lernen? 111213 31. Dez. 2019 Warum Programmieren lernen? § Was ist überhaupt «Programmieren» § Programmieren –> Programm § Programm: griechisch prógramma = schriftliche Bekanntmachung, Aufruf; Tagesordnung [Duden] § Programm(ausführung) manipuliert Symbole § Text, Zahlen, Bilder, … 15 Warum Programmieren lernen? § Was ist überhaupt «Programmieren» § Programmieren –> Programm § Programm: griechisch prógramma = schriftliche Bekanntmachung, Aufruf; Tagesordnung [Duden] § Programmieren: Erstellen eines Programms 16 Warum Programmieren lernen? § Was ist überhaupt «Programmieren» § Programmieren –> Programm § Programm: griechisch prógramma = schriftliche Bekanntmachung, Aufruf; Tagesordnung [Duden] § Programmieren (Zusammenfassend): Software Entwicklung § Programmierung behandelt alle Aspekte – von Entwurf bis Installation 17 Programmieren § Erstellen eines Programms § Programm: Folge von Anweisungen, die von einem Computer ausgeführt werden (können) § Programm realisiert einen Algorithmus § Algorithmus: beschreibt Schritt-für-Schritt wie eine Aufgabe gelöst wird 19 Programmierung und Informatik § Ein Thema der Informatik – es gibt auch andere § Zentral wenn Sie lernen wollen, wie die Informatik ein Problem angeht § Fokus auf «Möglichkeiten und Grenzen der maschinellen Informationsverarbeitung» § Es gibt «unmögliche» Probleme § Kosten der Berechnung (einer Lösung) sind sehr wichtig 20 Programmierung «Programming as universal activity» by Vinton Cerf, CACM March 2016, vol 59(3) p 7 § analyzing problems § breaking them down into manageable parts § finding solutions § integrating the results 21 Programmierung «Programming as universal activity» by Vinton Cerf, CACM March 2016, vol 59(3) p 7 § Probleme analysieren § Probleme in (beherrschbare) Teilprobleme zerlegen § Lösungen finden § Ergebnisse zusammenfügen/kombinieren 22 Vinton Cerf (*1943) Ph.D. UCLA (1972) Assistant Professor Stanford (1972-76) Program Manager (D)ARPA (1976-82) Zusammen mit Bob Kahn massgeblich an der Entwicklung von TCP/IP beteiligt (Internet Protokoll) Nach 1982 diverse Positionen in Industrie & Verbänden, seit 2005 VP Google Dr. h.c. ETH 1998 23 Schlagfertig beantwortete Vint Cerf die teilweise ziemlich kritischen Fragen des ETH-Publikums.(2006) http://web.ethlife.ethz.ch/articles/campuslife/vintcerf.html Programmierung § Lösungen finden: für andere Menschen § Beschreiben wie eine Lösung aussehen soll § Lösungen finden: für eine Maschine § Anweisungen für eine Maschine/Computer 24 Programmierung § Lösungen finden: für andere Menschen § Beschreiben wie eine Lösung aussehen soll § Lösungen finden: für eine Maschine § Anweisungen für eine Maschine/Computer § Beschreibung, Anweisung: in einer «Sprache» 25 Wie Programmieren lernen? § Programm: Folge von Anweisungen, die von einem Computer ausgeführt werden (können) § Wir müssen verstehen welche Anweisungen der Computer ausführen kann § Dann Erstellen der Folge von Anweisungen § Mögliche Anweisungen: Programmiersprache 26 Einführung in die Programmierung § Müssen eine Programmiersprache verwenden § Sprache für Computer (führt aus) § ... schreibt § Sprache für Menschen (schreibt, liest) § ... selten führt aus (heute) 27 § Müssen eine Programmiersprache verwenden § Sprache für Computer (führt aus) § ... schreibt § Sprache für Menschen (schreibt, liest) § ... selten führt aus (heute) § Charles [Peirce] was appointed to his first official position in the Coast Guard Survey [..] in July 1861, as an assistant computer at $ 35 per month. (J. Brent, Charles Sanders Peirce: A Life. 1993. p 61) Einführung in die Programmierung 28 Heute: Maschine Früher: Berufsbezeichnung Früher: Berufsbezeichnung Programmiersprachen Welche dieser Aussagen trifft Ihre Meinung am genauesten? 1. Eine Programmiersprache sollte es möglichst einfach machen ein Programm zu schreiben 2. Eine Programmiersprache sollte es möglichst einfach machen, ein Programm zu lesen 3. Beides ist gleich wichtig 4. Ich habe keine Meinung Antworten Sie mit dem EduApp Clicker 29 Poll 30 Einführung in die Programmierung § Müssen eine Programmiersprache verwenden § Wir verwenden Java™ § «Industrial strength» Sprache § Viele Konzepte § Nicht alle werden in «Einf. in die Programmierung» vorgestellt/verwendet § … diese werden auch nicht für die Prüfung erwartet § Mehr Themen/Konzepte in weiteren Vorlesungen 31 Programmieren § Wie kann man Programmieren lernen? § Braucht man eine besondere Begabung? § Gibt es nur Naturtalente (und der Rest kann zuschauen)? § Wie kann man XXXX lernen? 32 Jede(r) kann programmieren lernen § Ziel der Vorlesung: Kompetenz § Lernziel: Sie können korrekte Programme systematisch erstellen § Programmieren ist zentrales Thema der Informatik § Aber nicht das einzige! § Wichtig sind: § Aufmerksamkeit § Imagination, Phantasie § Übung Übung Übung Übung Übung 37 Veranstaltung = Vorlesung + Übung § Programmieren erfordert Übung § Nur Übung macht den Meister … § Sie lernen nicht programmieren wenn Sie sich nur die Vorlesung anhören § Sie müssen die Übungsaufgaben lösen (oder es zumindest versuchen) 4044 Visionen Dez 2020 45 Visionen Dez 2020 Übungen § Aufgabenblätter § Werden über Web Seite publiziert § In der Übungsgruppe vor-besprochen § Eine Gelegenheit zu lernen! § Praxis Übungen § Bonus Übungen § Teilnahme an Übungsgruppe nicht verbindlich aber sehr empfohlen § Es gibt selten nur eine Lösung § Üben Sie das Diskutieren und Vergleichen verschiedener Lösungen 46 Praxis und Bonus Übungen § Werden teilweise automatisch korrigiert § «Automatisch» – durch einen Computer § d.h. durch ein Programm, das von einem Computer ausgeführt wird § Hinweis: Ihr Java Programm wird nicht direkt ausgeführt, die Java Anweisungen werden übersetzt (durch einen Compiler) § Analyse des Programms § Selbe Technologie hilft bei der Bewertung von Programmen § Thema der Forschung 47 Praxis Übungen § Sie können die Lösungen im Internet (wahrscheinlich) finden § Musterlösung aus früheren Jahren § Langweilen die Assistierenden § Eine Gelegenheit zu lernen! § Besprechung in der Gruppe, Feedback, Überarbeiten 48 Bonus Übungen § Sie können (ab 4. oder 5. Aufgabenblatt) «Bonuspunkte» für die Basisprüfung sammeln § Bonuspunkte helfen die Note anzuheben – maximal 0.25 Notenbonus § Maximalnote auch ohne Bonus erreichbar § Programmieren ist Teil der Basisprüfung § Details später. 49 Bonus Übungen § Anreiz § Sie müssen die Aufgaben selber lösen. § Abschreiben (oder abschreiben lassen) ist unehrliches Verhalten und wird nach der ETH Disziplinarverordnung geahndet. § Nur die Bonusaufgaben lösen? Riskant. 5155 -10 0 10 20 30 40 50 60 70 80 90 100 110 120 -10 0 10 20 30 40 50 60 70 80 90 100 110 120 % LE Bonus vs % Programming 100 % < 100 < 90 < 80 < 70 < 60 < 50 < 40 < 30 < 20 < 10 100 %< 100< 90< 80< 70< 60< 50< 40< 30< 20< 10 % Bonus vs. % Programmieren (HS21) 57 0 10 20 30 40 50 60 0 10 20 30 40 50 60 70 80 90 100 110 Performance of Students w/ 100% Bonus (% Programming on X Axis) 100 %< 100< 90< 80< 70< 60< 50< 40< 30< 20< 100 0 Anzahl Studierende für % Programmieren (voller Bonus, HS21) Bonus Übungen § Anreiz § Stichwort: Eigenverantwortung § Nur die Bonusaufgaben lösen? Riskant wenn Sie wenig/keine Programmiererfahrung haben. § Und: Sie müssen die Aufgaben selber lösen um zu lernen. 58 Übungsgruppen § Wir bieten zwei Arten von Gruppen an: § Fokusgruppen Fokus auf Studierende ohne Vorkenntnisse und ohne vorherige Programmiererfahrung (egal welche Programmiersprache) § Gemischte Gruppen Für alle Vorkenntnisstufen Freie Wahl -- Alle Gruppen behandeln den selben Stoff/die selben Aufgaben 59 Übungsgruppen § Wir bieten zwei Arten von Gruppen an: § Fokusgruppen § Fokus auf Studierende ohne Vorkenntnisse und ohne vorherige Programmiererfahrung (egal welche Programmiersprache) § Gemischte Gruppen § Für alle Vorkenntnisstufen Freie Wahl -- Alle Gruppen behandeln den selben Stoff/die selben Aufgaben 60 Übungsgruppen § Wir bieten zwei Arten von Gruppen an: § Fokusgruppen § Fokus auf Studierende ohne Vorkenntnisse und ohne vorherige Programmiererfahrung (egal welche Programmiersprache) § Gemischte Gruppen § Für alle Vorkenntnisstufen § Freie Wahl -- Alle Gruppen behandeln den selben Stoff/die selben Aufgaben 61 Einschreibung § Ab heute Nachmittag in myStudies möglich § Wenn die bevorzugte Art von Gruppe nicht verfügbar ist: Warten! § Wir passen Anzahl und Grösse der Gruppen an § Wenn Sie mit anderen Studierenden in eine Gruppe wollen: § Zusammen (zeitgleich) einschreiben § Bitte bis Freitag (23. 9.) einschreiben! § Nachzügler später möglich, aber evtl. mit Einschränkungen 62 Bei Problemen § Erste Anlaufstelle Treffen der Übungsgruppe § Wenn nicht möglich: «Study Center» § Online via Zoom § Coaches können helfen § Study Center nicht Ersatz für Übungsgruppe § Weitere Informationen auf dem Web 63 Wöchentlicher Ablauf (im Normalfall) § Dienstag: Praxis Übungen und (später) Bonus Aufgaben auf dem Web publiziert § Übung 0: [Heute] Einrichten der Arbeitsumgebung § Mittwoch: Treffen Übungsgruppe § Besprechung Aufgaben (alte, neue, extra) und Vorlesungsthemen § Diese Woche nur Study Center § Dienstag Folgewoche: Abgabe der Lösungen (Praxis Übungen und Bonus Aufgaben) 64 Besondere Regeln für Woche 10 & 11 § Bonus Aufgabe erst am 30. 11. (7. 12.) publiziert und muss innerhalb von 2 Stunden abgegeben werden § Weitere Details auf dem Web und später in Vorlesung 65 Wieviel müssen Sie im 1. Semester arbeiten? 717273 1 ECTS Kredit = 30 Std/Semester 7 Kredits = 210 Std/Semester 1 Sem = 23 Wochen 210 Std/23 Wochen = 9 Std/Woche 30 Kredits = 900 Std/Semester … 39 Std/Woche Hmmm -- 39 Std/Woche?? Vielleicht im Film. Oder an der XXX Universität. Erwarten Sie mehr Arbeit an der ETH!! 0027 \"Einführung in die Programmierung\" § Programm: Anweisungen in Programmiersprache § Anweisungen arbeiten mit Werten (Zahlen) § Auch einfache Probleme können überraschen § Aufgabe: Berechnen Sie den Durchschnitt von 2 Messwerten § Algorithmus (wenn wir den Ausdruck verwenden wollen): § Addiere die Messwerte § Dividiere die Summe durch 2 77 Wo könnte das eine Rolle spielen? 78 Durchschnitt Steuerung Durchschnitt berechnet als (Sensor1 + Sensor2)/2 Sensor1 Sensor2 Wo könnte das eine Rolle spielen? 79 Sensor1 Sensor2 Durchschnitt Steuerung Durchschnitt berechnet als (Sensor1 + Sensor2)/2 © DLR German Aerospace Center / CC BY (https://creativecommons.org/licenses/by/2.0) Ariane-5 Wo könnte das eine Rolle spielen? 81 Sensor1 Sensor2 Durchschnitt Steuerung Durchschnitt Berechnung erwartet ganze Zahlen © DLR German Aerospace Center / CC BY (https://creativecommons.org/licenses/by/2.0) Ariane-5 Wo könnte das eine Rolle spielen? 83 Sensor1 Sensor2 liefert Gleitkommazahl Durchschnitt Steuerung Durchschnitt Berechnung erwartet ganze Zahl © DLR German Aerospace Center / CC BY (https://creativecommons.org/licenses/by/2.0) Ariane-5 Wo könnte das eine Rolle spielen? 84 Sensor1 Sensor2 liefert Gleitkommazahl Durchschnitt Steuerung Durchschnitt Berechnung erwartet ganze Zahl https://www.youtube.com/watch?v=5tJPXYA0Nec Ariane-5 (V88): Details sind etwas komplizierter aber der 1. Testflug war nicht erfolgreich: Ein trivialer Algorithmus § … und trotzdem einige Probleme beim Programmieren § Müssen genau festlegen, welche Formate (und Wertebereiche) erwartet werden § Erstes Thema: Wie können wir Formate beschreiben? § Dazu im Hintergrund: Arbeitsumgebung einrichten 85 Verschiedenes 86 Brauchen Sie einen Computer ? § Im Prinzip nein (Sie können die Systeme im CAB H56/57 oder im HG benutzen) § Irgendwann vielleicht schon … § Das Projekt Neptun bietet diverse Notebooks / Laptops zu günstigen Konditionen http://www.projektneptun.ch § Fenster bis 3. Oktober § Nächstes Fenster Anfang Frühjahrsemester 87 Diese Veranstaltung § Fragen (an den Dozenten) sind immer erlaubt und erwünscht § Fragen Sie nicht die Nachbarin/den Nachbar § Wie kann ich wissen was Ihnen Schwierigkeiten macht (oder was Sie nicht lesen können)?? § Chat besser als Hand heben: der Text muss nicht perfekt sein § Auch off-line sind Fragen möglich § eMail -- aber bitte mit Ihrer student.ethz.ch Adresse! § Sprechstunde bei Interesse 88 Wichtig: Bitte belegen Sie die Vorlesung in myStudies. Sonst können wir Sie nicht erreichen und Sie haben nicht Zugang zu Aufgaben, usw. Tragen Sie sich in eine Übungsgruppe ein Unbedingt bis Freitag den 23. 9., 12 Uhr mittags! 89 Weiterer Ablauf (Plan) § 23. 9.: 8:15 (Fr): Vorlesung § 27. 9.: 10:15 (Di): Vorlesung § 28. 9.: 1. Treffen der Gruppen (Mittwoch nächste Woche) § Thema: Arbeitsumgebung einrichten § 29. 9.: 14:15 (Do): Vorlesung [ETA F5, Keine «Algorithmen und Datenstrukturen» zu dieser Zeit] § 30. 9.: 8:15 (Fr): Vorlesung § 6. 10.: 14:15 (Do): Vorlesung [ETA F5] § 7. 10.: 8:15 (Fr): Vorlesung 90 Vorschau § Übung U0: (20. 9. -> 28. 9.): Einrichten der Arbeitsumgebung § Keine Abgabe – wir wollen Ihnen helfen schnell arbeiten zu können § Bei Problemen ggf. in der Gruppe einrichten § Sprechstunden (Study Center) nutzen § Übung U1 (27. 9. -> 4. 10.): «Abgabe» durchspielen, einfache Aufgabe § So erhalten Sie auch Feedback, ggf. in der Gruppe einreichen § Übung U2 (4. 10. -> 11. 10.): einfachste Programme § Übung U3 oder U4: Bonuspunkte möglich (später mehr) 91 252-0027 Einführung in die Programmierung 1.0 EBNF Thomas R. Gross Department Informatik ETH Zürich Programmierung § Eine Programmiersprache gibt uns vor, wie wir Lösung(en) eines Problems beschreiben können. § Mehr Einschränkungen (in der Sprache) machen die Kommunikation leichter § …. und erfordern mehr Aufwand bei der Entwicklung § Genaue Beschreibung (von Programmiersprachen, Werten, Input, ...) wichtiges Thema für Informatik 2 Programmiersprachen § Bestimmen die Anweisungen, die ein Programm enthalten darf § Bestimmen Formate und Wertebereiche, mit denen Programme arbeiten 3 Wie kann man eine (Programmier)Sprache beschreiben? § Notation EBNF E – Extended B – Backus N – Naur oder Normal F – Form § Beschreibt die Syntax einer Sprache § Food for thought: Welche Sprachen kann man damit beschreiben? 4 Es gibt weitere Gründe für EBNF in EProg § Praktische Beweise relevanter Eigenschaften § Beispiele kommen noch … § Jede EBNF Beschreibung hat zwei Seiten § Liefert eine Menge von Symbolen (die der EBNF Beschreibung genügen) § «Programmierung im ganz Kleinen» § Erlaubt zu prüfen ob ein Symbol der EBNF Beschreibung genügt § «Genügt»: (informell) der Beschreibung entsprechend § «Symbol»: (informell) Zeichen oder Zeichenfolge 7 Übersicht § Sie lernen die vier elementaren Ausdrucksmöglichkeiten in EBNF kennen § Sie lernen EBNF Beschreibungen zu lesen und verstehen § Sie lernen zu entscheiden ob ein Symbol legal ist (für eine EBNF Beschreibung) § …. 8 EBNF § Vier Elemente («control forms») die Sie in Java wiederfinden werden 11 EBNF § Programmierung im ganz Kleinen § Vier Elemente («control forms») die Sie in Java wiederfinden werden § Aufreihung («sequence») § Entscheidung («decision») – Auswahl und Option § Wiederholung («repetition») § Rekursion («recursion») 12 EBNF § Beschreibungen haben einen Namen und diese Namen können wieder verwendet werden § Um kompliziertere Beschreibungen zu erstellen § Erstellen einer EBNF Beschreibung ßà Programmieren in Java § Ähnliche Schritte § EBNF eine formale Beschreibung § Präzise und verständlich 13 1.1 EBNF Regeln und Beschreibungen § EBNF Beschreibung besteht aus Menge von EBNF Regeln § Menge: Reihenfolge der Regeln unwichtig § Jede Regel gibt an welche Symbole erlaubt sind § Beispiel: EBNF Regel für eine Ziffer § EBNF Beschreibung gibt an welche Symbole erlaubt sind § Erlaubt: den Regeln entsprechend gebildet § Wir werden das noch präzisieren § Beispiel: EBNF Beschreibung für 2-stellige positive ganze Zahlen § Verwendet (möglicherweise) EBNF Regeln für Ziffern 14 Wie sieht eine EBNF Regel aus? § Drei Bestandteile: § Linke-Seite (Left-Hand Side, LHS) § Rechte-Seite (Right-Hand Side, RHS) § ⟸ ⟸ trennt LHS von RHS, ausgesprochen «ist definiert als» § d.h LHS ⟸ RHS § LHS § Ein Wort (kursiv, kleingeschrieben) – der Name der EBNF Regel 18 § RHS § Die genaue Beschreibung für den Namen (d.h., der LHS) § Kann enthalten § Zeichen (stellen das Zeichen da, d.h. wir erwarten dieses Zeichen und kein anderes) § … 19 Beispiel EBNF Regel § ziffer_null ⟸ 0 § ziffer_eins ⟸ 1 21 § RHS § Die genaue Beschreibung für den Namen (d.h., der LHS) § Kann enthalten § Zeichen (stellen das Zeichen da, d.h. wir erwarten dieses Zeichen und kein anderes) § Namen (von EBNF Regeln) § ... 22 Beispiel EBNF Regel § ziffer_null ⟸ 0 § ziffer_eins ⟸ 1 § ziffer_null ⟸ 0 zahl_n0 ⟸ ziffer_null 23 § RHS § Die genaue Beschreibung für den Namen (d.h., der LHS) § Kann enthalten § Zeichen (stellen das Zeichen da, d.h. wir erwarten dieses Zeichen und kein anderes) § Namen (von EBNF Regeln) § Kombinationen der vier Kontrolelemente («control forms») (auf folgenden Seiten) 24 § EBNF Regel besteht aus: § Linke-Seite (Left-Hand Side, LHS) § Rechte-Seite (Right-Hand Side, RHS) § ⟸ (trennt LHS von RHS, ausgesprochen «ist definiert als») § LHS § Ein Wort (kursiv, kleingeschrieben) – der Name der EBNF Regel § RHS § Die genaue Beschreibung für den Namen (d.h., der LHS) durch § Namen (von EBNF Regeln) – kursiv und kleingeschrieben § Zeichen (stellen das Zeichen da, d.h. wir erwarten dieses Zeichen und kein anderes) – nicht kursiv § Kombinationen der vier Kontrolelemente («control forms») (auf folgenden Seiten) 25 Beispiel EBNF Regel § ziffer_null ⟸ 0 § ziffer_eins ⟸ 1 § ziffer_null ⟸ 0 zahl_n0 ⟸ ziffer_null 26 Müssen wir ein Alphabet angeben? 29 EBNF – statt kursiv zwei Klammern § digit_9 ⟸ 9 30 EBNF – statt kursiv zwei Klammern § digit_9 ⟸ 9 § <digit_9> ⟸ 9 31 § EBNF Regel besteht aus: § Linke-Seite (Left-Hand Side, LHS) § Rechte-Seite (Right-Hand Side, RHS) § ⟸ (trennt LHS von RHS, ausgesprochen «ist definiert als») § LHS § Ein Wort (kursiv, kleingeschrieben) – der Name der EBNF Regel § RHS § Die genaue Beschreibung für den Namen (d.h., der LHS) durch § Namen (von EBNF Regeln) – kursiv und kleingeschrieben § Zeichen (stellen das Zeichen da, d.h. wir erwarten dieses Zeichen und kein anderes) – nicht kursiv § Kombinationen der vier Kontrolelemente («control forms») (auf folgenden Seiten) 33 LHS ⟸ RHS EBNF § Vier Kombinationsmöglichkeiten («control forms») die Sie in Java wiederfinden werden § Aufreihung («sequence») § Entscheidung («decision») – Auswahl und Option § Wiederholung («repetition») § Rekursion («recursion») § Kombinieren (in der RHS) EBNF Regeln 34 Control forms (zum Kombinieren) § Aufreihung § Von links nach rechts gelesen § Reihenfolge ist wichtig § Aufreihung Beispiel 35 Control forms (zum Kombinieren) § Aufreihung § Von links nach rechts gelesen § Reihenfolge ist wichtig § Aufreihung Beispiel § number_98 ⟸ 9 8 § 8 und 9 sind Zeichen/Buchstabe unseres Alphabets § myrule ⟸ form_1 form_2 form_2 § form_1, form_2 woanders definiert 36 z.B. form_1 ⟸ S form_2 ⟸ B buchstabe_d ⟸ D buchstabe_2 ⟸ 2 buchstabe_8 ⟸ 8 raum_1 ⟸ buchstabe_d buchstabe_2 buchstabe_8 Beschreibung: Menge von Regeln § Aufreihung § Regel von links nach rechts gelesen § Reihenfolge ist wichtig § Aufreihung Beispiel – verschiedene Mengen, selbes Symbol 41 Menge1 buchstabe_8 ⟸ 8 raum_1 ⟸ buchstabe_d buchstabe_2 buchstabe_8 buchstabe_2 ⟸ 2 buchstabe_d ⟸ D Menge3 Menge4 raum_1 ⟸ D 2 8 buchstabe_d ⟸ D buchstabe_8 ⟸ 8 raum_1 ⟸ buchstabe_d buchstabe_2 buchstabe_8 buchstabe_2 ⟸ 2 Menge2 252-0027 Einführung in die Programmierung 1.0 EBNF Thomas R. Gross Department Informatik ETH Zürich 1.1 EBNF Regeln und Beschreibungen § EBNF Beschreibung besteht aus Menge von EBNF Regeln § Menge: Reihenfolge der Regeln unwichtig § Jede Regel gibt an welche Symbole erlaubt sind § Beispiel: EBNF Regel für eine Ziffer § EBNF Beschreibung gibt an welche Symbole erlaubt sind § Erlaubt: den Regeln entsprechend gebildet § Wir werden das noch präzisieren § Beispiel: EBNF Beschreibung für 2-stellige positive ganze Zahlen § Verwendet (möglicherweise) EBNF Regeln für Ziffern 3 § EBNF Regel besteht aus: § Linke-Seite (Left-Hand Side, LHS) § Rechte-Seite (Right-Hand Side, RHS) § ⟸ (trennt LHS von RHS, ausgesprochen «ist definiert als») § LHS § Ein Wort (kursiv, kleingeschrieben) – der Name der EBNF Regel § RHS § Die genaue Beschreibung für den Namen (d.h., der LHS) durch § Namen (von EBNF Regeln) – kursiv und kleingeschrieben § Zeichen (stellen das Zeichen da, d.h. wir erwarten dieses Zeichen und kein anderes) – nicht kursiv § Kombinationen der vier Kontrolelemente («control forms») (auf folgenden Seiten) 4 LHS ⟸ RHS EBNF § Vier Kombinationsmöglichkeiten («control forms») die Sie in Java wiederfinden werden § Aufreihung («sequence») § Entscheidung («decision») – Auswahl und Option § Wiederholung («repetition») § Rekursion («recursion») § Kombinieren (in der RHS) EBNF Regeln 5 1.1.1 Control form: Aufreihung § Aufreihung («sequence») § Folge von Zeichen («Buchstabe», «Ziffern», …) § Von links nach rechts gelesen § Reihenfolge der Zeichen ist wichtig § Aufreihung Beispiel 6 buchstabe_d ⟸ D buchstabe_2 ⟸ 2 buchstabe_8 ⟸ 8 raum_1 ⟸ buchstabe_d buchstabe_2 buchstabe_8 Beschreibung: Menge von Regeln § Aufreihung § Regel von links nach rechts gelesen § Reihenfolge der Zeichen ist wichtig § Aufreihung Beispiel – verschiedene Mengen, selbes Symbol 7 Menge1 buchstabe_8 ⟸ 8 raum_1 ⟸ buchstabe_d buchstabe_2 buchstabe_8 buchstabe_2 ⟸ 2 buchstabe_d ⟸ D Menge3 Menge4 raum_1 ⟸ D 2 8 buchstabe_d ⟸ D buchstabe_8 ⟸ 8 raum_1 ⟸ buchstabe_d buchstabe_2 buchstabe_8 buchstabe_2 ⟸ 2 Menge2 1.1.2 Kombinieren mit Entscheidungen § Auswahl – aus Alternativen § Eine Menge von Alternativen § Reihenfolge unwichtig § Durch | (gesprochen senkrechter Strich) («stroke») getrennt § Alternativen folgen den EBNF Bestimmungen für die RHS (Rechte- Seite) § Auswahl Beispiel digit ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 raum ⟸ E 12 | D 28 8 buchstabe_d ⟸ D buchstabe_2 ⟸ 2 buchstabe_8 ⟸ 8 buchstabe_e ⟸ E buchstabe_1 ⟸ 1 raum_1 ⟸ buchstabe_d buchstabe_2 buchstabe_8 raum_2 ⟸ buchstabe_e buchstabe_1 buchstabe_2 raum ⟸ raum_1 | raum_2 digit ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 10 Wofür wir ( und ) brauchen § A B | C § Was ist legal? § AB und C oder § AC und AB § Um Unklarheit zu vermeiden verwenden wir ( und ) § A ( B | C ) § (A B ) | C § Klammer schafft Klarheit 11 Kombinieren mit Optionen § Option § Element(e) in [ und ] (eckige Klammern) («square bracket») § Element muss EBNF Bestimmungen für die RHS folgen § Kann gewählt werden, muss aber nicht § Drei Beispiele § initials ⟸ T [ R ] G § raum ⟸ M L [ ( D 28 ) | ( E 12 ) ] § zahl ⟸ 0 x 0 [ 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ] 12 Beispiel § Oft Auswahl (..|..) und Option ([ .. ]) kombiniert § EBNF Beschreibung zahl digit ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 vorzeichen ⟸ [ + | - ] zahl ⟸ vorzeichen digit § 1, +2, -3, +0, 4 … sind legale Symbole § Wie drücken wir aus, dass nicht gewählt wurde? § \" (Ausgesprochen «epsilon») – die leere Zeichenfolge § \" erscheint nicht in Symbolen 13 Ist +4 legal? Ist 4 legal? 1. zahl ⟸ vorzeichen digit 2. zahl ⟸ + digit 3. zahl ⟸ + 4 15 1. zahl ⟸ vorzeichen digit 2. zahl ⟸ \" digit 3. zahl ⟸ 4 digit ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 vorzeichen ⟸ [ + | - ] zahl ⟸ vorzeichen digit Wenn nicht gewählt wird § raum ⟸ M L [ ( D 28 ) | ( E 12 ) ] § [ … ] kann gewählt werden, muss aber nicht § M L ist mögliches Symbol § Vielfältige Kombinationsmöglichkeiten zahlen ⟸ [ 0 | 1 ] [ 2 | 3 ] Z Möglich sind: 02Z 03Z 12Z 13Z 0Z 1Z 2Z 3Z Z 19 Kombinieren mit Optionen § Option § Element(e) in [ und ] (eckige Klammern) («square bracket») § Kann gewählt werden, muss aber nicht § Nicht immer eindeutig § initials ⟸ T [ R ] G § initials ⟸ ( T G ) | ( T [ R ] G ) § «Überspringen» einer Option § vorzeichen ⟸ [ + | - ] § vorzeichen ⟸ + | - | 20 digit ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 number ⟸ digit [ digit ] number ⟸ digit [ [ digit ] ] Kombinieren mit Optionen § Option § Element(e) in [ und ] (eckige Klammern) («square bracket») § Kann gewählt werden, muss aber nicht § Nicht immer eindeutig § initials ⟸ T [ R ] G § initials ⟸ ( T G ) | ( T [ R ] G ) § «Überspringen» einer Option § vorzeichen ⟸ [ + | - ] § vorzeichen ⟸ + | - | \" (Ausgesprochen «epsilon») 21 digit ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 number ⟸ digit [ digit ] number ⟸ digit [ [ digit ] ] Quiz 1: Welche Aussage ist korrekt? 1. «a | b» und «[ a | b ]» lassen die selben Zeichenfolgen zu. 2. «a | b» und «[ a ] | [ b ]» lassen die selben Zeichenfolgen zu. 3. «[a | b]» und «[ [ a | b ] ]» lassen die selben Zeichenfolgen zu. 4. « T [ R ] G» und «T[R]G» lassen die selben Zeichenfolgen zu. 22 Poll Quiz 1 1. «a | b» und «[ a | b ]» lassen die selben Zeichenfolgen zu? § Nein: \" wird von der 2. Beschreibung zugelassen 2. «a | b» und «[ a ] | [ b ] » lassen die selben Zeichenfolgen zu? § Nein: \" wird von der 2. Beschreibung zugelassen 3. «[a | b]» und «[ [ a | b ] ]» lassen die selben Zeichenfolgen zu? § Ja. [[a|b]] ist nicht schön aber erlaubt die selben Zeichenfolgen 4. « T [ R ] G» und «T[R]G» lassen die selben Zeichenfolgen zu? § Ja. Leerzeichen spielen keine Rolle. 23 Poll 1.1.3 Kombination mit Wiederholungen § Wiederholung § Der zu wiederholende Ausdruck steht zwischen { und } (geschweifte Klammer) («curly braces») § Kann 0, 1, … wiederholt werden § Immer daran denken: 0 Wiederholungen heisst – fehlt! 27 Kombination mit Wiederholungen § Wiederholung § Der zu wiederholende Ausdruck steht zwischen { und } (geschweifte Klammer) («curly braces») § Kann 0, 1, … Mal wiederholt werden § Immer daran denken: 0 Wiederholungen heisst – fehlt! § Beispiel digit ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 folge ⟸ digit { digit } 28 <digit> ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 <folge> ⟸ <digit> { <digit> } 29 1.1.4 EBNF Beispiele 30 EBNF Beispiel (i1) 3233 Was bestimmt diese EBNF Beschreibung? § Einfache (ganze) Zahlen § Umgangssprachlich: § Eine digit ist definiert als eines der Zeichen/Buchstaben 0 … 9 § Eine integer ist definiert als eine Folge von 3 Elementen § Ein optionales Vorzeichen (wenn es vorhanden ist, dann muss es eine der Alternativen + oder – sein) § Eine digit § Eine Wiederholung von 0 oder mehr digits wobei jede digit eine der Alternativen der digit Regel ist (und die Alternativen unabhängig gewählt werden) 34 EBNF Beschreibungen § Reihenfolge der Regeln und gewählte Namen unwichtig EBNF Description integer (i2) integer ⟸ [ + | - ] digit { digit } digit ⟸ 0| 1| 2| 3| 4| 5| 6| 7| 8| 9 § oder auch EBNF Description zahl (i3) zahl ⟸ [ + | - ] ziffer { ziffer } ziffer ⟸ 0| 1| 2| 3| 4| 5| 6| 7| 8| 9 § Konvention: von einfach nach komplex, relevante Namen § Name der letzten Regel ist der Name der relevanten Beschreibung 37 Übersicht § Es gibt vier elementare Ausdrucksmöglichkeiten in EBNF § Schon gesehen: Aufreihung, Auswahl/Option, Wiederholung § Sie lernen EBNF Beschreibungen zu lesen und verstehen § Sie lernen zu entscheiden ob ein Symbol legal ist (für eine EBNF Beschreibung) § Sie können entscheiden ob zwei EBNF Beschreibungen äquivalent sind § Sie lernen EBNF Beschreibungen zu erstellen § Sie lernen den Unterschied zwischen Syntax und Semantik 38 Übersicht § Es gibt vier elementare Ausdrucksmöglichkeiten in EBNF § Schon gesehen: Aufreihung, Auswahl/Option, Wiederholung § Sie lernen EBNF Beschreibungen zu lesen und verstehen § Sie lernen zu entscheiden ob ein Symbol legal ist (für eine EBNF Beschreibung) § Sie können entscheiden ob zwei EBNF Beschreibungen äquivalent sind § Sie lernen EBNF Beschreibungen zu erstellen § Sie lernen den Unterschied zwischen Syntax und Semantik 39 1.2 Symbole und EBNF Beschreibungen § Wie können wir eine EBNF Beschreibung wie ein Schiedsrichter interpretieren? § Gegeben eine EBNF Beschreibung und ein Symbol § Symbol: eine Folge von Zeichen § Schiedsrichter entscheidet ob das Symbol legal ist oder nicht (für diese EBNF Beschreibung) § Symbol legal gemäss einer Regel: alle Zeichen des Symbols stimmen mit den Elementen der Regel überein 40 Zeichen im Symbol – Elemente der Regel § Genaue Übereinstimmung: legal § Vergleich Zeichen im Symbol mit Elementen der Regel § Von Links nach Rechts § Zeichen für Zeichen § Ende des Symbols § Es darf kein (nicht-optionales) Element der Regel übrig bleiben § Keine weitere Regel § Es darf kein Zeichen im Symbol übrig bleiben § Nur dann sprechen wir von Übereinstimmung § Sonst: Symbol nicht legal oder illegal 41 Informeller Beweis: § Genaue Übereinstimmung: legal § Es darf kein Zeichen im Symbol übrig bleiben § Es darf kein (nicht-optionales) Element der Regel übrig bleiben § Nur dann sprechen wir von Übereinstimmung § Sonst: Symbol nicht legal, illegal 42 § Beispiel (mit digit): 6 legal, 86 nicht legal § Beispiel (mit digit): sign ⟸ [ + | - ] signed_number ⟸ sign digit 9, +9, -9 legal, 09, +-9 nichtAnimation 44 EBNF Beispiel (i1) 45 1.2.1 Informelle Beweise § Zeige dass X mit integer übereinstimmt (Beschreibung i1) § Start: 1. Element (optionales Vorzeichen) § Option gewählt oder nicht gewählt § nächstes Zeichen des Symbols muss mit Zeichen übereinstimmen § Zeichen durch digit Regel bestimmt § Wähle auf der RHS von digit § Keine oder mehr Wiederholungen 46 Informelle Beweise § Zeige dass +70 mit integer übereinstimmt (Beschreibung i1) § Start: 1. Element (optionales Vorzeichen) § Option gewählt oder nicht gewählt § nächstes Zeichen des Symbols muss mit Zeichen übereinstimmen § Zeichen durch digit Regel bestimmt § Wähle 7 auf der RHS von digit § Keine oder mehr Wiederholungen § Eine Wiederholung – Zeichen durch digit Regel bestimmt § Wähle 0 auf der RHS von digit § +70 ist legal 47 Animation 49 Informelle Beweise § Wissen (oder probieren) richtige Anzahl von Wiederholungen § Wenn Beschreibung nicht eindeutig dann finden wir die richtige Alternative 50 Animation 5256 Informeller Beweis für +8+1 58 Mehr Beispiele § 1249 § -320 § +445 59 Mehr Beispiele § 1’249 § A15 § 345- 60 1.2.2 Tabellen § Formaler als Umgangssprache § Kompakter § 1. Zeile: Name der EBNF Regel, mit der das Symbol übereinstimmen soll § Letzte Zeile: Symbol 63 Tabellen § Jede Zeile wird aus der Vorgängerzeile durch eine dieser Regeln abgeleitet: 1. Ersetze einen Namen (LHS) durch die entsprechende Definition (RHS) 2. Wahl einer Alternative 3. Entscheidung ob ein optionales Element dabei ist oder nicht 4. Bestimmung der Zahl der Wiederholungen § Manchmal werden 1&2 in einem Schritt gemacht 6465 Ableitungsbäume § Graphische Darstellung eines Beweises durch eine Tabelle § Oben: Name der EBNF Regel, mit der das Symbol übereinstimmen soll § Unten: Symbol § Kanten zeigen welche Regeln es uns erlauben von einer Zeile zur nächsten (in der Tabelle) zu gehen 71 Ableitungsbaum Beispiel 7273 Schnellübung § Welche dieser Symbole sind legal gemäss der integer Beschreibung (i1)? 78 1. +28 2. +0 3. - 4. IX 5. 333-111 6. -354 7. two 8. a2 9. 0 10. $100 11. 007 12. 824 Poll 79 aus dem Archiv….. Poll 8182 Ableitungsbaum für 28 integer [ + | - ] digit { digit } 2 digit 8 Eine Option die nicht genommen wurde Ableitungsbaum Versuch für A15 integer [ + | - ] digit { digit } Es geht nicht weiter. A ist nicht legale digit Poll 83 Ableitungsbaum für 28 integer [ + | - ] digit { digit } 2 digit 8 Eine Option die nicht genommen wurde Geht auch (mit \") { digit } \" 0 Wieder- holungen Sonderzeichen § Diese acht Zeichen (Buchstaben ) haben eine besondere Bedeutung in EBNF Beschreibungen: {, }, [, ], |, (, ), ⟸ § Auch < und > wenn wir Namen nicht kursiv schreiben § Was machen wir wenn wir ein \"{\" in einem Symbol wollen? § z.B. um eine Menge zu beschreiben § Antwort: Zeichen in Rahmen { § Manchmal alle Zeichen die nicht eine EBNF Regel bezeichnen in einem Rahmen § Alternativen (in Textbüchern): In Anführungszeichen, z.B. \"(\" § Dann ist \" auch ein Sonderzeichen 86 Sonderzeichen § Diese acht Zeichen (Buchstaben ) haben eine besondere Bedeutung in EBNF Beschreibungen: {, }, [, ], |, (, ), ⟸ § Auch < und > wenn wir Namen nicht kursiv schreiben § Was machen wir wenn wir ein \"{\" in einem Symbol wollen? § z.B. um eine Menge zu beschreiben § Antwort: Zeichen in Rahmen { § Manchmal alle Zeichen die nicht eine EBNF Regel bezeichnen in einem Rahmen § Alternativen (in Textbüchern): In Anführungszeichen, z.B. \"(\" § Dann ist \" auch ein Sonderzeichen § Um ein \" in einem Symbol zu bekommen: \"\" 87 Äquivalente EBNF Beschreibungen § Äquivalent: gleichwertig (sind immer gleich – in einem Kontext) 89 äqui- valent Äquivalent bzgl. Kaufkraft, nicht aber vor einem Automaten der keine Banknoten nimmt Äquivalente EBNF Beschreibungen § Äquivalent: gleichwertig (sind immer gleich – in einem Kontext) § Äquivalente EBNF Beschreibungen erkennen die selben legalen und illegalen Symbole § Jedes mögliche Symbol wird von beiden Beschreibungen als legal (oder illegal) erkannt 90 Äquivalente EBNF Beschreibungen § Jede EBNF Beschreibung definiert eine Sprache: Menge der legalen Symbole § Äquivalente EBNF Beschreibungen erkennen die selben legalen und illegalen Symbole § Jedes mögliche Symbol wird von beiden Beschreibungen als legal (oder illegal) erkannt § Die Sprachen der EBNF Beschreibungen sind identisch 91 Äquivalenz von EBNF Beschreibungen § Zwei EBNF Beschreibungen B1, B2 definieren die selbe Sprache: § Symbol legal für B1: dann auch legal für B2 § Symbol illegal für B1: dann auch illegal für B2 § Symbol legal für B2: dann auch legal für B1 § Symbol illegal für B2: dann auch illegal für B1 § B1 und B2 äquivalent 92 Weitere EBNF Beschreibung für integer (i4) 94 Andere Beschreibung für integer (i4') 97 Noch eine andere Beschreibung § Äquivalent zu früherer Beschreibung? § Symbol legal gemäss 1. Beschreibung: legal gemäss dieser Beschreibung § Gilt auch die Umkehrung? 98 Noch eine andere Beschreibung § Symbol legal gemäss 1. Beschreibung: legal gemäss dieser Beschreibung § Gilt auch die Umkehrung? § Nein: + ist jetzt legal, - ist jetzt legal § Nein: \" (leere Zeichenfolge) jetzt eine legale integer 100 Andere Zahlendarstellungen § Wir möchten auch Zahlen mit Hochkomma (z.B., 1’412) als integer erkennen § Fügen wir also ‘ zu digit als Alternative hinzu § EBNF Beschreibung comma_integer (ci1) § sign ⟸ + | - § comma_digit ⟸ 0| 1| 2| 3| 4| 5| 6| 7| 8| 9| ‘ § comma_integer ⟸ [sign] comma_digit { comma_digit } 102104 Frage § Beschreibung comma_integer lässt Symbole zu, die wir nicht akzeptieren wollen. § Können wir (ci1) so ändern, dass Hochkommas richtig (zur Gruppierung in Tausenderblöcke) gesetzt werden? § Jede Dreier-Gruppe von Ziffern ist durch ein Hochkomma von den links davor geschriebenen Ziffern getrennt. § Wenn eine Dreier-Gruppe am Anfang steht, dann steht dort kein Hochkomma (denn es gibt ja keine Ziffern links davor) 105 EBNF Beschreibung comma_integer (ci2) sign ⟸ + | - digit ⟸ 0| 1| 2| 3| 4| 5| 6| 7| 8| 9| 0 comma_separated_digits ⟸ digit digit digit number ⟸ digit | digit digit | digit digit digit comma_integer ⟸ [sign] number { ‘ comma_separated_digits } 106 Zurück zu integer (i1) § Welche dieser EBNF Beschreibungen ist äquivalent zur (früheren) Beschreibung (i1)? 107 A (i5) B (i6) Zurück zu integer § Welche dieser EBNF Beschreibungen ist äquivalent zur (früheren) Beschreibung (i1)? § Beide (A und B) 109 A (i5) B (i6) Syntax und Semantik § Syntax: Form § Semantik («semantics»): Bedeutung («meaning») § Syntax legt nur die Form fest. Alle lesenden Schiffe riechen gelb. Der Herrscher dachte an sich selbst zuletzt. 112 Syntax und Semantik § EBNF beschreibt nur die Syntax § Für Programmiersprachen: zwei wichtige Semantik Fragen: 1. Können unterschiedliche Symbole die selbe Bedeutung haben? 2. Kann ein Symbol verschiedene Bedeutungen haben? 113 Illustration § Symbole die wir untersuchen: Namen § Herr Wirth § Professor Wirth § Niklaus Wirth können sich auf selbe Person beziehen § Symbol das wir untersuchen: Ausdruck «nächste Vorlesung» § Die «nächste Vorlesung» fällt aus § 252-0027, (gestern): keine Vorlesung am Freitag § 252-0025, (gestern): keine Vorlesung am Montag 114 Semantik von integer § Bedeutung einer Zahl: ihr Wert § 1, +1 § -0, +0, 0 § Sollen 0012 und 12 die selbe Bedeutung haben? § Mathematik: ja § PIN code: nein 115 EBNF Beschreibung integer_set § Mengen von Zahlen § { Aufzählung von Zahlen } § Zwischen { und } keine, eine oder Reihe von Zahlen, durch Komma getrennt § { 1 } {3, 2} {3, 2, 3} { } § In EBNF Regeln, müssen unterscheiden zwischen { und { 117 EBNF Beschreibung integer_set § Mengen von Zahlen § { Aufzählung von Zahlen } § Zwischen { und } keine, eine oder Reihe von Zahlen, durch Komma getrennt § { 1 } {3, 2} {3, 2, 3} { } EBNF Beschreibung integer_list ⟸ integer { , integer } integer_set ⟸ { [ integer_list ] } 122 Diskussion § integer_list Regel – ähnlich vielen Regeln für Java § Beispiele § { } § { 1 } § { 2, -5, 18 } § Kann durch Tabelle (oder Ableitungsbaum) gezeigt werden 123 Diskussion { 2, -5, 18 } § Lemma: 2 ist eine integer § Lemma: -5 ist eine integer § Lemma: 18 ist eine integer 124125 Tabelle Regel integer_set Anfang jeder Tabelle { [ integer_list ] } Ersetzen von integer_set durch RHS (1) { integer_list } Option eingeschlossen (3) { integer { , integer } } Ersetzen von integer_list durch RHS (1) { integer , integer , integer } 2 Wiederholungen (4) { 2 , integer , integer } Lemma { 2 , -5 , integer } { 2 , -5 , 18 } 126 Bedeutung von Mengen § Wann sind zwei Mengen äquivalent? § Mehrfach Nennungen sind nicht wichtig § {1, 2, 3, 3, 2, 2, 2 } äquivalent zu {1, 2, 3} § Reihenfolge nicht wichtig § { 1, 2, 3 } äquivalent zu { 3, 2, 1 } § Kanonische (in Übereinstimmung mit Regel) Darstellung: geordnet, von kleinster [links] nach grösster Zahl [rechts] § Die kanonische Darstellung kann nicht durch EBNF Regeln erzwungen werden 132 EBNF Beschreibungen § Erstellen Sie eine EBNF Beschreibung so dass Zahlen nicht mit einer Null anfangen (also 007 ist illegal, 7 ist legal). 133 zero ⟸ 0 nonzero ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 digit ⟸ zero | nonzero integer ⟸ [ + | - ] nonzero { digit } 134 zero ⟸ 0 nonzero ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 digit ⟸ zero | nonzero integer ⟸ [ + | - ] nonzero { digit } … aber jetzt ist 0 kein gültiges Symbol Wie können wir die Beschreibung verbessern? 135 EBNF Beschreibung canonic_int zero ⟸ 0 nonzero ⟸ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 digit ⟸ zero | nonzero canonic_ int ⟸ ( [ + | - ] nonzero { digit } ) | zero Lässt nur 0, nicht aber +0 oder -0 zu (auf vielfachen Wunsch) 136 252-0027 Einführung in die Programmierung 1.0 EBNF Thomas R. Gross Department Informatik ETH Zürich 1.4 Graphische Darstellung von EBNF Regeln § Syntax Graph: graphische Darstellung § Kanten (gerichtet) mit Zeichen § Pfad durch den Graphen entspricht legalem Symbol § Links anfangen, dann durch Graphen § Macht es leicht(er) zu erkennen, welche Zeichen in einem Symbol (in welcher Reihenfolge) auftreten müssen 2 Graphische Darstellung von EBNF Regeln § Aufreihung: A B C D als Graph: § Option: [ A ] als Graph: 4 § Wiederholung: { A } als Graph: ABCD DCBA Graphische Darstellung von EBNF Regeln § Aufreihung: A B C D als Graph: § Option: [ A ] als Graph: 6 § Wiederholung: { A } als Graph: ABCD DCBA Graphische Darstellung von EBNF Regeln § Aufreihung: A B C D als Graph: § Option: [ A ] als Graph: 7 § Wiederholung: { A } als Graph: ABCD DCBA [A] A {A} A § Auswahl: A | B | C | D als Graph 9 A B C D A|B|C|D Pfad durch Graph: legales Symbol § Aufreihung: durch jedes Element in der Reihe § Auswahl: ein Element in der Leiter § Option: entweder obere Kante (mit Element) oder untere (ohne) § Wiederholung: wie Auswahl § Einzige Form die einen Pfeil von rechts nach links hat 12 Pfade durch Graphen § EBNF Beschreibung: Menge von EBNF Regeln § Graph: Menge von Graphen § Ein Graph für jede Regel § Pfad(e) durch Graphen für Regeln 13 Wofür wir ( und ) brauchen § A B | C 14 Wofür wir ( und ) gebrauchen können § A B | C § Welcher Graph? 15 A B C A B C Wofür wir ( und ) gebrauchen können § A B | C § Um Unklarheit zu vermeiden verwenden wir ( und ) § A ( B | C ) § (A B ) | C --- wenn es keine Klammern gibt --- Aufreihung «bindet stärker» als Auswahl 16 A B C A B C EBNF Beispiel (i1) nochmal 17 Beispiel 18 0 1 2 3 4 5 6 7 8 9 digit + − integer digit digit Substitution § Können einen Syntax Graphen in einen anderen einsetzen § «interne» Namen verschwinden § EBNF Beschreibung § Alle Graphen für Regeln der Beschreibung zusammen 23 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 + − integer Was für Symbole sind legal (für Graph)? 1. 2. 26 3.252-0027 Einführung in die Programmierung 1.0 EBNF Thomas R. Gross Department Informatik ETH Zürich Control forms (zum Kombinieren) § Aufreihung § Auswahl (Entscheidung) § Option, Wiederholung § Rekursion 35 § EBNF Regel besteht aus: § Linke-Seite (Left-Hand Side, LHS) § Rechte-Seite (Right-Hand Side, RHS) § ⟸ (trennt LHS von RHS, ausgesprochen «ist definiert als») § LHS § Ein Wort (kursiv, kleingeschrieben) – der Name der EBNF Regel § RHS § Die genaue Beschreibung für den Namen (d.h., der LHS) durch § Namen (von EBNF Regeln) – kursiv und kleingeschrieben § Zeichen (stellen das Zeichen da, d.h. wir erwarten dieses Zeichen und kein anderes) – nicht kursiv § Kombinationen der vier Kontrolelemente («control forms») (auf folgenden Seiten) 36 LHS ⟸ RHS 1.5 Rekursion 37 Positive (ganze) Zahlen § EBNF Regel pos_integer soll ganze Zahlen ohne Vorzeichen beschreiben § Wir haben eine Regel für Ziffern: digit ⟸ 0| 1| 2| 3| 4| 5| 6| 7| 8| 9 § Erster Versuch pos_integer ⟸ digit ....... 38 Mehr davon Positive (ganze) Zahlen § EBNF Regel pos_integer soll positive Zahlen ohne Vorzeichen beschreiben § Wir haben eine Regel für Ziffern: digit ⟸ 0| 1| 2| 3| 4| 5| 6| 7| 8| 9 § Erster Versuch pos_integer ⟸ digit ....... § Einfache Wiederholung nicht was wir wollen § Aber vielleicht ein Anfang 40 pos_integer ⟸ { digit } \" ist legale positive Zahl Option – kann, muss aber nicht dabei sein § Was wenn wir den Namen einer Regel auf der rechten Seite dieser Regel verwenden? § Mit Option – können alle ganzen Zahlen ohne Vorzeichen beschreiben § pos_integer ⟸ digit [ pos_integer ] 41 pos_integer ⟸ digit [ pos_integer ] § Beispiele für legale Symbole 42 pos_integer digit pos_integer digit digit pos_integer digit pos_integer digit pos_integer digit digit pos_integer digit digit digit Option nicht genommen Option nicht genommen Option nicht genommen Name der LHS auch auf der RHS § Es muss (mindestens) einen Weg geben, Namen der LHS durch eine RHS ohne diesen Namen zu ersetzen § pos_integer ⟸ digit [ pos_integer ] § Nicht-Wahl der Option: Nur digit auf der RHS § Andere Möglichkeit pos_integer ⟸ ( digit pos_integer ) | \" 44 pos_integer digit pos_integer digit digit pos_integer digit digit \" digit digit pos_integer digit pos_integer digit \" digit Ohne Klammern: Aufreihung bindet stärker als Auswahl Name der LHS auch auf der RHS § Es muss (mindestens) einen Weg geben, Namen der LHS durch eine RHS ohne diesen Namen zu ersetzen § pos_integer ⟸ digit [ pos_integer ] § Nicht-Wahl der Option: Nur digit auf der RHS § Andere Möglichkeit pos_integer ⟸ digit pos_integer | \" 45 pos_integer digit pos_integer digit digit pos_integer digit digit \" digit digit pos_integer digit pos_integer digit \" digit Rekursive Regel § Regel ist rekursiv: ihr Name wird in der Definition verwendet pos_integer ⟸ digit [ pos_integer ] § Beschreibung ist rekursiv: mindestens eine rekursive Regel 46 Rekursion § Rekursive Beschreibung enthält rekursive Regeln § Eine Regel ist direkt rekursiv wenn ihr Name in der Definition verwendet wird § Also die LHS erscheint auch auf der RHS § r ⟸ | A r § r ⟸ | ( A r ) falls Sie Unklarheit vermeiden wollen § r ⟸ \" | ( A r ) falls Sie alle Unklarheiten vermeiden wollen § EBNF Description r beschreibt Folge von null oder mehr A Zeichen 47 Diskussion 48 Rekursive Regel § Regel ist rekursiv: ihr Name wird in der Definition verwendet pos_integer ⟸ digit [ pos_integer ] § Hätten wir auch anders machen können § pos_integer ⟸ digit { digit } 50 Diskussion § Warum der Aufwand? § r ⟸ { A } § pos_number ⟸ { digit } § Kann jede Rekursion durch Wiederholung(en) ausgedrückt werden? § Kann jede Wiederholung durch Rekursion ausgedrückt werden? 51 Diskussion 53 Diskussion § Kann jede Rekursion durch Wiederholung(en) ausgedrückt werden? § Nein § Finden Sie Beschreibung für An Bn (n Zahl ≥ 0: also gleiche Anzahl A, B) EBNF Description balance balance ⟸ \" | A balance B balance ⟸ \" | ( A balance B ) 55 § Direkte Rekursion § r ⟸ A | A r § Indirekte Rekursion § Folge von Regeln N1 … Nk so dass N2 auf der RHS von N1, N3 auf der RHS von N2, … und N1 auf der RHS von Nk erscheint name2 ⟸ ( name1 B ) | ( X B ) name1 ⟸ A name2 61 § Direkte Rekursion § r ⟸ A | A r § Indirekte Rekursion § Folge von Regeln N1 … Nk so dass N2 auf der RHS von N1, N3 auf der RHS von N2, … und N1 auf der RHS von Nk erscheint name2 ⟸ name1 B | X B name1 ⟸ A name2 § Beschreibung von name1: AXB, AAXBB, .... 63 Ohne Klammern: Aufreihung bindet stärker als Auswahl Zusammenfassung: Ableitungsbaum, Tabellen, Graphen § Ein Ableitungsbaum oder eine Tabelle demonstrieren, dass ein Symbol legal gemäss einer EBNF Beschreibung ist. § In beiden Fällen kürzen wir die Schritte manchmal ab wenn keine Verwechslungsgefahr besteht. § Ein (EBNF) Graph ist eine andere Darstellung einer EBNF Beschreibung § Ein Pfad durch den Graphen entspricht einem Symbol das legal ist § Umgekehrt: um zu zeigen, dass ein Symbol legal ist, finden wir einen Pfad § Graph für rekursive Beschreibung: nicht elegant (muss endlich sein!) 65 r ⟸ B | A r § Ist AAB legal? -- Tabelle 66 Regel r Anfang jeder Tabelle B | A r Ersetzen von r durch RHS (1) A r 2. Auswahlmöglichkeit gewählt (2) A ( B | A r ) Ersetzen von r durch RHS (1), () zur Vermeidung von Missverständnissen A A r 2. Auswahlmöglichkeit gewählt (2) A A ( B | A r ) Ersetzen von r durch RHS (1) A A B 1. Auswahlmöglichkeit gewählt (2) r ⟸ B | A r § Ist AAB legal? -- Ableitungsbaum (Version 1) § In jeder Zeile wird eine EBNF Beschreibung durch eine rechte Seite ersetzt (hier immer A r, bis auf den letzten Schritt) 67 r B A r B A r B A r Auswahl getroffen § Ist AAB legal? -- Ableitungsbaum (Version 2) § Wir fassen Schritt 1 (Ersetzen der RHS) mit Schritt 2 (Auswahl treffen) zusammen § Unwichtiges lassen wir weg 68 r B A r B A r B A r § Ist AA legal? -- Ableitungsbaum (Version 2) § Wir fassen Schritt 1 (Ersetzen der RHS) mit Schritt 2 (Auswahl treffen) zusammen § Unwichtiges lassen wir weg 69 r A r A r r ⟸ \" | A r oder r ⟸ | A r EBNF Geschichte § BNF enthielt erst nur Rekursion und Auswahl § Diese sind essential § Option und Wiederholung von Niklaus Wirth hinzugefügt § Daher «E» – extended § Machen Beschreibung einfacher zu lesen § Motivation: Beschreibung von Pascal 71 Nochmal integer 72 EBNF § Das war’s. 73 252-0027 Einführung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH Zürich Übersicht § 2.0 Einfache Java Programme § 2.1 Methoden § Struktur § 2.2 Typen und Variable § 2.2.1 Einführung § 2.2.2 Basistypen: Einfache (eingebaute) Typen § 2.2.3 Deklaration von Variablen 2 2.0 Einfache Java Programme § Übersicht § Struktur § Namen § Output 3 2.0 Einfache Java Programme § Sie sollten Übung 0 bis Mittwoch (28. 9.) gemacht haben § Oder sicher sein dass diese keine Schwierigkeiten macht § Ab Übung 1 müssen Sie in «myStudies» registriert sein um Aufgaben abgeben zu können § Stellt sicher dass Sie Programmfragmente erhalten können und Lösungen abgeben können § «Nachzügler» müssen eMail schicken (siehe Web Seite) § Fragen Sie im Gruppentreffen morgen bei Problemen 5 EBNF § Hält die Syntax Regeln von Java Programmen fest § Beispiel: Namen in Programmen § Bezeichner («identifier») müssen Anforderungen erfüllen § Bezeichner muss mindestens ein Zeichen lang sein § … muss mit Buchstaben anfangen (a-z, A-Z) § … kann Buchstaben oder Ziffern (0-9) enthalten § (Java erlaubt noch mehr) (Manchmal gibt es noch mehr Einschränkungen) 6 Beispiel: Bezeichner («identifier») 8 Java Regeln (vereinfacht) EBNF Beschreibung bezeichner lowercaseletter ⟸ a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z uppercaseletter ⟸ A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z letter ⟸ lowercaseletter | uppercaseletter digit ⟸ 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7| 8 | 9 bezeichner ⟸ letter { letter | digit } 9 Java Regeln (vereinfacht) EBNF Beschreibung identifier lowercaseletter ⟸ a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z uppercaseletter ⟸ A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z letter ⟸ lowercaseletter | uppercaseletter digit ⟸ 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7| 8 | 9 identifier ⟸ letter { letter | digit } 10 Java Programme § Erstellen § Ausführen 11 Java Programme § Ganzes Programm § Für jede Datei … § Erstellen § Ausführen § Modifizieren 12 § Einzelne Anweisungen § Für jede Anweisung … § Lesen (Read) § Evaluieren (Ausführen) § Ausgeben (Print) § REPL § Read-Evaluate-Print Loop Java Programm: Text à Output 14 Java Programm (Text) Java Anweisungen Java Anweisungen Java Anweisungen Java Anweisungen Output (Grafik) Output (Text) Die Note ist: 6.0 Output (...) 0929095 8395798 9216320 0082134 Java Programm: Text à Output 15 Java Programm (Text) Java Anweisungen Java Anweisungen Java Anweisungen Java Anweisungen Output (Grafik) Output (Text) Die Note ist: 6.0 Output (...) 0929095 8395798 9216320 0082134 Java Programm (Prozessor Instruktionen) P1 Befehl P1 Befehl P1 Befehl P1 Befehl P1 Befehl Compiler Prozessor Übersetzt Führt aus Editor Java Programm: Text à Output 16 Java Programm (Text) Java Anweisungen Java Anweisungen Java Anweisungen Java Anweisungen Output (Grafik) Output (Text) Die Note ist: 6.0 Output (...) 0929095 8395798 9216320 0082134 Java Programm (Prozessor Instruktionen) P1 Befehl P1 Befehl P1 Befehl P1 Befehl P1 Befehl P1 Check P1 Check Compiler Prozessor + Laufzeit- system Übersetzt und prüft Führt aus und prüft Editor Java Programme § Ganzes Programm § Für jede Datei … § Erstellen (mit Editor) § Übersetzen (mit Compiler) § Ausführen (auf Prozessor) § Output analysieren § Modifizieren § Eclipse IDE enthält alle Komponenten § «Industrial strength» integrierte Entwicklungsumgebung 1719 Java und Eclipse § Viele Aspekte § Zuerst: Fokus auf das wichtigste § Sie kennen Java/Eclipse schon: super § Aber denken Sie an die, die noch nicht so weit sind § Schrittweise erklären wir mehr Konzepte § Was uns (jetzt) nicht interessiert: abdecken § Können diese Teile nicht ignorieren § Müssen diese Teile (fürs Erste) akzeptieren 202122 Java § Wir ignorieren fürs erste viele Aspekte die nicht absolut notwendig zum Verständnis sind § 1. Ziel: Programm lesen § 2. Ziel: Programm verstehen § 3. Ziel: Programm erstellen § Oft durch Modifikation eines Programmes § Wir können aber nicht alles ignorieren … 232425 § class : Java Programm (nur 1 class/Datei fürs erste) § Name des Programms gleich Namen der Datei (!!) 27 Java Programm javaprogram ⟸ public class bezeichner { method } 29 Hier fehlt noch etwas! Java Programm javaprogram ⟸ public class bezeichner { methoddefinition } 303133 § main: Java Methode (Java Code den wir ausführen können) § Methode enthält Aufreihung («sequence») von Anweisungen («statements») Java Programm javaprogram ⟸ public class bezeichner { methoddefinition } methoddefinition ⟸ public static void main ( String [] args ) { statementsequence } 34 Aufreihung von Anweisungen: statementsequence § Viele mögliche Anweisungen («Statements») § Zuweisungen § Schleifen § Input/Output § Methoden/Funktionen–Aufruf § Liste nicht vollständig 35 Aufreihung von Anweisungen: statementsequence § Viele mögliche Anweisungen (Statements) § Wichtig für Java (und viele anderen Programmiersprachen): § Methodenaufruf global bekannter Methoden § Format: MethodenName ( ) ; 36 Aufreihung von Anweisungen: statementsequence § Viele mögliche Anweisungen (Statements) § Wichtig für Java (und viele anderen Programmiersprachen): § Methodenaufruf für ein Objekt (Beispiel folgt) § Format: Objekt . MethodenName ( ) ; 37 Aufreihung von Anweisungen: statementsequence § Viele mögliche Anweisungen (Statements) § Wichtig für Java (und viele anderen Programmiersprachen): § Methodenaufruf § Format: Objekt . MethodenName ( ) ; 38 Details oder mehr Informationen Mit dem Objekt System.out können wir mit der println() Methode Text ausgeben System.out.println( ); Mehr über Text in ein paar Minuten -- es gibt viele Methoden für Textbearbeitung jshell> \"Hello\".toUpperCase(); 41 Objekt . MethodenName ( ) ; \"Hello\" . toUpperCase(); Beispiel Viele Methoden lassen das Objekt mit dem die Methode arbeitet unverändert Animation 4345 § println: Java Methode (Funktion) 46 § println: Java Methode (Funktion) § Gibt String aus («druckt») § String: Text zwischen \" (Anführungszeichen, «quotation mark», «double quote») und \" (beide \" müssen oben sein) 4748 Ausführen (automatisch übersetzt – sonst geht Ausführung nicht Java Details § Wir werden einen Teil des Programmes (fürs erste) ignorieren § Aber wir können diese Teile nicht weglassen/ignorieren! § Sonst können wir das Java Programm nicht «übersetzen» § Übersetzen (kompilieren, «compile\") heisst in eine Form bringen, die ausgeführt werden kann § Es gibt Fehlermeldungen wenn wir Teile weglassen oder falsch schreiben 49505152 Java § Nicht alle Rückmeldungen des Übersetzers («compilers») sind so klar 535455 Wir machen mal weiter …. 565758 § Leicht zu übersehen: die letzte } fehlt 59 Zusammenfassung public class name { public static void main(String[] args) { statement; statement; ... statement; } } 60 class: ein Programm mit Namen name statement: Anweisung die ausgeführt werden soll method: Gruppe von Anweisungen mit Namen main § Jedes (ausführbare) Java Programm besteht aus einer Klasse (class) § die eine Methode main enthält, § die eine Reihe von Anweisungen enthält § Später arbeiten wir mit Programmen mit mehreren Klassen 61 Java Programme 63 § Einzelne Anweisungen § Für jede Anweisung … § Lesen (Read) § Evaluieren (Ausführen) § Ausgeben (Print) § REPL § Read-Evaluate-Print Loop § Kein IDE nötig dafür JShell 64 Aufruf JShell auf Commandline Eine (Java) Anweisung Output 65 Aufruf JShell auf Commandline Eingabe einer Methode § Ist jetzt global bekannt § Erspart class und public static etc § Gut für kleine Programme Aufruf Methode main mit Output Namen und Bezeichner Jedes Programm braucht einen Namen public class HelloWorld {…} § Konvention: fängt mit Grossbuchstaben an § Konvention: Grossbuchstaben zur verbesserten Lesbarkeit § Regel: Dateiname gleich Programmname HelloWorld.java § Gross/Kleinbuchstaben sind (in Java) unterschiedlich 66 Jede Methode braucht einen Namen public static void main(String[] args) {…} § Konvention: fängt mit Kleinbuchstaben an § Konvention: Grossbuchstaben zur verbesserten Lesbarkeit § Beispiel: toUpperCase § Sonstige Bezeichner: Name für ein Programmelement § Muss mit einem Buchstaben (gross oder klein) anfangen § Danach Ziffern, Buchstaben oder _ («underscore», Unterstrich) § Weitere Konventionen später 67 Reservierte Symbole 69 § keyword: Ein Bezeichner («identifier») der reserviert ist (weil er für die Sprache eine besondere Bedeutung hat) abstract default if private this boolean do implements protected throw break double import public throws byte else instanceof return transient case extends int short try catch final interface static var char finally long strictfp void class float native super volatile const for new switch while continue goto package synchronized Reservierte Symbole 70 § Reserviert für besondere Werte false null true Kommentare Kommentare («comments») sind Notizen im Programmtext, die einem Leser beim Verstehen des Programmes helfen (sollen) § Leser: kann auch der Autor sein § Kommentare werden nicht ausgeführt, haben keinen Einfluss auf Programm § 2 Varianten § // Text bis zum Ende der Zeile § /* Text bis § zum naechsten */ 72 Ein triviales Programm … /* * Einfaches Programm aus vielen Texten * Author: Unbekannt */ public class HelloWorld { // nur eine Methode! // mit einer Anweisung!! public static void main(String[] args) { System.out.println(\"Hello World!\"); } // Ende von main } 73 Strings § String: eine Folge von Zeichen («characters») eingeschlossen in \" und \" § \"hello\" § \"Hello\" § \"3+2\" § Einschränkungen: § Nur eine Zeile lang \"Das ist kein Java String\" § Darf nicht \" enthalten (\"So etwas \"geht\" nicht\") § Achtung: verwenden Sie \" im Programm (nicht Varianten, auch wenn die Slides diese (manchmal) verwenden [Danke Powerpoint!]) 77 println(), println(\"Hello\") public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World!\"); System.out.println(); System.out.println(\"Hello World!\"); } } § println(String) Methode die einen String ausgibt § Arbeitet mit Objekt System.out 78 Output: Hello World! Hello World! Sonderzeichen § Und was machen wir wenn wir ein \" ausgeben wollen? § Es gibt sogenannte Ersatzdarstellungen («escape sequences») mit denen ein Sonderzeichen ausgedrückt werden kann § Fangen alle mit \\ (Rückwärtsschrägstrich) («backslash») an \\t Tab character \\n Neue Zeile (new line character) \\\" Quotation mark (double quote) character \\\\ Backslash character 80 Beispiele § Beispiel: System.out.println(\"\\\\Hallo\\nWie\\tgeht es \\\"Ihnen\\\"?\\\\\\\\\"); § Output: 82 Beispiele § Beispiel: System.out.println(\"\\\\Hallo\\nWie\\tgeht es \\\"Ihnen\\\"?\\\\\\\\\"); § Output: \\Hallo Wie geht es \"Ihnen\"?\\\\ 83 Fragen § Was drucken diese println Statements? System.out.println(\"\\ta\\tb\\tc\"); System.out.println(\"\\\\\\\\\"); System.out.println(\"'\"); System.out.println(\"\\\"\\\"\\\"\"); System.out.println(\"C:\\neuer Spor\\t Wagen\"); § Welches println Statement druckt diesen String? / \\ // \\\\ /// \\\\\\ 84 Antwort § Output jedes println Statements: a b c \\\\ ' \"\"\" C: euer Spor Wagen 85 Antwort § println Statement um die gewünschte Zeitle Output zu erzeugen: System.out.println(\"/ \\\\ // \\\\\\\\ /// \\\\\\\\\\\\\"); 86 252-0027 Einführung in die Programmierung 2.1 Methoden Thomas R. Gross Department Informatik ETH Zürich 88 Übersicht § 2.0 Einfache Java Programme § 2.1 Methoden § Struktur § 2.2 Typen und Variable § 2.2.1 Einführung § 2.2.2 Basistypen: Einfache (eingebaute) Typen § 2.2.3 Deklaration von Variablen 89 Übersicht public class name { public static void main(String[] args) { statement; statement; ... statement; } } 91 class: ein Programm mit Namen name Folge von Anweisungen: Rumpf («body») der Methode method: Gruppe von Anweisungen mit Namen main 2.1 Methoden § Beispiel: main im Program HelloWorld § Eine Klasse kann mehrere Methoden enthalten. 92 Methoden public class name { public static void main(String[] args) { statement; ... statement; } public static void helper() { statement; ... statement; } } 93 method: Gruppe von Anweisungen mit Namen main method: Gruppe von Anweisungen mit Namen helper Methoden § Methode: Sequenz von Anweisungen mit einem Namen (dem der Methode) § Methoden strukturieren die Anweisungen § Anstatt alle Anweisungen in einer Methode (main) unterzubringen § Methoden erlauben es, Wiederholungen zu vermeiden § Mehrfache Ausführung, aber nur einmal im Programm(text) § Eine (neue) Methode stellt eine neue Anweisung zur Verfügung 95 static methods § static methods: Methode mit weiteren Eigenschaften § main ist eine static method (Keyword static vor Name) § main wird automatisch aufgerufen § Wir erklären gleich wie andere Methoden aufgerufen werden 96 (Zu) Einfaches Beispiel public class PrintExample1 { public static void main(String[] args) { System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Lange Erklaerung\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } // main } 97 Output 98 -------- Warnung: sichern Sie die Daten -------- Lange Erklaerung -------- Warnung: sichern Sie die Daten -------- Wie entstehen Methoden? § Entwickeln des Algorithmus § Lösung des Problems § Aufteilung in Teil-Probleme § Festhalten des Algorithmus (auf- schreiben, codieren) § Ausführen (aufrufen, «call», «invoke») der Methode(n) 99 class method main n statement n statement n statement n statement n statement n statement n statement n statement n statement n statement Wie entstehen Methoden? § Entwickeln des Algorithmus § Lösung des Problems § Aufteilung in Teil-Probleme § Festhalten des Algorithmus (auf- schreiben, codieren) § Ausführen (aufrufen, «call», «invoke») der Methode(n) 100 class method main n statement n statement n statement method one n statement n statement method two n statement n statement n statement (Zu) Einfaches Beispiel public class PrintExample2 { // main fehlt noch public static void printWarning() { System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } } 101 § Entwickeln des Algorithmus § Lösung des Problems § Aufteilung in Teil-Probleme § Festhalten des Algorithmus (auf- schreiben, codieren) § Ausführen (aufrufen, «call», «invoke») der Methode(n) 102 class method main n one n statement n two method one n statement n statement method two n statement n statement n statement Wie entstehen Methoden?Methoden Definition (1. Approximation) § Zuerst definieren wir nur einfache Methoden § public static void name () { § statement(s); // Rumpf § } § Die Methode name kann überall aufgerufen werden (public static) und gibt keinen Wert (void) zurück § Wir können uns vorstellen dass an der Stelle des Aufrufs der Rumpf (Body) der Methode ausgeführt (eingesetzt) wird. 103 Definition von static Methode(n) methoddefinition ⟸ public static void main ( String [] args ) { statementsequence } othermethoddef othermethoddef ⟸ { public static void name ( ) { statementsequence } } 105 Aufruf einer Methode § Es gibt zwei Wege eine Methode aufzurufen § Mit explizitem Objekt: Objekt.methodName(); § Beispiel: System.out.println(\"Text\"); \"Hello\".toUpperCase(); § Ohne Objekt § Geht nur für Methoden mit besonderen Eigenschaften § besondere Eigenschaften : static Keyword § static methods (Methoden mit Keyword static) werden ohne Objekt aufgerufen § Der Methodenname genügt § Beispiel: printWarning(); 106 (Zu) Einfaches Beispiel public class PrintExample2 { public static void main(String[] args) { printWarning(); System.out.println(\"Lange Erklaerung\"); printWarning(); } // main public static void printWarning() { System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } } 107 Aufruf einer (static) Methode § Syntax: name(); § EBNF Beschreibung: methodinvocation ⟸ bezeichner ( ) ; § Mehrfaches Aufrufen ist zulässig § Beispiel: printWarning(); printWarning(); 108 252-0027 Einführung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH Zürich 252-0027 Einführung in die Programmierung 2.1 Methoden Thomas R. Gross Department Informatik ETH Zürich 1 Übersicht § 2.1 Methoden § Struktur § 2.2 Typen und Variable § 2.2.1 Einführung § 2.2.2 Basistypen: Einfache (eingebaute) Typen § 2.2.3 Deklaration von Variablen 2 (Zu) Einfaches Beispiel public class PrintExample1 { public static void main(String[] args) { System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Lange Erklaerung\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } // main } 3 Wie entstehen Methoden? § Entwickeln des Algorithmus § Lösung des Problems § Aufteilung in Teil-Probleme § Festhalten des Algorithmus (auf- schreiben, codieren) § Ausführen (aufrufen, «call», «invoke») der Methode(n) 4 (Zu) Einfaches Beispiel public class PrintExample2 { // main fehlt noch public static void printWarning() { System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } } 5 Aufruf einer Methode § Es gibt zwei Wege eine Methode aufzurufen § Mit explizitem Objekt: Objekt.methodName(); § Beispiel: System.out.println(\"Text\"); \"Hello\".toUpperCase(); § Ohne Objekt § Geht nur für Methoden mit besonderen Eigenschaften § besondere Eigenschaften : static Keyword § static methods (Methoden mit Keyword static) werden ohne Objekt aufgerufen § Der Methodenname genügt § Beispiel: printWarning(); 6 (Zu) Einfaches Beispiel public class PrintExample2 { public static void main(String[] args) { printWarning(); System.out.println(\"Lange Erklaerung\"); printWarning(); } // main public static void printWarning() { System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } } 7 Aufruf einer (static) Methode § Syntax: name(); § EBNF Beschreibung: methodinvocation ⟸ bezeichner ( ) ; § Mehrfaches Aufrufen ist zulässig § Beispiel: printWarning(); printWarning(); 8 Definition von static Methode(n) methoddefinition ⟸ public static void main ( String [] args ) { statementsequence } othermethoddef othermethoddef ⟸ { public static void name ( ) { statementsequence } } 9 Aufruf einer Methode (mit oder ohne Objekt) § Wenn die Anweisung name() (für die Methode name) ...; // irgendeine Anweisung name(); // z.B. in main stmtN; // naechste Anweisung ausgeführt wird, dann wird die Methode name aufgerufen («invoked», «called») § Damit beginnt die Ausführung der Methode name. § Es gibt auch andere Wege, eine Ausführung zu starten, aber diese interessieren uns (noch) nicht. § Wenn name fertig ist, geht es mit stmtN weiter 10 Ausführen einer Methode § Methode name wird aufgerufen (d.h. name() ) § 1. Anweisung von name ausgeführt § Gibt es weitere Anweisungen? § Nein: Ende der Ausführung von name § Ja: § Nächste Anweisung ausgeführt, weiter wie oben § Wir bezeichnen die Abfolge der Ausführung von Anweisungen als Kontrolfluss («control flow») § geradliniger Kontrollfluss: die ausgeführten Anweisungen folgen im Programm aufeinander § In Java: Anweisungsreihenfolge ist explizit 11 § Wenn eine Methode aufgerufen wird, dann § «springt» die Ausführung zur Methode und führt die Anweisungen der Methode aus und danach § «springt» die Ausführung wieder zu dem Ort zurück von dem der Aufruf erfolgte § Und es geht weiter mit der nächsten Anweisung § Anordnung der Methoden im Programm(text) ohne Bedeutung Kontrollfluss bei Methodenaufruf 14 Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 15 Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 16 Hier fangen wir an Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 17 1. Anweisung Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 18 Hier geht es weiter Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 19 1. und letzte Anweisung Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } Hier geht es weiter 20 Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 21 Hier geht es weiter Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 22 1. Anweisung Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 23 2. Anweisung Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 24 Hier geht es weiter Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 25 1. und letzte Anweisung Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 26 Hier geht es weiter Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } 27 Letzte Anweisung Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } Hier geht es weiter 28 Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } Letzte Anweisung 29 Methoden die Methoden aufrufen public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Ende von \\\"main\\\" \"); } // main public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } // message1 public static void message2() { System.out.println(\"Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } // message2 } Ende main 30 Output § Nachricht 1: Fertig § Die 2. Nachricht: § Nachricht 1: Fertig § Ende von Nachricht 2 § Ende von \"main\" 31 public class MethodsExample { public static void main(String[] args) { message1(); message2(); System.out.println(\"Done with \\\"main\\\".\"); } ... } public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } public static void message2() { System.out.println(\" Die 2. Nachricht:\"); message1(); System.out.println(\"Ende von Nachricht 2\"); } public static void message1() { System.out.println(\"Nachricht 1: Fertig\"); } Kontrollfluss 32 Einfaches Beispiel (Wir verwenden jetzt println weil es einfach ist. Spätere Java Programme benutzen eine andere Schnittstelle für Benutzer.) 33 Beispiel mit static methods Schreiben Sie ein Programm um diese Figuren zu drucken ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 34 Entwicklungsschritte Version 1: (ohne Ausnutzen der Struktur) n Erstellen Sie ein Programm mit leerer main Methode. n Kopieren Sie den erwünschten Output in main und schreiben für jede Zeile eine entsprechende System.out.println Anweisung. n Führen Sie die Methode aus um den Output mit der gewünschten Figur zu vergleichen ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 35 Program Version 1 public class Figures1 { public static void main(String[] args){ System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(\"+--------+\"); System.out.println(); System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"| STOP |\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"+--------+\"); } // main } // Figures1 36 Entwicklungsschritte Version 2: (mit Ausnutzen der Struktur, mit Redundanz) n Identifizieren Sie (eventuell vorhandene) Strukture(n). n Unterteilen Sie die main Methode basierend auf Ihrer Strukturierung. n Führen Sie die Methode aus um den Output mit der gewünschten Figur zu vergleichen ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 37 Struktur des Output Strukturen in dieser Figur n oben: Sechseck (Hexagon) (oder Ball …) n darunter: «Wanne» (oder Suppentasse …) n drittens «STOP Schild» Figur n viertens «Trapez» (oder Hut Figur …) Struktur à Methoden : n hexagon n wanne n stopSign n hut ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 38 Program Version 2 public class Figures2 { public static void main(String[] args) { hexagon(); wanne(); stopSign(); hut(); } //main ... 39 Program Version 2, Fortsetzung ... public static void hexagon() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); } public static void wanne() { System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(\"+--------+\"); System.out.println(); } ... 40 Program Version 2, Fortsetzung ... public static void stopSign() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"| STOP |\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); } public static void hut() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"+--------+\"); } } //Figures2 4142 ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ Entwicklungsschritte Version 3 (mit Ausnutzen der Struktur, ohne Redundanz) n Identifizieren Sie (eventuell vorhandene) Strukture(n) und Redundanz n Erstellen Sie Methoden um (soweit möglich) Redundanz zu vermeiden n Kommentieren Sie den Code n Führen Sie die Methode aus 43 ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ Redundanz im Output n Hexagon oberer Teil: im Stop Schild und Hut wiederverwendet n Hexagon unterer Teil: in Wanne und Stop Schild n Trennlinie: in Wanne und Hut n Diese Redundanz kann durch diese Methoden ausgenutzt (d.h. eliminiert) werden: n hexagonTop n hexagonBottom n line Program Version 3 // Ihr Name, 252-0027, Herbst 2020 // Prints several figures, with methods for structure and redundancy. public class Figures3 { public static void main(String[] args) { hexagon(); wanne(); stopSign(); hut(); } // Draws the top half of an an hexagon. public static void hexagonTop() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); } ... 45 Program Version 3, Fortsetzung ...// Draws the bottom half of an hexagon. public static void hexagonBottom() { System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); } // Draws a complete hexagon. public static void hexagon() { hexagonTop(); hexagonBottom(); System.out.println(); } ... 46 Program Version 3, Fortsetzung ... // Draws a tub («Wanne») figure. public static void wanne() { hexagonBottom(); line(); System.out.println(); } // Draws a stop sign figure. public static void stopSign() { hexagonTop(); System.out.println(\"| STOP |\"); hexagonBottom(); System.out.println(); } 47 Program Version 3, Fortsetzung ... // Draws a figure that looks sort of like a hat («Hut»). public static void hut() { hexagonTop(); line(); } // Draws a line of dashes. public static void line() { System.out.println(\"+--------+\"); } } //Figures3 48 Methoden (Übung) Schreiben Sie ein Programm das diese Rackete ausgibt: /\\ / \\ / \\ / \\ +-------+ | | | | | | +-------+ | | | ISS | | | +-------+ | | | | | | +-------+ /\\ / \\ / \\ / \\ 49 252-0027 Einführung in die Programmierung 2.2 Typen und Variablen Thomas R. Gross Department Informatik ETH Zürich 3 Übersicht § 2.0 Einfache Java Programme § 2.1 Methoden § Struktur § 2.2 Typen und Variable § 2.2.1 Einführung § 2.2.2 Basistypen: Einfache (eingebaute) Typen § 2.2.3 Deklaration von Variablen 5 2.2.1 Einführung 6 Typen § Typen («types») beschreiben Eigenschaften von Daten § Ein Typ beschreibt eine Menge (oder Kategorie) von Daten Werten. § Bestimmt (beschränkt) die Operationen, die mit diesen Daten gemacht werden können § Viele Programmiersprachen erfordern die Angabe (Spezifikation) von Typen § Typen Beispiele: ganze Zahlen, reelle Zahlen, Strings § Typen sind Teil der Dokumentation (was verarbeitet diese Methode?) 7 Typen § Die Programmiersprache legt fest, wie ein Typ implementiert ist § «Implementiert» – Darstellung der Werte und Definition der Operationen § Die interne Darstellung eines Types beruht auf Kombinationen von 1s und 0s 97 à 01100001 9 Typen § Die Programmiersprache legt fest, wie ein Typ implementiert ist § «Implementiert» – Darstellung der Werte und Definition der Operationen § Die interne Darstellung eines Types beruht auf Kombinationen von 1s und 0s 97 à 01100001 \"ab\" à 01100001 01100010 12 Typen § Die Programmiersprache legt fest, wie ein Typ implementiert ist § Die interne Darstellung eines Types beruht auf Kombinationen von 1s und 0s 97 à 01100001 \"ab\" à 01100001 01100010 ASCII Tabelle 97 01100001 a 98 01100010 b 13 Typen § Die Programmiersprache legt fest, wie ein Typ implementiert ist § Die interne Darstellung eines Types beruht auf Kombinationen von 1s und 0s 97 à 01100001 \"ab\" à 01100001 01100010 ASCII Tabelle 97 01100001 a 98 01100010 b 14¿ Was bedeutet 0110 0001 ? Basistypen in Java § Es gibt 8 eingebaute Typen («primitive types») für Zahlen, Buchstaben, etc. Name Beschreibung Beispiele § int ganze Zahlen -2147483648, -3, 0, 42, 2147483647 § § double reelle Zahlen 3.1, -0.25, 9.4e3 § char (einzelne) Buchstaben 'a', 'X', '?', '\\n' § boolean logische Werte true, false 17 Basistypen in Java § Es gibt 8 eingebaute Typen («primitive types») für Zahlen, Buchstaben, etc. Name Beschreibung Beispiele § int ganze Zahlen -2147483648, -3, 0, 42, 2147483647 § long grosse ganze Zahlen -3, 0, 42, 9223372036854775807 § double reelle Zahlen 3.1, -0.25, 9.4e3 § char (einzelne) Buchstaben 'a', 'X', '?', '\\n' § boolean logische Werte true, false 18 Oberfläche eines Quaders § Gegeben: Quader § Aufgabe: Java Programm zur Berechnung § der Oberfläche § Oflaeche = 2 * (70 * 27 + 27 * 40 + 70 * 40) cm2 Public domain, via Wikimedia Commons 19 70 cm 40 cm 27 cm Programm … public class Quader { // Berechnen wir die Oberflaeche ... public static void main(String[] args) { System.out.print(\"Die Oberflaeche ist \"); System.out.print(2 * (70 * 27 + 27 * 40 + 70 * 40)); System.out.println(\" cm2\"); } // Ende von main } 20 Output: Die Oberflaeche ist 11540 cm2 70 cm 40 cm 27 cm Programm … public class Quader { // Berechnen wir die Oberflaeche ... public static void main(String[] args) { System.out.print(\"Die Oberflaeche ist \"); System.out.print(2 * (70 * 27 + 27 * 40 + 70 * 40)); System.out.println(\" cm2\"); } // Ende von main } 21 Output: Die Oberflaeche ist 11540 cm2 Aufmerksamer Programmierer 70 cm 40 cm 27 cm Programm … public class Quader { // Berechnen wir die Oberflaeche ... public static void main(String[] args) { System.out.print(\"Die Oberflaeche ist \"); System.out.print(2 * (70 * 27 + 27 * 50 + 70 * 40)); System.out.println(\" cm2\"); } // Ende von main } 22 Output: Die Oberflaeche ist 12080 cm2 Unaufmerksamer Programmierer 70 cm 40 cm 27 cm Variable § Wir führen einen Namen ein mit dem wir uns auf einen Wert (z.B. 40) beziehen können § Erforderlich für Variable: Namen und auf was für Werte sich die Variable beziehen kann § Hier wären int Werte sinnvoll § Wir brauchen eine Variable für int Werte 23 Variable Deklaration: type name § Beispiel: int laenge; § int – Art (Typ) der Werte für diese Variable § Gleich mehr über Typen § laenge – Name der Variable § Frei wählbar, mit Einschränkungen § Keine Java Keywords, muss mit Buchstabe anfangen, … § Gross- und Kleinbuchstaben sind unterschiedlich § Deklaration: Erklärung, Bekanntmachung 24 Programm mit Variablen public class Quader { // Berechnen wir die Oberflaeche ... public static void main(String[] args) { int laenge; int hoehe; int tiefe; laenge = 70; hoehe = 40; tiefe = 27; System.out.print(\"Die Oberflaeche ist \"); System.out.print(2*(laenge*tiefe + tiefe*hoehe + laenge*hoehe)); System.out.println(\" cm2\"); } // Ende von main } 25 Output: Die Oberflaeche ist 11540 cm2 Variable Deklaration und Definition: type name = value § Java: können Deklaration mit Zuweisung verbinden § Value ist ein (passender) Wert … § «passend» -- d.h. vom Typ type 26 Programm mit Variablen public class Quader { // Berechnen wir die Oberflaeche ... public static void main(String[] args) { int laenge = 70; int hoehe = 40; int tiefe = 27; System.out.print(\"Die Oberflaeche ist \"); System.out.print(2*(laenge*tiefe + tiefe*hoehe + laenge*hoehe)); System.out.println(\" cm2\"); } // Ende von main } 27 Output: Die Oberflaeche ist 11540 cm2 Variable Deklaration § Deklaration legt Art/Typ der Werte fest – kann jeden Wert dieses Types darstellen § Macht den Namen bekannt § Name wird in ein Verzeichnis eingetragen § Variable wird nicht initialisiert wenn keine Definition § Gute Namen sind wichtig – besonders wenn Variable wiederholt verwendet wird § … und (manchmal) schwer zu finden § Kurzer Name wenn Variable nicht wichtig/langlebig ist § Daher oft in Beispielen (hier) 28 Variable Deklaration und Definition § Das Zeichen = («Gleichheitszeichen» – aber irreführender Name) bedeutet Zuweisung § § int laenge = 70; § Der int Variable laenge wird der Wert 70 zugewiesen § Wenn wir die Variable verwenden (z.B., um eine Operation auszuführen) so wird die Operation mit dem Wert (den die Variable gepeichert hat) ausgeführt 29 Wer definiert Typen? § Verlangen alle Programmiersprachen die Spezifikation von Typen? § Nein. (Mit manchmal überraschenden Folgen) § Java verlangt nicht immer eine Spezifikation des Typs § Manchmal kann der Compiler den Typ herausfinden § Welche Typen kann ein Java Programm verwenden? § Typen die in der Sprache definiert sind: Basistypen («primitive types», integrierte Typen) – Beispiel: int und long für ganze Zahlen § Typen aus Bibliotheken, die immer verfügbar sind (z.B. String) § Benutzer-definierte Typen 31 Wer definiert Typen? § Verlangen alle Programmiersprachen die Spezifikation von Typen? § Nein. (Mit manchmal überraschenden Folgen) § Java verlangt nicht immer eine Spezifikation des Typs § Manchmal kann der Compiler den Typ herausfinden § Welche Typen kann ein Java Programm verwenden? § Typen die in der Sprache definiert sind: Basistypen («primitive types», integrierte Typen) – Beispiel: int und long für ganze Zahlen § Typen aus Bibliotheken, die immer verfügbar sind (z.B. String) § Benutzer-definierte Typen 32 Warum Typen § Typen beschreiben Eigenschaften von Daten § Wertebereich § Operationen § Darstellung (welche Folge von 0 und 1 für einen Wert gewählt wird) § Richtige Wahl des Typs nötig § Java kann dann entsprechend Platz reservieren so dass Ergebnisse von Operationen darstellbar sind § Je nach Platform werden unterschiedliche (Hardware) Operationen ausgeführt § Addition ganzer Zahlen -- Addition von Reellen (Gleitkomma) Zahlen 34 Warum Typen § Programme manipulieren Symbole § Beispiel EBNF: Symbole aus Zeichen aus einer Menge («Alphabet») § Bestimmt ob legal oder nicht – aber nur bzgl. der Struktur § Programme übersetzen Sprachen, spielen Schach, berechnen die Steuerschuld § Symbole werden verknüpft, verglichen, geändert, gelesen, …. § Symbole werden durch Folgen von 0 und 1 dargestellt § Typ entscheidet die Interpretation dieser Folgen 35 Warum Typen § Typen verhindern Fehler § Kann nicht die AHV Nummer zum Gehalt addieren § Kann nicht Volumen und Fläche addieren § Typen erlauben Optimierungen (der Berechnung, der Darstellung) § Alle Darstellungen sind endlich! § Richtige Wahl des Typs nötig § Java kann dann entsprechend Platz reservieren so dass Ergebnisse von Operationen darstellbar sind (int oder long?) 36 Übersicht § 2.0 Einfache Java Programme § 2.1 Methoden § Struktur § 2.2 Typen und Variable § 2.2.1 Einführung § 2.2.2 Basistypen: Einfache (eingebaute) Typen § Operationen (mit Werten desselben und verschiedener Typen) § 2.2.3 Deklaration von Variablen 37 2.2.2 Primitive Types § Deklaration und Definition § int x = value; § Genauer: § value wird durch einen Ausdruck («expression») bestimmt § Der Ausdruck wird ausgewertet («evaluated») § Was sind die Regeln für Ausdrücke? § Zuerst für int (und long) 38 Ausdrücke («Expressions») § Ausdruck («expression») für einen Typ: Ein Wert oder Operanden und Operator(en) die einen Wert berechnen • Beispiele für int: 1 + 4 2 * 4 * 3 7 + ( 2 + 6 ) * 4 § Der einfachste Ausdruck ist ein Literal («literal value») § Ein Wert der direkt im Programm erscheint (z.B. 4) § Komplexe Ausdrücke können Teilausdrücke enthalten (später mehr) § (Teil)Ausdruck kann Operand sein 39 Arithmetische Operatoren § Operator: Verknüpft Werte oder Ausdrücke. § + Addition § - Subtraktion (oder Negation) § * Multiplikation § / Division § % Modulus (Rest) § Während der Ausführung eines Programms werden seine Ausdrücke ausgewertet («evaluated») § 1 + 1 ergibt 2 § System.out.println(3 * 4); ergibt (druckt) 12 § Wie würden wir den Text 3 * 4 drucken? 41 EBNF Beschreibung Ausdruck (Expression) number ⟸ integer | sign { digit } . digit { digit } op ⟸ + | - | * | / | % atom ⟸ number | identifier term ⟸ ( expr ) | atom expr ⟸ term { op term } 1. Nicht die vollständige Beschreibung für Java Ausdrücke 2. Beschreibt nur die Syntax (die Form) 43 Arithmetische Operatoren § Operator: Verknüpft Werte oder Ausdrücke. § + Addition § / Division …. § Werte haben einen [festgelegten] Typ § Evaluation eines Ausdrucks ergibt Wert eines Typs § EBNF beschreibt nur Form (int + int ergibt ? int , int + long ergibt ? ?? ) 44 Arithmetische Operatoren § Operator: Verknüpft Werte oder Ausdrücke. § + Addition § / Division …. § Werte haben einen [festgelegten] Typ § Evaluation eines Ausdrucks ergibt Wert eines Typs § EBNF beschreibt nur Form (int + int ergibt ? int , int + long ergibt ? ?? ) 45 Arithmetische Operatoren § Operator: Verknüpft Werte oder Ausdrücke. § + Addition § / Division …. § Werte haben einen [festgelegten] Typ § Evaluation eines Ausdrucks ergibt Wert eines Typs § EBNF beschreibt nur Form (int + int ergibt ? int , int + long ergibt ? ?? ) § Operator ⨂ : Typ_A ⨂ Typ_A ergibt Typ_A (für arithmetische Operatoren) Typ_A ⨂ Typ_B ergibt ???? (hängt von ⨂, Typ_A, Typ_B ab – später) 46 int Division mit / § Wenn wir ganze Zahlen dividieren ist der Quotient auch wieder eine ganze Zahl. § 14 / 4 ergibt 3, nicht 3.5 3 4 52 4 ) 14 10 ) 45 27 ) 1425 12 40 135 2 5 75 54 21 48 int Division mit / § Weitere Beispiele: § 32 / 5 ergibt 6 § 84 / 10 ergibt 8 § 156 / 100 ergibt 1 § -4 / 3 ergibt -1 § -101 / 9 ergibt -11 § Division durch 0 führt zu einem Fehler während der Ausführung des Programmes 49 int Rest mit % § Der % Operator liefert den Rest der Division ganzer Zahlen § 14 % 4 ergibt 2 § 218 % 5 ergibt 3 3 43 4 ) 14 5 ) 218 12 20 2 18 15 3 50 int Rest mit % § Einsatz des % Operators: § Finde letzte Ziffer einer ganzen Zahl : 230857 % 10 ist 7 § Finde letzte 4 Ziffern: 658236489 % 10000 ist 6489 § Entscheide ob Zahl gerade ist: 7 % 2 ergibt 1, 42 % 2 ergibt 0 51 Was ist das Ergebnis von 1. 10 / 4 2. 45 % 6 3. -23 / 11 4. 11 % 0 5. 2 % 2 6. 43 / 3 7. 8 % 20 52 Was ist das Ergebnis von 1. 10 / 4 2 2. 45 % 6 3 3. -23 / 11 -2 4. 11 % 0 5. 2 % 2 0 6. 43 / 3 14 7. 8 % 20 8 53 Ausdrücke mit mehreren Operanden § Hat ein Ausdruck mehrere Operanden X, Y, Z (mit Operatoren ⊙) so müssen wir festlegen, was X ⊙ Y ⊙ Z bedeutet. § 7 + 5 + 3 § 64 / 8 / 2 54 à (7 + 5) + 3 à (64 / 8 ) / 2 und nicht 64 / (8 / 2) Ausdrücke mit mehreren Operanden § Hat ein Ausdruck mehrere Operanden X, Y, Z (mit Operatoren ⊙) so müssen wir festlegen, was X ⊙ Y ⊙ Z bedeutet. § 7 + 5 + 3 § 64 / 8 / 2 § Wird durch die Assoziativität der Operatoren bestimmt 55 à (7 + 5) + 3 à (64 / 8 ) / 2 und nicht 64 / (8 / 2) Assoziativität («Associativity») -- Bindung § Die Assoziativität eines Operators ⊙ hält fest wie ein Operand zu verwenden ist: X ⊙ Y ⊙ Z § Y ist mit dem linken Operator verknüpft: links-assoziativ («left- associative») X ⊙ Y ⊙ Z = (X ⊙ Y ) ⊙ Z § Y ist mit dem rechten Operator verknüpft: rechts-assoziativ («right-associative») X ⊙ Y ⊙ Z = X ⊙ ( Y ⊙ Z ) 56 Assoziativität § Links-assoziativ: Y ist mit dem linken Operator verknüpft («left-associative», «left-to-right associative») X ⊙ Y ⊙ Z = (X ⊙ Y ) ⊙ Z Viele der uns bekannten Operatoren: +, *, § rechts-assoziativ: Y ist mit dem rechten Operator verknüpft («right-associative», «right-to-left associative») Später werden wir Beispiele sehen (es gibt einige!) § Es gibt Operatoren die sind assoziativ (in der Mathematik) § Rechts—assoziativ und links—assoziativ: (X ⊙ Y ) ⊙ Z = X ⊙ ( Y ⊙ Z) 58 Aber es gibt noch mehr zu bedenken … § Was für einen Wert erhalten wir für 2 + 6 * 5 59 Rang Ordnung § Hat ein Ausdruck mehrere Operanden X, Y, Z (mit Operatoren ⊙ und ⨂) so müssen wir festlegen, was X ⊙ Y ⨂ Z bedeutet. (⊙ und ⨂ sind unterschiedliche Operatoren) Operand Y kann zuerst mit ⊙ oder zuerst mit ⨂ verknüpft werden § Die Rang Ordung von ⊙ und ⨂ entscheidet. 61 Rang Ordnung («Precedence») 63 § Der Operand (Y) in X ⊙ Y ⨂ Z wird mit dem Operator verknüpft, der den höheren Rang hat. § 1 + 3 * 4 Rang Ordnung («Precedence») 64 § Der Operand (Y) in X ⊙ Y ⨂ Z wird mit dem Operator verknüpft, der den höheren Rang hat. § 1 + 3 * 4 § 1 + 3 * 4 § 1 + 12 § 1 + 12 § 13 Rang Ordnung 6 + 8 / 2 * 3 links anfangen 6 ist Literal 8 ist Literal / hat höheren Rang als + links anfangen: / zuerst / und * haben selben Rang 6 + 4 * 3 int Division ergibt 4 * hat höheren Rang als + 6 + 12 nur noch ein Operator Resultat: 18 65 Rang Ordnung 6 + 8 / 2 * 3 links anfangen 6 ist Literal 8 ist Literal / hat höheren Rang als + links anfangen: / zuerst / und * haben selben Rang 6 + 4 * 3 int Division ergibt 4 * hat höheren Rang als + 6 + 12 nur noch ein Operator Resultat: 18 66 Rang Ordnung 6 + 8 / 2 * 3 links anfangen 6 ist Literal 8 ist Literal / hat höheren Rang als + links anfangen: / zuerst / und * haben selben Rang 6 + 4 * 3 int Division ergibt 4 * hat höheren Rang als + 6 + 12 nur noch ein Operator Resultat: 18 67 Rang Ordnung 6 + 8 / 2 * 3 links anfangen 6 ist Literal 8 ist Literal / hat höheren Rang als + links anfangen: / zuerst / und * haben selben Rang 6 + 4 * 3 int Division ergibt 4 * hat höheren Rang als + 6 + 12 nur noch ein Operator Resultat: 18 68 Rang Ordnung 6 + 8 / 2 * 3 links anfangen 6 ist Literal 8 ist Literal / hat höheren Rang als + links anfangen: / zuerst / und * haben selben Rang 6 + 4 * 3 int Division ergibt 4 * hat höheren Rang als + 6 + 12 nur noch ein Operator Resultat: 18 69 Rang Ordnung 6 + 8 / 2 * 3 links anfangen 6 ist Literal 8 ist Literal / hat höheren Rang als + links anfangen: / zuerst / und * haben selben Rang 6 + 4 * 3 int Division ergibt 4 * hat höheren Rang als + 6 + 12 nur noch ein Operator Resultat: 18 70 Rang Ordnung 6 + 8 / 2 * 3 links anfangen 6 ist Literal 8 ist Literal / hat höheren Rang als + links anfangen: / zuerst / und * haben selben Rang 6 + 4 * 3 int Division ergibt 4 * hat höheren Rang als + 6 + 12 nur noch ein Operator Resultat: 18 71 Rang Ordnung 6 + 8 / 2 * 3 links anfangen 6 ist Literal 8 ist Literal / hat höheren Rang als + links anfangen: / zuerst / und * haben selben Rang 6 + 4 * 3 int Division ergibt 4 * hat höheren Rang als + 6 + 12 nur noch ein Operator Resultat: 18 72 Operanden und Operatoren § Operand wird vom Operator mit höherer Rang Ordnung («precedence», Präzedenz) verwendet § Wenn zwei Operatoren die selbe Rang Ordnung haben, dann entscheidet die Assoziativität § Wenn zwei Operatoren die selbe Rang Ordnung und Assoziativität haben, dann werden die (Teil)Ausdrücke von links nach rechts ausgewertet. § Wenn etwas anderes gewünscht wird: Klammern verwenden! 73 Operanden und Operatoren § Klammern bestimmen abweichende die Gruppierung: (1 + 3) * 4 ergibt 16 § Leerzeichen (oder Kommentare) haben keinen Einfluss auf die Reihenfolge der Auswertung 1+3 * 4-2 ergibt 11 (trotzdem keine gute Idee!) 74 Operanden und Operatoren § Beispiel Rang Ordnung und Assoziativität: Ausdruck1 + (Ausdruck2 + Ausdruck3) * Ausdruck4 75 Operanden und Operatoren § Beispiel Rang Ordnung und Assoziativität: Ausdruck1 + (Ausdruck2 + Ausdruck3) * Ausdruck4 77 1 2 3 5 4 6 7 Rang Ordnung Beispiele § 1 * 2 + 3 * 5 % 4 § \\_/ | 2 + 3 * 5 % 4 § \\_/ | 2 + 15 % 4 § \\___/ | 2 + 3 § \\________/ | 5 n 1 + 8 % 3 * 2 - 9 n \\_/ | 1 + 2 * 2 - 9 n \\___/ | 1 + 4 - 9 n \\______/ | 5 - 9 n \\_________/ | -4 78 Rang Ordnung Beispiele Welche Werte ergeben die Auswertung dieser Ausdrücke? § 9 / 5 § 695 % 20 § 7 + 6 * 5 § 7 * 6 + 5 § 248 % 100 / 5 § 6 * 3 - 9 / 4 § (5 - 7) * 4 § 6 + (18 % (17 - 12)) 79 9 / 5 ==> 1 695 % 20 ==> 15 7 + 6 * 5 ==> 37 7 * 6 + 5 ==> 47 248 % 100 / 5 ==> 9 6 * 3 - 9 / 4 ==> 16 (5 - 7) * 4 ==> -8 6 + (18 % (17 - 12)) ==> 9 80 Reelle Zahlen (Typ double) § Beispiele: 6.022 -42.0 2.143e17 § Hinzufügen von .0 oder . an eine ganze Zahl macht diese zu double. § Die Operatoren + - * / % () sind auch für double definiert. § / berechnet ein genaues Resultat: 15.0 / 2.0 ergibt 7.5 § Rang Ordnung (der Auswertung) ist die selbe: () vor * / % vor + - 81 Beispiel mit reellen Zahlen § 2.0 * 2.4 + 2.25 * 4.0 / 2.0 § \\___/ | 4.8 + 2.25 * 4.0 / 2.0 § \\___/ | 4.8 + 9.0 / 2.0 § \\_____/ | 4.8 + 4.5 § \\____________/ | 9.3 82 252-0027 Einführung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH Zürich Übersicht § 2.0 Einfache Java Programme § 2.1 Methoden § Struktur § 2.2 Typen und Variable § 2.2.1 Einführung § 2.2.2 Basistypen: Einfache (eingebaute) Typen § 2.2.3 Deklaration von Variablen 2 252-0027 Einführung in die Programmierung 2.2 Typen und Variablen Thomas R. Gross Department Informatik ETH Zürich 3 Arithmetische Operatoren § Operator: Verknüpft Werte oder Ausdrücke. § + Addition § / Division …. § Werte haben einen [festgelegten] Typ § Evaluation eines Ausdrucks ergibt Wert eines Typs § EBNF beschreibt nur Form (int + int ergibt ? int , int + long ergibt ? ?? ) § Operator ⨂ : Typ_A ⨂ Typ_A ergibt Typ_A (für arithmetische Operatoren) Typ_A ⨂ Typ_B ergibt ???? (hängt von ⨂, Typ_A, Typ_B ab – später) 4 Operanden und Operatoren § Operand wird vom Operator mit höherer Rang Ordnung («precedence», Präzedenz) verwendet § Wenn zwei Operatoren die selbe Rang Ordnung haben, dann entscheidet die Assoziativität § Wenn zwei Operatoren die selbe Rang Ordnung und Assoziativität haben, dann werden die (Teil)Ausdrücke von links nach rechts ausgewertet. § Wenn etwas anderes gewünscht wird: Klammern verwenden! 5 Kombinationen von Typen § Wenn int oder long und double kombiniert werden dann ist das Ergebnis double. § 4.2 * 3 ergibt 12.6 § Auch dann wenn das Result als int darstellbar wäre § 4.5 * 2 ergibt 9.0 § Umwandlung («conversion») von einem Typ in einen anderen § Wird für jeden Operator separat gemacht und beeinflusst nur dessen Operanden § Automatisch («implizit») – werden später sehen wie wir Umwandlungen erzwingen können 6 Ausdrücke mit verschiedenen Typen § Umwandlung geschieht für jeden Operator separat … § 7 / 3 * 1.2 + 3 / 2 § \\_/ | 2 * 1.2 + 3 / 2 § \\___/ | 2.4 + 3 / 2 § \\_/ | 2.4 + 1 § \\________/ | 3.4 3 / 2 ergibt 1 nicht 1.5. • 2.0 + 10 / 3 * 2.5 - 6 / 4 • \\___/ | 2.0 + 3 * 2.5 - 6 / 4 • \\_____/ | 2.0 + 7.5 - 6 / 4 • \\___________/ | 9.5 - 6 / 4 • \\_/ | 9.5 - 1 • \\__________/ | 8.5 7 Ausdrücke mit verschiedenen Typen Bitte evaluieren Sie diese Ausdrücke § 4 + 8 / 3.0 * 6 + 5 § 9.0 / (2.0 / 3) + 7 § 7 % 3 * 2 + 4.0 * 3 / 2 § 9 / (2 / 3) + 7 § 20 % 8 + 15 / 27 / (3 % 6) 8 Ausdrücke mit verschiedenen Typen Bitte evaluieren Sie diese Ausdrücke § 4 + 8 / 3.0 * 6 + 5 25.0 § 9.0 / (2.0 / 3) + 7 20.5 § 7 % 3 * 2 + 4.0 * 3 / 2 8.0 § 9 / (2 / 3) + 7 Laufzeitfehler § 20 % 8 + 15 / 27 / (3 % 6) 4 9 Division durch 0 ist nicht erlaubt. 2/3 ist 0, 9/0 resultiert in Laufzeitfehler Typ Umwandlungen § Ausser impliziten Umwandlungen gibt es die Möglichkeit der expliziten Umwandlung § implizit (ein Operand ist double – Umwandlung des anderen): 1.0 / 4 § explizite (erzwungene) Umwandlungen heissen «cast» oder «type cast» § type cast: Umwandlung von einem Typ in den anderen. § Um int in double umzuwandeln (z.B. damit Division das gewünschte exakte Ergebnis liefert) § Um einen double Wert in einen int Wert zu verwandeln § Abschneiden («truncation») – nicht Rundung Typ Umwandlungen § Syntax: (type) expression § Beispiele: (double) 19 / 5; // 3.8 (int) ((double) 19 / 5) ; // 3 Typ Umwandlungen § (type) ist ein Operator § Der «cast operator» § Höherer Rang (Präzedenz) als arithmetische Operatoren § Rechts-assoziativ § D.h. wandelt nur den Operanden direkt rechts daneben um § Für alle Basistypen verfügbar Bemerkungen über explizite Umwandlungen § Typ Umwandlung hat hohe Präzedenz und der Cast Operator bezieht sich nur auf den (Teil)Ausdruck direkt neben sich. § (double) 1 + 1 / 2; // 1.0 § 1 + (double) 1 / 2; // 1.5 § Mit Klammern kann man die Reihenfolge der Auswertung verändern. § (double) (2 + 1 + 1) / 3; // 1.3333333333333333 Rang Ordnung … § Die letzten Slides haben die Java Sicht gezeigt. § Andere Programmiersprachen haben (eventuell) andere Regeln § Notwendigkeit von Typ Information § Rang Ordnung sollte festgelegt sein § Nicht immer was man erwartet § Beispiel: Microsoft Excel 17181920212223 Operationen für Typen § Drei Möglichkeiten § Basistypen («primitive types») § Beispiele: int und long § Haben Werte (4, 1, 0, -218), Operationen und Variable gesehen § Beispiel: double § Haben Werte (0.0. -5.1, 4.3) und Operationen gesehen § Typen aus der Java Bibliothek § Beispiel: String § Haben Werte gesehen (\"hello\", \"2 + 3\") – jetzt Operationen § Selbst entwickelte Typen (später) 24 String Operationen § String Verkettung («concatenation»): Der Operator + erlaubt es, zwei (oder mehr) Strings zu verketten (verknüpfen) \"hello\" + \"world\" ergibt \"helloworld\" \"a\" + \"b\" + \"c\" ergibt \"abc\" § Ausdrücke können Operanden verschiedener Typen kombinieren § Auch Strings mit anderen Werten/Variablen/Ausdrücken 25 String Operationen § Java Regel: Für jeden Wert gibt es eine Darstellung als String § Gilt für alle Typen (Basistypen, Bibliothek, selbst entwickelte Typen) § Ob die default Darstellung (D: voreingestellte oder standardmässig eingestellte Darstellung) sinnvoll/verständlich ist – eine andere Frage § Trotzdem sehr praktisch: Kann jeden Wert W mittels print(W) ausgeben 26 Darstellung als String § Für Basistypen ist die default Darstellung die erwartete Darstellung § Für int oder long Variable und Konstanten § int Literal(Konstante) 42 Default Darstellung: \"42\" § int j = 99 Default Darstellung für j : \"99\" § Für double Variable genauso § Das selbe gilt für String § \"Hello\" Default Darstellung: \"Hello\" 27 String Operationen § Java Regel: Für jeden Wert gibt es eine Darstellung als String § Gilt für alle Typen (Basistypen, Bibliothek, selbst entwickelte Typen) § Ob die default Darstellung (D: voreingestellte oder standardmässig eingestellte Darstellung) sinnvoll/verständlich ist – eine andere Frage § Trotzdem sehr praktisch: Kann jeden Wert W mittels print(W) ausgeben § Der Operator + mit einem String und einem anderen Wert als Operanden ergibt einen längeren String § Verwendet die default Darstellung 28 Operator + mit String Operand § String + anderer Wert als Operand: verknüpfe String mit default Darstellung zu neuem String \"hello\" + 42 ergibt \"hello42\" \"hello\" + j ergibt \"hello99\" // j ist 99 § Nur der Operator + ist erlaubt (kein *, /, oder -) 29 Die üblichen Regeln … § Von links nach rechts rechnen § 12 – 3 + 5 ergibt 14 (nicht 4) § 2 + 3 + \" Hello\" ergibt \"5 Hello\" § \"Hello \" + 2 + 3 ergibt \"Hello 23\" § Punkt vor Strich § \"Hello \" + 2 * 3 ergibt \"Hello 6\" 34 String Operationen Quiz 1 + 2 + \"abc\" \"abc\" + 9 * 3 \"1\" + 1 4 - 1 + \"abc\" 35 Poll Weitere String Operationen 1 + 2 + \"abc\" ergibt \"3abc\" \"abc\" + 9 * 3 ergibt \"abc27\" \"1\" + 1 ergibt \"11\" 4 - 1 + \"abc\" ergibt \"3abc\" 37 PollString Operationen § Können + verwenden um einen String und den Wert eines Ausdrucks auszugeben. § System.out.println(\"Note: \" + (4.8 + 5.4) / 2); • Warum brauchen wir ( und )? 39 Output: Note: 5.1 2.2.3 Variablen 40 Übersicht § 2.0 Einfache Java Programme § 2.1 Methoden § Struktur § 2.2 Typen und Variable § 2.2.1 Einführung § 2.2.2 Basistypen: Einfache (eingebaute) Typen § 2.2.3 Deklaration von Variablen § Zuweisungen 41 Variable § Variable («variable»): Name der es erlaubt, auf einen gespeicherten Wert zuzugreifen 43 Variable § Variable («variable»): Name der es erlaubt, auf einen gespeicherten Wert zuzugreifen § Wert muss (irgendwo) vom Programm gespeichert werden § In Speicherzelle(n) im Computer § Ähnlich Schnellwahl (Telefon) 44 Variable § Variable («variable»): Name der es erlaubt, auf einen gespeicherten Wert zuzugreifen § Wert muss (irgendwo) vom Programm gespeichert werden § In Speicherzelle(n) im Computer § Ähnlich Schnellwahl (Telefon) 45 Variable § Wie man diese Wahlknöpfe benutzt: § Einrichten (in der Fabrik) § Konfiguration § Einsatz § Ähnlicher Ablauf für Variablen in einem Programm § Deklaration - gibt Namen und Typ an § Initialisierung - speichert einen Wert in der Variablen § Gebrauch - in einem Ausdruck oder println Anweisung 47 Deklaration § Deklaration einer Variablen: Reserviert Speicher für Werte § Variable müssen deklariert sein bevor sie verwendet werden können § Fürs erste: in einer Methode § Syntax: type name; name ist ein Bezeichner («identifier») type ist der Typ § int x; § double meineNote; § Auch mit Initialisierung int z = 99; x meineNote 48 Arbeiten mit einer Variablen § Variable muss deklariert sein bevor sie im Programm gebraucht wird § Als Operand einer Zuweisung («assignment») int z; z = 1; § Variable muss Wert haben bevor sie als Operand anderer Operatoren gebraucht werden kann § Wert kann von «Deklaration mit Initialisierung» oder Zuweisung kommen 49 Compiler Fehler Meldungen § Eine Variable kann erst nach einer Zuweisung verwendet werden. § int x; System.out.println(x); // ERROR: x has no value § Keine Doppeltdeklarationen. § int x; int x; // ERROR: x already exists § int x = 3; int x = 5; // ERROR: x already exists 50 Compiler Fehler Meldungen § Keine Doppeltdeklarationen. § int x; long x; // ERROR: x already exists § int x = 3; double x = 3.0; // ERROR: x already exists 51 Zuweisungen («Assignment») § Zuweisung: Anweisung die Wert in einer Variable speichert. § Wert kann ein Ausdruck sein, die Zuweisung speichert das Ergebnis § Fürs erste: Zuweisungen in einer Methode § Syntax: name = expression; § int x; x = 3; § double meineNote; meineNote = 3.0 + 2.25; x meineNote 53 3 5.25 Gebrauch von Variablen § Wiederholte Zuweisungen sind erlaubt: int x; x = 3; System.out.println(x + \" here\"); // 3 here x = 4 + 7; System.out.println(\"now x is \" + x); // now x is 11 x 3x 11 54 Assignment § Java verwendet = um eine Zuweisung auszudrücken § «Assignment operator» name = expression; EBNF Description assignment variableidentifier ⟸ bezeichner assignment ⟸ variableidentifier = expression ; Die EBNF Beschreibung für expression hatten wir schon gesehen. 55 Deklaration mit Initialisierung EBNF Description variabledeclaration typeidentifier ⟸ bezeichner variableidentifier ⟸ bezeichner variablelist ⟸ variableidentifier { , variableidentifier } variableinitialization ⟸ variableidentifier = expr variablespecification ⟸ variableinitialization | variablelist variabledeclaration ⟸ typeidentifier variablespecification ; 59 Zuweisung (Programm) und Algebra (Mathematik) § Zuweisung verwendet = , aber eine Zuweisung ist keine algebraische Gleichung! = bedeutet: «speichere den Wert der RHS in der Variable der LHS» Die rechte Seite des Ausdrucks wird zuerst ausgewertet, dann wird das Ergebnis in der Variable auf der linken Seite gespeichert § Was passiert hier? int x = 3; x = x + 2; // ??? x 3x 5 60 Was passiert hier ? Sehen Sie sich diese Anweisungen an. Welchen Wert hat x am Ende? int x; int y; x = 0; // (S1) y = 1; // (S2) x = y; // (S3) y = 2; // (S4) x hat den Wert ??? 631 PollWas passiert hier ? Sehen Sie sich diese Anweisungen an. Welchen Wert hat x am Ende? int x; int y; x = 0; // (S1) y = 1; // (S2) x = y; // (S3) y = 2; // (S4) x hat den Wert ??? 641 Poll Nach Var S1 S2 S3 S4 x y Nach Var S1 S2 S3 S4 x 0 y ? Nach Var S1 S2 S3 S4 x 0 0 1 1 y ? 1 1 2 Nach Var S1 S2 S3 S4 x 0 0 y ? 1 Nach Var S1 S2 S3 S4 x 0 0 1 y ? 1 1 252-0027 Einführung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH Zürich Übersicht § 2.0 Einfache Java Programme § 2.1 Methoden § Struktur § 2.2 Typen und Variable § 2.2.1 Einführung § 2.2.2 Basistypen: Einfache (eingebaute) Typen § 2.2.3 Deklaration von Variablen 72 Übersicht § 2.3 Aussagen über Programm(segment)e § Vorwärts/Rückwärts schliessen § 2.3.1 Pre- und Postconditions § 2.3.2 Hoare-Tripel für Anweisungen § 2.4 Verzweigungen 73 2.3 Aussagen über Programm(segment)e § Beispiel Programm(segment) public static void main(String[] args) { int laenge = 70; int hoehe = 40; int tiefe = 27; int flaeche = 2*(laenge*tiefe + tiefe*hoehe + laenge*hoehe); … } § Wir wollen eine Aussage über die Berechnung machen § Muss Variable flaeche involvieren 74 Aussagen über Programm(segment)e § Aussage über Variable flaeche muss an Ort (Stelle im Programm) gekoppelt sein public static void main(String[] args) { int laenge = 70; int hoehe = 40; int tiefe = 27; int flaeche = 2*(laenge*tiefe + tiefe*hoehe + laenge*hoehe); … } 75 Keine Aussage möglichKeine Aussage möglichKeine Aussage möglichKeine Aussage möglich Aussage möglich Ziel: Aussagen über ein Programm machen § Zuerst: welche Aussagen gelten für eine Methode § Erlaubte Anweisungen in der Methode: § Zuweisungen § Also zuerst Programm(segment) ist Rumpf (Body) einer Methode 76 (Logische) Aussagen § Aussage («assertion»): Eine Behauptung die entweder wahr oder falsch ist. § Wir fragen dann oft «Ist die Aussage wahr»? § Beispiele: § Zürich ist ein Kanton der Schweiz § Stockholm ist die Hauptstadt Norwegens § 11 ist eine Primzahl § 120 ist kleiner als 11 § x ≥ 0 (hängt von x ab) § x geteilt durch 2 ergibt 8 (hängt von x ab) 77 (Logische) Aussagen § Nicht alle Aussagen sind wahr § Für einige Aussagen können wir vielleicht nicht sofort entscheiden ob sie wahr oder falsch sind § Wichtig ist dass es Sinn macht zu fragen, ob die Aussage wahr oder falsch ist § Logisch heisst hier: im Sinne der klassischen Logik 78 Ziel: Aussagen über ein Programm herleiten § Welche Aussagen gelten (an einer Stelle) im Programm? § Ggf. was für Annahmen sind nötig, dass eine Aussage P wahr ist § Was heisst «an einer Stelle»? 79 Arbeiten mit Aussagen § Wir stellen uns vor, Positionen (Punkte) im Code haben einen Namen § Point A § Point B § … § Alle Anweisungen, die davor (im Programm) erscheinen, sind ausgeführt wenn wir diesen Punkt (während der Ausführung) erreichen § Keine Anweisung danach wurde ausgeführt 81 Hoare Logik § Tony Hoare entwickelte in den (19)70gern einen Ansatz wie man über Programme logische Schlüsse ziehen kann. § Schritt 1: Vorwärts und rückwärts schliessen § Schritt 2: Von einer Anweisung zu mehreren Anweisungen und Blöcken 82 Warum § Ziel ist es, dass Sie für ein einfaches Programm genau argumentieren können. § In der täglichen Programmentwicklung genügt es oft, weniger detailliert zu argumentieren als es die Hoare Logik erforderlich macht. § Für einfache Programme ist dieser Ansatz zu aufwändig. § Für realistische Programme wird der Ansatz schnell kompliziert. § Wir haben immer noch kein gutes Modell für Objekte und Parallelismus. Aliasing ist eine Herausforderung. § Aber manchmal hilft der Ansatz denn … 83 § Eine gute Schulung, systematisch zu programmieren § Wir können Aussagen machen über Zustände (der Ausführung) eines Programms (und später auch eines Objekts) § Wir können den Effekt eines Programms beschreiben § Wir können definieren was es heisst dass eine Aussage «weaker» (schwächer) oder «stronger» (stärker) ist. § Wichtig für die Definition von Schnittstellen (zwischen Modulen) wenn wir entscheiden müssen welche Bedingungen erfüllt sein müssen (um eine Methode aufzurufen). 84 Was für Aussagen brauchen wir? § Wie finden wir Aussagen für Stellen (Punkte) im Programm? § Uns interessieren nicht irgendwelche Aussagen sondern solche, die das Verhalten der Ausführung beschreiben § Alle Programm(segment)e arbeiten mit int Variablen und Werten § Wir nehmen an (oder wissen) dass die endliche Darstellung kein Problem ist § Alle Ergebnisse können korrekt dargestellt werden 85 Beispiel § Vorwärts schliessen § Vom Zustand vor der Ausführung eines Programm(segments) § Nehmen wir an wir wissen (oder vermuten) w > 0 // w > 0 x = 17; // y = 42; // z = w + x + y; // § Jetzt wissen wir einiges mehr über das Programm, u.a. z > 59 86 Beispiel § Vorwärts schliessen § Vom Zustand vor der Ausführung eines Programm(segments) § Nehmen wir an wir wissen (oder vermuten) w > 0 // w > 0 x = 17; // w > 0 ∧ x hat den Wert 17 y = 42; // w > 0 ∧ x hat den Wert 17 ∧ y hat den Wert 42 z = w + x + y; // w > 0 ∧ x hat den Wert 17 ∧ y hat den Wert 42 ∧ z > 59 § Jetzt wissen wir einiges mehr über das Programm, u.a. z > 59 89 Was sehen wir? § Folge von Statements: hier Zuweisungen § Vor und nach jeder Zuweisung eine Aussage § Als Java Kommentar // w > 0 x = 17; § Der Kommentar ist logische Aussage, kein Java Ausdruck oder Anweisung 91 Beispiel § Rückwärts schliessen: § Nehmen wir an wir wollen dass z nach Ausführung negativ ist // x = 17; // y = 42; // z = w + x + y; // z < 0 § Dann müssen wir wissen (oder vermuten) dass vor der Ausführung gilt: w < -59 § Notwendig und hinreichend 93 Beispiel § Rückwärts schliessen: § Nehmen wir an wir wollen dass z nach Ausführung negativ ist // w + 17 + 42 < 0 x = 17; // w + x + 42 < 0 y = 42; // w + x + y < 0 z = w + x + y; // z < 0 § Dann müssen wir wissen (oder vermuten) dass vor der Ausführung gilt: w < -59 § Notwendig und hinreichend 94 Anderer Blickwinkel § Wie erreichen wir ein gewünschtes Resultat § Den gewünschten Zustand nach der Ausführung von Anweisungen 95 Beispiel § Rückwärts schliessen: § Nehmen wir an wir wollen dass z nach Ausführung negativ ist // w + 17 + 42 < 0 x = 17; // w + x + 42 < 0 y = 42; // w + x + y < 0 z = w + x + y; // z < 0 § Dann müssen wir wissen (oder vermuten) dass vor der Ausführung gilt: w < -59 § Notwendig und hinreichend 96 Vorwärts vs Rückwärts, Teil 1 § Vorwärts schliessen: § Bestimmt was sich aus den ursprünglichen Annahmen herleiten lässt. § Sehr praktisch wenn eine Invariante gelten soll § Rückwärts schliessen: § Bestimmt hinreichende Bedingungen die ein bestimmtes Ergebnis garantieren § Wenn das Ergebniss erwünscht ist, dann folgt aus den Bedingungen die Korrektheit. § Ist das Ergebniss unerwünscht, dann reichen die Bedingungen um einen Bug (oder einen Sonderfall) zu generieren 97 Vorwärts vs Rückwärts, Teil 2 § Vorwärts schliessen: § Simuliert die Ausführung des Programms (für viele «Inputs» «gleichzeitig») § Oft leicht zu verstehen, erscheint «natürlich» § Aber führt dazu dass (viele) Details festgehalten werden, die letztlich irrelevant sind. 98 Vorwärts vs Rückwärts, Teil 3 § Rückwärts schliessen: § Oft von grossem praktischen Nutzen: Sie müssen verstehen (oder festhalten) was jede Anweisung zum Erreichen eines bestimmten Zustandes beiträgt. § Ein Programm(segment) «rückwärts» zu lesen erfordert Übung aber führt zu einer neuen Sicht auf ein Programm. 99 2.3.1 Pre- und Postconditions 100 Pre- und Postconditions § Precondition: notwendige Vorbedingungen die erfüllt sein müssen (vor Auszuführung einer Anweisung) § Postcondition: Ergebnis der Ausführung (wenn Precondition erfüllt) 101 Pre- und Postconditions § Pre- und Postconditions für eine Anweisung § Wenn vor der Ausführung der Anweisung die Precondition erfüllt ist, dann gilt nach der Ausführung die Postcondition, oder § Damit nach der Ausführung die Postcondition gilt, muss vor der Ausführung die Precondition erfüllt sein § Precondition, Anweisung und Postcondition hängen zusammen! § Werden wir für Folgen von Anweisungen erweitern 102 Terminologie § Die Annahme (Aussage), die vor der Ausführung eines Statements gilt, ist die Precondition. § Die Aussage, die nach der Ausführung gilt (unter der Annahme dass die Precondition gültig ist und das Statement ausgeführt wurde), ist die Postcondition. § Wenn wir diesen Punkt erreichen dann gilt die Postcondition § Wenn wir diesen Punkt nicht erreichen (z.B. wegen eines Laufzeitfehlers) dann machen wir keine Aussage 103 Pre/Postconditions § Aussagen (Pre/Postconditions) sind logische (bool’sche) Ausdrücke die sich auf den Zustand (der Ausführung) eines Programms beziehen. § Der Zustand eines Programms ist sichtbar durch die Namen der Variablen (und jede Variable liefert ihren Wert) § Die Variablennamen können in (logischen) Ausdrücken verwendet werden – solange die Ausdrücke keine Nebenwirkungen («no side- effects») haben § Nebenwirkungen wurden noch nicht diskutiert: das ist eine Warnung an Studierende mit Vorkenntnissen 105 Die übliche Notation § Statt die Pre/Postconditions in Kommentaren (nach //) anzugeben verwenden viele Texte {…} § Kein Java mehr … § Aber diese Schreibweise hat sich eingebürgert, lange vor Java { w < -59 } x = 17; { w + x < -42 } § Zwischen { und } steht eine logische Aussage § Kein Java Code (aber wir verwenden Java's Operatoren oder die aus der Mathematik bekannten) 106 assert-Statement in Java § Eine Aussage («Assertion», Behauptung) in Java kann durch ein assert-Statement ausgedrückt werden. § Syntax: assert expression; § expression ist ein logischer Ausdruck (nach den Java Regeln) § Also ohne «{» und «}» § Beispiel: assert x>0; 107 assert-Statement in Java § Wenn zur Laufzeit expression nicht gültig ist, dann wird ein Laufzeitfehler generiert § Programm wirft AssertionError (Subclass von Error) § Aber nur wenn das assert Statement eingeschaltet ist § Da { und } (fast) überall in Texten verwendet werden verwenden wir diese Zeichen § … und die Hoare Logik kann nicht nur für Java verwendet werden 108 2.3.2 Hoare Tripel (oder 3-Tupel) 109 Hoare Tripel (oder 3-Tupel) § Ein Hoare Tripel besteht aus zwei Aussagen und einem Programmsegment: {P} S {Q} § P ist die Precondition § S das Programmsegment (bzw Statement) § Q ist die Postcondition 110 Hoare Tripel (oder 3-Tupel) § Ein Hoare Tripel {P} S {Q} ist gültig wenn (und nur wenn): § Für jeden Zustand, für den P gültig ist, ergibt die Ausführung von S immer einen Zustand für den Q gültig ist. § Informell: Wenn P wahr ist vor der Ausführung von S, dann muss Q nachher wahr sein. § Andernfalls ist das Hoare Tripel ungültig. 111 Überblick § Wenn P wahr ist vor der Ausführung von S, dann muss Q nachher wahr sein. § Bisher «informell» § Für jedes Java Statement gibt es genaue Regeln die eine Precondition und eine Postcondition in Beziehung setzen § Regel für Zuweisungen § Regel für zwei aufeinander folgende Anweisungen § Regel für «if»-Statements § [später:] Regel für Schleifen 113 2.3.2.1 Eine Zuweisung 114 Zuweisungen {P} x = e; {Q} § Bilden wir Q’ in dem wir in Q die Variable x durch e ersetzen § Das Tripel ist gültig wenn: Für alle Zustände des Programms ist Q’ wahr wenn P wahr ist § D.h., aus P folgt Q’, geschrieben P ⇒ Q’ 115 Review ⇒ 118 U. Maurer: Diskrete Mathematik (Script) ETH Zürich, 2020 120 Beispiel {z > 34} y = z+1; {y > 1} Q’ ist {z+1 > 1} 121 Beispiel {z > 34} y = z+1; {y > 1} Q’ ist {z+1 > 1} Gilt P ⇒ Q’ ? 122 Also (z>34) ⇒ (z+1) > 1 ? ✓ Beispiel {z ≠ 1} y = z*z; {y ≠ z} Q’ ist {z*z ≠ z} 123 Beispiel {z ≠ 1} y = z*z; {y ≠ z} Q’ ist {z*z ≠ z} Gilt P ⇒ Q’ ? 124 Also (z ≠ 1) ⇒ (z*z) ≠ z ? ✘ (z==0) Beispiele Gültig oder ungültig? § Wir nehmen an: alles int Variablen, ohne Overflow/Underflow 1. {x ≠ 0} y = x*x; {y > 0} 2. {z ≠ 0} y = z*z; {y ≠ z} 3. {x >= 0} y = 2*x; {y > x} 126 PollBeispiele Gültig oder ungültig? § Wir nehmen an: alles int Variablen, ohne Overflow/Underflow 1. {x ≠ 0} y = x*x; {y > 0} 2. {z ≠ 0} y = z*z; {y ≠ z} 3. {x >= 0} y = 2*x; {y > x} 127 gültig ungültig ungültig Poll 252-0027 Einführung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH Zürich Übersicht § 2.3 Aussagen über Programm(segment)e § Vorwärts/Rückwärts schliessen § 2.3.1 Pre- und Postconditions § 2.3.2 Hoare-Tripel für Anweisungen § 2.3.2.1 Eine Zuweisung § 2.3.2.2 Folgen von Anweisungen § 2.4 Verzweigungen 2 Hoare Tripel (oder 3-Tupel) § Ein Hoare Tripel besteht aus zwei Aussagen und einem Programmsegment: {P} S {Q} § P ist die Precondition § S das Programmsegment (bzw Statement) § Q ist die Postcondition 3 Hoare Tripel (oder 3-Tupel) § Ein Hoare Tripel {P} S {Q} ist gültig wenn (und nur wenn): § Für jeden Zustand, für den P gültig ist, ergibt die Ausführung von S immer einen Zustand für den Q gültig ist. § Informell: Wenn P wahr ist vor der Ausführung von S, dann muss Q nachher wahr sein. § Andernfalls ist das Hoare Tripel ungültig. 4 Eine Zuweisung {P} x = e; {Q} § Bilden wir Q’ in dem wir in Q die Variable x durch e ersetzen § Das Tripel ist gültig wenn: Für alle Zustände des Programms ist Q’ wahr wenn P wahr ist § D.h., aus P folgt Q’, geschrieben P ⇒ Q’ 5 Hoare Tripel: {P} S {Q} 6 {P} S {Q} (Programm) Zustand (vor S) Zustand (nach S) Aussagen über Programmaus- führungen Variable Wert Hoare Tripel: {P} S {Q} 7 {P} S {Q} (Programm) Zustand (vor S) Zustand (nach S) Aussagen über alle Programmaus- führungen Variable Wert Hoare Tripel: {P} S {Q} 8 {P} x = y + 1 {Q} x 0 y 8 x 9 y 8 Zustand (vor S) Zustand (nach S) Hoare Tripel: {P} S {Q} 9 {??} x = y + 1 {x > 5} x 0 y 8 x 9 y 8 Zustand (vor S) Zustand (nach S) Hoare Tripel: {P} S {Q} 10 {y > 6} x = y + 1 {x > 5} x 0 y 8 x 9 y 8 Zustand (vor S) Zustand (nach S) Tripel ist gültig da aus y>6 folgt (y+1)>5 (das ist Q') Hoare Tripel: {P} S {Q} 11 {P} x = 6 {Q} x 0 x 6 Zustand (vor S) Zustand (nach S) Hoare Tripel: {P} S {Q} 12 {??} x = 6 {x > 5} x 0 x 6 Zustand (vor S) Zustand (nach S) Aussagen über alle Programmaus- führungen Wie drücken wir aus dass Q immer gilt? Hoare Tripel: {P} S {Q} 13 {true} x = 6 {x > 5} x 0 x 6 Zustand (vor S) Zustand (nach S) Aussagen über alle Programmaus- führungen Wie drücken wir aus dass Q immer gilt? 2.3.2.2 Folgen von Anweisungen § Wir können auch Hoare Tripel für eine Folge von Anweisungen definieren { Precondition } Statement 1 Statement 2 { Postcondition } § Auch hier ist Vorwärts- und Rückwärts-Schliessen möglich 14 Folgen von Anweisungen 15 § Einfachste Folge: zwei Statements {P} S1;S2 {Q} § Tripel ist gültig wenn (und nur wenn) es eine Aussage R gibt so dass 1. {P} S1 {R} ist gültig, und 2. {R} S2 {Q} ist gültig. Beispiel § Alle Variable sind int, kein Overflow/Underflow {z >= 1} y = z+1; w = y*y; {w > y} 16 Beispiel § Alle Variable sind int, kein Overflow/Underflow {z >= 1} y = z+1; {y > 1} w = y*y; {w > y} 19 Sei R die Aussage {y > 1} 1. Wir zeigen dass {z >= 1} y=z+1; {y > 1} gültig ist. Regel für Zuweisungen: z >= 1 impliziert z+1 > 1 2. Wir zeigen dass {y > 1} w=y*y; {w > y} gültig ist. Regel für Zuweisungen: y > 1 impliziert y*y > y Beispiele Gültig oder ungültig? § Wir nehmen an alles int Variablen, ohne Overflow/Underflow 1. {true} x = y; z = x; {y == z} 2. {x == 7 ∧ y == 5} tmp = x; x = tmp; y = x; {y == 7 ∧ x == 5} 21 PollBeispiele Gültig oder ungültig? § Wir nehmen an alles int Variablen, ohne Overflow/Underflow 1. {true} x = y; z = x; {y == z} gültig 2. {x == 7 ∧ y == 5} tmp = x; x = tmp; y = x; {y == 7 ∧ x == 5} ungültig 22 Poll 252-0027 Einführung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH Zürich 252-0027 Einführung in die Programmierung 2.4 Verzweigungen Thomas R. Gross Department Informatik ETH Zürich Übersicht § 2.4 Verzweigungen § 2.4.1 «if»-Anweisungen § Vergleichsoperatoren § 2.4.2 Typ boolean § 2.4.3 Bedingte («short-circuit») Auswertung § 2.4.4 Pre- und Postconditions § 2.4.5 «Schwächste» Vorbedingung 25 2.4 Verzweigungen («if»-Anweisungen) § Wollen nur manche Anweisungen (Statements) ausführen § Eine Anweisung die die Ausführung der anderen kontrolliert: § if-Anweisung § Verschiedene Varianten § Manchmal spricht man auch von «bedingter Ausführung» § Eine Bedingung muss erfüllt sein damit eine Anweisung ausgeführt wird 2.4.1 «if»-Anweisungen«if»-Anweisung («if-Statement») § Führt eine Anweisung (oder Anweisungen) nur aus wenn test den Wert wahr («true») ergibt. if (test) { statement(s); ... } // folgende Anweisung § Beispiel: double punkte = console.nextDouble(); if (punkte >= 50.0) { System.out.println(\"Pruefung bestanden.\"); } Anweisung(en) ausführen Ist test wahr? Folgende Anweisung ausführen janein «if-else»-Anweisung § Führt eine Gruppe von Anweisungen aus wenn test den Wert wahr («true») ergibt, sonst eine andere Gruppe if (test) { statement(s); } else { statement(s); } // folgende Anweisung § Beispiel: «if» Anweisung(en) ausführen Ist test wahr? Folgende Anweisung ausführen janein «else» Anweisung(en) ausführen double punkte = console.nextDouble(); if (punkte >= 50.0) { System.out.println(\"Pruefung bestanden.\"); } else { System.out.println(\"Pruefung nicht bestanden.\"); } «if-else»-Anweisung § Führt «if»-Block Gruppe von Anweisungen aus wenn test den Wert wahr («true») ergibt, sonst «else»-Block Gruppe if (test) { //if-Block statement(s); } else { //else-Block statement(s); } // folgende Anweisung § Statt if-Block sagen wir manchmal then-Block «if» -Block («then»-Block) Anweisung(en) Ist test wahr? Folgende Anweisung ausführen janein «else» -Block Anweisung(en) Boolesche Ausdrücke § Was für Tests können wir in einem if-Statement (oder if-else— Statement) verwenden? § Fall 1: Variable und Werte eines Basistyps § Bisher kennen wir nur int, long und double § Was wir vorstellen gilt für alle Basistypen 34 Boolesche Ausdrücke § if-Anweisungen und if-else-Anweisungen verwenden beide boolesche Ausdrücke if (i > 0) { ... } if (i > 10) { ... } else { ... } § Oft Vergleiche oder Kombinationen von Vergleichen § Diese Ausdrücke werden ausgewertet --- Ergebnis entweder «true» oder «false» § true und false sind Konstanten (für Wahrheitswerte) § Ausdrücke verwenden Vergleichsoperatoren Vergleichsoperatoren § Vorsicht: nicht alle Vergleichsoperatoren können für alle Typen (sinnvoll) angewendet werden § Vergleichsoperatoren haben tiefen Rang § 1+1==2 soll (1+1)==2 ergeben: 1+false macht keinen Sinn Operator Bedeutung Beispiel Wert == gleich 1 + 1 == 2 true != ungleich 3 != 2 true < weniger als 10 < 5 false > grösser als 10 > 5 true <= weniger als oder gleich 126 <= 100 false >= grösser als oder gleich 5 >= 5 true Vergleichsoperatoren § Vergleichsoperatoren haben eine tiefere Präzedenz als arithmetische Operatoren. 5 * 7 >= 8 + 4 * (7 - 1) 5 * 7 >= 8 + 4 * 6 35 >= 8 + 24 35 >= 32 true § Vergleichsoperatoren können nicht eine «Kette» bilden wie in Mathematik 2 <= x <= 10 true <= 10 (Annahme: x ist 15) error! Vergleichsoperatoren im if-Statement § Der boolesche Ausdruck steht (im if-Statement) in Klammern 39 Boolesche Ausdrücke § Aussagen: boolescher Ausdruck § Aussagen können mit && (UND) oder || (ODER) kombiniert werden 2 <= x && x <= 10 (Annahme: x ist 15) True && False False § Verwenden Sie Klammern um Klarheit zu schaffen (2 <= x) && (x <= 10) Boolesche Operatoren § Ausdrücke mit Vergleichsoperatoren können durch boolesche Operatoren verknüpft werden § «Wahrheitstabelle» für diese Operatoren, für Aussagen p und q: Operator Bedeutung Beispiel Wert && and (2 == 3) && (-1 < 5) false || or (2 == 3) || (-1 < 5) true ! not !(2 == 3) true p q p && q p || q true true true true true false false true false true false true false false false false p !p true false false true Boolesche Ausdrücke § Was ist das Ergebnis für die folgenden Ausdrücke? int x = 42; int y = 17; int z = 25; 1. y < x && y <= z 2. x % 2 == y % 2 || x % 2 == z % 2 3. x <= y + z && x >= y + z 4. !(x < y && x < z) 5. (x + y) % 2 == 0 || !((z - y) % 2 == 0) Poll § Was ist das Ergebnis für die folgenden Ausdrücke? int x = 42; int y = 17; int z = 25; 1. y < x && y <= z à true 2. x % 2 == y % 2 || x % 2 == z % 2 à false 3. x <= y + z && x >= y + z à true 4. !(x < y && x < z) à true 5. (x + y) % 2 == 0 || !((z - y) % 2 == 0) à false Boolesche Ausdrücke Poll= und == in Java § = ist der Zuweisungsoperator (assignment operator) int k = 4; // k hat nach diesem Statement den Wert 4 § Ergebnis ist der Wert 4 -- kein Wahrheitswert § Entsprechende Fehlermeldung § Aber manchmal ist die Fehlermeldung verwirrend 48 if (k = 4) { .... } HW.java:10: error: incompatible types if (k = 4) { ^ required: boolean found: int § Fehlermeldung eventuell verwirrend § Im Programm: § if (int j = 4) { § Compiler Antwort: HW.java:9: error: '.class' expected if (int j = 4) { ^ HW.java:9: error: illegal start of expression if (int j = 4) { ^ HW.java:9: error: ';' expected if (int j = 4) { ^ HW.java:9: error: illegal start of expression if (int j = 4) { ^ HW.java:9: error: ';' expected if (int j = 4) { ^ HW.java:13: error: class, interface, or enum expected 49 = und == in Java § = ist der Zuweisungsoperator («assignment operator») int k = 4; // k hat nach diesem Statement den Wert 4 § Ergebnis ist der Wert 4 -- kein Wahrheitswert § == ist der Vergleichsoperator (auf Gleichheit) § Kann in if-Statement verwendet werden § if (k == 4) { 50 if (k = 4) { .... } HW.java:10: error: incompatible types if (k = 4) { ^ required: boolean found: int Beispiel § Welcher boolesche Ausdruck ergibt true wenn das Jahr jahr ein Schaltjahr ist? § jahr ist Schaltjahr wenn jahr durch 4 teilbar ist (ohne Rest), jahr aber nicht durch 100 ohne Rest teilbar ist, es sei denn dass jahr ohne Rest durch 400 teilbar sei. § int jahr; // aktuelles Jahr § jahr % 4 == 0 && jahr % 100 != 0 || jahr % 400 == 0 § Besser mit Klammern: ((jahr % 4 == 0) && (jahr % 100 != 0)) || (jahr % 400 == 0) 51 Beispiel § Welcher boolesche Ausdruck ergibt true wenn ein Jahr jahr ein Schaltjahr ist? § jahr ist Schaltjahr wenn jahr durch 4 teilbar ist (ohne Rest), jahr aber nicht durch 100 ohne Rest teilbar ist, es sei denn dass jahr ohne Rest durch 400 teilbar sei. § int jahr; // aktuelles Jahr § jahr % 4 == 0 && jahr % 100 != 0 || jahr % 400 == 0 § Besser mit Klammern: ((jahr % 4 == 0) && (jahr % 100 != 0)) || (jahr % 400 == 0) 52 Beispiel § Welcher boolesche Ausdruck ergibt true wenn ein Jahr jahr ein Schaltjahr ist? § jahr ist Schaltjahr wenn jahr durch 4 teilbar ist (ohne Rest), jahr aber nicht durch 100 ohne Rest teilbar ist, es sei denn dass jahr ohne Rest durch 400 teilbar sei. § int jahr; // aktuelles Jahr § jahr % 4 == 0 && jahr % 100 != 0 || jahr % 400 == 0 § Besser mit Klammern: ((jahr % 4 == 0) && (jahr % 100 != 0)) || (jahr % 400 == 0) 53 Gebrauch von if Was fällt Ihnen in diesem Code Beispiel auf? Scanner console = new Scanner(System.in); System.out.print(\"Wieviele Punkte haben Sie erreicht? \"); int percent = console.nextInt(); if (percent >= 90) { System.out.println(\"Ihre Note ist 6.0.\"); } if (percent >= 80) { System.out.println(\"Ihre Note ist 5.0.\"); } if (percent >= 70) { System.out.println(\"Ihre Note ist 4.0.\"); } if (percent >= 60) { System.out.println(\"Ihre Note ist 3.5.\"); } if (percent < 60) { System.out.println(\"Ihre Note ist 3.0.\"); } ... Verschachtelte if-else-Anweisungen Auswahl bestimmt durch mehrere Tests if (test1) { statement(s); } else if (test2) { statement(s); } else { statement(s); } // folgende Anweisung Gruppe 1 Anwei- sungen ausführen Ergibt test1 wahr? janein Gruppe 2 Anwei- sungen ausführen Ergibt test2 wahr? Folgende Anweisung ausführen janein Gruppe 3 Anwei- sungen ausführen Verschachtelte if-else-Anweisungen Beispiel: if (x > 0) { System.out.println(\"Positiv\"); } else if (x < 0) { System.out.println(\"Negativ\"); } else { System.out.println(\"Null\"); } Gruppe 1 Anwei- sungen ausführen Ergibt test1 wahr? janein Gruppe 2 Anwei- sungen ausführen Ergibt test2 wahr? Folgende Anweisung ausführen janein Gruppe 3 Anwei- sungen ausführen Verschachtelte if-else-if § Endet mit else: genau ein Pfad muss ausgeführt werden § Endet mit if: Eventuell wird keine Anweisung ausgeführt. if (test1) { statement(s); //Gruppe 1 } else if (test2) { statement(s); //Gruppe 2 } else if (test3) { statement(s); //Gruppe 3 } Gruppe 1 Anwei- sungen ausführen Ergibt test1 wahr? janein Gruppe 2 Anwei- sungen ausführen Ergibt test2 wahr? janein Gruppe 3 Anwei- sungen ausführen Ergibt test3 wahr? janein Verschachtelte if-else-if if (place == 1) { System.out.println(\"Gold!!\"); } else if (place == 2) { System.out.println(\"Silber!\"); } else if (place == 3) { System.out.println(\"Bronze.\"); } Gruppe 1 Anwei- sungen ausführen Ergibt test wahr? janein Gruppe 2 Anwei- sungen ausführen Ergibt test wahr? ja Gruppe 3 Anwei- sungen ausführen Ergibt test wahr? janein Verschachtelte if-Konstrukte • Genau ein 1 Pfad mit Anweisung(en) (gegenseitiger Ausschluss) if (test) { statement(s); } else if (test) { statement(s); } else { statement(s); } • 0 oder 1 Pfad mit Anweisung(en) (gegenseitiger Ausschluss) if (test) { statement(s); } else if (test) { statement(s); } else if (test) { statement(s); } • 0, 1, oder viele Pfade mit Anweisung(en) (unabhängig, kein gegenseitiger Ausschluss) if (test) { statement(s); } if (test) { statement(s); } if (test) { statement(s); } verschachtelte if/else verschachtelte if/else/if aufeinanderfolgende if/if/if Welche if/else-Kombination? (1) verschachtelte if/else (2) verschachtelte if/else/if (3) Folge von if/if/if § Ob – abhängig von früheren Rennen – jemand in der ersten, zweiten, oder letzten Gruppe startet. § (1) verschachtelte if / else if / else § Ob es eine Medaille (Notendurschnitt ≥ 5.9) oder eine Urkunde (5.75 – 5.9) gibt. § (2) verschachtelte if / else if § Ob eine Zahl durch 2, 3, und/oder 5 teilbar ist. § (3) Folge von if / if / if § Note (auf 0.25 gerundet) aufgrund der Punkte (Prozent) in der Prüfung. § (1) verschachtelte if / else if / else if / else if / else Poll 2.4.2 Typ boolean § Boolesche Werte können in Variablen des Typs boolean gespeichert werden. § Der Typ boolean kennt nur zwei Werte: wahr (true) und falsch (false). § Ein Vergleich («test») ist ein boolescher Ausdruck (ein Ausdruck der ein boolean Ergebnis hat). § Boolesche Ausdrücke können mit den booleschen Operatoren kombiniert werden. § boolean quadrant1; oder boolean quadrant1 = true; deklarieren boolesche Variable. Gebrauch von boolean § Kann Ergebnis eines komplizierten Ausdrucks speichern und später wiederverwenden § Vorausgesetzt die Komponenten ändern sich nicht … § Macht Programm lesbarer Beispiel – wer kann Antrag stellen? 69 Beispiel (Keine Rechtsauskunft) int jahreCH_CB; int jahrCH_F; int jahreCHletzte5; int jahreKvor18; int jahreCH = (jahreCH_F/2 +jahreCH_CB); boolean bundJ10 = jahreCH >= 10; boolean bund1 = bundJ10 && (jahreCHletzte5 >= 3); boolean bund2 = (jahreCH>=6) && (jahreKvor18 + jahreGvor18)*2 >= 10; boolean antragErlaubt = bund1 || bund2; 70 int jahreKnach18; int jahreGvor18; int jahreGnach18; Hinweise § Manchmal sieht man solchen Code (test ob eine Variable den Wert true hat): boolean isPrime = … ; if (isPrime == true) { // schlecht ... } § Das ist nicht nötig und redundant. Besser : if (isPrime) { // gut ... } Hinweise § Auch nicht besser ist der Test für false: if (isPrime == false) { // schlecht if (!isPrime) { // gut 2.4.3 Bedingte Auswertung § Für && und || müssen nicht immer beide Operanden ausgewertet werden, um das Ergebnis zu ermitteln § Java beendet die Auswertung eines booleschen Ausdrucks sobald das Ergebnis fest steht. § Dies nennen wir eine «short-circuit» Auswertung oder bedingte Auswertung § Folgende Teilausdrücke werden abhängig von zuerst ausgewerteten Ausdrücken (nicht) evaluiert § Regel der Programmiersprache Bedingte («short-circuit») Auswertung § Für && und || müssen nicht immer beide Operanden ausgewertet werden, um das Ergebnis zu ermitteln § Java beendet die Auswertung eines booleschen Ausdrucks sobald das Ergebnis fest steht. § && stoppt sobald ein Teil(ausdruck) false ist § || stoppt sobald ein Teil(ausdruck) true ist Boolesche Operatoren § Ausdrücke mit Vergleichsoperatoren können durch boolesche Operatoren verknüpft werden § && und || sind links-assoziativ § Ausdrücke werden von links nach rechts, gemäss Präzedenz und Assoziativität ausgewertet § Klammern schaffen Klarheit Auswertung eines Tests § Gegeben Programm(segment) mit drei int Variablen a, b und x § Wir wollen x zum Quotienten a/b setzen, aber nur wenn a/b grösser als 0 ist int a; int b; int x; // a, b werden irgendwie gesetzt // nur positive Werte sollten gespeichert werden // integer division kann 0 fuer a,b !=0 ergeben x = ... Auswertung eines Tests § Gegeben Programm(segment) mit drei int Variablen a, b und x § Wir wollen x zum Quotienten a/b setzen, aber nur wenn a/b grösser als 0 ist int a; int b; int x; // a, b werden irgendwie gesetzt // nur positive Werte sollten gespeichert werden // integer division kann 0 fuer a,b !=0 ergeben // duerfen nicht durch 0 dividieren x = ... Auswertung eines Tests § Gegeben Programm(segment) mit drei int Variablen a, b und x § Wir wollen x zum Quotienten a/b setzen, aber nur wenn a/b grösser als 0 ist int a; int b; int x; // a, b werden irgendwie gesetzt // nur positive Werte sollten gespeichert werden // integer division kann 0 fuer a,b !=0 ergeben if (b != 0) { x = ... Auswertung eines Tests § Wollen Quotienten a/b nur speichern wenn grösser als 0 int a; int b; int x; // a, b werden irgendwie gesetzt // nur positive Werte sollten gespeichert werden // integer division kann 0 fuer a,b !=0 ergeben if (b != 0) { if (a/b > 0) { x = a/b; } } Auswertung eines Tests § Viele if-Statements machen Programm unleserlich int a; int b; int x; // a, b werden irgendwie gesetzt // nur positive Werte sollten gespeichert werden // integer division kann 0 fuer a,b !=0 ergeben if (b != 0) { if (a/b > 0) { x = a/b; } } Boolsche Ausdrücke schaffen Klarheit … § Viele if-Statements machen Programm unleserlich int a; int b; int x; // a, b werden irgendwie gesetzt // nur positive Werte sollten gespeichert werden // integer division kann 0 fuer a,b !=0 ergeben // (a/b) > 0 // b != 0 { x = a/b; } } Boolsche Ausdrücke schaffen Klarheit … § Umsetzung in boolschen Ausdruck einfach – in der Logik int a; int b; int x; // a, b werden irgendwie gesetzt // nur positive Werte sollten gespeichert werden // integer division kann 0 fuer a,b !=0 ergeben // (a/b) > 0 // b != 0 { x = a/b; } } Boolsche Ausdrücke schaffen Klarheit … § Dieser Code führt zu einer Fehlermeldung wenn b == 0: int a; int b; int x; // a, b werden irgendwie gesetzt // nur positive Werte sollten gespeichert werden // integer division kann 0 fuer a,b !=0 ergeben // (a/b) > 0 if ((a/b > 0) && (b != 0)) { x = a/b; } } Reihenfolge der Operanden ist wichtig § Dieser Code führt zu einer Fehlermeldung wenn b == 0: int a; int b; int x; // a, b werden irgendwie gesetzt // nur positive Werte sollten gespeichert werden // integer division kann 0 fuer a,b !=0 ergeben // (a/b) > 0 if ((a/b > 0) && (b != 0)) { x = a/b; } } Bedingte («short-circuit») Auswertung § Dieser Code führt zu keiner Fehlermeldung wenn b == 0: int a; int b; int x; // a, b werden irgendwie gesetzt // nur positive Werte sollten gespeichert werden // integer division kann 0 fuer a,b !=0 ergeben // (a/b) > 0 if ((b != 0) && (a/b > 0)) { x = a/b; } De Morgan's Regeln Regeln für die Negation boolescher Ausdrücke. § Praktisch wenn man das Gegenteil eines Ausdrucks braucht. § Beispiel: Ursprünglicher Ausdruck Negierter Ausdruck Alternative a && b !a || !b !(a && b) a || b !a && !b !(a || b) Original Negiert if (x == 7 && y > 3) { ... } if (x != 7 || y <= 3) { ... } 2.4.4 Pre/Postconditions für if-Anweisungen 88 If-Statement Muster // ursprüngliche Annahmen if (test) { // wissen das test true war then-Block (auch if-Block genannt) } else { // wissen das test false war else-Block } // können then-Block oder else-Block ausgeführt haben 89 If-Statement Muster // ursprüngliche Annahmen if (test) { // wissen das test true war then-Block } else { // wissen das test false war else-Block } // können then-Block oder else-Block ausgeführt haben 90 Grundidee(n) 1. Die Precondition für den then-Block und den else-Blocks (eines if-Statements) beinhaltet das Ergebnis des Tests. 2. Die Postcondition nach dem if-Statement ist die Disjunktion («oder») der Postconditions des then- und else-Blockes. 92 If-Statement Muster // ursprüngliche Annahmen if (test) { // wissen das test true war then-Block // Q1 } else { // wissen das test false war else-Block // Q2 } // Q1 ∨ Q2 (können then-Block oder else-Block ausgeführt haben) 93 If-Statements 94 {P} if (b) S1 else S2 {Q} § Tripel ist gültig wenn (und nur wenn) es Aussagen Q1, Q2 gibt so dass 1. {P ∧ b} S1 {Q1} ist gültig und 2. {P ∧ !b} S2 {Q2} ist gültig und 3. Nach dem if-Statement gilt Q, d.h. a) Aus Q1 folgt Q b) Aus Q2 folgt Q If-Statements 96 {P} if (b) S1 else S2 {Q} § Tripel ist gültig wenn (und nur wenn) es Aussagen Q1, Q2 gibt so dass 1. {P ∧ b} S1 {Q1} ist gültig und 2. {P ∧ !b} S2 {Q2} ist gültig und 3. Nach dem if-Statement gilt Q, d.h. (aus Q1 folgt Q) und (aus Q2 folgt Q) If-Statements 97 {P} if (b) S1 else S2 {Q} § Tripel ist gültig wenn (und nur wenn) es Aussagen Q1, Q2 gibt so dass 1. {P ∧ b} S1 {Q1} ist gültig und 2. {P ∧ !b} S2 {Q2} ist gültig und 3. Nach dem if-Statement gilt Q, d.h. (Q1 ⇒ Q) ∧ (Q2 ⇒ Q) If-Statements 99 {P} if (b) S1 else S2 {Q} § Tripel ist gültig wenn (und nur wenn) es Aussagen Q1, Q2 gibt so dass 1. {P ∧ b} S1 {Q1} ist gültig und 2. {P ∧ !b} S2 {Q2} ist gültig und 3. (Q1 ∨ Q2) ⇒ Q If-Statements 100 {P} if (b) S1 else S2 {Q} § Tripel ist gültig wenn (und nur wenn) es Aussagen Q1, Q2 gibt so dass 1. {P ∧ b} S1 {Q1} ist gültig und 2. {P ∧ !b} S2 {Q2} ist gültig und 3. Nach dem if-Statement gilt Q, d.h. a) Aus Q1 folgt Q b) Aus Q2 folgt Q Beispiel Alle Variable sind int, kein Overflow/Underflow {true} if (x > 7) { y = x; } else { y = 20; } {y > 5} § Sei Q1 {y > 7} (andere Aussagen gehen evtl. auch) § Sei Q2 {y == 20} (andere Aussagen gehen evtl. auch) 101 Hoare Tripel: {P} S {Q} 103 x ... y ... x ... y ... Zustand (vor S) Zustand (nach S) {true} if (x > 7) { y = x; } else { y = 20; } {y > 5} Beispiel Alle Variable sind int, kein Overflow/Underflow {true} if (x > 7) { y = x; } else { y = 20; } {y > 5} § Sei Q1 {y > 7} (andere Aussagen gehen evtl. auch) § Sei Q2 {y == 20} (andere Aussagen gehen evtl. auch) § Mit der Regel für Zuweisungen können wir zeigen {true ∧ x > 7} y = x; {y > 7} § Mit der Regel für Zuweisungen {true ∧ x <= 7} y = 20; {y == 20} 104 Beispiel Alle Variable sind int, kein Overflow/Underflow {true} if (x > 7) { y = x; } else { y = 20; } {y > 5} § Sei Q1 {y > 7} (andere Aussagen gehen evtl. auch) § Sei Q2 {y == 20} (andere Aussagen gehen evtl. auch) § Mit der Regel für Zuweisungen können wir zeigen {true ∧ x > 7} y = x; {y > 7} § Mit der Regel für Zuweisungen {true ∧ x <= 7} y = 20; {y == 20} § Dann zeige dass (y>7) ∨ (y==20) ⇒ y>5 105gültig Beispiel Alle Variable sind int, kein Overflow/Underflow {true} if (x > 7) { y = 4; } else { y = 20; } {y > 5} § Sei Q1 {y > 3} (andere Aussagen gehen evtl. auch) § Sei Q2 {y == 20} (andere Aussagen gehen evtl. auch) § Mit der Regel für Zuweisungen können wir zeigen {true ∧ x > 7} y = 4; {y > 3} § Mit der Regel für Zuweisungen {true ∧ x <= 7} y = 20; {y == 20} § Dann zeige dass a) Aus Q1 folgt Q b) Aus Q2 folgt Q 106 Hoare Tripel: {P} S {Q} 107 x 0 y ... x 0 y 20 Zustand (vor S) Zustand (nach S) {true} if (x > 7) { y = 4; } else { y = 20; } {y > 5} Hoare Tripel: {P} S {Q} 108 x 8 y 22 x 8 y 4 Zustand (vor S) Zustand (nach S) {true} if (x > 7) { y = 4; } else { y = 20; } {y > 5} Beispiel Alle Variable sind int, kein Overflow/Underflow {true} if (x > 7) { y = 4; } else { y = 20; } {y > 5} § Sei Q1 {y > 3} (andere Aussagen gehen evtl. auch) § Sei Q2 {y == 20} (andere Aussagen gehen evtl. auch) § Mit der Regel für Zuweisungen können wir zeigen {true ∧ x > 7} y = 4; {y > 3} § Mit der Regel für Zuweisungen {true ∧ x <= 7} y = 20; {y == 20} § Dann zeige dass a) y>3 ⇒ y>5 b) y==20 ⇒ y>5 109nicht gültig Beispiel Alle Variable sind int, kein Overflow/Underflow {true} if (x > 7) { y = 4; } else { y = 20; } {y > 5} § Sei Q1 {y > 3} § Sei Q2 {y == 20} (andere Aussagen gehen evtl. auch) § Mit der Regel für Zuweisungen können wir zeigen {true ∧ x > 7} y = 4; {y > 3} § Mit der Regel für Zuweisungen {true ∧ x <= 7} y = 20; {y == 20} § Dann zeige dass y>3 ∨ y==20 ⇒ y>5 111 Vorsicht § Zur Party darf wer mindes- tens 18 oder ETH Student/in ist § Informell: (age>=18) ∨ (ETHstudent) § «Darf zur Party» § Hoare Logik § y>3 ∨ y==20 ⇒ y>5 § Wenn gültig: Es kann nicht sein dass y>3 ∨ y==20 wahr aber y>5 falsch ist § Nicht: Wenn y>3 ∨ y==20 wahr ist dann ist y>5 wahr 112 Noch ein Beispiel Alle Variable sind int, kein Overflow/Underflow {x > 0} if (a < 10) { y = 2*x; } else { y = a*x; } {y > 0} 114 Beispiel Alle Variable sind int, kein Overflow/Underflow {x > 0} if (a < 10) {y = 2*x;} else {y = a*x;} {y > 0} § Sei Q1 {y ≥ 2} (andere Aussagen gehen evtl. auch) § Sei Q2 {y ≥ 10} (andere Aussagen gehen evtl. auch) § Mit der Regel für Zuweisungen können wir zeigen {x>0 ∧ a<10} y = 2*x; {y ≥ 2} § Mit der Regel für Zuweisungen {x>0 ∧ a≥10} y = a*x; {y ≥ 10} § Dann zeige dass y≥2 ∨ y≥10 ⇒ y>0 115 Beispiele Gültig oder ungültig? § Wir nehmen an alles int Variablen, ohne Overflow/Underflow (A) (B) {true} if (x > 7) { y = 4; } else { y = 3; } {y < 5} 117 {x > 10} if (x%4 == 0) { y = x/4; } {y ≥ 2} PollBeispiele Gültig oder ungültig? § Wir nehmen an alles int Variablen, ohne Overflow/Underflow (A) (B) {true} if (x > 7) { y = 4; } else { y = 3; } {y < 5} 118 {x > 10} if (x%4 == 0) { y = x/4; } else { ; } {y ≥ 2} PollBeispiele Gültig oder ungültig? § Wir nehmen an alles int Variablen, ohne Overflow/Underflow {true} if (x > 7) { y = 4; } else { y = 3; } {y < 5} gültig 120 {x > 10} if (x%4 == 0) { y = x/4; } {y ≥ 2} ungültig Poll 121 {x > 10} if (x%4 == 0) { y = x/4; } else { ; } {y ≥ 2} § Sei Q1 {y ≥ 2} (andere Aussagen gehen evtl. auch) § Für S2 können wir keine genaueren Aussagen über den Zustand von y machen Poll § Da {x > 10} ist x mindestens 12 und somit y ≥ 2 § Aber wir wissen nicht welchen Wert y vorher hatte und so kann man nicht zeigen dass y≥2 § Hätten wir als Precondition {x > 10 ∧ y > 10} gehabt (z.B.) so könnte Q2 {y > 10} sein und das Tripel wäre gültig. 2.4.5 Schwächste Vorbedingung 124 Was für eine Vorbedingung wollen wir? x, y int; kein Over/Underflow {x>10} y = x+1; {y ≥ 2} {x>5} y = x+1; {y ≥ 2} {x≥1} y = x+1; {y ≥ 2} 125 Aussagen über Zustände Wir haben zwei Aussagen P1 und P2 Wenn P1 ⇒ P2 (also P1 impliziert P2) gilt dann sagen wir: § P1 ist stärker («stronger») als P2 § P2 ist schwächer («weaker») als P1 § Wenn immer P1 gilt, dann gilt auch P2 § Es ist also schwieriger (oder zumindest genauso schwierig) P1 zu erfüllen als (wie) P2 zu erfüllen § «stärker als»: «stärker als oder genauso stark wie» 127 Warum ist das interessant? § Stellen wir uns vor: § Es gilt {P} S {Q}, und § P ist schwächer als eine Aussage P1, und § Q ist stärker als eine Aussage Q1 § Dann gilt: § {P1} S {Q} § {P} S {Q1} § {P1} S {Q1} 128 252-0027 Einführung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH Zürich 252-0027 Einführung in die Programmierung 2.4 Verzweigungen Thomas R. Gross Department Informatik ETH Zürich Übersicht § 2.4 Verzweigungen § 2.4.1 «if»-Anweisungen § Vergleichsoperatoren § 2.4.2 Typ boolean § 2.4.3 Bedingte («short-circuit») Auswertung § 2.4.4 Pre- und Postconditions § 2.4.5 «Schwächste» Vorbedingung 3 2.4.5 Schwächste Vorbedingung 4 Aussagen über Zustände Wir haben zwei Aussagen P1 und P2 Wenn P1 ⇒ P2 (also P1 impliziert P2) gilt dann sagen wir: § P1 ist stärker («stronger») als P2 § P2 ist schwächer («weaker») als P1 § Wenn immer P1 gilt, dann gilt auch P2 § Es ist also schwieriger (oder zumindest genauso schwierig) P1 zu erfüllen als (wie) P2 zu erfüllen § «stärker als»: «stärker als oder genauso stark wie» 5 Warum ist das interessant? § Stellen wir uns vor: § Es gilt {P} S {Q}, und § P ist schwächer als eine Aussage P1, und § Q ist stärker als eine Aussage Q1 § Dann gilt: § {P1} S {Q} § {P} S {Q1} § {P1} S {Q1} 6 § Stärkere Preconditions (Vorbedingungen) oder schwächere Postconditions sind einfach § Wenn {P} S {Q} gilt § Aber was für ein P wollen wir wenn S und Q gegeben sind? {???} S {Q} § Am besten wäre es wenn wir zeigen könnten dass {Ps} S {Q} gilt, wobei Ps die schwächste Precondition von Q für S ist § Schwächste heisst: hat die wenigsten Annahmen so dass Q gilt § Jede Precondition P so dass {P}S{Q} gültig ist, ist dann stärker als Ps, d.h., P => Ps 7 § Ohne Schleifen und Methoden gibt es für jedes Programmsegment S und jede Postcondition Q eine eindeutige schwächste Precondition («weakest precondition»), abgekürzt wp(S,Q) § Variable sind immer int Variable, ohne Over/Underflow 8 wp(S, Q) § wp(x = e, Q) ist Q in dem jedes x durch e ersetzt wurde § Bespiel: wp(x = y*y, x>4) ist (y*y>4), d.h., |y| > 2 9 wp(S1;S2 , Q) § wp(S1;S2, Q) ist wp(S1,wp(S2, Q)) § D.h. Sei R die wp(S2,Q) dann ist die schwächste Precondition für die Folge S1;S2 die wp(S1,R). § Beispiel: wp(y=x+3; z=y+1, z>4) ist (x+3>3), d.h., (x>0) warum? R sei die wp(z=y+1, z>4) R ist (y+1>4) d.h. (y>3) dann ist wp(y=x+3, y>3) doch (x+3>3), d.h., (x>0) 11 Beispiel § Wenn S die Folge y = x+1; z = y–3; von Anweisungen ist, und Q ist z == 10, dann ist wp(S,Q) … = wp(y = x+1; z = y–3, z == 10) = wp(y = x+1, wp(z = y–3, z == 10)) = wp(y = x+1, y–3 == 10) = (x+1)–3 == 10 = x == 12 13 Beispiel (ohne Vereinfachung) § Wenn S die Folge y = x+1; z = y–3; von Anweisungen ist, und Q ist z == 10, dann wp(S,Q) … = wp(y = x+1; z = y–3, z == 10) = wp(y = x+1, wp(z = y–3, z == 10)) = wp(y = x+1, y–3 == 10) = wp(y = x+1, y == 13) = x+1 == 13 = x == 12 14 Hoare Tripel: {P} S {Q} 24 x 6 y 22 x 6 y 20 Zustand (vor S) Zustand (nach S) {??} if (x > 7) { y = x+1; } else { y = 20; } {y > 5} Hoare Tripel: {P} S {Q} 25 x 8 y 22 x 6 y 9 Zustand (vor S) Zustand (nach S) {??} if (x > 7) { y = x+1; } else { y = 20; } {y > 5} wp( if …, Q) § wp(if b S1 else S2, Q) muss garantieren 1. { wp(if..) ∧ b} S1 {Q1} ist gültig und 2. { wp(if..) ∧ !b} S2 {Q2} ist gültig und 3. Nach dem if-Statement gilt Q, d.h. a) Aus Q1 folgt Q b) Aus Q2 folgt Q § (b ∧ wp(S1, Q1)) garantiert (für gültiges Tripel {P} if.. {Q} ) dass { b ∧ wp(S1,Q1) } S1 {Q1} gültig ist § Genauso brauchen wir (!b ∧ wp(S2, Q2)) für Gültigkeit von {!b ∧ wp(S2,Q2)} S2 {Q2} 26 If-Statements 27 {P} if (b) S1 else S2 {Q} § Tripel ist gültig wenn (und nur wenn) es Aussagen Q1, Q2 gibt so dass 1. {P ∧ b} S1 {Q1} ist gültig und 2. {P ∧ !b} S2 {Q2} ist gültig und 3. Nach dem if-Statement gilt Q, d.h. a) Aus Q1 folgt Q b) Aus Q2 folgt Q wp( if …, Q) § wp(if b S1 else S2, Q) – möglich wäre (b ∧ wp(S1,Q1)) ∨ (!b ∧ wp(S2,Q2)) § Aber wir wollen die schwächste Vorbedingung § Da Q1 ⇒ Q ist wp(S1, Q1) stärker als wp(S1, Q) und wg. Q2 ⇒ Q ist wp(S2, Q2) stärker als wp(S2, Q) § «stärker als» lässt auch «genauso stark wie» zu 28 wp( if …, Q) § Da Q1 ⇒ Q ist wp(S1, Q1) stärker als wp(S1, Q) und wg. Q2 ⇒ Q ist wp(S2, Q2) stärker als wp(S2, Q) § wp(if b S1 else S2, Q) ist: (b ∧ wp(S1,Q)) ∨ (!b ∧ wp(S2,Q)) § Bemerkungen § Egal welchen Zustand die Ausführung erreicht hat, b ist entweder wahr (true) oder falsch (false) § Oft kann dieser Ausdruck dann weiter vereinfacht werden 29 wp( if …, Q) § wp(if b S1 else S2, Q) ist: (b && wp(S1,Q)) || (!b && wp(S2,Q)) § Bemerkungen § Egal welchen Zustand die Ausführung erreicht hat, b ist entweder wahr (true) oder falsch (false) § Oft kann dieser Ausdruck dann weiter vereinfacht werden 30 Beispiel 31 S ist if (x < 5) { y = x*x; } else { y = x+1; } Q ist y >= 9 Beispiel 32 -4 -3 -2 -1 0 721 4 653 8 9 S ist if (x < 5) { y = x*x; } else { y = x+1; } Q ist y >= 9 wp(S, y >= 9) = (x < 5 ∧ wp(y = x*x, y >= 9)) ∨ (x >= 5 ∧ wp(y = x+1, y >= 9)) = (x < 5 ∧ x*x >= 9) ∨ (x >= 5 ∧ x+1 >= 9) = (x <= -3) ∨ (x >= 3 ∧ x < 5) ∨ (x >= 8) wp(S, Q) = true § Wenn wp(S,Q) = true dann heisst das, dass die Ausführung von S immer einen Zustand produziert in dem Q gilt. § true gilt für jeden Zustand § Keine Annahmen 38 Hoare Tripel: {P} S {Q} 39 {??} x = 6 {x > 5} x ... x 6 Zustand (vor S) Zustand (nach S) Schwächste Vorbedingung wp(x=6, x>5) wp(x = e, Q) ist Q in dem jedes x durch e ersetzt wurde Hoare Tripel: {P} S {Q} 40 {??} x = 6 {x > 5} x ... x 6 Zustand (vor S) Zustand (nach S) Schwächste Vorbedingung wp(x=6, x>5) wp(x = e, Q) ist Q in dem jedes x durch e ersetzt wurde wp(..): 6 > 5 Hoare Tripel: {P} S {Q} 41 {true} x = 6 {x > 5} x ... x 6 Zustand (vor S) Zustand (nach S) Schwächste Vorbedingung wp(x=6, x>5) wp(x = e, Q) ist Q in dem jedes x durch e ersetzt wurde wp(..): 6 > 5 Hoare Tripel: {P} S {Q} 42 {false} x = 4 {x > 5} x ... x 4 Zustand (vor S) Zustand (nach S) Schwächste Vorbedingung Unerfüllbar Zur Erinnerung: Wenn P wahr ist vor der Ausführung von S, dann muss Q nachher wahr sein. Die schwächste Vorbedingung § Stellen wir uns vor: § Wir haben S (Programm oder Statement) und Aussage Q, die nach Ausführung von S gelten soll. § Jetzt suchen wir P so dass {P}S{Q} gültig ist § Nehmen wir es gibt verschiedene Aussagen Pi so dass P1 ⇒ P2 ⇒ P3 ⇒ P4 ⇒ … § Pi ist schwächer als Aussage Pi-1 § Nehmen wir weiter an dass {P1}S{Q},{P2}S{Q},…, {P4}S{Q} gilt, aber nicht {P5}S{Q} § P5 reicht nicht aus, um zu zeigen, dass Q nach S wahr ist 44 Beispiel P1: a==4 P2: a>3 P3: a>=3 P4: a>=2 P5: a>=−1 {Pi} S: x = 5+a; Q: { x >= 5} 45 Beispiel P1: a==4 P2: a>3 P3: a>=3 P4: a>=2 P5: a>=−1 {Pi} S: x = 5+a; Q: { x >= 5} 47 {P1} S {Q} a==4 x = 5+a; x >= 5 gilt {P2} S {Q} a>3 x = 5+a; x >= 5 gilt Beispiel P1: a==4 P2: a>3 P3: a>=3 P4: a>=2 P5: a>=−1 {Pi} S: x = 5+a; Q: { x >= 5} 48 {P4} S {Q} a>=2 x = 5+a; x >= 5 gilt {P5} S {Q} a>=−1 x = 5+a; x >= 5 gilt nicht Die schwächste Vorbedingung § Stellen wir uns vor: § Wir haben S (Program oder Statement) und Aussage Q, die nach Ausführung von S gelten soll. § Jetzt suchen wir P so dass {P}S{Q} gültig ist § Nehmen wir es gibt verschiedene Aussagen Pi so dass P1 ⇒ P2 ⇒ P3 ⇒ P4 ⇒ … § Pi ist schwächer als Aussage Pi-1 § Vielleicht ist es einfacher zu zeigen, dass {P1}S{Q} gilt als {P2}S{Q} § Denn P1 ⇒ P2 usw. 49 Die schwächste Vorbedingung § Vielleicht ist es einfacher zu zeigen, dass {P1}S{Q} gilt als {P2}S{Q} § Denn P1 ⇒ P2 usw. § Aber wir müssen vielleicht irgendwann zeigen, dass P1 gilt, nachdem M ausgeführt wurde § Daher sind wir an der schwächsten Aussage P\" interessiert, die gerade noch ausreicht so das {P\"}S{Q} gültig ist § Also P\" ist die Aussage P an der wir interessiert sind. 50 {R} M {P??} S {Q} Also … § Wenn wir rückwärts schliessen und wir wollen das {P}S{Q} gültig ist, dann wir zeigen wir dass {P\"}S{Q} gilt, wobei P\" die schwächste Precondition von Q für S ist. § Schwächste heisst: hat die wenigsten Annahmen/Einschränkungen so dass Q gilt § Jede Precondition P so dass {P}S{Q} gültig ist, ist dann stärker als P\", d.h., P ⇒ P\" 52 Eine kleine Komplikation § Wenn wir vorwärts schliessen, dann gibt es ein Problem mit Zuweisungen: § Änderungen des Wertes einer Variablen können andere Annahmen/Aussagen beeinflussen. 70 Beispiel {true} w=x+y; {w == x + y} x=4; {w == x + y ∧ x == 4} y=3; {w == x + y ∧ x == 4 ∧ y == 3} 71 Beispiel {true} w=x+y; //S1 {w == x + y;} x=4; //S2 {w == x + y ∧ x == 4} y=3; //S4 {w == x + y ∧ x == 4 ∧ y == 3} 72 x==3 und y==4 Dann hätten wir w == 7 Beispiel mit Problem {true} w=x+y; {w == x + y;} x=4; {w == x + y ∧ x == 4} y=3; {w == x + y ∧ x == 4 ∧ y == 3} 73 Aber halt: wissen wir wirklich w == 7 ? Eine kleine Komplikation § Wenn wir vorwärts schliessen, dann gibt es ein Problem mit Zuweisungen: § Änderungen des Wertes einer Variablen können andere Annahmen/Aussagen beeinflussen. § Lösung: Wenn wir einer Variablen einen Wert zuweisen dann müssen wir in der Postcondition den Namen dieser Variablen durch einen anderen (neuen) Namen ersetzen § Dann können wir uns auf den «alten» Wert beziehen 75 Beispiel (berichtigt) {true} w=x+y; {w == x + y;} x=4; {w == x1 + y ∧ x == 4} y=3; {w == x1 + y1 ∧ x == 4 ∧ y == 3} 76 Beispiel (alternativ) {true} w=x+y; {w == x + y;} x=4; {w == xold + y ∧ x == 4} y=3; {w == xold + yold ∧ x == 4 ∧ y == 3} 77 Praktisches Beispiel § Austausch («swap») tmp = x; x = y; y = tmp; § Ansatz: § Geben Sie dem ursprünglichen Inhalt (Wert) einer Variable einen Namen so dass Sie ihn in der Postcondition verwenden können. § Diese Namen existieren nur für die logischen Ausdrücke; es gibt nicht entsprechende Variablen im Programm. § Diese zusätzlichen Namen verhindern dass wir Abhängigkeiten «vergessen» 78 {x == x_old ∧ y == y_old} tmp = x; {x == x_old ∧ y == y_old ∧ tmp == x_old} x = y; {x == y ∧ y == y_old ∧ tmp == x_old} y = tmp; {x == y_old ∧ y == tmp ∧ tmp == x_old} 79 {x == x_old ∧ y == y_old} tmp = x; {x == x_old ∧ y == y_old ∧ tmp == x_old} x = y; {x == y ∧ y == y_old ∧ tmp == x_old} y = tmp; {x == y_old ∧ y == tmp ∧ tmp == x_old} {x == y_old ∧ y == x_old} 81 252-0027 Einführung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH Zürich 252-0027 Einführung in die Programmierung 2.5 Schleifen («Loops») Thomas R. Gross Department Informatik ETH Zürich 90 Übersicht § 2.5 Schleifen (Loops) § 2.5.1 «for» Loops § 2.5.2 Verschachtelte Schleifen § 2.5.3 «while» Loops § 2.6 Methoden § 2.7 Strings § 2.8 Nochmals Schleifen 91 2.5 Schleifen («Loops») 93 2.5.1 Einfache Schleifen: «for»-loop § Schleifen erlauben wiederholte Ausführung einer (oder mehrerer) Anweisung(en). § Schleifen («loops») kommen in verschiedenen Varianten § Zuerst: «for»-loop 94 for-loops erlauben einfache Wiederholungen § Bisher waren Wiederholungen manchmal nötig: System.out.println(\"Ich werde die Uebungsaufgaben machen\"); System.out.println(\"Ich werde die Uebungsaufgaben machen\"); System.out.println(\"Ich werde die Uebungsaufgaben machen\"); System.out.println(\"Ich werde die Uebungsaufgaben machen\"); System.out.println(\"Ich werde die Uebungsaufgaben machen\"); 95 for loops erlauben Wiederholungen § … aber sie sind hässlich und machen Programm länger § Sie machen das Programm unübersichtlich § Javas «for»-loop Anweisung wiederholt Anweisungen for (int i = 1; i <= 5; i = i + 1) { // repeat 5 times System.out.println(\"Ich werde die Uebungsaufgaben machen\"); } 96 for-loop Syntax for (initialization; test; update) { statement; statement; ... statement; } // naechste Anweisung (n.A.) § Initialisierung («Initialization») wird einmal ausgeführt. § Wiederhole diese Schritte: § Prüfe ob test wahr (true) ergibt. Wenn nicht, stop und weiter mit n.A. § Führe die Anweisung(en) (Statement(s)) aus. § Führe die Aktualisierung («Update») aus. body (Rumpf) header (Kopf) 97 Initialisierung for (int i = 1; i <= 5; i = i + 1) { System.out.println(\"Ich werde die Uebungsaufgaben machen\"); } § Legt die Variable fest, die im Loop verwendet wird § Wird einmal am Anfang der Schleife ausgeführt § Diese Variable heisst Schleifenzähler («loop counter») § Kann jeden Namen haben, nicht nur i § Kann mit jedem Wert anfangen, nicht nur 1 99 Test for (int i = 1; i <= 5; i = i + 1) { System.out.println(\"Ich werde die Uebungsaufgaben machen\"); } § Vergleicht die Zählervariable mit einem Grenzwert § Verwendet Vergleichsoperatoren («comparison operators») § Die selben wie für if-Statements < weniger als («less than») <= weniger als oder gleich («less than or equal to») > grösser als («greater than») >= grösser als oder gleich («greater than or equal to») 100 Aktualisierung for (int i = 1; i <= 5; i = i + 1) { System.out.println(\"Ich werde die Uebungsaufgaben machen\"); } § Die Zählervariable muss sich ändern § Sonst findet die Schleife kein Ende § test ergibt immer true § Ein beliebiger Ausdruck zulässig § Compiler prüft nicht dass die Zählervariable verwendet wird 102 Wiederholungen für ein Interval [1..6] System.out.println(\"1 hoch 2 = \" + 1 * 1); System.out.println(\"2 hoch 2 = \" + 2 * 2); System.out.println(\"3 hoch 2 = \" + 3 * 3); System.out.println(\"4 hoch 2 = \" + 4 * 4); System.out.println(\"5 hoch 2 = \" + 5 * 5); System.out.println(\"6 hoch 2 = \" + 6 * 6); § Intuition: «Ich will eine Zeile für jede Zahl von 1 bis 6 ausgeben» § Ein for-Loop erledigt genau diesen Job! for (int i = 1; i <= 6; i = i+1) { System.out.println(i + \" hoch 2 = \" + (i * i)); } § \"Für jede ganze Zahl i von 1 bis 6, drucke...\" 104 Mehrere Anweisungen im Rumpf System.out.println(\"+----+\"); for (int i = 1; i <= 3; i = i+1) { System.out.println(\"\\\\ /\"); System.out.println(\"/ \\\\\"); } System.out.println(\"+----+\"); 108 Mehrere Anweisungen im Rumpf System.out.println(\"+----+\"); for (int i = 1; i <= 3; i = i+1) { System.out.println(\"\\\\ /\"); System.out.println(\"/ \\\\\"); } System.out.println(\"+----+\"); § Output: +----+ \\ / / \\ \\ / / \\ \\ / / \\ +----+109 Schleifenkontrolle int highTemp = 5; for (int i = -3; i <= highTemp / 2; i = i + 1) { System.out.println(i + \" C = \" + (i * 1.8 + 32) + \" F\"); } Output: -3 C = 26.6 F -2 C = 28.4 F -1 C = 30.2 F 0 C = 32.0 F 1 C = 33.8 F 2 C = 35.6 F 111 Hochzählen, herunterzählen § Die Aktualisierung («update») kann auch den Schleifenzähler herunterzuzählen Aber der Vergleich in test muss dann > anstatt von < verwenden System.out.print(\"T-minus \"); for (int i = 10; i >= 1; i = i-1) { System.out.print(i + \" \"); } System.out.println(\"blastoff!\"); System.out.println(\"The end.\"); Output: T-minus 10 9 8 7 6 5 4 3 2 1 blastoff! The end. 113 252-0027 Einführung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH Zürich 252-0027 Einführung in die Programmierung 2.5 Schleifen («Loops») Thomas R. Gross Department Informatik ETH Zürich 2 Übersicht § 2.5 Schleifen (Loops) § 2.5.1 «for» Loops § 2.5.2 Verschachtelte Schleifen § 2.5.3 «while» Loops § 2.6 Methoden § 2.7 Strings § 2.8 Nochmals Schleifen 3 for-loop Syntax for (initialization; test; update) { statement; statement; ... statement; } // naechste Anweisung (n.A.) § Initialisierung («Initialization») wird einmal ausgeführt. § Wiederhole diese Schritte: § Prüfe ob test wahr (true) ergibt. Wenn nicht, stop und weiter mit n.A. § Führe die Anweisung(en) (Statement(s)) aus. § Führe die Aktualisierung («Update») aus. body (Rumpf) header (Kopf) 4 Schleifenkontrolle int highTemp = 5; for (int i = -3; i <= highTemp / 2; i = i + 1) { System.out.println(i + \" C = \" + (i * 1.8 + 32) + \" F\"); } Output: -3 C = 26.6 F -2 C = 28.4 F -1 C = 30.2 F 0 C = 32.0 F 1 C = 33.8 F 2 C = 35.6 F 5 Hochzählen, herunterzählen § Die Aktualisierung («update») kann auch den Schleifenzähler herunterzuzählen Aber der Vergleich in test muss dann > anstatt von < verwenden System.out.print(\"T-minus \"); for (int i = 10; i >= 1; i = i-1) { System.out.print(i + \" \"); } System.out.println(\"blastoff!\"); System.out.println(\"The end.\"); Output: T-minus 10 9 8 7 6 5 4 3 2 1 blastoff! The end. 7 2.5.2 Verschachtelte for-Schleifen 9 for-Schleife for (initialization; test; update) { statement; statement; ... statement; } statement (Anweisung im Rumpf der Schleife) kann beliebige Java Anweisung sein Auch wieder eine Schleife …. body (Rumpf) header (Kopf) 1013 Verschachtelte Schleifen Was gibt dieses Programmsegment aus? for (int i = 1; i <= 5; i = i+1) { for (int j = 1; j <= i; j = j+1) { System.out.print(\"*\"); } System.out.println(); } § Output: * ** *** **** ***** 15 Verschachtelte Schleifen Was gibt dieses Programmsegment aus? for (int i = 1; i <= 5; i = i+1) { for (int j = 1; j <= i; j = j+1) { System.out.print(i); } System.out.println(); } § Output: 1 22 333 4444 5555518 Mögliche Fehler § Die Schleife terminiert nicht § Läuft und läuft und läuft § Endlosschleife («infinite loop») 19 Mögliche Fehler § Die Schleife terminiert nicht § Läuft und läuft und läuft § Endlosschleife («infinite loop») § Beispiele: for (int i = 1; i <= 5; i = i+1) { for (int j = 1; i <= 10; j = j+1) { System.out.print(\"*\"); } System.out.println(); } 21 Mögliche Fehler § Die Schleife terminiert nicht § Läuft und läuft und läuft § Endlosschleife («infinite loop») § Beispiele: for (int i = 1; i <= 5; i = i+1) { for (int j = 1; j <= 10; i = i+1) { System.out.print(\"*\"); } System.out.println(); } 22 Was tun? § Eclipse kann solche Programme stoppen. § Klicken auf «Terminate» 23 Mehr Beispiele § Welche verschachtelten for-Schleifen erzeugen diesen Output? ....1 ...2 ..3 .4 5 24 Mehr Beispiele § Welche verschachtelten for-Schleifen erzeugen diesen Output? ....1 ...2 ..3 .4 5 § Wir müssen eine Ausgabezeile konstruieren: § mit einer äusseren Schleife für jede Zeile § mit innerer(n) Schleife(n) für das Muster jeder Zeile äussere Schleife (5-mal da es 5 Zeilen gibt) innere Schleife (für jede Zeile) 25 Äussere und innere Schleife § Legen Sie erst die äussere Schleife fest, zählt von 1 bis zur Anzahl der Zeilen for (int line = 1; line <= 5; line = line+1) { ... } § Analysieren Sie jede Zeile. Entdecken Sie das Muster: ein paar Punkte (0 Punkte in der letzten Zeile) gefolgt von Zahl ....1 ...2 ..3 .4 5 26 Äussere und innere Schleife § Legen Sie erst die äussere Schleife fest, zählt von 1 bis zur Anzahl der Zeilen for (int line = 1; line <= 5; line = line+1) { ... } § Analysieren Sie jede Zeile. Entdecken Sie das Muster: ein paar Punkte (0 Punkte in der letzten Zeile) gefolgt von Zahl ....1 ...2 ..3 .4 5 Beobachtung: Die Anzahl der Punkte hängt von der Zeilennummer ab. 27 Zahlenfolgen à Schleifen for (int count = 1; count <= 5; count = count+1) { System.out.print( ... ); } Welche Anweisung im Rumpf würde diesen Output ergeben: 4 7 10 13 16 for (int count = 1; count <= 5; count = count+1) { System.out.print(3 * count + 1 + \" \"); } 28 Zahlenfolgen à Schleifen mit Tabellen § Welche Anweisung im Rumpf würde diesen Output ergeben: 2 7 12 17 22 § Zum Finden des Musters erstellen Sie eine Tabelle mit count und den Zahlen. § Wenn sich count um 1 erhöht, sollte die Zahl um 5 heraufgehen. § Aber count * 5 ist zu gross (um 3), also subtrahieren wir 3. count Zahl in Folge 5 * count 1 2 5 2 7 10 3 12 15 4 17 20 5 22 25 5 * count - 3 2 7 12 17 22 29 count Zahl in Folge 1 2 2 7 3 12 4 17 5 22 Weiteres Tabellen Beispiel § Welche Anweisung im Rumpf würde diesen Output ergeben: 17 13 9 5 1 § Konstruieren wir die Tabelle. § Wenn sich count um 1 erhöht, sollte die Zahl ... § Aber dieses Produkt ist zu ... count Zahl in Folge 1 17 2 13 3 9 4 5 5 1 -4 * count -4 * count + 21 -4 17 -8 13 -12 9 -16 5 -20 1 -4 * count -4 -8 -12 -16 -20 30 Zurück zum Beispiel mit for Schleife § Konstruieren wir eine Tabelle ....1 ...2 ..3 .4 5 § Um einen Buchstaben mehrfach zu drucken verwenden wir eine for-Schleife. for (int j = 1; j <= 4; j = j+1) { System.out.print(\".\"); // 4 Punkte } line # Punkte 1 4 2 3 3 2 4 1 5 0 -1 * line -1 -2 -3 -4 -5 -1 * line + 5 4 3 2 1 0 31 Lösung mit for-Schleife § Antwort: for (int line = 1; line <= 5; line = line+1) { for (int j = 1; j <= (-1 * line + 5); j = j+1) { System.out.print(\".\"); } System.out.println(line); } § Output: ....1 ...2 ..3 .4 5 32 Verschachtelte for-Schleifen § Was ist der Output dieser verschachtelten Schleifen? for (int line = 1; line <= 5; line = line+1) { for (int j = 1; j <= (-1 * line + 5); j = j+1) { System.out.print(\".\"); } for (int k = 1; k <= line; k = k+1) { System.out.print(line); } System.out.println(); } 33 Verschachtelte for-Schleifen § Was ist der Output dieser verschachtelten Schleifen? for (int line = 1; line <= 5; line = line+1) { for (int j = 1; j <= (-1 * line + 5); j = j+1) { System.out.print(\".\"); } for (int k = 1; k <= line; k = k+1) { System.out.print(line); } System.out.println(); } § Answer: ....1 ...22 ..333 .4444 55555 34 Verschachtelte for-Schleifen Übung § Verändern Sie das letzte Programm so dass dieser Output erzeugt wird: ....1 ...2. ..3.. .4... 5.... 35 Verschachtelte for Schleifen Übung Verändern Sie das letzte Programm so dass dieser Output erzeugt wird: ....1 ...2. ..3.. .4... 5.... (Eine) Antwort: for (int line = 1; line <= 5; line=line+1) { for (int j = 1; j <= (-1 * line + 5); j=j+1) { System.out.print(\".\"); } System.out.print(line); for (int j = 1; j <= (line - 1); j=j+1) { System.out.print(\".\"); } System.out.println(); } 36 Übersicht § 2.5 Schleifen (Loops) § 2.5.1 «for» Loops § 2.5.2 Verschachtelte Schleifen § 2.5.3 «while» Loops § 2.6 Methoden § 2.7 Nochmals Schleifen 37 2.5.3 while-SchleifenKlassifizierung von Schleifen § Bestimmte Schleife («definite loop»): Anzahl der Ausführungen des Rumpfes («Iterationen») ist vor Beginn der Ausführung der Schleife bekannt. § Die for-Schleifen waren bisher immer bestimmte Schleifen. § Drucke \"hello\" 10-mal. § Finden Sie alle Primzahlen < einer ganzen Zahl n. § Drucken Sie jede ungerade Zahl zwischen 7 und 91. § Unbestimmte Schleife («indefinite loop»): Anzahl der Iterationen ist nicht vorher bekannt. Beispiele von unbestimmten Schleifen § Unbestimmte Schleife («indefinite loop»): Anzahl der Iterationen ist nicht vorher bekannt. § Beispiele: § Lesen Sie den Input von der Konsole bis der Benutzer eine nicht- negative ganze Zahl eingeben hat. § Wiederholen Sie bis der Benutzer ein «q» eingegeben hat. § Lesen Sie eine Datei bis drei aufeinanderfolgende Sätze mit einem «!» enden. § Nehmen Sie Beiträge (via crowdfunding) entgegen bis das Ziel erreicht ist. Die «while»-Schleife § while-Schleife führt Schleifenrumpf so lange aus wie der boolesche Ausdruck test den Wert true ergibt while (test) { statement(s); } § Beispiel: int num = 1; // initialization while (num*num <= 2000) { // test System.out.print(num + \" \"); num = num * 2; // update } // output: 1 2 4 8 16 32 Die «while»-Schleife § while-Schleife führt Schleifenrumpf so lange aus wie der boolesche Ausdruck test den Wert true ergibt while (test) { statement(s); } § Beispiel: int num = 1; while (num*num <= 2000) { System.out.print(num + \" \"); num = num * 2; } // output: 1 2 4 8 16 32 Anweisung(en) im Loop ausführen Ist test wahr? Anweisung nach Loop ausführen janein Beispiel «while»-Schleife // finds the first factor of 91, other than 1 int n = 91; int factor = 2; while (n % factor != 0) { factor++; } System.out.println(\"First factor is \" + factor); // output: First factor is 7 § while ist hier bessser als for weil wir nicht wissen wie oft wir den Zähler erhöhen müssen um den 1. Faktor zu finden Übersicht § 2.6 Methoden, Teil 2 § 2.6.1 Methoden mit Parametern § 2.6.2 Rückgabewerte § 2.6.3 Namensräume § 2.7 Strings § 2.8 Nochmals Schleifen 48 2.6.1 Methoden mit Parametern 50 Zurück zu unserem einfachen Beispiel § Jede/r soll die Aufgaben machen (können): public class Beispiel { public static void main(String[] args) { vorsatz(); } // end main public static void vorsatz() { for (int i = 1; i <= 5; i = i+1) { System.out.println( \"Ich werde die Uebungsaufgaben machen\"); } } // end vorsatz } 52 Mit Methoden vorsatz5, vorsatz10, vorsatz15 public static void vorsatz5() { for (int i = 1; i <= 5; i = i+1) { ... } } // end vorsatz5 public static void vorsatz10() { for (int i = 1; i <= 10; i = i+1) { ... } } // end vorsatz10 public static void vorsatz15() { for (int i = 1; i <= 15; i = i+1) { ... } } // end vorsatz15 53 Noch mehr Vorsätze … § Diese «Lösung» lässt nur eine vorgebene Anzahl von Wiederholungen zu … § Was wenn wir auch andere Kombinationen wollen? § OK, kein echtes Thema aber es geht uns ja um das Prinzip § Wir brauchen einen Weg, die Anzahl Wiederholungen der Situation anzupassen § Parametrisierung: mit (veränderbaren) Parametern versehen 5457 Parametrisierung § Parameter: Ein Wert den eine aufgerufene Methode von der aufrufenden Methode erhält. § Statt vorsatz5, vorsatz10, vorsatz15 entwicklen wir eine Methode flexVorsatz so dass verschiedene Wiederholungen gewählt werden können. § Wenn wir eine Methode deklarieren dann geben wir an, dass diese Methode einen Parameter braucht. § Wenn wir die Method aufrufen, dann geben wir einen Wert für den Parameter an. 59 Parametrisierung main flexVorsatz 5 flexVorsatz10 Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen 60 flexVorsatz 2 Ich werde die Hausaufgaben machen Ich werde die Hausaufgaben machen Parameterdeklarationen Gibt an dass eine Methode einen Parameter braucht um ausgeführt werden zu können public static void methodName ( type name ) { statement; } name: «Parameter Variable» 62 Parameterdeklarationen Gibt an dass eine Methode einen Parameter braucht um ausgeführt werden zu können public static void methodName ( type name ) { statement; } § Beispiel: public static void echoPin(int code) { System.out.println(\"Die Geheimnummer ist: \" + code); } 63 Parameterdeklarationen Gibt an dass eine Methode einen Parameter braucht um ausgeführt werden zu können public static void methodName ( type name ) { statement; } § Beispiel: public static void echoPin(int code) { System.out.println(\"Die Geheimnummer ist: \" + code); } Wenn echoPin aufgerufen wird dann muss der Aufrufer einen int Wert angeben. 64 Wert(e) für Parameter Beim Aufruf der Methode muss ein Wert für den Parameter angegeben werden. name (expression); § Beispiel: public static void main(String[] args) { echoPin(42); echoPin(12345); } § Output Die Geheimnummer ist: 42 Die Geheimnummer ist: 12345 65 Wie werden Parameter übergeben? § Übergeben: vom Aufrufer zur aufgerufenen Methode § Wenn eine Methode aufgerufen wird dann: § Der Wert wird in der Parameter Variable gespeichert § Die Anweisungen der Methode werden ausgeführt (mit diesem Wert für die Parameter Variable). 66 Methode mit Parameter§ Zurück zum Beispiel: class Beispiel { public static void main (String[] args) { flexVorsatz(1000); } // end main public static void flexVorsatz(int wieoft) { for (int i = 1; i <= wieoft; i = i+1) { System.out.println(\"Ich werde die Hausaufgaben machen\"); } } // end flexVorsatz } 68 Parameter § Ein Parameter in der Deklaration einer Methode heisst formaler Parameter («formal parameter»). § Formal parameter: definiert § Der übergebene Wert heisst tatsächlicher Parameter («actual parameter») oder Argument («argument») § Aktuell: augenblicklich, derzeitig [Duden] § Aktueller Wert 69 Parameter Variable Die Parameter Variable kann in der Methode wie jede Variable verwendet werden (z.B. Anzahl der Iterationen einer Schleife kontrollieren) public static void main(String[] args) { printPunkt(3); } public static void printPunkt(int times) { for (int i = 1; i <= times; i = i+1) { System.out.print(\".\"); } System.out.println(); } Output: ... 70 Wie werden Parameter übergeben? public static void main(String[] args) { printPunkt(3); printPunkt(7); } public static void printPunkt(int times) { for (int i = 1; i <= times; i = i+1) { System.out.print(\".\"); } System.out.println(); } 37 Output: ... ....... 73 Mögliche Fehler § Wenn eine Methode einen Parameter erwartet dann muss dieser auch übergeben werden. printPunkt(); // ERROR: parameter value required § Der Wert muss den richtigen Typ hben printPunkt(3.7); // ERROR: must be of type int § Die Regeln für Umwandlungen gelten auch hier 74 Mehrere Parameter § Eine Methode kann mehrere Parameter erwarten (getrennt durch Komma («,») in Deklaration und im Aufruf) § Wenn die Methode aufgerufen wird muss ein Wert für jeden Parameter angegeben werden § Deklaration: public static void method(type name, ..., type name) { statement; } § Aufruf: method (value, value, ..., value); 75 Mehrere Parameter § Eine Methode kann mehrere Parameter erwarten (getrennt durch Komma («,») in Deklaration und im Aufruf) § Wenn die Methode aufgerufen wird muss ein Wert für jeden Parameter angegeben werden § Deklaration: public static void method(type1 name1, ..., typeN nameN) { statement; } § Aufruf: method (value1, value2, ..., valueN); 76 Beispiel mit mehreren Parametern public static void main (String[] args) { Scanner console = new Scanner(System.in); System.out.print(\"Input lower bound: \"); int low = console.nextInt(); System.out.print(\"Input upper bound: \"); int up = console.nextInt(); printOdd(low, up); printOdd(-up, -low); } public static void printOdd(int from, int to) { for (int i=from; i<=to; i = i+1) { if (i%2==1) { System.out.println(i); } } } 77 Wie werden Parameter übergeben? § Wenn eine Methode aufgerufen wird: § Wert für Parameter wird von Aufrufer berechnet und übergeben § Wert wird von aufgerufener Methode in der Parameter Variable gespeichert § Die Anweisungen der aufgerufenen Methode werden ausgeführt (anfangs mit diesem Wert für die Parameter Variable). § Der Wert, den der Aufrufer übergibt, kann durch einen Ausdruck (Expression) gegeben sein § Der Wert des Expressions wird berechnet und übergeben § Die aufgerufene Methode erhält den Wert und hat keine Kenntnis davon wie der Wert berechnet wurde 79 Wie werden Parameter übergeben? § Wenn eine Methode aufgerufen wird: § Wert für Parameter wird von Aufrufer berechnet und übergeben § Wert wird von aufgerufener Methode in der Parameter Variable gespeichert § Die Anweisungen der aufgerufenen Methode werden ausgeführt (anfangs mit diesem Wert für die Parameter Variable). § Der Wert, den der Aufrufer übergibt, kann durch eine Variable gegeben sein § Der Wert der Variable wird übergeben § Die aufgerufene Methode erhält den Wert und hat keine Kenntnis davon wo der Wert herkam 80 Übergabe von Werten («Value semantics») § Wenn ein (aktueller) Parameter eines Basistyps (z.B. int, double, boolean) übergeben wird, dann wird der Wert vom Aufrufer kopiert («value semantics») Wenn der aktuelle Parameter durch einen Ausdruck bestimmt wird, dann wird der Ausdrucks evaluiert und das Ergebnis kopiert. § Der kopierte Wert initialisiert die Parameter Variable in der aufgerufenen Methode 82 Übergabe von Werten («Value semantics») public static void main(String[] args) { int k = 3; printPunkt(k); printPunkt(k+4); } public static void printPunkt(int times) { for (int i = 1; i <= times; i = i+1) { System.out.print(“.\"); } System.out.println(); } 37 Output: ... ....... 83 Übergabe von Werten («Value semantics») § Wenn ein (aktueller) Parameter eines Basistyps (z.B. int, double, boolean) übergeben wird, dann wird der Wert vom Aufrufer kopiert («value semantics») § Veränderungen der Parameter Variable (des formalen Parameters) in der aufgerufenen Methode haben keine Auswirkung auf die aufrufende Methode 85 Übergabe von Werten («Value semantics») public static void strange(int x) { x = x + 1; System.out.println(\"1. x = \" + x); } public static void main(String[] args) { int x = 23; strange(x); System.out.println(\"2. x = \" + x); ... } Output: 1. x = 24 2. x = 23 8689 Übergabe von Werten («Value semantics») § Wenn ein (aktueller) Parameter durch eine Variable V eines Basistyps (int, double, boolean) bestimmt wird dann wird der Wert dieser Variable kopiert («value semantics»): § Name eines aktuellen Parameters (wenn eine Variable verwendet wird) ist unwichtig. 90 \"Parameter Übergabe\" Problem public class ParameterMystery { public static void main(String[] args) { int x = 9; int y = 2; int z = 5; mystery(z, y, x); mystery(y, x, z); } public static void mystery(int x, int z, int y) { System.out.println(z + \" and \" + (y - x)); } } 91 \"Parameter Übergabe\" Problem public class ParameterMystery { public static void main(String[] args) { int x = 9; int y = 2; int z = 5; mystery(z, y, x); mystery(y, x, z); } public static void mystery(int x, int z, int y) { System.out.println(z + \" and \" + (y - x)); } } x y z 9 2 5 5 2 9 5 2 9 Output: 2 and 4 x yz 93 \"Parameter Übergabe\" Problem public class ParameterMystery { public static void main(String[] args) { int x = 9; int y = 2; int z = 5; mystery(z, y, x); mystery(y, x, z); } public static void mystery(int x, int z, int y) { System.out.println(z + \" and \" + (y - x)); } } 2 9 5 2 9 5 Output: 9 and 3 x yz 94 x y z 9 2 5 Output: 2 and 4 9 and 3 96 2.6.2 Ergebnis Rückgabe für Methoden 97 import java.util.*; class PrintPrimes1 { public static void main (String[] args) { Scanner console = new Scanner(System.in); System.out.print(\"Input max: \"); int max = console.nextInt(); if (max >= 2) { printPrimes(max); } } public static void printPrimes(int limit) // Prints all prime numbers up to limit, limit >= 2 System.out.print(\"2\"); for (int i = 3; i <= limit; i++) { if ( /* isPrime(i) */ ) { System.out.print(\", \" + i); } } System.out.println(); // to end output } } 98 Ergebnis Rückgabe § Parameter erlauben Kommunikation vom Aufrufer zur aufgerufenen Methode § Bisher waren die Methoden sehr einfach § Methode als «Ersatz» für Anweisungen in main (oder anderer Methode) § Methoden können aber mehr … § Ein Rückgabewert («return value») erlaubt der aufgerufenen Methode dem Aufrufer einen Wert zu übermitteln § Damit eröffnen sich neue Möglichkeiten der Komposition 99101 { … name ( 7+i, true); … } public static name(int k, boolean b) { int result; while (k < 10) { k=k+1; … } if (b) { … } // result } 102 { … name ( 7+i, true); … } public static name(int k, boolean b) { int result; while (k < 10) { k=k+1; … } if (b) { … } // result } 103 { … name ( 7+i, true); … } public static name(int k, boolean b) { int result; while (k < 10) { k=k+1; … } if (b) { … } // result } Rückgabe eines Wertes § Ein Rückgabewert muss deklariert werden public static type name(parameters) { statements; ... return expression; } § Es gelten die selben Regeln für type wie bei der Deklaration von Variablen und Parametern § Keyword void bedeutet: kein Rückgabewert 104 Rückgabeanweisung § Das return-Statement («Rückgabe Anweisung») wertet einen Ausdruck aus § Der Wert wird dann an den Aufrufer «zurückgegeben» § Der Ausdruck muss einen Wert des Typs type (der Methoden Deklaration) ergeben. § Die Ausführung der return-Anweisung beendet die aufgerufene Methode. 107 Rückgabeanweisung (return-Statement) § return: Liefere einen Wert ab als das Ergebnis dieser Methode § «sende» das Ergebnis zum Aufrufer § Das Gegenstück zu Parametern: § Parameters schicken Werte in die aufgerufene Methode, vom Aufrufer § Rückgabewerte schicken Werte aus der Methode zum Aufrufer § Ein Methodenaufruf kann Teil eines Ausdrucks sein. § Aufrufer muss den Wert «annehmen» 108109 { … int size = name ( 7+i, true); … } public static int name(int k, boolean b) { int result; while (k < 10) { k=k+1; … } if (b) { … } return result; } Rückgabeanweisung («return») main abs(-42)-42 round(2.71) 2.71 42 3 abs(-81) -81 81 110 Beispiellösung mit Rückgabe eines Wertes public static boolean isPrime (int arg){ // Determine how many factors the given number has. boolean found = false; int step = 2; while (!found) { if (arg % step == 0) { found = true; // factor found } else { step++ ; // keep on searching } } // factor == arg: prime found return (step == arg); } 111 Rückgabe eines Wertes Beispiel: // Returns the slope of the line between the given points. public static double slope(int x1, int y1, int x2, int y2) { double dy = y2 - y1; double dx = x2 - x1; return dy / dx; } slope(1, 3, 5, 11) liefert 2.0 112 return ohne einen Wert § Wenn eine Methode keinen Wert zurück liefert dann braucht ein return-Statement keinen Wert zu schicken. public static void printPoint(int x, int y) { System.out.println(“x = “ + x + “ y = “ + y) ; return; } § In dem Fall kann man das return-Statement auch weglassen (meine Empfehlung) 113 Weitere Beispiele // Converts degrees Fahrenheit to Celsius. public static double fToC(double degreesF) { double degreesC = 5.0 / 9.0 * (degreesF - 32); return degreesC; } // Computes triangle hypotenuse length given its side lengths. public static double hypotenuse(int a, int b) { double c = squareRoot(a * a + b * b); return c; } 114 Weitere Beispiele Ein return-Statement kann auch einen (arithmetischen oder booleschen) Ausdruck verwenden public static double fToC(double degreesF) { return 5.0 / 9.0 * (degreesF - 32); } 115 Mögliche Fehler: Resultat nicht gespeichert § Ein return-Statement schickt einen Wert an den Aufrufer § Namen, die in der aufgerufenen Methode verwendet werden, sind belanglos (für den Aufrufer) 116 Was ist hier nicht richtig? public static void main(String[] args) { slope(0, 0, 6, 3); // Problem: return value not used/stored } public static double slope(int x1, int x2, int y1, int y2) { double dy = y2 - y1; double dx = x2 - x1; double result = dy / dx; return result; } 117 Was ist hier nicht richtig? public static void main(String[] args) { slope(0, 0, 6, 3); System.out.println(\"The slope is \" + result); // ERROR: } // result not defined public static double slope(int x1, int x2, int y1, int y2) { double dy = y2 - y1; double dx = x2 - x1; double result = dy / dx; return result; } 118 Den Fehler vermeiden § return schickt den Wert der Variable zurück zum Aufrufer. § Der zurückgegebene Wert muss gespeichert werden – oder in einem Ausdruck verwendet werden. § Der Compiler generiert keine Warnung oder Fehlermeldung wenn dies vergessen wird. 119 Den Fehler vermeiden public static void main(String[] args) { double s = slope(0, 0, 6, 3); System.out.println(\"The slope is \" + s); } public static double slope(int x1, int x2, int y1, int y2) { double dy = y2 - y1; double dx = x2 - x1; double result = dy / dx; return result; } 120 return-Anweisungen § Eine Methode kann mehrere return-Anweisungen enthalten. § Sinnvoll für Fallunterscheidungen § Eine Methode die einen Rückgabewert deklariert muss eine (oder mehrere) return-Anweisung(en) enthalten 121 if/else mit return // Returns the larger of the two given integers. public static int max(int a, int b) { if (a > b) { return a; } else { return b; } } § Methoden können ein return-Statement in durch if/else kontrollierten Blöcken enthalten § Das return-Statement am Ende eines Pfades liefert den Rückgabewert für diese Methode. 122 if/else mit return § Die Ausführung eines return-Statements beendet die aufgerufene Methode. § Einem return sollten keine weiteren Anweisungen folgen § Alle Pfade durch eine Methode müssen ein return- Statement enthalten § Wenn die Methode einen Rückgabewert deklariert hat 123 Alle Pfade … public static int max(int a, int b) { if (a > b) { return a; } // Error: not all paths return a value } § Der Compiler ist manchmal naiv: public static int max(int a, int b) { if (a > b) { return a; } else if (b >= a) { return b; } } Der Compiler meint dass es einen Pfad ohne return gibt. 124 So versteht Java das Programm int foo(int a) { if (a > 0) { return a; } else { if (a <= 0) { return -a; } } } 125 \"if\" ausführen: return a Ist a>0 wahr? Keine weiteren Anweisungen janein \"else\" ausführen: ausführen: return -a Ist a<=0 wahr? Keine weiteren Anweisungen janein So versteht Java das Programm int foo(int a) { if (a > 0) { return a; } else { if (a <= 0) { return -a; } } } 126 \"if\" ausführen: return a Ist a>0 wahr? Keine weiteren Anweisungen janein \"else\" ausführen: ausführen: return -a Ist a<=0 wahr? Keine weiteren Anweisungen janein Jeder Pfad ist möglich: Daher Fehlermeldung if/else, return Beispiel § Schreiben Sie eine Methode quadrant die für ein Paar von reellen Zahlen den Quadranten liefert in dem dieser Punkt liegt. § Beispiel: quadrant(-4.2, 17.3) liefert 2 § Fällt der Punkt auf eine der Achsen des Koordinatensystems liefere 0. x+x- y+ y- quadrant 1quadrant 2 quadrant 3 quadrant 4 129 if/else, return Beispiel public static int quadrant(double x, double y) { } 132 if/else, return Beispiellösung public static int quadrant(double x, double y) { if (x > 0 && y > 0) { return 1; } else if (x < 0 && y > 0) { return 2; } else if (x < 0 && y < 0) { return 3; } else if (x > 0 && y < 0) { return 4; } else { // at least one coordinate equals 0 return 0; } } 133 if/else, return Beispiellösung public static int quadrant(double x, double y) { if (x > 0.0 && y > 0.0) { return 1; } else if (x < 0.0 && y > 0.0) { return 2; } else if (x < 0.0 && y < 0.0) { return 3; } else if (x > 0.0 && y < 0.0) { return 4; } else { // at least one coordinate equals 0 return 0; } } 134 if/else, return weitere Beispiele § Schreiben Sie eine Methode countFactors die die Anzahl der Faktoren (Teiler) einer Zahl liefert. § countFactors(24) liefert 8 da 1, 2, 3, 4, 6, 8, 12, und 24 alle Teiler von 24 sind. 135 if/else, return weitere Beispiele § Lösung: // Returns how many factors the given number has. public static int countFactors(int number) { int count = 0; for (int i = 1; i <= number; i++) { if (number % i == 0) { count++; // i is a factor of number } } return count; } 136 2.6.3 Sichtbarkeit von Variablennamen § Namesräume § «Scope»: Bereich in dem ein Name sichtbar ist § Dann kann die Variable gelesen/modifiziert werden § Dann kann eine Methode aufgerufen werden (später) § 1. Approximation für das Innenleben von Methoden § Weitere Aspekte in späteren Vorlesungen 140 Scope (Sichtbarkeitsbereich) scope: Der Teil eines Programm in dem eine Variable sichtbar ist. § Variable müssen deklariert sein bevor sie sichtbar sind § Deklarationen müssen eindeutig sein § Sichtbar von Deklaration bis zum Ende des Blocks für den die Variable deklariert ist 141 Scope (Sichtbarkeitsbereich) scope: Der Teil eines Programm in dem eine Variable sichtbar ist. § Variable müssen deklariert sein bevor sie sichtbar sind § Deklarationen müssen eindeutig sein § Sichtbar von Deklaration bis zum Ende des Blocks für den die Variable deklariert ist Block: durch { und } begrenzt 142 { und } strukturieren ein Programm public static void fct(int j) { int i; int k; } 143 i sichtbar k sichtbar j sichtbar { und } strukturieren ein Programm if (...) { int i; } else { } ... 144 i sichtbar { und } strukturieren ein Programm for (int i = 0; ...; ...) { } ... for (int i = 1; ...; ...) { } ... 145 i sichtbar (anderes) i sichtbar Scope (Sichtbarkeitsbereich) scope: Der Teil eines Programm in dem eine Variable sichtbar ist § Variable müssen deklariert sein bevor sie sichtbar sind § Deklarationen müssen eindeutig sein § Sichtbar von Deklaration bis zum Ende des Blocks (der durch { und } angegeben wird) § Eine Variable die in einer for-Schleife deklariert wurde kann nur im Rumpf der Schleife verwendet werden. § Eine Variable die in einer Methode deklariert wurde existiert nur in der Methode. 147 Blöcke können geschachtelt sein § Loops in Methoden § Loops in Loops -- geschachtelte Schleifen («nested loops») § (Java: Methoden können nicht in anderen Methoden geschachtelt sein.) 148 Scope (Sichtbarkeitsbereich) public static void example() { int x = 3; for (int i = 1; i <= 10; i++) { System.out.println(x+i); } // i no longer exists here System.out.println(x); } // x ceases to exist here 149 x's scopei'sscope Scope (Sichtbarkeitsbereich) public static void example(int x) { for (int i = 1; i <= 10; i++) { for (int j = i; j<=10; j++) { System.out.print(x + i + j + \" \"); } // j no longer exists here System.out.println(i); } // i no longer exists here System.out.println(x); } // x no longer exists here 150 Folgen der Sichtbarkeitsregeln § Variable ohne überlappenden Sichtbarkeitsbereich können den selben Namen haben. for (int i = 1; i <= 100; i++) { System.out.print(\"/\"); } for (int i = 1; i <= 100; i++) { // OK System.out.print(\"\\\\\"); } int i = 5; // OK: outside of loop's scope 151 252-0027 Einführung in die Programmierung 2.0 Einfache Java Programme Thomas R. Gross Department Informatik ETH Zürich 1 Übersicht § 2.6 Methoden, Teil 2 § 2.6.1 Methoden mit Parametern § 2.6.2 Rückgabewerte § 2.6.3 Namensräume § 2.7 Strings § 2.8 Nochmals Schleifen 2 Scope (Sichtbarkeitsbereich) scope: Teil eines Programm in dem eine Variable sichtbar ist. § Variable müssen deklariert sein bevor sie sichtbar sind § Deklarationen müssen eindeutig sein § Sichtbar von Deklaration bis zum Ende des Blocks für den die Variable deklariert ist § Block: durch { und } begrenzt § Inklusive aller eingeschlossenen Blöcke § Eine in der for—Schleife deklararierte Variable gehört zum Rumpf («body») der Schleife § (Formale) Parameter gehören zum Rumpf («body») der Methode 3 Scope (Sichtbarkeitsbereich) public static void example(int x) { for (int i = 1; i <= 10; i++) { for (int j = i; j<=10; j++) { System.out.print(x + i + j + \" \"); } // j no longer exists here System.out.println(i); if (i%2==0) { int j = 4; System.out.print(i*j + \" \"); } // j no longer exists here } // i no longer exists here System.out.println(x); } // x no longer exists here 4 Folgen der Sichtbarkeitsregeln § Variable ohne überlappenden Sichtbarkeitsbereich können den selben Namen haben. for (int i = 1; i <= 100; i++) { System.out.print(\"/\"); } for (int i = 1; i <= 100; i++) { // OK System.out.print(\"\\\\\"); } int i = 5; // OK: outside of loop's scope 5 Folgen der Sichtbarkeitsregeln § Eine Variable kann in einem Sichtbarkeitsbereich nur einmal deklariert werden. for (int i = 1; i <= 100 * line; i++) { int i = 2; // ERROR: overlapping scope System.out.print(\"/\"); } i = 4; // ERROR: outside scope § Eine Variable kann nicht ausserhalb ihres Sichtbarkeitsbe- reiches verwendet werden 6 Folgen der Sichtbarkeitsregeln § Eine Variable kann in einem Sichtbarkeitsbereich nicht mehrmals deklariert werden. for (int i = 1; i <= 100 * line; i++) { for (int i = 2; i < line; i++) { // ERROR: overlapping scope // variable i is already defined in method … System.out.print(\"/\"); } } 7 Warum diese Regeln § Lesbarkeit der Programme § Vereinfachung der Verwaltung des Speichers § Platz für eine Variable eines Basistypes muss nur in dem Block organisiert werden, in dem die Variable deklariert ist § Werte (die in einer Variable eines Basistypes) gespeichert werden verschwinden am Ende des Blockes 8 Übersicht § 2.7 Strings § 2.X Input § 2.8 Nochmals Schleifen 9 2.7 Strings 10 Strings § String: Eine Folge von Buchstaben/Zeichen § Java Typ String definiert in Standard Bibliothek § String Variable definiert wie alle anderen Variablen String name ; § Initialisierung durch String Literal § Folge zwischen \" und \" ohne Zeilenende, ggf. mit Ersatzdarstellungen String name = \"Here \"; oder Textblock String name = \"\"\" Here we go\"\"\"; 11 3 x \" 3 x \" Ende der Zeile Leerzeichen ignoriert! Strings § String: Eine Folge von Buchstaben/Zeichen § Java Typ String definiert in Standard Bibliothek § String Variable definiert wie alle anderen Variablen String name ; § Initialisierung durch String Literal § Folge zwischen \" und \" ohne Zeilenende, ggf. mit Ersatzdarstellungen String name = \"Here \"; oder Textblock String name = \"\"\" Here we go\"\"\"; System.out.println(name); 12 String Literals § String Literal: String im Programmtext String text = name + \" \" + name; § + verbindet Strings (Literals und Variable) § Examples: String firstName = \"Robin\"; String lastName = \"Williams\"; String mrsDoubtfire = firstName + \" \" + lastName; 13 Strings § + erzwingt Konversion von anderen Typen (zu String) int x = 3; String point = \"(\" + x + \", \" + 5 + \")\"; § Konversion von anderen Typen (z.B. int) zu String String s = \"\" + x; § \"\" ist !, der leere String 14 String als Parameter public class StringParameters { public static void main(String[] args) { sayHello(\"Mark\"); String friend = \"Peter\"; sayHello(friend); } public static void sayHello(String name) { System.out.println(\"Welcome, \" + name); } } String als Parameter public class StringParameters { public static void main(String[] args) { sayHello(\"Mark\"); String friend = \"Peter\"; sayHello(friend); } public static void sayHello(String name) { System.out.println(\"Welcome, \" + name); } } Output: Welcome, Mark Welcome, Peter Strings § Weil Strings wichtig sind werden sie vom Compiler besonders behandelt § Wir hatten schon bei int und double gesehen dass praktische Überlegungen die Programmiersprache zwingen, Details in der Programmierung zu erwarten § Strings erfahren eine Sonderbehandlung § Standard Bibliothek enthält viele Methoden um Strings zu bearbeiten § Immer vorhanden, ohne import java.util.*; 18 Strings § Strings sind Objekte – Methoden mit «dot» Notation § Beispiele: toUpperCase(), toLowerCase(), ... § Können für jeden String seine Länge (Anzahl Zeichen) herausfinden § String str = \"Hello\"; § System.out.println(\"Laenge: \" + str.length() ); § Strings erlauben Zugriff auf die Buchstaben die den Text ausmachen. 19 Output: Laenge: 5 Teile eines Strings § Auf Teile eines Strings wird mit einem Index zugegriffen § Basis 0 String name = \"B. Dylan\"; § Index des ersten Buchstabens: 0 § Index des letzten Buchstabens: 1 weniger als die Länge des Strings § name.length() == 8 § Strings sind keine Arrays! § Arrays werden in Teil 3 behandelt (Fragen bitte zurückhalten) index 0 1 2 3 4 5 6 7 Zeichen B . D y l a n 20 Strings § Zugriff auf Elemente eines Strings erfolgt mit (vordefinierten) Methoden § Aufruf dieser Methoden in Punktnotation (Dot Notation) («dot notation») String s = \"hello\"; s.method(parameterValues); § Führe Methode method für s aus, «wende method auf s an», «rufe method für s auf» § Ergebnis kann sein String, int, boolean oder ein Zeichen (Buchstabe) 21 String Methoden die String liefern § «white space» -- Leerzeichen (blank, space), Tabulatorzeichen, LineFeed/CarriageReturn/Return/Enter/Zeilenumbruch … Method name Description substring(index1, index2) or substring(index1) the characters in this string from index1 (inclusive) to index2 (exclusive); if index2 is omitted, grabs till end of string toLowerCase() a new string with all lowercase letters toUpperCase() a new string with all uppercase letters stripLeading() a new string whose value is this string, with all leading white space removed. stripTrailing() a new string whose value is this string, with all trailing white space removed. 22 String Methoden die String liefern § Beispiel String writer = \"S. Beckett\"; //Laenge: 10 System.out.println(writer.substring(8)); // tt System.out.println(writer.substring(0,1)); // S System.out.println(writer.substring(3,7)); // Beck String w = writer.substring(1,2); // wie w = \".\" Method name Description substring(index1, index2) or substring(index1) the characters in this string from index1 (inclusive) to index2 (exclusive); if index2 is omitted, grabs till end of string 23 index 0 1 2 3 4 5 6 7 8 9 Zeichen S . B e c k e t t String Methoden die int liefern § Beispiel String writer = \"S. Beckett\"; //Laenge: 10 System.out.println(writer.indexOf(\"Beck\")); // 3 System.out.println(writer.indexOf(\"e\")); // 4 System.out.println(writer.indexOf(\"e\",5)); // 7 Method name Description indexOf(str) index where the start of the given string appears in this string (-1 if not found) length() number of characters in this string indexOf(str, fromIndex) index within this string of the first occurrence of the specified substring, starting at the specified index (-1 if not found) 25 index 0 1 2 3 4 5 6 7 8 9 Zeichen S . B e c k e t t String weitere Beispiele // index 0123456789012 String s1 = \"Alice Munro\"; String s2 = \"Doris Lessing\"; System.out.println(s1.length()); // 11 System.out.println(s1.indexOf(\"e\")); // 4 System.out.println(s2.substring(6, 9)); // Les String s3 = s2.substring(1, 7); System.out.println(s3.toLowerCase()); // oris l § Mit diesem String // index 012345678901234567890123456789012 String vorlesung = \"Einfuehrung in die Programmierung\"; Wie würden Sie das Wort \"die\" extrahieren ? 26 012345678911234567892123456789312 String weitere Beispiele // index 0123456789012 String s1 = \"Alice Munro\"; String s2 = \"Doris Lessing\"; System.out.println(s1.length()); // 11 System.out.println(s1.indexOf(\"e\")); // 4 System.out.println(s2.substring(6, 9)); // Les String s3 = s2.substring(1, 7); System.out.println(s3.toLowerCase()); // oris l § Mit diesem String // index 012345678901234567890123456789012 String vorlesung = \"Einfuehrung in die Programmierung\"; Wie würden Sie das Wort \"die\" extrahieren ? vorlesung.indexOf(\"die\"); // 15 vorlesung.substring(15, 18); 27 012345678911234567892123456789312 String weitere Beispiele // index 0123456789012 String s1 = \"Alice Munro\"; String s2 = \"Doris Lessing\"; System.out.println(s1.length()); // 11 System.out.println(s1.indexOf(\"e\")); // 4 System.out.println(s2.substring(6, 9)); // Les String s3 = s2.substring(1, 7); System.out.println(s3.toLowerCase()); // oris l § Mit diesem String // index 012345678901234567890123456789012 String vorlesung = \"Einfuehrung in die Programmierung\"; Wie würden Sie das Wort \"die\" extrahieren ? int loc = vorlesung.indexOf(\"die\"); // 15 vorlesung.substring(loc, loc+3); 28 012345678911234567892123456789312 § Methoden wie substring und toLowerCase konstruieren und liefern einen neuen String zurück, sie modifizieren nicht den String für den sie aufgerufen wurden. String s = \"Hello World\"; s.toUpperCase(); System.out.println(s); // Hello World § Um den Wert zu bearbeiten/speichern muss dieser wieder einer Variablen zugewiesen werden: String s = \"Hello World\"; String t = s.toUpperCase(); System.out.println(t); // HELLO WORLD String Literale 29 § Methoden wie substring und toLowerCase konstruieren und liefern einen neuen String zurück, sie modifizieren nicht den String für den sie aufgerufen wurden. String s = \"Hello World\"; s.toUpperCase(); System.out.println(s); // Hello World § Um den Wert zu bearbeiten/speichern muss dieser wieder einer Variablen zugewiesen werden: String s = \"Hello World\"; s = s.toUpperCase(); // kann selbe Variable sein System.out.println(s); // HELLO WORLD String Literale 30 String Vergleiche/Abfragen String s = \"Hello\"; String t = s.toUpperCase(); if (s.equals(t)) { System.out.println(\"Equal\")); } else {System.out.println(\"Not equal\")); } //Not equal if (\"Hello\".equals(s)) { System.out.println(\"Equal\")); } else {System.out.println(\"Not equal\")); } //Equal Method Description equals(str) ob 2 Strings die selben Buchstaben enthalten equalsIgnoreCase(str) ob 2 Strings die selben Buchstaben enthalten, ohne Berücksichtigung von Gross- und Kleinschreibung startsWith(str) ob der String mit den Buchstaben des anderen (str) anfängt endsWith(str) ob … endet contains(str) ob der String str (irgendwo) auftritt 31 Elemente eines Strings § Die einzelnen Buchstaben sind Werte des (Basistyps) char (später mehr) String name = \"B. Dylan\"; name.charAt(0) // B if (name.charAt(1) == '.') { … } // Paar single quote ' ' char c = name.charAt(7); System.out.println(name.indexOf('.')); // 1 § Verwenden Sie == nur für Basistypen (z.B. int oder char), nicht für String Variable § Später sehen wir wann wir == verwenden können index 0 1 2 3 4 5 6 7 Zeichen B . D y l a n 32 252-0027 Einführung in die Programmierung 2. X Input Thomas R. Gross Department Informatik ETH Zürich 33 Interaktive Programme mit Scanner § Einfache interaktive Programme ... § Program liest Benutzer Input § Text – Eingabe durch Tastatur § Lesen mit «Scanner» § (Oft mit) Ausgabe von Text auf Monitor/Bildschirm mit println(..) § Interaktiv: Programm kann auf Benutzer Input reagieren Einfache Eingabe (Input) § Interaktives Programm: Liest Input von der Konsole («console») oder Terminal. § Während das Programm ausgeführt wird fragt das Programm den Benutzer § Benutzer tippt Input ein § Der vom Benutzer eingegebene Input wird durch Anweisungen im Programm in Variablen gespeichert § Später auch andere Arten des Inputs (von anderen Fenstern) Konsole und System.in § Konsole («console»): früher ein Gerät, das mit Computer verbunden war § Erlaubte Eingabe (manchmal auch Ausgabe) Konsole und System.in § Konsole («console»): früher ein Gerät, das mit Computer verbunden war § Erlaubte Eingabe (manchmal auch Ausgabe) User LPfi on the Swedish Wikipedia (on Commons: LPfi) [CC BY-SA ] Konsole und System.in § Konsole («console»): früher ein Gerät das mit Computer verbunden war und Start/Management des Computers zulies § Heute: (meist) Fenster im (graphischen) Benutzerinterface § System.in (Standard Input): Ein (vordefiniertes) Fenster für Input § System.out (Standard Output): Ein (vordefiniertes) Fenster für Output. § System.in und System.out können dasselbe Fenster sein. Input und Output § Input komplizierter als Output § Benutzer können sich auf unvorgesehene Weise verhalten § Benutzer können Fehler machen § Benutzer können unpassenden Input liefern § Aber interaktive Programme sind viel interessanter ….. § Eclipse verwendet ein Fenster um System.in und System.out zu zeigen: § Output zu System.out § Keyboard Input von System.in Input für Programm § Müssen Input lesen § Umwandlung von Darstellung der Konsole/des Terminals in Format, das vom Java Programm verarbeitet werden kann § Idealerweise wird diese (Basis)Software zur Verfügung gestellt § Scanner bietet solche Services an § Es gibt auch andere Möglichkeiten aber Scanner ist (relativ) einfach und erleichtert unsere Arbeit. § Output hat das selbe Problem (Umwandlung der Darstellung) – auch dafür gibt es bereits Software (println(..)) 42 Input und System.in § Idee: Benutzer tippt Eingabe (via Tastatur) und Programm liest diese von System.in mittels eines Scanners § Scanner: erlaubt es Input von unterschiedlichen Quellen zu lesen § Kann von verschiedenen Stellen lesen § Auch von System.in § Datenquelle wird angegeben wenn Scanner konstruiert wird § Später auch von Dateien, Web Seiten, Datenbanken, … lesen Scanner Syntax § Scanner sind in der Bibliothek java.util definiert § Muss erst bekannt gegeben werden § import java.util.*; // so dass wir Scanner benutzen können § Programm braucht ein Scanner Objekt um von der Konsole zu lesen: § Dieses muss konstruiert werden § Scanner name = new Scanner(System.in); § Beispiel: Scanner myConsole = new Scanner(System.in); Scanner Syntax § Scanner sind in der Bibliothek java.util definiert § Muss erst bekannt gegeben werden § import java.util.*; // so dass wir Scanner benutzen können § Programm braucht ein Scanner Objekt um von der Konsole zu lesen: § Dieses muss konstruiert werden § Scanner name = new Scanner(System.in); § Beispiel: Scanner myConsole = new Scanner(System.in); Scanner Methoden Aufruf einer Methode braucht einen Scanner Scanner myConsole = new Scanner(System.in); und dann Aufruf in Punktnotation («dot notation»): int alter = myConsole.nextInt(); Method Description nextInt() reads an int from the user and returns it nextDouble() reads a double from the user next() reads a one-word String from the user nextLine() reads a one-line String from the user Scanner Methoden § Der eingegebene Wert kann weiter verarbeitet werden. int alter = myConsole.nextInt(); System.out.println(\"Ihre Eingabe \" + alter); § Aber wie weiss der Benutzer dass eine Eingabe erwartet wird? Method Description nextInt() reads an int from the user and returns it nextDouble() reads a double from the user next() reads a one-word String from the user nextLine() reads a one-line String from the user Scanner Eingabe § Das Programm fordert den Benutzer auf, Wert(e) einzugeben § «prompt» (Aufforderung): Text der angibt das/welche Eingabe erwartet wird § Der Prompt erscheint im Konsolenfenster § Jetzt kann die Eingabe erfolgen – erscheint auch im selben Fenster § System.in und System.out werden von Eclipse besonders behandelt § Jede Scanner Methode wartet bis der Benutzer die Eingabe mit der «ENTER» (oder «RETURN») Taste abschliesst. § Beispiel: System.out.print(\"Wie alt sind Sie? \"); // prompt int alter = myConsole.nextInt(); System.out.println(\"Ihre Eingabe \" + alter); Scanner Beispiel import java.util.*; // so dass Scanner verwendet werden kann public class UserInputExample { public static void main(String[] args) { Scanner myConsole = new Scanner(System.in); System.out.print(\"Wie alt sind Sie? \"); int alter = myConsole.nextInt(); int jahre = 65 - alter; System.out.println(jahre + \" Jahre bis zur Pensionierung!\"); } } Konsole (Eingabe des Benutzers unterstrichen): Wie alt sind Sie? 46 Jahre bis zur Pension! 19 alter 19 jahre 46 Scanner Beispiel 2 import java.util.*; public class ScannerMultiply { public static void main(String[] args) { Scanner console = new Scanner(System.in); System.out.print(\"Please type two numbers: \"); int num1 = console.nextInt(); int num2 = console.nextInt(); int product = num1 * num2; System.out.println(\"The product is \" + product); } } Output (Benutzereingabe unterstrichen): Please type two numbers: 8 6 The product is 48 § Der Scanner kann mehrere Zahlen in einer Zeile (endet mit RETURN) lesen. Wo finde ich Informationen https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html § Dort finden wir mehr Informationen § Z.Zt. noch nicht alle Konzepte erklärt § Darum «ignorieren» wir die andere Aspekte (ausser denen, die wir für das Beispiel brauchen) 545556 Eingabe Elemente § Scanner liest (für nextInt()) optionales Vorzeichen und Folge von Ziffern und wandelt diese in eine Zahl (int) um § Braucht Beschreibung von legalen ints § Z.B. EBNF Beschreibung § Muss wissen wo eine int Beschreibung aufhört (anfängt) § Beschreibung von Leerzeichen/Trennzeichen § Auch wieder mit EBNF möglich § Folge von Zeichen die der Scanner liest: Token § Input Element § Erwartete Zeichen hängen von Methode (z.B. nextDouble()) ab Eingabe Elemente § Folge von Zeichen die der Scanner liest: Token § Token werden durch Zwischenraum («whitespace») getrennt § Auf Deutsch: Leerzeichen, auf Englisch: «space», «blank» § Tabulator Zeichen («tab»), § Zeilenvorschub («new line»). § Wie viele Token sind in dieser Zeile? 23 John Smith 42.0 $2.50 Eingabe Elemente § Folge von Zeichen die der Scanner liest: Token § Token werden durch Zwischenraum («whitespace») getrennt § Auf Deutsch: Leerzeichen, auf Englisch: «space«, «blank» § Tabulator Zeichen («tab»), § Zeilenvorschub («new line»). § Wie viele Token sind in dieser Zeile? 23 John Smith 42.0 § Token kann Kontext-abhängig sein $2.50 \"hello World\" 1.456E12 \"45 18\" Eingabe Elemente Wenn das Token nicht den richtigen Typ hat gibt es (zur Laufzeit) eine Fehlermeldung. System.out.print(\"Was ist Ihr Alter? \"); int alter = myConsole.nextInt(); Output: Was ist Ihr Alter? Timmy java.util.InputMismatchException at java.util.Scanner.next(Unknown Source) at java.util.Scanner.nextInt(Unknown Source) ... Noch ein Beispiel import java.util.*; // for Scanner public class IncNumber { public static void main(String[] args) { Scanner console = new Scanner(System.in); System.out.print(\"Type a number: \"); int numberIn = console.nextInt(); System.out.println(\"Number + 1: \" + (1 + numberIn)); } } 64 § Scanner's next Methode liest ein Wort (d.h. keine Zwischenräume) als String. Scanner console = new Scanner(System.in); System.out.print(\"What is your name? \"); String name = console.next(); name = name.toUpperCase(); System.out.println(name + \" has \" + name.length() + \" letters and starts with \" + name.substring(0, 1)); § Beispiele: (Input unterstrichen) What is your name? Chamillionaire CHAMILLIONAIRE has 14 letters and starts with C What is your name? Donald Duck DONALD has 6 letters and starts with D What is your name? \"Mickey Mouse\" \"MICKEY has 7 letters and starts with \" 65 Scanner Methoden § Jede Methode wartet bis der Benutzer die Eingabe mit der \"ENTER\" (oder \"RETURN\") Taste abschliesst. § Die next() Methode liest ein Wort (d.h. keine Zwischenräume) als String § Keine Anführungszeichen (\")! Method Description nextInt() reads an int from the user and returns it nextDouble() reads a double from the user next() reads a one-word String from the user nextLine() reads a one-line String from the user 66 252-0027 Einführung in die Programmierung 2.8 Nochmals Schleifen Thomas R. Gross Department Informatik ETH Zürich 68 Übersicht § 2.8 Nochmals Schleifen § 2.8.1 Kurzformen (für Aktualisierung) § 2.8.2 Kurzformen und bedingte («short-circuit») Ausführung § 2.8.3 Terminierung von Schleifen § 2.8.4 Input Werte zur Schleifenkontrolle § 2.8.5 Invarianten 69 2.8 Nochmals Schleifen § Kurzform zur Aktualisierung des Loop Counters (Schleifenzählers) § Tipps für korrekte Terminierung der Schleifen § Hoare Tripel für Schleifen 70 2.8.1 Aktualisierung for (int i = start ; i < bound; i = i + 1) { // Statement } Aktualisierung: i wird um 1 erhöht for (int i = start ; i > bound; i = i - 1) { // Statement } Aktualisierung: i wird um 1 reduziert Auch andere Aktualisierungen sind möglich aber diese hier treten häufig auf 71 Kurzformen für Zuweisungen § Zuweisungen der Form j = j+1 tretten häufig auf § Machen Programm unübersichtlich § Früher: unnötige Extra-Arbeit für Compiler und Computer § Kurzformen erlauben Inkrement (Addition von 1) und Dekrement (Subtraktion von 1) § «increment» und «decrement» Operator § Veränderung immer um 1 72 Inkrement und Dekrement Kurzform Äquivalente ausführlichere Version variable++; variable = variable + 1; //increment variable--; variable = variable - 1; //decrement Beispiele int x = 2; x++; // x = x + 1; // x now stores 3 double note = 4.5; note--; // note = note - 1; // note now stores 3.5 73 Aktualisierung for (int i = start ; i < bound; i++) { // Statement } Aktualisierung: i wird um 1 erhöht for (int i = start ; i > bound; i--) { // Statement } Aktualisierung: i wird um 1 reduziert ++ (und --) oft in Aktualisierungen des Loop Counters 75 Inkrement und Dekrement Kurzform Äquivalente ausführlichere Version variable++; variable = variable + 1; variable--; variable = variable - 1; Variable wird verwendet und dann verändert Dies gilt auch in Ausdrücken und Zuweisungen Beispiel int x = 2; int y; y = x++; 76 Inkrement und Dekrement Kurzform Äquivalente ausführlichere Version variable++; variable = variable + 1; //increment variable--; variable = variable - 1; //decrement Beispiele int x = 2; System.out.println(x++); // x = x + 1; x now stores 3 System.out.println(x++); // x = x + 1; x now stores 4 77 Output: 2 3 Inkrement und Dekrement Kurzform Äquivalente ausführlichere Version variable++; variable = variable + 1; variable--; variable = variable - 1; Variable wird verwendet und dann verändert Dies gilt auch in Ausdrücken und Zuweisungen Beispiel int x = 2; int y; y = x++; 78 Inkrement und Dekrement Kurzform Äquivalente ausführlichere Version variable++; variable = variable + 1; variable--; variable = variable - 1; Variable wird verwendet und dann verändert Dies gilt auch in Ausdrücken und Zuweisungen Beispiel int x = 2; int y; y = x++; 79 int temp = x; x++; y = temp; //x: //y: Inkrement und Dekrement Kurzform Äquivalente ausführlichere Version variable++; variable = variable + 1; variable--; variable = variable - 1; Variable wird verwendet und dann verändert Dies gilt auch in Ausdrücken und Zuweisungen Beispiel int x = 2; int y; y = x++; 80 int temp = x; x = x + 1; y = temp; //x: //y: Zuweisungen (Assignment Statement) 84 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiele LHS: int k int i = 3; int j = 7; RHS Resultat: 9 9 3+5 8 i+2 5 i++ 3 // i: 4 j-- + j%4 9 // j: 6 Zuweisungen (Assignment Statement) 85 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; Achtung: Zwei Variablen werden verändert! Zuweisungen (Assignment Statement) 86 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; Zuweisungen (Assignment Statement) 87 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 1. RHS: 3 2. 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; = 3; //update i!! Zuweisungen (Assignment Statement) 88 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 1. RHS: 3 2. Addiere 1 zu Variable i 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; = 3; //update i!! // i+1 Zuweisungen (Assignment Statement) 89 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 1. RHS: 3 2. Addiere 1 zu Variable i 3. Speichere Variable i 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; = 3; //update i!! // i+1 // i= Zuweisungen (Assignment Statement) 90 LHS = RHS; LHS: Eine Basistyp Variable (z.B. int, long, oder double) RHS: Ein Ausdruck Ablauf: 1. Rechte Seite (RHS) wird berechnet 1. RHS: 3 2. Addiere 1 zu Variable i 3. Speichere Variable i 2. Resultat (Wert) wird in Variable (LHS) gespeichert Beispiel int i = 3; int j = i++; = 3; //update i!! // i+1 // i= j = Inkrement und Dekrement Puzzles int x = 1; int y = 0; int z = 0; y = x++; z = x++ + x++; § Wert x? § Wert y? § Wert z? 93 PollInkrement und Dekrement Puzzles 95 int x = 1; //S1 int y = 0; //S2 int z = 0; //S3 y = x++; //S4 z = x++ + x++; //S5 E1 E2 nach S1 S2 S3 S4 E1 E2 S5 x 1 1 1 2 3 4 4 y 0 0 1 1 z 0 0 5 PollInkrement und Dekrement Puzzles int a = 1; a = a++; § Wert a? int i = 10; int j = i-- - i--; § Wert i? § Wert j? 96 PollInkrement und Dekrement Puzzles int i = 10; int j = i-- - i--; // in Zeitlupe int i = 10; int temp1 = i; // 10 i = i - 1; // 9 int temp2 = i; // 9 i = i – 1; // 8 j = temp1 – temp2; // 1 § Wert i? 8 § Wert j? 1 97 int a = 1; a = a++; // in Zeitlupe int a = 1; int temp = a; // 1 a = a + 1; // 2 a = temp; // 1 § Wert a? 1 PollInkrement und Dekrement Puzzles 101 § Unser Ziel ist es verständliche Programme zu schreiben Inkrement und Dekrement Puzzles 102 § Unser Ziel ist es verständliche Programme zu schreiben § … und nicht Puzzles zu konstruieren! § Sie sollten ++ und -- (er)kennen § Auch in komplexen Ausdrücken § Ihre Entscheidung ob sie es verwenden (aber wenn dann richtig) § Diese Operatoren sind nicht so effizient dass wir dafür die Klarheit eines Programmes opfern wollen. Weitere Kurzformen § Erlauben Verwendung des Wertes einer Variable gefolgt von einer Modifikation (Zuweisung) Kurzform Äquivalente ausführlichere Version variable += value; variable = variable + value; variable -= value; variable = variable - value; variable *= value; variable = variable * value; variable /= value; variable = variable / value; variable %= value; variable = variable % value; § Modifikation mit beliebigen Werten (nicht nur 1) 103 Weitere Kurzformen Beispiele x += 3; // x = x + 3; note -= 0.5; // note = note - 0.5; number *= 2; // number = number * 2; Warnung: x += 1; // x = x + 1; x =+ 1; // x = + 1; 104 Weitere Kurzformen – manchmal nützlich § x++ und j-- heissen Post-Increment bzw. Post-Decrement Operator, da die Veränderung (von x und j) gemacht wird nachdem der Wert (von x oder j) gelesen («gebraucht») wurde. § Es gibt auch Operatoren, die die Veränderung (Increment oder Decrement) durchführen bevor der Wert gelesen wurde; dies sind der Pre-Increment bzw. Pre-Decrement Operator: ++j oder --x. Beispiele int x = 2; System.out.println(++x); // x = x + 1; x now stores 3 System.out.println(++x); // x = x + 1; x now stores 4 105 Output: 3 4 Weitere Kurzformen – manchmal unnötig § x++ und j-- heissen Post-Increment bzw. Post-Decrement Operator, da die Veränderung (von x und j) gemacht wird nachdem der Wert (von x oder j) gelesen («gebraucht») wurde. § Es gibt auch Operatoren, die die Veränderung (Increment oder Decrement) durchführen bevor der Wert gelesen wurde; dies sind der Pre-Increment bzw. Pre-Decrement Operator: ++j oder --x. Beispiele int x = 2; System.out.println(++x); // x = x + 1; x now stores 3 System.out.println(++x); // x = x + 1; x now stores 4 106 Output: 3 4 2.8.2 Bedingte Auswertung und Kurzformen § Für && und || müssen nicht immer beide Operanden ausgewertet werden, um das Ergebnis zu ermitteln § Java beendet die Auswertung eines booleschen Ausdrucks sobald das Ergebnis fest steht. § && und || sind links-assoziativ § Ausdrücke werden von links nach rechts, gemäss Präzedenz und Assoziativität ausgewertet § && stoppt sobald ein Teil(ausdruck) false ist § || stoppt sobald ein Teil(ausdruck) true ist 107 Bedingte Auswertung: Vorsicht § Was ist der Wert von count am Ende des Codesegments? // look closely int count = 0; Scanner console = new Scanner(System.in); for (int i = 0; i<4; i++) { System.out.print(\"Eingabe Zahl: \"); int wert = console.nextInt(); if ((wert != 0) && (count++ < 9)) { System.out.println(\"Hit\"); } } // count: Anzahl Werte ungleich 0, nicht Iterationen § Vorsicht bei ++/-- 108 Bedingte Auswertung: Vorsicht § Die logischen Operatoren sind nicht kommutativ wenn die Auswertung den Zustand des Programms verändern kann. § (expr1 && expr2) nicht immer gleich (expr2 && expr1) § Vorsicht bei Operatoren mit Nebenwirkungen («side effects») § Offensichtliche Nebenwirkungen: z.B. int x,y; x++ y-- o. ä. § Nicht sofort offensichtlich: § Methoden oder Funktionen, die Zustand des Programms ändern (werden wir später kennenlernen) § Operationen die Zustand des Systems ändern (wie z.B. x/0 – Fehler!) 109 Kurzformen - Recap § Unser Ziel ist es, verständliche Programme zu schreiben. § Vorsicht bei Kurzformen und bedingter Auswertung § Oft sinnvoll um kompakt Laufzeitfehler zu vermeiden § Gebrauch erlaubt, nicht erzwungen § Was wird gedruckt? int x = 2; System.out.println(++x + x++ + \" \" + x + ++x + x); 110 Kurzformen - Recap § Unser Ziel ist es, verständliche Programme zu schreiben. § Vorsicht bei Kurzformen und bedingter Auswertung § Oft sinnvoll um kompakt Laufzeitfehler zu vermeiden § Gebrauch erlaubt, nicht erzwungen § Was wird gedruckt? int x = 2; System.out.println(++x + x++ + \" \" + x + ++x + x); 111 Output 6 455 int x = 2; System.out.println(++x + x++ + \" \" + x + ++x + x); 112 Output 6 455 pre: erhöhe, dann verwenden 3 x: 3 post: verwende, dann erhöhen 3 x: 4 \"4\" +: 6 \"6\" pre: erhöhe, dann verwenden 5 \"5\" x: 5 5 \"5\" 2.8.3 Terminierung von Schleifen 114 Eine triviale Aufgabe ... § Schreiben Sie eine Methode printNumbers die die Zahlen von 1 bis N durch Komma getrennt ausgibt. Beispiel: Obergrenze N eingeben: 5 sollte ergeben: 1, 2, 3, 4, 5 115 Lösungsansatz public static void printNumbers() { Scanner console = new Scanner(System.in); System.out.print(\"Obergrenze N eingeben: \"); int max = console.nextInt(); for (int i = 1; i <= max; i++) { System.out.print(i + \", \"); } System.out.println(); // to end the line of output } 116 Welche Schleifen liefern gewünschten Output? public static void printNumbers() { Scanner console = new Scanner(System.in); System.out.print(\"Obergrenze N eingeben: \"); int max = console.nextInt(); // Option A for (int i = 1; i <= max; i++) { System.out.print(i + \", \"); } System.out.println(); // to end the line of output // Option B for (int i = 1; i <= max; i++) { System.out.print(\", \" + i); } System.out.println(); // to end the line of output } }// printNumbers Poll 117 A: Fehlerhafte Lösung public static void printNumbers() { Scanner console = new Scanner(System.in); System.out.print(\"Obergrenze N eingeben: \"); int max = console.nextInt(); for (int i = 1; i <= max; i++) { System.out.print(i + \", \"); } System.out.println(); // to end the line of output } Output bei Eingabe 5: 1, 2, 3, 4, 5, 118 B: Fehlerhafte Lösung public static void printNumbers() { Scanner console = new Scanner(System.in); System.out.print(\"Obergrenze N eingeben: \"); int max = console.nextInt(); for (int i = 1; i <= max; i++) { System.out.print(\", \" + i); } System.out.println(); // to end the line of output } Output bei Eingabe 5: , 1, 2, 3, 4, 5 120 Gartenzaun Analogie § Wir geben n Zahlen aus aber brauchen nur n - 1 Kommas. § Ähnlich dem Bau eines Weidezaunes mit Pfosten und Querstreben § Wenn wir – wie in der 1. fehlerhaften Lösung – Pfosten und Streben installieren dann hat der letzte Pfosten in der Luft hängende Streben. for (Länge des Zauns) { Betoniere Pfosten. Installiere Querstreben. } 122 Gartenzaun Analogie § Wir geben n Zahlen aus aber brauchen nur n - 1 Kommas. § Ähnlich dem Bau eines Weidezaunes mit Pfosten und Querstreben § Wenn wir – wie in der 2. fehlerhaften Lösung – Streben und Pfosten installieren dann hat der erste Pfosten in der Luft hängende Streben. for (Länge des Zauns) { Installiere Querstreben. Betoniere Pfosten. } 123 Schleife § Fügen Sie eine Anweisung ausserhalb der Schleife hinzu um den ersten «Pfosten» zu plazieren Betoniere Pfosten. for (Länge des Zauns - 1) { Installiere Querstreben. Betoniere Pfosten. } 124 Lösungen basierend auf dieser Idee System.out.print(1); for (int i = 2; i <= max; i++) { System.out.print(\", \" + i); } System.out.println(); // to end the line Alternative: 1. oder letzter Durchlauf durch die Schleife kann verändert werden: for (int i = 1; i <= max - 1; i++) { System.out.print(i + \", \"); } System.out.println(max); // to end the line 125 Lösung (eine Möglichkeit) public static void printNumbers() { Scanner console = new Scanner(System.in); System.out.print(\"Obergrenze N eingeben: \"); int max = console.nextInt(); System.out.print(1); for (int i = 2; i <= max; i++) { System.out.print(\", \" + i); } System.out.println(); // to end the line } 126 «off-by-one» Error (Um-Eins-Daneben-Fehler) § Die Schleife wurde einmal zuviel (oder einmal zuwenig) durchlaufen. § «Zaunpfahlproblem» – es gibt sogar eine D Wikipedia Seite (Inhalt ohne Gewähr) 127 Terminierung von Loops § Verwandeln Sie die Methode printNumbers in eine neue Methode printPrimes die alle Primzahlen (durch Komma getrennt) bis zur Obergrenze max ausgibt (max ≥ 2). § Beispiel: printPrimes mit Eingabe 50 ergibt: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 § Eine Primzahl p kann in genau zwei Faktoren zerlegt werden: p und 1 128 import java.util.*; class PrintPrimes1 { public static void main (String[] args) { Scanner console = new Scanner(System.in); System.out.print(\"Input max: \"); int max = console.nextInt(); if (max >= 2) { printPrimes(max); } } public static void printPrimes(int limit) // Prints all prime numbers up to limit, limit >= 2 System.out.print(\"2\"); for (int candidate = 3; candidate <= limit; candidate++) { if ( /* isPrime(candidate) */ ) { System.out.print(\", \" + candidate); } } System.out.println(); // to end output } } 130 public static void printPrimes(int limit) { // Prints all prime numbers from 2 up to the given limit // limit >= 2 System.out.print(\"2\"); for (int candidate = 3; candidate <= limit; candidate++) { // Determine if candidate is prime // Count factors! 2: prime, >2 not prime int count = 0; for (int j = 1; j<=candidate; j++) { if (candidate % j == 0) { count++; } } if (count == 2) { System.out.print(\", \" + candidate); } } System.out.println(); // to end output } 132 2.8.4 Input Werte zur Schleifen Kontrolle § Interessantes Beispiel eines unbestimmten Loops § Kandidat für while-Schleife § Wert wird nicht (nur) zur Berechnung verwendet sondern kontrolliert auch den Loop (d.h. die Terminierung) § Wert ist (zusätzlich) Hinweis 134 § Hinweiszeichen (Sentinel) («sentinel»): Ein Wert der das Ende eine Reihe anzeigt § sentinel loop: Schleife deren Rumpf ausgeführt wird bis ein Sentinel gesehen wurde § Beispiel: Ein Programm soll Zahlen einlesen bis der Benutzer eine 0 eingibt; dann soll die Summe aller eingegebenen Zahlen ausgegeben werden. § (In diesem Beispiel ist 0 das Hinweiszeichen/der Sentinel.) Werte die Hinweise sind … 135 § Beispiel: Ein Programm soll Zahlen einlesen bis der Benutzer eine 0 eingibt; dann soll die Summe aller eingegebenen Zahlen ausgegeben werden. § (In diesem Beispiel ist 0 das Hinweiszeichen/der Sentinel) Enter a number (0 to quit): 10 Enter a number (0 to quit): 20 Enter a number (0 to quit): 30 Enter a number (0 to quit): 0 The sum is 60 Werte die Hinweise sind … 136 Fehlerhafte Lösung § Was ist an diesem Programm schlecht? Scanner console = new Scanner(System.in); int sum = 0; int number = 1; // \"dummy value\", anything but 0 while (number != 0) { System.out.print(\"Enter a number (0 to quit): \"); number = console.nextInt(); sum = sum + number; } System.out.println(\"The total is \" + sum); 137 Ein anderes Hinweiszeichen … § Ändern Sie das Programm so dass -1 der Sentinel ist. Scanner console = new Scanner(System.in); int sum = 0; int number = 1; // \"dummy value\", anything but 0 while (number != -1) { System.out.print(\"Enter a number (0 to quit): \"); number = console.nextInt(); sum = sum + number; } System.out.println(\"The total is \" + sum); 138 Ein anderes Hinweiszeichen … § Ändern Sie das Programm so dass -1 der Sentinel ist. § Example log of execution: Enter a number (-1 to quit): 15 Enter a number (-1 to quit): 25 Enter a number (-1 to quit): 10 Enter a number (-1 to quit): 30 Enter a number (-1 to quit): -1 The total is 79 139 Ein anderes Hinweiszeichen … § Setzen Sie den Sentinel auf -1: Scanner console = new Scanner(System.in); int sum = 0; int number = 1; // \"dummy value\", anything but -1 while (number != -1) { System.out.print(\"Enter a number (-1 to quit): \"); number = console.nextInt(); sum = sum + number; } System.out.println(\"The total is \" + sum); § Jetzt ist das Result falsch. Warum? The total is 79 140 Fehlerhafte Lösung – 0 à -1 § Was ist an diesem Programm falsch? Scanner console = new Scanner(System.in); int sum = 0; int number = 1; // \"dummy value\", anything but 0 while (number != 0) { System.out.print(\"Enter a number ( 0 to quit): \"); number = console.nextInt(); sum = sum + number; } System.out.println(\"The total is \" + sum); § Was ist an diesem Programm falsch? Scanner console = new Scanner(System.in); int sum = 0; int number = 1; // \"dummy value\", anything but -1 while (number != -1) { System.out.print(\"Enter a number (-1 to quit): \"); number = console.nextInt(); sum = sum + number; } System.out.println(\"The total is \" + sum); 141 Das Problem mit diesem Programm § Unser Programm folgt diesem Muster: summe = 0 while (input ist nicht der sentinel) { drucke prompt; lese input addiere input zu summe } § Beim letzten Durchlauf durch den Rumpf wird der Sentinel -1 zur Summe addiert: 143 Das Problem mit diesem Programm § Beim letzten Durchlauf durch den Rumpf wird der Sentinel -1 zur Summe addiert: drucke prompt; lese input (-1) addiere input (-1) zu summe § Beispiel inkorrekter Terminierung (off-by-one error, Zaunpfahlproblem): § Müssen N Zahlen lesen aber nur die ersten N-1 addieren. 144 Lösung summe = 0 drucke prompt; lese input // setzen eines pfostens while (input ist nicht der sentinel) { addiere input zu summe // installation querstrebe drucke prompt; lese input // setzen eines pfostens } § Schleifen mit einem Sentinel folgen oft diesem Muster. 145 Beispiel mit Sentinel Scanner console = new Scanner(System.in); int sum = 0; // pull one prompt/read (\"post\") out of the loop System.out.print(\"Enter a number (-1 to quit): \"); int number = console.nextInt(); while (number != -1) { sum = sum + number; // moved to top of loop System.out.print(\"Enter a number (-1 to quit): \"); number = console.nextInt(); } System.out.println(\"The total is \" + sum); 147 do-while-Schleife § do-while-Schleife: Führt test am Ende des Schleifenrumpfes aus um zu entscheiden, ob ein weiterer Durchlauf nötig ist § Stellt sicher dass der Rumpf { … } mindestens einmal ausgeführt wird. do { statement(s); } while (test); // naechste Anweisung Anweisung(en) im Loop ausführen Ist test wahr? Anweisung nach Loop ausführen ja nein 149 do-while-Schleife § Beispiel: // Example: prompt until correct PIN is typed int input; do { System.out.print(\"Type your PIN: \"); input = console.nextInt(); } while (input != userPinCode); Anweisung(en) im Loop ausführen Ist test wahr? Anweisung nach Loop ausführen ja nein 150 Übersicht § 2.8 Nochmals Schleifen § 2.8.1 Kurzformen (für Aktualisierung) § 2.8.2 Kurzformen und bedingte («short-circuit») Ausführung § 2.8.3 Terminierung von Schleifen § 2.8.4 Input Werte zur Schleifenkontrolle § 2.8.5 Invarianten 151 if/else, return Beispiel Lösungen Schreiben Sie eine Methode quadrant die für ein Paar von reellen Zahlen den Quadranten liefert in dem dieser Punkt liegt. § Beispiel: quadrant(-4.2, 17.3) liefert 2 § Fällt der Punkt auf eine der Achsen des Koordinatensystems liefere 0. 152 x+x- y+ y- quadrant 1quadrant 2 quadrant 3 quadrant 4 if/else, return Beispiellösung public static int quadrant(double x, double y) { if (x > 0 && y > 0) { return 1; } else if (x < 0 && y > 0) { return 2; } else if (x < 0 && y < 0) { return 3; } else if (x > 0 && y < 0) { return 4; } else { // at least one coordinate equals 0 return 0; } } 153 if/else, return Beispiellösung public static int quadrant(double x, double y) { if (x > 0.0 && y > 0.0) { return 1; } else if (x < 0.0 && y > 0.0) { return 2; } else if (x < 0.0 && y < 0.0) { return 3; } else if (x > 0.0 && y < 0.0) { return 4; } else { // at least one coordinate equals 0 return 0; } } 154 public static int quadrant (double x, double y) { if (x>0 && y>0) { return(1); } else if (x<0 && y>0) { return(2); } else if (x<0 && y<0) { return(3); } else if (x>0 && y<0) { return(4); } else { //if Koordinate is on an axis return(0); } } ✓ 155156✓ 157✓ public static int quadrant(double x, double y) { int q=0; if (x==0 || y==0) { q=0; } else if (x>0 && y>0) { q=1; } else if (x<0 && y>0) { q=2; } else if (x<0 && y<0) { q=3; } else if(x>0 && y<0) { q=4; } return q; } ✓ 158 { und } kosten nicht viel for (int i = 0; i < 10; i++) System.out.print(a[i] + \" \"); Aber wir wollen auch die Zahlen summieren for (int i = 0; i < 10; i++) System.out.print(a[i] + \" \"); sum += a[i]; System.out.println(sum); Output: 0 1 2 3 4 5 6 7 8 9 Compiler error: Variable i nicht definiert 159 { und } kosten nicht viel Schön wenn es einen Compiler Fehler gibt … nicht immer haben wir soviel Glück int i; for (i = 0; i < 10; i++) System.out.print(a[i] + \" \"); sum += a[i]; System.out.println(sum); Mit Glück ein Laufzeitfehler (wenn Variable i ≥ a.length) Sonst: viel Spass bei Fehlersuche 160 Fehlende { und } kosten (evtl) viel Zeit § Auch Schleifenrumpf oder Verzweigung mit 1 Anweisung: immer { und } verwenden for (int i=0; i<10; i++) { System.out.print(a[i] + \" \"); } 161 ? Operator § Der ? Operator erlaubt Auswahl zwischen 2 Alternativen boolean_expression ? expression1 : expression2 § Wenn boolean_expression «true» ergibt wird expression1 evaluiert, sonst wird expression2 evaluiert § Beispiel int j = k < 0 ? -1 : 1; // k int 162 int quadrant (double x, double y){ if (x==0||y==0) { return 0; } else { return ((y<0)?3:1)+((x<0)^(y<0)?1:0); } } 163 (caret) bitwise exclusive OR int quadrant (double x, double y){ if (x==0||y==0) { return 0; } else { return ((y<0)?3:1)+((x<0)^(y<0)?1:0); } } 164 (caret) bitwise exclusive OR The operators &, ^, and | are bitwise operators when the operands are primitive integral types. They are non-short-circuit logical boolean operators when the operands are boolean, and their behavior in the latter case is specified. See the section 15.22.2 of the Java Language Specification for details. boolean boolean ✓ Also … § Viele Lösungen mit kleinen Fehlern § Compiler findet einige: fehlende return, falscher Typ des Rückgabewertes, fehlendes ; § Daher verwenden wir Compiler in Prüfung § Testumgebung fände weitere: Methodendeklaration mit falschem Rückgabetyp, falsche Parameterdeklaration § Lernen wir im Verlauf der Vorlesung kennen § Falscher Methodennamen – kein Test funktioniert (in Prüfung) § Logische Fehler müssen Sie eliminieren! § Aufgaben genau lesen (auch wenn lang) § Dann ist auch Ihre Lösung korrekt 165 252-0027 Einführung in die Programmierung 2.8 Nochmals Schleifen Thomas R. Gross Department Informatik ETH Zürich 1 Übersicht § 2.8 Nochmals Schleifen § 2.8.1 Kurzformen (für Aktualisierung) § 2.8.2 Kurzformen und bedingte («short-circuit») Ausführung § 2.8.3 Terminierung von Schleifen § 2.8.4 Input Werte zur Schleifenkontrolle § 2.8.5 Invarianten 2 2.8.5 Invarianten 3 Schleifen § Fokus auf while-Loop § Allgemeiner als for-Loop § Zusätzlich: Keine nicht-lokalen Kontrolltransfers § Also ohne break und continue § Könnten Sie bereits kennen § Kontrolltransfer: nach der Ausführung der Anweisung A ist die nächste ausgeführte Anweisung X nicht die Anweisung B, die im Programmtext direkt auf A folgt. 45 Beispiel (informell) Was ist die Grundidee? Sehen wir uns einen Loop an: (int Variable, kein Overflow/Underflow) 6 // y = 0; i = 0; // // while (i != x) { // i = i+1; // y = y+i; // } // // Beispiel (informell) Was ist die Grundidee? Sehen wir uns einen Loop an: 8 // x >= 0 y = 0; i = 0; // // while (i != x) { // i = i+1; // y = y+i; // } // // y == sum(1,x) 9 Beispiel (informell) § Müssen den Loop zusammenfassen (um Aussage am Ende des Programms zu untersuchen) § Invariante: Zusammenfassung des Loop Body § Deckt ab keine Iteration (vor 1. Ausführung, keine Ausführung des Loop Body) § Deckt ab k Iterationen 13 // x >= 0 y = 0; i = 0; // x >= 0 ∧ y == 0 ∧ i == 0 // invariant: y == sum(1,i) while (i != x) { // y == sum(1,i) ∧ i != x i = i+1; // y == sum(1,i-1) y = y+i; // y == sum(1,i-1)+i } // i == x ∧ y == sum(1,i) // y == sum(1,x) 1415 // x >= 0 y = 0; i = 0; // x >= 0 ∧ y == 0 ∧ i == 0 // invariant: y == sum(1,i) while (i != x) { // y == sum(1,i) ∧ i != x inew = i+1; // y == sum(1,inew-1) ynew = y+inew; // ynew == sum(1,inew-1)+inew i = inew y = ynew ; } // i == x ∧ y == sum(1,i) // y == sum(1,x) 17 Beobachtungen § Um Aussagen über die Ausführung des Loops zu machen brauchen wir eine Invariante § Der Rumpf der Schleife könnte beliebig oft ausgeführt werden § Die Precondition für die Schleife muss die Invariante implizieren § Precondition muss stärker als (oder gleich stark wie) die Invariante sein 19 § Invariante und der Schleifen Test (wenn er wahr ist) müssen stark genug sein um zu zeigen, dass die Postcondition des Rumpfs auch die Invariante impliziert § Invariante und der Schleifen Test (wenn er falsch ist) müssen stark genug sein um die Postcondition der Schleife zu zeigen. § Invariante hat/verbindet zwei Aspekte: kommen dem gewünschten Ergebnis schrittweise näher und eine Variable die in jedem Schritt verändert wird verbindet Schleifen Test und partielles Ergebnis. 20 // x >= 0 y = 0; i = 0; // x >= 0 ∧ y == 0 ∧ i == 0 // invariant: y == sum(1,i) ∧ i < x+1 while (i != x) { // y == sum(1,i) ∧ i < x+1 ∧ i != x inew = i+1; // y == sum(1,inew-1) ynew = y+inew; // ynew == sum(1,inew-1)+inew i = inew y = ynew ; } // i == x ∧ y == sum(1,i) ∧ i < x+1 // y == sum(1,x) 21 Hoare Logik § Gegeben sei ein Tripel für einen while-loop {P} while(B) S; {Q} Ein solches Tripel ist gültig wenn es eine Invariante I gibt so dass: § P ⇒ I Invariante gilt zu Beginn § {I ∧ B} S {I} Nach Ausführen des Rumpfes gilt die Invariante wieder § (I ∧ !B) ⇒ Q Invariante (und Verlassen der Schleife, d.h test B ist false) impliziert Postcondition Q. 2223 § Für ein gültiges Hoare Tripel einer Schleife {P} while(B) S; {Q} sind Schleifentest B, Schleifenrumpf S und die Schleifen- invariante I aufeinander abgestimmt § S kann eine Folge von Anweisungen sein (auch geschachtelte Loops) § Für eine Postcondition Q gibt es (oft, manchmal) verschiedene Schleifen, die für die Precondition P das selbe Result berechnen § Diese Schleifen haben dann andere Invarianten und Statements im Rumpf § Definition allgemein genug, deckt auch den Fall ab dass der Rumpf keinmal durchlaufen wird 24 Beispiel, genauer 25 {pre: x >= 0} y = 0; i = 0; while(i != x) { i = i+1; y = y+i; } {P} while (B) S; {Q} § P ⇒ I Invariante gilt zu Beginn § {I ∧ B} S {I} Nach Ausführen des Rumpfes gilt die Invariante wieder § (I ∧ !B) ⇒ Q Invariante und Verlassen der Schleife impliziert Q. 26 {pre: x >= 0} y = 0; i = 0; {pre: x >= 0 ∧ y == 0 ∧ i == 0} {inv: y == sum(1,i)} while(i != x) { i = i+1; y = y+i; } {post: i == x ∧ y == sum(1,i)} (also: y == sum(1,x)) {P} while (B) S; {Q} § P ⇒ I Invariante gilt zu Beginn § {I ∧ B} S {I} Nach Ausführen des Rumpfes gilt die Invariante wieder § (I ∧ !B) ⇒ Q Invariante und Verlassen der Schleife impliziert Q. 27 Ein anderer Loop (für das selbe Problem) Ein anderer Loop hat eine andere Invariante 29 {pre: x >= 0} y = 0; i = 1; {pre: x >= 0 ∧ y==0 ∧ i==1} {inv: y == sum(1,i-1)} while(i != x+1) { y = y+i; i = i+1; } {post: i=x+1 ∧ y == sum(1,i-1)} (also: y == sum(1,x)) 30 Invarianten helfen Bugs zu finden Dieser Loop ist ähnlich aber macht nicht was wir wollen: 31 {pre: x >= 0} y = 0; i = 1; {pre: x >= 0 ∧ y==0 ∧ i==1} {inv: y == sum(1,i-1)} while(i != x) { y = y+i; i = i+1; } {post: i==x ∧ y == sum(1,i-1)} (also: y == sum(1,x)) 32 Mehr Bugs § Dieser Loop enthält ein ungültiges Hoare Triple 33 {pre: x >= 0} y = 0; i = 0; {pre: x >= 0 ∧ y==0 ∧ i==0} {inv: y == sum(1,i)} while(i != x) { y = y+i; i = i+1; // Invariante gilt nicht – warum? } {post: i==x ∧ y == sum(1,i)} Invarianten …. § … dürfen weder zu stark noch zu schwach sein § Wenn die Invariante zu stark ist, dann ist sie evtl. false § D.h. wir können nicht zeigen, dass sie zu Beginn gültig ist, oder § Die Invariante ist nicht wahr nachdem der Rumpf ausgeführt wurde § Wenn die Invariante zu schwach ist § Dann kann die Postcondition nach dem Verlassen des Loops evtl. nicht die Postcondition der Schleife implizieren § Und/oder es ist unmöglich zu zeigen dass die Invariante nach der Ausführung des Rumpfes (wieder) gilt 35 Invarianten … nicht zu stark und nicht zu schwach § Das ist der Grund warum es keinen vollautomatischen Weg gibt, eine Loop Invariante zu konstruieren § Programmieren eine kreative Tätigkeit § Finden der Invariante erfordert nachdenken (oder manchmal «raten») § Oft zusammen mit dem Schreiben des Programms § Wenn es keinen Beweis gibt, dann muss entweder der Code, die Invariante, oder beides geändert werden. § Manchmal gibt es verschiedene Invarianten, die alle genügen (d.h. sind weder zu stark noch zu schwach), aber unterschiedlich zweckmässig sind 36 Eine Methodologie § Hier ist ein Ansatz wie wir Schleife und Invarianten entwickeln können § Kein vollständiges Rezept § Nicht stur zu befolgen – aber besser als der «schnelle» Weg, erst den Code zu entwickeln und dann die Invariante zu suchen. 37 § [M]ethodology is the general research strategy that outlines the way in which research is to be undertaken and, among other things, identifies the methods to be used in it. § [Wikipedia] § Computer science usage, in general «analysis of the body of methods and principles associated with a branch of knowledge» [dto] 38 Eine Methodologie § Hier ist ein Ansatz wie wir Schleife und Invarianten entwickeln können § Kein vollständiges Rezept § Nicht stur zu befolgen – aber besser als der «schnelle» Weg, erst den Code zu entwickeln und dann die Invariante zu suchen. 39 Eine Methodologie § Hier ist ein Ansatz wie wir Schleife und Invarianten entwickeln können § Kein vollständiges Rezept § Nicht stur zu befolgen – aber besser als der «schnelle» Weg, erst den Code zu entwickeln und dann die Invariante zu raten. 40 Eine Methodologie § Vorschlag (funktioniert überraschenderweise oft): 1. Bestimmen Sie zuerst die Invariante und lassen Sie sie die anderen Schritte leiten (!) § Wie bringt uns jede Iteration näher an das Ziel? § Was muss nach jeder Iteration gelten? 2. Schreiben Sie einen Rumpf der die Invariante gültig lässt 3. Bestimmen Sie den Loop Test so, dass Test-ist-false die Postcondition impliziert 4. Schreiben Sie die Initialisierung so dass dieser Code die Invariante sicher stellt. 41 Eine Methodologie § Ein Ansatz wie wir Schleife und Invarianten entwickeln können § Kein vollständiges Rezept § Nicht stur zu befolgen – aber besser als der «schnelle» Weg, erst den Code zu entwickeln und dann die Invariante zu suchen. 42 Beispiel Wir suchen für positive x und y den Quotienten q, also q==x/y. (Ohne / (int) Operator, nur mit + oder -.) Die Variablen x und y haben den Typ int, y ≠ 0, und das Ergebnis kann korrekt in einer int Variable gespeichert werden. 1. Bestimmen Sie zuerst die Invariante und lassen Sie sie die anderen Schritte leiten 2. Idee: Wiederholt y von x subtrahieren – findet wie oft y in x enthalten ist § Invariante: q speichert wie oft y subtrahiert wurde, dann ist q * y + r == x (r der Rest, möglicherweise r ≥ y, q ≥ 0) § Andere Invarianten sind auch möglich … 43 Wir suchen für x und y den Quotienten q, also q==x/y 2. Schreiben Sie einen Rumpf der die Invariante gültig lässt {inv: q*y+r == x ∧ q >= 0} while ( ) { // invariante gültig r = r – y; // q zählt wie oft wir y subtrahieren konnten q = q + 1; // invariante wieder gültig } 44 Wir suchen für x und y den Quotienten q, also q==x/y 3. Bestimmen Sie den Loop Test so, dass Test-ist-false die Postcondition impliziert 4. Wie oft wollen wir y subtrahieren? {inv: q*y+r == x ∧ q >= 0} while ( ) { // invariante gültig r = r – y; // q zählt wie oft wir y subtrahieren konnten q = q + 1; // invariante wieder gültig } 45 Wir suchen für x und y den Quotienten q, also q==x/y 3. Bestimmen Sie den Loop Test so, dass Test-ist-false die Postcondition impliziert 4. Wie oft wollen wir y subtrahieren? Rest r ≥ 0 (da x ≥ 0, y > 0) {inv: q*y+r == x ∧ q >= 0} while ( ) { // invariante gültig r = r – y; // q zählt wie oft wir y subtrahieren konnten q = q + 1; // invariante wieder gültig } 46 Wir suchen für x und y den Quotienten q, also q==x/y 3. Bestimmen Sie den Loop Test so, dass Test-ist-false die Postcondition impliziert 4. Wie oft wollen wir y subtrahieren? Rest r ≥ 0 (da x ≥ 0, y > 0) {inv: q*y+r == x ∧ q >= 0 ∧ (r >= 0) } while ( ) { // invariante gültig r = r – y; // q zählt wie oft wir y subtrahieren konnten q = q + 1; // invariante wieder gültig } 47 Wir suchen für x und y den Quotienten q, also q==x/y 3. Bestimmen Sie den Loop Test so, dass Test-ist-false die Postcondition impliziert 4. Wie oft wollen wir y subtrahieren? Rest r ≥ 0 (da x ≥ 0, y > 0) {inv: q*y+r == x ∧ q >= 0 ∧ (r >= 0) } while ( r > y ) { // invariante gültig r = r – y; // q zählt wie oft wir y subtrahieren konnten q = q + 1; // invariante wieder gültig } 48 Wir suchen für x und y den Quotienten q, also q==x/y 3. Bestimmen Sie den Loop Test so, dass Test-ist-false die Postcondition impliziert {inv: q*y+r == x ∧ q >= 0 ∧ (r >= 0) } while ( y <= r ) { // invariante gültig r = r – y; // q zählt wie oft wir y subtrahieren konnten q = q + 1; // invariante wieder gültig } {post: (q*y+r == x) ∧ (r >= 0) ∧ (r < y) } 49 Wir suchen für x und y den Quotienten q, also q==x/y 4. Schreiben Sie die Initialisierung so dass dieser Code die Invariante sicher stellt. r = x; q = 0; {inv: q*y+r == x ∧ q >= 0 ∧ (r >= 0) } while ( y <= r ) { // invariante gültig r = r – y; // q zählt wie oft wir y subtrahieren konnten q = q + 1; // invariante wieder gültig } 50 Was muss noch gelten? § Die Initialisierung hat eine Precondition: x >= 0 ∧ y > 0 {pre: x >= 0 ∧ y > 0 } r = x; q = 0; {inv: q*y+r == x ∧ q >= 0 ∧ (r >= 0) } while ( y <= r ) { r = r – y; q = q + 1; } {post: (q*y+r == x) ∧ (r >= 0) ∧ (r < y) } 51 Korrektheit Sie erinnern sich: ist Hoare-Tripel {P} S {Q} gültig dann gilt nach Ausführung von S Aussage Q, vorausgesetzt dass P davor galt § Wenn wir den Punkt nach S erreichen … § Warum erreichen wir nicht den Punkt nach Ausführung von S? § S kann nicht ausgeführt werden (z.B. Division durch 0) § Ausführung von S bricht ab (z.B. Ergebnis kann nicht gespeichert werden) § S terminiert nicht § … und viele andere mehr 52 Korrektheit für {P} S {Q} § Bisher: Partielle Korrektheit (korrekt unter der Annahme Terminierung von S) § Vollständiger Korrektheitsbeweis erfordert einen Beweis, dass S terminiert § Wie zeigen wir Terminierung einer Schleife? 53 Terminierung § Idee: wir bilden den Zustand (nach Ausführung eines Durchlaufs durch die Schleife) auf eine ganze Zahl ≥ 0 ab so dass diese Zahl durch jede Ausführung des Rumpfes verkleinert wird § Wir finden einen Beweis dass der Loop Test «false» ergibt wenn diese Zahl zu 0 wird § Damit zeigen wir Terminierung: jede Ausführung verkleinert die Zahl, d.h. es gibt nur endlich viele Schritte, die die Zahl auf 0 bringen. 54 Beispiele § Summierung von 1 .. x: Abbildung auf (x-i) § Am Anfang positiv (x≥0, i == 0) § Wird in jeder Iteration kleiner (x unverändert, i = i+1) § Wenn (x-i)==0 dann ist x==i und Loop terminiert § Quotient-und-Rest: Sei R == x % y Abbildung auf (r – R) § Am Anfang positiv (r == x, R < x) § Wird in jeder Iteration immer kleiner (r = r–y, y>0) § Wenn (r-R==0) dann ist r==R und damit y≤r, und Loop terminiert § Ist die Abbildungsfunktion 0 vor Beginn des Loops dann keine Iteration 55 252-0027 Einführung in die Programmierung 3.0 Arrays (Reihen) Thomas R. Gross Department Informatik ETH Zürich 56 Übersicht Verwandte Themen: § 3.0 Arrays § 4.0 Klassen und Objekte Wichtig um «interessante» Programme zu schreiben: § 5.0 Input/Output 57 3.0 Reihen (Arrays) Based on Slides by Reges et al. Copyright (c) Pearson 2013. All rights reserved. 58 Übersicht § 3.0 Arrays § 3.1 Motivation § 3.2 Deklaration und Erstellen § 3.3 Arbeiten mit Arrays § 3.4 Arrays und Methoden 59 3.1 Ein neues Problem Sie wollen für die Mitglieder eines Sportvereins (oder einer Gruppe/Team/Sektion) Daten analysieren z.B. Grösse: Durchschnittsgrösse und Anzahl der Spieler/innen die über dem Durchschnitt liegen Könnte so aussehen § Input unterstrichen Anzahl Mitglieder? 6 Groesse in cm: 165 Groesse in cm: 164 Groesse in cm: 158 Groesse in cm: 163 Groesse in cm: 169 Groesse in cm: 181 Durchschnitt in cm = 166.7 Anzahl ≥ Durchschnitt: 2 (33 %) 60 Schritte § Jeder Wert (Grösse) muss eingegeben werden um den Durchschnitt zu berechnen (Summe dividiert durch Anzahl Mitglieder) § Nach der Berechnung des Durchschnitts müssen wir zählen wieviele Personen grösser (gleich) als der Durchschnitt sind § Aber den Durchschnitt kennen wir erst zum Schluss § Müssen die Messwerte bis zum Ende speichern 61 Was ist problematisch? § Jeder Wert muss zweimal verwendet werden: § Um den Durchschnitt zu berechnen § Um die Anzahl Personen die grösser (gleich) als der Durchschnitt sind zu finden § Könnten natürlich jeden Wert in einer Variable speichern … aber : § Wir wissen nicht mit wievielen Personen wir arbeiten bis das Programm ausgeführt wird § Wir wissen nicht wieviele Variable wir brauchen § Wir brauchen einen Weg, mehrere Variable auf einmal zu deklarieren 62 «Arrays» (Reihen) § Ein Array erlaubt uns mehrere Werte des selben Typs zu speichern § Element: Ein Wert in einem Array. § Index: Zahl (>= 0) um ein Element eines Arrays auszuwählen § Base: Das erste Element hat den Index 0 63 «Arrays» (Reihen) § Ein Array erlaubt uns mehrere Werte des selben Typs zu speichern. § Element: Ein Wert in einem Array. § Index: Zahl (>= 0) um ein Element eines Arrays auszuwählen § Base: Das erste Element hat den Index 0 Index 0 1 2 3 4 5 6 7 8 9 Wert 12 49 -2 26 5 17 -6 84 72 3 Element 0 Element 4 Element 9 Ein Array für int Werte 64 «Arrays» (Reihen) § Ein Array erlaubt uns mehrere Werte des selben Typs zu speichern § Element: Ein Wert in einem Array. § Index: Zahl (>= 0) um ein Element eines Arrays auszuwählen § Base: Das erste Element hat den Index 0 § Müssen Variable deklarieren um auf Array zugreifen zu können § Deklaration in einer Methode (z.B. main) 65 3.2 Deklaration und Erstellen von Arrays 66 Array: Deklarieren und Erstellen Syntax type[] name = new type[length]; § Beispiel: int[] numbers = new int[10]; § Deklariert Variable numbers und lässt sie auf Array mit 10 Elementen des Typs int verweisen Index 0 1 2 3 4 5 6 7 8 9 Wert 0 0 0 0 0 0 0 0 0 0 numbers 68 type[] name = new type[length] § type: Der Typ der Elemente des Arrays § Genauer: § type_var[] name = new type_element[length]; § Z. Zt. müssen type_var und type_element identisch sein § Beispiele: § int[] numbers = new int[10]; § new: Operator der Array mit Platz für length Element erstellt § name: Name der Variable mit der Zugriff möglich ist Array: Deklarieren und Erstellen, Fortsetzung type[] name = new type[length] § length: Länge length kann ein beliebiger int Ausdruck sein int x = 2 * 3 + 1; int[] data = new int[x % 9 + 3]; § new: Operator der Array mit Platz für length Element erstellt Index 0 1 2 3 4 5 6 7 8 9 Wert ? ? ? ? ? ? ? ? ? ? data Platz für int WertPlatz für int Wert Array: Deklarieren und Erstellen § new: Operator der Array mit Platz für length Element erstellt § Was für Werte sollen da (am Anfang) gespeichert werden? § Wollen verhindern dass ein Program Daten eines anderen liest § Wollen bei wiederholter Ausführung das selbe Resultat (ohne Input…) § Daher genau definiert: § Jedes Element wird auf einen Wert der Null «entspricht» gesetzt § Voreinstellung («default») Type Default Wert int 0 boolean false String null Array: Deklarieren und Erstellen, Beispiele type[] name = new type[length] § Länge length: beliebiger int Ausdruck sein mit Wert >= 0 int x = 2 * 3 + 1; int[] data = new int[x % 9 + 3]; § Länge < 0 resultiert in Laufzeitfehler int[] bad = new int[-1]; Index 0 1 2 3 4 5 6 7 8 9 Wert 0 0 0 0 0 0 0 0 0 0 data Array: Deklarieren ohne Erstellen Syntax type[] name; § Deklariert eine Variable (name) die auf Arrays mit type Elementen verweist § Beispiel: int[] numbers; § Keine Länge nötig § Variable numbers kann auf Array mit 10 int Elementen, auf Array mit 7 int Elementen, auf Array mit 42 int Elementen … verweisen § Später Zuweisung nötig § z.B. numbers = new int[42]; «Arrays» (Reihen) § Ein Array erlaubt uns mehrere Werte des selben Typs zu speichern § Element: Ein Wert in einem Array. § Index: Zahl (>= 0) um ein Element eines Arrays auszuwählen § Base: Das erste Element hat den Index 0 § Zugriff auf Element: Name einer Variable die auf den Array verweist und Index Zugriff auf Elemente: name[index] Setzen § name[index] = expression; // Modifikation § name: Name der Variable um auf Arrayelemente zu zu greifen § index: int Wert (Ausdruck der int ergibt) § expression: Ausdruck der Wert vom Typ der Elemente des Arrays ergibt int[] data = new int[10]; data[0] = 27; data[3] = -6; index 0 1 2 3 4 5 6 7 8 9 value 0 0 0 0 0 0 0 0 0 0 Index 0 1 2 3 4 5 6 7 8 9 Wert 27 0 0 -6 0 0 0 0 0 0 data Zugriff auf Elemente: name[index] Lesen § name[index]liefert Wert des Elements index § name: Name der Variable um auf Arrayelemente zu zu greifen § index: int Wert (Ausdruck der int ergibt) § Kann überall auftreten wo ein Wert (dieses Typs) verwendet werden kann int j = data[0]; int k = data[3]; System.out.print(j+k) index 0 1 2 3 4 5 6 7 8 9 value 0 0 0 0 0 0 0 0 0 0 Index 0 1 2 3 4 5 6 7 8 9 Wert 27 0 0 -6 0 0 0 0 0 0 21 Arrays für andere Typen boolean[] results = new boolean[5]; results[2] = true; results[4] = true; String[] address = new String[6]; address[3] = \"Florastrasse 6\"; Index 0 1 2 3 4 Wert false false true false true Index 0 1 2 3 4 5 Wert null null null \"Florastrasse 6\" null null 79 Legale Index Werte Legale Index Werte: zwischen 0 und (Länge des Arrays - 1). § Einschliesslich § Lesen oder Schreiben (Zugriff, «access») mit einem Index ausserhalb dieses Bereichs resultiert in einer ArrayIndexOutOfBoundsException § «Out-of-bounds» Fehler Index 0 1 2 3 4 5 6 7 8 9 Wert 0 0 0 0 0 0 0 0 0 0 10 11 12 …… -3 -2 -1 80 Out-of-bounds Zugriffe § Example: int[] data = new int[10]; System.out.println(data[0]); // okay System.out.println(data[9]); // okay System.out.println(data[-1]); // exception System.out.println(data[10]); // exception Index 0 1 2 3 4 5 6 7 8 9 Wert 0 0 0 0 0 0 0 0 0 0 Abbruch der Ausführung dieses Programmsdata 81 Arrays und Zugriffe auf Elemente int[] numbers = new int[8]; numbers[1] = 3; numbers[4] = 99; numbers[6] = 2; int x = numbers[1]; numbers[x] = 42; numbers[numbers[6]] = 11; // use numbers[6] as index x Index 0 1 2 3 4 5 6 7 Wertnumbers 82 Arrays und Zugriffe auf Elemente int[] numbers = new int[8]; numbers[1] = 3; numbers[4] = 99; numbers[6] = 2; int x = numbers[1]; numbers[x] = 42; numbers[numbers[6]] = 11; // use numbers[6] as index xx 3 Index 0 1 2 3 4 5 6 7 Wert Index 0 1 2 3 4 5 6 7 Wert 0 3 11 42 99 0 2 0 Index 0 1 2 3 4 5 6 7 Wert 0 3 0 0 99 0 2 0 Index 0 1 2 3 4 5 6 7 Wert 0 3 0 42 99 0 2 0numbers 83 Arrays und for-Schleifen § Oft wird auf Arrayelemente in einer for-Schleife zugegriffen for (int i = 0; i < 8; i++) { System.out.print(numbers[i] + \" \"); } System.out.println(); // output: 0 3 11 42 99 0 2 0 § Eine Schleife eignet sich auch zur Zuweisung an jedes Element eines Arrays. for (int i = 0; i < 8; i++) { numbers[i] = 2 * i; } Index 0 1 2 3 4 5 6 7 Wert 0 2 4 6 8 10 12 14 numbers 84 Das length Attribut Das length Attribut eines Arrays name liefert die Anzahl der Elemente name.length for (int i = 0; i < numbers.length; i++) { System.out.print(numbers[i] + \" \"); } // output: 0 2 4 6 8 10 12 14 85 Das length Attribut § Das length Attribut eines Arrays name liefert die Anzahl der Elemente. name.length § Was für ein Ausdruck erlaubt den Zugriff auf: § Das letzte Element des Arrays (name)? § Das Element in der Mitte? Poll 0 1 2 3 4 0 1 2 3 4 5 Mitte ….. Index Index 86 Das length Attribut § Das length Attribut eines Arrays name liefert die Anzahl der Elemente. name.length § Was für ein Ausdruck erlaubt den Zugriff auf: § Das letzte Element des Arrays (name)? § Das Element in der Mitte? Poll 0 1 2 3 4 0 1 2 3 4 5 Mitte ….. Index Index 87 Das length Attribut § Das length Attribut eines Arrays name liefert die Anzahl der Elemente. name.length § Was für ein Ausdruck erlaubt den Zugriff auf: § Das letzte Element des Arrays (name)? name[name.length-1] § Das Element in der Mitte? name[(name.length-1)/2] 0 1 2 3 4 0 1 2 3 4 5 Mitte ….. Index Index 88 Poll 8990 Array Initialisierung § (Richtige) Programme lesen Dateien um Array zu initialisieren § Wir können einen Loop verwenden … for (int i = 0; i < 8; i++) { numbers[i] = 2 * i; } § Manchmal mühsam § Java erlaubt Initialisierung mit Konstanten 91 Array Initialisierung § type[] name = { value1, value2, …., valueN } § Deklariert und initialsiert Array name mit N Elementen § valuei : Typ muss mit type übereinstimmen int[] myIntArray = { 1, 3, 8, 4, 10, 11, 0, -2} 92 Index 0 1 2 3 4 5 6 7 Wert 1 3 8 4 10 11 0 -2 myIntArray Array Initialisierung für andere Typen § type[] name = { value1, value2, …., valueN } double[] myDoubleArray = {1.0, 0.0, 0.5, 0.99999999999}; boolean[] myBooleanArray = {true, true, true, false}; String[] myStringArray = {\"ein\", \"Versuch\"} 93 Index 0 1 2 3 Wert 1.0 0.0 0.5 0.99999999999 myBooleanArray Index 0 1 2 3 Wert true true true false myDoubleArray myBooleanArray Index 0 1 Wert \"ein\" \"Versuch\" Unser Beispiel am Anfang (Messwertanalyse) Ein Array hilft uns, dieses Programm zu schreiben Anzahl Mitglieder? 6 Groesse in cm: 165 Groesse in cm: 164 Groesse in cm: 158 Groesse in cm: 163 Groesse in cm: 169 Groesse in cm: 181 Durchschnitt in cm = 166.7 Anzahl ≥ Durchschnitt: 2 (33 %) 94 Programm // Liest Groessen, berechnet Durchschnitt, gibt Anzahl und // Prozentsatz >= Durchschnitt aus import java.util.*; public class Analyse { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"Anzahl Mitglieder? \"); int members = input.nextInt(); int[] data = new int[members]; double sum = 0.0; for (int i = 0; i < members; i++) { // Groesse einlesen System.out.print(\"Groesse in cm: \"); data[i] = input.nextInt(); sum += data[i]; } // Fortsetzung naechste Seite 95 Programm , Fortsetzung // compute results double avg = (double) sum/members; System.out.println(\"Durchschnitt in cm = \" + avg); int count = 0; for (int i = 0; i < members; i++) { if (data[i] >= avg) { count++; }; } // report results System.out.println(\"Anzahl >= Durchschnitt: \" + count + \" (\" + (double)count/members*100 + \" %)\"); // Formatierung koennte besser sein … } } 96 Diskussion § Idealerweise können wir diese Anweisungen in einer Methode organisieren § Möchten den Array der Messwerte als Parameter übergeben können § Wir ignorieren Formatierung der Ergebnisse 97 252-0027 Einführung in die Programmierung 3.0 Arrays (Reihen) Thomas R. Gross Department Informatik ETH Zürich 98 Übersicht § 3.0 Arrays § 3.1 Motivation § 3.2 Deklaration § 3.3 Arbeiten mit Arrays § 3.4 Arrays und Methoden 99 3.3 Arbeiten mit Arrays 100 Arrays § Arrays sind Objekte int[] myArray = new int[10]; § Der new Operator ist ein Hinweis § Um mit dem Array zu arbeiten brauchen wir eine neue Art von Variablen § Eine Variable die auf den Array verweist 101 Arrays § Arrays sind Objekte int[] myArray = new int[10]; § Der new Operator ist ein Hinweis § Um mit dem Array zu arbeiten brauchen wir eine neue Art von Variablen § Eine Variable die auf den Array verweist – erlaubt Zugriff (auf Elemente, Verwendung als Parameter, usw.) § myArray ist eine «Referenzvariable» («reference variable») § Genauer «Variable of reference type» § Nicht eine «primitive variable» (d.h. Variable eines Basistyps) 102 Java Variable – Referenztyp § Eine Referenzvariable (auch: «reference type variable», Variable eines Referenztyps) erlaubt den Zugriff auf einen Array int[] myArray; § myArray ist eine Referenzvariable (kann für Arrays von int Werten gebraucht werden) § Nicht für andere Arten von Arrays (dazu später mehr) § Speichert/liefert Information die Zugriff auf Array erlaubt § Nach der Deklaration gibt es noch keinen Array der Daten speichert 103 Java Variable – Referenztyp § Eine Referenzvariable erlaubt den Zugriff auf einen Array (ein Objekt) § Entweder neu erstellt (mit Deklaration) int[] myArray = new int[10]; § Oder auf existierenden Array (in Deklaration oder Zuweisung) int[] yourArray = myArray; int[] someArray; someArray = yourArray; 104 Index 0 1 2 3 4 5 6 7 8 9 Wert 0 0 0 0 0 0 0 0 0 0myArray § Durch eine Zuweisung kann eine Referenzvariable auf einen anderen Array verweisen int[] a = { 4, 3, 2, 1, 0}; int[] b = { 10, 20, 30, 40}; a = b; System.out.println(Arrays.toString(a))//a:[10, 20, 30, 40] § Die rechte Seite einer Zuweisung zu einer Referenzvariable muss auch eine Referenzvariable sein. § Der Typ der Elemente muss übereinstimmen § Die Anzahl der Elemente muss nicht übereinstimmen 106 Index 0 1 2 3 4 Wert 4 3 2 1 0 a b Index 0 1 2 3 Wert 10 20 30 40 Zugriff mit Java Referenztyp Variable § Eine Referenzvariable («reference type variable») erlaubt den Zugriff auf einen Array int[] myArray = new int[10]; § Zugriff auf den gesamten Array § z.B. als Parameter (dazu später mehr) § System.out.println(myArray); // erlaubt aber macht nicht was wir wollen .... § Zugriff auf Elemente … 109 Index 0 1 2 3 4 5 6 7 8 9 Wert 0 0 0 0 0 0 0 0 0 0 myArray Zugriff auf Elemente des Arrays … erfordert [ .. ] (mit legalem Index) (wenn Array exisitiert) myArray[1] = 99; int b = myArray[7]; System.out.println(myArray[1]); //99 [..] ist auch ein Operator (mit höchstem Rang) Sonst macht myArray[1]+1 keinen Sinn 110 Java Referenzvariable in Zuweisungen § Zuweisungen mittels der Referenzvariable für einen Array ändern die Elemente des Arrays myArray[1] = 99; Linke Seite (von =) ist keine Referenzvariable sondern die Auswahl eines Elements (das mit Index 1) welches geändert wird § Zuweisung ändert nicht die Referenzvariable myArray § Die Referenzvariable verweist (weiterhin) auf den selben Array § myArray[0] unverändert (nur Element 1 hat anderen Wert) 112 Zugriff mit Java Referenztyp Variable int[] myArray = new int[10]; myArray[1] = 99; 113 Index 0 1 2 3 4 5 6 7 8 9 Wert 0 99 0 0 0 0 0 0 0 0myArray Java Variable – Referenztyp § int[] myArray deklariert eine Referenzvariable (kann für Arrays von int Werten gebraucht werden) § Speichert/liefert Information die Zugriff auf Array erlaubt § Noch gibt es keinen Bereich der Daten speichert § Erst eine Zuweisung verknüpft Referenzvariable mit einem Array § Entweder in der Deklaration int[] myArray = new int[10]; § int[] someArray = {0, 1, 4, 9}; § Oder in separaten Schritten § int[] myArray; § myArray = new int[10]; 114 Java Variable – Referenztyp § int[] myArray deklariert eine Referenzvariable (kann für Arrays von int Werten gebraucht werden) § Erst eine Zuweisung verknüpft Referenzvariable mit einem Array § Entweder in der Deklaration int[] myArray = new int[10]; § Oder in separaten Schritten § int[] myArray; § myArray = new int[10]; § Oder durch Zuweisung eines anderen Arrays § int[] newArray = myArray; 115 Java Referenzvariable § Wir müssen unterscheiden zwischen § Zugriff auf ein Element (mittels name[index]) § Zugriff auf den Array, auf den die Referenzvariable verweist § z.B. um andere Referenzvariable zu setzen ( = name) § Referenzvariable ist eine Kurzform um zu sagen: dies ist eine Java Variable des Typs «Reference auf ….» long[] longArray; //Verweist auf Array mit long Elementen int[] intArray; //Verweist auf Array mit int Elementen 117 252-0027 Einführung in die Programmierung 3.0 Arrays (Reihen) Thomas R. Gross Department Informatik ETH Zürich 1 Bonus Übungen § Sie können (ab dem nächsten Aufgabenblatt) «Bonuspunkte» für die Basisprüfung sammeln § Bonuspunkte helfen die Note anzuheben § Maximalnote auch ohne Bonus erreichbar § Bonus erhöht die Note der Basisprüfung um maximal 0.25 § 80% (oder mehr) der Punkte für Bonusaufgaben ergeben vollen Bonus, darunter proportional angepasst 2 Bonus Übungen § Anreiz § Nur die Bonusaufgaben: riskante Strategie § Sie müssen die Aufgaben selber lösen. § Abschreiben (oder abschreiben lassen) ist unehrliches Verhalten und wird nach der ETH Disziplinarverordnung geahndet. 3 Selber lösen! § Sie können mit anderen über die Aufgaben reden. § Vielleicht zeichnen Sie eine Skizze auf eine Tafel, ein Blatt, ein Tablet … § Sie entwicklen ein Programm(segment) § Sie dürfen keine Aufzeichnungen aus dem Treffen mitnehmen § Alle Aufzeichnungen werden weggeworfen. § Sie warten (mindestens) 1 Stunde nach dem Treffen bevor Sie etwas aufschreiben § Skizzen, Entwürfe, Programmsegmente, etc. 4 Übersicht § 3.0 Arrays § 3.1 Motivation § 3.2 Deklaration § 3.3 Arbeiten mit Arrays § 3.4 Arrays und Methoden 5 3.3 Arbeiten mit Arrays 6 Java Variable – Referenztyp § Eine Referenzvariable (auch: «reference type variable», Variable eines Referenztyps) erlaubt den Zugriff auf einen Array int[] myArray; § myArray ist eine Referenzvariable (kann für Arrays von int Werten gebraucht werden) § Nicht für andere Arten von Arrays (dazu später mehr) § Speichert/liefert Information die Zugriff auf Array erlaubt § Nach der Deklaration gibt es noch keinen Platz für die Daten 7 Zugriff auf Elemente des Arrays … erfordert [ .. ] (mit legalem Index) (wenn Array exisitiert) myArray[1] = 99; int b = myArray[7]; System.out.println(myArray[1]); //99 [..] ist auch ein Operator (mit höchstem Rang) Sonst macht myArray[1]+1 keinen Sinn 9 Java Referenzvariable § Wir müssen unterscheiden zwischen § Zugriff auf ein Element (mittels name[index]) § Zugriff auf den Array auf den die Referenzvariable verweist § z.B. um andere Referenzvariable zu setzen ( = name) § Referenzvariable ist eine Kurzform um zu sagen: dies ist eine Java Variable des Typs «Reference auf ….» long[] longArray; //Verweist auf Array mit long Elementen int[] intArray; //Verweist auf Array mit int Elementen 11 § Durch eine Zuweisung kann eine Referenzvariable auf einen anderen Array verweisen int[] a = { 4, 3, 2, 1, 0}; int[] b = { 10, 20, 30, 40}; a = b; § Und wenn a nicht mehr auf diesen Array verweisen soll? § Zuweisung des besonderen Wertes null a = null; § null heisst das a auf keinen Array verweist § Nur noch b verweist jetzt auf den Array 12 Index 0 1 2 3 4 Wert 4 3 2 1 0a b Index 0 1 2 3 Wert 10 20 30 40 null § null ist der Wert einer Referenzvariable die auf keinen Array verweist. 13 int[] a = new int[10]; a[0] = 1; ✓ System.out.println(a.length); ✓ a = null; System.out.println(a.length); ✘ a[1] = 2; ✘ System.out.println(a); ✓ //null Was passiert mit dem Array {4, 3, 2, 1, 0}? Nach Zuweisung von null verweist eine Referenzvariable auf keinen Array int[] a = { 4, 3, 2, 1, 0}; int[] b = { 10, 20, 30, 40}; a = b; a = null; Wenn keine weitere Referenzvariable auf den Array verweist dann ist der Array unerreichbar § Keine direkte Auswirkung auf Programmausführung § Kann (und wird) irgendwann vom Java System entfernt werden (nicht unser Thema, abhängig von Version, Speicherplatz, Host, …) § Wir können uns auf das Erstellen eines korrekten Programms «beschränken» 14 Index 0 1 2 3 4 Wert 4 3 2 1 0a b Index 0 1 2 3 Wert 10 20 30 40 Reference Semantics § Wenn eine Referenzvariable als Operand in einer Zuweisung erscheint (x=y) dann wird der Array nicht kopiert sondern beide Variablen beziehen sich nun (verweisen nun) auf den selben Array: Reference Semantics! § Variablen x und y enthalten nun eine Referenz («reference», Verweis) auf den selben Array. Veränderungen der Elemente einer Referenzvariable bewirken eine Änderung der Werte der anderen Referenzvariable. § Aliasing: zwei (oder mehr) Referenzvariable verweisen auf den selben Array 15 3.4 Arrays und Methoden § Array Parameter § Array Rückgabe Werte 19 Filter § Schreiben Sie ein Programm(segment) das in einem Array alle Elemente < 0 auf 0 setzt § Zum Beispiel für diesen Array: [11, -42, -5, 27, 0, 89] § Sollte der gefilterte Array so aussehen: [11, 0, 0, 27, 0, 89] § Das Programm sollte für int Arrays jeder Grösse funktionieren. 20 Filter — Variante 1 § Der Array der Elemente ist sichtbar, Name der Referenzvariable numbers // filter the array numbers for (int i = 0; i < numbers.length; i++) { if (numbers[i] < 0) { numbers[i] = 0; } } 21 Filter, Verbesserte Anforderungen § Schreiben Sie (ausgehend von dem Programm Segment das einen Array filtert) eine filter Methode § Soll den Array, dessen Werte zu filtern sind, als Parameter akzeptieren. int[] numbers = {11, -42, -5, 27, 0, 89}; filter(the_numbers); 22 Filter, Verbesserte Anforderungen § Schreiben Sie (ausgehend von dem Programm Segment das einen Array filtert) eine filter Methode § Soll den Array, dessen Werte zu filtern sind, als Parameter akzeptieren. int[] numbers = {11, -42, -5, 27, 0, 89}; filter(the_numbers); § Fragen: 1. Wie schreiben wir eine Methode die einen Array als Parameter hat? 2. (Wie) Müssen wir den Inhalt des geänderten Arrays nach Verarbeitung zurück geben? 23 Array Parameter (Deklaration) return_type methodName(type[] name) § Deklaration einer Methode methodName die einen Array als Parameter akzeptiert § … und dann auch erfordert § mehrere Parameter möglich (wie bisher), auch gewöhnliche (skalare) Parameter § return_type: Typ des Rückgabewertes § Die bekannten Regeln (werden demnächst erweitert) § type: Typ der Elemente des Arrays § name: Name des formalen Parameters 24 Array Parameter (Deklaration) return_type methodName(type[] name) § Beispiel: // Returns the average of the given array of numbers int average(int[] numbers) { int sum = 0; for (int i = 0; i < numbers.length; i++) { sum += numbers[i]; } return sum / numbers.length; } 25 Array Parameter (Deklaration) return_type methodName(type[] name) § In der Deklaration steht dass ein Array Parameter gebraucht wird § Keine Angabe der Grösse § Angabe des Typs der Elemente § Obwohl die Länge des Arrays nicht in der Parameterliste erscheint so kann die Methode die Länge jedoch herausfinden § length Attribut name.length 26 Aufruf einer Methode mit Array Parameter § Wie gehabt (Aufruf einer Methode mit Basistyp Parametern) 27 Array Parameter (Aufruf) methodName(arrayName); § arrayName: Name des aktuellen Parameters § Beispiel: // figure out the average TA IQ int[] iq = {126, 84, 149, 167, 95}; int avg = average(iq); System.out.println(\"Average IQ = \" + avg); 28 Array Parameter (Aufruf) methodName(arrayName); § arrayName: Name des aktuellen Parameters § Beispiel: // figure out the average TA IQ int[] iq = {126, 84, 149, 167, 95}; int avg = average(iq); System.out.println(\"Average IQ = \" + avg); Keine [] wenn der Array übergeben wird! 29 Array Rückgabe (Deklaration) § Methoden können auch Arrays zurückgeben return_type[] methodName(ParameterListe) { return_type: Typ der Elemente des zurückgegebenen Arrays § Wieder verwenden wir ein return Statement um anzugeben, was als Ergebnis einer Methode zurückgegeben wird. 30 Array Rückgabe Beispiel // Returns a new array with two copies of each value. // Example: [1, 4, 0, 7] -> [1, 1, 4, 4, 0, 0, 7, 7] int[] duplicateElements(int[] numbers) { int[] result = new int[2 * numbers.length]; for (int i = 0; i < numbers.length; i++) { result[2 * i] = numbers[i]; result[2 * i + 1] = numbers[i]; } return result; } 31 Array Rückgabewerte § Die aufrufende Methode sollte den Rückgabewert entgegen nehmen § Dafür brauchen wir eine passende Variable return_type[] name = methodName(parameters); int[] iq = {126, 84, 149, 167, 95}; int[] iqd = duplicateElements(iq); 34 Filter, Verbesserte Anforderungen § Schreiben Sie (ausgehend von dem Programm Segment das einen Array filtert) eine filter Methode § Soll den Array, dessen Werte zu filtern sind, als Parameter akzeptieren. int[] numbers = {11, -42, -5, 27, 0, 89}; filter(the_numbers); § Fragen: 1. Wie schreiben wir eine Methode die einen Array als Parameter hat? 2. (Wie) Müssen wir den Inhalt des geänderten Arrays nach Verarbeitung zurück geben? 36 Filter – Variante 2 § Schreiben Sie (ausgehend von dem Programm Segment das einen Array filtert) eine filter Methode. § Soll den Array, dessen Werte zu filtern sind, als Parameter akzeptieren. int[] numbers = {11, -42, -5, 27, 0, 89}; int[] filteredNumbers = filter(numbers); § Antwort auf Frage 1: int[] filter (int[] inputArray) { … return resultArray; } 37 Filter – vollständige Variante 2 int[] filter (int [] numbers) { int [] filtered = new int[numbers.length]; for (int i = 0; i < numbers.length; i++) { if (numbers[i] < 0) { filtered[i] = 0; } } return filtered; } 38 Filter – vollständige Variante 2 int[] filter (int [] numbers) { int [] filtered = new int[numbers.length]; for (int i = 0; i < numbers.length; i++) { if (numbers[i] < 0) { filtered[i] = 0; } } return filtered; } § Vergisst (leider) die Werte die >= 0 sind! 39 Filter – Variante 3: Lösung mit Einschränkungen int[] filter (int[] numbers) { int[] filtered = new int[numbers.length]; for (int i = 0; i < numbers.length; i++) { if (numbers[i] < 0) { filtered[i] = 0; } else { filtered[i] = numbers[i]; } } return filtered; } 40 Diskussion § Lösung korrekt (gibt uns den gewünschten Array) § Nehmen wir an der Array hat die Länge 8’500’000 und 20 Elemente < 0 § Wie viele Zuweisungen werden ausgeführt? § Wie viele davon sind absolut notwendig? § Eine Methode möchte Elemente eines Arrays modifizieren ohne die Elemente kopieren zu müssen § Ein Beispiel von vielen … 41 Array Parameter § Wir wollen einer Methode erlauben, einen Array (oder ein Objekt) als Parameter zu erhalten ohne dass die Arrayelemente kopiert werden müssen § Wir sparen Zeit. § Wir sparen Platz. § Wir können Veränderungen («Updates») direkt («in place») vornehmen § Dann brauchen wir (evtl) auch keinen Rückgabewert 42 Wir erinnern uns: Reference Semantics § Reference Semantics: Eine Variable enthält eine Referenz («reference», Verweis) auf einen Array § Wenn eine Referenzvariable als Operand in einer Zuweisung erscheint dann wird der Array nicht kopiert sondern beide Variablen beziehen sich nun (verweisen nun) auf den selben Array. § Veränderungen der Elemente einer Referenzvariable bewirken eine Änderung der Werte der anderen Referenzvariable. 43 Übergabe eines Array Parameters § Wie eine Zuweisung int[] localA = new int[3]; int[] localB = localA; § // irgendwo: void method(int[] pA) { … } method(localA); § // beim Aufruf: int[] pA = localA; § Wie geht das? Das System kopiert die Information die besagt, wo sich der Array befindet 44 Reference Semantics § Wenn wir einen Array als Parameter übergeben kann die aufgerufene Methode den Array verändern und die Veränderungen sind für den Aufrufer sichtbar § Bei Variablen eines Basistyps (int, double, boolean, …) ist das anders 46 Filter, vollständige Lösung public static void filter (int [] numbers) { for (int i = 0; i < numbers.length; i++) { if (numbers[i] < 0) { numbers[i] = 0; } } } 47 Filter public static void filter (int[] numbers) { for (int i = 0; i < numbers.length; i++) { if (numbers[i] < 0) { numbers[i] = 0; } } } int[] numbers = {11, -42, -5, 27, 0, 89}; filter(numbers); // Nach Ende von filter: numbers ist Array mit Werten // [11, 0, 0, 27, 0, 89] 48 Array als Parameter § Wenn ein Array als Parameter übergeben wird, dann wird der Array nicht kopiert. Der Parameter verweist auf den selben (ursprünglichen) Array. § Wenn der Array modifiziert wird, dann wird auch der Array, den die aufrufende Methode sieht, verändert. 50 Array Parameter verwenden Reference Semantics § Wir sagen dass Array Parameter «by reference» übergeben werden. § Veränderungen in einer Methode werden von der aufrufenden Methode gesehen. 51 Verweise und Arrays § Arrays verwenden Reference Semantics. Warum? § Effizienz. Das Kopieren grosser Arrays kostet (zu)viel Zeit. § Programmstruktur. Es ist oft sinnvoll (und logisch) wenn verschiedene Methoden mit einem (gemeinsamen) Array arbeiten. int[] dataSet = new int[ … ]; step1(); // mit dataSet step2(); // mit dataSet § Objekte verwenden auch Reference Semantics 52 3.4 Arrays und Methoden § Array Parameter § Array Rückgabe Werte § Output eines Arrays § Invarianten – Beispiel mit Array 53 Arrays sind Objekte § … aber viele Operatoren sind für Objekte nicht definiert § Der Additionsoperator + ist nur für Strings definiert String s = \"hello\"; String t = \"world\"; s = s + \" \" + t; // \"hello world\" Scanner sc = new Scanner(System.in); Scanner ec = new Scanner(System.in); sc = sc + ec; // operator + cannot be applied § Der Multiplikationsoperator * ist auch für Strings nicht definiert s = 2 * s; // operator * cannot be applied § Auch die meisten Vergleichsoperatoren sind nicht definiert § Und Output auch nicht so wie wir es wollen 54 Arrays § Manchmal wünschen wir uns (vielleicht) dass (z.B.) + definiert ist int[] a = new int[10]; int[] b = new int[10]; a = a + b; // error if ( a >= b ) { … } // error § Aber Java unterstützt dies nicht. 56 Vergleiche von Arrays § Leider gibt es kein equals für Arrays § Wie für Strings: if (\"hello\".equals(myString)) { … } § Man kann zwei Arrays weder mit == noch mit equals vergleichen um zu prüfen ob sie die selben Elemente haben int[] a1 = {42, -7, 1, 15}; int[] a2 = {42, -7, 1, 15}; if (a1 == a2) { ... } // incorrect! if (a1.equals(a2)) { ... } // incorrect! 57 Arrays und Output § Auch für Arrays gibt es eine Default Darstellung § int[] myArray = new int[5]; § System.out.println(myArray); 58 Arrays und Output § Auch für Arrays gibt es eine Default Darstellung § int[] myArray = new int[5]; § System.out.println(myArray); § Nur leider hilft uns diese nicht weiter 59 Output I@2a139a55 Die Klasse Arrays § Die Klasse Arrays in der Bibliothek java.util enthält einige Methoden, die wir in einer static Methode aufrufen können Method name Description binarySearch(array, value) returns the index of the given value in a sorted array (or < 0 if not found) copyOf(array, length) returns a new copy of an array equals(array1, array2) returns true if the two arrays contain same elements in the same order fill(array, value) sets every element to the given value sort(array) arranges the elements into sorted order toString(array) returns a string representing the array, such as \"[42, -7, 1, 15]\" 60 Die Arrays Klasse § Syntax: Arrays.methodName(parameters) § methodName: Service den wir brauchen § parameter(s) : Ein oder mehr Parameter § Beispiel import java.util.Arrays; int[] a1 = {42, -7, 1, 15}; int[] a2 = {42, -7, 1, 15}; if (Arrays.equals(a1, a2)) { ... } 61 Arrays.toString § Arrays.toString nimmt einen Array als Parameter und liefert einen String mit den Array Elementen int[] e = {0, 2, 4, 6, 8}; e[1] = e[3] + e[4]; System.out.println(\"e is \" + Arrays.toString(e)); Output: e is [0, 14, 4, 6, 8] § Einfacher Weg String mit den Werten des Arrays zu erhalten63 3.4 Arrays und Methoden § Array Parameter § Array Rückgabe Werte § Output eines Arrays § Invarianten – Beispiel mit Array 65 Sie erinnern sich … § Methodologie wie wir Schleife und Invarianten entwickeln können § Kein vollständiges Rezept § Nicht stur zu befolgen – aber besser als der «schnelle» Weg, erst den Code zu entwickeln und dann die Invariante zu suchen. 66 Eine Methodologie § Vorschlag (funktioniert überraschenderweise oft): 1. Bestimmen Sie zuerst die Invariante und lassen Sie sie die anderen Schritte leiten (!) § Wie bringt uns jede Iteration näher an das Ziel? § Was muss nach jeder Iteration gelten? 2. Schreiben Sie einen Rumpf der die Invariante gültig lässt 3. Bestimmen Sie den Loop Test so, dass Test-ist-false die Postcondition impliziert 4. Schreiben Sie die Initialisierung so dass dieser Code die Invariante sicher stellt. 67 Beispiel Wir wollen dass max den grössten (int) Wert enthält, der in einem Array items auftritt. (int[] items) 1. Bestimmen Sie zuerst die Invariante und lassen Sie sie die anderen Schritte leiten § Invariante: max speichert den grössten Wert der Elemente 0..k-1 im Array items und items.length ≥ k ≥ 0 § Kürzen items.length mit length ab § Andere Invarianten sind auch möglich … 68 Wir wollen dass max den grössten (int) Wert enthält, der in einem Array items auftritt. 2. Schreiben Sie einen Rumpf der die Invariante gültig lässt Postcondition impliziert {inv: max holds largest value in items[0..k-1] ∧ length ≥ k ≥ 0 } while ( ) { // inv holds if (max < items[k]) { max = items[k]; // breaks invariant temporarily } else { // nothing to do } // max holds largest value in items[0..k] k = k+1; // invariant holds again } 70 Wir wollen dass max den grössten (int) Wert enthält, der in einem Array items auftritt. 3. Bestimmen Sie Loop Test so, dass Test-false die Postcondition impliziert {inv: max holds largest value in items[0..k-1] ∧ length ≥ k ≥ 0 } while (k != items.length) { // inv holds if (max < items[k]) { max = items[k]; // breaks invariant temporarily } else { // nothing to do } // max holds largest value in items[0..k] k = k+1; // invariant holds again } 71 Wir wollen dass max den grössten (int) Wert enthält, der in einem Array items auftritt. 3. Bestimmen Sie Loop Test so, dass Test-false die Postcondition impliziert {inv: max holds largest value in items[0..k-1] ∧ length ≥ k ≥ 0 } while (k != items.length) { // inv holds if (max < items[k]) { max = items[k]; // breaks invariant temporarily } else { // nothing to do } // max holds largest value in items[0..k] k = k+1; // invariant holds again } {post: k == items.length ∧ max largest … in items[0..k-1] (also: max largest value in items) } 72 Wir wollen dass max den grössten (int) Wert enthält, der in einem Array items auftritt. 4. Schreiben Sie die Initialisierung so dass dieser Code die Invariante sicher stellt. k = 1; max = items[0]; {inv: max holds largest value in items[0..k-1] ∧ length ≥ k ≥ 0 } while (k != items.length) { // inv holds … k = k+1; // invariant holds again } 74 Was muss noch gelten? § Die Initialisierung hat eine Precondition: items.length > 0 {items.length > 0} k=1; max = items[0]; {inv: max holds ... in items[0..k-1] ∧ length ≥ k ≥ 0 } while (k != items.length) { … } 75 Precondition § Es ist (je nach Situation) akzeptabel eine solche Precondition zu erfordern § Aber sie muss angegeben sein! § Oder wir brauchen eine andere Postcondition («if length is 0, …») und ein If-Statement das diesen Fall prüft § Der Gewinn für uns: Genaue Preconditions halten fest, was der Code (die Methode) vom Klienten erwartet. § Für alle lesbar … 76 Array Zusammenfassung § Reference Semantics für Arrays § Eine Zuweisung a = b; mit Referenzvariablen lässt a auf den selben Array wie b verweisen § Werte werden nicht kopiert § Das selbe gilt wenn eine Referenzvariable als Parameter übergeben wird § Die Parametervariable verweist auf den selben Array und Änderungen in der Methode sind für den Aufrufer sichtbar 77 Zur Erinnerung: Value Semantics § Parameter eines Basistyps (int, double, …) werden mit «value semantics» übergeben § Wert wird kopiert (initialisiert Parametervariable) § Änderungen des Parameters in Methode sind für Aufrufer unsichtbar int a = 1; myMethod(a); System.out.println(a); 78 public static void myMethod(int x) { x = 2*x; System.out.println(x); } Output: 2 1 Reference Semantics § Parameter eines Referenztyps (int[], …) werden mit «reference semantics» übergeben § Die Parametervariable verweist auf den selben Array/das selbe Objekt § Änderungen des Parameters in Methode sind für Aufrufer sichtbar int[] a = {1,2}; myMethod(a); System.out.println( Arrays.toString(a)); 80 public static void myMethod(int[] x) { x[0] = 9; System.out.println(Arrays. toString(x)); } Output: [9,2] [9,2] Parameter: Basistyp public static void main (String[] args) { int j = 3; int k = plusOne(j); System.out.println(j); System.out.println(k); } public static int plusOne(int k) { k = k + 1; return k; } 82 Parameter: Basistyp public static void main (String[] args) { int j = 3; int k = plusOne(j); System.out.println(j); System.out.println(k); } public static int plusOne(int k) { k = k + 1; return k; } 83 Output: 3 4 Parameter: Element eines Basistyps public static void main (String[] args) { int[] x = {2, 4, 6, 8}; int m = plusOne(x[0]); System.out.println(Arrays.toString(x)); System.out.println(x); } public static int plusOne(int k) { k = k + 1; return k; } 84 Parameter: Element eines Basistyps public static void main (String[] args) { int[] x = {2, 4, 6, 8}; int m = plusOne(x[0]); System.out.println(Arrays.toString(x)); System.out.println(m); } public static int plusOne(int k) { k = k + 1; return k; } 85 Output: [2, 4, 6, 8] 3 Parameter: Array public static void main (String[] args) { int[] x = {2, 4, 6, 8}; plusOneA(x); System.out.println(Arrays.toString(x)); } public static void plusOneA(int[] y) { for (int k=0; k<y.length; k++) { y[k]++; } } 86 Parameter: Array public static void main (String[] args) { int[] x = {2, 4, 6, 8}; plusOneA(x); System.out.println(Arrays.toString(x)); } public static void plusOneA(int[] y) { for (int k=0; k<y.length; k++) { y[k]++; } } 87 Output: [3, 5, 7, 9] Parameter: Array mit alias public static void main (String[] args) { int[] a = {2, 4, 6, 8}; int[] b = a; plusOneA(a); System.out.println(Arrays.toString(a)); System.out.println(Arrays.toString(b)); } public static void plusOneA(int[] y) { for (int k=0; k<y.length; k++) { y[k]++; } } 88 Parameter: Array mit alias public static void main (String[] args) { int[] a = {2, 4, 6, 8}; int[] b = a; plusOneA(a); System.out.println(Arrays.toString(a)); System.out.println(Arrays.toString(b)); } public static void plusOneA(int[] y) { for (int k=0; k<y.length; k++) { y[k]++; } } 89 Output: [3, 5, 7, 9] [3, 5, 7, 9] Parameter: Array (und es gibt Array mit gleichen Elementen) public static void main (String[] args) { int[] c = {2, 4, 6, 8}; int[] d = {2, 4, 6, 8}; plusOneA(c); System.out.println(Arrays.toString(c)); System.out.println(Arrays.toString(d)); } public static void plusOneA(int[] y) { for (int k=0; k<y.length; k++) { y[k]++; } } 90 Parameter: Array (und es gibt Array mit gleichen Elementen) public static void main (String[] args) { int[] c = {2, 4, 6, 8}; int[] d = {2, 4, 6, 8}; plusOneA(c); System.out.println(Arrays.toString(c)); System.out.println(Arrays.toString(d)); } public static void plusOneA(int[] y) { for (int k=0; k<y.length; k++) { y[k]++; } } 91 Output: [3, 5, 7, 9] [2, 4, 6, 8] Parameter: Array (umständlich) public static void main (String[] args) { int[] f = {2, 4, 6, 8}; plusOneArrTemp(f); System.out.println(Arrays.toString(f)); } public static void plusOneArrTemp(int[] y) { int[] t = y; for (int k=0; k<t.length; k++) { t[k]++; } } 92 Parameter: Array (umständlich) public static void main (String[] args) { int[] f = {2, 4, 6, 8}; plusOneArrTemp(f); System.out.println(Arrays.toString(f)); } public static void plusOneArrTemp(int[] y) { int[] t = y; for (int k=0; k<t.length; k++) { t[k]++; } } 93 Output: [3, 5, 7, 9] Parameter: Array (umständlich, mit Rückgabe) public static void main (String[] args) { int[] g = {2, 4, 6, 8}; int[] h = plusOneMitRueck(g); System.out.println(Arrays.toString(g)); System.out.println(Arrays.toString(h)); } public static int[] plusOneMitRueck(int[] y) { int[] t = new int[y.length]; for (int k=0; k<t.length; k++) { t[k] = y[k]+1; } return t; } 94 Parameter: Array (umständlich, mit Rückgabe) public static void main (String[] args) { int[] g = {2, 4, 6, 8}; int[] h = plusOneMitRueck(g); System.out.println(Arrays.toString(g)); System.out.println(Arrays.toString(h)); } public static int[] plusOneMitRueck(int[] y) { int[] t = new int[y.length]; for (int k=0; k<t.length; k++) { t[k] = y[k]+1; } return t; } 95 Output: [2, 4, 6, 8] [3, 5, 7, 9] Parameter: Array – was wird ausgegeben? public static void main (String[] args) { int[] g = {2, 4, 6, 8}; plusOhneEffekt(g); System.out.println(Arrays.toString(g)); } public static void plusOhneEffekt(int[] y) { int[] t = new int[y.length]; for (int k=0; k<t.length; k++) { t[k] = y[k]+1; } y = t; } 96 Poll Output: [? , ? , ? , ? ] Parameter: Array – was wird ausgegeben? public static void main (String[] args) { int[] g = {2, 4, 6, 8}; plusOhneEffekt(g); System.out.println(Arrays.toString(g)); } public static void plusOhneEffekt(int[] y) { int[] t = new int[y.length]; for (int k=0; k<t.length; k++) { t[k] = y[k]+1; } y = t; } 97 Poll Output: [2, 4, 6, 8] Parameter: Array – aber ohne Wirkung public static void main (String[] args) { int[] g = {2, 4, 6, 8}; plusOhneEffekt(g); System.out.println(Arrays.toString(g)); } public static void plusOhneEffekt(int[] y) { int[] t = new int[y.length]; for (int k=0; k<t.length; k++) { t[k] = y[k]+1; } y = t; } 98 Output: [2, 4, 6, 8] Index 0 1 2 3 Wert 2 4 6 8 Index 0 1 2 3 Wert 0 0 0 0 Index 0 1 2 3 Wert 3 5 7 9 PollParameter: Array – aber ohne Wirkung public static void main (String[] args) { int[] g = {2, 4, 6, 8}; plusOhneEffekt(g); System.out.println(Arrays.toString(g)); } public static void plusOhneEffekt(int[] y) { int[] t = new int[y.length]; for (int k=0; k<t.length; k++) { t[k] = y[k]+1; } y = t; } 99 Output: [2, 4, 6, 8] Index 0 1 2 3 Wert 2 4 6 8 Index 0 1 2 3 Wert 3 5 7 9 Poll 252-0027 Einführung in die Programmierung 4.0 Klassen und Objekte Thomas R. Gross Department Informatik ETH Zürich 103 Übersicht Verwandte Themen: § 3.0 Arrays § 4.0 Klassen und Objekte Wichtig um «interessante» Programme zu schreiben: § 5.0 Input/Output 104 4.0 Klassen und Objekte: Übersicht 4.1 Klassen und Objekte (allgemein) 4.2 Objekte als Parameter 4.3 Klassen (selber entwickeln) 4.4 Attribute 4.5 Klassen und ihre Klienten 4.6 Methoden 4.7 Konstruktoren 4.8 Sichtbarkeit von Attributen 4.9 static Methoden und Variable 105 4.1 Klassen (und Objekte) § Klassen können in Java für verschiedene Zwecke verwendet werden 1. Implementation eines Algorithmus oder einer «Application» § Bietet «Service» (Dienst) an (Application ist ein Anwendungsprogramm) – bisheriger Einsatz von Klassen 2. Implementation verschiedener (zusammenhängender) Dienste in einer Java Bibliothek § Beispiel: Scanner 3. Von uns entwickelte Dienste § Keine strikte Trennung (z.B. zwei Dienste die durch Parameter ausgewählt werden, von uns entwickelte Java Bibliothek) 106 Drei Verwendungen von Klassen § Klasse die wir selbst entwickeln um ein (einfaches) Problem zu lösen § Methode main wird ausgeführt § Evtl. mit weiteren (public static) Methoden § Klassen die wir in einer Bibliothek finden § Z.B. Scanner, Arrays, … § Klassen die wir (später) selbst entwickeln § Um eigene Dienste zu entwickeln § Möglichkeit Werte über das Ende einer Methode hinaus zu bewahren107 Klassen § Eine Klasse (deklariert als class Name) erlaubt uns einen Algorithmus zu implementieren § Methode main fängt an, ruft ggf. andere Methoden auf § Parameter: Lösung/Methode wird angepasst § Rückgabewert: Zerlegung in Teilprobleme § Methode main liefert Antwort (z.B. Ausgabe auf Konsole) § Keyword public (in public class Name) wird später eine Rolle spielen § Klasse enthält Programm 108 Dienste von Klassen § «Namenloser» Dienst § Klasse wird geladen/ausgeführt § In Eclipse oder von der Shell aus § Ruft automatisch main auf § Klassenname ist Name des Dienstes/Service § Sinnvoll für Aufruf im IDE, Betriebssystem, Shell, … § Namenlos weil Dienst keinen eigenen Namen hat § Mit Namen ausgewählter Dienst (in Bibliothek) § Beispiele: nextInt(), nextString(), println(), toString() § Brauche Klassennamen oder Objekt, mit dot Notation (z.B., console.nextInt(), Arrays.toString(...) ) 109 Ein anderer Blick § Dienste Blick: Scanner stellt Dienst(e) zur Verfügung § Brauche ein Scanner Objekt um Dienst aufzurufen § Scanner console = new Scanner(System.in); § int x = console.nextInt(); § Daten Blick: Für Scanner Objekte sind Operationen definiert, für System.out sind Operationen definiert (z.B. println(...)) § Scanner Objekt und System.out müssen bestimmten Zustand haben § Müssen Daten für jedes Objekt speichern 110 Zustand plus Operationen: Typ § Ein (Daten)Typ beschreibt (bzw. bestimmt) zulässige Operationen und zulässige Werte § Basistyp int: arithmetische Operatoren, Umwandlung in Strings, keine Division durch 0 § Typ String: + Operator, neue Strings durch toUpperCase() § Type int[] (int Array): Zugriff auf Elemente, Abfrage der Länge 111 Klassen beschreiben einen Typ § Typen beschreiben Eigenschaften von Daten § Ein Typ beschreibt eine Menge (oder Kategorie) von Daten Werten. § Bestimmt (beschränkt) die Operationen, die mit diesen Daten gemacht werden können § Bisher einige Beispiele von (Daten)typen: Strings, Arrays, Scanner § Basistypen (ganze Zahlen, reelle Zahlen, boolesche Werte) beschreiben Typ ohne Klasse § «Eingebaut», mit «üblichen» Operationen 112 Objekte § Der Begriff «Objekt» ist der Sammelbegriff für alle Datenwerte, die durch (irgend) eine Klasse beschrieben werden. § Ein Scanner ist ein Objekt, ein Zufallszahlengenerator ist ein Objekt, …, ein String ist ein Objekt, ein Array ist ein Objekt, … § Wenn wir uns auf ein Objekt beziehen sprechen wir (manchmal) von einem Objektexamplar (kurz: Exemplar) § Bevor ein Programm mit einem Objekt(exemplar) arbeiten kann muss dieses erst erschaffen («erstellt», «instanziert») werden. 113 Objekt Erstellung § Bevor ein Programm mit einem Objekt arbeiten kann muss dieses erst erschaffen werden. § Das kann mit dem new Operator geschehen Scanner console; console = new Scanner(System.in); Random rand; // Zufallszahlengenerator rand = new Random(); § Das kann durch eine Initialisierung geschehen String s =\"hello world\"; int[] myA = {1, 3, 4, 9}; 114 Strings § Auch Strings könn(t)en mit new Operator erstellt werden § String s = new String(\"hello world\"); § Das ist aber nicht empfohlen § Warum? Kurze Antwort: weil Strings besonders (optimiert) behandelt werden. § Lange Antwort: später 116 Arbeiten mit Objekten § Eine Referenzvariable bezieht sich auf ein Objekt § z.B. einen Array § z.B. einen String § z.B. einen Scanner § Wir brauchen eine Referenzvariable um mit dem Objekt arbeiten zu können § z.B. um eine Methode auszuführen (Strings, Arrays, …) § z.B. um auf ein Element zuzugreifen ([ ] Operator für Arrays) § z.B. um mit einem Operator zu arbeiten (+ für Strings) § z.B. um Objekt als Parameter zu übergeben 117 4.2 Objekte als Parameter § Was wir für Array Parameter gelernt haben gilt auch für (andere) Objekte 118 Objekte als Parameter § Objekte können an eine Methode als Parameter übergeben werden § Die üblichen Regeln gelten (Parameter muss deklariert werden, wenn ein Parameter deklariert ist dann muss er übergeben werden) § Es wird eine Referenzvariable übergeben § Reference Semantics! 119 Beispiel: Scanner als Parameter Wenn mehrere Methoden Input lesen wollen, deklarieren Sie einen Scanner in main und übergeben ihn an andere Methoden als Parameter. public static void main(String[] args) { Scanner console = new Scanner(System.in); int sum = readSum3(console); System.out.println(\"The sum is \" + sum); } // Prompts for 3 numbers and returns their sum. public static int readSum3(Scanner console) { System.out.print(\"Type 3 numbers: \"); int num1 = console.nextInt(); int num2 = console.nextInt(); int num3 = console.nextInt(); return num1 + num2 + num3; } 120 Random Beispiel § Schreiben Sie ein Programm das in der 1. Primarschulklasse zum Rechnenüben verwendet werden kann. 4 + 10 + 3 + 10 = 27 9 + 2 = 11 8 + 6 + 7 + 9 = 25 Wrong! The answer was 30 5 + 9 = 13 Wrong! The answer was 14 4 + 9 + 9 = 22 3 + 1 + 7 + 2 = 13 4 + 2 + 10 + 9 + 7 = 42 Wrong! The answer was 32 You earned 4 total points. § Es sollen Rechnungen mit 2-5 Zahlen zwischen 1 und 10 gelöst werden. § Es gibt 1 Punkt für eine korrekte Antwort, 0 für eine falsche. § Das Programm terminiert nach 3 falschen Antworten. 121 Die Java Random Klasse random {adjective} zufällig willkürlich [wahllos] zufallsbedingt Zufalls- dem Zufall überlassen (aus E-D Wörterbuch) 122 Die Java Random Klasse § Die Random Klasse liefert einen Zufallszahlengenerator § Pseudozufallszahlen. § Klasse Random ist auch in java.util. import java.util.Random; Method name Description nextInt() returns a random integer nextInt(max) returns a random integer in the range [0, max) in other words, 0 to max - 1 inclusive nextDouble() returns a random real number in the range [0.0, 1.0) 123 Die Java Random Klasse § Beispiel: import java.util.Random; Random rand = new Random(); int randomNumber = rand.nextInt(10); // 0-9 Method name Description nextInt() returns a random integer nextInt(max) returns a random integer in the range [0, max) in other words, 0 to max - 1 inclusive nextDouble() returns a random real number in the range [0.0, 1.0) 124 Erzeugen von Zufallszahlen § Häufig brauchen wir (ganze) Zufallszahlen zwischen 1 und N int n = rand.nextInt(20) + 1; // 1-20 inclusive § Um eine ganze Zahl in irgendeinem Interval [min, max] zu bekommen (inklusive Grenzen): name.nextInt(size of range) + min; // name Zufallszahlengenerator mit (size of range) == (max - min + 1) § Beispiel: Eine zufällige ganze Zahl zwischen 4 und 10 einschliesslich: int n = rand.nextInt(7) + 4; 125 Fragen zu Random Mit dieser Deklaration Random rand = new Random(); wie würden Sie erhalten? 1. Eine zufällige ganze Zahl zwischen 1 und 47 einschliesslich? int random1 = rand.nextInt(47) + 1; 2. Eine zufällige ganze Zahl zwischen 23 und 30 einschliesslich? int random2 = rand.nextInt(8) + 23; 3. Eine zufällige ganze gerade Zahl zwischen 4 and 12 einschliesslich? int random3 = rand.nextInt(5) * 2 + 4; 127 Random und andere Basistypen § Die Methode nextDouble liefert eine reelle Zahl (double) zwischen 0.0 und 1.0 § Beispiel: eine zufällige Note zwischen 1.0 and 6.0: double randomGrade = rand.nextDouble() * 5.0 + 1.0; § Jede Menge von Werten kann auf die ganzen Zahlen abgebildet werden 128 Frage zu Random § Schreiben Sie ein Programm um das Rollen zweier Würfel (mit je 6 Seiten) zu simulieren bis die Summe der Würfel 7 ergibt. 2 + 4 = 6 3 + 5 = 8 5 + 6 = 11 1 + 1 = 2 4 + 3 = 7 Sie haben nach 5 Versuchen gewonnen! 130 Lösung // Rolls two dice until a sum of 7 is reached. import java.util.*; public class Dice { public static void main(String[] args) { Random rand = new Random(); int tries = 0; int sum = 0; while (sum != 7) { int dice1 = rand.nextInt(6) + 1; // roll the dice once int dice2 = rand.nextInt(6) + 1; sum = dice1 + dice2; System.out.println(dice1 + \" + \" + dice2 + \" = \" + sum); tries++; } System.out.println(\"Sie haben nach \" + tries + \" Versuchen gewonnen!\"); } } 131 do/while Lösung // Rolls two dice until a sum of 7 is reached. import java.util.*; public class Dice { public static void main(String[] args) { Random rand = new Random(); int tries = 0; int sum; do {int dice1 = rand.nextInt(6) + 1; // one roll int dice2 = rand.nextInt(6) + 1; sum = dice1 + dice2; System.out.println(dice1 + \" + \" + dice2 + \" = \" + sum); tries++; } while (sum != 7); System.out.println(\"Sie haben nach \" + tries + \" Versuchen gewonnen!\"); } } 132 252-0027 Einführung in die Programmierung 4.0 Klassen und Objekte Thomas R. Gross Department Informatik ETH Zürich 1 4.0 Klassen und Objekte: Übersicht 4.1 Klassen und Objekte (allgemein) 4.2 Objekte als Parameter 4.3 Klassen (selber entwickeln) 4.4 Attribute 4.5 Klassen und ihre Klienten 4.6 Methoden 4.7 Konstruktoren 4.8 Sichtbarkeit von Attributen 4.9 static Methoden und Variable 2 4.3 Klassen (selber entwickeln) § Motivation § Objekt-orientiertes Programmieren (OOP) 13 Arrays und ihre Grenzen (für Software Entwurf) § Sie haben ein Programm, das für einen Verein die Körpergrösse (cm) von verschiedenen Personen einliest. § Erste Eingabe gibt an für wie viele Personen wir die Daten erheben wollen § Jetzt wollen wir zusätzlich das Gewicht (kg) einlesen § Sonst ist das Format nicht verändert § Könnte so aussehen: 16 Anzahl Mitglieder? 6 Groesse in cm: 165 Gewicht in kg: 52 Groesse in cm: 164 Gewicht in kg: 56 Groesse in cm: 158 … § Diese Daten wollen wir analysieren, z.B. prüfen wie weit Gewicht und Grösse von einander abhängig sind, oder den Durchschnitt berechnen, … § Also lesen wir die Daten ein … 17 Eine (schlechte) Lösung ... Scanner input = new Scanner(System.in); System.out.print(\"Anzahl Mitglieder? \"); int personCount = input.nextInt(); int[] height = new int[personCount]; int[] weight = new int[personCount]; for (int i = 0; i < personCount; i++) { System.out.print(\"Groesse in cm: \"); // read each person height[i] = input.nextDouble(); System.out.print(\"Gewicht in kg: \"); weight[i] = input.nextDouble(); } ... 19 Warum ist diese Lösung schlecht? § Zwei Arrays die «parallel» sind § Leicht die Übersicht zu verlieren § Wenn wir z.B. die Personen nach ihrer Grösse sortieren wollen müssen wir aufpassen, dass wir den Bezug zwischen Höhe und Gewicht nicht verlieren § Was wenn wir mehr als 2 Dimensionen haben ? § Adressen § Geschlecht § … § Dies ist ein Beispiel einer häufig auftretenden Situation 21 Ein ähnliches Problem § Gegeben sei eine Datei mit den (X, Y) Schweizer Landes- koordinaten von Orten; erster Wert gibt die Anzahl der Orte an: 4 2 679 520 1 212 273 Rigi 2 683 740 1 247 853 Zuerich (ETH HG) 2 617 036 1 091 691 Matterhorn 2 686 163 1 157 017 Gotthard (Pass) § Schreiben Sie ein Programm, das für ein Tiefdruckgebiet mit Zentrum (X,Y) bestimmt in welchen Orten es regnen wird Zentrum X Koordinate? 2653891 Zentrum Y Koordinate? 1156900 Ausdehnung Tiefdruckgebiet? 7500 22 Scanner input = new Scanner(…); int locCount = input.nextInt(); int[] xCoords = new int[locCount]; int[] yCoords = new int[locCount]; for (int i = 0; i < locCount; i++) { xCoords[i] = input.nextInt(); // read each location yCoords[i] = input.nextInt(); } ... 23 Beobachtungen § Die Daten im 1. Fall beschreiben eine Gruppe von Personen § Sie sollten als Personen Objekte gespeichert werden § Die Daten im 2. Fall beschreiben eine Menge von Punkten § in der (X,Y) Ebene (oder ggf. (X,Y,Z) Raum wenn wir Höheninfo haben) § Die Daten sollten besser als Punkt Objekte («TopoPoint» Objekte) gespeichert werden § Die Objekte speichern die Informationen für einen Ort/eine Person 24 Beobachtungen § Ein Person Objekt: § Speichert das Gewicht einer Person § Speichert die Grösse einer Person § Wir können Personen vergleichen § Wir können die Grösse (in cm) in andere Einheiten (Zoll) umrechnen 25 Beobachtungen § Ein TopoPoint Objekt: § Speichert die (X, Y) Koordinaten eines Ortes in Schweizer Landeskoordinaten § Könnte weitere Werte speichern (Höhe ü. M.) § Wir könnten den Abstand zu einem anderen Ort berechnen (z.B. um zu prüfen ob sich ein Tiefdruckgebiet über dem Ort befindet). § Wenn wir eine Landkarte zeichnen wollen, dann wüsste jeder TopoPoint wie/wo er gezeichnet werden soll. 26 Beobachtungen § Programme, die mit Personen (Punkten) arbeiten, könnten einfacher und kürzer werden. § Gibt es Unterschiede zwischen den beiden Problemen? 27 Klassen und Objekte § Klasse («class»): Eine Programm Einheit mit der wir entweder: 1. Einen namenlosen Service implementieren können (via main(..)) 2. Eine neue Art (neuen Typ) von Objekten beschreiben können Die Klassen Random und Scanner sind Beispiele § Random beschrieb ein Objekt, das Zufallszahlen erstellt (musste mit new erschaffen werden) § Scanner beschrieb ein Objekt, das Eingabe von einer Datei, der Konsole, … erlaubt (musste mit new erschaffen werden) § Objekte sind Exemplare einer Klasse mit Wert(en) und erlauben Operationen 28 Klassen und Objekte § Klasse («class»): Eine Programm Einheit mit der wir entweder: 1. Einen namenlosen Service implementieren können (via main(..)) 2. Eine neue Art (neuen Typ) von Objekten beschreiben können Die Klassen Random und Scanner sind Beispiele § Objekt («object»): Ein Gebilde das Zustand («state») und Verhalten («behavior») verbindet § Stellt Services zur Verfügung (Scanner: nextInt(); Random: nextInt()) 29 Klassen und Objekte § Objekt-orientiertes Programmieren («OOP»): Ein Programmiermodel das ein Programm als eine Menge von aufeinander einwirkenden Objekten organisiert. § Objekte «interagieren» – ein Objekt ruft Methoden (Services) eines anderen Objektes auf, die dann Werte zurückliefern § und/oder stellt Methoden (Services) zur Verfügung die seinen Zustand verändern (können) und/oder Werte zurückliefern § Sehr allgemein – deckt Strings und Scanner ab 31 Klassen und Objekte § Klasse («class»): Eine Programm Einheit mit der wir entweder: 1. Einen namenlosen Service implementieren können (via main(..)) 2. Eine neue Art (neuen Typ) von Objekten beschreiben können. § Objekt («object»): Ein Gebilde das Zustand («state») und Verhalten («behavior») verbindet. § Klasse ist die Vorlage (Mustervorlage, Schablone) die Objekte beschreibt § Objekt wird gemäss Vorlage erschaffen 32 Klassen und Objekte § Klasse beschreibt die Form/Funktionalität von Objekten § Objekte sind Exemplare («instances») einer Klasse § Manche Autoren sprechen von Objektinstanzen (statt Objekt) § Wird ein Objekt erschaffen spricht man dann von der Instanziierung § Die Menge aller Objekte einer Klasse bilden einen Typ § Man kann sich auch OOP ohne Klassen vorstellen, aber viele Programmiersprachen (Java, C++, C#) sind klassenbasiert. 33 Objekt-orientiertes Programmieren § In der Entwicklung eines Software Systems § In der Modellierung «realer» Situationen 34 Objekt-orientiertes Programmieren § In der Entwicklung eines Software Systems § Beispiel: Input mit Scanner § Scanner Objekt wird erstellt, entsprechend Parametern § In der Modellierung «realer» Situationen § Beispiel: Push Broadcast zu (Gruppe von) Smartphones § Modellierung eines Netzes von Smartphones § Modellierung jedes Geräts 35 § Wenn wir einen Scanner konstruieren dann wird dieser für unsere Anforderungen «hergestellt» § Scanner (in /java/util) ist die allgemeine Beschreibung § Scanner(System.in) oder Scanner(myFile) sind spezielle Scanner § Wenn wir ein Netzwerk modellieren dann wird für jeden Knoten (Smartphone) ein entsprechendes Objekt erstellt § Es gibt eine (allgemeine) Beschreibung für Smartphones § Jedes Smartphone ist anders konfiguriert 39 Vorlagen SmartPhone Vorlage (Muster) Zustand: Position Erreichbare Nachbarn Verbleibende Batterieladung Verhalten: Ein/Ausschalten Update Nachbarn Liste Kommunikation (Snd, Rec) Phone #1 Zustand: Postion=120,6540 Nachbarn: {#2} Batterie = 2.5 hrs Verhalten: Ein/Ausschalten Update Nachbarn Liste Kommunikation (Snd, Rec) Phone #2 Zustand: Postion=310,5740 Nachbarn: {#1,#3} Batterie = 3.41 hrs Verhalten: Ein/Ausschalten Update Nachbarn Liste Kommunikation (Snd, Rec) Phone #3 Zustand: Postion=220,6088 Nachbarn: {#2} Batterie = 1.8 hrs Verhalten: Ein/Ausschalten Update Nachbarn Liste Kommunikation (Snd, Rec) produziert 40 Bilder von Shritwod in der Wikipedia auf Englisch, CC BY-SA 3.0,https://commons.wikimedia.org/w/index.php?curid=10767220 Kommunikation ohne Base Stations § Sende Nachrichten zu Nachbar(n) § Nachbar(n) leitet/leitet weiter § Bis zum Ziel § .... 41 Vorlagen § Nicht alle Details sind relevant § Smartphone Farbe § Wir wollen Kommunikationssoftware entwickeln § Was ist wichtig? § (Teil) des Verhaltens § Was ist unwichtig? § Wie ein Smartphone hergestellt wird § Wie ein Smartphone konfiguriert wird 42 Abstraktion § Abstraktion: Eine reduzierte Beschreibung (lässt irrelevante Details weg) § Wir können (viele) Gegenstände benutzen ohne zu wissen, wie sie genau funktionieren. § Auch beim Verhalten eines Objektes interessiert uns nur was für einen Service das Objekt anbietet, nicht wie er implementiert ist. § Abstraktionen sind nicht falsch (oder richtig): sie sind nützlich oder nicht § LED Lampe: Lichtquelle § LED Lampe: Halbleiter mit ohmschen Widerstand 43 Abstraktion § Abstraktion für einen Knoten (Smartphone): § Sie verstehen sein Benutzerverhalten (Schalter, Regler, Bildschirm) § Sie verstehen nicht die interne Organisation, die Programme (MPEG), etc. 44 Die 1. Aufgabe § Wir wollen eine einfache Point Klasse programmieren um zu lernen, wie Klassen definiert werden. § Punkte in einer 2-d Ebene § Wir werden einen Typ von Objekten definieren den wir Point nennen. § Jedes Point Objekt wird die x/y Koordinaten als Attribut («attribute», «fields») speichern (Zustand des Punktes) § Das Verhalten jedes Point Objektes wird durch Methoden («methods») beschrieben. 45 Point Objekte § Point Objekte können von anderen Programmen verwendet werden § «Andere Programme»: beschrieben durch Klassen (siehe (1) und (2)) § «verwendet»: rufen Methoden auf, erstellen Point Objekte -- um ein Objekt zu verwenden müssen wir es erreichen können § Programme die Point Objekte verwenden heissen Klienten («client programs») der Point Klasse. § Später werden wir sehen dass auch die Point Klasse Point Objekte verwenden kann (Point ist Klient von Point) 46 Arbeiten mit Point Objekten § Wir brauchen eine Variable § Referenzvariable § Muss deklariert sein vor Verwendung § Verweist auf Point Objekt § (Haben uns entschieden diese Objekte Point zu nennen) § Beispiele für Deklaration Point p1; Point home; 47 § Deklaration macht Namen (der Referenzvariable) bekannt § Brauchen ein Exemplar wenn wir damit arbeiten wollen § Erstellen durch new Operator § Beispiel Point p1 = new Point(); //Kombination Deklaration und Erstellen Point home; p1 = new Point(); 48 § Deklaration macht Namen (der Referenzvariable) bekannt § Brauchen ein Exemplar wenn wir damit arbeiten wollen § Erstellen durch new Operator § Analog arbeiten mit Arrays Point p1 = new Point(); int[] a = new int[10]; Point home; int[] b; p1 = new Point(); b = new int[12]; 49 Zustand plus Operationen: Typ § Ein (Daten)Typ beschreibt (bzw. bestimmt) zulässige Operationen und zulässige Werte § Type int[] (int Array): Zugriff auf Elemente, Abfrage der Länge § Type Point: Zugriff auf x/y Koordinaten, Verschieben eines Punktes, Spiegelung, Abstand zwischen zwei Point Objekten (die zwei Punkte einer 2-d Ebene modellieren) 50 Point Objekte (erwünschte Zustände) Point p1 = new Point(); Point p2 = new Point(); // origin, (0, 0) § Daten für jedes Point Objekt: § Muss diese für jedes Objekt speichern (irgendwie) § Aufgabe der Klasse Attribut Name Beschreibung x x – Koordinate des Punktes y y – Koordinate des Punktes 52 Attribut Wert x ? y ? p1 Referenzvariable (kann auf Point Exemplare verweisen) Point Objekte (erwünschte Zustände) Point p1 = new Point(); p1.x = 5; new Point( p1.y = 2; § Daten für jedes Point Objekt: § Muss diese für jedes Objekt speichern (irgendwie) § Aufgabe der Klasse Attribut Name Beschreibung x x – Koordinate des Punktes y y – Koordinate des Punktes 53 Attribut Wert x 5 y 2 p1 Referenzvariable (kann auf Point Exemplare verweisen) Point Objekte (erwünschte Zustände) Point p1 = new Point(5, 2); Point p2 = new Point(); // was für Werte? § Daten für jedes Point Objekt: 55 Attribut Name Beschreibung x x – Koordinate des Punktes y y – Koordinate des Punktes Point Objekte (erwünschte Zustände) Point p1 = new Point(5, 2); Point p2 = new Point(); // was die Point Klasse // voreingestellt hat § Daten für jedes Point Objekt: 56 Attribut Name Beschreibung x x – Koordinate des Punktes y y – Koordinate des Punktes Point Objekte (erwünschte Zustände) Point p1 = new Point(5, 2); Point p2 = new Point(); // Origin (0,0) § Daten für jedes Point Objekt: 57 Attribut Wert x 0 y 0 p2 Referenzvariable (kann auf Point Exemplare verweisen) Attribut Name Beschreibung x x – Koordinate des Punktes y y – Koordinate des Punktes Point Objekte (erwünschtes Verhalten) § Methoden für jedes Point Objekt: Methoden Name Bechreibung setLocation(x, y) Setze die x und y Koordinaten dieses Punktes auf diese Werte translate(dx, dy) Verändere die x und y Koordinaten des Punktes um diese Werte distance(p) Wie weit ist der Punkt p von diesem Punkt entfernt draw(g) Zeichne den Punkt auf einer 2-d Fläche g 60 Attribut Name Beschreibung x x – Koordinate des Punktes in Schweizer Landeskoordinaten y y – Koordinate des Punktes in Schweizer Landeskoordinaten TopoPoint Objekte TopoPoint Zurich = new TopoPoint(2683779, 1247994); TopoPoint origin = new TopoPoint(); // new TopoPoint(2600000, 1200000) § Ähnliche Attribute, aber andere Defaultwerte 62 TopoPoint Objekte (Verhalten) § Methoden für jedes Point Objekt: Methoden Name Bechreibung setLocation(x, y) Setze die x und y Koordinaten dieses Punktes auf diese Werte translate(dx, dy) Verändere die x und y Koordinaten des Punktes um diese Werte distance(p) Wie weit ist der Punkt p von diesem Punkt entfernt draw(g) Zeichne den Punkt auf einer 2-d Fläche g 63 Point Klasse als Vorlage Point class Zustand: int x, y Verhalten: setLocation(int x, int y) translate(int dx, int dy) distance(Point p) draw(Graphics g) Point object #1 Zustand: x = 5, y = -2 Verhalten: setLocation(int x, int y) translate(int dx, int dy) distance(Point p) draw(Graphics g) Point object #2 Zustand: x = -245, y = 1897 Verhalten: setLocation(int x, int y) translate(int dx, int dy) distance(Point p) draw(Graphics g) Point object #3 Zustand: x = 18, y = 42 Verhalten: setLocation(int x, int y) translate(int dx, int dy) distance(Point p) draw(Graphics g) 64 Klassen und Objekte § Klasse («class»): Eine Programm Einheit mit der wir entweder: 1. Einen namenlosen Service implementieren können (via main(..)) 2. Eine neue Art (neuen Typ) von Objekten beschreiben können. § Objekt («object»): Ein Gebilde das Zustand («state») und Verhalten («behavior») verbindet. § Klasse ist die Vorlage (Mustervorlage, Schablone) die Objekte beschreibt § Objekt wird gemäss Vorlage erschaffen 66 Klassen und Objekte § Klasse («class»): Eine Programm Einheit mit der wir entweder: 1. Einen namenlosen Service implementieren können (via main(..)) 2. Eine neue Art (neuen Typ) von Objekten beschreiben können. § Objekt («object»): Ein Gebilde das Zustand («state») und Verhalten («behavior») verbindet. § Klasse ist die Vorlage (Mustervorlage, Schablone) die Objekte beschreibt § Objekt wird gemäss Vorlage erschaffen § Vorlage beschreibt Werte: Zustand (Attribute) § Vorlage beschreibt Verhalten: Operationen (Methoden) 67 4.4 Attribute Copyright (c) Pearson 2013. and Thomas Gross 2016 All rights reserved. 68 Zustand eines Objekt: Attribute 69 Point Klasse, Version 1 public class Point { int x; int y; } § Dieser Code muss in einer Datei mit Namen Point.java abgelegt werden. § Dieser Code definiert einen neuen Typ mit Namen Point. § Jedes Point Objekt enthält zwei Daten: eine ganze Zahl (int) mit Namen x, und eine ganze Zahl (int) mit Namen y. § Für Point Objekte haben wir (noch) kein Verhalten definiert. 70 Point Klasse, Version 1 public class Point { int x; int y; } § Dieser Code muss in einer Datei mit Namen Point.java abgelegt werden. § Dieser Code definiert einen neuen Typ mit Namen Point. § Jedes Point Objekt enthält zwei Daten: eine ganze Zahl (int) mit Namen x, und eine ganze Zahl (int) mit Namen y. § Für Point Objekte haben wir (noch) kein Verhalten definiert. 71 Attribute jedes Point Objektes Referenzvariable für Point Objekte § Um auf Point Objekte zugreifen zu können brauchen wir eine Referenzvariable § Die Deklaration der Referenzvariable legt den Typ der Objekte fest, auf die mittels dieser Variable zugegriffen werden kann § Typ hier: Klasse § Beispiel Point p1; § Exemplar der Klasse wird mit new Operator konstruiert home = new Point(); 73 Attribute § Attribute («field»): Eine Variable innerhalb eines Objektes die Teil des Objekt Zustandes ist. (Manchmal auch Objektattribut genannt.) § Jedes Objekt hat seine eigene Kopie jedes Attributes. § Syntax für Deklaration: § Wie für Variable in Methoden type name; 75 Attribute § Attribute («field»): Eine Variable innerhalb eines Objektes die Teil des Objekt Zustandes ist. (Manchmal auch Objektattribut genannt.) § Beispiel: public class Student { String name; // each Student object has a double notenDS; // name and grade avg. field } 76 Zugriff auf Attribute § Andere Klassen können auf die Attribute eines Objektes mittels Referenzvariable zugreifen (lesen oder verändern) § Zugriff (Lesen): variable.attribut § Verändern: variable.attribut = value; § Beispiel (in einer Methode einer beliebigen Klasse): Point p1 = new Point(); Point p2 = new Point(); System.out.println(\"the x-coord is \" + p1.x); // access p2.y = 1290130; // modify 77 Zugriff auf Attribute § Andere Klassen können auf die Attribute eines Objektes mittels Referenzvariable zugreifen (lesen oder verändern) § Zugriff (Lesen): variable.attribut § Verändern: variable.attribut = value; § Wir sagen «die (Referenz)Variable wird dereferenziert» (um auf ein Attribut zuzugreifen bzw. eine Methode aufzurufen) § «Dot Notation» – Referenzvariable . (Punkt, dot) Attribut 79 Zugriff auf Attribute: Länge eines Arrays § Sie errinnern sich: jeder Array (ein Objekt – aber ohne Klasse!) hat das Attribut length, welches die Länge angibt § int [] myArray; § Zugriff (Lesen): myArray.length § Verändern: nicht möglich § Wir sagen «die (Referenz)Variable myArray wird «dereferenziert» (um auf das Attribut length zuzugreifen) § «Dot Notation» – Referenzvariable . (Punkt, dot) Attribut 80 Arbeiten mit Objekten § Konkretes Objekt erstellt nach Vorlage in Klasse § Objektinstanz, Instanz (\"instance\") § Exemplar der Klasse § Zugriff auf Attribute nur möglich wenn es Exemplar gibt § Klasse ist die Vorlage § Daher können in der Klasse keine Anweisungen sein (ausser für Initalisierung und in Methoden) § Operator new erstellt Exemplare § Referenz auf konkretes Objekt 81 Arbeiten mit Objekten (Zusammenfassung) § new liefert Verweis («Reference») auf Exemplar § Kann in einer Variable gespeichert werden Point p = new Point(); § Wir sagen dass p eine Referenzvariable («reference variable») ist. § Genauer: p ist eine Variable eines Referenztyps § Im Gegensatz zu Variablen eines Basistypes (eingebauten Typs) § Zugriff auf Objektattribute via Referenzvariable § «Dot Notation» int z = p.x; // p refers to a Point, see above 82 Reference Semantics § Für Reference Variables gelten die Reference Semantics Regeln Point p1 = new Point(); p1.x = 3; p1.y = 2; Point p2 = p1; // p2.x == 3, p2.y == 2 p2.x = 4; // p2.x == 4, p2.y == 2 // p1.x == 4, p2.y == 2 § Für Objekte wie für Arrays 83 Attribut Wert x 3 y 2 Attribut Wert x 4 y 2 Reference Semantics § Wir brauchen einen Weg, eine Reference Variable zurückzu- setzen Point p1 = new Point(); p1.x = 3; p1.y = 2; Point p2 = p1; // p2.x == 3, p2.y == 2 p2.x = 4; // p2.x == 4, p2.y == 2 // p1.x == 4, p2.y == 2 § p2 soll nicht mehr auf p1 verweisen 88 Reference Semantics § Wir brauchen einen Weg, eine Reference Variable zurückzu- setzen Point p1 = new Point(); p1.x = 3; p1.y = 2; Point p2 = p1; // p2.x == 3, p2.y == 2 p2.x = 4; // p2.x == 4, p2.y == 2 // p1.x == 4, p2.y == 2 § p2 soll nicht mehr auf p1 verweisen § Besonderer Wert null (gut für alle Klassen) p2 = null; // only p1 refers to Point (4,2) 89 null – ein besonderer Wert § null ist ein Wert (den jede Referenzvariable haben kann) § Variable mit Reference Semantics § Beispiele Point p2; p2 = null; // forget whatever p2 referred to! int[] a = new int[10]; a = null; // forget this array! String s = \"Hello\"; s = null; // forget this string § Hat eine Variable den Wert null so sprechen wir manchmal von einer «null reference» 90 null § null ist der Wert einer Referenzvariable die auf kein Objekt verweist. Point p = new Point(); p.x = 1; ✓ p = null; p.y = 2; ✘ 91 int [] a = new int[10]; a[0] = 1; ✓ System.out.println(a.length); ✓ a = null; System.out.println(a.length); ✘ a[1] = 2; ✘ Wofür null (noch) gut ist § Wir erinnern uns (vielleicht): Wird ein neuer Array erstellt int[] data = new int[...]; String[] words = new String[...]; § so wird jedes Element auf einen Wert der Null «entspricht» gesetzt § Voreinstellung («default») § Array Elemente, die auf Objekte verweisen können, werden mit null initialisiert 93 Type Default Wert int 0 double 0.0 boolean false String (oder anderes Objekt) null Arrays mit Objektverweisen § Die Elemente eines Arrays für Objektverweise werden mit null initialisiert. String[] words = new String[5]; DrawingPanel[] windows = new DrawingPanel[3]; index 0 1 2 3 4 value null null null null null index 0 1 2 value null null null words windows 94 Wofür null gut ist § Speichern von null in einem Array Element (eines durch eine Klasse definierten Typs) String[] words = {\"ein\", \"einfaches\", \"Beispiel\"}; words[1] = null; 95 index 0 1 2 value \"ein\" null \"Beispiel\" Arbeiten mit null § Hat eine Referenzvariable den Wert null, so können wir sie nicht dereferenzieren § Kein Zugriff auf Attribute oder auf Länge eines Arrays § Zur Erinnerung: Dereferenzieren («dereference»): Zugriff auf Attribute oder Methoden eines Objektes in Dot Notation, z.B. s.length() für String s oder a.length für Array a. § Einmal mit Methode, einmal als Attribut 96 Null Reference Exception § Es ist nicht erlaubt, null zu dereferenzieren § Fehler (error) im Programm, zur Laufzeit entdeckt, hat Exception zur Folge). Point p1 = new Point(); p1.x = 3; p1.y = 2; Point p2 = p1; // p2.x == 3, p2.y == 2 p2 = null; System.out.println(\"p2.x :\" + p2.x); //ERROR Exception in thread \"main\" java.lang.NullPointerException at C1.main(C1.java:9) § null ist nicht irgendein Objekt, d.h. es gibt keine Methoden oder Daten (Attribute) 97 Null Reference Exception String[] words = new String[5]; System.out.println(\"word is: \" + words[0]); words[0] = words[0].toUpperCase(); // ERROR Output: word is: null Exception in thread \"main\" java.lang.NullPointerException at Example.main(Example.java:8) § Der Name java.lang.NullPointerException verrät etwas über die Implementierung von References index 0 1 2 3 4 value null null null null null 98 Einschub Frage: Sind null und ! (der leere String) das selbe? Antwort: Nein. § Der leere String (\"\") ist ein String der keinen Buchstaben enthält. § Sie können mit dem String arbeiten, z.B. Addition von \"\" und einem int Wert (Beispiel \"\"+ 67) ergibt den String \"67\" § null ist der Wert einer Referenzvariable, die auf nichts verweist. § Man kann die Referenzvariable nicht dereferenzieren 99 Arbeiten mit null § Prüfen ob eine Variable oder Array Element null ist if (words[2] == null) { ... } § Verhindert das Auftreten einer Exception («Laufzeitfehler») § Wir lernen später mehr über Exceptions und auch wie ein Programm auf Exceptions reagieren kann. § Aber: Exceptions sollen die Ausnahme sein – ein Programm sollte das Auftreten verhindern. 100 luege, lose, laufe … § Sie können prüfen ob eine Referenz null ist bevor eine Methode für ein Objekt aufgerufen wird. String[] words = new String[5]; words[0] = \"hello\"; words[2] = \"goodbye\"; // words[1], [3], [4] are null for (int i = 0; i < words.length; i++) { if (words[i] != null) { words[i] = words[i].toUpperCase(); } } index 0 1 2 3 4 value \"HELLO\" null \"GOODBYE\" null nullwords 101 luege, lose, laufe … § Sie können prüfen ob eine Referenz null ist bevor eine Methode für ein Objekt aufgerufen wird. String[] words = new String[5]; words[0] = \"hello\"; words[2] = \"goodbye\"; // words[1], [3], [4] are null for (int i = 0; i < words.length; i++) { if (words[i] != null) { if (words[i].equals(\"goodbye\") { words[i] = words[i].toUpperCase(); } } } index 0 1 2 3 4 value \"hello\" null \"GOODBYE\" null null words 102 luege, lose, laufe … Bedingte Auswertung hilft! § Sie können prüfen ob eine Referenz null ist bevor eine Methode für ein Objekt aufgerufen wird. String[] words = new String[5]; words[0] = \"hello\"; words[2] = \"goodbye\"; // words[1], [3], [4] are null for (int i = 0; i < words.length; i++) { if (words[i] != null && words[i].equals(\"goodbye\")) { words[i] = words[i].toUpperCase(); } } index 0 1 2 3 4 value \"hello\" null \"GOODBYE\" null null 103words Wofür null gut ist § Übergeben von null als ein Parameter einer Methode System.out.println(null); // null § Methode muss Referenzvariable als Parameter erwarten public static void foo(int[] numbers) { . . . } public static void foo(Point p) { . . . } § Damit drücken wir aus: kein Array, kein Point Objekt, … § Vorsicht: Methode muss evtl. überprüfen ob Parameter null ist! § Zurückgeben von null von einer Methode (wird oft verwendet um einen Fehler anzuzeigen) return null; 106 (1.) Zusammenfassung § Eine Referenzvariable («reference type variable», Variable eines Referenztyps) erlaubt den Zugriff auf einen Array oder ein Objektexamplar Point p; //Verweis auf Pointexemplar int[] myarray; //Verweis auf Array von int Elementen String s; //Verweis auf String Point[] parray; //Verweis auf Array von Pointverweisen § Zuweisung muss Referenzvariable mit Objektexamplar oder Array verknüpfen § Sonst gibt es keinen Array oder Exemplar die Daten speicheren 108 § Zuweisung muss Referenzvariable mit Objektexamplar oder Array verknüpfen Point p; p = new Point(); Point q; q = p; int[] myarray; myarray = new int[100]; (oder) myarray = {1, 2, 3}; int[] yarray; yarray = myarray; String s; s = \"Hello\"; String t; t = s + \" Again\"; Point[] parray; parray = new Point[4]; § Hat eine Referenzvariable den Wert null so verweist sie auf kein Objekt 109 § Referenzvariable verwenden für Objekte (einschliesslich Arrays) Reference Semantics § Zwei (oder mehr) Referenzvariable können auf das selbe Objekt verweisen Point p1 = new Point(); p1.x = 3; p1.y = 2; Point p2 = p1; // p2.x == 3, p2.y == 2 p2.x = 4; // p2.x == 4, p2.y == 2 // p1.x == 4, p2.y == 2 § Änderungen mittels einer Referenzvariable sind auch mittels der anderen Referenzvariable sichtbar § Array und Objekt Parameter verwenden Reference Semantics 110 § Sind die Elemente eines Arrays ein Referenztyp so speichert der Array nicht die Objekte(examplare) sondern Verweise auf Objekte. § Sind die Elemente Basistypen so wird der Wert gespeichert § Die Initialisierung erfordert oft zwei Schritte (in dieser Reihenfolge): 1. Initialisierung des Arrays (Jedes Element wird auf null gesetzt bei Objekten; 0, 0.0, oder false bei Basistypen) 2. Initialisierung der Elemente String[] words = new String[4]; // phase 1 for (int i = 0; i < words.length; i++) { words[i] = \"word\" + i; // phase 2 } index 0 1 2 3 value \"word0\" \"word1\" \"word2\" \"word3\"words 111 Referenzvariable und Basistyp Variable § Der Unterschied in der Behandlung als Parameter ist nicht überraschend § Effizienz Überlegungen und praktische Notwendigkeit fordern ihren Tribut § Auch in der «realen Welt» finden wir ähnliche Situation 112 Vor Yahoo, Lycos, AltaVista … und … Google § Es gab Bibliotheken § Noch immer … § Finden eines Textes nicht immer einfach § Schon damals 11 3 Long Room Interior, Trinity College Dublin Photo by DAVID ILIFF. License: CC BY-SA 3.0 Wie findet man ein Dokument? § Jedes Dokument hat eine «Signatur» -- Folge von Buchstaben und Ziffern § Diese Folge bestimmt wo das Dokument abgelegt ist § Wir sagen auch dass die Folge die «Klassifikation» ist § Es gibt verschiedene Klassifikationssysteme § Ein häufig verwendetes Systems: LoC § (US) Library of Congress § Nicht perfekt, aber flexibel und seit Einführung (1897!!) immer weiter entwickelt 114115 Viele Dokumente (insbesondere Bücher) drucken die Signatur auf Seite 2 oder stellen sie online zur Verfügung 117118119 https://commons.wikimedia.org/wiki/File:LibraryOfCongressClassification.jpg Raysonho @ Open Grid Scheduler / Grid Engine, Public domain, via Wikimedia Commons § Zurück zu Referenzvariablen und Basistyp Variablen § Unsere Bibliothek bietet einen tollen Service an: § Wenn ein Dokument (das wir wollen) ein kurzer Text ist, dann kopiert die Bibliothek für uns das Dokument 120121 Kurzer Text: Quelle: https://openclipart.org/detail/2854 Kopierer https://en.wikisource.org/wiki/Page:Emily_Dickinson_Poems_(1890).djvu/30 § Zurück zu Referenzvariablen und Basistyp Variablen § Unsere Bibliothek bietet einen tollen Service an: § Wenn ein Dokument (das wir wollen) ein kurzer Text ist, dann kopiert die Bibliothek für uns das Dokument § Wenn das Dokument ein langer Text ist, dann sagt uns der Katalog der Bibliothek wo das Dokument im Regal steht 122 Katalog Karte: Lage 124 Langer Text: Quelle: https://commons.wikimedia.org/wiki/File:Copyright_Card_Catalog_Files.jpg https://commons.wikimedia.org/wiki/File:Library_card.jpg https://commons.wikimedia.org/wiki/File:HK_Wan_Chai_Library_Inside_Bookcase_a.jpg https://commons.wikimedia.org/wiki/File:LibraryOfCongressClassification.jpg QA76 Flanagan, David 73 Java in a J38 nutshell F553 2005 Kurzer Text: Copy § Können Ihre Kopie verändern: § Original unverändert § Viele (gleichzeitige) Kopien möglich § Jede unbeschränkt nutzbar Langer Text: Library Card § Card gibt Lage (im Archiv) an § Dort steht das Buch § Card ≠ Buch § Änderungen von anderen sichtbar (Bitte keine Seiten entfernen) § Nur einer kann zur selben Zeit bearbeiten § Kann Karte kopieren, aber es gibt nur ein Buch § Kann neue Nummer auf Card schreiben § Kein Einfluss auf altes Buch/Card 125 Basistyp: Copy § Aufrufer kann Wert verändern: § Original unverändert § Viele (gleichzeitige) Kopien möglich § Jede unbeschränkt nutzbar Reference Type: Reference § Referenz verweist auf Array/Objekt § Array/Objekt liegt im Speicher § Referenz ≠ Array (bzw. Objekt) § Änderungen von anderen sichtbar § Nur bestimmte Änderungen möglich § Nur einer sollte zur selben Zeit bearbeiten (nächstes Semester) § Kann Referenz weitergeben, aber es gibt nur einen Array bzw. ein Objekt 126 Vergleich deckt nicht alle Aspekte ab …. Einschub: Math Klasse 127 Auch manchmal hilfreich: Math Klasse 128 Method name Description Math.abs(value) absolute value Math.ceil(value) rounds up Math.floor(value) rounds down Math.log10(value) logarithm, base 10 Math.max(value1, value2) larger of two values Math.min(value1, value2) smaller of two values Math.pow(base, exp) base to the exp power Math.random() random double between 0 and 1 Math.round(value) nearest whole number Math.sqrt(value) square root Math.sin(value) Math.cos(value) Math.tan(value) sine/cosine/tangent of an angle in radians Math.toDegrees(value) Math.toRadians(value) convert degrees to radians and back Constant Description Math.E 2.7182818... Math.PI 3.1415926... Aufruf von Math Methoden Syntax: Math.methodName(parameters) § methodName: Service den wir brauchen § parameter(s) : Ein oder mehr Parameter § Beispiele: double squareRoot = Math.sqrt(121.0); System.out.println(squareRoot); // 11.0 int absoluteValue = Math.abs(-50); System.out.println(absoluteValue); // 50 System.out.println(Math.min(3, 7) + 2); // 5 130 Besonderheiten von Math Methoden § Einige Math Methoden lieferen keinen int Wert obwohl wir es erwarten (könnten) § Liefern einen double Wert: int x = Math.pow(10, 3); // ERROR: incompatible types § Wollen wir einen int Wert, so ist Cast nötig int x = (int) Math.pow(10, 3); // 1000 132 4.0 Klassen und Objekte: Übersicht 4.1 Klassen und Objekte (allgemein) 4.2 Objekte als Parameter 4.3 Klassen (selber entwickeln) 4.4 Attribute 4.5 Klassen und ihre Klienten 4.6 Methoden 4.7 Sichtbarkeit von Attributen 4.8 Konstruktoren 4.9 static Methoden und Variable 138 4.5 Klassen und ihre Klienten 140 Arbeiten mit Objekten § Klienten sind alle die Programme die Exemplare einer Klasse erstellen oder auf Exemplare zugreifen (können) [z.B. weil sie als Parameter übergeben wurden] § Klient: Beziehung zwischen Klassen § Programm: muss in einer Klasse sein § Wenn Zugriff möglich ist: Klient 141 Klassen und Klienten § Point.java ist (alleine) kein ausführbares Programm Point.java (Klasse für Objekte) public class Point { int x; int y; } 143 Klassen und Klienten § Point.java ist (alleine) kein ausführbares Programm § Die Klasse kann von Klienten verwendet werden. PointMain.java (Klient) public class PointMain { public static void main(String[] args) { Point p1 = new Point(); p1.x = 7; p1.y = 2; Point p2 = new Point(); p2.x = 4; p2.y = 3; ... } } Point.java (Klasse für Objekte) public class Point { int x; int y; } x 7 y 2 x 4 y 3 144 new Operator § Der new Operator initialisiert die Attribute mit einem Wert der «Null» entspricht § Für int Attribute: 0 § Für double Attribute: 0.0 § Für boolean Attribute: false § Für Referenz auf String (oder anderes) Objekt: null 145 Klassen und Klienten - Zeitlupe § Point.java ist (alleine) kein ausführbares Programm § Eine Klasse kann von Klienten verwendet werden. PointMain.java (Klient) public class PointMain { public static void main(String[] args) { Point p1 = new Point(); p1.x = 7; p1.y = 2; Point p2 = new Point(); p2.x = 4; p2.y = 3; ... } } Point.java (Klasse für Objekte) public class Point { int x; int y; } x 0 y 0 146 Klassen und Klienten - Zeitlupe § Point.java ist (alleine) kein ausführbares Programm § Eine Klasse kann von Klienten verwendet werden. PointMain.java (Klient) public class PointMain { public static void main(String[] args) { Point p1 = new Point(); p1.x = 7; p1.y = 2; Point p2 = new Point(); p2.x = 4; p2.y = 3; ... } } Point.java (Klasse für Objekte) public class Point { int x; int y; } x 7 y 0 147 Klassen und Klienten - Zeitlupe § Point.java ist (alleine) kein ausführbares Programm § Eine Klasse kann von Klienten verwendet werden. PointMain.java (Klient) public class PointMain { public static void main(String[] args) { Point p1 = new Point(); p1.x = 7; p1.y = 2; Point p2 = new Point(); p2.x = 4; p2.y = 3; ... } } Point.java (Klasse für Objekte) public class Point { int x; int y; } x 7 y 2 148 Klassen und Klienten - Zeitlupe § Point.java ist (alleine) kein ausführbares Programm § Eine Klasse kann von Klienten verwendet werden. PointMain.java (Klient) public class PointMain { public static void main(String[] args) { Point p1 = new Point(); p1.x = 7; p1.y = 2; Point p2 = new Point(); p2.x = 4; p2.y = 3; ... } } Point.java (Klasse für Objekte) public class Point { int x; int y; } x 7 y 2 x 0 y 0 149 Klassen und Klienten - Zeitlupe § Point.java ist (alleine) kein ausführbares Programm § Eine Klasse kann von Klienten verwendet werden. PointMain.java (Klient) public class PointMain { public static void main(String[] args) { Point p1 = new Point(); p1.x = 7; p1.y = 2; Point p2 = new Point(); p2.x = 4; p2.y = 3; ... } } Point.java (Klasse für Objekte) public class Point { int x; int y; } x 7 y 2 x 4 y 0 150 Klassen und Klienten - Zeitlupe § Point.java ist (alleine) kein ausführbares Programm § Eine Klasse kann von Klienten verwendet werden. PointMain.java (Klient) public class PointMain { public static void main(String[] args) { Point p1 = new Point(); p1.x = 7; p1.y = 2; Point p2 = new Point(); p2.x = 4; p2.y = 3; ... } } Point.java (Klasse für Objekte) public class Point { int x; int y; } x 7 y 2 x 4 y 3 151 PointMain Beispiel für Klient public class PointMain { public static void main(String[] args) { // create two Point objects Point p1 = new Point(); p1.y = 2; System.out.println(p1.x + \", \" + p1.y); // 0, 2 Point p2 = new Point(); p2.x = 4; // 4, 0 // change p2 and then print it p2.x += 2; p2.y++; System.out.println(p2.x + \", \" + p2.y); // 6, 1 } } 153 Arrays mit Referenzen («Verweisen») String[] words; § Deklariert eine neue Referenzvariable (words) die sich auf einen Array beziehen kann ... ... 154 Arrays mit Objektverweisen § Die Elemente eines Arrays für Objektverweise werden mit null initialisiert. String[] words = new String[5]; index 0 1 2 3 4 value null null null null nullwords 155 Die ganze Wahrheit über Arrays Point[] places; § Deklariert eine neue Referenzvariable (places) die sich auf einen Array beziehen kann ... 156 Die ganze Wahrheit Point[] places; § Deklariert eine neue Referenzvariable (places) die sich auf einen Array beziehen kann ... § Initialisierung wie bei String Arrays places = new Point[10]; 157 index 0 1 2 3 4 5 6 7 8 9 value null null null null null null null null null nullplaces Wir erinnern uns (vielleicht) Wird ein neuer Array erstellt int[] data = new int[...]; String[] words = new String[...]; so wird jedes Element auf einen Wert der Null «entspricht» gesetzt § Voreinstellung («default») Type Default Wert int 0 double 0.0 boolean false String (oder anderes Objekt) null 158 Die ganze Wahrheit Point[] places; § Deklariert eine neue Referenzvariable (places) die sich auf einen Array beziehen kann ... places = new Point[10]; § Nach Initialisierung (des Arrays) können wir etwas speichern places[0] = new Point(); § Element mit Index 0 verweist jetzt auf Punkt (0,0) 159 Die ganze Wahrheit § places[0] ist eine Variable die eine Referenz (auf ein Point Exemplar) enthält 161 index 0 1 2 3 4 5 6 7 8 9 value null null null null null null null null nullplaces x 0 y 0 Die ganze Wahrheit § places[0] ist eine Variable die eine Referenz (auf ein Point Exemplar) enthält § Jetzt können wir mit dem Exemplar arbeiten places[0].x = 8; places[0].y = 5; 162 index 0 1 2 3 4 5 6 7 8 9 value null null null null null null null null nullplaces x 0 y 0x 8 y 5 Die ganze Wahrheit § places[k] sind Variable die eine Referenz (auf ein Point Exemplar) enthalten können (k≥0, k<places.length) § Weitere Exemplare im Array speichern: places[2] = new Point(); places[2].y = 7; 163 index 0 1 2 3 4 5 6 7 8 9 value null null null null null null null nullplaces x 8 y 5 x 0 y 7 Die ganze Wahrheit Point[] places; § Deklariert eine neue Referenzvariable (places) die sich auf einen Array beziehen kann ... ... auf einen Array von Verweisen (Referenzen) auf Point Objekte § Element places[k] enthält Verweis auf ein konkretes Exemplar § Oder null wenn kein Exemplar vorhanden § null kann für alle Klassen verwendet werden 164 Die ganze Wahrheit Point[] places; § Deklariert eine neue Referenzvariable (places) die sich auf einen Array beziehen kann ... ... dazu muss der Array existieren § places = new Point[4]; § Sonst hat places den Wert null wenn kein Array vorhanden ist § null kann für alle Arrays oder Klassen verwendet werden 165 Klassen: Zustand und Verhalten § Attribute eines Objekts können einen beliebigen Typ haben und legen den Zustand (legale Werte) fest § Basistypen § Strings § Arrays § … § Das Verhalten (Menge der Operationen) wird durch Methoden bestimmt § Und evtl. sind Operatoren zulässig – aber nicht für von uns entwicklte Klassen 170 252-0027 Einführung in die Programmierung 4.0 Klassen und Objekte Thomas R. Gross Department Informatik ETH Zürich 1 4.0 Klassen und Objekte: Übersicht 4.1 Klassen und Objekte (allgemein) 4.2 Objekte als Parameter 4.3 Klassen (selber entwickeln) 4.4 Attribute 4.5 Klassen und ihre Klienten 4.6 Methoden 4.7 Konstruktoren 4.8 Sichtbarkeit von Attributen 4.9 static Methoden und Variable 2 4.6 Methoden Copyright (c) Pearson 2013 and Thomas Gross 2016-9 All rights reserved. 3 Ein Problem (Arbeitszeit berechnen) § Die File hours.txt enthält die folgenden Daten: ID Name in der Woche gearbeitete Stunden (pro Arbeitstag) 123 Paula 12.5 8.1 7.6 3.2 456 Erich 4.0 11.6 6.5 2.7 12 789 Steffie 8.0 8.0 8.0 8.0 7.5 § Wir wollen ein Programm schreiben das die Anzahl Stunden für jede Person berechnet: Paula (ID#123) worked 31.4 hours (7.85 hours/day) Erich (ID#456) worked 36.8 hours (7.36 hours/day) Steffie (ID#789) worked 39.5 hours (7.9 hours/day) 4 Was für ein Objekt brauchen wir? § Modellierung der «Person» § Operationen mit Personen § Vielleicht wollen wir ein Programm um den Lohn zu berechnen § Anzahl Stunden × Stundenlohn 5 Attribute § Attribute können können einen beliebigen Typ haben § Basistypen § Strings § Arrays § … 6 Beispiel Arbeitszeit § Sinnvoll wäre hier ein Typ Person public class Person { String name; int id; double[] hours; } § Unser Programm (main) arbeitet dann mit einem Array von (Referenzen auf) Person Objekten Scanner input = new Scanner(new File(\"data.txt\")); Person[] staff = new Person[input.nextInt()]; for (int i = 0; i < staff.length; i++) { staff[i] = readData(input); } 7 Beispiel Arbeitszeit Also in einer Klasse HoursWorked (Klient von Person) public class HoursWorked { public static void main (String[] args) { Scanner input = new Scanner(new File(\"data.txt\")); Person[] staff = new Person[input.nextInt()]; for (int i = 0; i < staff.length; i++) { staff[i] = readData(input); } //compute hours worked … } 9 Methoden beschreiben das Verhalten § Beschreiben das Verhalten eines Objektes § Verhalten – Zustandsänderungen oder Abfragen des Zustandes 10 Redundanz im Klienten § Unser Klientenprogramm möchte den Lohn für alle Angestellten berechnen 11 § Gegeben ein Array1 staff von Person Objekten: double salary; // compute salary in loop for (int i = 0; i < staff.length; i++) { double sum = 0; for (int j = 0; j < staff[i].hours.length; j++) { sum += staff[i].hours[j]; }; salary = sum * 20.00; //print salary ... } // for i 1: Array von Referenzen auf Person Objekten 12 Was geht hier vor? for (int i = 0; i < staff.length; i++) { double sum = 0; for (int j = 0; j < staff[i].hours.length; j++) { sum += staff[i].hours[j]; }; }; 13 index 0 1 2 valuestaff name \"Paula\" id 123 hours index 0 1 2 3 value 12.5 8.1 7.6 3.2 index 0 1 2 3 4 value name \"Erich\" id 456 hours name \"Steffie\" id 789 hours index 0 1 2 3 4 value Redundanz im Klienten § Wenn wir diese Berechnung an mehreren Stellen durchführen wollen, müssen wir den Code kopieren … § Diese Art von Redundanz kann mit einer Methode verhindert werden § Methode computePay(Person p) public static double computePay(Person p) { double sum = 0; for (int k = 0; k < p.hours.length; k++) { sum += p.hours[k]; } return sum * 20.00; } 15 Ohne Redundanz, Version 1 § main würde dann diese Methode aufrufen // compute total wages to be paid double totalWages = 0.0; for (int i = 0; i < staff.length; i++) { totalWages += computePay(staff[i]); } 16 Beispiel (vollständiger) public class HoursWorked { public static void main (String[] args) { Scanner input = new Scanner(new File(\"data.txt\")); Person[] staff = new Person[input.nextInt()]; for (int i = 0; i < staff.length; i++) { staff[i] = readData(input); } double totalWages = 0.0; for (int i = 0; i < staff.length; i++) { totalWages += computePay(staff[i]); } } //main public static double computePay(Person p) { double sum = 0; for (int k = 0; k < p.hours.length; k++) { sum += p.hours[k]; } return sum * 20.00; } // computePay } 17 Probleme mit dieser Programmstruktur § Methode computePay(…) ist Teil von HoursWorked (dem Klienten) § Jedes Programm das mit Person Objekten arbeitet müsste eine computePay(…) Methode implementieren. § Objekte erlauben Wiederverwendung von Code – aber diese findet nicht statt wenn jeder Klient den Code für die Gehaltsberechnung duplizieren muss. 19 Probleme mit dieser Programmstruktur § Die Methode computePay(…) muss viele Einzelheiten über die Implementation von Person Objekten wissen for (int k = 0; k < p.hours.length; k++) sum += p.hours[k]; } § Die Attribute von Person könnten sich aber ändern 20 Eine mögliche Änderung § Der Array hours enthält die Anzahl Stunden, die eine Person an einem Tag gearbeitet hat. § Was wenn wir zwischen Normalzeit und Überstunden unterscheiden wollen ? § Ersten 8 Stunden/Tag sind Normalzeit, sFr 20.00 pro Stunde § Über 8 Stunden gilt als Überstunde, 25% Zuschlag § Wir müssen Person Objekte anpassen und die Methoden computePay(…) in allen Klienten anpassen 21 Person mit Überstunden Attribut public class Person { String name; int id; double[] hours; double[] overtime; } § Viele andere Attribute für richtige Personendaten … 22 computePay mit Überstunden public static double computePay(Person p) { double sumStd = 0.0; double sumOvt = 0.0; for (int i = 0; i < p.hours.length; i++) { sumStd += p.hours[i]; } for (int i = 0; i < p.overtime.length; i++) { sumOvt += p.overtime[i]; } return sumStd * 20.00 + sumOvt * 25.00; } 23 Probleme mit dieser Programmstruktur § Wir wollen Klassen entwickeln die (innerhalb eines bestimmten Rahmens) von den Klienten unabhängig (weiter)entwickelt werden können. § Wir wollen Klienten entwickeln die von der Implementation der Klassen (die sie verwenden) unabhängig sind. 24 Probleme mit dieser Programmstruktur § Im Klienten ist überhaupt nicht ersichtlich dass computePay(…) eine Methode für Person Objekte ist § Es wird ein Person Objekt als Parameter übergeben for (int i = 0; i < staff.length; i ++) { totalWages += computePay(staff[i]); } § Person Objekte sind Parameter, aber kein weiterer Bezug zur Person Klasse 26 Probleme mit dieser Programmstruktur § Klassen sollten Zustand und Verhalten kombinieren. § Berechnung des Gehaltes computePay(…) ist ein Verhalten das eng mit den Daten eines Person Objektes verbunden ist. § Diese Methode gehört daher in jedes Person Objekt. § Dann kann diese Methode in Dot Notation aufgerufen werden § totalWages += staff[i].computePay(); 2728 Methoden für Exemplare § Eine Methode (auch «object method») existiert innerhalb jedes Objekt(exemplar)s einer Klasse und beschreibt das Verhalten eines Objektes. § Syntax: public type name(parameters) { statements; } § Selbe Syntax wie bei den bisher bekannten Methoden aber ohne das Keyword static 30 Typ der Rückgabe Parameterliste Name der Methode 31 Beispiele public class Greetings { public void hello(String name) { System.out.println(\"HELLO \" + name); } } public class Person { String name; int id; double[] hours; double[] overtime; public String nameIs() { // return name return name; } } // usage example on next slide 33 Beispiele, Einsatz public class HoursWorked { public static void main(String[] args) { Scanner input = new Scanner(new File(\"data.txt\")); Person[] staff = new Person[input.nextInt()]; Greetings friendly = new Greetings(); for (int i = 0; i < staff.length; i++) { staff[i] = readData(input); } // process entries for employees for (int i = 0; i < staff.length; i++) { friendly.hello(staff[i].nameIs()); } } 3435 Bemerkungen § Eine Methode kann sich auf Attribute beziehen § Beispiel name in Methode nameIs() § Wir brauchen ein Exemplar um eine Methode aufzurufen § In «Dot Notation» § Beispiel friendly und staff[i] in main 36 Person Objekte mit Methode computePay public class Person { String name; int id; double[] hours; double[] overtime; // Computes wages, 25% overtime supplement public double computePay() { double sumStd = 0; double sumOvt = 0; for (int i = 0; i < hours.length; i++) { sumStd += hours[i]; } for (int i = 0; i < overtime.length; i++) { sumOvt += overtime[i]; } return sumStd * 20.00 + sumOvt * 25.00; } } 3738 Methoden für Exemplare public class Person { String name; int id; double[] hours; double[] overtime; // Computes wages, 25% overtime supplement public double computePay() { … } } § Die computePay Method hat nicht mehr einen Person p Parameter. § Wie «weiss» die Methode wieviele Stunden eine Person gearbeitet hat? § Wie erhält die Methode Zugang zu Daten in hours und overtime? 39 § Jedes Person Objekt hat seine eigene Kopie der computePay Methode, die mit dem Zustand dieses Objektes arbeitet: Person p1 = new Person(); // read data Person p2 = new Person(); // read data p1.computePay(); p2.computePay(); Person Objekte mit Methoden 40 name \"xxxx\" id n hours index 0 1 2 value X X X name \"yyyy\" id m hours index 0 1 2 3 value X X X X computePay computePay 41 Person p1 = new Person(); // read data Person p2 = new Person(); // read data p1.computePay(); p2.computePay(); public double computePay() { // this code can see p1's data } hours[0] 12.5 hours[1] 8.1 hours[2] 7.6 p2 p1 public double computePay() { // this code can see p2's data } hours[0] 4.0 hours[1] 11.6 hours[2] 6.5 4445 Der implizite Parameter Impliziter («implicit») Parameter: Referenz auf Objekt für das die Methode aufgerufen wird. § Während der Ausführung von p1.computePay(); ist der implizite Parameter das Objekt auf das p1 verweist. § Während der Ausführung von p2.computePay(); ist der implizite Parameter das Objekt auf das p2 verweist. § Die Methode wird im Kontext eines konkreten Objektes ausgeführt. § computePay kann auf hours und overtime des Objektes zugreifen für das diese Methode aufgerufen wurde. § Methode wird «für» dieses Objekt aufgerufen; Methode wird auf dieses Objekt «angewendet» 47 Person Objekte mit Methoden public class Person { String name; int id; boolean leftCompany; double[] hours; double[] overtime; // Computes wages, 25% overtime supplement public double computePay() { double sumStd = 0; double sumOvt = 0; for (int i = 0; i < hours.length; i++) { sumStd += hours[i]; } for (int i = 0; i < overtime.length; i++) { sumOvt += overtime[i]; } return sumStd * 20.00 + sumOvt * 25.00; } 48 Person mit Methode present // weiter in class Person // Find out if employee left public void present() { if (leftCompany) { System.out.println(\"Left company\"); } else { System.out.println(\"Still employed\"); } } } //class Person 49 Der implizite Parameter Impliziter («implicit») Parameter: Referenz auf Objekt für das die Methode aufgerufen wird. § Während der Ausführung von p1.computePay(); verweist der implizite Parameter auf das Objekt auf das p1 verweist. § Während der Ausführung von p2.computePay(); verweist der implizite Parameter auf das Objekt auf das p2 verweist. § Die (Objekt)Methoden können mit den Attributen dieses Objekt(exemplar)s arbeiten (d.h. lesen und schreiben). § Eine (Objekt)Methode wird im Kontext eines konkreten Objekte(exemplar)s ausgeführt. § computePay kann auf hours und overtime des Objektes zugreifen für das diese Methode aufgerufen wurde. 50 Methoden § Existieren innerhalb jedes Objekt(examplars) einer Klasse und beschreiben das Verhalten des Objektes § Arbeiten mit den Attributwerten dieses Exemplars § Dieses Exemplar: impliziter Parameter § Methode hat Zugriff auf Attribute wie auf einen Parameter -- auch wenn das Objektexemplar nicht in der Parameterliste erscheint 51 Point Klasse, Version 2 § Und was für Methoden sollen wir für die Klasse Point definieren? public class Point { int x; int y; } § Bisher hatten wir kein Verhalten für Point Objekte diskutiert. 52 // A Point object represents an (x, y) location. public class Point { int x; int y; public void setLocation(int newX, int newY) { x = newX; y = newY; } public void translate(int dx, int dy) { setLocation(x + dx, y + dy); } 53 Methoden § Können andere Methoden aufrufen § Wie bisher – aber evtl. mit implizitem Parameter § Auch Aufruf der selben Methode ist möglich § … und manchmal von Vorteil § Beispiel: Sie wollen Anzahl Leerzeichen (\" \") in String zählen § Geht auch anders … 54 Klasse MyString § Können String nicht modifizieren § Auch keine neuen Methoden hinzufügen § Also neue Klasse: MyString public class MyString { String s; public static void main(String[] args) { MyString beispiel = new MyString(); beispiel.s = \"Nach Besuch der Veranstaltung sollen Sie einfache Programme in Java systematisch entwickeln koennen.\"; int count = beispiel.leer(); System.out.println(\"Anzahl Leerzeichen: \" + count); } // geht weiter 55 // weiter public int leer() { if (s.length() == 0) { return 0; } if (s.length() == 1) { if (s.equals(\" \")) { return 1; } else { return 0; } } else { MyString front = new MyString(); front.s = s.substring(0, (s.length()+1)/2); MyString back = new MyString(); back.s = s.substring((s.length()+1)/2); return front.leer() + back.leer(); } } // leer } // MyString 56575859 Mehr Attribute für Person public class Person { String name; int id; double hourlyRate; double[] hours; double[] overtime; // various methods … } § Wenn wir für jede Person den Stundenlohn festhalten wollen 60 Zugriff auf Attribute § Jeder Klient kann (bisher) auf alle Attribute eines Objektes zugreifen (lesen und/oder modifizieren) § Dies ist nicht immer gewünscht § Sonst könnte jeder hourlyRate verändern … § Als Vorbereitung für eine bessere Struktur betrachten wir zwei Arten von Methoden: 61 Methoden § Accessor Methode («accessor»): Eine Methode die es erlaubt den Zustand eines Objektes anzusehen § Beispiel: getAdresse(), getHourlyRate() § Hat sehr oft einen Rückgabewert der nicht void ist (non-void return) § Mutator Methode («mutator»): Eine Methode die den Zustand eines Objekts verändert § Beispiele: setHourlyRate(…), addTrainingTime(…), setAdresse(…) 62 Mutator Methoden § Schreiben Sie eine Methode setHourlyRate die den Stundenlohn auf den übergebenen Betrag newRate (vom Typ double) setzt. § Schreiben Sie eine Methode addTrainingTime die für jeden gearbeiteten Tag die Normalarbeitszeit um extraTime (ein Parameter vom Typ double) erhöht. 64 Mutator Methoden public void setHourlyRate(double newRate) { hourlyRate = newRate; } public void addTrainingTime(double extraTime) { for (int i = 0; i < hours.length; i++ ) { hours[i] += extraTime; } 66 Accessor Methoden § Schreiben Sie eine Methode distanceFromOrigin die den Abstand (als double) eines Punktes vom Nullpunkt (0,0) zurückgibt. § Fragen: § Formel: Pythagoras § Typ des Rückgabewertes: double public class Point { int x; int y; } 67 Accessor Methoden public double distanceFromOrigin() { return Math.sqrt(x * x + y * y); } 69 Accessor Methoden § Schreiben Sie eine Methode distance die den Abstand (als double) zu einem anderen Punkt berechnet § Fragen: § Formel für Abstand zwischen (x1, y1) und (x2,y2): § Was ist/sind der/die Parameter § Typ des Rückgabewertes: double 70 ( ) ( ) 2 12 2 12 yyxx -+- Accessor Methoden public double distance(Point other) { int dx = x - other.x; int dy = y - other.y; return Math.sqrt(dx * dx + dy * dy); } 71 Accessor Methoden public double distance(Point other) { int dx = x - other.x; int dy = y - other.y; return Math.sqrt(dx * dx + dy * dy); } // andere Implementation von distanceFromOrigin public double distanceFromOrigin() { Point origin = new Point(); // init (0,0) return distance(origin); } 72 Ausgabe (Drucken) von Objekten Ohne weitere Hilfe weiss das Java System nicht, wie ein Objekt gedruckt werden soll: Person[] staff = new Person[size]; // read from file for (int i = 0; i < staff.length; i++) { System.out.println(\"MA \" + i + \" ist \" + staff[i]); } Ausgabe: MA 0 ist Person@c17164 MA 1 ist Person@1fb8ee3 MA 2 ist Person@61de33 74 Ausgabe (Drucken) von Objekten Ohne weitere Hilfe weiss das Java System nicht, wie ein Objekt gedruckt werden soll: Person[] staff = new Person[size]; // read from file for (int i = 0; i < staff.length; i++) { System.out.println(\"MA \" + i + \" ist \" + staff[i]); } 75 String String int String Ref. Person String default Aktion .... Umwandlung zu String ... durch Methode toString() aus der Klasse Methode existiert auch wenn wir sie nicht geschrieben haben § Sagt Java System wie Objekt in String verwandelt wird for (int i = 0; i < staff.length; i++) { System.out.println(\"MA \" + i + \" ist \" + staff[i]); } § Nicht unbedingt was wir wollen 78 Umwandlung zu String ... durch Methode toString() aus der Klasse § Methode existiert auch wenn wir sie nicht geschrieben haben § Sagt Java System wie Objekt in String verwandelt wird for (int i = 0; i < staff.length; i++) { System.out.println(\"MA \" + i + \" ist \" + staff[i].toString()); } § Nicht unbedingt was wir wollen 79 Die toString Methode § Die default toString Methode ist § KlassenName @ Adresse_im_Speicher § Nicht das was wir wollen …. aber wir können uns eine eigene schaffen § Bessere toString Methode public String toString() { // Instruktionen die einen String für dieses Objekt zurückgeben } § Name der Methode, Keyword public, return Typ String, und (kein) Parameter müssen genau stimmen 83 toString Beispiel // Returns a String representing this Person. // Put in class Person! public String toString() { return name + \" (#\" + id + \") ist \" + Arrays.toString(hours) + \" \" + Arrays.toString(overtime); } 85 4.0 Klassen und Objekte: Übersicht 4.1 Klassen und Objekte (allgemein) 4.2 Objekte als Parameter 4.3 Klassen (selber entwickeln) 4.4 Attribute 4.5 Klassen und ihre Klienten 4.6 Methoden 4.7 Sichtbarkeit von Attributen 4.8 Konstruktoren 4.9 static Methoden und Variable 87 4.7 Sichtbarkeit für Attribute 88 Methoden der Klasse Person … können zugreifen auf (lesen und/oder modifizieren) § Parameter § In der Methode deklarierte Variable § Attribute des Objekts (implizierter Parameter) § In der Klasse deklariert § Beispiel: Methode computePay() § Sowie auf Attribute der Klassen deren Klient Person ist 90 Zugriff auf Attribute § Jeder Klient kann (bisher) auf alle Attribute eines Objektes zugreifen (lesen und/oder modifizieren) § Accessor und Mutator Methoden strukturieren den Code aber Zugriff ist noch immer möglich § Dies ist nicht immer gewünscht § Sonst könnte jeder hourlyRate verändern … public void myFriend(Person p) { p.hourlyRate = p.hourlyRate * 2.0; } 91 Zugriff auf Attribute § Jeder Klient kann (bisher) auf alle Attribute eines Objektes zugreifen (lesen und/oder modifizieren) § Wie können wir Objektexemplare so konstruieren dass (manche/alle) Attribute «geschützt» sind? § Grundproblem der Abkapselung («Encapsulation») 92 «Encapsulation» (Datenkapselung) § Bisher: Definition von Variablen in Methoden § … mit Sichtbarkeit in der Methode § Jetzt: Objekte haben einen Zustand (Objektattribute) § Variable ausserhalb von Methoden deklariert § Zugriff (Dot-Notation) mittels Referenzvariable DOT Name § Zugriff in Methode (Name genügt) § Klassen bieten Mechanismus der Abkapselung § «Encapsulation» (manchmal Datenkapselung) 9395 public class Point { int x; int y; } // in einem Klienten Point p1 = new Point(); p1.x = 6; Attribute x und y sind für jeden Klienten sichtbar x 6 y 0 Encapsulation § Idee: Verstecken der Details der Implementation einer Klasse vor den Klienten der Klasse § Encapsulation zwingt zur Abstraktion. § Trennung von Verhalten (extern sichtbar) und Zustand (intern) § Schützt die Daten eines Objektes vor unbeabsichtigten oder unerwünschten Operationen § Encapsulation erlaubt Anpassung(en) der Implementation ohne Änderungen der Klienten Programme § Grundlage für Weiterentwicklung/Wiederverwendung 96 Encapsulation § Bei der Definition eines Attributes können wir dessen Sichtbarkeit angeben § Attribute die nur intern (d.h. von Methoden der Klasse) geändert bzw gelesen werden können § Attribute auf die «von aussen» (d.h. aus Methoden in Klienten – d.h. extern) zugegriffen werden kann § Zugriff mit Dot Notation § Bisher in unseren Klassen verwendet um nicht zuviel auf einmal erklären zu müssen § Später lernen wir noch andere Möglichkeiten kennen, interne und externe Attribute zu trennen 98 Attribute mit Sichtbarkeit private Ein Attribut («field») auf das nur innerhalb der Klasse zugegriffen werden kann § Syntax: private type name; § Beispiele (alles Attribute einer Klasse!) private int id; private String lastName; 99 Attribute mit Sichtbarkeit private Ein Attribut («field») auf das nicht von ausserhalb der Klasse zugegriffen werden kann § Syntax: private type name; § Beispiele (alles Attribute einer Klasse!) private double d; private String[] names; 100 Point Klasse, Version 2 mit Sichtbarkeitseinschränkung // A Point object represents an (x, y) location. public class Point { private int x; private int y; public void setLocation(int newX, int newY) { x = newX; y = newY; } public void translate(int dx, int dy) { setLocation(x + dx, y + dy); } 101 Private Attribute public class Person { private String name; private int id; private double hourlyRate; private double[] hours; private double[] overtime; // various methods public double computePay() { ... for (int i = 0; i < hours.length; i++) ... } } Direkter Zugriff auf Attribute in Methoden der Klasse wie bisher 102 Person Klasse mit Methode computePay public class Person { private String name; private int id; private double hourlyRate; private double[] hours; private double[] overtime; // Computes wages, 25% overtime supplement public double computePay() { double sumStd = 0; double sumOvt = 0; for (int i = 0; i < hours.length; i++) { sumStd += hours[i]; } for (int i = 0; i < overtime.length; i++) { sumOvt += overtime[i]; } return sumStd * hourlyRate + sumOvt * hourlyRate * 1.25; } } 103 Private Attribute // irgendwo in einem Klienten Person myRecord = …; // set to my Person object myRecord.hourlyRate = 50.0; //ERROR Klienten Programm wird nicht übersetzt wegen unerlaubten Zugriffs auf privates Attribut: PersonExample.java:17: hourlyRate has private access in Person myRecord.hourlyRate = 50.0; 105 public class Person { ... private double hourlyRate; ... // various methods } Attribute ohne Sichtbarkeit Information Wenn wir nicht die Sichtbarkeit (mit private) einschränken dann ist das Attribut für uns überall sichtbar § In der Klasse § In allen Klienten § Das Attribut hat voreingestellte («default») Sichtbarkeit § Die genauen Regeln folgen später nachdem wir mehr Konzepte kennen. § Nur private schränkt Sichbarkeit ein – Accessor/Mutator Methoden strukturieren Programm aber kein Einfluss auf Sichtbarkeit § Syntax: type name; 106 Zugriff auf private Attribute § Nur Methoden die in der Klasse definiert sind können auf private Attribute zugreifen § Siehe Methode computePay § Wenn Zugriff von extern erlaubt sein soll dann muss die Klasse dafür Methoden zur Verfügung stellen § Accessor Methode(n) § Mutator Methode(n) 107 Zugriff auf den privaten Zustand // A read-only access to the hourlyRate field // (accessor) public int getHourlyRate() { return hourlyRate; } // Allows clients to change the hourlyRate field // (mutator) public void setHourlyRate (int newRate) { hourlyRate = newRate; } 108 Zugriff auf den privaten Zustand, im Klienten § Das Klientenprogramm sieht dann so aus : Person myRecord = … //z.B. staff[j] System.out.println(myRecord.getHourlyRate()); myRecord.setHourlyRate(40); 109 Vorteile Mutator/Accessor Methode § Methoden können zusätzliche Kontrollen vornehmen § Check Recht eine Änderung vorzunehmen § Log aller Änderungen § Methoden können Transformationen vornehmen 110 Point Klasse, Version 3 // A Point object represents an (x, y) location. public class Point { private int x; private int y; public Point(int initialX, int initialY) { x = initialX; y = initialY; } public int getX() { return x; } public int getY() { return y; } public void setX(int newX) { x = newX; } public void setY(int newY) { ... public double distanceFromOrigin() { return Math.sqrt(x * x + y * y); } public void setLocation(int newX, int newY) { setX(newX); setY(newY); } public void translate(int dx, int dy) { setLocation(x + dx, y + dy); } 111 Vorteile der Encapsulation § Abstraktion des Objektes und des Klienten § Objekt: stellt Methoden zur Verfügung, «verheimlicht» Implementation § Klient: ruft Methoden auf, keine Annahmen über die Implementation § Schutz vor unerwünschtem Zugriff § Accessor/Mutator Methoden sind optional § Beispiel: Person ohne setHourlyRate Methode § Objekt kann (z.B.) ein Protokoll der Zugriffe anlegen § Wann wurde hourlyRate geändert § Objekt kann weitere Kontrollen durchführen (Erlaubnis …) 112 Vorteile der Encapsulation § Objekt kann die Implementation verändern § Beispiel: Klasse Point könnte Polarkoordinaten (r, θ) verwenden – Namen der Methoden sind gleich aber die Implementation ändert sich § Beispiel: Klasse Person unterscheidet zwischen Normalzeit, Überzeit und Überstunden § Können den Zustand eines Objektes weiteren Beschränkungen unterwerfen § Beispiel: hourlyRate muss positiv sein § Ein Datum muss einen Monat von 1 bis 12 enthalten u.s.w. 113 Encapsulation (Hinweis) § Nicht nur Attribute können private sein, auch Methoden § Nicht-öffentliches Verhalten § Sinnvoll wenn wir aus Methoden gemeinsame Anweisungen herausnehmen (und in einer eigenen Methode zusammenfassen) aber sicherstellen wollen, dass diese Methode nicht von einem Klienten direkt aufgerufen wird § Syntax: private type name(parameters) { statements; } 114 Encapsulation § Bisher: Variable (oder Parameter) in Methode geschützt § Deklariert Variable für Block (bzw Parameter für Body der Methode) § Kein Zugriff von aussen § Jetzt: Attribute deklarieren «Variable» für die Methoden der Klasse § Attribut geschützt wenn sie private sind § Verantwortung der Entwickler § Was passiert bei Namenskonflikten? 115 Beispiel Klasse public class Bsp { private int x; int y; public int method1(int x) { return x+1; // x ?? } public int method1(int y) { return y+1; // y ?? } public int method1(int z) { int x = z+1; return x; // x ?? } } 117 Sollte private einen Unterschied machen? Welches x? Welches y? Welches x? Namenskonflikte § Die innere Deklaration gewinnt d.h. verdeckt («shadows») die äussere Deklaration public class Beispiel { int x = 0; public int increment() { int x = 1; //sets method-local variable return x + 1; } ... } 118 Namenskonflikte § Die innere Deklaration gewinnt d.h. verdeckt («shadows») die äussere Deklaration public class Beispiel { int x = 0; public int increment(int x) { x = 1; //sets parameter variable return x + 1; } ... } 119 Verdecken von Variablen («shadowing») § shadowing: Zwei Variable mit dem selben Namen die beide sichtbar sind. § Normalerweise in Java illegal – Ausnahme wenn eine der Variablen ein Attribut («field») einer Klasse ist. § Seien x und y Attribute § Wenn eine Methode x und y als Parameter hat, dann beziehen sich x und y auf die Parameter § Wenn eine Methode x und y als Variable deklariert dann beziehen sich x und y auf die Variable 121 Verdecken von Variablen («shadowing») public class Point { private int x; private int y; public void method1() { // A: x bezieht sich auf } public void method2(int x) { // B: x bezieht sich auf } public void method3() { int x; // C: x bezieht sich auf } } 122 PollVerdecken von Variablen («shadowing») public class Point { private int x; private int y; public void method1() { // A: x bezieht sich auf Attribut x } public void method2(int x) { // B: x bezieht sich auf Parameter x } public void method3() { int x; // C: x bezieht sich auf Variable x } } 123 PollVerdecken von Variablen («shadowing») public class Point { int x; int y; public void method1() { // D: x bezieht sich auf } public void method2(int x) { // E: x bezieht sich auf } public void method3() { int x; // F: x bezieht sich auf } } 124 PollVerdecken von Variablen («shadowing») public class Point { int x; int y; public void method1() { // D: x bezieht sich auf Attribut x } public void method2(int x) { // E: x bezieht sich auf Parameter x } public void method3() { int x; // F: x bezieht sich auf Variable x } } 125 Poll Und was wenn … § Sie haben eine Klasse mit Attribut x und eine (vielleicht lange) Methode mit Parametervariable x … § Es gibt keinen besseren Name für den Parameter … public class Point { int x; public void method1(double x) { // Need to set attribute x! x = … } } § … und Sie müssen in dieser Methode das Attribut x setzen 126 Zur Erinnerung: Der implizite Parameter Impliziter («implicit») Parameter: Referenz auf Objekt für das die Methode aufgerufen wird. § Die Methode wird im Kontext eines konkreten Objektes ausgeführt § Auch für den impliziten Parameter gibt es eine Parametervariable: this 127 Parametervariable this § this verweist auf das Objekt für das eine Methode aufgerufen wird (impliziter Parameter) § this wird automatisch gesetzt (Teil des Aufrufs einer Objektmethode) § Definiert (nur) in einer Methode der Klasse (und auch nur dort zu verwenden) § Expliziter Zugriff auf ein Attribut: this.variable § Expliziter Aufruf einer Methode: this.method(parameters); § Attribut oder Methode der selben Klasse § Erlaubt aber umständlich (Methode kann nicht verdeckt sein) 128 Einsatz von this § Sie haben eine Klasse mit Attribut x und eine (vielleicht lange) Methode mit Parametervariable x … § Es gibt keinen besseren Name für den Parameter … § Mit this können Sie auf das Attribut zugreifen public class Point { int x; public void method1(double x) { // Need to set attribute x! this.x = (int)(x/2); } } 129 4.8 Konstruktoren 131 Konstruktion und Initialisierung von Objekten § Der new Operator liefert eine Referenz (einen Verweis) auf ein neues Objekt § new class(): Referenz auf Exemplar der Klasse class § Kann in Referenzvariable gespeichert werden § Point p = new Point(); § Kann in Array von Referenzen gespeichert werden § Point[] pa = new Point[10]; § pa[0] = new Point(); § Referenz muss gespeichert werden sonst ist das Exemplar underwiderruflich verloren 132 Initialisierung von Objekten § Bisher waren mehrere Anweisungen nötig, um ein Exemplar einer Klasse zu konstruieren und es zu initialisieren: Point p = new Point(); p.x = 3; p.y = 8; § (N+1) Anweisungen bei N Attributen § Lange Folgen von Anweisungen § Leicht etwas zu übersehen 133 Initialisierung von Objekten § Besser wäre es die Werte für die Attribute gleich anzugeben: Point p = new Point(3, 8); // better! Person employee = new Person(\"Paula\", 123); § Wir können so etwas für viele Arten von Objekten in Java machen. 134 Konstruktoren Konstruktor («constructor»): Initialisiert den Zustand eines neuen Objektes. public type(parameters) { statements; } § type ist der Name der Klasse § Ausgeführt wenn der new Operator angewendet wird § Es gibt keinen Rückgabewert § Im Rumpf können beliebige Anweisungen auftreten (wie in Methode) 135 Konstruktoren § Ein Konstruktor ist keine Methode § Konstruktoren sind optional § Wenn eine Klassendefinition keinen Konstruktor enthält, dann stellt Java einen (voreingestellten) default Konstruktor («default constructor») zur Verfügung § Der default Konstruktor hat keine Parameter – setzt alle Felder auf einen Wert der «Null» enspricht (entweder 0, 0.0, false oder null) 136 Beispiele von Konstruktoren public class Point { private int x; private int y; // Constructs a Point at the given x/y location. public Point(int initialX, int initialY) { x = initialX; y = initialY; } // Methods ... } 137 Beispiele von Konstruktoren public class Person { private String name; private int id; private double hourlyRate; private double[] hours; private double[] overtime; // Constructs a Person with given name and Id public Person(String firstName, int uniqueId) { name = firstName; id = uniqueId; } // Methods ... } 139 Konstruktor § Attribute, die nicht in einem Konstruktor auf einen Wert gesetzt werden, werden auf Null gesetzt (0, 0.0, false or null). § Beispiel: public Point (int initialX) { x = initialX; } Point p1 = new Point(7); // p1.y == 0 140 Ausführung eines Konstruktors in Zeitlupe § Was passiert wenn dieser Code ausgeführt wird? Point p1 = new Point(7, 2); 141 Ausführung eines Konstruktors in Zeitlupe § Was passiert wenn dieser Code ausgeführt wird? Point p1 = new Point(7, 2); public Point(int initialX, int initialY) { x = initialX; y = initialY; } public void setLocation(int newX, int newY) { … x y p1 144 Ausführung eines Konstruktors in Zeitlupe § Was passiert wenn dieser Code ausgeführt wird? Point p1 = new Point(7, 2); public Point(int initialX, int initialY) { x = initialX; y = initialY; } public void setLocation(int newX, int newY) { … x 0 y 0p1 145 Ausführung eines Konstruktors in Zeitlupe § Was passiert wenn dieser Code ausgeführt wird? Point p1 = new Point(7, 2); public Point(int initialX, int initialY) { x = initialX; y = initialY; } public void setLocation(int newX, int newY) { … x 7 y 0p1 146 Ausführung eines Konstruktors in Zeitlupe § Was passiert wenn dieser Code ausgeführt wird? Point p1 = new Point(7, 2); public Point(int initialX, int initialY) { x = initialX; y = initialY; } public void setLocation(int newX, int newY) { … x 7 y 2p1 147 Ausführung eines Konstruktors in Zeitlupe § Was passiert wenn dieser Code ausgeführt wird? Point p1 = new Point(7, 2); public Point(int initialX, int initialY) { x = initialX; y = initialY; } public void setLocation(int newX, int newY) { … x 7 y 2p1 148 Mehrere Konstruktoren Eine Klasse kann mehrere Konstruktoren haben. § Jeder Konstruktor muss eine unverwechselbare Liste von Parametern haben § Entscheidend ist dass die Typen der Parameterliste unverwechselbar sind § Erlaubt public Point(int initialX, int initialY) { x=initialX; y=initialY; } public Point(int initialX) {x = initialX; y = 0;} § Nicht erlaubt public Point(int initialX, int initialY) { x=initialX; y=initialY; } public Point(int a, int b) { x = a; y = b; } 149 int, int int int, int int, int § Schreiben Sie einen Point Konstruktor ohne Parameter, der den Punkt mit (0, 0) initialisiert für die Klasse Point public class Point { private int x; private int y; } 151 Einfache Aufgabe § Schreiben Sie einen Point Konstruktor ohne Parameter, der den Punkt mit (0, 0) initialisiert für die Klasse Point public class Point { private int x; private int y; // Constructs a new point at (0, 0). public Point() { x = 0; y = 0; } } 152 Einfache AufgabeEncapsulation und Namensräume § Konstruktoren sind keine Methoden aber es gelten die selben Regeln für Namensräume. § Parameter definiert eine Variable für den Rumpf des Konstruktors § Was passiert wenn wir x und y als Namen für die Parameter verwenden (wollen)? § Z. B. für den Konstruktor für Point Objekte: public Point(int initialX, int initialY) { x = initialX; y = initialY; } 153 Encapsulation und Namensräume § Konstruktor für Point Objekte (mit problematischen Namen für Parametervariable): public Point(int x, int y) { x = x; y = y; } § Der Parametername verdeckt (shadows) das Attribut der Klasse Point § Schlecht für Konstruktor der ja Attribut initialisieren soll 154 Parametervariable this § this verweist auf das Objekt für das eine Methode aufgerufen wird (impliziter Parameter) § Analog verweist this in einem Konstruktor auf das Objekt das gerade konstruiert (initialisiert) wird § Expliziter Zugriff auf ein Attribut: this.variable § this wird automatisch gesetzt (Teil des Aufrufs einer Objektmethode bzw. eines Konstruktors) 155 Also … public class Point { private int x; private int y; ... public Point(int x, int y) { this.x = x; this.y = y; } } Innerhalb des Konstruktors Point § Um sich auf das Attribut x zu beziehen: verwende this.x § Um sich auf den Parameter x zu beziehen: verwende x 156 Konstruktoren § Konstruktoren sind optional § Wenn eine Klassendefinition keinen Konstruktor enthält, dann stellt Java einen (voreingestellten) default Konstruktor («default constructor») zur Verfügung § Der default Konstruktor hat keine Parameter – setzt alle Felder auf einen Wert der «Null» enspricht (entweder 0, 0.0, false oder null) § ABER: der (voreingestellte) default Konstruktor existiert nur wenn eine Klasse keinen Konstruktor selber definiert. 157 252-0027 Einführung in die Programmierung 5.0 Input/Output Thomas R. Gross und Michael Faes Department Informatik ETH Zürich 1 Übersicht 5.1 Arbeiten mit Dateien 5.2 Scanner im Einsatz/Beispiele 5.3 Output 5.4 Einfache Graphische Benutzeroberfläche (GUI) 2 Manipulieren von Dateien § Klasse File erlaubt Operationen mit Dateien (Files) § Lesen/schreiben § Informationen abrufen, z.B. Grösse § Umbenennen, löschen, … 3 import java.io.File; File file = new File(\"example.txt\"); if (file.exists() && file.length() > 1000) { file.delete(); } Import nötig! File-Methoden 4 exists() Gibt true zurück, falls diese Datei existiert, sonst false canRead() Gibt true zurück, falls diese Datei gelesen werden kann, sonst false getName() Gibt den Namen dieser Datei zurück length() Gibt die Dateigrösse, in Bytes, zurück delete() Löscht die Datei! renameTo(file) Benennt die Datei um! Datei-«Handle» § Ausdruck new File(\"example.txt\") erstellt keine Datei! § Sondern nur ein Objekt («handle»), welches für eine Datei mit diesem Namen steht § Und mit welchem diese Datei manipuliert werden kann § Datei, für welche File steht, kann existieren oder nicht § Deshalb: exists() 5 Lesen aus einer Datei § Das können Sie schon! § Oder kürzer: 6 import java.io.File; import java.util.Scanner; File file = new File(\"input.txt\"); Scanner scanner = new Scanner( ); int zahl = scanner.nextInt(); file Scanner scanner = new Scanner(new File(\"input.txt\")); Einschub: Text-Datei erstellen § In Eclipse auf Projekt rechtsklicken à New à File 78 Einschub: Text-Datei erstellen § In Eclipse auf Projekt rechtsklicken à New à File § Dateinamen eingeben, z.B. input.txt à Finish § In Editor Text eingeben, z.B. 42, dann speichern § Nicht das Zeilenende vergessen 11 Dokumentation für Scanner https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Sc anner.html 12 … noch viel mehr Text folgt Konstruktoren § Es gibt verschiedene Möglichkeiten, einen Scanner aufzusetzen § Unterschiedliche Arten von Input Quellen § Die Input Quelle wird dem Konstruktor als Parameter übergeben § Es gibt für jede Art von Input Quelle einen Konstruktor 13 Scanner Konstruktoren 14 Erstellen, Detail 15 Was bedeutet das? Compiler-Fehler… § Wenn wir nichts machen, reklamiert der Compiler… 16 Was sind Exceptions? § Eine Exception («Ausnahme») ist die Folge eines Fehlers der zur Laufzeit des Programmes festgestellt wird: § Eine ganze Zahl durch 0 dividieren § Zugriff auf ein Array-Element, das nicht existiert § Dereferenzieren einer Referenzvariable mit Wert null § Lesen eines falschen Typs im Scanner § Lesen einer Datei, die nicht existiert 17 Ablauf (1. Approximation) § Fehler wird festgestellt § Eine Exception wird generiert § Später darüber mehr § Exceptions sind auch wieder Objekte § Die Exception wird weitergereicht bis ein Teil des Programms diese Exception bearbeiten kann § Wir sagen, ein Programm mit einem Fehler «wirft» («throws») eine Exception. 18 Exception-Beispiel 19 void main() { // ... foo(); // ... } void foo() { bar(); // ... } void bar() { int x = 2; int y = 10/x; // ... } Exception-Beispiel 20 void main() { // ... foo(); // ... } void foo() { bar(); // ... } void bar() { int x = 0; int y = 10/x; // ... } Fehler! Exceptions auffangen § Ein Programm kann Exceptions auch «auffangen» («catch»), um auf Fehler zu reagieren (dazu später mehr) § Manche Exceptions müssen vom Programm aufgefangen werden! § Es gibt Exceptions, die können überall auftreten (Division durch 0, Dereferenzieren von null, …) – auf diese Exceptions ist das Java System vorbereitet § Für andere Exceptions braucht das System Hilfe um zu wissen, wo eine Exception behandelt wird 21 Exceptions auffangen § Exceptions für die das System mehr Informationen braucht heissen «checked Exceptions» (überprüfte Ausnahmen) § Wer prüft? Der Compiler § Compiler prüft dass die Exception entweder lokal aufgefangen wird oder die aufgerufene Methode gibt an, dass eine Exception auftreten kann. § Sonst wird das Programm nicht übersetzt § Müssen festlegen, wie unser Programm mit I/O-Problemen umgeht… 22 throws-Ankündigung § throws: Ankündigung in der Deklaration einer Methode § Deklariert, dass Methode evtl. eine Exception wirft… § … und nicht selber wieder auffängt! § D.h. wer die Methode aufruft, muss die Exception fangen (oder sie wiederum ankündigen) § Syntax: public static retType name(…) throws type § oder public retType name(…) throws type § Wobei type die Art der geworfenen Exception ist 23 throws-Ankündigung § Was für Methoden gilt, gilt auch für Konstruktoren § throws: Ankündigung in der Deklaration eines Konstruktors § Wer diesen Konstruktor verwendet muss Exceptions fangen (oder sie wiederum ankündigen) § Syntax: public cType(…) throws eType § Wobei eType die Art der geworfenen Exception ist und § cType ist der Name der Klasse für den Konstruktor 24 Das kennen wir doch schon… 25 throws-Beispiel § Jetzt ist der Compiler zufrieden! § Exceptions, welche die main-Methode wirft, werden vom System gefangen (und produzieren einen Stacktrace) 26 \u0000 Addendum § Nicht alle Konstruktoren von Scanner werfen möglicherweise eine Exception § Deshalb konnten wir einen Scanner für System.in erstellen new Scanner(System.in) // Konstruktor für InputStream new Scanner(new File(\"input.txt\")) // Konstruktor für File 27 Übersicht 5.1 Arbeiten mit Dateien 5.2 Scanner im Einsatz/Beispiele 5.3 Output 5.4 Einfache Graphische Benutzeroberfläche (GUI) 28 5.2 Input (soweit mit Scanner) § Folge von Zeichen die der Scanner liest: Token § Input Element § Erwartete Zeichen hängen von Methode (z.B. nextDouble()) ab § Scanner zerlegt den Inhalt einer File in Tokens 29 Scanner Methoden Method Description nextInt() reads an int from the user and returns it nextDouble() reads a double from the user next() reads a one-word String from the user nextLine() reads a one-line String from the user Input Tokens § Wenn eine Input Datei diese Zeichen (Buchstaben) enthält: 23 3.14 \"John Smith\" § Dann kann der Scanner die Tokens als Input verschiedener Typen interpretieren: Token Type(s) 23 int, double, String 3.14 double, String \"John String Smith\" String 32 Files und der Input Cursor («Zeiger») § Nehmen wir an, eine Datei weather.txt enthält diesen Text: 16.2 23.5 19.1 7.4 22.8 18.5 -1.8 14.9 § Für den Scanner ist jeder Input eine Folge von Buchstaben: 16.2 23.5\\n19.1 7.4 22.8\\n\\n18.5 -1.8 14.9\\n ^ § ^ ist der «input cursor»: die augenblickliche Position des Scanners § \\n steht für «Neue Zeile» oder «Umbruch» ist aber ein Zeichen in der Datei 34 Verarbeiten einer Input File § Der Scanner identifiziert ein Token § Das Token wird gelesen und an den Aufrufer des Scanners abgeliefert § Annahme: keine Fehler § Dabei wird der Cursor über die gelesenen Buchstaben geführt § Wir sagen der Scanner konsumiert das Token 36 Konsumieren von Input § Konsumieren von Tokens: Input lesen und dabei Cursor weiter bewegen § Aufruf von nextInt, nextDouble, etc. bewegt den Cursor hinter das aktuelle Token. 16.2 23.5\\n19.1 7.4 22.8\\n\\n18.5 -1.8 14.9\\n ^ § Die Datei wird dabei nicht verändert 37 Konsumieren von Input, Teil 2 § Aufruf von nextInt, nextDouble, etc. bewegt den Cursor hinter das aktuelle Token. 16.2 23.5\\n19.1 7.4 22.8\\n\\n18.5 -1.8 14.9\\n ^ double d = input.nextDouble(); // 16.2 16.2 23.5\\n19.1 7.4 22.8\\n\\n18.5 -1.8 14.9\\n ^ String s = input.next(); // \"23.5\" 16.2 23.5\\n19.1 7.4 22.8\\n\\n18.5 -1.8 14.9\\n ^ 38 File Input Aufgabe 1 § Gegeben eine File mit Wetter Daten § Schreiben Sie ein Programm das den Temperaturunterschied zwischen zwei aufeinander folgenden Tagen berechnet. 16.2 23.5 19.1 7.4 22.8 18.5 -1.8 14.9 16.2 to 23.5, change = 7.3 23.5 to 19.1, change = -4.4 19.1 to 7.4, change = -11.7 7.4 to 22.8, change = 15.4 22.8 to 18.5, change = -4.3 18.5 to -1.8, change = -20.3 -1.8 to 14.9, change = 16.7 40 File Input Antwort // Displays changes in temperature from data in an input file. import java.io.File; import java.io.FileNotFoundException; import java.util.Scanner; public class Temperatures { public static void main(String[] args) throws FileNotFoundException { Scanner input = new Scanner(new File(\"weather.txt\")); double prev = input.nextDouble(); // fencepost for (int i = 1; i <= 7; i++) { double next = input.nextDouble(); System.out.println(prev + \" to \" + next + \", change = \" + (next - prev)); prev = next; } } } 41 Lesen einer ganzen File § Nehmen wir an unser Programm sollte für eine beliebige Anzahl von Zahlen in der Datei funktionieren. § Bis jetzt wurden zusätzliche Daten nicht gelesen. § Wenn die Datei weniger Daten enthält – was passiert dann? Ein Laufzeitfehler! Beispiel mit einer Datei mit 3 Zahlen: 16.2 to 23.5, change = 7.3 23.5 to 19.1, change = -4.4 Exception in thread \"main\" java.util.NoSuchElementException at java.util.Scanner.throwFor(Scanner.java:838) at java.util.Scanner.next(Scanner.java:1347) at Temperatures.main(Temperatures.java:12) 42 Scanner Exceptions § NoSuchElementException § Versuch über das Ende der Datei hinauszulesen § InputMismatchException § Versuch den falschen Type von Daten zu lesen (z.B. lesen von \"hi\" als int). 43 Scanner Exceptions beheben § Finden Sie die Stelle im ExceptionText, die sich auf eine Zeile Ihres Programms bezieht § Erste Zeile die sich auf Ihr Programm bezieht; oft gegen Ende der Fehlermeldung Exception in thread \"main\" java.util.NoSuchElementException at java.util.Scanner.throwFor(Scanner.java:838) at java.util.Scanner.next(Scanner.java:1347) at Temperatures.main(Temperatures.java:12) 44 Scanner Methoden § Diese Scanner Methoden prüfen ob gültiger Input vorliegt § Konsumieren keinen Input – lieferen nur Information über das nächste Token § Praktisch um vorauszusehen was für Input kommt um so Laufzeitfehler zu verhindern. Method Description hasNext() returns true if there is a next token hasNextInt() returns true if there is a next token and it can be read as an int hasNextDouble() returns true if there is a next token and it can be read as a double 45 Gebrauch der hasNext Methode § Um Lesen mit einem unpassenden Typ zu vermeiden: Scanner console = new Scanner(System.in); System.out.print(\"How old are you? \"); if (console.hasNextInt()) { int age = console.nextInt(); // will not crash! System.out.println(\"Wow, \" + age + \" is old!\"); } else { System.out.println(\"You didn't type an integer.\"); } 46 Gebrauch der hasNext Methode § Um nicht über das Ende einer Datei hinauszulesen: Scanner input = new Scanner(new File(\"example.txt\")); if (input.hasNext()) { String token = input.next(); // will not crash! System.out.println(\"next token is \" + token); } 47 File Input Aufgabe 2 § Verändern Sie das Temperatur Programm, so dass es die gesamte File verarbeitet, unabhängig von der Anzahl der Datensätze in der File. § Beispiel: Mit Daten für den 9. Tag wäre der Output: 16.2 to 23.5, change = 7.3 23.5 to 19.1, change = -4.4 19.1 to 7.4, change = -11.7 7.4 to 22.8, change = 15.4 22.8 to 18.5, change = -4.3 18.5 to -1.8, change = -20.3 -1.8 to 14.9, change = 16.7 14.9 to 16.1, change = 1.2 48 File Input Lösung 2 // Displays changes in temperature from data in an input file. import java.io.File; // for File import java.io.FileNotFoundException; import java.util.Scanner; // for Scanner public class Temperatures { public static void main(String[] args) throws FileNotFoundException { Scanner input = new Scanner(new File(\"weather.txt\")); double prev = input.nextDouble(); // fencepost while (input.hasNextDouble()) { double next = input.nextDouble(); System.out.println(prev + \" to \" + next + \", change = \" + (next - prev)); prev = next; } } } 49 File Input Aufgabe 3 § Modifizieren Sie das Temperatur Programm so dass es auch dann funktioniert wenn die Input Datei nicht-numerische Tokens enthält. § Diese sollten ignoriert werden § Für die Input File weather2.txt sollte das Programm den selben Output lieferen wie vorher 16.2 23.5 Dienstag 19.1 Mittwoch 7.4 Do.Wert: 22.8 18.5 -1.8 <-- Messfehler??? --Stefan P. 14.9 :-) § Sie können davon ausgehen dass das 1. Token eine reelle Zahl ist. 50 File Input Lösung 3 // Displays changes in temperature from data in an input file. import java.io.File; import java.io.FileNotFoundException; import java.util.Scanner; public class Temperatures2 { public static void main(String[] args) throws FileNotFoundException { Scanner input = new Scanner(new File(\"weather.txt\")); double prev = input.nextDouble(); // fencepost while (input.hasNext()) { if (input.hasNextDouble()) { double next = input.nextDouble(); System.out.println(prev + \" to \" + next + \", change = \" + (next - prev)); prev = next; } else { input.next(); // throw away unwanted token } } } } 51 File Input Lösung 3 // Displays changes in temperature from data in an input file. import java.io.File; import java.io.FileNotFoundException; import java.util.Scanner; public class Temperatures2 { public static void main(String[] args) throws FileNotFoundException { Scanner input = new Scanner(new File(\"weather.txt\")); double prev = input.nextDouble(); // fencepost while (input.hasNext()) { if (input.hasNextDouble()) { double next = input.nextDouble(); System.out.println(prev + \" to \" + next + \", change = \" + (next - prev)); prev = next; } else { input.next(); // throw away unwanted token } } } } 52 Ein weiteres Problem (Arbeitszeit berechnen) § Die File hours.txt enthält die folgenden Daten: 123 Paula 12.5 8.1 7.6 3.2 456 Erich 4.0 11.6 6.5 2.7 12 789 Steffie 8.0 8.0 8.0 8.0 7.5 § Wir woll(t)en ein Programm schreiben das die Anzahl Stunden für jede Person berechnet: Paula (ID#123) worked 31.4 hours (7.85 hours/day) Erich (ID#456) worked 36.8 hours (7.36 hours/day) Steffie (ID#789) worked 39.5 hours (7.9 hours/day) 53 Pro Person eine Zeile Ein weiteres Problem (Arbeitszeit berechnen) § Die File hours.txt enthält die folgenden Daten: 123 Paula 12.5 8.1 7.6 3.2 456 Erich 4.0 11.6 6.5 2.7 12 789 Steffie 8.0 8.0 8.0 8.0 7.5 § Wir hatten die Details des Einlesens der Daten zurückgestellt. § Jetzt sehen wir wie wir die Datei lesen können 54 Pro Person eine Zeile Ein weiteres Problem (HoursWorked Input) § Fangen wir mit den Token an und behandeln jedes Token … 55 Lösungsversuch (HoursWorked Input) // Let’s try to fill in the body … import java.io.File; import java.io.FileNotFoundException; import java.util.Scanner; public class HoursWorked { public static void main(String[] args) throws FileNotFoundException { Scanner input = new Scanner(new File(\"hours.txt\")); while (input.hasNext()) { } } } 56 (Fehlerhafte) Lösung für HoursWorked Input // This solution does not work! while (input.hasNext()) { // process one person int id = input.nextInt(); String name = input.next(); double totalHours = 0.0; int days = 0; while (input.hasNextDouble()) { totalHours += input.nextDouble(); days++; } System.out.println(name + \" (ID#\" + id + \") worked \" + totalHours + \" hours (” + (totalHours / days) + \" hours/day)\"); } 57 Fehlerhafter Output und Exception Paula (ID#123) worked 487.4 hours (97.48 hours/day) Exception in thread \"main\" java.util.InputMismatchException at java.util.Scanner.throwFor(Scanner.java:840) at java.util.Scanner.next(Scanner.java:1461) at java.util.Scanner.nextInt(Scanner.java:2091) at HoursWorked.main(HoursBad.java:9) 58 (Fehlerhafte) Lösung zur Stundenberechnung // This solution does not work! while (input.hasNext()) { // process one person int id = input.nextInt(); String name = input.next(); double totalHours = 0.0; int days = 0; while (input.hasNextDouble()) { totalHours += input.nextDouble(); days++; } System.out.println(name + \" (ID#\" + id + \") worked \" + totalHours + \" hours (” + (totalHours / days) + \" hours/day)\"); } 60 123 Paula 12.5 8.1 7.6 3.2 456 True True True True 123 Paula 12.5 8.1 7.6 3.2 456 Erich 4.0 11.6 6.5 2.7 12 … (Fehlerhafte) Lösung zur Stundenberechnung // This solution does not work! while (input.hasNext()) { // process one person int id = input.nextInt(); String name = input.next(); double totalHours = 0.0; int days = 0; while (input.hasNextDouble()) { totalHours += input.nextDouble(); days++; } System.out.println(name + \" (ID#\" + id + \") worked \" + totalHours + \" hours (” + (totalHours / days) + \" hours/day)\"); } 61 123 Paula False 12.5 8.1 7.6 3.2 456 True True True True True 123 Paula 12.5 8.1 7.6 3.2 456 Erich 4.0 11.6 6.5 2.7 12 … Paula (ID#123) worked 487.4 hours (97.48 hours/day) (Fehlerhafte) Lösung zur Stundenberechnung // This solution does not work! while (input.hasNext()) { // process one person int id = input.nextInt(); String name = input.next(); double totalHours = 0.0; int days = 0; while (input.hasNextDouble()) { totalHours += input.nextDouble(); days++; } System.out.println(name + \" (ID#\" + id + \") worked \" + totalHours + \" hours (” + (totalHours / days) + \" hours/day)\"); } 62 123 Paula Erich 12.5 8.1 7.6 3.2 456 True True True True True 123 Paula 12.5 8.1 7.6 3.2 456 Erich 4.0 11.6 6.5 2.7 12 … Fehlerhafter Output § Etwas lief falsch … § Die innere while Schleife hat die Personalnummer der nächsten Person gelesen. § Wir wollen die Tokens verarbeiten aber wir wollen auch wissen, wo eine Zeile endete (\\n sagt an wann die Daten für eine Person abgeschlossen sind). § Eine bessere Lösung basiert auf einem hybriden Ansatz: § Zuerst: zerlege den Input in Zeilen. § Dann zerlege jede Zeile in Tokens. 63 Zeilen-basierte Scanner Aktivität Scanner input = new Scanner(new File(\"fileName\")); while (input.hasNextLine()) { String line = input.nextLine(); // bearbeiten dieser Zeile } Method Description nextLine() returns next entire line of input (from cursor to \\n) hasNextLine() returns true if there are any more lines of input to read (always true for console input) 64 Verarbeiten von Input Zeilen 23 3.14 John Smith \"Hello\" world 45.2 19 § Der Scanner liest die Zeilen folgendermassen: 23\\t3.14 John Smith\\t\"Hello\" world\\n\\t\\t45.2 19\\n ^ String line = input.nextLine(); 23\\t3.14 John Smith\\t\"Hello\" world\\n\\t\\t45.2 19\\n ^ § Jedes \\n Zeichen wird konsumiert aber nicht an die aufrufende Methode übergeben. 65 Verarbeiten von Input Zeilen 23 3.14 John Smith \"Hello\" world 45.2 19 23\\t3.14 John Smith\\t\"Hello\" world\\n\\t\\t45.2 19\\n ^ § Der Scanner liest die Zeilen folgendermassen weiter: String line2 = input.nextLine(); 23\\t3.14 John Smith\\t\"Hello\" world\\n\\t\\t45.2 19\\n^ § Vorsicht: Jedes \\n Zeichen wurde konsumiert aber nicht an die aufrufende Methode übergeben. 66 Scanner für Strings § Ein Scanner kann auch die Tokens in einem String finden: Scanner name = new Scanner(einString); § Beispiel: String text = \"15 3.2 hello 9 27.5\"; Scanner scan = new Scanner(text); int num = scan.nextInt(); System.out.println(num); // 15 double num2 = scan.nextDouble(); System.out.println(num2); // 3.2 String word = scan.next(); System.out.println(word); // hello 67 Zeilen und Tokens // Counts the words on each line of a file Scanner input = new Scanner(new File(\"input.txt\")); while (input.hasNextLine()) { String line = input.nextLine(); Scanner lineScan = new Scanner(line); // process the contents of this line … } Input file input.txt: Output to console: The quick brown fox jumps over the lazy dog. Line has 6 words Line has 3 words 68 // Counts the words on each line of a file Scanner input = new Scanner(new File(\"input.txt\")); while (input.hasNextLine()) { String line = input.nextLine(); Scanner lineScan = new Scanner(line); int count = 0; // process the contents of this line while (lineScan.hasNext()) { String word = lineScan.next(); count++; } System.out.println(\"Line has \" + count + \" words\"); } 69 Zurück zur Aufgabe, die Stunden zu berechnen § Verbessern Sie das HoursWorked Program so, dass es die Input File richtig liest: 123 Paula 12.5 8.1 7.6 3.2 456 Erich 4.0 11.6 6.5 2.7 12 789 Steffi 8.0 8.0 8.0 8.0 7.5 § Gewünschter Output: Paula (ID#123) worked 31.4 hours (7.85 hours/day) Erich (ID#456) worked 36.8 hours (7.36 hours/day) Steffi (ID#789) worked 39.5 hours (7.9 hours/day) 70 (Fehlerhafte) Lösung für HoursWorked Input // This solution does not work! while (input.hasNext()) { // process one person int id = input.nextInt(); String name = input.next(); double totalHours = 0.0; int days = 0; while (input.hasNextDouble()) { totalHours += input.nextDouble(); days++; } System.out.println(name + \" (ID#\" + id + \") worked \" + totalHours + \" hours (” + (totalHours / days) + \" hours/day)\"); } 71 // Processes an employee input file and outputs each employee's hours. import java.io.File; import java.io.FileNotFoundException; import java.util.Scanner; public class Hours { public static void main(String[] args) throws FileNotFoundException { Scanner input = new Scanner(new File(\"hours.txt\")); while (input.hasNextLine()) { String line = input.nextLine(); Scanner lineScan = new Scanner(line); int id = lineScan.nextInt(); // e.g. 456 String name = lineScan.next(); // e.g. \"Erich\" double sum = 0.0; int count = 0; while (lineScan.hasNextDouble()) { sum = sum + lineScan.nextDouble(); count++; } 72 Korrekte Lösung // Ende letzte Folie while (input.hasNextLine()) { String line = input.nextLine(); Scanner lineScan = new Scanner(line); int id = lineScan.nextInt(); // e.g. 456 String name = lineScan.next(); // e.g. \"Erich\" double sum = 0.0; int count = 0; while (lineScan.hasNextDouble()) { sum = sum + lineScan.nextDouble(); count++; } double average = sum / count; System.out.println(name + \" (ID#\" + id + \") worked \" + sum + \" hours (\" + average + \" hours/day)\"); } } } 74 Warnung: Tokens und Zeilen zusammen § Vorsicht bei der Verwendung von nextLine wenn auch Token-basierte Methoden für den selben Scanner verwendet werden. 23 3.14 Joe \"Hello\" world 45.2 19 § Wir sehen einen int Wert, einen double Wert und dann eine Zeile Text. 75 Tokens und Zeilen § Hier ist ein erster Versuch: § Wir (versuchen) 23 und 3.14 mit nextInt und nextDouble zu lesen und wollen dann Joe \"Hello\" world mit nextLine lesen. System.out.println(input.nextInt()); // 23 System.out.println(input.nextDouble()); // 3.14 System.out.println(input.nextLine()); // § Aber der Aufruf von nextLine liefert keinen Output! Warum? 76 23 3.14 Joe \"Hello\" world 45.2 19 Tokens und Zeilen § Sie sollten nicht Tokens und Zeilen vom selben Scanner lesen: 23 3.14 Joe \"Hello\" world 45.2 19 input.nextInt() // 23 23\\t3.14\\nJoe\\t\"Hello\" world\\n\\t\\t45.2 19\\n ^ input.nextDouble() // 3.14 23\\t3.14\\nJoe\\t\"Hello\" world\\n\\t\\t45.2 19\\n ^ input.nextLine() // \"\" (empty!) 23\\t3.14\\nJoe\\t\"Hello\" world\\n\\t\\t45.2 19\\n ^ input.nextLine() // \"Joe\\t\\\"Hello\\\" world\" 23\\t3.14\\nJoe\\t\"Hello\" world\\n\\t\\t45.2 19\\n ^ 77 Beispiel Scanner console = new Scanner(System.in); System.out.print(\"Enter your age: \"); int age = console.nextInt(); System.out.print(\"Now enter your name: \"); String name = console.nextLine(); System.out.println(name + \" is \" + age + \" years old.\"); 78 Beispiel Fortsetzung § Protokoll der Ausführung (Benutzer Eingabe unterstrichen): Enter your age: 12 Now enter your name: Sideshow Bob is 12 years old. § Warum? § Input insgesamt: 12\\nSideshow Bob § Nach nextInt(): 12\\nSideshow Bob ^ § Nach nextLine(): 12\\nSideshow Bob ^ 79 Übersicht 5.1 Arbeiten mit Dateien 5.2 Scanner im Einsatz/Beispiele 5.3 Output 5.4 Einfache Graphische Benutzeroberfläche (GUI) 82 PrintStream-Klasse § Wie File aus java.io; erlaubt es Daten auszugeben (z.B. in eine File) § Alle Methoden, die wir von System.out kennen, funktionieren auch für PrintStream! § D.h. print(), println() § Syntax: 83 File file = new File(\"example.txt\"); PrintStream output = new PrintStream(file); PrintStream output = new PrintStream(new File(\"example.txt\")); Statt in Konsole, in Datei 84 import java.io.File; import java.io.FileNotFoundException; import java.io.PrintStream; File file = new File(\"output.txt\"); PrintStream fileOutput = new PrintStream(file); for (int i = 0; i < 10; i++) { .print(\"Hello World \"); .print(i); .println(\"!\"); } System.out System.out System.out fileOutput fileOutput fileOutput Datei-Ausgabe § Wenn Datei nicht existiert, wird sie erstellt § Wenn sie existiert, wird sie überschrieben! § Ausgabe ansehen: § In Eclipse auf Projekt rechtsklicken à Refresh § Datei output.txt sollte erscheinen (im Projekt, nicht im Java src Folder) § Doppelklick 85 Mehr über PrintStream PrintStream name = new PrintStream(new File(\"file name\")); § Öffnet die Datei (zum Schreiben) § Falls keine Datei mit diesem Namen existiert so wird sie erstellt § Sollte die Datei schon existieren so wird sie überschrieben. § Beliebter (?) Fehler: eine Datei in einer Methode zum Schreiben öffnen § Die Methode mehrfach ausführen § Die Datei wird wiederholt geöffnet, alter Inhalt geht verloren § Nur der letzte Output kann in der Datei gefunden werden § Output den das Programm produziert erscheint in einer Datei, nicht im Konsole Fenster. Mit Editor (oder IDE) den Inhalt ansehen. 86 Mehr über PrintStream PrintStream name = new PrintStream(new File(\"file name\")); § Arbeiten Sie nicht mit der selben Datei als Input (Lesen durch Scanner) und Output (Schreiben mit PrintStream) zur selben Zeit! § Sie überschreiben die Input Datei und ersetzen sie durch eine leere Datei (0 Byte). 87 PrintStream Aufgabe § Modifieren Sie die vorherige Version von Hours so dass es einen PrintStream verwendet um Output in die File hours_out.txt zu schreiben § Das Programm soll keinen Konsolen Output produzieren. § Aber die Datei hours_out.txt soll erschaffen werden und diesen Text enthalten: Paula (ID#123) worked 31.4 hours (7.85 hours/day) Erich (ID#456) worked 36.8 hours (7.36 hours/day) Steffi (ID#789) worked 39.5 hours (7.9 hours/day) 89 PrintStream Lösung // Processes an employee input file and outputs each employee's hours. import java.io.File; // for File import java.io.FileNotFoundException; import java.io.PrintStream; import java.util.Scanner; // for Scanner public class Hours2 { public static void main(String[] args) throws FileNotFoundException { Scanner input = new Scanner(new File(\"hours.txt\")); PrintStream out = new PrintStream(new File(\"hours_out.txt\")); while (input.hasNextLine()) { String line = input.nextLine(); Scanner lineScan = new Scanner(line); int id = lineScan.nextInt(); // e.g. 456 String name = lineScan.next(); // e.g. \"Eric\" double sum = 0.0; int count = 0; // while 90 PrintStream Lösung while (lineScan.hasNextDouble()) { sum = sum + lineScan.nextDouble(); count++; } double average = sum / count; out.println(name + \" (ID#\" + id + \") worked \" + sum + \" hours (\" + average + \" hours/day)\"); } } } 91 Beispiel: Filenamen als User Input § Wir können den Namen der File, die gelesen werden soll, vom Benutzer erfragen. § Der Name der File könnte Leerzeichen enthalten; verwenden Sie nextLine(), nicht next() // prompt for input file name Scanner console = new Scanner(System.in); System.out.print(\"Type a file name to use: \"); String filename = console.nextLine(); Scanner input = new Scanner(new File(filename)); 92 Beispiel: Filenamen als User Input § Die Klasse File stellt eine exists Methode zur Verfügung um zu testen ob der Filename sich auf eine File bezieht (verhindert FileNotFoundException später): File file = new File(\"hours.txt\"); if (!file.exists()) { // try a second input file as a backup System.out.print(\"hours.txt file not found!\"); file = new File(\"hours2.txt\"); } 94 Übersicht 5.1 Arbeiten mit Dateien 5.2 Scanner im Einsatz/Beispiele 5.3 Output 5.4 Einfache Graphische Benutzeroberfläche (GUI) 9596 5.4 Einfache Graphische Benutzeroberfläche (GUI) Demo bei Interesse in Übungen «GUI» § GUI: Graphical User Interface § (Grafische Benutzeroberfläche/-schnittstelle) § Thema: Input/Output (I/O) § Bisher, Input/Output über die Konsole § Output: System.out.println() § Input: new Scanner(System.in).nextInt() 98 Pseudo-GUIs § Man kann die Konsole für vieles verwenden… § … aber wo hört der Spass auf? 99 [147.0, 149.6) ├─╫─┤ [149.6, 152.2) ├──────╫──────────────┤ [152.2, 154.8) ├──────╫────────────┤ [154.8, 157.4) ├───────╫────────┤ [157.4, 160.0) ├──────╫──────────────────┤ [160.0, 162.6) ├─────────────╫───────────────────┤ [162.6, 165.2) ├─────────╫─────────────────────────────────┤ [165.2, 167.8) ├─────────╫────────────────┤ [167.8, 170.4) ├───────────╫─────────────────┤ [170.4, 173.0) ├─────────────╫──────────────────────────┤ [173.0, 175.6) ├──────────────╫───────────────┤ [175.6, 178.2) ├────────────────╫─────────────────────────────┤ [178.2, 180.8) ├──────────────╫──────────┤ [180.8, 183.4) ├─────────╫─────────┤ [183.4, 186.0) ├────────────╫───────────────┤ [186.0, 188.6) ├──────────╫───────────┤ [188.6, 191.2) ├───────────╫───────────────┤ [191.2, 193.8) ├─────────╫──────┤ [193.8, 196.4) [196.4, 199.0) ├─╫─┤ ----------------------------------- | | | | | +++++++ | | +++++++ | | +++++++ | | +++++++++++++++++++++ | | +++++++++++++++++++++ | | +++++++++++++++++++++ | | +++++++ | | +++++++ | | +++++++ | | | | | ----------------------------------- «Richtige» GUIs (die den Namen graphisch verdienen) § Input/Output in einem Fenster, d.h. grafisch 100 «Echte» GUIs § Vorteile § 2- oder sogar 3-dimensional (Konsole ist 1-dimensional) § Eingabe durch Maus/Gesten möglich § Oft intuitiver und ansprechender § Nachteil: Hohe Komplexität gegenüber Konsole § Kontrollfluss: Programm muss jederzeit auf Benutzer reagieren § Verschiedene Steuerelemente: Knöpfe, Textboxen, Auswahlboxen, Listen, Menüs, Drag-and-drop… § Layout muss sich an Fenstergrösse anpassen 102 Komplexität 103 § Wollen Java Programm einmal entwickeln § Dann auf Linux, MacOS, und Microsoft Windows Systemen ausführen § Aber jedes Betriebssystem hat (heute) ein eigenes GUI System § Mit den eigenen Vorstellungen wie ein Fenster aussehen soll § Entweder macht Java alles selbst oder muss sich anpassen Microsoft Windows 104 MacOS 10.x Scharfe Ecken vs Runde Ecken Position des Namens Grösse des Kontrolstreifens Steuerfeld(er) Window-Klasse § Einfache Fenster ohne Steuerelemente oder anpassbares Layout § Entwickelt von Michael Faes 105 import gui.Window; public class Empty { public static void main(String[] args) { Window window = new Window(\"Empty\", 500, 300); window.open(); window.waitUntilClosed(); } } 106107 § Vordefinierte Window-Klasse (wie Scanner) § Neues Fenster erstellen mit new Window(…) import gui.Window; public class Empty { public static void main(String[] args) { Window window = new Window(\"Empty\", 500, 300); window.open(); window.waitUntilClosed(); } } Window-Klasse 108 Fenstertitel Breite Höhe Window-Methoden 109 open() Fenster wird geöffnet, d.h. sichtbar close() Fenster wird geschlossen, d.h. unsichtbar waitUntilClosed() Programm wartet, bis Benutzer das Fenster schliesst (z.B. durch den ● oder ⨉ klicken) isOpen() Gibt true zurück, falls Fenster gerade offen ist, sonst false Zeichnen § Weitere Methoden um Formen, Text oder Bilder auf das Fenster zu zeichnen 110 import gui.Window; public class Square { public static void main(String[] args) { Window window = new Window(\"Square\", 500, 300); window.fillRect(20, 20, 50, 50); window.open(); window.waitUntilClosed(); } } Breite Höhe 111 Zeichnen § Weitere Methoden um Formen, Text oder Bilder auf das Fenster zu zeichnen 112 import gui.Window; public class Square { public static void main(String[] args) { Window window = new Window(\"Square\", 500, 300); window.fillRect(20, 20, 50, 50); window.open(); window.waitUntilClosed(); } } x-Koordinate y-Koordinate Breite Höhe Fenster-Koordinatensystem § GUIs 113 § Mathematik Einheit: 1 Pixel Mehr Zeichnen 114 Window window = new Window(\"Squares\", 500, 300); for (int i = 0; i < 4; i++) { window.fillRect(60 * i + 20, 60 * i + 20, 50, 50); } window.open(); window.waitUntilClosed(); 115 Window window = new Window(\"Squares\", 500, 300); for (int i = 0; i < 4; i++) { window.fillRect(60 * i + 20, 60 * i + 20, 50, 50); } window.open(); window.waitUntilClosed(); Mehr Zeichnen 116 Window window = new Window(\"Squares\", 500, 300); window.setColor(255, 0, 0); for (int i = 0; i < 4; i++) { window.fillRect(60 * i + 20, 60 * i + 20, 50, 50); } window.open(); window.waitUntilClosed(); Farben! § Farbe bleibt so lange bestehen, bis sie wieder geändert wird. 117 Farben mischen § Alle Farben werden aus drei Grundfarben gemischt: § Mischung funktioniert «additiv”, d.h. mehr von einer Grundfarbe gibt helleren Farbton. 118 Bild von Benutzer Bb3cxv, en.wikipedia.org/wiki/Image:RGB_illumination.jpg Blau Grün Rot RGB Farben mischen § Farben befinden sich in einem 3D-Raum, mit Achsen R, G, B: 119Bild von Benutzer SharkD, commons.wikimedia.org/wiki/File:RGB_color_solid_cube.png setColor(255, 0, 0); setColor( 0, 255, 0); setColor( 0, 0, 255); setColor(255, 0, 255); setColor(255, 255, 255); setColor( 0, 0, 0); setColor(127, 127, 127); setColor( 70, 80, 120); Ablauf für einfache GUI-Programme 1. Erstellen eines Fensters: new Window(…) «Leinwand erwerben» 2. Inhalt ausgeben, d.h. zeichnen: setColor(…), fill…() «Leinwand bemalen» 3. Fenster sichtbar machen: open() «Vernissage» 120121 Einfache Zeichen-Methoden § Trick: fillRect(x, y, 1, 1) zeichnet einzelnen Pixel! fillRect(double x, double y, double width, double height) Zeichnet ein (ausgefülltes) Rechteck der Grösse width × height, welches die linke obere Ecke beim Punkt (x, y) hat fillCircle(double x, double y, double radius) Zeichnet einen (ausgefüllten) Kreis mit Radius radius, welches den Mittelpunkt beim Punkt (x, y) hat fillOval(double x, double y, double width, double height) … Pixelweise zeichnen § Farbe des Pixels ist abhängig von der Position. Je mehr x, desto mehr Grün, usw. 122 Window window = new Window(\"Pixels\", 255, 255); for (int x = 0; x < 255; x++) { for (int y = 0; y < 255; y++) { window.setColor(127, x, y); window.fillRect(x, y, 1, 1); } } window.open(); window.waitUntilClosed(); Funktionen-Plotter 123 int width = 500, height = 300; Window window = new Window(\"Plotter\", width, height); for (int i = 0; i < width; i++) { double x = 0.05 * i; double y = Math.sin(x); window.fillRect(i, y * height/4 + height/2, 1, 1); } window.open(); window.waitUntilClosed(); 124 Koordinatentransformation 125 int width = 500, height = 300; Window window = new Window(\"Plotter\", width, height); for (int i = 0; i < width; i++) { double x = 0.05 * i; double y = Math.sin(x); window.fillRect(i, y * height/4 + height/2, 1, 1); } window.open(); window.waitUntilClosed(); 1 x-Einheit = 20 px 1 y-Einheit = Höhe/4 y-Achse in der Mitte des Fensters Ändern des Fensterinhalts?? § Bisher: Fenster erstellen, zeichnen, anzeigen. § Was, wenn wir Fensterinhalt ändern möchten? § Geht nicht, Zeichnung muss «veröffentlicht» werden! 126 Window window = new Window(\"Fenster\", 500, 300); // Zeichnen window.open(); window.waitUntilClosed(); ? Veröffentlichen von Änderungen 127 refresh() Zeigt die aktuelle Zeichnung im Fenster an. refresh(int waitTime) Zeigt die aktuelle Zeichnung im Fenster an. Um ein konstantes Zeitintervall zwischen mehreren Refreshs zu erreichen, zeigt diese Methode die Änderungen erst waitTime Millisekunden nach dem letzten Aufruf von refresh() an. refreshAndClear(int waitTime) Zeigt wie refresh(waitTime) die aktuelle Zeichnung an, aber leert die Zeichnungsfläche danach für ein neues Bild. Plotten, animiert! 128 int width = 500, height = 300; Window window = new Window(\"Plotter\", width, height); window.open(); for (int i = 0; i < width; i++) { double x = 0.05 * i; double y = Math.sin(x); window.fillRect(i, y * height/4 + height/2, 1, 1); window.refresh(10); } window.waitUntilClosed(); 129 Oder, mit refreshAndClear() 130 int width = 500, height = 300; Window window = new Window(\"Plotter\", width, height); window.open(); for (int i = 0; i < width; i++) { double x = 0.05 * i; double y = Math.sin(x); window.fillCircle(i, y * height/4 + height/2, 10); window.refreshAndClear(10); } window.waitUntilClosed(); 131 Ablauf für animierte GUI-Programme 1. Erstellen eines Fensters: new Window(…) 2. Fenster sichtbar machen: open() 3. Animieren a. Zeichnen: fill…() b. Aktuelle Zeichnung veröffentlichen: refresh() oder refreshAndClear() 132 Input/Output? § Arten von GUI-Input: § Tasten drücken § Mausklicks/-bewegungen § Touch-Gesten § … 133 Interaktion 134 int width = 500, height = 300; Window window = new Window(\"Moving\", width, height); window.open(); int x = width/2; while (window.isOpen()) { if (window.isKeyPressed(\"left\")) { x--; } if (window.isKeyPressed(\"right\")) { x++; } window.fillCircle(x, height/2, 10); window.refreshAndClear(10); } Interaktion 135 int width = 800, height = 400; PongGame game = new PongGame(width, height); Window window = new Window(\"Pong\", width, height); window.open(); while (window.isOpen()) { if (window.isKeyPressed(\"w\")) { game.move(game.p1, true); } if (window.isKeyPressed(\"s\")) { game.move(game.p1, false); } Interaktion - Fortsetzung 136 if (window.isKeyPressed(\"up\")) { game.move(game.p2, true); } if (window.isKeyPressed(\"down\")) { game.move(game.p2, false); } game.step(); drawPlayer(window, game.p1); drawPlayer(window, game.p2); for (BallNode n = game.balls.first; n != null; n = n.next) { drawBall(window, n.ball); } window.refreshAndClear(20); } Methoden für Eingabe 137 isKeyPressed(String keyName) Gibt true zurück, falls gegebene Taste im Moment gerade gedrückt wird, false andernfalls isLeftMouseButtonPressed() / isRightMouseButtonPressed() Gibt true zurück, falls die linke/rechte Maustaste im Moment gerade gedrückt wird, false andernfalls wasKeyTyped(String keyName) / was…MouseButtonClicked() Gibt true zurück, falls die gegebene Taste gerade «getippt”/«geklickt» wurde, false andernfalls getMouseX() / getMouseY() Gibt die aktuelle X-/Y-Koordinate des Mauszeigers (Cursors) zurück Ablauf für interaktive GUI-Programme 1. Erstellen eines Fensters: new Window(…) 2. Fenster sichtbar machen: open() 3. Interagieren a. Benutzereingaben abfragen: is…Pressed() b. Zeichnen: fill…() c. Aktuelle Zeichnung veröffentlichen: refresh() oder refreshAndClear() 138 Mehr Window-Methoden 139 drawRect(x, y, width, height) Zeichnet die Kontur eines Rechtecks drawCircle(x, y, radius) drawLine(x1, y1, x2, y2) drawString(string, x, y) Zeichnet den gegebenen String so, dass sich die Grundlinie des ersten Zeichens bei (x, y) befindet drawImage(path, x, y) Zeichnet das Bild, das sich in der Datei bei path befindet, mit der linken oberen Ecke bei (x, y) drawImageCentered(path, x, y) setColor(red, green, blue) Setzt die Farbe für die folgenden Zeichenbefehle auf den RGB-Wert gegeben durch red, green, blue setStrokeWidth(width) Setzt die Strichdicke für die folgenden draw-Zeichenbefehle setFontSize(fontSize) Setzt die Schriftgrösse für die folgenden drawString-Befehle ... 252-0027 Einführung in die Programmierung 4.0 Klassen und Objekte Thomas R. Gross Department Informatik ETH Zürich 1 4.0 Klassen und Objekte: Übersicht 4.1 Klassen und Objekte (allgemein) 4.2 Objekte als Parameter 4.3 Klassen (selber entwickeln) 4.4 Attribute 4.5 Klassen und ihre Klienten 4.6 Methoden 4.7 Sichtbarkeit von Attributen 4.8 Konstruktoren 4.9 static Methoden und Variable 2 4.8 Konstruktoren 3 Mehrere Konstruktoren Eine Klasse kann mehrere Konstruktoren haben. § Jeder Konstruktor muss eine unverwechselbare Liste von Parametern haben § Entscheidend ist dass die Typen der Parameterliste unverwechselbar sind § Erlaubt public Point(int initialX, int initialY) { x=initialX; y=initialY; } public Point(int initialX) {x = initialX; y = 0;} § Nicht erlaubt public Point(int initialX, int initialY) { x=initialX; y=initialY; } public Point(int a, int b) { x = a; y = b; } 4 int, int int int, int int, int Mehrere Konstruktoren § Manchmal muss ein Konstruktor einen anderen aufrufen § Delegation (eines Teils) der Initialisierung an anderen Konstruktor § Mit this(…) kann man einen anderen Konstruktor aufrufen § Ein Konstruktor ruft einen anderen auf: § this(parameters); § parameters: Liste der Parameter, kann leer sein § Klammern ( und ) wichtig § Beispiel für sinnvollen Einsatz ... 5 Einen anderen Konstruktor aufrufen public class Point { private int x; private int y; public Point() { x = 0; y = 0; } public Point(int x, int y) { this.x = x; this.y = y; } ... } 6 Einen anderen Konstruktor aufrufen public class Point { private int x; private int y; public Point() { x = 0; y = 0; } public Point(int x, int y) { this.x = x; this.y = y; } ... } 7 Da wir Point(int,int) definierten gibt es keinen default Konstrukor Einen anderen Konstruktor aufrufen public class Point { private int x; private int y; public Point() { x = 0; y = 0; } public Point(int x, int y) { this.x = x; this.y = y; } ... } Programm könnte Point() brauchen Point(0,0) erledigt den Job aber Point() muss explizit definiert werden! 8 Einen anderen Konstruktor aufrufen public class Point { private int x; private int y; public Point() { this(0, 0); // calls (x, y) constructor } public Point(int x, int y) { this.x = x; this.y = y; } ... } 11 Einen anderen Konstruktor aufrufen § Vermeidet Redundanz zwischen Konstruktoren § Nur ein Konstruktor kann einen anderen Konstruktor aufrufen § Eine Methode kann nicht einen Konstruktor aufrufen! 13 Häufige Fehler in Konstruktoren 1. (Erneute) Deklaration von Attributen als Variable: public Point(int initialX, int initialY) { int x = initialX; int y = initialY; } § Jetzt gibt es Variable x und y die nur im Konstruktor bekannt sind. Diese erhalten einen Wert – aber die Attribute werden nicht modifiziert und bleiben 0. 15 Häufige Fehler in Konstruktoren 2. Versehentlich für den Konstruktor einen Rückgabewert deklarieren: public void Point(int initialX, int initialY) { x = initialX; y = initialY; } § Nicht die Definition eines Konstruktors sondern die Definition einer Methode mit Namen Point § Erlaubt aber nicht sinnvoll 16 Häufige Fehler mit Konstruktoren 3. Den parameterlosen default Konstruktor verwenden wenn andere Konstruktoren definiert wurden aber kein neuer parameterloser Konstruktor definiert wurde. public class PPoint { int x; int y; public PPoint(int initialX, int initialY) { … } // methods } // in the client PPoint p = new PPoint(); 17 4.9 static Methoden und Variablen 19 Kurze Geschichte der Methoden die wir in der Vorlesung kennen gelernt hatten § public static void main(String[] args) { … } § public static void name() { … } § public static void name(type name) { … } § public static type name(type name) { … } § public type name(type name) { … } § private type name(type name) { … } 20 Kurze Geschichte der Methoden die wir in der Vorlesung kennen gelernt hatten § public static void main(String[] args) { … } § public static void name() { … } § public static void name(type name) { … } § public static type name(type name) { … } § public type name(type name) { … } § private type name(type name) { … } 21 Namenloser Service (Hilfs)Methode für … mit Parametern … und Rückgabewert Methode (überall sichtbar) Methode (intern sichtbar) Was bedeutet static wirklich? Methoden die wir in der Vorlesung kennen gelernt hatten § public static void main(String[] args) { … } § public static void name() { … } § public static void name(type name) { … } § public static type name(type name) { … } § public type name(type name) { … } § private type name(type name) { … } 22 Was bedeutet static wirklich? Methoden die wir in der Vorlesung kennen gelernt hatten § public static type name(type name) { … } § Kann von main (oder anderer Methode mit static Eigenschaft) aufgerufen werden § public type name(type name) { … } § Kann für Objekt aufgerufen werden: von Methode (in Klasse) oder mit «Dot» Notation von ausserhalb § Es muss ein Exemplar geben 23 Vom Programm zum (Software)System § Fast alle Software Systeme bestehen aus vielen Klassen § Eine Hauptklasse ruft Methoden anderer Klassen auf § Hauptklasse hat eine Anfangsmethode public static void main (String[] args) Main Class #1 main method1 method2 Class #2 method3 method5 Class #3 method4 method6 § Vorteile: § Code Wiederverwendung § Gliedert das Programm in überschaubare Teile 25 Vom Programm zum (Software)System § Fast alle Software Systeme bestehen aus vielen Klassen § Eine Hauptklasse ruft Methoden anderer Klassen auf § Hauptklasse hat eine Anfangsmethode public static void main (String[] args) Main Class #1 main method1 method2 Class #2 method3 method5 Class #3 method4 method6 26 Main Class #4 main methodA methodB Ein Programm mit Redundanz, Aufgabe 1 // This program sees whether some interesting numbers are prime. public class Primes1 { public static void main(String[] args) { int[] nums = {1234517, 859501, 53, 142}; for (int i = 0; i < nums.length; i++) { if (isPrime(nums[i])) { System.out.println(nums[i] + \" is prime\"); } } } // continued on next slide 27 Ein Programm mit Redundanz, Aufgabe 1, Teil 2 // Returns the number of factors of the given integer. public static int countFactors(int number) { int count = 0; for (int i = 1; i <= number; i++) { if (number % i == 0) { count++; // i is a factor of the number } } return count; } // Returns true if the given number is prime. public static boolean isPrime(int number) { return countFactors(number) == 2; } } 28 Ein Programm mit Redundanz, Aufgabe 2 // This program prints all prime numbers up to a maximum. public class Primes2 { public static void main(String[] args) { Scanner console = new Scanner(System.in); System.out.print(\"Max number? \"); int max = console.nextInt(); for (int i = 2; i <= max; i++) { if (isPrime(i)) { System.out.print(i + \" \"); } } System.out.println(); } // continued on next slide 29 Ein Programm mit Redundanz, Aufgabe 2, Teil 2 // Returns true if the given number is prime. public static boolean isPrime(int candidate) { return countFactors(candidate) == 2; } // Returns the number of factors of the given integer. public static int countFactors(int candidate) { int count = 0; for (int i = 1; i <= candidate; i++) { if (candidate % i == 0) { count++; // i is a factor of the number } } return count; } } 30 Redundanz in Programmen § Wir möchten die gemeinsamen Methoden nur einmal schreiben § … nur einmal dokumentieren § ... nur einmal testen § ... (später) nur einmal verändern (falls nötig) § Klassen geben uns die Möglichkeit gemeinsames Verhalten (von Objekten) zusammenzufassen. 31 Redundanzen public class Primes1 { public static int countFactors(int number) { .. } public static boolean isPrime(int number) { .. } } public class Primes2 { public static boolean isPrime(int candidate) { .. } public static int countFactors(int candidate) {.. } } 32 Klassen als Module § Modul: wiederverwendbare Software, in einer Klasse abgelegt. § Beispiele von Modulen (Klassen): Math, Arrays, System § Im Beispiel legen wir die gemeinsamen Methoden in einer Klasse Factors ab 33 Vom Programm zum (Software)System § Fast alle Software Systeme bestehen aus vielen Klassen § Eine Hauptklasse ruft Methoden anderer Klassen auf § Hauptklasse hat eine Anfangsmethode public static void main (String[] args) Primes1 main Factors isPrime(int) countFactors(int) 34 Primes2 main Klassen als Module // This class is a module that contains useful methods // related to factors and prime numbers. public class Factors { // Returns the number of factors of the given integer. public static int countFactors(int number) { int count = 0; for (int i = 1; i <= number; i++) { if (number % i == 0) { count++; // i is a factor of the number } } return count; } 35 Klassen als Module // Returns true if the given number is prime. public static boolean isPrime(int number) { return countFactors(number) == 2; } } // Factors 36 Module § Ein Modul ist Teil eines Programms, nicht ein vollständiges (ausführbares) Programm. § Es gibt keine main Methode. Code kann nicht direkt ausgeführt werden. § Module sollen von Klienten (Programmen/Klassen) verwendet werden. § Syntax: class.method(parameters); class: Name der Klasse § Beispiel: § int factorsOf24 = Factors.countFactors(24); 37 static Variable und Methoden § static: ist Teil einer Klasse, nicht Teil (Attribut) eines Objekt(exemplar)s. § Klassen können static Methoden und Variable haben § (Leider) heissen «static Variable» im Englischen manchmal «fields» § Eine static Variable existiert nur einmal – Methoden aller Exemplare der Klasse können auf diese zugreifen § Eine static Variable wird nicht (wie ein Attribut) für jedes Objekt geschaffen. § Statt static Variable verwenden viele Autoren den Begriff «class variable» («Klassenvariable») 38 static Variable und Methoden § static: ist Teil einer Klasse, nicht Teil (Attribut) eines Objekt(exemplar)s. § Daher … § static Variable und Methoden existieren nur einmal und leben so lange wie die Klasse § Attribute und (Objekt)Methoden existieren so lange wir auf das Exemplar zugreifen können § static: Lebensdauer unbegrenzt (während der Ausführung des Programms) 39 static Variable und Methoden § static: ist Teil einer Klasse, nicht Teil (Attribut) eines Objekt(exemplar)s. § Daher … § static Variable und Methoden existieren nur einmal und leben so lange wie die Klasse § Attribute und (Objekt)Methoden existieren so lange wir auf das Exemplar zugreifen können § static: Lebensdauer unbegrenzt (während der Ausführung des Programms) § Klassen können auch entsorgt werden – aber nicht in «Einführung…» 40 static Variable und Methoden § static: ist Teil einer Klasse, nicht Teil (Attribut) eines Objekt(exemplar)s und eine Klassenvariable (static Variable) existiert § Eine Klassenvariable (static Variable) existiert auch wenn es keine Exemplare der Klasse gibt § Eine static Methode kann ohne Objekt(exemplar) ausgeführt werden § static Variable sollten die Ausnahme sein § Im «Normalfall» verwenden wir Objektattribute § Fast immer ist (in Ihren Programmen) static falsch! 41 42 class C Zustand (state): private static int staticFieldA private static String staticFieldB private int field1; private double field2; Verhalten (behavior) oder Service: public static void someStaticMethodC() public static void someStaticMethodD() public void method3() public int method4() object #1 state: int field1 double field2 behavior: public void method3() public int method4() object #2 state: int field1 double field2 behavior: public void method3() public int method4() object #3 state: int field1 double field2 behavior: public void method3() public int method4() § Eine static Methode ist eine Methode für die Klasse § Eine static Methode kann ohne eine Referenz auf ein Exemplar aufgerufen werden. class.method(parameters); § Deshalb haben wir z.B. Arrays.toString(…) oder Math.abs(... ) aufrufen können. 44 Beispiel, Teil 1 // This program sees whether some interesting numbers are prime. public class Primes { public static void main(String[] args) { int[] nums = {1234517, 859501, 53, 142}; for (int i = 0; i < nums.length; i++) { if (Factors.isPrime(nums[i])) { System.out.println(nums[i] + \" is prime\"); } } } } 45 Beispiel, Teil 2 // This program prints all prime numbers up to a given maximum. public class Primes2 { public static void main(String[] args) { Scanner console = new Scanner(System.in); System.out.print(\"Max number? \"); int max = console.nextInt(); for (int i = 2; i <= max; i++) { if (Factors.isPrime(i)) { System.out.print(i + \" \"); } } System.out.println(); } } 46 static Variable § static Variable: Mit der Klasse gespeichert, nicht mit jedem Objektexemplar § Gemeinsame («shared») Variable für alle Exemplare § Kann von allen Methoden aller Exemplare gelesen und modifiziert werden § Insbesondere Modifikationen sind kritisch § Leicht die Übersicht zu verlieren § Vorsicht bei static § Solche Variable speichern Zustand über mehrere Aufrufe für verschiedene Exemplare 47 Gemeinsame («shared») Variable für alle Exemplare § Vorsicht: welche Methode kann diese Variable verändern? § Vermeiden wenn nicht absolut notwendig § (Sichere) Ausnahme: Die Variable kann nicht verändert werden § Einfach bei Basistypen da die Variable den Wert speichert § Bei Referenzvariablen komplizierter 48 Gemeinsame («shared») Variable für alle Exemplare § Vorsicht: welche Methode kann diese Variable verändern? § Vermeiden wenn nicht absolut notwendig § (Sichere) Ausnahme: Die Variable kann nicht verändert werden – Keyword final § Einfach bei Basistypen da die Variable den Wert speichert § Bei Referenzvariablen komplizierter 49 Module in Java Bibliotheken // Java's built-in Math class is a module public class Math { public static final double PI = 3.14159265358979323846; ... public static int abs(int a) { if (a >= 0) { return a; } else { return -a; } } public static double toDegrees(double radians) { return radians * 180 / PI; } } 50 Deklaration (und ggf. Definition) von static Variablen Selbe Regeln wie für Attribute oder (Methoden)Variable private static type name; private static type name = value; oder static type name; static type name = value; § Beispiel: private static int theAnswer = 42; 51 Zugriff auf static Variable § Innerhalb der Klasse in der die Variable deklariert wurde: varName // get the value varName = value; // set the value § Aus einer anderen Klasse (sofern nicht private) ClassName.varName // get the value ClassName.varName = value; // set the value 52 Zugriff auf static Variable § Im Normalfall sind static Variable private es sei denn sie sind final § final: Wert kann nach Initialisierung nicht geändert werden § Damit auf (static) Variable in allen anderen Klassen zugegriffen werden kann müssen diese Variablen public sein § Also (in einer Klasse) public static type name; public static type name = value; § Keyword public erlaubt Zugriff von überall (später mehr dazu) 53 Zugriff auf static Variable § Aus einer anderen Klasse (wenn die Variable public ist): ClassName.fieldName // get the value ClassName.fieldName = value; // set the value 54 Zugriff auf static Variable § Aus einer anderen Klasse (wenn die Variable public ist): ClassName.fieldName // get the value ClassName.fieldName = value; // set the value § … doch public static sollte final sein! § Wenn nicht final, dann nur durch Accessor/Mutator Methoden erreichbar (also private) 55 Übung (Beispiel für notwendiges static) § Erweitern Sie die Klasse Person so, dass jedes neue Objekt eine eindeutige ID für die neue Person erhält § Altes Design hatte einen Konstruktor der die ID als Parameter übernahm Person employee1 = new Person(\"Paula\", 123); Person employee2 = new Person(\"Erich\", 123); § Wir wollen jetzt die ID in der Klasse verwalten/zuweisen 56 public class Person { String name; int id; double hourlyRate; double[] hours; double[] overtime; // Constructs a Person with given name and Id public Person(String firstname, int uniqueId) { name = firstname; id = uniqueId; } // Methods ... } 57 § Idee: eine static (Klassen)Variable hält fest, wieviele Objektexemplare schon erstellt wurden § Muss static sein da für alle Exemplare § Auch wenn zwischendurch es keine Exemplare mehr gibt § Wer kann erstellte Exemplare zählen? 58 § Idee: eine static (Klassen)Variable hält fest, wieviele Objektexemplare schon erstellt wurden § Muss static sein da für alle Exemplare § Auch wenn zwischendurch es keine Exemplare mehr gibt § Wer kann erstellte Exemplare zählen? § Konstruktor 59 public class Person { private static int uniqueId = 0; String name; int id; double hourlyRate; double[] hours; double[] overtime; // Constructs a Person with given name and assigns ID public Person(String firstname) { name = firstname; id = uniqueId++; } // Methods ... } 60 static Methoden § Wenn es static (Klassen)Variable gibt, dann brauchen wir (evtl.) auch Accessor und Mutator Methoden § Denn die Variable sollte private sein … § Solche Methoden müssen ohne Objekt(exemplar) aufgerufen werden können § Denn die Variable existieren ja unabhängig von Exemplaren der Klasse § Solche Methoden werden durch das Keyword static gekennzeichnet § Wie die Methoden eines Moduls 62 static Methoden § Sonst ändert sich nichts in der Definition solcher Methoden § public static type name(parameters) { Statements; } § Dies sind die Methoden die wir zuerst kennengelernt haben § Damals kannten wir keine Klassen oder Objektexemplare § Ausreichend für «namenlosen» Service § Deshalb kann main vor Erstellung des ersten Objekts aufgerufen werden 63 Typ der Rückgabe Parameterliste Name der Methode static Methoden § static Methode: Methode die in der Klasse aufgesetzt ist § Ohne Bezug zu einem Objektexemplar § Gemeinsam für alle Exemplare, nicht für jedes Exemplar § D.h. Nicht mit den Attributen/dem Zustand eines Exemplars verbunden § Es gibt keinen impliziten Parameter this § Daher kann eine solche Methode nicht auf den Zustand eines Objekts zugreifen, d.h. (Objekt)Attribute können nicht gelesen oder geschrieben werden. 64 Übung (Beispiel static Methode) § Erweitern Sie die Klasse Person um eine Methode (numberEmployees) die die Anzahl der bisher erstellten Person Objekte zurückgibt. § Muss auf static Klassenvariable zugreifen 65 Übung § Erweitern Sie die Klasse Person um eine Methode die die Anzahl der bisher erstellten Person Objekte zurückgibt. § Was müssen wir festlegen? § Sichtbarkeit (Wer kann Methode aufrufen?) § Rückgabewert § Parameter (Was braucht Methode um Job zu erledigen?) § Lebensdauer (So lange wie ein Exemplar, so lange wie die Klasse?) 66 public class Person { private static int uniqueId = 0; String name; int id; double hourlyRate; double[] hours; double[] overtime; // Constructs a Person with given name and assigns ID public Person(String firstname) { name = firstname; id = uniqueId++; } // Methods public static int numberEmployees( ) { } } 67 Übung § Erweitern Sie die Klasse Person um eine Methode die die Anzahl der bisher erstellten Person Objekte zurückgibt. § Was müssen wir festlegen? § Sichtbarkeit (Wer kann Methode aufrufen?) § Rückgabewert § Parameter (Was braucht Methode um Job zu erledigen?) § Lebensdauer (So lange wie ein Exemplar, so lange wie die Klasse?) 68 Poll public class Person { private static int uniqueId = 0; String name; int id; double hourlyRate; double[] hours; double[] overtime; // Constructs a Person with given name and assigns ID public Person(String firstname) { name = firstname; id = uniqueId++; } // Methods public static int numberEmployees( ) { return uniqueId; } } 69 Poll public class Person { private static int uniqueId = 0; String name; int id; double hourlyRate; double[] hours; double[] overtime; // Constructs a Person with given name and assigns ID public Person(String firstname) { name = firstname; id = uniqueId++; } // Methods public static int numberEmployees() { return uniqueId; } } 7071 Zusammenfassung Java Klassen § Eine Klasse kann in einem grossen Software System: 1. Ein Programm enthalten 2. Eine Objekt Klasse (d.h. Typ) definieren 3. Ein Modul definieren 72 Zusammenfassung Java Klassen § Eine Klasse kann in einem grossen Software System: 1. Ein Programm enthalten: Hat eine public static main Methode und ggf. andere static Methoden. § Normalerweise ohne static Variable (ausser sie sind final) § Implementiert einen Service für Benutzer 73 Zusammenfassung Java Klassen § Eine Klasse kann in einem grossen Software System: 2. Einen Typ definieren: Die Objekt Klasse beschreibt neuen Typ von Objekten (Werte und Verhalten) § Deklariert Objektattribute, Konstruktoren und Methoden § Deklariert möglicherweise static Variable oder Methoden, aber diese spielen i.A. eine untergeordnete Rolle § Ist abgekapselt («encapsulated») – alle Attribute (und sollte es sie geben … static Variablen) sind private § Beispiel von Objekt Klassen: Point, Person, Random, Scanner 74 Zusammenfassung Java Klassen § Eine Klasse kann in einem grossen Software System: 3. Ein Modul definieren: Wiederverwendbarer Code der durch static Methoden implementiert ist 4. Beispiel: Math, Arrays, Factors 75 Wo stehen wir? § Kernkonzepte für einfache Programme § if-else, if-else-if § Schleifen: for, while, do … while § Ausdrücke (einschliesslich Zuweisungen) § Änderungen der Ausführungsreihenfolge durch Methodenaufruf § Strukturierung in Methoden § Parameter § Rückgabewerte 76 Wo stehen wir? § Entwurf (einfacher) Klassen § Attribute § Methoden § «Klassenvariable» § Erste Schritte mit Java System § Scanner, Math, File, PrintStream, Random 77 Wo stehen wir? § Deklaration von Variablen eines Basistyps § Deklaration von Variablen eines Referenztyps § Sowohl einzelne Variable als auch Arrays § Erstellen von Objekt(exemplaren) 78 Wenn Sie mehr lesen wollen § (und das sollten Sie …) § Lehrbücher § Java Dokumentation 7980 S. Reges und M. Stepp, Building Java Programs: A Back to Basics Approach, 5th Edition, Pearson, ISBN 978-0-13-5471944. R. Sedgewick und K. Wayne, Introduction to Programming in Java: An Interdisciplinary Approach (2nd Edition) , 2017, Addison- Wesley, ISBN 978-0-67-233784-0 81 S. Reges und M. Stepp, Building Java Programs: A Back to Basics Approach, 4th Edition, Pearson, ISBN 978-0-13-432276-6. R. Sedgewick und K. Wayne, Einführung in die Programmierung mit Java, 2011, (Deutsch) ISBN 978-3-86894-0476-3. 82 R. Sedgewick und K. Wayne, Introduction to Programming in Java: An Interdisciplinary Approach (2nd Edition) , 2017, Addison- Wesley, ISBN 978-0-67-233784-0 S. Reges und M. Stepp, Building Java Programs: A Back to Basics Approach, 4th Edition, Pearson, ISBN 978-0-13-432276-6. Java Lehrbücher § Es gibt viele (in vielen Sprachen) § Werfen Sie einen Blick auch in andere Bücher § Manche Bücher sind auch online verfügbar 83 Java Informationen § Online gibt es die Sprachbeschreibung sowie die Dokumentation der APIs § Wir werden im Laufe des Semesters einige Bibliotheken (und weitere Klassen) kennenlernen § Nutzen Sie die online Informationen 8485 252-0027 Einführung in die Programmierung 6.0 Arbeiten mit Objekten und Klassen Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2020,2021 All rights reserved. 86 Übersicht 6.1 Stil und Konventionen § Hinweise (und Regeln) für verständliche Programme § Teil 1: Nicht vollständig – später erweitert 6.2 Datenstrukturen mit Verknüpfungen 6.3 Entwurf von (abgekapselten) Klassen 6.4 Programmbeispiel und –ausführung 6.5 (Mehr) Optionen für Sichtbarkeit Copyright (c) Pearson 2013 and Thomas Gross 2016,2017,2019. All rights reserved. 88 6.1 Stil und Konventionen Hinweise für verständliche Programme § Einfache Regeln § Setzen Eclipse/IDE voraus § Überlassen Sie Eclipse Layout und Formattierung 89 Hinweise und Regeln § Nicht strikt § Ausnahmen können sinnvoll sein. § Aber man sollte sich wirklich gut überlegen, ob eine Ausnahme gerechtfertigt ist. § Was ist das Ziel solcher (aller) Regeln? 90 § Programme sollen gut lesbar sein. § Möglichst kompakt («Don’t repeat yourself») 91 § Programme sollen gut lesbar sein. § Wichtige Leser sind § Development team / Maintenance team § Andere Programmierer (die mit der Problemstellung vertraut sind) § Der Compiler § Möglichst kompakt («Don’t repeat yourself») 92 Eclipse Formattierung Source -> Format 94 Programm Layout § Aufeinanderfolgende Anweisungen untereinander int x = 10; int y = x + 1; § Gleich weit eingerückt § Nicht: int x = 10; int y = x+1; int z = y*2; z = z+1; 95 «White Space»: Zwischenraum & Leerzeichen § Kosten wenig – können helfen § Einrücken von Blöcken § Trennen Keywords § for▢(int i = 1; …) oder while▢(true) § for(int i=1; …) oder while(true) § Aber § myMethod(params) oder myMethod() § myMethod▢(params), myMethod▢▢▢() oder myM(▢param▢) § Methodenaufrufe sind so schnell zu erkennen 98 ▢: Leerzeichen, zur Illustration hervorgehoben Leerzeichen § Zuweisungsoperator = mit Leerzeichen abgesetzt § Keine Leerzeichen nach ( oder vor ) § Nicht (▢ oder ▢) 99 «NewLines» § Schreiben Sie Code der durchsucht werden kann § new Operator mit Konstruktor auf eine Zeile, ein Leerzeichen § Also new▢Foo(parameter) und nicht new ↵ Foo(parameter) oder auch nicht new▢▢▢Foo(parameter) § Lange Ausdrücke: nach Operator trennen § und Rest einrücken 101 a+b+c+d wenn kein Platz a+b+ c+d Verwenden Sie { und } // Good if (x < 0) { computeHead(x); } else { colorHead(x); } // Not good if (x < 0) computeHead(x); 103 Position von { und } § Die sich öffnende Klammer { steht in der Zeile, die den neuen Block beginnt if (foo()) { nicht if (foo() { … § Die sich schliessende Klammer wird soweit eingrückt wie die Anweisung, die den Block beginnt § ... macht Eclipse für Sie ... 104 § Verwenden Sie { und } … aber nicht mehr als nöng double eps = 0; while (eps > bound) { n++ eps = findPoint(n); } { double approx = 0.0; double sum = 0.0; for (int i = 0; i <= 25; i++) { approx += 1.0/Math.pow(n, 2); } } 111 Datei Layout § Reihenfolge in Datei Name.java § Import § (Haupt) Klasse (public class Name …) § main Methode (wenn vorhanden) § andere Methoden § ggf. andere Klassen (später mehr) 113 Klassen § Attribute die verändert werden können sind private § Zugriff via «getter» und «setter» Methoden § Flexibel – kann Darstellung (des Attributes) später ändern § Methoden sind zuerst private und bleiben private – es sei denn ein Klient ruft sie auf § Dann sind sie public (bis wir weitere Optionen kennen lernen) § Klassen sind public wenn es Klienten gibt 114 Regeln für Namen 115 § Nur Buchstaben und Ziffern § Keine _, $, etc. § Keine Umlaute § Klassennamen: MitGrossBuchstaben § Methodennamen § Wenn möglich mit Verb § erster Buchstabe klein insert, remove, drawLine § Namen für Variable: beschreibend § Kurze Namen für Loopcounter for (int i; …) 116 Variablennamen § Kurze Variablennamen reserviert für Loopcounter § D.h. i, j, k usw sollten immer Loopcounter sein § Idealerweise im for Statement deklariert § for (int i = 0; …; i++) { … } § for (double d : measuredTemp) { … } § Standard Konvention § MyClass für Typen: Klassen und Interfaces § MyClass() ist dann der Konstruktor der Klasse § myVariable für Attribute, Parameter und Variable (static und local) § myMethod() für Methoden § MY_CONSTANT für Konstanten (sind final) 117 Variablennamen § Keine Typ/Metainformation im Namen // Good int i; int responses; // Not good int[] scoreArray; double doubleNote; § Masseinheit soll (wenn relevant) Teil des Names sein // Good int refreshIntervalMs; 118 Variable § Deklaration in dem Block in dem Variable gebraucht wird // Not good int i; .... for (i = 0; i < weight.length; i++) { .... } // Good for (int i = 0; i < weight.length; i++) { .... } 120 (Methoden) Variablen § Eine Variable pro Deklaration. Initalisierung nicht vergessen. // Not good int k, m; … k = ...; // Good int k = 100; int m = 0; // Also i.O. int k; k = ...; 121 § Für Parameter gelten die selben Regeln wie für (Methoden- lokale) Variablen 122 Arrays § Obwohl die Java Syntax flexibel ist, verbinden wir die [] mit dem Typ der Arrayelemente // Good String[] args; // Not good String args[]; // Java akzeptiert das … String▢[] args; // Java akzeptiert das … § Der Typ ist «StringArray» – daher die Position für [] 123 Code 124 Faktorisierung § Sie erinnern sich an die Zerlegung einer Zahl in Primzahlen § Klasse Factors – Modul für andere Klassen (Programme) § Oder die Zerlegung von Polynomen (in der Mathematik) § «Faktorisierung» -- Zerlegung in Terme/Teile § Idee: keine Überlappung § Faktorisierung («factoring») von Code : Herausarbeiten von gemeinsamen/redundanten Anweisungen § In der Praxis of Refaktorisierung («refactoring») Faktorisierung für if/else Anweisungen § Example: if (a == 1) { System.out.println(a); x = 3; b = b + x; } else if (a == 2) { System.out.println(a); x = 6; y = y + 10; b = b + x; } else { // a == 3 System.out.println(a); x = 9; b = b + x; } System.out.println(a); b = b + x; Faktorisierung für if/else Anweisungen § Example: if (a == 1) { System.out.println(a); x = 3; b = b + x; } else if (a == 2) { System.out.println(a); x = 6; y = y + 10; b = b + x; } else { // a == 3 System.out.println(a); x = 9; b = b + x; } System.out.println(a); x = 3 * a; b = b + x; Faktorisierung für if/else Anweisungen § Example: if (a == 1) { System.out.println(a); x = 3; b = b + x; } else if (a == 2) { System.out.println(a); x = 6; y = y + 10; b = b + x; } else { // a == 3 System.out.println(a); x = 9; b = b + x; } System.out.println(a); x = 3 * a; if (a == 2) { y = y + 10; } b = b + x; Boolesche Ausdrücke if (((x>0) && (y>0)) && (z > 0)) { // block 1 } else if (((x>0) && (y>0)) && (z < 0)) { // block 2 } else if (((x>0) && (y>0)) && (z == 0)) { // block 3 } § Was ist an diesem Code Beispiel schlecht? 131 Boolesche Ausdrücke if (((x>0) && (y>0)) && (z > 0)) { // block 1 } else if (((x>0) && (y>0)) && (z < 0)) { // block 2 } else if (((x>0) && (y>0)) && (z == 0)) { // block 3 } § Was ist an diesem Code Beispiel schlecht? § (x>0) && (y>0) mehrfach berechnet und unübersichtlich 132 Beispiel -- Faktorisierung if (((x>0) && (y>0))) { if (z > 0) { // block 1 } else if (z < 0) { // block 2 } else if (z == 0) { // block 3 } } 133 Methoden § Kurze Methoden sind schneller zu lesen § Keine Code Duplikation! § Methoden erlauben Wiederverwendung § In der Regel nicht mehr als 20-40 Anweisungen pro Methode § Es gibt manchmal gute Gründe für Ausnahmen § (z.B. switch Statement, geschachtelte if-Statements) § Wenn es mehr Anweisungen gibt: separate Methode! 136 Methoden § Kurze Parameterlisten § If you have a procedure with ten parameters, you probably missed some. (Alan Perlis Epigrams in Programming) § Eine Methode sollte ein Problem/eine Aufgabe lösen 137 § Kurze Methoden sind schneller zu verstehen Methoden § Kurze Parameterlisten § If you have a procedure with ten parameters, you probably missed some. (Alan Perlis Epigrams in Programming) § Eine Methode sollte ein Problem/eine Aufgabe lösen 138 § Kurze Methoden mit kurzen Parameterlisten sind schneller zu verstehen Entwurf von/Auoeilung in Methoden 140 Attribute eines Exemplars Methode Methoden helfen nicht unbedingt 141 Attribute eines Exemplars Methoden Methoden helfen vielleicht 142 Attribute eines Exemplars Methoden Statt 143 Struktur mit Mehrfachverwendung 144 Manchmal ruo sich eine Methode auf … 146 Rekursive Methoden § Eine Methode f() ist rekursiv, wenn ein Aufruf von f() wieder zu einem Aufruf von f() führen kann § f() ist direkt rekursiv wenn der Aufruf von f() im Rumpf von f() auftritt § Eine Methode g() ist indirekt rekursiv, wenn der Aufruf von g() zum Aufruf von h() (und dieser zum Aufruf von …) führt, in dem dann g() wieder aufgerufen wird § g() à h() à m() à …. à g() 147 Rekursive Methoden § … sind manchmal der beste Weg ein Problem zu lösen § … sind Iteration (Schleifen) oft überlegen § ... sind oft kürzer als Schleifen § … haben eine einfachere Kontrollstruktur (weniger if-Fälle, z.B.) § … kommen mit weniger Variablen aus § … haben oft einen einfachen Korrektheitsbeweis § Später mehr dazu § … und sind in manchen Programmiersprachen der einzige Weg, Wiederholungen auszudrücken 148 Rekursive Methoden § Wir erinnern uns: EBNF erlaubte Rekursion und Iteration § Genauso viele Programmiersprachen § z.B. Java 149 Iteration vs. Rekursion § Grundidee: Ein Problem verkleinern – bis es einfach zu lösen ist (oder keine weitere Zerlegung möglich ist) § Beispiel: § Annahme: Wir leben in einer altruistischen Gesellschaft. Wenn jemand uns fragt, so spenden wir 1 Rappen § Aufgabe: Wir wollen sFr 1'000.00 für einen guten Zweck sammeln 150 Quelle: https://upload.wikimedia.org/wikipedia/de/0/00/Einrappen.png (GNU Free Documentation License, version 1.2) Iteration vs. Rekursion § Iteranve Lösung: § Wir fragen 100'000 Personen und sammeln vom jeder 1 Rappen ein § Rekursive Lösung: § Wenn uns eine Person um 1 Rappen fragt, so geben wir der Person 1 Rappen, sonst (d.h. es will jemand mehr als 1 Rappen) § Kontakkere 10 Personen und beaulrage jede, 1/10 des Betrages zu sammeln, der von uns verlangt wird § Lege das von diesen Personen gesammelte Geld in eine Schachtel § Gebe die Schachtel der Person, die uns gefragt hat 151 § Iteration: Das Problem ist in 100'000 Teil-Probleme zerlegt § Jedes Teil-Problem ist gleich gross § Rekursion: Die Teil-Probleme werden kleiner und kleiner § … bis nur noch 1 Rappen gesammelt werden muss § (ein kleineres Problem gibt es nicht, 1 Rappen ist die kleinste Münze) 152 solve(): Eine rekursive Methode (Muster) Wenn das Problem nicht weiter zerlegt werden kann (minimal ist, Basisfall): löse Problem direkt (ohne Rekursion) und liefere die Lösung sonst 1. Zerlege Problem in ein oder mehr ähnliche, aber kleinere Teil-Probleme TP1, TP2, …, TPn 2. Rufe rekursiv solve() auf, um die kleineren Teil-Probleme zu lösen (denn diese sind ähnlich): solve(TP1), solve(TP2), … , solve(TPn) 3. Füge die Lösungen der Teil-Probleme (von solve(TPi) geliefert) zusammen um das ursprüngliche Problem zu lösen 4. Liefere die Lösung zum ursprünglichen Problem (an den Aufrufer) 153 Übung § Wir sagen eine ganze posinve Zahl N hat die Eigenschao AZT (alle Ziﬀern sind Teiler) wenn jede Ziﬀer von N die Zahl N ohne Rest teilt. § Beispiel § 124, 128 haben die AZT Eigenschal § 127, 104 haben sie nicht § Beobachtung: eine Zahl mit Ziﬀer 0 hat nie die AZT Eigenschao 154 Übung § Schreiben Sie ein Programm (eine Methode) die für eine positive ganze Zahl N true zurückgibt, wenn N die AZT Eigenschaft hat. § Zur Erinnerung: ob eine Zahl ohne Rest teilt können wir mit dem modulo-Operator % feststellen § Die k-te Ziffer erhalten wir durch / 10k (von rechts nach links) 155 Lösung public class AZT { public static void main(String[] args) { System.out.println(\"124 : \" + azt(124)); } public static boolean azt(int x) { } } 156157 1 2 4 124 % 1 == 0 ? 124 % 2 == 0 ? 124 % 4 == 0 ? ✓ ✓ ✓ AZT✓ 158 1 2 4 124 % 4 == 0 ? 124 % 2 == 0 ? 124 % 1 == 0 ? ✓ ✓ ✓ AZT✓ 159 4 3 1 431 % 1 == 0 ? 431 % 3 == 0 ? 431 % 4 == 0 ? ✓ ✘ AZT✘ Lösung § % 10 liefert letzte Ziffer Z § Müssen Eingabe Zahl N bereithalten § Um zu prüfen ob Z die Zahl N ohne Rest teilt 160 Lösung § % 10 liefert letzte Ziffer Z § Müssen Eingabe Zahl N bereithalten § Um zu prüfen ob Z die Zahl N ohne Rest teilt § Idee: eine Helfer-Methode mit zwei Parametern: die Zahl N und das Residuum (Ziffern die noch nicht untersucht wurden) § N wird «weitergereicht» , Residuum wird immer kleiner § Helfer-Methode prüft, ob N durch Z ohne Rest teilbar ist § Wenn ja: Aufruf von Helfer-Methode mit Residuum \\ { Z } 161 Lösung -- Residuum § Residuum: Ziffern die noch nicht untersucht wurden § Könnten eine Menge nehmen (alle Ziffern von N) § Könnten einen Array nehmen (alle Ziffern von N) § Einfach: Division durch 10 «entfernt» letzte Ziffer § Residuum: Zahl § Müssen Helfer-Methode am Anfang mit Residuum N aufrufen 163 Lösung public class AZT { public static void main(String[] args) { System.out.println(\"124 : \" + azt(124)); } public static boolean azt(int x) { return azt_helper(x, x); } } 164 azt_helper(int origin, int residuum) § Wann sind wir fertig? § Wenn alle Ziffern untersucht wurden und Teiler sind § Dann hat die Zahl die AZT Eigenschaft § Wenn alle Ziffern untersucht wurden: es gibt keine weiteren Ziffern § D.h. residuum ist 0 § (Es wurde immer die letzte Ziffer untersucht) 165 azt_helper: Eine rekursive Methode Wenn das Problem nicht weiter zerlegt werden kann (minimal ist, Basisfall): löse Problem direkt (ohne Rekursion) und liefere die Lösung public static boolean azt_helper(int origin, int residuum) { if (residuum == 0) { return true; } 166 azt_helper: Eine rekursive Methode sonst 1. Zerlege Problem in ein oder mehr ähnliche, aber kleinere Teil-Probleme TP1, TP2, …, TPn 2. TP1 : Letzte Ziffer von residuum: Nicht 0 und teilt die Zahl N ohne Rest? 3. TP2 : Übrige Ziffern von residuum 2. Rufe rekursiv azt-helper(...) auf, um das kleinere Teil-Problem TP2 zu lösen (denn dieses ist ähnlich) 3. Füge die Lösungen der Teil-Probleme zusammen um das ursprüngliche Problem zu lösen 4. Liefere die Lösung zum ursprünglichen Problem (an den Aufrufer) 167 azt_helper(int origin, int residuum) Ist origin durch letzte Ziffer von residuum teilbar? § Wenn die letzte Ziffer eine 0 ist, dann macht diese Frage keinen Sinn (und die Zahl hat nicht die AZT Eigenschaft) § Dies müssen wir prüfen bevor obige Bedingung geprüft werden kann 168 Lösung public static boolean azt_helper(int origin, int residuum) { if (residuum == 0) { return true; } else { // Letzte Ziffer von residuum: ≠ 0 und teilt die Zahl N ohne Rest? boolean resultTP1; resultTP1 = (residuum%10!=0) && (origin%(residuum%10)==0); // Rufe rekursiv azt-helper(...) fuer TP2 auf boolean resultTP2 = azt_helper(origin, residuum/10); return resultTP1 && resultTP2; } } 169 azt_helper: Eine rekursive Methode sonst 1. Zerlege Problem in ein oder mehr ähnliche, aber kleinere Teil-Probleme TP1, TP2, …, TPn 2. TP1 : Letzte Ziffer von residuum: Nicht 0 und teilt die Zahl N ohne Rest? 3. TP2 : Übrige Ziffern von residuum. 2. Rufe rekursiv azt-helper(...) auf, um das kleinere Teil-Problem TP2 zu lösen (denn dieses ist ähnlich) 3. Füge die Lösungen der Teil-Probleme zusammen um das ursprüngliche Problem zu lösen 4. Liefere die Lösung zum ursprünglichen Problem (an den Aufrufer) 170 Lösung public static boolean azt_helper(int origin, int residuum) { if (residuum == 0) { return true; } else { // Letzte Ziffer von residuum: ≠ 0 und teilt die Zahl N ohne Rest? boolean resultTP1; resultTP1 = (residuum%10!=0) && (origin%(residuum%10)==0); // Rufe rekursiv azt-helper(...) fuer TP2 auf boolean resultTP2 = azt_helper(origin, residuum/10); return resultTP1 && resultTP2; } } 171 azt_helper: Eine rekursive Methode sonst 1. Zerlege Problem in ein oder mehr ähnliche, aber kleinere Teil-Probleme TP1, TP2, …, TPn 2. TP1 : Letzte Ziffer von residuum: Nicht 0 und teilt die Zahl N ohne Rest? 3. TP2 : Übrige Ziffern von residuum. 2. Rufe rekursiv azt-helper(...) auf, um das kleinere Teil-Problem TP2 zu lösen (denn dieses ist ähnlich) 3. Füge die Lösungen der Teil-Probleme zusammen um das ursprüngliche Problem zu lösen 4. Liefere die Lösung zum ursprünglichen Problem (an den Aufrufer) 172 Lösung public static boolean azt_helper(int origin, int residuum) { if (residuum == 0) { return true; } else { // Letzte Ziffer von residuum: ≠ 0 und teilt die Zahl N ohne Rest? boolean resultTP1; resultTP1 = (residuum%10!=0) && (origin%(residuum%10)==0); // Rufe rekursiv azt-helper(...) fuer TP2 auf boolean resultTP2 = azt_helper(origin, residuum/10); return resultTP1 && resultTP2; } } 173 Vereinfacht … mit «short-circuit» Auswertung 174 public static boolean azt_helper(int origin, int residuum) { if (residuum == 0) { return true; } else { return // Letzte Ziffer von residuum: ≠ 0 und teilt die Zahl N ohne Rest? ( (residuum%10!=0) && (origin%(residuum%10)==0) && // Rufe rekursiv azt-helper(...) fuer TP2 auf azt_helper(origin, residuum/10) ); } } 6.2 Datenstrukturen mit Verküpfungen 175 Datenstrukturen mit Verküpfungen § Bisher hatten wir Arrays als Datenstruktur kennen gelernt § Ein Array besteht aus Elementen eines Typs int[] ia = {42, -3, 17, 9}; § Grösse muss im Voraus bekannt sein § Entweder für new int[length] oder für Initialisierung § Oft wollen wir mit einer unbestimmten Anzahl von Elementen arbeiten. 176 Index 0 1 2 3 Wert 42 -3 17 9 Datenstrukturen mit Verküpfungen § Wir wollen mit einer unbestimmten § Anzahl von Elementen arbeiten § Können nicht berechnen wieviele § Elemente wir brauchen werden § Diese können wir als verknüpfte Objekte («linked objects») organisieren. Jedes Objekt (Knoten) speichert ein Element und einen Verweis auf einen anderen Knoten. list 42 -3 17 9 178? Index 0 1 2 3 Wert 42 -3 17 9 Datenstrukturen mit Verküpfungen § Wir wollen mit einer unbestimmten § Anzahl von Elementen arbeiten § Können nicht berechnen wieviele § Elemente wir brauchen werden § Diese können wir als verknüpfte Objekte («linked objects») organisieren. Jedes Objekt (Knoten) speichert ein Element und einen Verweis auf einen anderen Knoten. list 42 -3 17 9 179 Index 0 1 2 3 Wert 42 -3 17 9 null Datenstrukturen mit Verküpfungen § Wir wollen mit einer unbestimmten § Anzahl von Elementen arbeiten § Können nicht berechnen wieviele § Elemente wir brauchen werden § Diese können wir als verknüpfte Objekte («linked objects») organisieren. Jedes Objekt (Knoten) speichert ein Element und einen Verweis auf einen anderen Knoten. list 42 -3 17 9 180 Index 0 1 2 3 Wert 42 -3 17 9 Eine Klasse für Knoten einer Liste public class ListNode { int data; ??? next; } § Jeder Knoten der Liste speichert: § Den Wert einer ganzen (int) Zahl § Einen Verweis auf einen anderen Listenknoten § ListNodes können zu einer Kette verbunden («linked») wer- den um eine Menge oder Liste von Werten zu speichern. data next 42 data next -3 data next 17 data next 9 181 Eine Klasse für Knoten einer Liste public class ListNode { int data; ListNode next; } § Jeder Knoten der Liste speichert: § Den Wert einer ganzen (int) Zahl § Einen Verweis auf einen anderen Listenknoten § ListNodes können zu einer Kette verbunden («linked») wer- den um eine Menge oder Liste von Werten zu speichern. data next 42 data next -3 data next 17 data next 9 182 ListNode Klient - Beispiel public class ConstructList1 { public static void main(String[] args) { ListNode list = new ListNode(); list.data = 42; list.next = new ListNode(); list.next.data = -3; list.next.next = new ListNode(); list.next.next.data = 17; list.next.next.next = null; System.out.println(list.data + \" \" + list.next.data + \" \" + list.next.next.data); // 42 -3 17 } } data next 42 data next -3 data next 17list 183184 Konstruktor für Knoten einer Liste public class ListNode { int data; ListNode next; public ListNode(int data) { this.data = data; this.next = null; } public ListNode(int data, ListNode next) { this.data = data; this.next = next; } } 185 Übung § Modifizieren Sie das letzte Klientenprogramm so dass es diese Konstruktoren verwendet. 186 ListNode Klient – mit Konstruktor public class ConstructList1 { public static void main(String[] args) { ListNode list = new ListNode(42, new ListNode(-3, new ListNode(17))); System.out.println(list.data + \" \" + list.next.data + \" \" + list.next.next.data); // 42 -3 17 } } data next 42 data next -3 data next 17list 187 ListNode Klient – mit Konstruktor public class ConstructList1 { public static void main(String[] args) { ListNode list = new ListNode(42, new ListNode(-3, new ListNode(17))); System.out.println(list.data + \" \" + list.next.data + \" \" + list.next.next.data); // 42 -3 17 } } data next 42 data next -3 data next 17list 188 ListNode Klient – mit Konstruktor public class ConstructList1 { public static void main(String[] args) { ListNode list = new ListNode(42, new ListNode(-3, new ListNode(17))); System.out.println(list.data + \" \" + list.next.data + \" \" + list.next.next.data); // 42 -3 17 } } data next 42 data next -3 data next 17list 189190 Verknüpfte Knoten -- Übungsproblem 1 Welche Folge von Anweisungen verändert dieses Bild: in dieses? data next 10 data next 20 list data next 10 data next 20 list data next 30 191 Verknüpfte Knoten -- Übungsproblem 1 Welche Folge von Anweisungen verändert dieses Bild: in dieses? list.next.next = new ListNode(30); data next 10 data next 20 list data next 10 data next 20 list data next 30 193194 Verknüpfte Knoten -- Übungsproblem 2 Welche Folge von Anweisungen verändert dieses Bild: in dieses? data next 10 data next 20 list data next 30 data next 10 list data next 20 195 Verknüpfte Knoten -- Übungsproblem 2 Welche Folge von Anweisungen verändert dieses Bild: in dieses? data next 10 data next 20 list data next 30 data next 10 list data next 20 197 list = new ListNode(30, list); Verknüpfte Knoten -- Übungsproblem 3 Welche Folge von Anweisungen verändert dieses Bild: in dieses? data next 10 data next 20 list1 data next 30 data next 40 list2 data next 10 data next 30 list1 data next 40 list2 data next 20 198 Verknüpfte Knoten -- Übungsproblem 3 Welche Folge von Anweisungen verändert dieses Bild: data next 10 data next 20list1 data next 30 data next 40list2 rest 199 rest = list2.next; list2.next = list1.next; list1.next = list2; list2 = rest; ListNode rest, list1, list2; rest = list2.next; list2.next = list1.next; list1.next = list2; list2 = rest; 201 Zuweisungen mit Referenzvariablen Variable = Wert; § Die Variable (links von = ) ist Referenzvariable § Entweder Attribut (z.B., next) eines durch eine andere Referenzvariable (z.B., a) bestimmten Objekts oder Variable/Parameter einer Methode § Referenzvariable (z.B. ListNode next) speichern Verweis auf Objekt (z.B. a.next verweist auf nächstes Element einer Liste) § Der Wert (rechts von = ) ist ein Verweis auf ein Exemplar (ein Rechteck, ein Window, ein Element einer Liste, usw.) § Typ des Exemplars muss mit Referenzvariable übereinstimmen § Java erlaubt keine arithmetischen Ausdrücke mit Referenzvariablen, daher muss Wert auch eine Referenzvariable sein oder einen Verweis erstellen (mittels new o.ä.) 202 Referenzen vs. Objekte Variable = Wert; Für die Liste rechts: § a.next = Wert; heisst anpassen worauf zeigt § Variable = a.next; heisst die Variable setzen so dass sie auf zeigt data next 10a data next 201 2 1 2 203 Referenzen verändern § Wenn das Programm sagt: a.next = b.next; § dann heisst das: § «Lasse die Variable a.next auf den selben Wert (Objekt) zeigen wie b.next» § Oder: «Lasse a.next auf den selben Ort wie b.next verweisen.» data next 10 a data next 20 data next 30 b data next 40 204205 § Nehmen wir an wir haben eine lange Kette von Knoten: § Wir wissen nicht wie lang die Kette ist. § Wie könnten wir die Werte in allen Knoten ausgeben? data next 10 data next 990 list ... data next 20 206 Verknüpfte Knoten -- Übungsproblem 4Algorithmus Pseudocode § Fangen wir am Anfang der Liste an § list verweist auf 1. Knoten § while (es gibt noch Knoten auszugeben): § Gebe den data Wert des Knotens aus § Gehe weiter zum nächsten Knoten via das next Attribut. § Wie wissen wir ob noch Knoten auszugeben sind? § Wir haben einen Verweis auf einen Knoten § Nach der Ausgabe des letzten Knotens ist sein next Attribute null. data next 10 data next 990 list ... data next 20 208 Algorithmus Pseudocode § Fangen wir am Anfang der Liste an § list verweist auf 1. Knoten § while (es gibt noch Knoten auszugeben): § Gebe den data Wert des Knotens aus § Gehe weiter zum nächsten Knoten via das next Attribut. § Wie können wir uns durch die Liste arbeiten ? § list = list.next; // is this a good idea? data next 10 data next 990 list ... data next 20 209 Abarbeiten einer Liste? § Ein (schlechter) Weg jeden Wert in der Liste auszugeben : while (list != null) { System.out.println(list.data); list = list.next; // move to next node } § Was ist das Problem? 210 Abarbeiten einer Liste? § Ein (schlechter) Weg jeden Wert in der Liste auszugeben : while (list != null) { System.out.println(list.data); list = list.next; // move to next node } § Was ist das Problem? § Wir verlieren die Liste während wir sie ausgeben data next 10 data next 990 list ... data next 20 211 Eine weitere Referenz: current § Wir wollen list nicht verändern. Wir deklarieren eine andere Variable und ändern diese. § Eine ListNode (Referenz)Variable ist nicht ein ListNode Objekt § … sondern eine Referenz (Verweis) auf ein Objekt ListNode current = list; data next 10 data next 990 list ... data next 20 current 212 Eine weitere Referenz: current ListNode current = list; § Was passiert wenn wir jetzt diese Anweisung ausführen: current = current.next; data next 10 data next 990 list ... data next 20 current 213 Eine weitere Referenz: current ListNode current = list; § Was passiert wenn wir jetzt diese Anweisung ausführen: current = current.next; data next 10 data next 990 list ... data next 20 current 214 Korrektes Durchlaufen einer Liste § Der korrekte Weg jeden Wert der Liste auszugeben: ListNode current = list; while (current != null) { System.out.println(current.data); current = current.next; // move to next node } § Das Verändern von current hat keinen Einfluss auf die Liste. data next 10 data next 990 list ... data next 20 215 Verknüpfte Knoten -- Übungsproblem 5 Welche Folge von Anweisungen verändert dieses Bild: in dieses? data next 10 data next 990 list ... data next 10 data next 990 list ... data next 1000 216 252-0027 Einführung in die Programmierung 6.0 Arbeiten mit Objekten und Klassen Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2020,2021 All rights reserved. 1 Übersicht 6.1 Stil und Konventionen § Hinweise (und Regeln) für verständliche Programme § Teil 1: Nicht vollständig – später erweitert 6.2 Datenstrukturen mit Verknüpfungen 6.3 Entwurf von (abgekapselten) Klassen 6.4 Programmbeispiel und –ausführung 6.5 (Mehr) Optionen für Sichtbarkeit Copyright (c) Pearson 2013 and Thomas Gross 2016,2017,2019. All rights reserved. 2 Korrektes Durchlaufen einer Liste § Der korrekte Weg jeden Wert der Liste auszugeben: ListNode current = list; while (current != null) { System.out.println(current.data); current = current.next; // move to next node } § Das Verändern von current hat keinen Einfluss auf die Liste. data next 10 data next 990 list ... data next 20 3 6.3 Entwurf von (abgekapselten) Klassen 4 Eine Klasse LinkedIntList § ListNodes sollen nicht von Klienten direkt verändert werden. § Also entwickeln wir eine Klasse die die Knoten versteckt: LinkedIntList. front LinkedIntList ListNode ListNode ListNode data next 42 data next -3 data next 17 5 Eine Klasse LinkedIntList § Klienten arbeiten mit LinkedIntList, nicht mit ListNode Objekten. § Wir können die Elemente numerieren (von 0 an) front LinkedIntList ListNode ListNode ListNode data next 42 data next -3 data next 17 element 0 element 1 element 2 6 § Hat die Methoden § add(value) - füge neues Element am Ende hinzu § remove() - entferne erstes Element § Die Liste ist als Kette von Knoten intern implementiert § Das LinkedIntList Objekt enthält eine Referenz auf das erste Element in front front LinkedIntList ListNode ListNode ListNode data next 42 data next -3 data next 17 element 0 element 1 element 2 7 § Hat weitere Methoden § add(value,index) - füge Element in Position k hinzu § remove(index) - entferne k-tes Element § Das LinkedIntList Objekt enthält eine Referenz auf das erste Element in front § null im next Attribut signalisiert Ende der Liste § Hat front den Wert null so ist die Liste leer front add(value) add(index, value) indexOf(value) remove(index) size() toString() LinkedIntList ListNode ListNode ListNode data next 42 data next -3 data next 17 element 0 element 1 element 2 8 Namen von Methoden § In einer Klasse können verschiedene Methoden den selben Namen haben public void add (int value) { … } public void add (int value, int index) { … } § Die Typen der Parameter müssen unterschiedlich sein public void add (int value) { … } public void add (int index) { … } // not OK § Ein Name (z.B, add) für mehrere Implementationen § «Overloading» -- in Java erlaubt wenn Parameterlisten unterschiedlich 9 LinkedIntList Klasse v1 public class LinkedIntList { private ListNode front; public LinkedIntList() { front = null; } // methods } front = LinkedIntList 10 Die add Methode // Adds the given value to the end of the list. public void add(int value) { ... } § Wie wollen wir einen neuen Knoten am Ende hinzufügen? § Sind die Werte in der Liste vor diesem Schritt wichtig? front = data next 42 data next -3 data next 17 element 0 element 1 element 2 11 Ein Element in eine leere Liste hinzufügen § Bevor 20 hinzugefügt wird: Danach: front = front = data next 20 element 0 12 Ein Element in eine leere Liste hinzufügen § Bevor 20 hinzugefügt wird: Danach: § Wir müssen einen Knoten erstellen und an die Liste anhängen. front = front = data next 20 element 0 13 Die add Methode, 1. Versuch // Adds the given value to the end of the list. public void add(int value) { if (front == null) { // adding to an empty list front = new ListNode(value); } else { // adding to the end of an existing list ... } } 14 § Bevor 20 am Ende hinzugefügt wird : § Danach: front = data next 42 data next -3 front = data next 42 data next 20 element 0 element 2 element 0 element 1 An eine nicht-leere Liste anhängen data next -3 element 1 15 data next -3 Vorsicht an der Kante! § Um ein Element zur Liste hinzuzufügen müssen wir das next Attribut des vorherigen Knotens modifizieren. front = data next 42 element 0 element 1 16 Vorsicht an der Kante! § Um ein Element zur Liste hinzuzufügen müssen wir das next Attribut des vorherigen Knotens modifizieren. § Wie durchlaufen wir eine Liste? front = data next 42 element 0 element 1 17 current = list; while (current != null) { current = current.next; // move to next node } data next -3 Vorsicht an der Kante! § Um ein Element zur Liste hinzuzufügen müssen wir das next Attribut des vorherigen Knotens modifizieren. § Wie durchlaufen wir eine Liste? § Was für einen Typ muss current haben? front = data next 42 element 0 element 1 18 data next -3 Vorsicht an der Kante! § Um ein Element zur Liste hinzuzufügen müssen wir das next Attribut des vorherigen Knotens modifizieren. § Wie durchlaufen wir eine Liste? § Was für einen Typ muss current haben? ListNode front = data next 42 element 0 element 1 19 data next -3 Vorsicht an der Kante! § Um ein Element zur Liste hinzuzufügen müssen wir das next Attribut des vorherigen Knotens modifizieren. § Worauf sollte current verweisen wenn wir 20 am Ende einfügen wollen? § Welcher Loop Test lässt uns an dieser Stelle anhalten? front = data next 42 element 0 element 1 20 data next -3 Die add Methode // Adds the given value to the end of the list. public void add(int value) { if (front == null) { // adding to an empty list front = new ListNode(value); } else { // adding to the end of an existing list ListNode current = front; while (current.next != null) { current = current.next; } current.next = new ListNode(value); } } 21 Verknüpfte Knoten -- Übungsproblem 5 Welche Folge von Anweisungen verändert dieses Bild: in dieses? data next 10 data next 990 list ... data next 10 data next 990 list ... data next 1000 22 Implementation von get // Returns value in list at given index. // 0 <= index < size() -- legal index for list public int get(int index) { ... } § Implementieren Sie die get Methode. front = data next 42 data next -3 data next 17 element 0 element 1 element 2 23 Die get Methode // Returns value in list at given index. // 0 <= index < size() public int get(int index) { ListNode current = front; for (int i = 0; i < index; i++) { current = current.next; } return current.data; } 24 Implementation von add (index) // Inserts the given value at the given index. public void add(int value, int index) { ... } § Implementieren Sie diese Variante der add Methode. front = data next 42 data next -3 data next 17 element 0 element 1 element 2 25 Implementation von add (index) // Inserts the given value at the given index. public void add(int value, int index) { ... } § Implementieren Sie diese Variante der add Methode. front = data next 42 data next -3 data next 17 element 0 element 1 element 2 26 PollDie 2. Variante der add Methode // Inserts the given value at the given index. // 0 <= index <= size() public void add(int value, int index) { if (index == 0) { // like adding to an empty list front = new ListNode(value, front); } else { // inserting into an existing list ListNode current = front; for (int i = 0; i < index - 1; i++) { current = current.next; } current.next = new ListNode(value, current.next); } } 27 Poll Implementation von add (index) § add(3, 20) front = data next 42 data next -3 data next 17 element 0 element 1 element 2 28 Poll data next 32 element 3 front = data next 42 data next -3 data next 17 element 0 element 1 element 2 data next 20 element 3 data next 32 element 4 Implementation von add (index) § add(4, 99) front = data next 42 data next -3 data next 17 element 0 element 1 element 2 29 Poll data next 32 element 3 front = data next 42 data next -3 data next 17 element 0 element 1 element 2 data next 32 element 3 data next 99 element 4 // Inserts the given value at the given index. // 0 <= index <= size() public void add(int value, int index) { if (index == 0) { // like adding to an empty list front = new ListNode(value, front); } else { // inserting into an existing list ListNode current = front; for (int i = 0; i < index - 1; i++) { current = current.next; } current.next = new ListNode(value, current.next); } } 30 Poll current b: indexa: index-1 c:index+1 current value: indexa: index-1 b:index+1 c:index+2 Element entfernen: remove // Removes the list's first value. public void remove() { ... } § Wie entfernt man den ersten Knoten einer Liste? § Ist der Inhalt der Liste wichtig wenn wir den ersten Knoten entfernen wollen? 34 Entfernen des ersten Elements § Vor dem Entfernen des ersten Elements: § Nachdem ein Element entfernt wurde: Nachdem 2 Elemente … : front = data next 20 front = data next 42 data next 20 element 0 element 1 element 0 front = 35 remove Methode // Removes the first value. // List must not be empty. public void remove() { if (front != null) { front = front.next; } } § Verhalten nicht definiert wenn Liste leer § Wer ist verantwortlich? § Wollen wir wirklich keinen Rückgabewert? 36 remove Methode // Removes the first value. // List must not be empty. public int remove() { if (front != null) { int result = front.data; front = front.next; return result; } } 37 remove Methode // Removes the first value. // List must not be empty. public int remove() { if (front != null) { int result = front.data; front = front.next; return result; } } § Im Ansatz richtig – aber von Java nicht akzeptiert § Kein Rückgabewert (fehlendes return Statement) in else-Block 38 remove Methode // Removes and returns the first value. // List must not be empty. public int remove() { if (front != null) { int result = front.data; front = front.next; return result; } else { System.exit(-1); return 0; //never executed } } 39 remove Methode // Removes and returns the first value. // List must not be empty. public int remove() { if (front != null) { int result = front.data; front = front.next; return result; } else { System.exit(-1); return 0; //never executed, keeps Java happy } } 40 Eine weitere remove Methode // Removes value at given index from list. // Precondition: 0 <= index < size public void remove(int index) { ... } § Wie können wir ein beliebiges Element der Liste entfernen? § Ist der Inhalt der Liste wichtig wenn wir einen Knoten entfernen wollen? 43 Entfernen eines Elementes § Vor dem Entfernen des Elements mit Index 1: § Danach: front = data next 20 front = data next 42 data next -3 data next 20 element 0 element 1 element 2 element 0 element 1 data next 42 44 Vorsicht an der Kante! § Um ein Element aus der Liste zu entfernen müssen wir das next Attribut des vorherigen Knotens modifizieren. 45 front = data next 42 data next -3 data next 20 element 0 element 1 element 2 Entfernen des Elements mit Index 0 § Vor Entfernen des Elements mit Index 0: § Danach: front = data next -3 data next 20 front = data next 42 data next -3 data next 20 element 0 element 1 element 2 element 0 element 1 46 Entfernen des einzigen Elementes § Davor: Danach: § Wir müssen das front Attribut auf null setzen (so dass es nicht auf einen ListNode verweist) § Ist das ein Sonderfall den wir im Programm behandeln müssen? front front = data next 20 element 0 48 remove Methode (Variante 2) // Removes value at given index from list. // Precondition: 0 <= index < size() public void remove(int index) { if (index == 0) { // special case: removing first element front = front.next; } else { // removing from elsewhere in the list ListNode current = front; for (int i = 0; i < index - 1; i++) { current = current.next; } current.next = current.next.next; } } 49 remove Methode (Variante 2) // Removes value at given index from list. // Precondition: 0 <= index < size() public void remove(int index) { if (index == 0) { // special case: removing first element front = front.next; } else { // removing from elsewhere in the list ListNode current = front; for (int i = 0; i < index - 1; i++) { current = current.next; } current.next = current.next.next; } } 50current c: indexa: index-1 d:index+1 current b: indexa: index-1 c:index+1 d:index+2 LinkedIntList Klasse v2 public class LinkedIntList { private ListNode front; public LinkedIntList() { front = null; } public void add (int value) { … } public void add (int value, int index) { … } public int remove() { … } public void remove(int index) { … } } front = LinkedIntList 56 Übung § Schreiben Sie eine Methode addSorted die den Wert einer ganzen Zahl als Parameter akzeptiert und diesen Wert in die sortierte Liste an der richtigen Position einfügt (d.h., die Liste ist auch danach sortiert). § Vor addSorted(17) : § Nach addSorted(17) : front = data next -4 data next 8 data next 22 element 0 element 1 element 2 front = data next -4 data next 17 data next 22 element 0 element 2 element 3 data next 8 element 1 57 Der «Normalfall»: irgendwo einfügen § Einfügen eines Elementes «im Inneren» der Liste: addSorted(17) § Welche Verweise (Referenzen) müssen geändert werden? § Was für eine Schleife bietet sich an? § Wann sollte die Schleife terminieren? front = data next -4 data next 8 data next 22 element 0 element 1 element 2 58 Erster Versuch § Fehlerhafte Schleife: ListNode current = front; while (current.data < value) { current = current.next; } § Wo ist der Fehler? § Die Schleife endet zu spät um die Liste korrekt zu verändern. front = data next -4 data next 8 data next 22 element 0 element 1 element 2 current 60 Idee: vorausschauen § Korrekte Schleife: ListNode current = front; while (current.next.data < value) { current = current.next; } § Diesmal hört die Schleife an der richtigen Stelle auf. front = data next -4 data next 8 data next 22 element 0 element 1 element 2 current 61 Spezialfall 1: Hinzufügen am Ende § Hinzufügen am Ende der Liste: addSorted(42) Exception in thread \"main\": java.lang.NullPointerException § Warum gibt es eine Exception? § Was können wir ändern um diesen Fall richtig zu behandeln? front = data next -4 data next 8 data next 22 element 0 element 1 element 2 63 Mehrere Tests für die Schleife § Fehler beheben in der Schleife: ListNode current = front; while (current.next != null && current.next.data < value) { current = current.next; } § Müssen prüfen ob next den Wert null hat bevor wir das data Attribut des Knotens (d.h., next.value) prüfen front = data next -4 data next 8 data next 22 element 0 element 1 element 2 current 64 while (current.next.data < value) { while (current.next != null && current.next.data < value) { Version 1 – noch nicht vollständig // Adds given value to list in sorted order. // Precondition: Existing elements are sorted public void addSorted(int value) { // insert in middle or end of list ListNode current = front; while (current.next != null && current.next.data < value) { current = current.next; } current.next = new ListNode(value, current.next); } } 65 Spezialfall 2: Hinzufügen am Anfang § Einfügen am Anfang der Liste: addSorted(-10) § Was passiert jetzt in unserem Programm? § Wie können wir diesen Fehler beheben? front = data next -4 data next 8 data next 22 element 0 element 1 element 2 68 Hinzufügen am Anfang § Eine weitere Verbesserung des Programms if (value <= front.data) { // insert at front of list front = new ListNode(value, front); } else { // insert in middle or end of list ListNode current = front; while (current.next != null && current.next.data < value) { current = current.next; } current.next = new ListNode(value, current.next); } § Kann diese Methode jetzt alle möglichen Fälle behandeln? 70 Spezialfall 3: Leere Liste § Hinzufügen (am Anfang) zu einer leeren Liste: addSorted(42) § Was passiert jetzt in unserem Programm? § Wie können wir diesen Fehler beheben? front = 71Endgültige Version // Adds given value to list in sorted order. // Precondition: Existing elements are sorted public void addSorted(int value) { if (front == null || value <= front.data) { // insert at front of list front = new ListNode(value, front); } else { // insert in middle of list ListNode current = front; while (current.next != null && current.next.data < value) { current = current.next; } current.next = new ListNode(value, current.next); } } 72 LinkedIntList Klasse v2 public class LinkedIntList { private ListNode front; public LinkedIntList() { front = null; } public void add (int value) { … } public int remove() { … } public int size() { … } public int getFront() { … } public void setFront() { … } ... } front = LinkedIntList 73 (Verknüpfte) Liste vs. Array § Algorithmus um die Werte der Liste auszugeben: ListNode front = ...; ListNode current = front; while (current != null) { System.out.println(current.data); current = current.next; } § Algorithmus um die Werte des Arrays auszugeben: int[] a = ...; int i = 0; while (i < a.length) { System.out.println(a[i]); i++; } 74 Diskussion Liste vs. Array § Vorteil Array § Vorteil Liste 75 Diskussion Liste vs. Array § Vorteil Array § Konstante Zugriffszeit § Vorteil Liste § Grösse flexibel 76 Ein paar Fragen 1. Was ist der Unterschied zwischen einer LinkedIntList und einem ListNode? 2. Was ist der Unterschied zwischen einer leeren und einer null Liste? Wie können wir jede von ihnen konstruieren/generieren 77 Ein paar Fragen 3. Die Attribute von ListNode sind nicht private? Ist das guter oder schlechter Stil? 4. Welchen Effekt hat dieses Codesegment auf eine LinkedIntList values? ListNode current = values.getFront(); current = null; 78 Antworten 1. Was ist der Unterschied zwischen einer LinkedIntList und einem ListNode? § Eine LinkedIntList Liste besteht aus 0 oder mehr ListNode Knoten. § Jeder Knoten ist ein ListNode Objekt § Jeder Knoten enthält einen einzigen (int) Wert. 79 Antworten 2. Was ist der Unterschied zwischen einer leeren und einer null Liste? Wie können wir jede von ihnen konstruieren/generieren § Null-Liste: Referenzvariable für Liste hat Wert null § LinkedIntList list = null; leere Liste: Liste enthält keine Elemente § LinkedIntList list = new LinkedIntList(); 80 Antworten 3. Die Attribute von ListNode sind nicht private? Ist das guter oder schlechter Stil? § Das kann man vertreten da LinkedIntList der einzige Klient von ListNode ist § Andere Programme manipulieren nicht die ListNode Objekte sondern arbeiten mit Methoden der LinkedIntList Klasse. § Es gibt in Java noch bessere Möglichkeiten, solche Klassen zu organisieren, aber die lernen wir erst später kennen 81 Antworten 4. Welchen Effekt hat dieses Codesegment auf eine LinkedIntList values? ListNode current = values.getFront(); current = null; § Diese Zuweisungen ändern die Liste nicht. Die Liste kann nur auf folgende Weise verändert werden: § Ändern des front Attributes § Ändern des next Verweises auf einen Knoten in der Liste § (Ändern des data Attributes eines Knotens) 82 Andere Operationen für Listen § Implementieren Sie weitere Methoden für LinkedIntList: § int size() § boolean isEmpty() § void clear() § String toString() § int indexOf(int) § boolean contains(int) § void push(int) § int pop() § int top() § Deklarieren Sie ein elements Attribut so dass die Anzahl Knoten schnell zurückgegeben werden kann. 83 Das elements Attribute § Deklarieren Sie ein elements Attribut so dass die Anzahl Knoten schnell zurückgegeben werden kann. § Idee: wir verändern elements wenn die Liste verändert wird. § Welche Methoden sind betroffen (d.h., müssen elements auf den aktuellen Stand bringen)? 84 LinkedIntList Klasse v3 (Minimal) public class LinkedIntList { private ListNode front; private int elements = 0; public LinkedIntList() { front = null; } public void add (int value) { … } public int remove() { … } public int size() { return elements; } public int getFront() { … } public void setFront … ... } front = LinkedIntList 85 LinkedIntList Klasse v3 (Minimal) public class LinkedIntList { private ListNode front; private int elements = 0; public LinkedIntList() { front = null; } public void add (int value) { … } public int remove() { … } public int size() { … } public int getFront() { … } public void setFront() { … } ... } front = LinkedIntList 86 252-0027 Einführung in die Programmierung 6.0 Arbeiten mit Objekten und Klassen Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2020,2021 All rights reserved. 87 Übersicht 6.1 Stil und Konventionen § Hinweise (und Regeln) für verständliche Programme § Teil 1: Nicht vollständig – später erweitert 6.2 Datenstrukturen mit Verknüpfungen 6.3 Entwurf von (abgekapselten) Klassen 6.4 Programmbeispiel und –ausführung 6.5 (Mehr) Optionen für Sichtbarkeit Copyright (c) Pearson 2013 and Thomas Gross 2016,2017,2019. All rights reserved. 88 Zahlen § Wir haben int, long und double kennengelernt § double ist der bevorzugte Basistyp für «reelle Zahlen» § Aber double ist endlich (genauso wie int und long …) § Kann nur eine Approximation darstellen § Wir erinnern uns: reelle Zahlen umfassen rationale Zahlen und irrationale Zahlen § Rationale Zahlen: lassen sich als Bruch ganzer Zahlen darstellen § Kann double (wenigstens) rationale Zahlen exakt darstellen? Rationale Zahlen § Auch für rationale Zahlen ist double nur eine Approximation double x = (1.0/2.0) + (1.0/3.0) + (1.0/6.0); System.out.println(x); § Aber rationale Zahlen können als Bruch ganzer Zahlen exakt dargestellt werden: wir brauchen einen neuen Typ Output 0.9999999999999999 + = 2 1 3 1 6 1 1+ Brüche (ganzer Zahlen) § Ein Bruch hat einen Nenner und einen Zähler § Es gibt die üblichen arithmetischen Operationen § Sollen wir jetzt eine Klasse Bruch entwickeln? 91 a b + c d = ad + bc bd a b – c d = ad – bc bd a b x c d = ac a b c d = bd ad bc Addition: Subtraction: Multiplication: Division: : Klasse Bruch public class Bruch { private int zaehler; private int nenner; public Bruch add(Bruch a, Bruch b) { … } public Bruch multiply(Bruch a, Bruch b) { … } public Bruch subtract(Bruch a, Bruch b) { … } public Bruch divide(Bruch a, Bruch b) { … } 92 Klasse Bruch public class Bruch { private int zaehler; private int nenner; public static Bruch add(Bruch a, Bruch b) { … } public static Bruch multiply(Bruch a, Bruch b) { … } public static Bruch subtract(Bruch a, Bruch b) { … } public static Bruch divide(Bruch a, Bruch b) { … } 93 Klasse Bruch public class Bruch { private int zaehler; private int nenner; public static Bruch add(Bruch a, Bruch b) { … } public static Bruch multiply(Bruch a, Bruch b) { … } public static Bruch subtract(Bruch a, Bruch b) { … } public static Bruch divide(Bruch a, Bruch b) { … } 94 Brüche § Was sind die Attribute? § Nenner, Zähler § Was sind die Methoden? § Addieren, subtrahieren, multiplizieren, dividieren – aber was noch? § Was soll für Exemplare der Klasse gelten? § Welche Invarianten? § Wir wollen Brüche vergleichen können 95 Brüche § Wir wollen Brüche vergleichen können 96 ? 2 1 3 1 ? 3 2 4 3 ? 3 2 3 1 ? 4 2 2 1 ? 3 -2 2 -3 ? -8 -4 2 4 Brüche § Kanonische Darstellung § Zähler und Nenner so weit wie möglich gekürzt § Nenner immer positiv § Ist der Nenner negativ, so negieren wir den Zähler § Invarianten für die Exemplare § Wer ist dafür verantwortlich? § Konstruktor – aber dann darf niemand die Attribute ändern § Jede Methode die einen Bruch als Ergebnis liefert 97 Verantwortung bei Methoden … § Konstruktor: Bruch(int z, int n) { zaehler = z; nenner = n; } § Add Methode: public Bruch add(Bruch x) { Bruch result; result = new Bruch(0,0); result.zaehler = zaehler * x.nenner + x.zaehler * nenner; result.nenner = nenner * x.nenner; return simplify(result); } 98 public class Bruch { private int zaehler; private int nenner; public class Bruch { private int zaehler; private int nenner; Verantwortung bei Methoden … simplify Methode: private Bruch simplify(Bruch x) { int gcd; gcd = euclid(x.zaehler,x.nenner); x.zaehler /= gcd; x.nenner /= gcd; return x; } /* Euclid's algorithm, see http://www.nist.gov/dads/HTML/euclidalgo.html */ private int euclid(int a, int b) { if (b==0) { return a; } else { return euclid(b, a % b); } } 99 § Wir brauchen die simplify Methode für jede arithmetische Operation § Ist keine Methode für Exemplar § (Könnte static sein) § Welche anderen Fallstricke gibt es? § Brauchen wir eine Methode add(int i)? public Bruch add(int i) { return simplify(new Bruch(zaehler + i * nenner, nenner)); } § Vielleicht doch Konstruktoren (mehrere!) verantwortlich 100 Verantwortung bei Methoden …Klasse für Rationale Zahlen: Rational § Neuer Name -- Bruch ist nur eine Darstellung einer rationalen Zahl § Attribute (sollten private sein) § num (numerator) -- Zähler, int § den (denominator) – Nenner, int § Konstruktoren § Rational() – § Rational(int x) – § Rational(int n, int d) – 101 0 1 x 1 n d Klasse für Rationale Zahlen: Rational § Methoden § Für die arithmetischen Operationen: § add § multiply § subtract § divide § toString() für Ausgabe § Hilfsfunktion § gcd um den grössten gemeinsamen Teiler zu finden 102 Implementation von Rational § Konstruktoren stellen sicher dass Zähler und Nenner auf die kleinstmöglichen Werte «gekürzt» werden § Da sich die Exemplare der Klasse nie ändern bleibt diese Eigenschaft bestehen § Finden eindeutige Darstellung (1/2, 2/4, 3/6, … immer num: 1, den: 2) § Methoden add, subtract, … erstellen immer neue Exemplare § Einer der Operanden ist der implizite Parameter, der andere das Argument Rational newNumber = someNumber.add(anotherNumber); § (Auf den impliziten Parameter wird durch this zugegriffen) public class Rational { /* Attributes: * Private instance variables */ private int num; /* The numerator of this Rational */ private int den; /* The denominator of this Rational */ /* Creates a string representation of this rational number. * @return The string representation of this rational number */public String toString() { if (den == 1) { return \"\" + num; } else { return num + \"/\" + den; } } Klasse Rational /* Creates a new Rational initialized to zero. */ public Rational() { this(0); } /* Creates a new Rational from the integer argument. * @param n The initial value */public Rational(int n) { this(n, 1); } /* Creates a new Rational with the value x / y. * @param x The numerator of the rational number * @param y The denominator of the rational number */public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } Klasse RationalKlasse Rational /* Subtracts the rational number r from this one. * @param r The rational number to be subtracted * @return The result of subtracting r from the current number */public Rational subtract(Rational r) { return new Rational(this.num * r.den - r.num * this.den, this.den * r.den); } /* Multiplies this number by the rational number r. * @param r The rational number used as a multiplier * @return The result of multiplying the current number by r */public Rational multiply(Rational r) { return new Rational(this.num * r.num, this.den * r.den); } Klasse Rational /* Divides this number by the rational number r. * @param r The rational number used as a divisor * @return The result of dividing the current number by r */public Rational divide(Rational r) { return new Rational(this.num * r.den, this.den * r.num); } /* Adds the rational number r to this one and returns the sum. * @param r The rational number to be added * @return The sum of the current number and r */public Rational add(Rational r) { return new Rational(this.num * r.den + r.num * this.den, this.den * r.den); } Klasse Rational /* Calculates the greatest common divisor using Euclid's algorithm. * @param x First integer * @param y Second integer * @return The greatest common divisor of x and y */private int gcd(int x, int y) { int r = x % y; while (r != 0) { x = y; y = r; r = x % y; } return y; } } // Rational Simulation § Wir wollen sehen wie ein einfaches Programm drei rationale Zahlen addiert § Danach werfen wir einen Blick hinter die Kulissen § Das Ergebnis dieser Berechnung soll(te) exakt sein 1 sein § Im Gegensatz zur Rechnung mit double + 2 1 3 1 6 1 + // in class TestRational public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); System.out.println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 110 c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 2 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 2 1 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 2 1 1 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 2 1 1 2 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 3 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 3 1 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 3 1 1 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 3 1 1 3 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 6 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 6 1 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 6 1 1 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 6 1 1 6 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 1 6 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 1 6 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 1 6 public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 1 2 r num den 1 3 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 1 6 public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 1 2 r num den 1 3 5 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 1 6 public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 1 2 r num den 1 3 6 5 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 1 6 public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 1 2 r num den 1 3 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 5 6 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 1 6 public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 1 2 r num den 1 3 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 5 6 1 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 1 6 public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 1 2 r num den 1 3 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 5 6 1 5 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 1 2 1 3 1 6 public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 1 2 r num den 1 3 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 5 6 1 5 6 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 temporary result Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 temporary result public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 5 6 r num den 1 6 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 temporary result public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 5 6 r num den 1 6 36 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 temporary result public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 5 6 r num den 1 6 36 Based on Eric Roberts, The Art and Science of Java Pearson (2007) 36 c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 temporary result public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 5 6 r num den 1 6 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 36 36 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 temporary result public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 5 6 r num den 1 6 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 36 36 36 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 temporary result public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 5 6 r num den 1 6 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 36 36 36 1 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 temporary result public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 5 6 r num den 1 6 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 36 36 36 1 1 Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 1 1 temporary result Based on Eric Roberts, The Art and Science of Java Pearson (2007) c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 1 1 temporary result Based on Eric Roberts, The Art and Science of Java Pearson (2007) 1/2 + 1/3 + 1/6 = 1 c sumba public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } TestRational 5 6 1 2 1 3 1 6 1 1 temporary result 1/2 + 1/3 + 1/6 = 1 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 2 1 1 2 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 3 1 1 3 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 1 6 1 1 6 public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 1 2 r num den 1 3 6 5 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 5 6 1 5 6 public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } this num den 5 6 r num den 1 6 36 36 public Rational(int x, int y) { int g = gcd(Math.abs(x), Math.abs(y)); num = x / g; den = Math.abs(y) / g; if (y < 0) num = -num; } y gx this num den 36 36 36 1 1 Based on Eric Roberts, The Art and Science of Java Pearson (2007) Blick hinter die Kulissen § Wir sahen was für Berechnungen gemacht wurden § Aber die Methoden (und Objekte) müssen auch (irgendwo) gespeichert werden § Daher sehen wir uns jetzt an, wie der Speicherplatz verwendet wird 149 Speicher und Addressen § Jedes Byte im Speicher hat eine Adresse – eine Zahl zwischen 0 und einer Obergrenze § Im Beispiel sind Adressen in Hexadezimal- notation mit 4 Stellen angezeigt § Im Java System sind die Adressen unsichtbar und das Beispiel zeigt willkürliche Werte § Illustrationen mit Bytes sind unübersichtlich daher fassen wir 4 Bytes zu einem Wort zusammen und zeigen immer Wortadressen (die dann in 4-er Schritten ansteigen) 0000 0001 0002 0003 0004 0005 0006 0007 0008 0009 000A 000B FFF4 FFF5 FFF6 FFF7 FFF8 FFF9 FFFA FFFB FFFC FFFD FFFE FFFF 0000 0004 0008 000C 0010 0014 0018 001C 0020 0024 0028 002C FFD0 FFD4 FFD8 FFDC FFE0 FFE4 FFE8 FFEC FFF0 FFF4 FFF8 FFFC . . . . . . § Für eine deklarierte Variable muss das Laufzeitsystem Speicherplatz finden § Der Speicher des Computers ist in verschiedene Bereiche unterteilt § Genauer: der Teil des Speichers den unser Java Programm nutzen darf § Ein Bereich ist reserviert für die Variablen die immer exisitieren (während der gesamten Laufzeit des Programms) § Dazu gehörten Konstanten, Informationen über Klassen, etc. § Dieser Bereich heisst «static data» Speicherplatz für VariableSpeicherplatz für Variable § Objekte die durch den new Operator erschaffen werden, werden im «heap» (Halde) abgelegt. § Für jede aufgerufene Methode stellt das Laufzeitsystem einen neuen Bereich zur Verfügung § Dieser heisst «Stack Frame» § Alle Stack Frames werden in einem Stack organisiert § Variable, die in einer Methode deklariert wurden, finden Platz im Stack Frame § Parameter übrigens auch … 152 § Manchmal sind Stack und Heap so angeordnet, dass sie gegeneinander wachsen § Jede Region kann so gross wie möglich werden (bei gegebenem Speicherplatz) static data 0000 stack FFFF heap Stack und Heap § Ein einfaches Modell dieser Bereiche hilft, verschiedene Aspekte von Java zu verstehen § Da Programme oft in einer Methode Variable deklarieren, die auf Exemplare verweisen, müssen wir sowohl den Heap als auch den Stack im Auge behalten § In den folgenden Folien zeigen wir links den Heap und rechts den Stack § Getrennt durch Linie § Stack-Heap Diagramm 155 Stack und Heap § Wenn eine Methode aufgerufen wird, dann muss der neue Stack Frame genug Platz für alle (lokalen) Variablen haben § Wenn eine Methode fertig ist, dann kann ihr Stack Frame wiederverwendet werden § Wenn ein Objektexemplar geschaffen wird, dann brauchen wir Speicherplatz für alle Attribute (Zustandsvariablen) § Dazu brauchen wir zusätzlich Platz für Java-interne Zwecke – Overhead den wir nicht kontrollieren können 156157 a num: 1 den: 2 Type: Rational Rational a = new Rational(1,2) Verweise (References) auf Objekte § Für jedes Exemplar hält das Java System die Adresse des Exemplars fest § Diese Adresse (ggf. mit weiteren Informationen) wird in einer Variable gespeichert (einer «reference variable» – die Variable enthält den Verweis, d.h. die Reference, auf ein Objektexemplar). § Nehmen wir an, eine Methode enthält die Deklaration Rational r1 = new Rational(1, 2); für die Klasse Rational (wie vorher eingeführt) 158 Verweise (References) auf Objekte § Wenn die Deklaration Rational r1 = new Rational(1, 2); umgesetzt wird, brauchen wir im Heap Platz für ein neues Rational Exemplar. § Nehmen wir an wir finden diesen mit der Adresse 1000 § Die Variable r1 wird im Stack Frame gespeichert und erhält den Wert 1000 – die Adresse des neuen Exemplars 159 heap 2den 1num 1008 1004 1000 stack 1000r1 FFFC In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } heap Stack Frame der run Methode. In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } heap In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 2den 1num heap 1008 1004 1000 Alle Objekte liegen im Heap. In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 3den 1num 2den 1num heap 1014 1010 100C 1008 1004 1000 In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 Stack Frame der add Methode. In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1000 100C In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1000 100C In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } 1 heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1000 100C In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } 1 3 heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1000 100C In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } 1 3 1 heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1000 100C In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } 1 3 1 2 heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1000 100C In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } 5 heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1000 100C In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } 6 5 heap 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1000 100C In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack Dieses Objekt ist ein Zwischenergebnis. public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 5num 6den 1num 3den 1num 2den 1num heap 102C 1028 1024 1020 101C 1018 1014 1010 100C 1008 1004 1000 In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 5num 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } heap 102C 1028 1024 1020 101C 1018 1014 1010 100C 1008 1004 1000 Dieses Objekt ist ein Zwischenergebnis. 181182 In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 5num 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } heap 102C 1028 1024 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1024 1018 Stack Frame der add Methode. In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 5num 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } heap 102C 1028 1024 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1024 1018 In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 5num 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } 36 heap 102C 1028 1024 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1024 1018 In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 6den 5num 6den 1num 3den 1num 2den 1num public Rational add(Rational r) { return new Rational( this.num * r.den + r.num * this.den , this.den * r.den ); } 36 36 heap 102C 1028 1024 1020 101C 1018 1014 1010 100C 1008 1004 1000 1000 100C this r FFE8 FFE4 FFE0 1024 1018 In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 1030 TestRationalstack public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 1den 1num 6den 5num 6den 1num 3den 1num 2den 1num heap 1038 1034 1030 102C 1028 1024 1020 101C 1018 1014 1010 100C 1008 1004 1000 In Zeitlupe a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 1030 TestRationalstack 1/2 + 1/3 + 1/6 = 1 public void run() { Rational a = new Rational(1, 2); Rational b = new Rational(1, 3); Rational c = new Rational(1, 6); Rational sum = a.add(b).add(c); println(a + \" + \" + b + \" + \" + c + \" = \" + sum); } 1den 1num 6den 5num 6den 1num 3den 1num 2den 1num heap 1038 1034 1030 102C 1028 1024 1020 101C 1018 1014 1010 100C 1008 1004 1000 Explizite Pointer 1den 1num 6den 5num 6den 1num 3den 1num 2den 1num heap stack a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 1030 1038 1034 1030 102C 1028 1024 1020 101C 1018 1014 1010 100C 1008 1004 1000 § Die Skizze links zeigt den Zustand des Speichers am Ende der Methode run aus TestRational. § Das Bild rechts zeigt den selben Zustand mit einem Pfeil (manchmal «Pointer» genannt) anstelle der Adresse (Pointer Modell) 1den 1num 6den 5num 6den 1num 3den 1num 2den 1num a b c sum heap stack Adressen vs. Pointer 1den 1num 6den 5num 6den 1num 3den 1num 2den 1num heap stack a b c sum FFFC FFF8 FFF4 FFF0 FFEC 1000 100C 1018 1030 1038 1034 1030 102C 1028 1024 1020 101C 1018 1014 1010 100C 1008 1004 1000 Beide Skizzen (mit Adressen oder Pointern) zeigen den selben Zustand aber betonen unterschiedliche Aspekte. – Adressen verdeutlichen dass Verweise (References) eine Zahl enthalten. 1den 1num 6den 5num 6den 1num 3den 1num 2den 1num a b c sum heap stack – Das Pointer Modell betont die Beziehung zwischen Referenz(variable) und Objekt(exemplar). Nicht-erreichbare Objekte Das Pointer Modell macht klar das es keinen Verweis auf das Rational Exemplar 5/6 gibt. Dieser Wert ist jetzt «Garbage». Das Java Laufzeitsystem führt von Zeit zu Zeit eine Speicherbereini- gung durch («garbage collection») – automatisch 1den 1num 6den 5num 6den 1num 3den 1num 2den 1num a b c sum heap stack Exemplar das temporär gebraucht wurde aber jetzt unerreichbar ist. Basistypen vs Objekte § Ein Basistyp Parameter wird nach den Regeln der Value Semantics übergeben. § Ein Parameter für eine Referenzvariable folgt den Regeln der Reference Semantics. § Nur auf den ersten Blick scheint es, dass Basistypen und Referenztypen unterschiedlich behandelt werden. 194 § Wenn wir eine Basistyp Variable als Parameter übergeben, dann kopieren wir den Wert der Variable § (Zur Erinnerung: Basistyp Variablen enthalten den Wert) § Veränderungen in der aufgerufenen Methode haben daher keine Wirkung (die in der aufrufenden Methode sichtbar ist) § Wenn wir ein Referenzvariable als Parameter übergeben, so kopieren wir die Referenz (mit der Adresse) § Daher können wir das Exemplar, das wir über die Adresse erreichen, verändern § Entweder über Accessor/Mutator Methoden oder durch direkten Zugriff auf ein Attribut oder Array Element § Aber wenn wir der Referenzvariable einen neuen Wert zuweisen so ändert sich nichts in der aufrufenden Methode 195 Basistypen vs Objekte § Basistyp Parameter: Kopie des Wertes wird übergeben § Referenzvariable Parameter: Kopie der Referenzvariable (des Pointers und/oder Adresse) wird übergeben § Dieser Wert kann nicht verändert werden § Aber was durch die Referenzvariable erreicht werden kann (Array Element, Attribut eines Exemplars, …) kann geändert werden. 197 Speicherverwaltung § Garbage Collection hat viele Aspekte § Herausfinden welcher Bereich nicht mehr erreicht werden kann § Speicher für Wiederverwendung bereit stellten § Speicherplatz für neue Exemplare finden § Ein interessantes Thema 198 in Gebrauch in Gebrauchfrei in Gebrauch freifrei in Speicherverwaltung § Garbage Collection hat viele Aspekte § Herausfinden welcher Bereich nicht mehr erreicht werden kann § Speicher für Wiederverwendung bereit stellten § Speicherplatz für neue Exemplare finden § Ein interessantes Thema § Aber nicht für die \"Einf. in die Programmierung\" 199 in Gebrauch in Gebrauchfrei in Gebrauch frei in Speicherverwaltung The Garbage Collection Handbook: The Art of Automatic Memory Management Richard Jones, Antony Hosking, and Eliot Moss Taylor & Francis Ltd (2011) 511 Seiten. 200 Speicherverwaltung § 12-byte Exemplare (wie Rational) sind nie das Problem § Manche Exemplare brauchen viel Platz für Buffer o.ä. § Diesen möchte die Klasse (oft) selber managen § Scanner Exemplare brauchen Buffer und es gibt einen Pool von Buffern nur für diese Exemplare § Damit dieser Speicher verwaltet werden kann muss das I/O System wissen, wann die Buffer (für Scanner myScanner) frei sind § Es genügt nicht, myScanner auf null zu setzen § Methode close() (also myScanner.close()) informiert I/O System § Eclipse warnt wenn diese Methode nicht verwendet wird § Fehlender Aufruf kein Problem für einfache Programme 201 Speicherverwaltung § 12-byte Exemplare (wie Rational) sind selten das Problem § Manche Exemplare brauchen viel Platz für Buffer o.ä. § Diesen möchte die Klasse (oft) selber managen § Scanner Exemplare brauchen Buffer und es gibt einen Pool von Buffern nur für diese Exemplare § Damit dieser Speicher verwaltet werden kann muss das I/O System wissen, wann die Buffer (für Scanner myScanner) frei sind § Es genügt nicht, myScanner auf null zu setzen § Methode close() (also myScanner.close()) informiert I/O System § Eclipse warnt wenn diese Methode nicht verwendet wird § Fehlender Aufruf kein Problem für einfache Programme 202 (Extra) Nochmal: Entwurf von Methoden 206 Eine Klasse für Knoten einer Liste public class ListNode { int data; ListNode next; } § Jeder Knoten der Liste speichert: § Den Wert einer ganzen (int) Zahl § Einen Verweis auf einen anderes ListNode Exemplar § «Rekursiver Datentyp» § Werte (des Datentyps) enthalten Referenzen auf Exemplare (dieses Typs) data next -3 data next 17 data next 9 207 solve(): Eine rekursive Methode (Muster) Wenn das Problem nicht weiter zerlegt werden kann (minimal ist, Basisfall): löse Problem direkt (ohne Rekursion) und liefere die Lösung sonst 1. Zerlege Problem in ein oder mehr ähnliche, aber kleinere Teil-Probleme TP1, TP2, …, TPn 2. Rufe rekursive solve() auf, um die kleineren Teil-Probleme zu lösen (denn diese sind ähnlich): solve(TP1), solve(TP2), … , solve(TPn) 3. Füge die Lösungen der Teil-Probleme (von solve(TPi) geliefert) zusammen um das ursprüngliche Problem zu lösen 4. Liefere die Lösung zum ursprünglichen Problem (an den Aufrufer) 209 n! § n! = n natürliche nicht-negative Zahl § Beispiele: 4! = 24; 5! = 120; 0! = 1; (so festgelegt!!) 210 ∏j=1 j=n n! § n! = n natürliche nicht-negative Zahl § Beispiele: 4! = 24; 5! = 120; 0! = 1; (so festgelegt!!) § Rekursive Definition 0! = 1 -- 0 ist die kleinste Zahl für die ! definiert ist n! = n * (n-1)! -- für n>0, ! ist definiert durch ! für kleinere Zahl § Beispiel 5! = 5*4! = 5*4*3! = 5*4*3*2! = 5*4*3*2*1! = 5*4*3*2*1*0! = 5*4*3*2*1*1 211 ∏j=1 j=n Methode fakultaet public static int fakultaet(int n) { if (n == 0) { return 1; } else { int tp1 = n - 1; //(1) Ein Teilproblem int solutionTP1 = fakultaet(tp1); //(2) Rekursion um TP zu lösen int solution = n * solutionTP1; //(3) Lösung des ursp. Problems return solution; //(4) Liefern der Lösung } } 212 Vereinfachte Methode fakultaet public static int fakultaet(int n) { if (n == 0) { return 1; } else { return n * fakultaet(n-1); } } 213 Iterative Methode fakultaet public static int fakultaet(int n) { int resultat = 1; for (int i=2; i<=n; i++) { resultat *= i; } return resultat; } 214 Vergleich Rekursion und Iteration public static int fakultaet(int n) { if (n == 0) { return 1; } else { return n * fakultaet(n-1); } } 215 int resultat = 1; for (int i=2; i<=n; i++) { resultat *= i; } return resultat; Iteration braucht 2 Variable (resultat, i) die in jedem Schleifendurchlauf geändert werden an – a hoch n § n ist eine natürliche, nicht-negative Zahl § Rekursive Definition a0 = 1 -- gilt auch für a == 0 an = a * an-1 -- für alle n>0 § Beispiel a4 = a * a3 = a * a * a2 = a * a * a * a1 = a * a * a * a * a0 = a * a * a * a * 1 216 an – a hoch n § n ist eine natürliche, nicht-negative Zahl § Rekursive Definition a0 = 1 -- gilt auch für a == 0 an = a * an-1 -- für alle n>0 § Beispiel a4 = a * a3 = a * a * a2 = a * a * a * a1 = a * a * a * a * a0 = a * a * a * a * 1 § Kann Methode fakultaet direkt in eine Methode power übertragen 217 Methode power public static int power(int a, int n) { if (n == 0) { return 1; } else { return a * power(a, n-1); } } 218 power(a, 3) = a * power(a, 2) = a * a * power(a, 1) = a * a * a * power(a, 0) = a * a * a * 1 Anzahl Multiplikationen: n (hier: 3) Iterative Methode power public static int power(int a, int n) { int resultat = 1; for (int i=1; i<=n; i++) { resultat *= a; } return resultat; } 219 Vergleich Rekursion und Iteration § Beide Methoden brauchen n Multiplikationen § Es gibt aber einen besseren Weg an zu berechnen: a100 = a50 * a50 = (a50)2 § a0 = 1 § an = 220 (an/2)2 für n gerade a * an-1 für n ungerade{ Variante der Methode power 221 public static int power(int a, int n) { if (n == 0) { return 1; } else if (n%2 == 1) { // n ist ungerade return a * power(a, n-1); } else { // n ist gerade return square(power(a, n/2)); } } public static int square(int y) { return y * y; } Diskussion § Diese Variante führt weniger Multiplikationen aus § Beispiel: a16 § Iteration: 16 Multiplikationen § Rekursion(Variante): 5 Multiplikationen a16 = (a8)2 = ((a4)2)2 = (((a2)2)2)2 = ((((a1)2) 2)2)2 = ((((a * a0)2) 2)2)2 § Fragen § Gibt es eine Formel für die Anzahl Multiplikationen (für an)? § Braucht diese Variante die minimale Anzahl Multiplikationen? § Angebote (Antworten) per eMail an den Dozenten 222 252-0027 Einführung in die Programmierung 6.0 Arbeiten mit Objekten und Klassen Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2020,2021 All rights reserved. 226 Übersicht 6.1 Stil und Konventionen § Hinweise (und Regeln) für verständliche Programme § Teil 1: Nicht vollständig – später erweitert 6.2 Datenstrukturen mit Verknüpfungen 6.3 Entwurf von (abgekapselten) Klassen 6.4 Programmbeispiel und –ausführung 6.5 (Mehr) Optionen für Sichtbarkeit Copyright (c) Pearson 2013 and Thomas Gross 2016,2017,2019. All rights reserved. 227 Übersicht § 6.5.1 Sichtbarkeit (Packages) § 6.5.2 Geschachtelte Klassen § 6.5.3 Spezielle Klasse: enum 228 6.5.1 Packages: Mehr Optionen für Sichtbarkeit 229 Optionen für Kontrolle der Sichtbarkeit § Programmiersprachen stellen verschiedene Mittel zur Verfügung um den Zugriff auf Attribute (bzw. Variable oder auch Methoden) zu kontrollieren § Ziel ist es, unabhängige Entwicklung (von Programmteilen) zu unterstützen § Ziel ist es, möglichst viele Fehler durch den Compiler finden zu lassen § Keine Kosten zur Laufzeit § Verhindern von Fehlern zur Ausführungszeit 230 Hierarchie der Namensräume § Grundregel: keine Doppeldeklaration (für Variable/Methoden/...) § Ziel: Lesbarer, verständlicher Code § Müssen die Sichtbarkeit einschränken § Vier Ebenen (mit Vereinfachungen) 1. Methoden 2. Klassen 3. 4. 231232 method2(p) { q … … } method1(p) { q … … } SomeClient { } ? class Z { y } 233 method2(p) { q … … } method1(p) { q … … } SomeClient { Z ……; } class Z { y } public class Z { public y } 234 public method2(p) { q … … } public method1(p) { q … … } SomeClient { Z z; z.y z.method1(…) } Viele Klassen … § Jeder will eine Klasse List für Listen … § Weitere Möglich- keiten zur Ver- waltung des Namesraumes public class Z { public y } 235 public method1(p) { q … … } import PA.*; SomeClient { Z z; z.y z.method1(…) } package PA; Ziel ist Abkapselung eines Namensraumes § Nicht alles aus einer Package soll (aussen) sichtbar sein Packages § Anweisung (am Anfang einer Datei) § package name; § bestimmt dass alle Klassen dieser Datei zur Package name gehören § Regeln für name (betreffen Folder/Directory) – siehe folgende Slides § Package kann dann imporiert werden § import name; 236 Warum hat uns das niemand gesagt? § Wenn wir keine «Package» Anweisung geben, dann kommen alle Klassen in eine (anonyme) Package § Dies haben wir bisher ausgenutzt § … auch weiterhin 237 Java Packages § Können den Raum der Packages weiter unterteilen § Definition von Unterpaketen («sub-packages») § Sub-packages können ähnliche Namen haben sind aber nicht wirklich in einer Package enthalten § java.awt enthält nicht java.awt.event § Aber «gehört» zur Package java.awt § Paket («package»): Eine Ansammlung von zusammengehörenden Klassen § Eine Datei kann nur in einer Package sein § Klasse legt fest in welcher Package sie ist Java Packages § Gebrauch von Java Packages: § Weg zusammengehörende Klassen zu bündeln § Schafft einen Raum für Namen («namespace») um Nameskonflikte zu vermeiden § Kontrolliert Zugriff bzw. bietet Schutz vor unerwünschten Zugriffen § Erlaubt Gliederung eines grossen Software Projektes 239 Packages und Dateienverzeichnisse § Package ßà Verzeichnis («directory», «folder») § Klasse ßà Datei («file») § Klasse mit Namen D in der Package a.b.c gehört in Datei: a/b/c/D.java § (relativ zur «Root» Ihres Projektes) § Das Haupt («Root») Verzeichnis der Package Hierarchie wird vorgeben durch den classpath oder ist das Verzeichnis von dem aus java aufgerufen wurde § Einstellung in Eclipse Classpath § classpath: Der Ort (Directory) bzw. die Orte in dem/denen Java «class» Files sucht. § .class File: übersetzte .java File § Der Classpath kann beinhalten: § Aktuelles «working directory» in dem javac / java aufgerufen wird § Bzw. Eclipse die Übersetzung durchführt § Andere Verzeichnisse § JAR Archive (JAR: Java Archive) § URLs § ... Classpath § Konfiguriert in Eclipse § Kann explizit gesetzt werden wenn man Java von der Shell aus startet: § java -cp /home/eprog/libs:/foo/bar/jbl MyClass § Ist aber für uns (zum Glück) kein Thema 242 252-0027 Einführung in die Programmierung 6.0 Arbeiten mit Objekten und Klassen Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2020,2021 All rights reserved. 1 Übersicht § 6.5.1 Sichtbarkeit (Packages) § 6.5.2 Geschachtelte Klassen § 6.5.3 Spezielle Klasse: enum 2 6.5.1 Packages: Mehr Optionen für Sichtbarkeit 3 Deklaration einer Package Syntax: package packageName; public class className { ... } § Klasse className ist jetzt in der Package packageName § Muss am Anfang der Datei (className.java) stehen § Beispiel: package pacman.model; public class Ghost { ... } § File Ghost.java sollte im Folder pacman/model sein. Import einer Package import packageName.*; // all classes Beispiel: package pacman.gui; import pacman.model.*; public class PacManGui { ... Ghost blinky = new Ghost(); } Import einer Package § Für die Klasse PacManGui muss die pacman.model Package importiert sein um die Klasse Ghost verwenden zu können § PacManGui muss im Folder pacman.gui liegen § Import pacman.model.* importiert alle Klassen der Package § Kein Import von «Sub-Packages» (z.B. pacman.model.util) 6 Sichtbarkeit und Packages § Ziel ist Abkapselung eines Namensraumes § Sichtbarkeit überall: § In der Package und ausserhalb (nach Import) § Keyword: public § Sichtbarkeit nur in der Package § Nicht aussen sichtbar – auch wenn Package importiert wurde § Keyword: nichts (kein Keyword) – d.h. ! der leere String …. 7 public class W { ! ! ! ! ! v } 8 public method1(p) { } import PA.*; SomeClient { W w; w.v w.method1(…) U u; u.t u.method1() } package PA; ✘ public class U { public t } ! ! ! ! ! method1(p) { } ✘ public class W { ! ! ! ! ! v } 9 public method1(p) { } import PA.*; SomeClient { W w; w.v w.method1(…) U u; u.t u.method1() } package PA; ✘ public class U { public t } ! ! ! ! ! method1(p) { } ✘ ! ! ! ! ! sieht man nicht! class W { v } 10 method1(p) { } import PA.*; SomeClient { W w; U u; u.method1() } package PA; Auch Klassen können nur in der Package sichtbar sein ✘ public class U { } public method1(p) { W w; w.method1() w.v } Import einer Klasse import packageName.className; // one class § Beispiel: package pacman.gui; import pacman.model.Ghost; public class PacManGui { Ghost blinky = new Ghost(); } § Nur Klasse Ghost ist jetzt bekannt Import von Klassen vs. Import einer Package § (Klassen)Namenskonflikte werden unterschiedlich behandelt: § Importieren einer einzelnen Klasse gibt der Klasse einen hohen Stellenwert: § Mit import foo.* gilt: eine Klasse mit dem selben Name in dieser Package verdeckt die importierte Klasse § Mit import foo.className gilt: die Klasse mit dem selben Namen verdeckt nicht die importierte Klasse 12 Arbeiten mit Packages § Auch ohne import können wir uns auf eine Klasse mit vollständigen Namen beziehen. Syntax: packageName.className statt className § Beispiel: java.util.Scanner console = new java.util.Scanner(java.lang.System.in); § Dies ist manchmal praktisch wenn es Namenskonflikte gibt: § Beispiel: java.awt.List und java.util.List § Oder eine Klasse importieren (und dann für die andere den vollständigen Namen verwenden) Arbeiten mit Klassen einer Package § Eine Klasse mit Namen D in der Package a.b.c sollte in dieser Datei gespeichert sein: a/b/c/D.java 17 Arbeiten mit Klassen einer Package § Eine sichtbare Klasse mit Namen D in der Package a.b.c muss in dieser Datei gespeichert sein: a/b/c/D.java § Diese Regel haben wir bis jetzt immer befolgt § Sie gilt nicht für Klassen, die nur innerhalb einer Package verwendet werden 18 Arbeiten mit Packages § Die Package Angabe muss immer als erstes in einer .java Datei erscheinen § Vor der ersten Klasse § Nur einmal pro Datei § Was passiert wenn wir (wie bisher) keine Package deklarieren? 19 Die default Package § Dateien (d.h., die Klassen in der Datei), die keine Package Deklaration enthalten, gehören in eine namenlose default Package. § Klassen in der default Package: § Können nicht importiert werden § Können nicht von anderen Klassen in anderen Packages verwendet werden. § Kein Problem für einfache Programme Die default Package § Wir werden weiterhin nur mit der default Package arbeiten 21 Der default Import § Die Package java.lang wird implizit (automatisch) von allen Packages (und damit Programmen) importiert. import java.lang.*; // redundant 22 Sichtbarkeit und Packages § Ziel ist Abkapselung eines Namensraumes § Sichtbarkeit überall: § In der Package und ausserhalb (nach Import) § Keyword: public § Sichtbarkeit nur in der Package § Nicht aussen sichtbar – auch wenn Package importiert wurde § Keyword: nichts (kein Keyword) – d.h. ! der leere String …. § Default – heisst auch «Package Sichtbarkeit» 23 Sichtbarkeit und Packages § Ziel ist Abkapselung eines Namensraumes § Sichtbarkeit nur in dieser Klasse: § In der Klasse (und ggf. in eingeschlossenen Klassen/Typen – später mehr) § Keyword: private 24 Packages und Sichtbarkeit § Damit ein Attribut/eine Methode die default Sichtbarkeit hat brauchen Sie keinen Modifizierer anzugeben. package pacman.model; public class Sprite { int points; // default: visible to pacman.model.* String name; // default: visible to pacman.model.* } public class Xray { int direction; // default: visible in default package String name; // default: visible in default package } 28 Packages und Sichtbarkeit § In einer Datei Problem.java public class Problem { public static void main(String[] args) { … } } class SubProblem { } 29 Kann SubProblem Exemplare erstellen Aber SubProblem entscheidet Sichtbarkeit von Attributen etc Packages und Sichtbarkeit § In einer Datei Problem.java public class Problem { public static void main(String[] args) { … } } class SubProblem { } 30 Kann SubProblem Exemplare erstellen Aber SubProblem entscheidet Sichtbarkeit von Attributen etc Packages und Sichtbarkeit § In einer Datei Problem.java public class Problem { public static void main(String[] args) { … } } class SubProblem { } 31 Kann Problem Exemplare erstellen Aber SubProblem entscheidet Sichtbarkeit von Attributen etc Attribute und Methoden Sichtbarkeit 32 In einer Datei Problem.java public class Problem { public static void main( String[] args) { SubProblem s = new SubProblem(); int a = s.x; a = s.y; } } Fortsetzung Datei Problem.java class SubProblem { int x; public int y; } Attribute und Methoden Sichtbarkeit 33 In einer Datei Problem.java public class Problem { public static void main( String[] args) { SubProblem s = new SubProblem(); int a = s.f(); a = s.g(); } } Fortsetzung Datei Problem.java class SubProblem { int f() { … } public int g() { … } } Attribute und Methoden Sichtbarkeit 34 In einer Datei Problem.java public class Problem { public static void main( String[] args) { SubProblem s = new SubProblem(); int a = s.v; // prohibited } } Fortsetzung Datei Problem.java class SubProblem { private int v; } Attribute und Methoden und Sichtbarkeit 35 In einer Datei Problem.java public class Problem { public static void main( String[] args) { SubProblem s = new SubProblem(); int a = s.f(); //prohibited } } Fortsetzung Datei Problem.java class SubProblem { private int f() { … } } Attribute, Methoden und (static) Variable 36 In einer Datei Problem.java public class Problem { static int a; public static void main( String[] args) { SubProblem s = new SubProblem(); a = s.f(); a = s.g(); } } Fortsetzung Datei Problem.java class SubProblem { int f() { … } public int g() { … } } Übersicht § 6.5.1 Sichtbarkeit (Packages) § 6.5.2 Geschachtelte Klassen § 6.5.3 Spezielle Klasse: enum 42 6.5.2 Geschachtelte Klassen 43 [Zur Erinnerung] Ein paar Fragen § Die Attribute von ListNode sind nicht private? Ist das guter oder schlechter Stil? Antwort: § Das kann man vertreten da LinkedIntList der einzige Klient von ListNode ist § Andere Programme manipulieren nicht die ListNode Objekte sondern arbeiten mit Methoden der LinkedIntList Klasse. § Es gibt in Java noch bessere Möglichkeiten, solche Klassen zu organisieren, aber die lernen wir erst später kennen. 44 jetzt ListNode und LinkedIntList § Eine Lösung: § LinkedIntList ist eine public Klasse in einer Package § Kann nach Import verwendet werden § Package hat Namen § ListNode ist eine Klasse in der selben Package, aber nicht public § Kann von LinkedIntList verwendet werden, nicht von anderen Klienten § Es gibt noch weitere Lösungen 45 Nested classes § Geschachtelte Klasse («nested class»): Eine Klasse die innerhalb einer anderen Klasse definiert ist. § Können als static oder non-static (default) Klassen definiert werden § non-static nested classes heissen inner classes (innere Klasse) § Wir betrachten hier zuerst die non-static Klassen, d.h. die inneren Klassen («inner class») 46 Inner classes § Warum: § Innere Klassen sind nicht sichtbar für andere Klassen (Abkapselung) § Innere Objekte können die Attribute des äusseren Objekts lesen/modifizieren § Aber: § Exemplare der inneren Klasse existieren nur innerhalb eines Exemplars der sie umschliessenden («outer») Klasse Exemplar der inneren Klasse Exemplar der äusseren Klasse 47 public class outerName { class innerName { } } class Inner { int i; } 50 void method1(p) { i = …; } package X; import Y.*; SomeClient { Outer o; Inner i; i = new Inner(); i.method1(…) } package Y; public class Outer { ✘ ✘ ✘ public class Inner { public int i; } 51 public void method1(p) { i = …; } package X; import Y.*; SomeClient { Outer o; o = new Outer(); int k; k = o.in.i; o.in.method1(…) } package Y; public class Outer { public in = new Inner(); private class Inner { int i; } 52 method1(p) { i = …; } // same package // as Outer SomeClient { Outer o; Inner i; i = new Inner(); i.method1(…) } public class Outer { ✘ ✘ ✘ method2 (p) { Inner i; i = new Inner(); } Inner Class Syntax // outer (enclosing) class public class outerName { ... // inner class private class innerName { ... } } 53 Inner Class Syntax // outer (enclosing) class public class outerName { ... // inner class class innerName { ... } } 54 Inner Class Syntax // outer (enclosing) class public class outerName { ... // inner class public class innerName { ... } } 55 Innere Klassen § Wenn private: Nur der Code in dieser Klasse kann die innere Klasse sehen oder Exemplare konstruieren. § Ohne private: Package § Jedes innere Objekt ist mit dem äusseren Objekt, welches es konstruierte, verbunden § Kann die Attribute/Methoden des äusseren Objektes lesen/modifizieren/aufrufen § Wenn nötig kann das äussere Objekt über die Referenzvariable OuterClassName.this erreicht werden § Denn this bezieht sich auf das innere Objekt 56 Zugriff auf Attribut der äusseren Klasse class TestClass { int i = 3; // in outer class String foo() { InnerClass i = new InnerClass(7); return \"\" + i.bar(); } class InnerClass { } } public class InnerAndOuter { public static void main(String[] args) { System.out.println(new TestClass().foo()); } 57 class InnerClass { int i; // in inner class InnerClass(int i) { this.i = i; } String bar() { String s = \"Inner i=\" + i + \"..\"; s = s + \"Outer i=\" + TestClass.this.i; return s; } } // end InnerClass Output: 58 LinkedIntList/ListNode Beispiel class LinkedIntList { private ListNode front; class ListNode { int data; ListNode next; ListNode() { } ListNode(int v) { } ListNode(int v, ListNode c){} public String toString() {} } // ListNode public String toString() {} //Adds value to end of List void add (int value) { } int remove() { } } // LinkedIntList 59 LinkedIntList/ListNode Beispiel // Beispiel Inner Class public class InnerExample { public static void main(String[] args) { new ListExample().run(); } } class ListExample { void run() { LinkedIntList list = new LinkedIntList(); list.add(1); System.out.println(list); } } Output: [ 1 ] 60 Innere und äussere Objekte § Exemplare der inneren Klasse existieren nur innerhalb eines Exemplars der sie umschliessenden (outer) Klasse § Wenn es kein äusseres Objekt gibt, dann kann es auch kein inneres geben § Einschränkung für static Methoden (der outer Klasse) 61 Ohne umschliessendes Exemplar 62 public class InnerExample2 { public static void main(String[] args) { System.out.println(new InnerClass().foo); } class InnerClass { int foo = 2; } } javac Inner2.java Inner2.java:3: error: non-static variable this cannot be referenced from a static context System.out.println(new InnerClass().foo); ^ Nested Classes als Namensraum § Wir wollen die Schachtelung (in Klasse Outer) nur verwenden um Namenskonflikte (für Klasse Inner) zu vermeiden § Dann wollen wir evtl. in einem Klienten Exemplare einer solchen Klasse Inner konstruieren § Ohne Examplare der Klasse Outer zu konstruieren 63 static nested classes § Das Keyword static wird benutzt um zu zeigen dass diese innere Klasse «zur äusseren Klasse» gehört und wir kein Exemplar von Outer brauchen Outer.Inner myHandle = new Outer.Inner(); § Fast wie eine static Variable – existiert in der Klasse, nicht für jedes Exemplar § Bringt nicht mehr als Packages 64 Mit static,ohne umschliessendes Exemplar 66 public class Outer { public static void main(String[] args) { System.out.println(new Inner().foo); } static class Inner { int foo = 2; } } static inner class ohne outer class Exemplar 67 public class InnerAndOuter2 { public static void main(String[] args) { System.out.println(new TestClass.InnerClass().bar()); } } class TestClass { static int i = 3; static class InnerClass { int i = 0; InnerClass() { this(1); } InnerClass(int i) { this.i = i; } String bar() { String s = \"Inner i=\" + i + \"..\"; s = s + \"Outer i=\" + TestClass.i; return s; } } // InnerClass } TestClass // Alles in einer Datei/Package 68 Übung: § Ändern Sie die LinkedIntList so dass eine innere Klasse ListNode verwendet wird. 69 Hierarchie der Namensräume § Grundregel: keine Doppeldeklaration (für Variable/Methoden/Attribute...) § Ziel: Lesbarer, verständlicher Code § Müssen die Sichtbarkeit einschränken § Vier Ebenen (mit Vereinfachungen) 1. Methoden 2. Klassen 3. Geschachtelte Klassen (inner/outer class) 4. Packages 70 Zusammenfassung § Wichtig ist dass Ihre Programme nicht auf beliebige Attribute zugreifen § z.B. soll LinkedIntList der einzige Klient sein § private schützt vor unerwünschten Zugriffen § Attribut front sollte private sein § Wir arbeiten weiterhin mit der default Package § Default Sichtbarkeit (innerhalb der Package) § Vielleicht Änderung in der (fernen) Zukunft 71 Übersicht § 6.5.1 Sichtbarkeit (Packages) § 6.5.2 Geschachtelte Klassen § 6.5.3 Spezielle Klasse: enum 72 6.5.3 Spezielle Klasse: enum § Manchmal soll eine Variable/ein Aaribut nur einen Wert aus einer endlichen Menge annehmen ??? day; // Montag, Dienstag, Mittwoch, Donnerstag, Freitag § Bei zwei möglichen Werten haben wir uns mit boolean beholfen 6 Geschlecht (1: männlich, 0: weiblich) boolean § Was wenn es mehr Opbonen gibt? § ??? geschlecht // männlich, weiblich, divers 73 enum: Aufzählung public enum Geschlecht { MÄNNLICH, WEIBLICH, DIVERS } § Konvention: mögliche Werte in GROSSBUCHSTABEN § ... sind ja Konstanten § Klasse für Person Exemplare: public class Person { String name; int id; geschlecht Geschlecht; // aus MÄNNLICH, WEIBLICH, DIVERS ... } 74 enum: Aufzählung public enum Day { MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, FREITAG } § Und dann im Programm Day day; day = Day.MONTAG; if (day == Day.FREITAG) { party(); } 75 enum: Aufzählung public enum Day { MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, FREITAG } § Und dann im Programm Day day; day = Day.MONTAG; § Keine Arithmetik erlaubt! day = Day.MONTAG + 1; day = day++; 76 252-0027 Einführung in die Programmierung 7.0 Vererbung Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016-2021 All rights reserved. Übersicht 7.1 Einleitung 7.2 Neue Klassen aus existierenden Klassen 7.3 Vererbung und Konstruktoren 7.4 Selektiv Verhalten (von Objekten) festlegen 7.5 Klasse Object 7.6 Polymorphismus Copyright (c) Pearson 2013 and Thomas Gross 2016, 2021. All rights reserved. 78 SoXware Entwicklung § Programmieren ist anspruchsvoll § Es ist leicht Fehler zu machen § LinkedIntList Aufgaben § Wir würden gerne Software wiederverwenden § Auf früheren Lösungen aufbauen § Bessere (schnellere) Implementationen § Erweiterte Funktionalität § … 79 7.1 Einleitung 80 LinkedIntList § Die Klasse LinkedIntList fügt neuen Knotens am Ende der Liste hinzu void add(int v) { … } 81 front = data next -4 data next 8 data next 22 element 0 element 1 element 2 front = data next -4 data next 38 data next 22 element 0 element 1 element 2 data next 12 element 3 LinkedIntList § add muss Liste durchlaufen um das Ende zu erreichen while (current.next != null) { current = current.next; } § Für kurze Listen (10 … 100 Elemente) ist das kein Problem. Für lange Listen (100'000'000 … Elemente) aber schon 82 front = data next -4 data next 38 data next 22 element 0 element 1 element 2 data next 12 element 3 FastLinkedIntList § Wir brauchen eine Variante von LinkedIntList die einen Verweis auf das letzte Element enthält class FastLinkedIntList { private ListNode front; private ListNode tail; … } 83 front tail FastLinkedIntList data next -4 data next 38 data next 22 element 0 element 1 element 2 data next 12 element 3 LinkedIntList à FastLinkedIntList § Wie können wir die Klasse FastLinkedIntList definieren und dabei möglichst viel von LinkedIntList übernehmen? 84 LinkedIntList § Die Klasse LinkedIntList erlaubt (nur) Speichern eines int Werts in einem Knoten void add(int v) { … } § Was wenn wir double Werte speichern wollen? § Liste besteht aus Kette von ListNode Objekten – diese müssen (auch) geändert werden front = data next 222.3 element 0 element 1 element 2 data next 61.3 data next -43.93 LinkedDoubleList § Wir brauchen eine Variante von LinkedIntList die das Speichern eines double Werts erlaubt void add(double v) { … } § Knoten mit double Werten – sonst keine Änderung class DoubleListNode { double data; DoubleListNode next; } front = data next 222.3 element 0 element 1 element 2 data next 61.3 data next -43.93 LinkedDoubleList DoubleListNode DoubleListNode DoubleListNode LinkedIntList à LinkedDoubleList § Wie können wir eine Klasse LinkedDoubleList definieren und dabei möglichst viel von LinkedIntList übernehmen? § Wie können wir eine Klasse xxxxxxListNode definieren (so dass LinkedxxxxxxList mit diesen Knoten arbeiten kann)? 87 Software Entwicklung § Für einfache Fälle (wie hier auf den Slides gezeigt …) scheint «Copy&Paste» nicht so schlimm § Die Klassen sind nicht sehr gross, wenige Klienten § Richtige Software Projekte haben mehr/grössere Klassen § Wir würden gerne Software wiederverwenden § Auf früheren Lösungen aufbauen § Von LinkedIntList zu FastLinkedIntList § Von LinkedIntList zu LinkedDoubleList, ... 88 Übersicht 7.1 Einleitung 7.2 Neue Klassen aus existierenden Klassen 7.3 Vererbung und Konstruktoren 7.4 Selektiv Verhalten (von Objekten) festlegen 7.5 Klasse Object 7.6 Polymorphismus Copyright (c) Pearson 2013 and Thomas Gross 2016, 2021. All rights reserved. 89 7.2 Neue Klassen aus existierenden Klassen 90 Ein Beispiel – zur Illustration der Probleme § Gegeben: ein Spital § Personen im Spital § Mitarbeiter/innen § Patient/innen § Externe (Handwerker, Techniker, …) § Nicht unbedingt sofort zum Management eines heutigen modernen Spitals geeignet ... 91 Ein Beispiel – zur Illustration der Probleme § Gegeben: ein Spital § Personen im Spital § Mitarbeitende (Angestellte) § Patient/innen § Externe (Handwerker, Techniker, …) § Unsere Aufgabe: Management (Einsatz, Bezahlung, …) der Mitarbeitenden § Ärzte/innen § Fachangestellte (FaGe) 92 § OP-Raum Fachkräfte § Administratoren/innen Spital Beispiel § Gemeinsame Regeln für alle Angestellten: Arbeitszeit, Urlaub, Sozialleistungen, Fortbildung, Pflichtenheft, … § Alle Angestellten besuchen eine gemeinsame Orientierungveranstal- tung um die für alle gültigen Regeln des Spitals zu erhalten § Verhalten im Notfall, professionelles Verhalten, Lohnfortzahlung im Krankheitsfall, … § Alle Angestellten erhalten das 20-seitige Handbuch, das die Arbeitsverhältnisse im Spital regelt § Aber … 93 § Aber jede Abteilung hat noch ihre eigenen Regeln § Angestellte erhalten ein weiteres Handbuch (mit 1-5 Seiten) für die Regeln, die für ihre Abteilung gelten 94 § Das Zusatzhandbuch enthält weitere Regeln und ändert oder erweitert Regeln aus dem (allgemeinen) Spitalregelwerk. Angestellten Handbuch 20 Seiten Arzt/Ärztin Handbuch 25 Seiten FaGe (Pflege) Handbuch 22 Seiten Adminstrator/in Handbuch 21 Seiten OP-Fachkraft Handbuch 25 Seiten Organisation der Regeln § Warum wollen wir nicht je ein Handbuch für Ärzte/innen (25 Seiten), eines für FaGe (22 Seiten), eines für Administratoren (21 Seiten) und eines für OP-Fachkräfte (25 Seiten) erstellen? § Vorteile wenn wir die Handbücher aufteilen : § Anpassungen: Nur eine Stelle muss geändert werden, wenn sich die allgemeinen Regeln ändern. § Lokalitätsprinzip: Schneller Überblick über die Regeln die nur für Ärzte/innen (oder andere Gruppen) gelten. 97 Was wir aus dem Beispiel mitnehmen § Allgemeine Regeln sind sinnvoll (das 20-seitige allgemeine Handbuch) § Einzelne Gruppen brauchen evtl. Zusatzregeln die nur für diese Abteilung gelten § Gruppenregeln haben Vorrang vor den allgemeinen Regeln § Gruppenregeln können evtl. allgemeine Regeln ausser Kraft setzen. 98 Regeln für Angestellte § Hier ist ein Satz von Regeln die für Angestellte des Krankenhauses gelten: § Die Arbeitszeit beträgt 42 Stunden pro Woche § Angestellte erhalten einen Basislohn von 80’000 sFr/Jahr, bis auf OP- Fachkräfte die 10’000 sFr/Jahr extra erhalten, und Administratoren/-innen, die 5’000 sFr/Jahr extra erhalten. § Angestellte haben 4 Wochen Urlaub pro Jahr, bis auf Ärzte/innen, die eine Woche extra (also insgesamt 5 Wochen) bekommen § Um einen Urlaub zu beantragen sollten Angestellte ein grünes Formular verwenden, bis auf Ärzte/innen, die ein gelbes Formular brauchen. 99 Aufgaben und Fähigkeiten der Angestellten § Jede Art von Angestellten spielt im Spitalbetrieb eine bestimmte Rolle § Ärzte/innen behandeln Patienten (untersuchen und stellen eine Diagnose) § Administratoren verarbeiten Rechnungen § FaGe pflegen Patienten auf einer Station (müssen also einer Station zugeteilt sein, für einen bestimmten Zeitraum) § OP-Fachkräfte organisieren und unterstützen Aktivitäten im OP-Saal § Wir wollen jetzt ein System erstellen, das die Spitaldirektion bei der Einsatzplanung, Rechnungsstellung etc unterstützt § Für jede/r Angestellte/n gibt es ein Exemplar einer Klasse mit der wir planen/verwalten können 100 Regeln für Angestellte § Hier ist ein Satz von Regeln die für Angestellte des Krankenhauses gelten: § Die Arbeitszeit beträgt 42 Stunden pro Woche § Angestellte erhalten einen Basislohn von 80’000 sFr/Jahr, bis auf OP- Fachkräfte die 10’000 sFr/Jahr extra erhalten, und Administratoren/-innen, die 5’000 sFr/Jahr extra erhalten. § Angestellte haben 4 Wochen Urlaub pro Jahr, bis auf Ärzte/innen, die eine Woche extra (also insgesamt 5 Wochen) bekommen § Um einen Urlaub zu beantragen sollten Angestellte ein grünes Formular verwenden, bis auf Ärzte/innen, die ein gelbes Formular brauchen. 101 Angestellte: Klasse für Angestellte // A class to represent employees in general (20-page manual). public class Angestellte { public int getHours() { return 42; // works 42 hours / week } public double getSalary() { return 80000.0; // sFr 80'000.00 / year } public int getVacationDays() { return 20; // 4 weeks paid vacation, not including weekends } public String getVacationForm() { return \"green\"; // use the green form } } 102 § Erstellen Sie eine Klasse für FaGe § Alle gemeinsamen Regeln gelten ohne Einschränkung § Fachangestellte (FaGe) zeichnen sich dadurch aus, dass sie (für einen Tag) auf einer Station arbeiten 103 § Erstellen Sie eine Klasse für FaGe § Alle gemeinsamen Regeln gelten ohne Einschränkung § Fachangestellte (FaGe) zeichnen sich dadurch aus, dass sie (für einen Tag) auf einer Station arbeiten § Spezielles Verhalten von FaGe § workAtStation(int station) // arbeitet auf Station 104 Redundante FaGe Klasse // A redundant class to represent FaGe (nurses), 22 page manual public class FaGe { public int getHours() { return 42; // works 42 hours / week } public double getSalary() { return 80000.0; // sFr 80'000.00 / year } public int getVacationDays() { return 20; // 4 weeks paid vacation, not including weekends } public String getVacationForm() { return \"green\"; // use the green form } public void workAtStation(int station) { System.out.println(\"Working at station: \" + station); } } 105 Viel (redundanter) Code § workAtStation ist das einzige Verhalten das FaGe von anderen Angestellten unterscheidet § Die Struktur des Programms sollte die Verhältnisse in der realen Welt widerspiegeln § Was wir wirklich gerne sagen wollen ist § Die Klasse für FaGe ist wie die Klasse für alle Angestellten und enthält noch eine weitere Methode (da sie auf einer Station arbeiten) 106 Beziehungen und Vererbung § Vererbung («inheritance») erlaubt uns, eine Klasse als Erweiterung einer anderen Klasse auszudrücken § Grundlage der Vererbung sind die Verhältnisse der verschiedenen Arten von Angestellten zueinander § Ein/e Arzt/Ärztin ist ein/e Angestellte/r § Jede OP-Fachkraft ist ein/e FaGe § Die ist-ein («is a») Beziehung hält fest: diese Gruppe von Angestellten ist ein Spezialfall einer anderen Gruppe 107 Beziehungen und Vererbung § Die ist-ein («is a») Beziehung hält fest, wann eine Gruppe von Angestellten als ein Spezialfall einer anderen Gruppe gilt § Hierarchie § Vererbungshierarchie («Inheritance Hierachy»): Eine Menge von Klassen – verbunden durch eine ist-ein Beziehung – die gemeinsamen Code verwenden können. 108 Vererbungshierarchie 111 Angestellte Arzt/Ärztin FaGe (Pflege) Adminstrator/in OP-Fachkraft ist-ein Beziehung(en) § Es gibt viele Situationen, in denen eine «ist-ein» Beziehung exisitiert § Ein Quadrat ist ein Rechteck § Ein Rechteck ist ein Parallelogramm § Ein Parallelogramm ist ein Viereck 112 «ist-ein» à Vererbungshierarchie 113 Viereck konvexes Viereck überschlage- nes Viereck konkaves Viereck Tangentenvier- eck Trapez Drachenvier- eck Parallelo- gramm Sehnenviereck «ist-ein» à Vererbungshierarchie 114 Viereck überschlage- nes Viereck Figuren aus Wikipedia Vererbung § Vererbung erlaubt es neue Klassen aus existierenden Klassen zu bilden so dass die neue Klasse die Attribute bzw das Verhalten der alten Klasse übernimmt § Erlaubt es verwandte Klassen in Gruppen anzuordnen § Erlaubt dass zwei oder mehr Klassen Code teilen § Eine Klasse kann eine andere erweitern («extend») und Daten und Zustand sowie Verhalten absorbieren 115 Vererbungshierarchie § Klasse erweitert eine andere Klasse § «superclass» («Oberklasse»): Klasse die erweitert wird. § «subclass» («Unterklasse»): Klasse die die Oberklasse erweitert und ihre Eigenschaften/ihr Verhalten erbt. § Subclass erhält Kopie jedes Attributes/jeder Methode der Superclass 116 Angestellte Arzt/Ärztin FaGe (Pflege) Adminstrator/ in OP-Fachkraft Inheritance Syntax public class name extends superclass { § Beispiel: public class FaGe extends Angestellte { ... } Die Erweiterung von Angestellte bewirkt für FaGe Objekte: § Methoden getHours(), getSalary(), getVacationDays(), und getVacationForm() existieren automatisch § Können als Angestellte Objekt(exemplar) von Klienten behandelt werden (Details später) 119120 Angestellte: Klasse für Angestellte // A class to represent employees in general (20-page manual). public class Angestellte { public int getHours() { return 42; // works 42 hours / week } public double getSalary() { return 80000.0; // sFr 80'000.00 / year } public int getVacationDays() { return 20; // 4 weeks paid vacation, not including weekends } public String getVacationForm() { return \"green\"; // use the green form } } 121 Verbesserte FaGe Klasse // A class to represent FaGe. public class FaGe extends Angestellte { public void workAtStation (int station) { System.out.println(\"Working at station: \" + station); } } § Brauchen nur die Teile die spezifisch für eine Gruppe sind zu schreiben § FaGe erbt Methoden getHours(), getSalary(), getVacationDays(), und getVacationForm() von Angestellte. § FaGe fügt die workAtStation() Methode hinzu. 122 Eine Klasse für Arzt/Ärztin § Sammeln wir die Regeln die für Ärzte und Ärztinnen gelten: § Ärzte/innen erhalten eine Woche mehr Urlaub (insgesamt 5) § Ärzte/innen verwenden ein gelbes Formular wenn sie Urlaub beantragen § Ärzte/innen haben besondere Fähigkeiten: sie können Patienten behandeln § Problem: Wir wollen dass Ärzte/innen von Angestellte das meiste Verhalten erben aber wir wollen Teile durch neues Verhalten ersetzen (und neues Verhalten hinzufügen) 123 Klasse Arzt § Diese Klasse soll auf der Klasse Angestellte aufbauen § Erweiterung alleine ist aber nicht genug § Anderes Formular für Urlaub, mehr Urlaub public class Arzt extends Angestellte { } 124 Überschreiben von Methoden § Überschreiben («override»): Definieren einer neuen Version einer Methode in einer Subclass die die Version dieser Methode aus der Superclass ersetzt § Keine besondere Syntax erforderlich. Einfach eine neue Version der Methode schreiben. public class Arzt extends Angestellte { // overrides getVacationForm method in Angestellte class public String getVacationForm() { return \"yellow\"; } ... } 125 Annotationen – nicht notwendig aber oft nützlich @Override public int gethours() { //ein Fehler? Überschreiben von Methoden § Überschreiben («override»): Definieren einer neuen Version einer Methode in einer Subclass die die Version dieser Methode aus der Superclass ersetzt. § Keine besondere Syntax erforderlich. Einfach eine neue Version der Methode schreiben. Annotation @Override drückt Absicht aus. public class Arzt extends Angestellte { @Override // overrides method in Angestellte class public String getVacationForm() { return \"yellow\"; } ... } 126 Aufgabe: Vervollständigen Sie Klasse Arzt § (Besondere) Eigenschaften des Verhaltens für Arzt § 5 Wochen Urlaub § Gelbes Formblatt für Urlaubsantrag § Behandelt Patienten (Untersuchung, Diagnose, Therapie) § treatPatient() § Sonst sind Ärzte/innen Angestellte 127 Arzt Klasse // A class to represent medical personel, 25 page manual public class Arzt extends Angestellte { // overrides getVacationForm from Angestellte class public String getVacationForm() { return \"yellow\"; } // overrides getVacationDays from Angestellte class public int getVacationDays() { return 25; // 5 weeks vacation } public void treatPatient() { System.out.println(\"I'll take care of you!\"); } } 128 § Superclass: Angestellte § Subclass: FaGe § Superclass: Angestellte § Subclass: Arzt § Frage: Wer kann/hat mehr? (mehr Methoden, mehr Attribute, mehr spezifische Methoden)? § Superclass (Oberklasse) § Subclass (Unterklasse) 130 Poll 132 § Erstellen Sie eine Klasse für Administratoren § Alle gemeinsamen Regeln gelten ohne Einschränkung bis auf § Administratoren verdienen sFr 5'000 extra/Jahr § Administratoren zeichnen sich dadurch aus, dass sie Rechnungen verarbeiten (Rg. schicken, Zahlungseingang kontrollieren, …) 134 § Wir brauchen also eine Methode für dieses Verhalten § Nennen wir sie processBill() Eine Klasse für Administratoren/-innen // A class to represent administrators (21-page manual). public class Administrator extends Angestellte { // overrides getSalary from Angestellte public double getSalary() { return 85000.0; // sFr 85'000.00 / year } public void processBill() { System.out.println(\"Pay now! \"); } } 135 Ebenen in der Inheritance Hierarchie § Die Inheritance Hierarchie erlaubt verschiedene Ebenen § Beispiel: Eine OP-Fachkraft ist ein/e FaGe aber verdient mehr (90'000 sFr/Jahr) – und kann auch einen OP Saal managen. public class OPFachkraft extends FaGe { ... } § Übung: Vervollständigen Sie die OPFachkraft Klasse § manageOP() besonderes Verhalten 136 OPFachkraft Klasse // A class to represent OPFachkraft, 25 page manual public class OPFachkraft extends FaGe { // overrides getSalary from Angestellte public double getSalary() { return 90000.0; // sFr 90'000.00 / year } public void manageOP() { System.out.println(\"I control the tools!\"); } } 139 Motivation § Wir wollen weiter am Spitalmanagement System arbeiten. § Stellen wir uns vor dass es Änderungen gibt, die alle Spitalangestellten betreffen. § Beispiel: Jede/r erhält ein um sFr 10’000 höheres Gehalt um die Wertschätzung auszudrücken. Das Basisgehalt ist nun sFr 90’000/Jahr. § OP-Fachkräfte verdienen nun sFr 100’000/Jahr. § Administratoren verdienen nun sFr 95’000/Jahr. § Diese Änderungen erzwingen dass wir den Code überarbeiten 141 Veränderungen der Superclass // A class to represent employees in general (20-page manual). public class Angestellte { public int getHours() { return 42; // works 42 hours / week } public double getSalary() { return 90000.0; // sFr 90'000.00 / year } ... } § Ist das genug (an Änderungen)? 142 § Die Subclasses von Angestellte sind noch nicht richtig. § Diese Klassen hatten getSalary() überschrieben um andere Werte zurückzugeben 143 (K)eine Lösung public class OPFachkraft extends FaGe { public double getSalary() { return 100000.0; // sFr 100'000.00 / year } ... } public class Administrator extends Angestellte { public double getSalary() { return 95000.0; // sFr 95'000.00 / year } ... } § Problem: die Löhne der Subclasses basieren auf dem Lohn für Angestellte aber der Code in getSalary() macht das nicht klar. 144 Aufruf von überschriebenen Methoden § Subclasses können überschriebene Methoden mittels der Referenzvariablen super aufrufen. super.method(parameters) § Beispiel: public class Administrator extends Angestellte { public double getSalary() { return super.getSalary() + 5000.0; } ... } 145 Übung § Verändern Sie die Klassen Arzt und OPFachkraft so dass sie super gebrauchen. 146 Verbesserte Arzt Subclass public class Arzt extends Angestellte { public String getVacationForm() { return \"yellow\"; } public int getVacationDays() { return super.getVacationDays() + 5; } public void treatPatient() { System.out.println(\"I'll take care of you!\"); } } 147 Mit Arzt Subclass arbeiten public class Arzt extends Angestellte { … public int getVacationDays() { return super.getVacationDays() + 5; } } // somewhere … void printInfo(Arzt y) { System.out.println(y.getVacationDays()); } 148149 Verbesserte OPFachkraft Subclass public class OPFachkraft extends FaGe { public double getSalary() { return super.getSalary() + 10000.0; } public void manageOP() { System.out.println(\"I control the tools!\"); } } § super bezieht sich hier auf FaGe – da diese Klasse aber getSalary() nicht überschreibt wird die Methode aus der Klasse Angestellte ausgeführt. 151152 Verbesserte Administrator Subclass public class Administrator extends Angestellte { public double getSalary() { return super.getSalary() + 5000.0; } public void processBill() { System.out.println(\"Pay now! \"); } } 155 Übersicht 7.1 Einleitung 7.2 Neue Klassen aus existierenden Klassen 7.3 Vererbung und Konstruktoren 7.4 Selektiv Verhalten (von Objekten) festlegen 7.5 Klasse Object 7.6 Polymorphismus Copyright (c) Pearson 2013 and Thomas Gross 2016, 2021. All rights reserved. 156 7.3 Vererbung und Konstruktoren 157 Vererbung und Konstruktoren § Wir wollen Angestellten (nicht aber FaGe) mehr Urlaubstage geben je länger sie in diesem Spital gearbeitet haben § Für jedes Jahr gibt es 2 zusätzliche Ferientage § Wenn ein Angestelle Objekt konstruiert wird, dann übergeben wir die Anzahl Jahre als Parameter für den Konstruktor § Wir müssen die Angestellte Klasse verändern und neue Attribute (Zustandsvariablen) und neues Verhalten hinzufügen § Übung: Machen Sie die nötigen Änderungen für Angestellte165 Veränderte Klasse Angestellte public class Angestellte { private int years; //Prevent client access public Angestellte(int initialYears) { years = initialYears; } public int getVacationDays() { return 20 + 2 * years; } public int getHours() { return 42; } public double getSalary() { return 90000.0; } public String getVacationForm() { return \"green\"; } } // Angestellte 166 Ein Problem mit Konstruktoren § Jetzt wird die erweiterte Klasse Arzt nicht vom Compiler akzeptiert. § Da es einen Konstruktor in der Klasse für Angestellte gibt wird die Subclass (Arzt) nicht übersetzt. Die Fehlermeldung: Arzt.java:2: cannot find symbol symbol : constructor Angestellte() location: class Angestellte public class Arzt extends Angestellte{ ^ 167 Konstruktoren – Zur Erinnerung § Für jede Klasse gibt es (vom System) den (parameterlosen) default constructor class Foo() { int x; Foo y; } § Wenn eine Klasse (mindestens) einen Konstruktor definiert so gibt es keinen default constructor class Foo() { … Foo(int a) { x = a; } § Ein parameterloser Konstruktor muss dann explizit erstellt werden 169 Foo () { x = 0; y = null; } Foo () { x = 0; y = null; } Ein Problem mit Konstruktoren § Eine kurze Erklärung: Wenn wir einen Konstruktor (mit Parametern) in der Superclass definieren dann müssen wir auch Konstruktoren für die Subclass(es) liefern. § D.h. da es einen Konstruktor für Angestellte gibt brauchen wir auch einen Konstruktor für Arzt § Eine lange Erklärung: (die nächsten Slides) 170 Genauere Erklärung § Konstruktoren werden nicht geerbt. § Eine Subclass erbt nicht den Angestellte(int) Konstruktor. § Zwei Folgen: 1. Brauchen wir einen Konstruktor so muss die Subclass ihn enthalten § Sonst gibt es nur den parameterlosen Defaultkonstruktor 2. Subclassen erweitern die Superclass – wenn der Superclass Konstruktor etwas für Superclass Exemplare festlegen will so sollte das auch für Subclass Exemplare gelten 171 Genauere Erklärung § Ein Konstruktor der Subclass muss einen Konstruktor der Superclass aufrufen können § Die Subclass «weiss» nicht was der Superclass Konstruktor will § Wir wollen (evtl) die Superclass ändern ohne die Subclass ändern zu müssen § Beispiel: § Superclass fügt Attribut ein und dies muss mit einem Wert initialisiert werden § Alle Superclass Exemplare sind betroffen, auch Subclass Exemplare § Subclass Konstruktor muss Superclass Konstruktor involvieren 172173174 Genauere Erklärung § Einen Konstruktor der Superclass können wir (in einem Konstruktor der Subklasse!) explizit aufrufen: super(parameters); § Beispiel public Subclass(int v) { // constructor in Subclass super(v); // calls Superclass constructor mit // Parameter v } 175 class SuperC { SuperC(int i) { ... } } class Subclass extends SuperC { Subclass(int v) { ... } } 176 Genauere Erklärung § Für Subclasses gibt es nur einen default Konstruktor der den parameterlosen Konstruktor der Superclass aufruft: public Arzt() { super(); // calls Angestellte() constructor } § super() ruft den parameterlosen Konstruktor des direkten Vorgängers in der Inheritance Hierarchie auf 179 § Aber der Konstruktor Angestellte(int) entfernt den default Angestellte() Konstruktor § Dieser ist jetzt nicht mehr verfügbar § Der default constructor der Subclass versucht jetzt den nicht- existierenden parameterlosen (default) Konstruktor für Angestellte aufzurufen. § Entweder ändern wir die Subclass (und definieren Konstruktoren) oder wir sorgen dafür dass ein parameterloser Konstruktor in der Superclass definiert ist. 181 Aufrufe der Konstruktoren der Superclass super(parameters); § Beispiel: public class Arzt extends Angestellte { public Arzt(int years) { super(years); // calls Angestellte constructor } ... } § Aufruf von super() muss erste Anweisung im Konstruktor sein. 182 Aufgabe § Machen Sie entsprechende Änderungen in der Klasse Administrator 183 Veränderte Administrator Klasse // A class to represent administrators. public class Administrator extends Angestellte { public Administrator (int years) { super(years); } public void processBill() { System.out.println(\"Pay now! \"); } @Override public double getSalary() { return super.getSalary() + 5000.0; } } 184 Aufgabe § Verändern Sie die FaGe Subclass § Angestellte dieser Gruppe erhalten keine zusätzlichen Ferientage basierend auf der Zeit in der er/sie im Spital arbeitete. § Die Jahre die ein/e FaGe im Spital gearbeitet hat spielen für die Urlaubsberechnung keine Rolle. 185 Veränderte FaGe Klasse // A class to represent FaGe. public class FaGe extends Angestellte { public FaGe() { // Replaces default constructor super(0); } public void workAtStation (int station) { System.out.println(\"Working at station: \" + station); } } § Da OPFachkraft keinen Parameter für den Konstruktor braucht wird OPFachkraft ohne (expliziten) Konstruktor übersetzt § Der default Konstruktor OPFachkraft() ruft FaGe() auf. 187 public class OPFachkraft extends FaGe { ... } § Der default Konstruktor OPFachkraft() sieht so aus: public OPFachkraft() { super(); // calls FaGe() constructor } § Der Konstruktor des direkten Vorgängers in der Inheritance Hierarchie wird durch super() aufgerufen. 190 252-0027 Einführung in die Programmierung 7.0 Vererbung Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016-2021 All rights reserved. Übersicht 7.1 Einleitung 7.2 Neue Klassen aus existierenden Klassen 7.3 Vererbung und Konstruktoren 7.4 Selektiv Verhalten (von Objekten) festlegen 7.5 Klasse Object 7.6 Polymorphismus Copyright (c) Pearson 2013 and Thomas Gross 2016, 2021. All rights reserved. 2 7.3 Vererbung und Konstruktoren 3 Vererbung und Konstruktoren § Wir wollen Angestellten (nicht aber FaGe) mehr Urlaubstage geben je länger sie in diesem Spital gearbeitet haben § Für jedes Jahr gibt es 2 zusätzliche Ferientage § Wenn ein Angestelle Objekt konstruiert wird, dann übergeben wir die Anzahl Jahre als Parameter für den Konstruktor § Wir müssen die Angestellte Klasse verändern und neue Attribute (Zustandsvariablen) und neues Verhalten hinzufügen § Übung: Machen Sie die nötigen Änderungen für Angestellte 4 Veränderte Klasse Angestellte public class Angestellte { private int years; //Prevent client access public Angestellte(int initialYears) { years = initialYears; } public int getVacationDays() { return 20 + 2 * years; } public int getHours() { return 42; } public double getSalary() { return 90000.0; } public String getVacationForm() { return \"green\"; } } // Angestellte 5 Unerwünschte Konsequenz(en) § Da es einen Konstruktor Angestellte(int) gibt, verschwindet der parameterlose default Konstruktor § Subclasses erben keinen Konstruktor, es gibt nur den parameterlosen default Konstruktor § ... ruft den parameterlosen Konstruktor der direkten Superclass auf: public Arzt() { // default constructor super(); // calls Angestellte() constructor ... // sets attributes to Null } § Entweder ändern wir die Subclass (und definieren Konstruktoren) oder wir sorgen dafür dass ein parameterloser Konstruktor in der Superclass definiert ist. 6 § Konstruktor der Klasse Arzt ruft Superclass Konstruktor auf super(parameters); § Aufruf von super() muss erste Anweisung sein. public class Arzt extends Angestellte { public Arzt(int years) { super(years); // calls Angestellte constructor } ... } § Kein Arzt Konstruktor ruft parameterlosen Angestellte Konstruktor auf 7 Veränderte Arzt KlasseVeränderte Administrator Klasse // A class to represent administrators. public class Administrator extends Angestellte { public Administrator (int years) { super(years); } public void processBill() { System.out.println(\"Pay now! \"); } @Override public double getSalary() { return super.getSalary() + 5000.0; } } 8 Aufgabe § Verändern Sie die FaGe Subclass § Angestellte dieser Gruppe erhalten keine zusätzlichen Ferientage basierend auf der Zeit in der er/sie im Spital arbeitete. § Die Jahre die ein/e FaGe im Spital gearbeitet hat spielen für die Urlaubsberechnung keine Rolle. 9 Veränderte FaGe Klasse // A class to represent FaGe. public class FaGe extends Angestellte { public FaGe() { // Replaces default constructor super(0); } public void workAtStation (int station) { System.out.println(\"Working at station: \" + station); } } § Da OPFachkraft keinen Parameter für den Konstruktor braucht wird OPFachkraft ohne (expliziten) Konstruktor übersetzt § Der default Konstruktor OPFachkraft() ruft FaGe() auf. 1112 class Angstellte { Angestellte(int initY) { years = initY; } } class FaGe extends Angestellte { public FaGe() { //replaces default constructor super(0); } } class OPFachkraft extends FaGe { public OPFachKraft() { // default constructor super(); } } 13 7.3.1 Sichtbarkeit von private 16 Vererbung und Attribute § Wir wollen den Lohn von Ärzten/–innen erhöhen -- um sFr 5’000 pro Jahr das im Spital gearbeitet wurde: public class Arzt extends Angestellte { ... public double getSalary() { return super.getSalary() + 5000 * years; } ... } § Diese Konstruktion wird vom Compiler nicht akzeptiert 17 Vererbung und Attribute § Wir erhalten folgende Fehlermeldung: Arzt.java:7: years has private access in Angestellte return super.getSalary() + 5000 * years; ^ § Auf private Attribute (Variable, Elemente) kann in der Subclass nicht direkt zugegriffen werden. § Ein Grund: so kann eine Subclass nicht die Abkapselung der Superclass zerstören. § Wie kann man mit dieser Einschränkung arbeiten? 18 Verbesserte Angestellte Klasse Wir definieren einen Accessor für alle Attribute die die Subclass lesen soll. public class Angestellte { private int years; public Angestellte (int initialYears) { years = initialYears; } public int getYears() { return years; } ... } 19 Verbesserte Arzt Klasse public class Arzt extends Angestellte { public Arzt(int years) { super(years); } @Override public double getSalary() { return super.getSalary() + 5000 * getYears(); } ... } 20 7.3.2 Beispiele Angestellte peter = new Angestellte(); peter.getSalary(); System.out.println(peter.years); 25 Beispiele Angestellte peter = new Angestellte(); peter.getSalary(); // 90’000 System.out.println(peter.years); // Error (Compiler beschwert sich) 26 Angestellte private int yearsBeispiele Angestellte peter = new Angestellte(); peter.getSalary(); System.out.println(peter.years); Arzt sue = new Arzt(7); sue.getSalary(); sue.treatPatient(); 27 Beispiele Angestellte peter = new Angestellte(); peter.getSalary(); // 90’000 System.out.println(peter.years); // Error (Compiler beschwert sich) Arzt sue = new Arzt(7); sue.getSalary(); // 125’000 (90 + 5 * 7)000 sue.treatPatient(); // \"I’ll take care of you!\" 28 Arzt void treatPatientBeispiele Angestellte peter = new Angestellte(); peter.getSalary(); System.out.println(peter.years); Arzt sue = new Arzt(7); sue.getSalary(); sue.treatPatient(); OPFachkraft roger = new OPFachkraft(); roger.getSalary(); roger.manageOP(); roger.treatPatient(); 29 Beispiele Angestellte peter = new Angestellte(); peter.getSalary(); // 90’000 System.out.println(peter.years); // Error (Compiler beschwert sich) Arzt sue = new Arzt(7); sue.getSalary(); // 125’000 sue.treatPatient(); // \"I’ll take care of you!\" OPFachkraft roger = new OPFachkraft(); roger.getSalary(); // 100’000 roger.manageOP(); roger.treatPatient(); // Nicht moeglich (Compiler beschwert sich) 30 OPFachKraft void manageOPBeispiele OPFachkraft roger = new OPFachkraft(); roger.workAtStation(3); 31 Beispiele OPFachkraft roger = new OPFachkraft(); roger.workAtStation(3); // \"Working at station 3\" // OPFachkraft ist eine FaGe 32 Übersicht 7.1 Einleitung 7.2 Neue Klassen aus existierenden Klassen 7.3 Vererbung und Konstruktoren 7.4 Selektiv Verhalten (von Objekten) festlegen 7.5 Klasse Object 7.6 Polymorphismus Copyright (c) Pearson 2013 and Thomas Gross 2016, 2019. All rights reserved. 35 7.4 Selektiv Verhalten (von Objekten) festlegen 36 § Bisher (und weiterhin) Fokus auf Methoden class Y extends Base { ... } § Wenn Klasse Y die Klasse Base erweitert § Y erbt die Methoden von Base § Y kann Methoden von Base überschreiben § Y erbt die Attribute von Base § Y erbt nicht die Konstruktoren von Base 37 Vererbungshierarchie 42 Angestellte private int years getVacationDays getHours getYears getSalary getVacationForm OPFachkraft int years getVacationDays getHours getYears getSalary getVacationForm manageOP workAtStation FaGe int years getVacationDays getHours getYears getSalary getVacationForm workAtStation Arzt int years getVacationDays getHours getYears getSalary getVacationForm treatPatient Administrator int years getVacationDays getHours getYears getSalary getVacationForm processBill Klasse Attribute (später mehr) geerbte Methode definierte Methode 43 Vererbungshierarchie § Für alle Angestellte Exemplare können wir getHours, getYears, getVacationForm, getVacationDays aufrufen (anwenden) § Für getHours und getYears wird für alle Exemplare der selbe Code (aus Angestellte) ausgeführt § Klienten von Angestellte können sich darauf verlassen dass diese Methoden existieren § (Sub)Klasse muss sicherstellen dass die Methoden richtig sind § Subklassen können Verhalten ändern aber Methoden nicht verschwinden lassen 45 Arzt lin = new Arzt(12); FaGe bob = new FaGe(); Adminstrator tom = new Administrator(3); OPFachkraft an = new OPFachkraft(); 46 Angestellte Arzt FaGe OPFachkraft Administrator lin.getHours() bob.getSalary() lin.getVacationForm() tom.getSalary an.getSalary() an.workAtStation() Welche Methode? In welcher Klasse ist die Methode definiert? Arzt lin = new Arzt(12); FaGe bob = new FaGe(); Adminstrator tom = new Administrator(3); OPFachkraft an = new OPFachkraft(); 47 Angestellte Arzt FaGe OPFachkraft Administrator lin.getHours() ✓ bob.getSalary() ✓ lin.getVacationForm() ✓ tom.getSalary ✓ an.getSalary() ✓ an.workAtStation() ✓ Wenn es mehrere Versionen (@Override) gibt … § Festlegen der Version, die aufgerufen wird, nennt man Bindung («binding») – wir binden (verknüpfen) Code mit dem Namen der Methode § Java legt fest, dass die Klasse des Objektexemplars (für das die Methode ausgeführt wird) bestimmt, welche Version ausgeführt wird § Es findet eine dynamische Bindung («dynamic binding») statt – die Klasse steht (evtl.) erst zur Ausführungszeit fest § Diesen Aspekt werden wir jetzt bzw. in der nächsten Vorlesung noch mehr untersuchen 48 Zusammenfassung Methodenaufruf § Gegeben Superklasse X und Subklasse A class X { void doit() { … } } } § Klasse A überschreibt also Methode doit aus X § Wird für ein Exemplar der Klasse A die Methode doit aufgerufen, so wird die Version der Klasse A ausgeführt new A().doit(); // doit aus A! new X().doit(); // doit aus X – was sonst?? 49 class A extends X { @Override void doit() { … } } Zusammenfassung Methodenaufruf § Wird für ein Exemplar der Klasse A die Methode doit aufgerufen, so wird die Version der Klasse A ausgeführt new A().doit(); // doit aus A! new X().doit(); // doit aus X – was sonst?? § Unabhängig davon was für eine Referenzvariable verwendet wird A rA = new A(); rA.doit(); // doit aus A! X rX = new X(); rX.doit(); // doit aus X – was sonst?? X tX = new A(); tX.doit(); // doit aus A!! 50 X A 51 Zurück zu Angestellte und FaGe § Die FaGe Klasse hat im Augenblick verschiedene Probleme. § Wir setzten die Jahre für alle Fachangestellten auf 0 Jahre da diese Gruppe keinen Dienstaltersbonus für den Urlaub bekommt § Damit können wir das Attribut years nicht für andere Berechnungen verwenden § Wir trennen die 20 Basisurlaubstage von denen, die auf Grund des Dienstalters vergeben werden. 55 Idee: Details offen halten § Verhalten durch Methoden ausgedrückt § Methode1 § Methode2 § Methoden rufen Methoden auf § Methode1 à Methode2 § In der Superclass muss Methode2 nicht (endgültig) festgelegt werden – eine Subclass kann Methode2 überschreiben § «Override»: selbe Signatur, anderes Verhalten § Signatur: Parameter, Return Typ, Sichtbarkeit 5657 public class Angestellte { private int years; public Angestellte(int initialYears) { years = initialYears; } public int getVacationDays() { return 20 + getSeniorityBonus(); } // vacation days given for each year in the hospital public int getSeniorityBonus() { return 2 * years; } ... } 58 public class Angestellte { private int years; public Angestellte(int initialYears) { years = initialYears; } public int getVacationDays() { return 20 + getSeniorityBonus(); } // vacation days given for each year in the hospital public int getSeniorityBonus() { return 2 * years; } ... } Wie hilft uns dieses Design mit der Klasse FaGe? Verbesserte FaGe Klasse § FaGe kann selektiv die Methode getSeniorityBonus überschreiben. § Wenn getVacationDays ausgeführt werden soll, dann wird die neue (überschriebene) Version aufgerufen. § Festlegen der Version, die aufgerufen wird, durch dynamische Bindung («dynamic binding»). 59 public class FaGe extends Angestellte { public FaGe(int years) { super(years); // now records true number of years } // FaGe don't get extra vacation for their years of service. @Override public int getSeniorityBonus() { return 0; } public void workAtStation(int station) { System.out.println(\"Working at station: \" + station); } } 6062 Angestellte public int getVacationDays() { … getSeniorityBonus() } public int getSeniorityBonus() { … } Administrator FaGe public int getSeniorityBonus() { … } mary = new Administrator(5); mary.getVacationDays(); peter = new FaGe(7); peter.getVacationDays(); 6464 Methoden Aufruf f() à m() m() f() f() m() Klasse SubclassA Superclass SubclassB m() Methode m() in Subklasse SubclassB überschrieben SubclassA erbt m() m() f() SubclassA Superclass SubclassB m() Methode m() in Subklasse SubclassB überschrieben SubclassA erbt m() m() f() m() 67 Superclass 67 SubclassA SubclassB m() m() // A Für Exemplar der Subklasse SubclassA ... Methoden Aufruf f() à m() ... m() Methode m() in Subklasse SubclassB überschrieben SubclassA erbt m() f() f() 68 Superclass 68 SubclassA SubclassB m() m() // B Für Exemplar der Subklasse SubclassB ... Methoden Aufruf f() à m() ... m() Methode m() in Subklasse SubclassB überschrieben SubclassA erbt m() f() f() 69 Superclass 69 SubclassA SubclassB m() Abhängig von Subklasse oder m() // A m() // B Methode m() in Subklasse SubclassB überschrieben SubclassA erbt m() m() f() f() 71 Angestellte public int getVacationDays() { … getSeniorityBonus() } public int getSeniorityBonus() { … } Administrator FaGe public int getSeniorityBonus() { … } mary = new Administrator(5); mary.getVacationDays(); peter = new FaGe(7); peter.getVacationDays(); 72 Angestellte Administrator 72 FaGe oder getVacationDays getVacationDays getSeniorityBonus getSeniorityBonus getSeniorityBonus 73 mary = new Administrator(5); mary.getVacationDays(); 7474 getVacationDays getSeniorityBonus mary = new Administrator(5); mary.getVacationDays(); Angestellte Administrator getVacationDays getSeniorityBonus 76 peter = new FaGe(7); peter.getVacationDays(); 7777 FaGe getVacationDays getSeniorityBonus getSeniorityBonus Angestellte getVacationDays getSeniorityBonus peter = new FaGe(7); peter.getVacationDays(); § Mit dieser Organisation verbleibt die Logik der Methode getVacationDays in der Klasse Angestellte § Anpassungen können durch überschreiben der Methoden, die getVacationDays aufruft, implementiert werden § (Natürlich können wir auch die Methode selber überschreiben aber dann müssen wir evtl. mehr Code in den Subclasses übernehmen) 82 Sichtbarkeit (von Attributen), nochmal § Die Methode getSalary liefert das Gehalt. § Die Methode liefert für alle Exemplare jeder Subclass den selben Wert § Was wenn wir individuelle Gehälter für Arzt und FaGe wollen? § Wie müssten die Klassen verändert werden? 83 Sichtbarkeit (von Attributen), nochmal § Die Methode getSalary liefert das Gehalt. § Die Methode liefert für alle Exemplare jeder Subclass den selben Wert § Was wenn wir individuelle Gehälter für Arzt und FaGe wollen? § Wie müssten die Klassen verändert werden? § Was für eine Sichtbarkeit sollte das neue Attribut haben? 84 Geschützte Attribute public class Angestellte { private int years; private double salary; public Angestellte (int y, double s) { years = y; salary = s; } } public class Arzt extends Angestellte { … public void setSalary(double s) { salary = s; } 85 § Methode setSalary soll nicht in Angestellte sein § Z.B. weil sie Attribute von FaGe oder Arzt verwenden soll § Dieses Programm kann aber nicht übersetzt werden: public class Arzt extends Angestellte { … public void setSalary(double s) { salary = s; } Arzt.java:29: salary has private access in Angestellte salary = s; ^ § Keyword private verhindert Zugriff in der Subclass 86 protected Attribute 87 Ein Attribut auf das nur innerhalb der Klasse und ihrer Subclasses zugegriffen werden kann § Syntax: protected type name; § Beispiele: protected int id; protected String name; protected Attribute public class Angestellte { private int years; protected double salary; public Angestellte (int y, double s) { years = y; salary = s; } } public class Arzt extends Angestellte { … public void setSalary(double s) { salary = s; } 88 public class Arzt extends Angestellte { … public void setSalary(double s) { salary = s; //getSalary() no longer overridden } 90 Arzt Klasse Methode getSalary() braucht keine Gruppen-spezifischen Anpassungen mehr vornehmen und braucht daher nur in der Klasse Angestelle sein – es gibt keinen Grund die Methode in der Subclass zu überschreiben Anderes Design § Es gibt viele andere Klassen Entwürfe § Eine neue Subklasse MedAng … § Dort Attribut salary und die Methode setSalary § Arzt und FaGe erweitern MedAng § Noch eine Hierarchie Stufe § protected erlaubt allen Subklassen Zugriff § Hier auch Administrator § Sinnvoll wenn Subklassen Zugriff brauchen, andere Klassen aber nicht 94 Sichtbarkeit und Packages § Ziel ist Abkapselung von Namensräumen. Sichtbarkeit § private: nur in dieser Klasse § default (! ): nur in Package § protected: § in dieser Klasse § in allen Erweiterungen (Subclasses, Unterklassen) der Klasse § in allen anderen Klassen die in dieser Package deklariert sind § public: überall (nach import) § protected lässt viel zu ... Subclass evtl. in anderer Package 95 protected – Das ganz Kleingedruckte [Sichtbar] nur in der Klasse und ihren Subclassen auch dann wenn die Subclass in einer anderen Package ist § Exemplare der Subclass S erben protected Attribut p von T auch wenn S in einer anderen Package ist § Eine Subklasse Methode m (für Exemplare von S) kann auf das geerbte Attribut m ihres Exemplars zugreifen § Auf geerbte Attribute anderer Exemplare eT der Superklasse T kann m nur zugreifen wenn eT ein Exemplar der Klasse S ist § Obwohl eT auch das Attribut p besitzt 96 T protected p S m() { … p …} 97 protected – Das ganz Kleingedruckte package package2; public class T { protected int i = 1; public T() { i = 1; } } package package2a; import package2.T; public class S extends T { public S() { super(); } public String v(T aT) { return \">\" + aT.i + \"<\"; } } error: i has protected access in T return \">\" + aT.i + \"<\"; ^ 98 protected – Das ganz Kleingedruckte package package2; public class T { protected int i = 1; public T() { i = 1; } } package package2a; import package2.T; public class S extends T { public S() { super(); } public String v(S anS) { return \">\" + anS.i + \"<\"; } } Erlaubt da in v anS sicher auf Exemplar der Klasse S verweist § Das Kleingedruckte werden Sie vielleicht in der Praxis erleben -- nicht in dieser Vorlesung § Problem vermeiden indem Superklasse und Subklasse in selber Package sind § Wir erwarten auch nicht das Verständnis der Regeln für Packages – ausser § Sie kennen die Default Package (mit der wir arbeiten) § Sie wissen was die Default Sichtbarkeit ist § Sie wissen das protected Zugriff in allen Subklassen und in der selben Package erlaubt 99 protected – Das ganz Kleingedruckte Klasse Angestellte public class Angestellte { private int years; protected double salary = 90000.0; public Angestellte() { this(0); } public Angestellte(int y){ years = y; } public Angestellte(int y, double s){ year = y; salary = s; } public int getVacationDays() { return 20 + getSeniorityBonus(); } public int getSeniorityBonus() { return 2 * years; } public int getHours() { return 42; } public int getYears() { return years; } public double getSalary() { return salary; } public String getVacationForm(){ return \"green\"; } } // Angestellte 100 v6 Arzt Klasse public class Arzt extends Angestellte { public Arzt(int years) { super(years); } @Override public int getVacationDays() { return super.getVacationDays() + 5; } @Override public String getVacationForm() {... } public void setSalary(double s) { salary = s; } public void treatPatient() { System.out.println(\"I'll take care of you!\"); } 101 v6FaGe Klasse public class FaGe extends Angestellte { public FaGe() { super(0); } public FaGe(int years) { super(years); } public void setSalary(double s) { salary = s; } @Override public int getSeniorityBonus() { return 0; } public void workAtStation(int station) { … } } //FaGe 102 v6 Administrator und OPFachkraft Klassen public class Administrator extends Angestellte { public Administrator(int years) { super(years); salary = super.getSalary()+5000.0; } public void processBill() { ... } } public class OPFachkraft extends FaGe { public OPFachkraft(int years) { super(years); salary = super.getSalary() + 10000.0; } public void manageOP() {... } } 103 v6 v6 Typen § Klassen definieren einen (neuen) Typ public class Angestellte {} public class Arzt extends Angestellte {} … § Verweise auf Exemplare § Referenzvariable speichern Referenzen auf Exemplare (eines Typs) Arzt peter = new Arzt(0); Arzt vertreter = peter; // peter auch Referenz à Arzt Arzt mary = new Arzt(10); // 10 years of service vertreter = mary; 104 Typen § Klassen definieren einen (neuen) Typ public class Angestellte {} public class Arzt extends Angestellte {} … § Verweise auf Exemplare § Referenzvariable speichern Referenzen auf Exemplare (eines Typs) Arzt peter = new Arzt(0); Arzt vertreter = peter; // peter auch Referenz à Arzt Arzt mary = new Arzt(10); // 10 years of service vertreter = mary; 105 Klassen und Referenzvariable § Was wenn wir Verweise auf alle Angestellten speichern wollen? § z.B. in einem Array staff § z.B. in der Reihenfolge der Anstellung § Wir wissen aber nicht ob wir als erste (oder nächste) Person § eine/n Arzt/Ärztin § eine/n FaGe § eine/n Administrator/in anstellen. Unser Array staff muss Verweise auf alle Arten von Angestellten aufnehmen können! 106 Ist-ein § Die ist-ein Beziehung definiert die Inheritance Hierarchy. § Ein Arzt Exemplar ist auch ein Angestellte Exemplar 107 § Wir können ein Arzt Exemplar überall verwenden, wo wir ein Angestellte Exemplar verwenden können. 108 Ist-ein § Eine Referenzvariable für Angestellte kann Verweise auf {Arzt, FaGe, OPFachkraft, Administrator} Exemplare enthalten. Angestellte jane; jane = new Arzt(); jane.getSalary(); jane = new OPFachkraft(); jane.getSalary(); § Die Umkehrung gilt nicht! 111 Ist-ein § Eine Referenzvariable für Angestellte kann Verweise auf { Arzt, FaGe, OPFachkraft, Administrator } Exemplare enthalten. § Die Umkehrung gilt nicht! FaGe john; john = new Angestellte(); john.worksAtStation(); //nicht möglich! 112 Ist-ein § Eine Referenzvariable für Angestellte kann Verweise auf { Arzt, FaGe, OPFachkraft, Administrator } Exemplare enthalten. § Brauchen einen Array von Verweisen auf Angestellte wenn wir mit Exemplaren von { Arzt, …, Administrator} arbeiten wollen Angestellte[] staff = new Angestellte [5]; staff[0] = new Administrator(); staff[1] = new OPFachkraft(); staff[2] = new Arzt(); staff[3] = new Angestellte(); staff[1] = new Arzt(); // auch möglich 113114 0 1 2 3 4 null 115 0 1 2 3 4 null staff[1] = new Arzt(); Ist-ein § Wir können ein Arzt Exemplar verwenden wo ein Angestellte Exemplar erwartet wird (Arzt ist-ein Angestellte Exemplar) aber nicht umgekehrt. § Wenn ein Arzt Exemplar gebraucht wird genügt nicht ein Exemplar der Klasse Angestellte § … könnte nicht treatPatient() ausführen 117 § Was wenn wir mit Exemplaren irgendeiner Klasse arbeiten wollen? Übersicht 7.1 Einleitung 7.2 Neue Klassen aus existierenden Klassen 7.3 Vererbung und Konstruktoren 7.4 Selektiv Verhalten (von Objekten) festlegen 7.5 Klasse Object 7.6 Polymorphismus Copyright (c) Pearson 2013 and Thomas Gross 2016, 2021. All rights reserved. 118 7.5 Die Klasse Object 119 Vererbungshierarchie § Es gibt eine (besondere) Klasse Object die Urahn aller Klassen ist § Object hat keine Superclass § Alle Klassen sind (direkte oder indirekte) Subclasses von Object § Jede Klasse erweitert Object § … oder eine Subclass von Object § class X {} heisst class X extends Object {} 120 Vererbungshierarchie 121 Angestellte Arzt/Ärztin FaGe (Pflege) Adminstrator/in OPFachkraft Object Sub erbt von Super Super Sub Vererbungshierarchie 122 Angestellte Arzt/Ärztin FaGe (Pflege) Adminstrator/in OPFachkraft Object Sub erweitert Super Super Sub Vererbungshierarchie § Es gibt eine (besondere) Klasse Object die Urahn aller Klassen ist § Object hat keine Superclass § Alle Klassen sind (direkte oder indirekte) Subclasses von Object § Jede Klasse erweitert Object § … oder eine Subclass von Object § class X {} heisst class X extends Object {} § Eine Referenzvariable für Object Exemplare kann auf Exemplare jeder Klasse verweisen 124 Die Klasse Object § Alle Typen, die durch eine Klasse definiert sind, haben eine Superclass namens Object. § Jede Klasse erweitert implizit Object 125 Object Die Klasse Object § Die Object Klasse definiert Methoden: § public String toString() Liefert eine Darstellung als Text so dass das Objekt ausgegeben werden kann. § public boolean equals(Object other) Vergleiche den impliziten Parameter mit other und liefere true wenn gleich. § Alle Typen, die durch eine Klasse definiert sind, haben eine Superclass namens Object. § Jede Klasse erweitert implizit Object Object equals toString getClass hashCode notify wait 126 Erweiterungen von Object erben § Wenn eine Klasse Object erweitert dann erbt der neue Typ das Verhalten (die Methoden) von Object § Nicht immer machen diese Methoden was wir wollen … § Später mehr dazu § … aber Name, Returntype, Sichtbarkeit und Parameterliste sind (vor)definiert Object equals toString getClass hashCode notify wait Point distance getX getY translate 127 Point Klasse public class Point { private int x; private int y; public Point() { … } public Point(int x) { … } public Point(int x, int y) { … } public double distance(Point o) { } public int getX() { … } public int getY() { … } … 128 … hat auch Methoden equals toString getClass hashCode … und einige mehr von Object Erweiterungen von Object erben § Wenn eine Klasse Object erweitert dann erbt der neue Typ das Verhalten (die Methoden) von Object § Nicht immer machen diese Methoden was wir wollen … § Später mehr dazu § … aber Name, Returntype, Sichtbarkeit und Parameterliste sind (vor)definiert Object equals toString getClass hashCode notify wait Point distance getX getY translate 129 Erweiterungen von Object erben § Wenn eine Klasse Object erweitert dann erbt der neue Typ das Verhalten (die Methoden) von Object § Nicht immer machen diese Methoden was wir wollen … § Später mehr dazu § … aber Name, Returntype, Sichtbarkeit und Parameterliste sind (vor)definiert Object equals toString getClass hashCode notify wait Angestellte getVacationDays getHours getVacationForm getSalary 130 Object Referenzvariable § In einer Referenzvariable für Object kann man Verweise auf Exemplare jeder Klasse speichern: Object o1 = new Point(5, -3); Object o2 = \"hello there\"; Object o3 = new Scanner(System.in); § Das Verhalten eines Object Exemplars umfasst nur wenige Methoden. String s = o1.toString(); // ok int len = o2.length(); // error String line = o3.nextLine(); // error 131 Object Referenzvariable § Mit einer Referenzvariable für Object kann man nur die Methoden ausführen die für Object definiert sind String s = o1.toString(); // ok int len = o2.length(); // error String line = o3.nextLine(); // error § Die in einer Subclass definierten Methoden und Attribute existieren aber die Referenzvariable erlaubt keinen Zugriff 132 Object Referenzvariable § Methoden können Parameter vom Typ Object akzeptieren. public void checkForNull(Object o) { if (o == null) { System.out.println(\"Object is null!!!\"); } } 134 Wir erinnern uns: Vergleichen von Objekten Der == Operator funktioniert nicht wie gewünscht mit Objekten. == vergleicht Referenzen auf Objekte, nicht den Zustand. Das Ergebnis ist nur dann true wenn ein Objekt mit sich selbst verglichen wird. Point p1 = new Point(5, 3); Point p2 = new Point(5, 3); if (p1 == p2) { // false System.out.println(\"equal\"); } ... x 5 y 3p1 p2 ... x 5 y 3 135 § Der Vergleichsoperator == funktioniert nicht wie erwartet für Objekte. Scanner console = new Scanner(System.in); System.out.print(\"Wie heissen Sie? \"); String name = console.next(); if (name == \"Hase\") { System.out.println(\"Wissen Sie mehr? \"); ... } § Dieses Programm wird übersetzt aber der Test ergibt nie true. § == vergleicht Objektverweise («references») (später) und liefert daher evtl. false selbst wenn zwei Strings die gleichen Buchstaben haben. [früher] Vergleiche von String Objekten[früher] Vergleiche von String Objekten § Um String Objekte zu vergleichen benutzen wir equals if (name.equals(\"Hase\")) { System.out.println(\"Wissen Sie mehr? \"); } equals vergleicht den Zustand von Objekten [jetzt] § Methode equals ist in der Klasse Object definiert § Wieso kann diese Methode den Zustand der Strings vergleichen? 138 Die Methode equals § Version von equals wie in der Klasse Object definiert kann nicht den Zustand von Objekten vergleichen § Wenn wir eine Klasse erstellen, dann verhält sich (die geerbte Methode) equals wie == Point p1 = new Point(5,3); Point p2 = new Point(5,3); if (p1.equals(p2)) { // false :-( System.out.println(\"equal\"); } 140 ... x 5 y 3p1 p2 ... x 5 y 3 Vergleichen von Objekten § Wenn wir eine Klasse erstellen, dann verhält sich (die geerbte Methode) equals wie == Point p1 = new Point(5,3); Point p2 = new Point(5,3); if (p1.equals(p2)) { // false :-( System.out.println(\"equal\"); } § Denn diese Version hat die Klasse von Object geerbt. § Java versteht nicht wie Point Exemplare verglichen werden sollen. 141 == Vergleich von Referenzen Wann könnte es Sinn machen, die Referenzen (Adressen) zu vergleichen? 142143 § Good News: Wir können das geerbte Verhalten ändern indem die Klasse eine Methode equals definiert. § Neue Methode überschreibt das von Object geerbte Verhalten. § Diese Methode sollte den Zustand der zwei Objekte vergleichen und true zurückgeben wenn sie die selben x/y Koordinaten haben. Eine fehlerhafte Lösung: public boolean equals(Point other) { if (x == other.x && y == other.y) { return true; } else { return false; } } 147 In Klasse Point Guter Ansatz, aber wollen anderes equals § Good News: Wir können das geerbte Verhalten ändern indem die Klasse eine Methode equals definiert. § Neue Methode überschreibt das von Object geerbte Verhalten. § Diese Methode sollte den Zustand der zwei Objekte vergleichen und true zurückgeben wenn sie die selben x/y Koordinaten haben. Eine fehlerhafte Lösung: public boolean equals(Point other) { if (x == other.x && y == other.y) { return true; } else { return false; } } 148 In Klasse Point Guter Ansatz, aber wollen anderes equals § Good News: Wir können das geerbte Verhalten ändern indem die Klasse eine Methode equals definiert. § Neue Methode überschreibt das von Object geerbte Verhalten. § Diese Methode sollte den Zustand der zwei Objekte vergleichen und true zurückgeben wenn sie die selben x/y Koordinaten haben. § Eine fehlerhafte Lösung: public boolean equals(Point other) { if (x == other.x && y == other.y) { return true; } else { return false; } } 149 In Klasse Point § Können wir diese Methode besser schreiben? 150 § Können wir diese Methode besser schreiben? public boolean equals(Point other) { return (x == other.x && y == other.y); } § Eleganter -- aber immer noch nicht ganz richtig! 151 In Klasse Point Probleme mit dieser Methode § Es muss legal sein ein Point Objekt mit irgendeinem Objekt zu vergleichen (nicht nur mit Exemplaren von Point): // this should be allowed Point p = new Point(7, 2); if (p.equals(\"hello\")) { // false ... § equals sollte immer false zurückgeben wenn das Argument kein Point ist. 153 equals muss beliebige Referenzen akzeptieren public boolean equals(?????????) { statement(s) that return a boolean value ; } 155 equals und Object public boolean equals(Object name) { statement(s) that return a boolean value ; } Der Parameter zu equals muss vom Typ Object sein Genauer: Referenz (Verweis) auf Objekt Nur so kann equals in Object überschrieben werden Mit einem Object Parameter kann jedes Objekt übergeben werden 156 equals und Object public boolean equals(Object name) { statement(s) that return a boolean value ; } Der Parameter zu equals muss vom Typ Object sein Genauer: Referenz (Verweis) auf Objekt Nur so kann equals in Object überschrieben werden Mit einem Object Parameter kann jedes Objekt übergeben werden Aber: Wenn wir aber den (genauen) Typ nicht kennen, wie können wir den Parameter vergleichen? 157 Eine weitere Lösung mit Problemen § Hier ist eine weitere Implementation von equals: public boolean equals(Object obj) { return x == obj.x && y == obj.y; } § Der Compiler beschwert sich: Point.java:36: cannot find symbol symbol : variable x location: class java.lang.Object return x == obj.x && y == obj.y; ^ ^ 158 Eine weitere Lösung mit Problemen § Hier ist eine weitere Implementation von equals: public boolean equals(Object obj) { return x == obj.x && y == obj.y; } § Der Compiler beschwert sich: Point.java:36: cannot find symbol symbol : variable x location: class java.lang.Object return x == obj.x && y == obj.y; ^ ^ D.h.: «obj könnte irgendein Objekt sein. Nicht jedes Objekt hat ein x Attribut.» 159 «Casts» (Umwandlungen) für Objekte § Lösung: Umwandlung («cast») der Referenz auf ein Object in eine Referenz auf einen Point public boolean equals(Object obj) { Point other = (Point) obj; return x == other.x && y == other.y; } § Das Programm verwandelt zur Laufzeit die Referenz in obj (kann eine Referenz auf irgendein Object Exemplar sein) in eine Referenz auf ein Point Exemplar. 161 «Casts» (Umwandlungen) für Objekte § Genauer: eine Umwandlung eines Referenztypes (Typ1) ReferenzVariableVomTyp2 Beispiel: (Point) obj § Wird oft in einer Referenzvariable (für Typ1) gespeichert Beispiel: Point p = (Point) obj; § Zur Unterscheidung von Umwandlungen der Basistypen («cast») sprechen wir [manchmal] von einer Typumwandlung («type cast») 162 «Casts» (Umwandlungen) für Objekte Point other = (Point) obj; § Für other sind die Attribute eines Point definiert § other.x wird vom Compiler akzeptiert § Umwandlungen («type casts») für Objekte unterscheiden sich von Umwandlungen eines Basistyps § Wir ändern eine Object Referenz in eine Point Referenz. § Dies ändert nicht das Objekt. § Eigentlich sagen wir nur dem Compiler das er annehmen kann dass obj auf ein Point Objekt verweist. 164 Cast mit der Lupe § Client code: Point p1 = new Point(5, 3); Point p2 = new Point(5, 3); if (p1.equals(p2)) { System.out.println(\"equal\"); } x 5 y 3 p1 p2 ... x 5 y 3 165 Cast mit der Lupe § Client code: Point p1 = new Point(5, 3); Point p2 = new Point(5, 3); if (p1.equals(p2)) { System.out.println(\"equal\"); } public boolean equals(Object obj) { Point other = (Point) obj; return x == other.x && y == other.y; } x 5 y 3 p1 p2 ... x 5 y 3 166 obj Cast mit der Lupe § Client code: Point p1 = new Point(5, 3); Point p2 = new Point(5, 3); if (p1.equals(p2)) { System.out.println(\"equal\"); } public boolean equals(Object obj) { Point other = (Point) obj; return x == other.x && y == other.y; } x 5 y 3 p1 p2 ... x 5 y 3 obj other Nur die Attribute/ Methoden von Object sind bekannt 170 Cast mit der Lupe § Client code: Point p1 = new Point(5, 3); Point p2 = new Point(5, 3); if (p1.equals(p2)) { System.out.println(\"equal\"); } public boolean equals(Object obj) { Point other = (Point) obj; return x == other.x && y == other.y; } x 5 y 3 p1 p2 ... x 5 y 3 other Auch die Attribute/ Methoden von Point sind bekannt 171 obj Haben wir alles bedacht? § Diese Version überschreibt Object.equals(Object): @Override public boolean equals(Object obj) { Point other = (Point) obj; return x == other.x && y == other.y; } § Was passiert wenn obj auf irgendein Exemplar (nicht Point Exemplar) verweist? § Return sollte false sein (ist sicher nicht gleich) 173 Unterschiedliche Typen vergleichen Point p = new Point(7, 2); if (p.equals(\"hello\")) { // should be false ... } § Ohne weitere Änderungen gibt es eine Exception zur Laufzeit: Exception in thread \"main\" java.lang.ClassCastException: java.lang.String at Point.equals(Point.java:25) at PointMain.main(PointMain.java:25) § Das Problem ist die Cast Anweisung public boolean equals(Object obj) { Point other = (Point) obj; 174 Casts – es geht nicht alles § Wenn ein Programm eine Umwandlung eines Referenztyps enthält, dann prüft das Laufzeit System ob das Objekt (auf das verwiesen wird) wirklich diesen Typ hat Point p = new Point(); Object o = p; String s = \"hello\"; Point q = (Point) o; Point r = (Point) s; // not allowed -- Exception § Wir müssen sicher sein (oder prüfen) dass eine Umwandlung problemlos möglich ist. 175 Der instanceof Operator if (name instanceof type) { statement(s); } expression result s instanceof Point false s instanceof String true p instanceof Point true p instanceof String false p instanceof Object true s instanceof Object true null instanceof String false null instanceof Object false • Prüft ob eine Variable auf ein Object dieses Typs verweist. § Ergibt boolean Resultat. String s = \"hello\"; Point p = new Point(); 179 Verbesserte equals Methode (endlich) // Returns whether obj refers to a Point object with // the same (x, y) coordinates as this Point. public boolean equals(Object obj) { if (obj instanceof Point) { // obj is a Point; cast and compare it Point other = (Point) obj; return (x == other.x) && (y == other.y); } else { // obj is not a Point; cannot be equal return false; } } 180 Bemerkung: toString() § Jetzt verstehen wir warum wir eine Methode toString() definieren konnten § … und mussten wenn wir Informationen über ein Person Objekt drucken wollten § toString() ist in Objekt definiert § Default Rückgabe ist Adresse + Typ § Können eigene Version durch Überschreiben erschaffen 181 Bemerkung: toString() § Jetzt verstehen wir warum wir eine Methode toString() definieren konnten § … und mussten wenn wir Informationen über ein Person Objekt drucken wollten § toString() ist in Objekt definiert § Default Rückgabe ist Adresse + Typ § Können eigene Version durch Überschreiben erschaffen § Muss Methode aus Object überschreiben und Sichtbarkeit public haben 182 Bemerkung: toString() public class Person { @Override public String toString() { return name + \" (#\"+id+\") ist \" + Arrays.toString(hours) + \" \" + Arrays.toString(overtime); } ... § Annnotation @Override hier sinnvoll § Verhindert Fehler wegen eines Schreibfehlers public class Person { public String tostring() { return name + ... } 183 Vererbungshierarchie im Einsatz § Programmausführung kann zu ungeplantem Ereignis führen § Überraschung (surprise) § Java System entdeckt Ereignis und generiert eine Exception § \"Exception wird geworfen\" – und irgendwo behandelt § Ursache ist (mindestens) ein Fehler im Programm § Beispiele § ArrayIndexOutOfBoundsException bei versuchtem Zugriff auf nicht existierendes Array Element § ArithmeticException, NullPointerException 184 Vererbungshierarchie im Einsatz § Es gibt eine Vererbungs- hierarchie für Exceptions § RuntimeException ist die Superclass für viele Exceptions 185 NullPointer Exception Arithmetic Exception Runtime Exception 186 Vererbungshierarchie im Einsatz § Es gibt eine Vererbungs- hierarchie für Exceptions § RuntimeException ist die Superclass für viele Exceptions § Ebenen für weitere Spezialisierungen 187 NullPointer Exception Arithmetic Exception Runtime Exception IndexOutOfBounds Exception ArrayIndexOutOf BoundsException Vererbungshierarchie im Einsatz § RuntimeException ist Subclass von Exceptions § Mit vielen anderen Subclasses 188 NullPointer Exception Arithmetic Exception Runtime Exception IndexOutOfBounds Exception ArrayIndexOutOf BoundsException Exception IOException FileN Vererbungshierarchie Aus \"Java in a Nutshell\" 7th Edition B Evans, D Flanagan Dec 2018 O'Reilly Media, Inc. 189 Vererbungshierarchie im Einsatz § RuntimeException ist Subclass von Exceptions § Mit vielen anderen Subclasses § Exceptions lassen (manchmal) Korrekturen zu 190 NullPointer Exception Arithmetic Exception Runtime Exception IndexOutOfBounds Exception ArrayIndexOutOf BoundsException Exception IOException FileN Vererbungshierarchie im Einsatz § Wenn das Java System Probleme hat, dann ist das ein Fehler (Error) § Status festhalten § Geordneter Shutdown 191 NullPointer Exception Arithmetic Exception Runtime Exception IndexOutOfBounds Exception ArrayIndexOutOf BoundsException Exception IOException FileN Vererbungshierarchie im Einsatz § Klasse Error mit Subklassen 192 NullPointer Exception Arithmetic Exception Runtime Exception IndexOutOfBounds Exception ArrayIndexOutOf BoundsException Exception IOException FileN Error IOError VirtualMachine Error StackOverflow Error OutOfMemory Error Vererbungshierarchie im Einsatz § Error und Exception haben direkte Superclass: Throwable 193 NullPointer Exception Arithmetic Exception Runtime Exception IndexOutOfBounds Exception ArrayIndexOutOf BoundsException Exception IOException FileN Error IOError VirtualMachine Error StackOverflow Error OutOfMemory Error Throwable Vererbungshierarchie im Einsatz 194 NullPointer Exception Arithmetic Exception Runtime Exception IndexOutOfBounds Exception ArrayIndexOutOf BoundsException Exception IOException FileN Error IOError VirtualMachine Error StackOverflow Error OutOfMemory Error Throwable Object Errors und Exceptions § Manche unerwünschten Ereignisse mussten dem Compiler angekündigt werden § Beispiel: … throws FileNotFoundException für Methode § «Unchecked Exceptions» – immer erwartet und daher nicht vom Compiler registriert § RuntimeException – und alle Subclasses § Error – und alle Subclasses § «Checked Exceptions» – muss (dem Compiler) angekündigt werden § Throwable – und alle Subclasses bis auf Error § Exception – und alle Subclasses bis auf RuntimeException 195 Vererbungshierarchie im Einsatz 196 NullPointer Exception Arithmetic Exception Runtime Exception IndexOutOfBounds Exception ArrayIndexOutOf BoundsException Exception IOException FileN Error IOError VirtualMachine Error StackOverflow Error OutOfMemory Error Throwable Object Unchecked Checked 252-0027 Einführung in die Programmierung 7.0 Vererbung Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016-2021 All rights reserved. 252-0027 Einführung in die Programmierung 7.0 Vererbung Keine \"EProg\" Vorlesung am 22. Nov. Statt dessen \"Algorithmen und Datenstrukturen\" ML D28/E12/LiveStream (Nächste Folien Kopie aus früherer Vorlesung, hier nur damit Sie lokal nachschlagen können) 3 Klasse Angestellte public class Angestellte { private int years; protected double salary = 90000.0; public Angestellte() { this(0); } public Angestellte(int y){ years = y; } public Angestellte(int y, double s){ year = y; salary = s; } public int getVacationDays() { return 20 + getSeniorityBonus(); } public int getSeniorityBonus() { return 2 * years; } public int getHours() { return 42; } public int getYears() { return years; } public double getSalary() { return salary; } public String getVacationForm(){ return \"green\"; } } // Angestellte 4 v6 Arzt Klasse public class Arzt extends Angestellte { public Arzt(int years) { super(years); } @Override public int getVacationDays() { return super.getVacationDays() + 5; } @Override public String getVacationForm() {... } public void setSalary(double s) { salary = s; } public void treatPatient() { System.out.println(\"I'll take care of you!\"); } 5 v6FaGe Klasse public class FaGe extends Angestellte { public FaGe() { super(0); } public FaGe(int years) { super(years); } public void setSalary(double s) { salary = s; } @Override public int getSeniorityBonus() { return 0; } public void workAtStation(int station) { … } } //FaGe 6 v6 Administrator und OPFachkraft Klassen public class Administrator extends Angestellte { public Administrator(int years) { super(years); salary = super.getSalary()+5000.0; } public void processBill() { ... } } public class OPFachkraft extends FaGe { public OPFachkraft(int years) { super(years); salary = super.getSalary() + 10000.0; } public void manageOP() {... } } 7 v6 v6 Vererbungshierarchie 8 Angestellte Arzt/Ärztin FaGe (Pflege) Adminstrator/in OPFachkraft Object Übersicht 7.1 Einleitung 7.2 Neue Klassen aus existierenden Klassen 7.3 Vererbung und Konstruktoren 7.4 Selektiv Verhalten (von Objekten) festlegen 7.5 Klasse Object 7.6 Polymorphismus Copyright (c) Pearson 2013 and Thomas Gross 2016, 2019. All rights reserved. 9 Polymorphismus § Poly – viele § Morphe – Gestalt, Form, Aussehen [Duden] § griechisch morphḗ = Gestalt, Form 10 Polymorphismus (griechisch für Vielgestaltigkeit) Bedeutung: das Vielgestaltigsein Ihre Suche im Wörterbuch nach Vielgestaltigsein ergab folgende Treffer: Polymorphismus § Polymorphismus: Ein Programm ist so entwickelt dass es für unterschiedliche Objekttypen verwendet werden kann und sein Verhalten an diese Typen anpasst. § System.out.println kann Objekte jeden Typs ausgeben. § Jeder Typ wird auf seine Art auf der Konsole ausgegeben. § Scanner() erlaubt uns einen Scanner für Files, Konsole (und andere Quellen) zu konstruieren. 11 Programmieren mit und für Polymorphismus § Zwei Aspekte: § Sichtbarkeit – welche Attribute und Methoden sind «sichtbar»? § D.h. können gelesen und modifiziert werden § Bindung – wenn es mehr als ein Attribut/eine Methode mit diesem Namen gibt, welche/s ist involviert? § Nicht sichtbar: Bindung kein Thema § Einschränkungen: § Kein Verstecken (Shadowing) von Attributen (fürs erste) § D.h. evtl. gibt es mehrere Versionen einer Methode aber immer nur ein Attribut 14 Kontext § Um über Sichtbarkeit und Bindung reden zu können brauchen wir § Eine Referenzvariable (eines Typs) § Eine (Methoden-lokale) Variable § Ein Parameter § Ein Attribut § Ein Objekt(examplar) einer Klasse (eines Typs) § Referenzvariable bezieht sich/verweist auf Objekt(exemplar) § Keine null-Referenz 17 Kontext § Die Regeln für Sichtbarkeit und Bindung sollen es erlauben, abgekapselte («encapsulated») Klassen zu entwickeln § Klienten können den Zustand nur kontrolliert verändern/lesen § Klassen können separat (weiter) entwickelt werden § Klassen erfüllen einen Vertrag («contract») mit Invarianten und Services § Dafür dürfen sie auch Erwartungen festlegen § Klienten müssen Erwartungen erfüllen, können mit Vertragserfüllung rechnen § Diese Regeln gelten auch für Subklassen 18 Programmieren mit und für Polymorphismus § Eine Referenzvariable für den Typ T : 19 T Referenz auf …. …. Typ des Exemplars auf das verwiesen werden kann Programmieren mit und für Polymorphismus § Eine Referenzvariable für den Typ T kann eine Referenz auf BLANK ein Objekt der Klasse T enthalten oder einer Subclass von T enthalten Angestellte leiterin = new Angestellte(); 20 T T Klasse T – steht für ein Exemplar auf das verwiesen wird Programmieren mit und für Polymorphismus § Eine Referenzvariable für den Typ T kann eine Referenz auf BLANK ein Objekt der Klasse T enthaltenoder einer Subclass von T enthalten Angestellte leiterin = new Angestellte(); § Damit kann man auf die Attribute von T zugreifen und die Methoden in T aufrufen (soweit erlaubt, d.h. sichtbar): leiterin.getYears(); // public method leiterin.getSalary(); // public method … = this.years; // private attribute, only in A method … = years; // private attribute, only in A method … = salary; // protected attribute, in A and subclasses of A 21 T T 23 Kontrolle der Sichtbarkeit durch die Klasse § Vier Optionen für die Sichtbarkeit von Attributen und Methoden § überall – Keyword public § in der Klasse, in ihren Subclassen, in der Package – Keyword protected § auch dann wenn die Subclasse in einer anderen Package ist § in der Klasse, in der Package – das ist der Default, kein Keyword § nur in der Klasse – Keyword private § Was nicht sichtbar ist kann nicht aufgerufen, gelesen, oder modifiziert werden 26 Programmieren mit und für Polymorphismus § Eine Referenzvariable für den Typ T kann eine Referenz auf BLANK ein Objekt der Klasse T oder einer Subclass S von T enthalten Angestellte leiterin = new Arzt(1); § Nur Methoden der Klasse Angestellte können für das BLANK Objekt, auf das leiterin verweist, aufgerufen werden. leiterin.getVacationForm(); leiterin.getVacationDays(); leiterin.treatPatients(); // not in Angestellte 34 T S T Programmieren mit und für Polymorphismus § Eine Referenzvariable für den Typ T kann eine Referenz auf BLANK ein Objekt der Klasse T oder einer Subclass S von T enthalten Angestellte leiterin = new Arzt(1); § Nur Methoden der Klasse Angestellte können für das BLANK Objekt, auf das leiterin verweist, aufgerufen werden. § Wenn eine Methode für leiterin aufgerufen wird dann wird die Variante der Klasse Arzt ausgeführt – dynamische Bindung! leiterin.getVacationForm(); // yellow leiterin.getVacationDays(); // 27 35 T S T Bindung § Der Typ des Objektes für das eine Methode aufgerufen wird bestimmt die Version der Methode – dynamische Bindung! 36 Vererbungshierarchie 37 Angestellte leiterin = new Arzt(1); System.out.println(leiterin.getVacationDays()); Angestellte Arzt/Aerztin FaGe (Pflege) Adminstrator/in OPFachkraft Object Arzt years: 1 salary: 95000.00 Vererbungshierarchie 38 Angestellte leiterin = new Arzt(1); System.out.println(leiterin.getVacationDays()); Angestellte Arzt/Aerztin FaGe (Pflege) Adminstrator/in OPFachkraft Object public int getVacationDays() { return super.getVacationDays()+5; } public int getVacationDays() { return 20 + getSeniorityBonus(); } 2 * 1 public int getSeniorityBonus() { return 2 * years; } 2 22 27 22 Arzt years: 1 salary: 95000.00 Vererbungshierarchie 39 Angestellte springer = new FaGe(7); System.out.println(springer.getVacationDays()); Angestellte Arzt/Aerztin FaGe (Pflege) Adminstrator/in OPFachkraft Object FaGe years: 7 salary: 90000.00 public int getVacationDays() { return 20 + getSeniorityBonus(); } public int getSeniorityBonus() { return 0; } 0 20 20 Bindung § Der Typ des Objektes für das eine Methode aufgerufen wird bestimmt die Version der Methode – dynamische Bindung! § Es spielt keine Rolle ob die Methode in einer Superclass definiert ist («upcall») oder einer Subclass («downcall»). 40 class T { void s0(){ m(); } void m(){…} } class S extends T { void s1() { m(); } void s2() { p(); } void p() {…} } class R extends S { void p() {…} } T aT = new T(); aT.s0(); aT = new S(); aT.s1(); aT.s2(); aT = new R(); aT.s1(); aT.s2(); void s1(){} void s2(){}By request: mit @Override 41 class T { void s0(){ m(); } void m(){…} } class R extends S { @Override void p() {…} } void s1(){} void s2(){} class S extends T { @Override void s1() { m(); } @Override void s2() { p(); } void p() {…} } Sichtbarkeit und Bindung 42 class T { void s0(){ m(); } private void m(){…} } class S extends T { void s1() { m(); //Error } void s2() { p(); } void p() {…} } class R extends S { void p() {…} } void s1(){} void s2(){} error: cannot find symbol m(); ^ symbol: method m() location: class S class S extends T { void s1() { m(); } void s2() { p(); } void p() {…} } Methode m() ist nicht definiert (für S) wenn m() in T Sichtbarkeit private hat. Sichtbarkeit Bindung 43 class T { void s0(){ m(); } void m(){…} } class S extends T { void s1() { m(); } void s2() { p(); } void p() {…} } class R extends S { private void p() {…} } void s1(){} void s2(){} error: p() in R cannot override p() in S private void p() {} ^ attempting to assign weaker access privileges; was package Wenn Methode m() in der Subclass X Methode m() aus der Superclass Base überschreibt, dann darf die Sichtbarkeit von m() in X nicht restriktiver sein als die Sichtbarkeit von m() in Base Jedes Exemplar von X ist auch Exemplar von Base, also müssen die Methoden aus Base verfügbar sein. allgemeine Formulierung Sichtbarkeit Bindung 44 class T { void s0(){ m(); } void m(){…} } class S extends T { void s1() { m(); } void s2() { p(); } void p() {…} } class R extends S { private void p() {…} } void s1(){} void s2(){} error: p() in R cannot override p() in S private void p() {} ^ attempting to assign weaker access privileges; was package Hier: Wenn Methode p() in der Subclass R Methode p() aus der Superclass S überschreibt, dann darf die Sichtbarkeit von p() in R nicht restriktiver sein als die Sichtbarkeit von p() in S. Jedes Exemplar von R ist auch Exemplar von S, also müssen die Methoden aus S verfügbar sein. Bindung 45 class T { void s0(){ m(); } void m(){…} } class S extends T { void s1() { m(); } void s2() { p(); } private void p() {…} } class R extends S { private void p() {…} } void s1(){} void s2(){}aT.s0(); aT = new S(); aT.s1(); aT.s2(); T aT = new R(); aT.s1(); aT.s2(); § Der Typ des Objektes für das eine Methode aufgerufen wird bestimmt die Version der Methode – dynamische Bindung! § Aber die Methode muss sichtbar sein § Es spielt keine Rolle ob die Methode in einer Superclass definiert ist («upcall») oder einer Subclass («downcall»). Bindung 46 class T { void s0(){ m(); } void m(){…} } class S extends T { void s1() { m(); } void s2() { p(); } protected void p() {…} } class R extends S { void p() {…} } void s1(){} void s2(){}aT.s0(); aT = new S(); aT.s1(); aT.s2(); T aT = new R(); aT.s1(); aT.s2(); § Der Typ des Objektes für das eine Methode aufgerufen wird bestimmt die Version der Methode – dynamische Bindung! § Aber die Methode muss sichtbar sein § Es spielt keine Rolle ob die Methode in einer Superclass definiert ist («upcall») oder einer Subclass («downcall»). Nicht erlaubt – p() in R erfüllt nicht Bedingung Bindung 47 class T { void s0(){ m(); } void m(){…} } class S extends T { void s1() { m(); } void s2() { p(); } protected void p() {…} } class R extends S { public void p() {…} } void s1(){} void s2(){}aT.s0(); aT = new S(); aT.s1(); aT.s2(); T aT = new R(); aT.s1(); aT.s2(); § Der Typ des Objektes für das eine Methode aufgerufen wird bestimmt die Version der Methode – dynamische Bindung! § Aber die Methode muss sichtbar sein § Es spielt keine Rolle ob die Methode in einer Superclass definiert ist («upcall») oder einer Subclass («downcall»). Bindung 48 class T { void s0(){ m(); } void m(){…} } class S extends T { void s1() { m(); } void s2() { p(); } private void p() {…} } class R extends S { protected void p() {…} } void s1(){} void s2(){}aT.s0(); aT = new S(); aT.s1(); aT.s2(); T aT = new R(); aT.s1(); aT.s2(); § Der Typ des Objektes für das eine Methode aufgerufen wird bestimmt die Version der Methode – dynamische Bindung! § Aber die Methode muss sichtbar sein § Es spielt keine Rolle ob die Methode in einer Superclass definiert ist («upcall») oder einer Subclass («downcall»). Extra: auf Wunsch Bindung 49 class T { void s0(){ m(); } void m(){…} } class S extends T { void s1() { m(); } void s2() { p(); } protected void p() {…} } class R extends S { protected void p() {…} } void s1(){} void s2(){}aT.s0(); aT = new S(); aT.s1(); aT.s2(); T aT = new R(); aT.s1(); aT.s2(); § Der Typ des Objektes für das eine Methode aufgerufen wird bestimmt die Version der Methode – dynamische Bindung! § Aber die Methode muss sichtbar sein § Es spielt keine Rolle ob die Methode in einer Superclass definiert ist («upcall») oder einer Subclass («downcall»). Extra: auf Wunsch Bindung 50 class T { void s0(){ m(); } void m(){…} } class S extends T { void s1() { m(); } void s2() { p(); } /*default*/ void p() {…} } class R extends S { protected void p() {…} } void s1(){} void s2(){}aT.s0(); aT = new S(); aT.s1(); aT.s2(); T aT = new R(); aT.s1(); aT.s2(); § Der Typ des Objektes für das eine Methode aufgerufen wird bestimmt die Version der Methode – dynamische Bindung! § Aber die Methode muss sichtbar sein § Es spielt keine Rolle ob die Methode in einer Superclass definiert ist («upcall») oder einer Subclass («downcall»). Polymorphismus Subtyp («subtype»): Typ einer Subclass. § Eine Referenzvariable für den Typ T kann eine Referenz auf ein Objekt des Typs T oder eines Subtyps von T enthalten § Klasse T bestimmt die Methoden die aufgerufen werden können § Der Typ der Referenzvariable ist statisch bekannt (und damit dem Compiler bekannt) und bestimmt die Menge der Methoden § Der aktuelle (Sub)Typ des Exemplars, auf das die Referenzvariable verweist, bestimmt die Version der aufgerufenen Methode § Dieser Typ ist erst zur Laufzeit bekannt, die aufgerufene Methode wird dynamisch bestimmt. 53 T S R Q TPolymorphismus § Eine Referenzvariable für den Typ S kann eine Referenz auf BLANK ein Objekt des Typs S oder eines Subtyps von S enthalten § Klasse S bestimmt die Methoden die aufgerufen werden können § Daher kann einer Referenzvariable aT für den Typ T der Wert einer Referenzvariable aS für den Typ S zugewiesen werden § Aber nicht umgekehrt. 57 T S R Q T S T S S aS aT = aS; T S S aS T aT Polymorphismus § Eine Referenzvariable für den Typ S kann eine Referenz auf BLANK ein Objekt des Typs S oder eines Subtyps von S enthalten § Klasse S bestimmt die Methoden die aufgerufen werden können § Daher kann einer Referenzvariable aT für den Typ T der Wert einer Referenzvariable aS für den Typ S zugewiesen werden § Aber nicht umgekehrt. 58 T S R Q T S T S aS = aT; ✘ T aT T S S aS T aT Polymorphismus § Eine Referenzvariable für den Typ S kann eine Referenz auf BLANK ein Objekt des Typs S oder eines Subtyps von S enthalten § Klasse S bestimmt die Methoden die aufgerufen werden können § Daher kann einer Referenzvariable aT für den Typ T der Wert einer Referenzvariable aS für den Typ S zugewiesen werden § Aber nicht umgekehrt. 59 T S R Q T S T S aS = aT; ✘ T aT Polymorphismus § Eine Referenzvariable für den Typ S kann eine Referenz auf BLANK ein Objekt des Typs S oder eines Subtyps von S enthalten § Klasse S bestimmt die Methoden die aufgerufen werden können § Daher kann einer Referenzvariable aT für den Typ T der Wert einer Referenzvariable aS für den Typ S zugewiesen werden § Umgekehrt nur mit Cast 61 T S R Q T S T S aS = (S) aT; T aT T S S aS T aT Parameter § Die selben Regeln gelten für die Beziehung zwischen aktuellen Parametern (Argumenten) und formalen Parametern § Übergabe eines Parameters wie Zuweisung formaler_Parameter = aktueller_Parameter (an Stelle des Aufrufs) 62 Polymorphismus und Parameter § Wenn eine Methode als Parameter eine Referenzvariable für den Typ T erwartet, dann kann auch eine Referenzvariable eines Subtyp von T übergeben werden. public static void printInfo(Angestellte ang) { // works with any argument that is of type // Angestellte or a subtype of Angestellte } § Damit können wir eine Methode so schreiben dass sie Referenzen auf T und alle Subtypen von T als Parameter zulässt. 63 Angestellte temp; temp = new Angestellte(); temp = new Arzt(); temp = new FaGe(); temp = new OPFachkraft(); temp = new Administrator(); printInfo(temp); printInfo(Angestellte ang) { ... } 64 Polymorphismus und Parameter public class AngestellteMain{ public static void main(String[] args) { Arzt lisa = new Arzt(4); FaGe steve = new FaGe(7); printInfo(lisa); printInfo(steve); } public static void printInfo(Angestellte ang) { System.out.println(\"salary: \" + ang.getSalary()); System.out.println(\"v.days: \" + ang.getVacationDays()); System.out.println(\"v.form: \" + ang.getVacationForm()); System.out.println(); } } Output: salary: 100000.0 salary: 90000.0 v.days: 28 v.days: 20 v.form: yellow v.form: green 67 Polymorphismus und Arrays Arrays für die Superclass können Referenzen auf Subclass Exemplare als Element enthalten public class AngestellteMain { public static void main(String[] args) { Angestellte[] staff = { new Arzt (4), new FaGe(7), new OPFachkraft(12),new Adminstrator(2) }; for (int i = 0; i < staff.length; i++) { printInfo(staff[i]); } } } 69 Polymorphismus und Arrays Output: salary: 110000.0 v.days: 28 v.form: yellow salary: 90000.0 v.days: 20 v.form: green salary: 100000.0 v.days: 20 v.form: green salary: 95000.0 v.days: 24 v.form: green 71 Polymorphismus Subtyp («subtype»): Typ einer Subclass. § Eine Referenzvariable für den Typ T kann eine Referenz auf ein Objekt des Typs T oder eines Subtyps von T enthalten § Klasse T bestimmt die Methoden die aufgerufen werden können § Der Typ der Referenzvariable ist statisch bekannt (und damit dem Compiler bekannt) und bestimmt die Menge der Methoden § Der aktuelle (Sub)Typ des Exemplars, auf das die Referenzvariable verweist, bestimmt die Version der aufgerufenen Methode § Dieser Typ ist erst zur Laufzeit bekannt, die aufgerufene Methode wird dynamisch bestimmt. 72 T S R Q TPolymorphismus Übung § 4-5 Klasses in Vererbungshierarchie § Ein Klient enthält Referenzvariable und ruft Methoden auf, für Exemplare der Klassen § Methoden geben Strings aus § Sie müssen das Programm lesen und herausfinden welche Methoden aufgerufen werden. 73 Nehmen wir an diese 4 Klassen wurden definiert: public class Foo { public void method1() { System.out.println(\"foo 1\"); } public void method2() { System.out.println(\"foo 2\"); } public String toString() { return \"foo\"; } } public class Bar extends Foo { public void method2() { System.out.println(\"bar 2\"); } } 74 Beipiel, Teil 2 public class Baz extends Foo { public void method1() { System.out.println(\"baz 1\"); } public String toString() { return \"baz\"; } } public class Mumble extends Baz { public void method2() { System.out.println(\"mumble 2\"); } } 75 Beispiel, Teil 3 § Was wäre der Output für dieses Klienten Programm? Foo[] pity = {new Baz(), new Bar(), new Mumble(), new Foo()}; for (int i = 0; i < pity.length; i++) { System.out.println(pity[i]); pity[i].method1(); pity[i].method2(); System.out.println(); } 76 Beipiel auf einer Seite public class Foo { public void method1() { System.out.println(\"foo 1\"); } public void method2() { System.out.println(\"foo 2\"); } public String toString() { return \"foo\"; } } public class Bar extends Foo { public void method2() { System.out.println(\"bar 2\"); } } public class Baz extends Foo { public void method1() { System.out.println(\"baz 1\"); } public String toString() { return \"baz\"; } } public class Mumble extends Baz { public void method2() { System.out.println(\"mumble 2\"); } } 77 § Organisieren Sie die Klassen von oben (Superclass) nach unten (Subclass). Klasse B erweitert Klasse A (Klasse B erbt von Klasse A) § Beachten Sie die geerbten Methoden § Kursiv / (Kursiv) / Unterstreichen § Notieren Sie (wenn möglich) Output oder Berechnung der Methoden Zeichnen wir die Abhängigkeiten A B 78 Zeichnen wir die Abhängigkeiten 79 Übersicht durch eine Tabelle method Foo Bar Baz Mumble method1 method2 toString method Foo Bar Baz Mumble method1 foo 1 baz 1 method2 foo 2 bar 2 mumble 2 toString foo baz method Foo Bar Baz Mumble method1 foo 1 foo 1 baz 1 baz 1 method2 foo 2 bar 2 foo 2 mumble 2 toString foo foo baz baz 81 Beispiel, Teil 3 § Was wäre der Output für dieses Klienten Programm? Foo[] pity = {new Baz(), new Bar(), new Mumble(), new Foo()}; for (int i = 0; i < pity.length; i++) { System.out.println(pity[i]); pity[i].method1(); pity[i].method2(); System.out.println(); } 82 Beispiel Antwort Foo[] pity = {new Baz(), new Bar(), new Mumble(), new Foo()}; for (int i = 0; i < pity.length; i++) { System.out.println(pity[i]); pity[i].method1(); pity[i].method2(); System.out.println(); } § Output: baz baz 1 foo 2 foo foo 1 bar 2 baz baz 1 mumble 2 foo foo 1 foo 2 83 Ein weiteres Beispiel § Die Reihenfolge der Klassen ist zufällig § Methoden rufen manchmal andere Methoden auf. Achtung! public class Lamb extends Ham { public void b() { System.out.print(\"Lamb b \"); } } 84 public class Ham { public void a() { System.out.print(\"Ham a \"); b(); } public void b() { System.out.print(\"Ham b \"); } public String toString() { return \"Ham\"; } } Fortsetzung (2) public class Spam extends Yam { public void b() { System.out.print(\"Spam b \"); } } public class Yam extends Lamb { public void a() { System.out.print(\"Yam a \"); super.a(); } public String toString() { return \"Yam\"; } } 86 Alles auf einer Seite public class Spam extends Yam { public void b() { System.out.print(\"Spam b \"); } } public class Yam extends Lamb { public void a() { System.out.print(\"Yam a \"); super.a(); } public String toString() { return \"Yam\"; } } 87 public class Ham { public void a() { System.out.print(\"Ham a \"); b(); } public void b() { System.out.print(\"Ham b \"); } public String toString() { return \"Ham\"; } } public class Lamb extends Ham { public void b() { System.out.print(\"Lamb b \"); } } Fortsetzung (3) § Was wäre der Output für dieses Klienten Programm? Ham[] food = {new Lamb(), new Ham(), new Spam(), new Yam()}; for (int i = 0; i < food.length; i++) { System.out.println(food[i]); food[i].a(); System.out.println(); // to end the line of output food[i].b(); System.out.println(); // to end the line of output System.out.println(); } 88 Klassen Diagram 89 Polymorphism in action § Lamb erbt Methode a von Ham. a ruft b auf. Aber Lamb überschreibt b ... public class Ham { public void a() { System.out.print(\"Ham a \"); b(); } public void b() { System.out.print(\"Ham b \"); } public String toString() { .. } } public class Lamb extends Ham { public void b() { System.out.print(\"Lamb b \"); } } 90 Output von a für Lamb: Ham a Lamb b Tabelle method Ham Lamb Yam Spam a b toString method Ham Lamb Yam Spam a toString 91 Fortsetzung (3) § Was wäre der Output für dieses Klienten Programm? Ham[] food = {new Lamb(), new Ham(), new Spam(), new Yam()}; for (int i = 0; i < food.length; i++) { System.out.println(food[i]); food[i].a(); System.out.println(); // to end the line of output food[i].b(); System.out.println(); // to end the line of output System.out.println(); } 92 PollErgebnis Ham[] food = {new Lamb(), new Ham(), new Spam(), new Yam()}; for (int i = 0; i < food.length; i++) { System.out.println(food[i]); food[i].a(); food[i].b(); System.out.println(); } § Output: Ham Ham a Lamb b Lamb b Ham Ham a Ham b Ham b Yam Yam a Ham a Spam b Spam b Yam Yam a Ham a Lamb b Lamb b 93 Poll Tabelle method Ham Lamb Yam Spam a b toString method Ham Lamb Yam Spam a Ham a b() Yam a Ham a b() b Ham b Lamb b Spam b toString Ham Yam method Ham Lamb Yam Spam a Ham a b() Ham a b() Yam a Ham a b() Yam a Ham a b() b Ham b Lamb b Lamb b Spam b toString Ham Ham Yam Yam 94 PollKein Beipiel class SchwanzLurche extends Lurche { void info() { System.out.print(\"Salamander&Molche \"); } void zuerst() { // Larven entwickeln ... System.out.println(\"Arme zuerst\"); } } class FroschLurche extends Lurche { public String toString() { return \"FroschLurche \" + super.toString(); } void zuerst() { // Larven entwickeln ... System.out.println(\"Beine zuerst\"); } } 95 Alle Methoden public aber aus Platzgründen tlw. weggelassen (eh nicht wichtig da in der selben Package) Kein Beipiel, Teil 2 class Lurche extends Amphibien { class Amphibien { void info() { void info() { super.info(); System.out.print(\"Amphibien \"); System.out.print(\"Amphibien \"); } } void status() { void zuerst() { System.out.print(\"bedroht \"); } } public String toString() { public String toString() { return \"Lurche \"; return \"Amphibien \"; } } } } class Feuersalamander extends SchwanzLurche { void zuerst() { System.out.println(\"Lebend geboren\"); } void status () { System.out.print(\"Fast ausgestorben \"); } } 96 Zeichnen wir die Abhängigkeiten 98 Amphibien Feuersalamander Lurche info zuerst (status) toString (info) zuerst status (toString) info status toString SchwanzLurche info zuerst (status) (toString) FroschLurche (info) zuerst (status) toString Übersicht durch eine Tabelle method Amphibien Lurche SchwanzL. FroschL. Feuersalamander info zuerst status toString 99 Übersicht durch eine Tabelle method Amphibien Lurche SchwanzL. FroschL. Feuersalamander info \"Amph…\" \"Amph…\"+ \"Amph…\" \"Sa…&Mo…\" zuerst {} \"Arme …\" \"Beine …\" \"Lebend …\" status \"bedroht\" \"Fast ausgestorben \" toString \"Amph…\" \"Lurche\" \"Fro… Lurche\" 100 Noch ohne geerbte Methoden Übersicht durch eine Tabelle method Amphibien Lurche SchwanzL. FroschL. Feuersalamander info \"Amph…\" \"Amph…\"+ \"Amph…\" \"Sa…&Mo…\" \"Amph…\"+ \"Amph…\" \"Sa…&Mo…\" zuerst {} \"Arme …\" \"Beine …\" \"Lebend …\" status \"bedroht\" \"bedr… \" \"bedroht\" \"bedroht\" \"Fast ausgestorben \" toString \"Amph…\" \"Lurche\" \"Lurche\" \"Fro… Lurche\" \"Lurche\" 101 Geerbte Methoden kursiv Klient (Teil 1) § Was wäre der Output für dieses Klienten Programm? Amphibien[] meinTerrarium = { new Amphibien(), new Lurche(), new Feuersalamander() }; for (int i = 0; i < meinTerrarium.length; i++) { System.out.println(meinTerrarium[i]); meinTerrarium[i].info(); System.out.println(); meinTerrarium[i].status(); System.out.println(); } 102 Klient (Teil 2) § Fortsetzung Lurche[] ihrTerrarium = { new SchwanzLurche(), new FroschLurche(), new Feuersalamander() }; for (int i = 0; i < ihrTerrarium.length; i++) { System.out.println(ihrTerrarium[i]); ihrTerrarium[i].info(); System.out.println(); ihrTerrarium[i].zuerst(); } 103 Beispiel Antwort // 1. Teil // i == 0 Amphibien Amphibien bedroht // i == 1 Lurche Amphibien Amphibien bedroht // i == 2 Lurche Salamander&Molche Fast ausgestorben 104 // 2. Teil // i == 0 Lurche Salamander&Molche Arme zuerst // i == 1 FroschLurche Lurche Amphibien Amphibien Beine zuerst // i == 2 Lurche Salamander&Molche Lebend geboren Zusammenfassung (1. Versuch) § Sichtbarkeit § Vier Optionen § Bindung § Dynamische Bindung bei Methodenaufruf § Sichtbarkeit Regeln gelten auch für Attribute § Es gibt für Attribute kein Überschreiben § Wohl aber Verstecken – darüber reden wir später 105 Polymorphismus § Eine Referenzvariable für den Typ T kann eine Referenz auf ein BLANK Objekt des Typs T oder eines Subtyps von T enthalten § Klasse T bestimmt die Methoden die aufgerufen werden können § Klasse T bestimmt Attribute auf die zugegriffen werden kann § Voraussetzung: Sichtbarkeit erlaubt Zugriff § Es gibt zwei Möglichkeiten, eine Referenzvariable für den Typ T zu erhalten § Deklaration (z.B. T aReferenceToT) oder § Cast (z.B. T aReferenceToT = (T) aReferenceToU) 106 U T S R T Casts und Referenzen § Mit einer (Referenz)Variable können wir nur die Methoden aufrufen, die der Typ der Referenzvariable zulässt. § Und nicht Methoden die für einen Subtyp definiert sind Angestellte mary = new Arzt(); int hours = mary.getHours(); // ok; it's in Angestellte mary.treatPatient(); // compiler error § Compiler Logik: mary kann Referenzen auf alle Arten von Angestellten enthalten, und nicht alle wissen wie man Patienten behandelt. § Der Compiler weiss (i.A.) nicht auf was mary verweist – kann irgendein Angestellte Objekt sein. 107 Casts und Referenzen § Wenn wir Methoden des Typs Arzt verwenden wollen, dann müssen wir einen Typcast machen. Angestellte mary = new Arzt(); Arzt doctorMary = (Arzt) mary; doctorMary.treatPatient(); // ok oder kurz: ((Arzt) mary).treatPatient(); Die Klammern sind wichtig! 108 Annonyme (namenlose) Referenzvariable Mehr über Casts § Die Ausführung generiert einen (Laufzeit)fehler wenn wir versuchen, einen nicht-legalen Typ zu verwenden. § z.B. Cast zu einem Typ zu weit unten in der Inheritance Hierarchie Angestellte eric = new FaGe(); ((FaGe) eric).workAtStation(777); // ok OPFachkraft leiter = (OPFachkraft) eric; // Exception zur Laufzeit! // eric refers to an instance of FaGe, can't be cast to // OPFachkraft 110 Angestellte FaGe (Pflege) OPFachkraft Typ der Referenz: Angestellte Typ des Objekts: FaGe Mehr über Casts § Die Ausführung generiert einen (Laufzeit)fehler wenn wir versuchen, einen nicht-legalen Typ zu verwenden. § Wir können eine Referenz auf Typ S in eine Referenz auf einen Supertyp T von S umwandeln Angestellte sue = new OPFachkraft(); ((FaGe) sue).workAtStation(333); // O.k. as FaGe is supertyp 111 Angestellte FaGe (Pflege) OPFachkraft Typ der Referenz: Angestellte Typ des Objekts: OPFachkraft Mehr über Casts § Die Ausführung generiert einen (Laufzeit)fehler wenn wir versuchen, einen nicht-legalen Typ zu verwenden. § Wir können eine Referenz auf Typ S in eine Referenz auf einen Supertyp T von S umwandeln § Aber nur die Methoden von T sind verfügbar Angestellte sue = new OPFachkraft(); ((FaGe) sue).manageOP(); // illegal – compiler error // ((FaGe) sue) refers to an instance of OPFachkraft but only FaGe attributes and methods are known 112 Angestellte FaGe (Pflege) OPFachkraft Typ der Referenz: Angestellte Typ des Objekts: OPFachkraft Mehr über Casts § Wir können in der Inheritance Hierarchie nur nach unten (und oben) umwandeln, aber nicht seitlich. Arzt linda = new Arzt(); ((FaGe) linda).workAtStation(0); // exception OPFachkraft leiter = (OPFachkraft) linda; // exception // Arzt object cannot be cast to FaGe or OPFachkraft § Casting ändert nicht die Darstellung oder das Verhalten eines Objektes. Es ändert nur die Menge der Methoden, die aufgerufen werden können. ((Angestellte) linda).getVacationForm(); // yellow (Arzt) 114 Angestellte Arzt/Aerztin FaGe (Pflege) Adminstrator/in OPFachkraft Typische Fehler § Verwenden einer Methode die nur für Subclass definiert ist § Compiler stellt Fehler fest à Programm kann nicht ausgeführt werden § Angestellte mary = new Arzt(); § mary.treatPatient(); // Compiler Error § Versuch Referenz auf Superclass Exemplar in Referenz auf Subclass umzuwandeln § Wird zur Laufzeit entdeckt – Exception führt zu Abbruch der Ausführung § Angestellte eric = new FaGe(); § OPFachkraft leiter = (OPFachkraft) eric; // Runtime (Laufzeit) Exception117 Attribute § Bisher: Methoden § Nun: Attribute 1. Selbe Regeln für Sichtbarkeit 2. Es gibt kein Überschreiben § Wohl aber Verstecken – darüber reden wir jetzt 120 Wo sich Attribute und Methoden unterscheiden § Unser Ziel ist es, die (Weiter)Entwicklung von abgekapselten Klassen zu unterstützen 121 Evolution (von Klassen) § Gegeben sei Klasse T mit Subklasse S § Eine Methode s0() von T ruft m() auf § Irgendwann muss das Verhalten von m() für Exemplare von S angepasst werden § S überschreibt m() aus T § Methode s0() in T ruft für Exemplare von S die überschriebene Version auf § Annahme: m() in S ist treffender 124 T aT; aT = new S(); aT.s0(); class T { void s0(){ m(); } void m(){…} } class S extends T { @Override void m(){ … … } } Evolution (von Klassen) § Gegeben sei Klasse T mit Subklasse S § Eine Methode s0() von T ruft m() auf § Irgendwann muss das Verhalten von m() für Exemplare von S angepasst werden § S überschreibt m() aus T § Methode s0() in T ruft für Exemplare von S die überschriebene Version auf § Annahme: m() in S ist treffender 125 T aT; aT = new S(); aT.s0(); class T { void s0(){ m(); } void m(){…} } class S extends T { @Override void m(){ … … } } Evolution (von Klassen) § Irgendwann fügt S ein Attribut x hinzu § (Neues) Attribut in S: int x; § Es gibt noch kein Attribut x in T § Sonst würden wir einen besseren Namen finden …. -) 126 class T { void s0(){ m(); } void m(){…} } class S extends T { int x; @Override void m(){ … = x; } } Evolution (von Klassen) § Irgendwann fügt T ein Attribut x hinzu § (Neues) Attribut in T: long x; § T kennt nicht alle Subklassen und ihre Attribute § Methode s1 in T liest x § Welches x soll s1 lesen?? § Aus Klasse T? § Aus Klasse S? 128 class T { long x; void s1(){ … = x; } } class S extends T { int x; @Override void m(){…} } T aT; aT = new S(); aT.s1(); Evolution (von Klassen) § Welches x soll s1 lesen?? § Aus Klasse T? § Aus Klasse S? § Java liest Attribut x aus T (in s1) § s1 kann effizient übersetzt werden § T kann unabhängig von S verändert werden § Wenn es kein x gibt kann sich der Compiler beschweren 129§ Andere Programmiersprachen: andere Regeln class T { long x; void s1(){ … = x; } } class S extends T { int x; @Override void m(){…} } T aT; aT = new S(); aT.s1(); Verdecken von Variablen («shadowing») § shadowing: Zwei Variable mit dem selben Namen die beide sichtbar sind. § Normalerweise in Java illegal – Ausnahme wenn eine der Variablen ein Attribut einer Klasse ist. § Gegeben: Attribute x und y § Wenn eine Methode x und y als Parameter hat, dann beziehen sich x und y auf die Parameter § Wenn eine Methode x und y als Variable deklariert dann beziehen sich x und y auf die Variable Früher: Verdecken von Variablen («shadowing») § shadowing: Zwei Variable mit dem selben Namen die beide sichtbar sind. § Normalerweise in Java illegal – Ausnahme wenn eine der Variablen ein Attribut einer Klasse ist. § «Eine der Variablen …» – es können auch beide sein § Attribut der Subklasse kann Attribut der Superklasse verdecken § Sollte man verhindern § Nicht immer möglich – siehe letztes Beispiel Möglich aber nicht notwendig § Eine Subklasse kann ein Attribut neu definieren class A { int x; int y; } class B extends A { double x; } § Sie sollten das nicht machen. Aber es ist möglich 133 Möglich aber nicht notwendig class A { int x; int y; } class B extends A { double x; } § Das Attribut x in B «verdeckt» (shadows, hides) das Attribut x in A. § Aber das x (aus A) existiert für jedes Exemplar von B 134 Möglich aber nicht notwendig class A { int x; int y; } class B extends A { double x; } A aref = new A(); B bref = new B(); 135 Möglich aber nicht notwendig class A { int x; int y; } class B extends A { double x; } A aref = new A(); B bref = new B(); 136 int x : 0 int y : 0 Parameterloser default Konstruktor für B: B() { super(); x = 0.0; //alles auf Null } Möglich aber nicht notwendig class A { int x; int y; } class B extends A { double x; } A aref = new A(); B bref = new B(); 137 int x : 0 int y : 0 A() Konstruktor B() Konstruktor int x : 0 int y : 0 double x : 0.0 Möglich aber nicht notwendig class A { int x; int y; } class B extends A { double x; } B bref = new B(); bref.x // 0.0 138 int x : 0 int y : 0 double x : 0.0 Casts zur Superklasse § B erbt das (int) Attribut x von A, aber das (double) Attribut x in B verdeckt dieses geerbte Attribut § Es gibt kein «Überschreiben» für Attribute § Kann man auf x aus A zugreifen? § Wir erinnern uns, dass immer auf das Attribut zugegriffen wird, das in der Klasse definiert wurde § Gilt auch wenn Subklassen es verdecken 139 Casts zur Superklasse § B erbt das (int) Attribut x von A, aber das (double) Attribut x in B verdeckt dieses geerbte Attribut § Es gibt kein «Überschreiben» für Attribute § Kann man auf x aus A zugreifen? § Wir erinnern uns, dass immer auf das Attribut zugegriffen wird, das in der Klasse definiert wurde § Gilt auch wenn Subklassen es verdecken § Und wir erinnern uns, dass der Typ der Referenzvariable bestimmt, auf welche Attribute zugegriffen werden kann 140 Casts zur Superklasse § Eine Referenzvariable für den Typ B kann mittels Cast in eine Referenzvariable für den Typ A umgewandelt werden § Denn B ist eine SubKlasse von A § Damit ist Zugriff auf die Attribute der Klasse A erlaubt § Auch wenn diese Attribute in B verdeckt sind 141 class S extends T { int x; void q(){ … = x; } } Zugriff auf versteckte Attribute § Welches x soll gelesen werden? § Aus Klasse T? § Aus Klasse S? § Java liest Attribut x aus T (in s1) § Und mit Referenzvariable für T § Java liest Attribut x aus S (in q) § Und mit Referenzvariable für S 142 class T { long x; void s1(){ … = x; } } // Klient T aT = new T(); aT.x // x aus T aT = new S(); aT.x // x aus T S aS = (S) aT; aS.x // x aus S Möglich aber sollte nicht notwendig sein class A { int x; int y; } class B extends A { double x; } B bref = new B(); ((A) bref).x = 1; ((A) bref).x // 1 bref.x // 0.0 143 int x : 0 int y : 0 double x : 0.0 § Bei Zugriff auf ein Attribut bestimmt der Typ der Referenzvariable das Attribut 144 § Attribut der Superklasse oder Attribut der Subklasse § Für Methodenaufruf entscheidet der aktuelle Typ des Objektexemplars welche Version ausgeführt wird § Immer die Version der aktuellen Klasse § Sie sollten in einer Subklasse die Attribute der Super- klasse nicht verdecken -- dann ist das Programm besser lesbar. (Lassen Sie sich einen neuen Namen einfallen!) Unterschiede Attribut vs. Methode class X { String s = \"in X\"; String myS() { return s; } } class Y extends X { String s = \"in Y\"; @Override String myS() { return s; } } 145 (Warnendes) Beispiel jshell> class X { } | created class X jshell> class Y extends X { } | created class Y jshell> Y yref = new Y(); yref ==> Y@604ed9f0 jshell> yref.s $4 ==> \"in Y\" jshell> yref.myS() $5 ==> \"in Y\" jshell> ((X) yref).myS() $6 ==> \"in Y\" jshell> ((X) yref).s $7 ==> \"in X\" 146 class X { String s = \"in X\"; String myS() {return s;} } class Y extends X { String s = \"in Y\"; @Override String myS() { return s;} } jshell> class X { } | created class X jshell> class Y extends X { } | created class Y jshell> Y yref = new Y(); yref ==> Y@604ed9f0 jshell> yref.s $4 ==> \"in Y\" jshell> yref.myS() $5 ==> \"in Y\" jshell> ((X) yref).myS() $6 ==> \"in Y\" jshell> ((X) yref).s $7 ==> \"in X\" 147 class X { String s = \"in X\"; String myS() {return s;} } class Y extends X { String s = \"in Y\"; @Override String myS() { return s;} } Verwirrend? Nicht wenn Sie die Regeln kennen jshell> class X { } | created class X jshell> class Y extends X { } | created class Y jshell> Y yref = new Y(); yref ==> Y@604ed9f0 jshell> yref.s $4 ==> \"in Y\" jshell> yref.myS() $5 ==> \"in Y\" jshell> ((X) yref).myS() $6 ==> \"in Y\" jshell> ((X) yref).s $7 ==> \"in X\" 148 class X { String s = \"in X\"; String myS() {return s;} } class Y extends X { String s = \"in Y\"; @Override String myS() { return s;} } Verwirrend? Nicht wenn Sie «Verdecken» vermeiden 149 § One major purpose [of these rules] is to confuse people. It's bad practice and should be avoided. § If you can avoid it [shadowing] though, you should since it may cause confusion. 150 Aber halt: Noch mehr zu beachten § Für static Methoden brauchen wir kein Exemplar § Daher macht es keinen Sinn vom «aktuellen Typ» zu sprechen § … und daher entscheidet der Typ der Referenz § static Methoden können nur von static Methoden überschrieben werden § Mein Rat: vermeiden 151 Ein anderes Beispiel (für casts, ohne hiding) § Die folgenden Klassen wurden deklariert: public class Snow { public void method2() { System.out.println(\"Snow 2\"); } public void method3() { System.out.println(\"Snow 3\"); } } public class Rain extends Snow { public void method1() { System.out.println(\"Rain 1\"); } public void method2() { System.out.println(\"Rain 2\"); } } 152 public class Sleet extends Snow { public void method2() { System.out.println(\"Sleet 2\"); super.method2(); method3(); } public void method3() { System.out.println(\"Sleet 3\"); } } public class Fog extends Sleet { public void method1() { System.out.println(\"Fog 1\"); } public void method3() { System.out.println(\"Fog 3\"); } } 153 Was passiert wenn diese (Klienten)Programme ausgeführt werden? • Beispiel 1: Snow var1 = new Sleet(); var1.method2(); • Beispiel 2: Snow var2 = new Rain(); var2.method1(); • Beispiel 3: Snow var3 = new Rain(); ((Fog) var3).method1(); 154 Ein anderes Beispiel public class Snow { public void method2() { System.out.println(\"Snow 2\"); } public void method3() { System.out.println(\"Snow 3\"); } } public class Rain extends Snow { public void method1() { System.out.println(\"Rain 1\"); } public void method2() { System.out.println(\"Rain 2\"); } } public class Sleet extends Snow { public void method2() { System.out.println(\"Sleet 2\"); super.method2(); method3(); } public void method3() { System.out.println(\"Sleet 3\"); } } public class Fog extends Sleet { public void method1() { System.out.println(\"Fog 1\"); } public void method3() { System.out.println(\"Fog 3\"); } } 155 Ansatz 1: Abhängigkeiten zeichnen § Wir zeichnen die Klassen von oben (Superclass) nach unten. 156 Ansatz 1: Abhängigkeiten zeichnen § Wir zeichnen die Klassen von oben (Superclass) nach unten. Snow method2 method3 method1 method2 (method3) Rain method1 (method2) method3 Fog method2 method3 Sleet 157 Ansatz 2: Tabelle method Snow Rain Sleet Fog method1 method2 method3 Italic - geerbtes Verhalten Fett - dynamischer Aufruf einer Methode der Subclass method Snow Rain Sleet Fog method1 method2 method3 158 Ansatz 2: Tabelle method Snow Rain Sleet Fog method1 method2 method3 method Snow Rain Sleet Fog method1 method2 Snow 2 method3 Snow 3 159 Italic - geerbtes Verhalten Fett - dynamischer Aufruf einer Methode der Subclass Ansatz 2: Tabelle method Snow Rain Sleet Fog method1 method2 method3 method Snow Rain Sleet Fog method1 Rain 1 Fog 1 method2 Snow 2 Rain 2 Sleet 2 Snow 2 method3() Sleet 2 Snow 2 method3() method3 Snow 3 Snow 3 Sleet 3 Fog 3 160 Italic - geerbtes Verhalten Fett - dynamischer Aufruf einer Methode der Subclass Was passiert wenn diese (Klienten)Programme ausgeführt werden? • Beispiel 1: Snow var1 = new Sleet(); var1.method2(); • Beispiel 2: Snow var2 = new Rain(); var2.method1(); • Beispiel 3: Snow var3 = new Rain(); ((Fog) var3).method1(); 161 Beispiel 1 § Klient: Snow var1 = new Sleet(); var1.method2(); § Output: Snow method2 method3 method1 method2 (method3) Rain method1 (method2) method3 Fog method2 method3 Sleet object variable 162 Beispiel 1 § Klient: Snow var1 = new Sleet(); var1.method2(); § Output: Sleet 2 Snow 2 Sleet 3 Snow method2 method3 method1 method2 (method3) Rain method1 (method2) method3 Fog method2 method3 Sleet object variable 163 Beispiel 1 -- Variation § Klient: Snow var1 = new Fog(); var1.method2(); § Output: Snow method2 method3 method1 method2 (method3) Rain method1 (method2) method3 Fog method2 method3 Sleet object variable 164 Beispiel 1 -- Variation § Klient: Snow var1 = new Fog(); var1.method2(); § Output: Sleet 2 Snow 2 Fog 3 Snow method2 method3 method1 method2 (method3) Rain method1 (method2) method3 Fog method2 method3 Sleet object variable 165 Beispiel 2 § Klient: Snow var2 = new Rain(); var2.method1(); § Output: Snow method2 method3 method1 method2 (method3) Rain method1 (method2) method3 Fog method2 method3 Sleet variable object 166 Beispiel 2 § Klient: Snow var2 = new Rain(); var2.method1(); § Output: Kein Output! Compiler entdeckt Fehler da Snow keine method1 enthält. Snow method2 method3 method1 method2 (method3) Rain method1 (method2) method3 Fog method2 method3 Sleet variable object 167 Beispiel 3 § Klient: Snow var3 = new Rain(); ((Fog) var3).method1(); § Output: 168 Beispiel 3 § Klient: Snow var3 = new Rain(); ((Fog) var3).method1(); § Output: Snow method2 method3 method1 method2 (method3) Rain method1 (method2) method3 Fog method2 method3 Sleet object variable 169 Beispiel 3 § Klient: Snow var3 = new Rain(); ((Fog) var3).method1(); § Output: Kein Output! Laufzeitfehler da ein Rain Objekt nicht ein Fog Objekt ist. Snow method2 method3 method1 method2 (method3) Rain method1 (method2) method3 Fog method2 method3 Sleet object variable 170 Themen heute: Sichtbarkeit & Bindung § Unser Ziel ist es, die (Weiter)Entwicklung von abgekapselten Klassen zu unterstützen 171 Polymorphismus – Zusammenfassung (2.Versuch) § Ziel ist Programme zu erstellen, die mit Exemplaren verschiedener Klassen arbeiten § Klassen müssen in einer Vererbunghierarchie angeordnet sein § Der Typ der Referenzvariable bestimmt die Methoden die für Objekte aufgerufen werden können. § Der aktuelle (Sub)Typ des Exemplars (auf das die Referenzvariable verweist) bestimmt die Version der aufgerufenen Methode § Casts verwandeln eine Referenz auf Objekte des Typs T in eine Referenz des Typs S. § Umwandlung nur nach unten (und oben) in der Inheritance Hierarchie, nicht seitlich. § Nach unten: dynamischer Check, zur Laufzeit. § Casting ändert nicht die Darstellung oder das Verhalten eines Objektes sondern nur die Menge der Methoden, die aufgerufen werden können. 177 252-0027 Einführung in die Programmierung 8.0 Interfaces Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016-2022 All rights reserved. Feedback § Fragen via EduApp Backchannel § Auch möglich wenn Sie im ML D28 sind § Danke an anonyme und weitere Helfer § Kann (leider) nicht richtige Antwort markieren (Nur UpVote) § Bitte weitermachen § Andere Fragen: wenn nicht in 24 hr beantwortet: bitte mail schicken § Mir fehlen Details, ich denke die Frage ist beantwortet … 4 Übersicht § 8.1 Einleitung § 8.2 Interfaces in Java 5 Entwurf von Systemen § Polymorphismus erlaubt uns Programme zu entwicklen, die für mehrere Klassen zu gebrauchen sind § Vererbung: erlaubt es Klassen in einer Hierarchie anzuordnen § Grundlage ist (bzw. sollte sein) die ist-ein Beziehung der (modellierten) Objekte/Konzepte § Finden einer sinnvollen und brauchbaren Vererbungshierarchie nicht einfach § Übung und (in der Praxis) Überarbeiten § Dazu kommen weitere Überlegungen und Einschränkugen 6 Beispiel: Universitätsverwaltung § Weniger Detail als Spital Beispiel… § Universität hat Angestellte § Mitarbeitende § 41 Std/Woche § 25 Tage/Jahr Urlaub § Dozierende § Keine ﬁxe Arbeitszeit § Kein fester Urlaub § «regeln Arbeitszeit selbstständig» 7 Angestellte Eintritt Austritt Mitarbeitende Urlaubstage Arbeitszeit Dozierende Sabbatical Beispiel: Universitätsverwaltung § Weniger Detail als Spital Beispiel… § Universität hat Angestellte § Verhalten: § Datum getEintritt() § Datum getAustritt() § double getLohn() 8 Angestellte EintriO AustriO Mitarbeitende Urlaubstage Arbeitszeit Dozierende Sabbatical § Universität hat Angestellte § Mitarbeitende § Vollzeit § Teilzeit (Stundenlohn) § Dozierende § Professoren/-innen § Festangestellte § Zeitvertrag § «Tenure Track» (kann zu festangestellt befördert werden) § Temporäre Finanzierung § Sonstige 10 Angestellte Eintritt Austritt Mitarbeitende Urlaubstage Arbeitszeit Dozierende Sabbatical Vollzeit Teilzeit Lohn/Std Sonstige Professoren Zeitvertrag Lehre: 4 SWS Permanent Lehre: 8 SWS § Universität hat Studierende § B.S. Programm § In Programm (Dept. übergreifend) § Post-Graduate Programm § Mentor § In Departement § M.S. § Doktorat § Gaststudent Studierende Eintritt Austritt Post-Graduate Mentor Department Bachelor Urlaubssemester Doktorat Master Gaststudent Heimatuniversität § Universität hat Studierende § Verhalten Studierende Datum getEintritt() Datum getAustritt() String getReglement() Studierende Eintritt Austritt Post-Graduate Mentor Department Bachelor Urlaubssemester Doktorat Master Gaststudent Heimatuniversität class Angestellte { private Datum eintritt; Datum getEintritt() {..} private Datum austritt; Datum getAustritt() {..} } class Mitarbeitende extends Angestellte { private double arbeitszeit; private double urlaubstage; } class Teilzeit extends Mitarbeitende { private double stundenlohn; } class Studierende { private Datum eintritt; Datum getEintritt() {..} private Datum austritt; Datum getAustritt() {..} private String Reglement; } class Bachelor extends Studierende { private int urlaubsemester; } 1415 § Universität bietet Lehrveranstaltungen an § Nr/Titel § Studienprogramm(e) § Vorlesungen § Sprache § Zeit § Übungen § Verbunden mit Vorlesung Lehrveranstaltung Nr Studienprogramm(e) Vorlesung Sprache Zeit Raum Uebung Vorlesung Assistierende_1 Assistierende_2 Im Verwaltungs-Programm § Was heisst § Übungen § Verbunden mit Vorlesung § Jedes Exemplar der Klasse Uebung enthält Referenz auf Exemplar der Klasse Vorlesung 16 Vorlesung 252-0027 B.S. Inform., Interd. NW. Deutsch Di 10-12, Fr 8-10 ML D28 Uebung 252-0027 B.S. Inform., Interd. NW. vorlesung Assistierende_1 Assistierende_2 class Uebung extends Lehrveranstaltung { Vorlesung vorlesung; } class Vorlesung extends Lehrveranstaltung {…} 17 § Universität bietet Lehrveranstaltungen an § Nr/Titel § Studienprogramm(e) § Vorlesungen § Sprache § Zeit § Übungen § Verbunden mit Vorlesung § Verbunden mit Assistierende § Welche Art von Objekt? Mitarbeiter oder Studierender? § Verhalten ????[] getAssistierende() //Array von ???? Lehrveranstaltung Nr Studienprogramm(e) Vorlesung Sprache Zeit Raum Uebung Vorlesung Assistierende Im Verwaltungs-Programm § Klasse Uebung enthält Referenz auf Klasse Vorlesung § Übungen geleitet von Assistierenden § Verbunden mit Person(en) § Jedes Exemplar der Klasse Uebung enthält Referenz(en) auf ? 18 Vorlesung 252-0027 B.S. Inform., Interd. NW. Deutsch Di 10-12, Fr 8-10 ML D28 Uebung 252-0027 B.S. Inform., Interd. NW. vorlesung Assistierende[0] Assistierende[1] Teilzeit 15. 9. 2020 31. 12. 2020 0 (im Stundenlohn enthalten) 10 Std/Woche 30.00 sFr/Stunde Bachelor kein Urlaubssemester? Vererbung in Java: Einschränkungen § Assistierende können sowohl (Bachelor) Studierende als auch Teilzeit (Angestellte) sein § Eine Klasse für Assistierende sollte sowohl Teilzeit als auch Bachelor erweitern § Aber wir können keine Klasse definieren die sowohl von Bachelor als auch Teilzeit erbt – Java kennt nur einfache Vererbung (class FooBar extends Foo, Bar {…} ) § Eine Klasse kann nur von einer Superklasse erben § Andere Programmiersprachen: andere Regeln (und andere Probleme) 21 nicht in Java Interfaces § Es gibt aber einen anderen Weg in Java eine ist-ein Beziehung auszudrücken: Interface § Ein Interface lässt keinen gemeinsamen Code zu § Das Wort «Interface» bedeutet Schnittstelle § D.h. die zwei Komponenten gemeinsame Grenze § In Java spezielle Bedeutung § In Java ein Weg eine Menge von Methoden vorzuschreiben, die von einer Klasse implementiert werden müssen 22 Java interface § Ein interface legt gemeinsames Verhalten fest: Menge von Methoden public interface Personal { Datum getEintritt(); Datum getAustritt(); } § Nur die Signatur der Methoden wird angegeben (Rückgabewert, Name, Parameterliste) 23 Java Interface DeklaraFon Syntax: public interface name { public type name(type name, ..., type name); public type name(type name, ..., type name); ... } Beispiel: public interface Vehicle { public void start(); public void move(); public void stop(); } 24 Interface § Eine Interface Deklaration enthält abstrakte Methoden: Methoden Header ohne Implementation § Sichtbarkeit ist public – kann angegeben werden muss aber nicht § Kein Code für den Rumpf der Methode [Footnote] § Abstrakte Methoden enthalten keinen Code. Klassen müssen dieses Verhalten (Methode) implementieren [Footnote] Java (seit Java 8) erlaubt auch default Methoden mit Code im Interface – kein Thema für uns 25 Java interface § Ein interface legt gemeinsames Verhalten fest § Das Interface kann von Klassen implementiert werden: dann stellt jede Klasse die Methoden des Interfaces zur Verfügung § Die Klassen haben die Methoden des Interfaces gemeinsam § Eine Klasse deklariert dass sie ein Interface implementiert 26 Gebrauch eines Interfaces § Eine Klasse deklariert dass sie ein Interface implementiert § Klasse muss Code für alle Methoden des Interfaces enthalten. (Sonst kann die Klasse nicht übersetzt werden.) § Syntax: class name implements interface { ... } § Damit erklärt die Klasse dass die ist-ein Beziehung gilt § Ein Exemplar der Klasse ist-ein …. (was das Interface bestimmt) § Exemplar ist-ein Objekt das Methoden des Interfaces zur Verfügung stellt 27 class Angestellte implements Personal { private Datum eintritt; Datum getEintritt() {..} private Datum austritt; Datum getAustritt() {..} } class Mitarbeitende extends Angestellte {.. } class Teilzeit extends Mitarbeitende { private double stundenlohn; } class Studierende implements Personal { private Datum eintritt; Datum getEintritt() {..} private Datum austritt; Datum getAustritt() {..} private String Reglement; } class Bachelor extends Studierende {..} 28 public interface Personal { Datum getEintritt(); Datum getAustritt(); } Java Interface § interface: Eine Gruppe von Methoden die eine Klasse implemenaeren kann ... nicht nur implemenaeren kann sondern implemenaeren muss public interface Personal { Datum getEintritt(); Datum getAustritt(); } § Keine Aussagen über Abribute (eintrib, lohn, austrib …) 29 Interfaces § Eine Klasse die ein Interface implementiert muss für alle Methoden Code enthalten § Methode ist abstrakt im Interface § Methode ist konkret in der Klasse 30 Interfaces § Interfaces geben uns eine ist-ein Beziehung ohne gemeinsamen Code und Zustand aber mit gemeinsamem Verhalten (Methoden) § Das Interface Personal schreibt Verhalten vor § Ein Studierende Objekt kann als Personal behandelt werden. § Ein Angestellte Objekt kann als Personal behandelt werden. § Angestellte und Studierende sind nicht Teil einer Inheritance Hierarchy § Vererbung gibt uns ist-ein Beziehungen und die Möglichkeit, Code wiederzuverwenden. § Ein Arzt Objekt kann als ein Angestellte Objekt behandelt werden und Arzt erbt Code (Verhalten) und Attribute (Zustand) von Angestellte. 31 Interfaces: Eine Art ZerFﬁzierung § Im Berufsleben gibt es (geschützte) Zertifizierungen § z.B. «Steuerexperte/Steuerexpertin» § Kann Steuern berechnen, Veranlagungen prüfen, etc. § Zusätzlich zu anderen Qualifikationen 32 Interfaces: Eine Art Zertifizierung § «Ich bin ein Wirtschaftsanwalt und bin als eidg. dipl. Steuerexperte zertifiziert. D.h. ich kann Steuern berechnen, Veranlagungen prüfen, etc.» § «Ich bin Betriebswirt und bin als eidg. dipl. Steuerexperte zertifiziert. D.h. ich kann Steuern berechnen, Veranlagungen prüfen, etc.» § «Ich bin Steuerkommissärin und bin als eidg. dipl. Steuerexpertin zertifiziert. D.h. ich kann Steuern berechnen, Veranlagungen prüfen, etc.» § Ein interface beschreibt Eigenschaften (Verhalten) unabhängig von der Vererbungshierarchie 3334 Jurist Anwalt Wirtschaftsanwalt Justitiar Betriebswirt Controller Revisor Angestellte KanzleiAngestellte Buchhalter Steuerkommissär 35 Jurist Anwalt Wirtschaftsanwalt Justitiar Betriebswirt Controller Revisor Angestellte KanzleiAngestellte Buchhalter Steuerkommissär <<interface>> SteuerExperte veranlagen 36 Jurist Anwalt Wirtschaftsanwalt Justitiar Betriebswirt Controller Revisor Angestellte KanzleiAngestellte Buchhalter Steuerkommissär <<interface>> SteuerExperte veranlagenInterfaces: Eine Art Zertifizierung § Ein interface beschreibt Eigenschaften (Verhalten) unabhängig von der Vererbungshierarchie § Vererbungshierarchie der Klassen drückt wichtigste ist-ein Beziehung aus (Studierende à Bachelor oder Angestellteà Mitarbeiter) § interface name hält andere ist-ein Beziehung fest § Manche Klassen sind zertifiziert dass ist-ein name Beziehung gilt § «Ich bin als Personal zertifiziert. D.h. kann ein Eintrittsdatum (und ggf. Austrittsdatum) liefern» 37 Sichtbarkeit und Interfaces § Die Sichtbarkeit der im Interface deklarierten Methoden ist immer public § Auch wenn wir es nicht hinschreiben (andere Sichtbarkeit verboten) § Das Interface selbst kann default (Package) oder andere (z.B. public) Sichtbarkeit haben § In der Praxis ﬁnden Sie og public public interface Personal { Datum getEintritt(); Datum getAustritt(); } 39 Sichtbarkeit und Interfaces § Die Sichtbarkeit der im Interface deklarierten Methoden ist immer public § Auch wenn wir es nicht hinschreiben (andere Sichtbarkeit verboten) § Das Interface selbst kann default (Package) oder andere (z.B. public) Sichtbarkeit haben § In der Praxis finden Sie oft public public interface Personal { public Datum getEintritt(); public Datum getAustritt(); } 40 Verwandte Typen § Wir sollen eine Gruppe von Klassen implementieren um mit geometrischen Formen zu arbeiten: § Kreis (Circle), Rechteck (Rectangle), und Dreieck (Triangle). § Alle Formen haben einige Operationen gemeinsam: § berechneUmfang - Länge der Begrenzungslinien § berechneFläche - 2D Raum der durch die Figur eingenommen wird § Diese Operationen sind allen gemeinsam auch wenn sie unterschiedlich definiert sind. 41 Fläche und Umfang § Rechteck («rectangle») (definiert durch Länge l und Höhe h): Fläche = lh Umfang = 2l + 2h § Kreis («circle») (definiert durch Radius r): Fläche = pr2 Umfang = 2pr § Dreieck («triangle») (definiert durch Seiten a, b und c) Fläche = √(s(s - a)(s - b)(s - c)) mit s = ½(a + b + c) Umfang = a + b + c 42 Gemeinsame Methoden § Wir schreiben also Klassen mit den Methoden perimeter (berechneUmfang) und area (berechneFläche) § Jede Klasse enthält Code für die Berechnungen – nach den gezeigten Regeln § Wir wollen z. B. in der Lage sein, die Fläche zweier (beliebiger) geometrischen Formen vergleichen zu können § Solange es sich um einen Kreis, Rechteck oder Dreieck handelt § Oder eine Methode soll jede Form zeichnen können 43 Java Interface § Mit einem interface können wir gemeinsames Verhalten festlegen § Menge von Methoden (mit Signaturen: Parameter und Rückgabewert) public interface Shape { double area(); double perimeter(); } § Alle Klassen die das Interface Shape implementieren stellen die Methoden area() und perimeter() zur Verfügung 44 Einsatz des Interfaces Circle stellt area() und perimeter() zur Verfügung: public class Circle implements Shape { private double radius; // others omitted public double area() { return Math.PI * radius * radius; } public double perimeter() { return 2 * Math.PI * radius; } } Fläche = pr2 Umfang = 2pr 46 Java Interface und Sichtbarkeit § Sichtbarkeit der im Interface deklarierten Methoden ist immer public § Klasse muss diese Menge von Methoden implementieren wenn sie das Interface «implementiert» § Mit Sichbarkeit public! public interface Shape { double area(); double perimeter(); } 48 class Circle implements Shape { public double area() {…} public double perimeter() {…} ... // and more … } Java Interface und Sichtbarkeit § Sichtbarkeit der im Interface deklarierten Methoden ist immer public § Klasse muss diese Menge von Methoden implementieren wenn sie das Interface «implementiert» § Mit Sichbarkeit public! public interface Shape { double area(); double perimeter(); } 49 class Circle implements Shape { private double area() {…} private double perimeter() {…} ... // and more … } Java Interface und Sichtbarkeit § Sichtbarkeit der im Interface deklarierten Methoden ist immer public § Klasse muss diese Menge von Methoden implementieren wenn sie das Interface «implementiert» § Mit Sichbarkeit public! public interface Shape { double area(); double perimeter(); } 50 class Circle implements Shape { double area() {…} double perimeter() {…} ... // and more … } Gebrauch eines Interfaces § Eine Klasse kann deklarieren dass sie ein Interface implementiert -- auch wenn sie von einer andere Klasse erbt public class name extends parent implements interface { ... } § Eine Klasse S die eine Klasse T (die ein Interface implement- tiert) erweitert erbt alle in T definierten Methoden (auch die aus dem Interface) § Oder überschreibt sie § Überschriebene Methode muss (auch) Sichtbarkeit public haben 51 Mehrere Interfaces § Eine Klasse kann mehr als ein Interface implementierten public class name implements interface1, interface2 { ... } § Muss dann alle Methoden aus interface1 und interface2 implementieren 5253 <<interface>> Car start() stop() cruise() setDirection() public interface Car { public void start(); public void stop(); public double cruise(); public void setDirection(); } Beides (z.B. Auto der Marke WaterCar)? Muss dann alle Methoden aus interface1 und interface2 implementieren class WaterCar implements Car, Boat { public void start() { ... } public void stop() { ... } public double cruise() { ...} public void setDirection() { ... } public double swim() { ...} } <<interface>> Boat start() stop() swim() public interface Boat { public void start(); public void stop(); public void swim(); } Methode start() in beiden Interfaces Aber nur eine Implementation Erweiterung von Interfaces § Ein Interface kann wie eine Klasse erweitert werden § Durch ein anderes Interface public interface name extends baseInterface { public type name(type name, ..., type name); public type name(type name, ..., type name); ... } § Klasse die name implemenaert muss die Methoden aus dem Interface name und die Methoden aus nameBase deﬁnieren 5455 <<interface>> Vehicle start() move() stop() <<interface>> Car cruise() setDirection() public interface Vehicle { public void start(); public void move(); public void stop(); } public interface Car extends Vehicle { public double cruise(); public void setDirection(); } Interface Erweiterung § Ein Interface kann mehrere Interfaces erweitern. public interface name extends name1, name2 { public type name(type name, ..., type name); } § Beispiel: public interface Boat extends Vehicle { public void swim(); } public interface Property { public double tax(); public interface Amphibian extends Car, Boat, Property { } 5657 <<interface>> Vehicle start() move() stop() <<interface>> Car cruise() setDirection() <<interface>> Property tax() <<interface>> Boat swim() <<interface>> Amphibian Typen – Interfaces und Klassen § Interfaces definieren auch einen Typ (Verhalten) § Werte nur wenn Konstanten (Keyword final – siehe Beispiel) § Referenzvariable können auf Exemplare verweisen, die ein Interface implementieren § Definition wie Referenzvariable für Objektexemplare § Kann als Variable oder als Parameter verwendet werden – wie Referenzvariable für Objektexemplare § Erlaubt Definition von Methoden die als Parameter Exemplare aller Klassen, die ein Interface implementieren, akzeptieren § Polymorphismus für Klassen die ein Interface implementieren58 Referenzvariable: Typ durch Interface besGmmt § Gegeben sei public interface Shape { public static final double PI_APPROX = 3.14159; public double area(); public double perimeter(); } § Dann können wir Referenzvariable und Parameter vom Typ Shape deklarieren Shape s; Shape s = new Circle(); //siehe naechste Seite void process(Shape myS) { … } 59 Typen – Interfaces und Klassen § Mit dem Interface Shape kann jetzt eine Methode definiert werden die Shape Objekte akzeptiert § Exemplare aller Klassen die das Interface Shape implementieren public static void printInfo(Shape s) { System.out.println(\"The shape: \" + s); System.out.println(\"area : \" + s.area()); System.out.println(\"perim: \" + s.perimeter()); } § Jedes Objekt, das das Interface implementiert, kann als Parameter übergeben werden 61 Typen – Interfaces und Klassen Circle circ = new Circle(12.0); Rectangle rect = new Rectangle(4, 7); printInfo(circ); printInfo(rect); § Auch Arrays von Referenzen sind möglich Shape[] shapes = {circ, rect}; printInfo(shapes[0]); printInfo(shapes[1]); 62 Entwurf von Systemen § Ziel: Polymorphismus erlaubt uns Programme zu entwicklen, die für viele Objekte zu gebrauchen sind § Entweder durch Interfaces oder Vererbung in einer ist-ein Beziehung § Vererbung: Klassen in einer Hierarchie übernehmen Code § Aber Java erlaubt nur einfache Vererbung § Eine Klasse kann nur eine Superklasse erweiteren – und nicht mehrere § Interfaces: beschreiben (erzwingen) Verhalten § Klassen die ein Interface implementieren müssen Methoden des Interfaces zur Verfügung stellen § Ein Interface kann mehrere Interfaces erweiteren § Eine Klasse kann mehrere Interfaces implementieren 63 Interfaces + Polymorphismus § Interfaces nützen nicht der Klasse sondern den Klienten! § Die durch ein Interface ausgedrückte ist-ein Beziehung erlaubt dem Klienten Polymorphismus § Der Klient kann «so allgemein wie möglich» geschrieben werden – arbeitet für alle Klassen die das Interface implementieren § Siehe public static void printInfo(Shape s) { … } § Jedes Objekt, das das Interface implementiert, kann als Parameter übergeben werden § Aber nur die Methoden dieses Interfaces können aufgerufen werden 64 252-0027 Einführung in die Programmierung 9.0 Exceptions Thomas R. Gross Department Informaik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016, 2021 All rights reserved. Übersicht § 9.1 Einführung § 9.2 Handler (try-catch) § 9.3 «Werfen» von Exception Objekten § 9.4 Weitere Beispiele 66 9.1 Einführung 67 Ausnahmen («Exceptions») § Ausnahme («Excepaon»): Aulreten eines aussergewöhn- lichen Ereignisses (während der Ausführung) § Folge: Änderung der Ausführungsreihenfolge («control ﬂow») § Normalerweise wird eine Anweisung nach der anderen abgearbeitet § Kann Methodenaufruf sein … es wird immer «die nächste» Anweisung ausgeführt 68 Exception-Beispiel 69 void main() { // ... foo(); // ... } void foo() { bar(); // ... } void bar() { int x = 2; int y = 10/x; // ... } Ausnahmen («Exceptions») § Ausnahme («Excepaon»): Aulreten eines aussergewöhn- lichen Ereignisses § Folge: Änderung der Ausführungsreihenfolge («control ﬂow») § Normalerweise wird eine Anweisung nach der anderen abgearbeitet § Nach Erkennen der Excepion wird eine andere Anweisung ausgeführt 70 Exception-Beispiel 71 void main() { // ... foo(); // ... } void foo() { bar(); // ... } void bar() { int x = 0; int y = 10/x; // ... } Fehler! Wohin? Java Ausnahmen Modell § Betrifft alle Arten von Ausnahmen § Fehler vom Laufzeitsystem entdeckt (/0, x[-1], null.toString() …) § Fehler des Laufzeitsystems (Stack Overflow, …) § Fehler von der Hardware entdeckt (defekte Speicherbausteine, …) § Vom Benutzerprogramm definierte Fehler/Sonderfälle § Sehr praktisch um Programme stabil zu machen § Einheitliche Behandlung aller Ausnahmen § Kompromiss zwischen Programmier- und Laufzeitaufwand 73 Java Ausnahmen Modell § Für jeden Block B (von Anweisungen, kann auch nur eine sein) können wir bestimmen wie eine Ausnahme behandelt werden soll § Die Folge von Anweisungen, die eine aufgetretene Ausnahme bearbeiten, heisst «Handler» § Handler orientiert sich an der Block-Struktur eines Java Programms D.h. Handler verbunden mit Block B, nicht irgendwo im Programm § Jede Art von Ausnahmen kann ihren eigenen Handler haben § Art: Typ – siehe Hierarchie der Exceptions 74 9.2 Handler 75 Handler und geschützter Bereich § Der Handler schützt einen Block: sollte es im Block zu einer Ausnahme (des Typs SomeException) kommen, so wird der Handler ausgeführt § Syntax: try { try-Block } catch (SomeException name) { catch-Block } § Der catch-Block (Handler) kommt nur zur Ausführung wenn es eine SomeException Ausnahme im try-Block gibt. 76 geschützter Bereich Handler Typ der Aus- name die Handler kennt Handler und geschützter Bereich § Falls im try-Block eine Ausnahme vom Typ SomeException auftritt: § Beende try-Block (d.h. breche Ausführung ab) § Führe Handler (catch-Block) aus, name verweist auf ein Objekt, das mehr Informationen über die Ausnahme liefern kann § Handler ist wie ein Methodenaufruf an der Stelle der Ausnahme § Wenn der Handler fertig ist wird die nachfolgende Anweisung ausgeführt (die try-catch folgt) § Falls im try-Block keine Ausnahme auftritt wird die nachfolgende Anweisung ausgeführt § catch-Block ohne Wirkung 77 try-catch § try-catch verknüpft Block mit Handler für einen Typ von Ausnahmen § Details bzgl. der Typen folgen § Beliebige Anweisungen im try-Block, beliebige Anweisungen im Handler § Handler § catch (SomeException name) { … } § wie eine (namenlose) Methode die nach Auftreten einer Exception (im try-Block) ausgeführt wird 78 Pfade in Programmen try catch Pfade in Programmen try catch Pfade in Programmen try catch Pfade in Programmen try catch Pfade in Programmen try catch Beispiel try-catch import java.util.*; public class ExceptionExample { public static void main (String[] args) { Scanner console = new Scanner(System.in); System.out.println(\"Zwei Zahlen a und b (b ungleich 0): \"); boolean done = false; while (!done) { try { int a = console.nextInt(); int b = console.nextInt(); System.out.println(a + \"/\" + b + \" = \" + a/b); done = true; } catch (Exception e) { System.out.println(\"Bitte b ungleich 0!!!\"); } } } } 85 Java Ausnahmen Modell § Für jeden Block B (von Anweisungen, kann auch nur eine sein) können wir bestimmen wie eine Ausnahme behandelt werden soll § Für jede Art von Exception gibt es einen Handler § Entweder (implizit) bereits vom Java System eingerichtet § … oder explizit im Programm angegeben 87 müssen Ausnahmen Klassifikation 1. Ausnahmen die ein Programm nicht behandeln kann und/oder fast überall auftreten können § OutOfMemoryError § NullPointerException 2. Ausnahmen die (im Prinzip) vom Programm behandelt werden können (oder könnten) § i.A. wohldefinierte Anweisung/Methode die BLANK BLANK BLANK für Ausnahme verantwortlich ist § Beispiel: FileNotFoundException 88 Handler exisitiert bereits (aber können eigenen einrichten) Ausnahmen KlassiﬁkaFon 1. Ausnahmen die ein Programm nicht behandeln kann und/oder fast überall auftreten können § OutOfMemoryError § NullPointerException 2. Ausnahmen die (im Prinzip) vom Programm behandelt werden können (oder könnten) § i.A. wohldefinierte Anweisung/Methode die BLANK BLANK BLANK für Ausnahme verantwortlich ist 89 Handler exisitiert bereits (aber können eigenen einrichten) Handler muss eingerichtet werden oder Ankündigung dass Handler gebraucht wird Ausnahmen Modell § Ausnahmen die vom Programm behandelt werden können (oder könnten) müssen auch vom Programm behandelt werden § Entweder Handler einrichten mit try-catch § Oder: Ankündigung (dass Handler gebraucht wird da Ausnahme in Methode auftreten kann) mit throws § Beispiel: throws FileNotFoundException in Methodendeklaration § Compiler prüft dass Handler oder Ankündigung exisitiert {«checked exception») 90 Beispiel Ankündigung: throws public static void main (String[] args) throws FileNotFoundException { Scanner console = new Scanner(System.in); Scanner rd = openFileReader(console); int i = rd.nextInt(); System.out.println(\"here \" + i); } public static Scanner openFileReader(Scanner input) throws FileNotFoundException { String name = input.next(); return new Scanner(new FileReader(name)); } 91 Jetzt alternativ mit try-catch public static Scanner openFileReader(Scanner input) { Scanner rd = null; while (rd == null) { try { String name = input.next(); rd = new Scanner(new FileReader(name)); } catch (FileNotFoundException ex) { System.out.println(\"Can't open file\" + ex.getMessage()); } } return rd; } 92 § Dann braucht die main Methode auch nicht mehr ankündigen, dass sie eine Exception generieren kann public static void main (String[] args) { Scanner console = new Scanner(System.in); Scanner rd = openFileReader(console); int i = rd.nextInt(); System.out.println(\"here \" + i); } § Sollte die File nicht gefunden werden so wird dieses Problem in Methode openFileReader behandelt 93 Handler muss nicht lokal sein § Der Handler kann auch in einem Aufrufer sein public static Scanner openFileReader(Scanner input) { Scanner rd = null; while (rd == null) { try { String name = input.next(); rd = getScanner(name); } catch (FileNotFoundException ex) { System.out.println(\"Can't open file\"); } } return rd; } 94 Handler muss nicht lokal sein public static Scanner getScanner(String n) throws FileNotFoundException { Scanner sc = delegateWork(n); return sc; } public static Scanner delegateWork(String n) throws FileNotFoundException { return new Scanner(new FileReader(n)); } 95 openFileReader getScanner delegateWork (will) catch(..) (may) throw (may) throw falls Exception auftrittfalls Exception auftritt Nicht-lokaler Handler § Tritt eine Exception in den aufgerufenen Methoden (getScanner, delegateWork) auf, so wird der Handler (catch- Block des try-catch Konstrukts) im Aufrufer aktiviert § Die aufgerufenen Methoden müssen ankündigen, dass sie eine Exception generieren (und nicht selber behandeln) können § Die Methode openFileReader braucht nicht mehr mittels throws ankündigen, dass sie eine Exception generieren kann § Denn catch-block fängt mögliche FileNotFoundException auf § Es wird der catch-Block ausgeführt, der das Auftreten am engsten umschliesst. 96 9.3 «Werfen» von Exception Objekten 97 «Werfen» von Exception Exemplaren § Wenn eine Exception auftritt dann generiert das Java System ein Exception Exemplar § Genauer: Exemplar der Klasse Throwable (… oder einer Subclass) 9899 Vererbungshierarchie im Einsatz 100 NullPointer Exception Arithmetic Exception Runtime Exception IndexOutOfBounds Exception ArrayIndexOutOf BoundsException Exception IOException FileN Error IOError VirtualMachine Error StackOverflow Error OutOfMemory Error Throwable Object «Werfen» von Exception Exemplaren § Wenn eine Exception auftritt dann generiert das Java System ein Exception Exemplar § Genauer: Exemplar der Klasse Throwable (… oder einer Subclass) § Dieses Objekt wird dann zum passenden Handler weitergereicht («thrown») § Automatisch § Ein Programm kann auch explizit ein Ausnahme Exemplar generieren (new Throwable()) und dieses dann zum Handler weiterreichen lassen § … mit der throw Anweisung 101 throw-Anweisung § Ein Programm kann selbst eine Exception generieren § Genauso behandelt als wenn das Laufzeit System das Auftreten feststellt § Syntax: throw exception; § exception muss eine Referenz auf ein Exemplar vom Typ Throwable sein § z.B. : throw new ArithmeticException(); 102 Beispiel throw import java.util.*; public class ExceptionExample { public static void main (String[] args) { Scanner console = new Scanner(System.in); boolean done = false; while (!done) { try { System.out.println(computeFraction(console)); done = true; } catch (ArithmeticException e) { System.out.println(e.getMessage()); System.out.println(\"Bitte b ungleich 0!!!\"); } } } } 103 static String computeFraction(Scanner in) { System.out.println(\"Zwei Zahlen a und b (b ungleich 0): \"); int a = in.nextInt(); int b = in.nextInt(); if (b==0) { throw new ArithmeticException(\"Input 0 nicht erlaubt\"); } return \"\" + a + \"/\" + b + \" = \" + a/b; } Bemerkungen § Sowohl try-catch als auch throw sind für dieses Problem (Input riskiert Division durch 0) Overkill § if-Statement oder null-Return wären vielleicht besser § Entscheidung Abhängig von Häufigkeit und Abstand zwischen Punkt an dem Fehler behoben werden kann zu Punkt an dem Fehler auftritt § Spätere Slides zeigen anderes Beispiel § Mein Tip: Zurückhaltung bei Verwendung von try-catch und throw 104 Welche Exception Objekte werden gefangen? § Wir sagen «Exception Exemplar» (oder E. Objekt) obwohl es genau genommen ein Exemplar von Throwable ist § Exception ist Subklasse von Throwable § Andere ist Error – ist für uns weniger wichtig § Handler fängt eine Exception wenn der Typ des Exception Objekts mit dem Typ im catch-Konstrukt kompatibel ist. § catch (SomeException name) § Zuweisung § SomeException name = RefExceptionObjekt § muss erlaubt sein 106 Was wird gefangen? § catch (E name) § Sei T der Typ des Exception Objektes 107 Arithmetic Exception Exception IOException Throwable T Throwable Exception IOException Arithmetic Exception Throwable Exception IOException Arithmetic Exception E ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Mehrere Handler möglich § Für einen try-Block kann es mehrere Handler geben try { try-Block } catch (Exception1 name) { catch-Block } catch (Exception2 name) { catch-Block } // oder mehr Handler … § Wenn eine Exception im try-Block auftritt wird der passende Handler gefunden. 108 Handler für Exception1 Handler für Exception2 § Zur Laufzeit (wenn eine Ausnahme festgestellt oder generiert wurde) werden die catch-Blöcke der Reihe nach angesehen catch (FirstException ex) { ... } catch (SecondException ex) { ... } catch (ThirdException ex) { ... } // nachfolgende Anweisung (Nur) der erste Block dessen Parameter passt (d.h., Referenzen auf einen Supertyp des Exception-Objektes zulässt) wird ausgeführt § Die aktuelle Ausnahme wird durch ein Objekt beschrieben – \"ist-ein\" Exemplar der erwarteten Ausnahmen § Wenn kein Block passt geht es mit dem umschliessenden Konstrukt weiter (try-catch oder throws) 109 Bemerkung § Natürlich können wir neue Klassen definieren, die Throwable (oder Exception) erweitern § class MyException extends Exception { § String info; § MyException(String s) { § info = s; § } } § MyException Exemplar mit throw weiterreichbar … § Viele Möglichkeiten (siehe folgendes Beispiel) 110 9.4 Weitere Beispiele 111 Beispiel § Wir wollen nicht zulassen, dass grosse Files geöﬀnet werden § Die Länge (length) einer Datei können wir erst erfahren nachdem die Datei geöﬀnet wurde. § Ist die File zu gross, gibt es eine Excepion § Genauso als wenn sie nicht exisiert § Sinn des Beispiels ist den Einsatz einer eigenen Excepaon zu zeigen, nicht der Dialog mit dem Filesystem 112 public static Scanner openFileReader(Scanner input) { Scanner rd = null; while (rd == null) { try { String name = input.next(); rd = getScanner(name); } catch (MyException ex) { System.out.println(\"Don't want to open this file\"); } // warning – Not yet complete // // } return rd; } Noch nicht ganz vollständig .... 113 ⚠ Unvollständig Code für getScanner (jetzt mit Check für Grösse) und MyException public static Scanner getScanner(String n) throws FileNotFoundException, MyException { File f = new File(n); if (f.exists() && f.length() > 1000) { throw new MyException(); } return new Scanner(f); } // getScanner public class MyException extends Exception { // could have [more] attributes but not needed } 114 Klienten Programm public class ExceptionExample { public static void main (String[] args) { Scanner console = new Scanner(System.in); Scanner rd = openFileReader(console); int i = rd.nextInt(); System.out.println(\"here \" + i); } } // end ExceptionExample 115 Diskussion § Diese Variante der Methode getScanner weigert sich, eine grosse Datei zu öffnen § catch (MyException ex){ } fängt die geworfene Exception auf und gibt eine Fehlermeldung aus. § Allerdings gibt es noch ein Problem § Die Datei exisitiert vielleicht gar nicht § Die Methode getScanner kann immer noch eine FileNotFoundException werfen 116 Diskussion § Diese Exception (FileNotFoundException) muss auch von einem catch-Block gefangen werden § Oder mittels throws angekündigt werden 117 public static Scanner openFileReader(Scanner input) { Scanner rd = null; while (rd == null) { try { String name = input.next(); rd = getScanner(name); } catch (MyException ex) { System.out.println(\"Don't want to open this file\"); } catch (IOException ex) { System.out.println(\"Can't open file\"); } } return rd; } 118 IOException ist SuperKlasse von FileNotFoundException Diskussion § Diese Exception (FileNotFoundException) muss auch von einem catch-Block gefangen werden § Oder mittels throws angekündigt werden § catch (IOException ex) {...} fängt eine ggf. auftretende FileNotFoundException auf § IOException ist ein Supertyp (eine Superklasse) von FileNotFoundException 121 Weiter mit Beispiel § Wir wollen zwischen grossen Dateien (> 1000 Bytes) und gigantischen Dateien (>2000 Bytes) unterscheiden. § Wir wollen auch Feedback geben wenn die Datei zu gross ist. § Entweder die Datei ist gross (> 1000 Bytes, <= 2000 Bytes) oder sie ist gigantisch (> 2000 Bytes) § Sollte die Datei nicht existieren so fragen wir nur nach einem anderen Namen. 122 public class Exception2 { public static void main (String[] args) { Scanner console = new Scanner(System.in); Scanner rd = null; while (rd == null) { try { try { System.out.println(\"Please enter a file name:\"); String name = console.next(); rd = getScanner(name); } catch (MyBigException ex) { System.out.println(\"This file is HUGE!\"); } catch (MyException ex) { System.out.println(\"This file is large!\"); } if (rd == null) { System.out.println(\"Please enter name of a small file\"); } // Ende outer try-block -- large file } // weiter mit catch fuer outer try-block 123 Fortsetzung 1 // Ende outer try-block on previous slide // } catch (IOException ex) { // catch -- no such file System.out.println(\"File does not exist\"); } // end while loop } // use rd to read from small file … int i = rd.nextInt(); System.out.println(\"Found: \" + i); } // end main 124 Fortsetzung 2 public static Scanner getScanner(String n) throws FileNotFoundException, MyException { File f = new File(n); if (f.exists() && f.length() > 1000) { if (f.length() > 2000) { throw new MyBigException(); } else { throw new MyException(); } } return new Scanner(f); } } // Exception2 public class MyException extends Exception { } public class MyBigException extends MyException { } 125 MyException ist SuperKlasse von MyBigException public class Exception2 { public static void main (String[] args) { Scanner console = new Scanner(System.in); Scanner rd = null; while (rd == null) { try { try { System.out.println(\"Please enter a file name:\"); String name = console.next(); rd = getScanner(name); } catch (MyBigException ex) { System.out.println(\"This file is HUGE!\"); } catch (MyException ex) { System.out.println(\"This file is large!\"); } if (rd == null) { System.out.println(\"Please enter name of a small file\"); } // Ende outer try-block -- large file } catch (IOException ex) { // catch fuer outer try-block // catch -- no such file System.out.println(\"File does not exist\"); } // end while loop } // use rd to read from small file … int i = rd.nextInt(); System.out.println(\"Found: \" + i); } // end main 126 public static Scanner getScanner(String n) throws FileNotFoundException, MyException { File f = new File(n); if (f.exists() && f.length() > 1000) { if (f.length() > 2000) { throw new MyBigException(); } else { throw new MyException(); } } return new Scanner(f); } } // Exception2 public class MyException extends Exception { } public class MyBigException extends MyException { } Output § Die Dateien ls -alt *txt 8 -rw-------. 1 trg inf 6 Nov 24 2019 data.txt 8 -rw-------. 1 trg inf 2804 Oct 24 2019 hoehe.txt 8 -rw-------. 1 trg inf 1067 Oct 21 2019 hs.txt § Ausführung Please enter a file name: no-such-file.txt File does not exist Please enter a file name: hs.txt This file is large! Please enter name of a small file Please enter a file name: hoehe.txt This file is HUGE! Please enter name of a small file Please enter a file name: data.txt Found: 33333 127 data.txt: 33333 Frage Was passiert wenn wir die Reihenfolge von } catch (MyBigException ex) { System.out.println(\"This file is HUGE!\"); } catch (MyException ex) { System.out.println(\"This file is large!\"); } in } catch (MyException ex) { System.out.println(\"This file is large!\"); } catch (MyBigException ex) { System.out.println(\"This file is HUGE!\"); } ändern? 128 Exception Modell Zusammenfassung § Methoden können mit throws ankündigen, wenn sie Excepaons generieren oder nicht selbst behandeln § Zwingend bei checked Excepions – müssen behandelt oder angekündigt werden § Selbst behandeln heisst: Anweisungen, die Excepaons generieren können, werden in einem «try-Block» ausgeführt, und der «catch-Block» fängt ggf. aulretende Excepaons § Mehrere catch-Blöcke sind möglich § Die Reihenfolge der catch-Blöcke ist wichig 130 252-0027 Einführung in die Programmierung 10.0 Generische Programmierung Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016—2021 All rights reserved. Übersicht § 10.1 Einleitung § 10.1.1 Wrapper Klassen § 10.1.2 Typparameter § 10.2 ArrayList<T> § 10.3 Vergleichen von Objekten § 10.4 Mengen § 10.5 Abbildungen § 10.6 Iteratoren § 10.7 Implementation eines einfachen generischen Typs 2 10.1 Einleitung 3 Software Entwicklung § Programmieren ist anspruchsvoll § Es ist leicht Fehler zu machen § Zwei Ansätze diese Aufgabe zu lösen § Abstraktion § Wiederverwendung von früheren Lösungen 5 lösenvereinfachen Auf früheren Lösungen aufbauen § Schnellere Implementationen § Design und Code vorgegeben § Weniger Testaufwand § Bisher: zwei Ansätze § Vererbung: gemeinsamer Code § Wiederverwendung für Subclasses § Interfaces: Code der Exemplare vieler Klassen akzeptiert 6 Software Wiederverwendung § Vererbung (inheritance): Klassen übernehmen Code der Superklasse § Hat ein formaler Parameter den Typ «Referenz auf Superklasse» so kann der aktuelle Parameter vom Typ «Referenz auf Subklasse» sein. § Interfaces erlauben weitere Typhierarchie § Hat ein formaler Parameter den Typ «Referenz auf Interface» so kann der aktuelle Parameter auf ein Exemplar irgendeiner Klasse verweisen, die das Interface implementiert. 7 Angestellte Arzt/Ärztin FaGe (Pflege) Adminstrator /in OP-Fachkraft Problem: LinkedDoubleList § Wir brauchen eine Variante von LinkedIntList die das Speichern eines double Werts erlaubt void add(double v) { … } § Knoten mit double Werten – sonst keine Änderung class DoubleListNode { double data; DoubleListNode next; } front = data next 222.3 element 0 element 1 element 2 data next 61.3 data next -43.93 LinkedDoubleList DoubleListNode DoubleListNode DoubleListNode LinkedIntList à LinkedDoubleList § Wie können wir eine Liste (eventuell mit Hilfsklassen wie ListNode) so definieren, dass die Klasse für alle Typen verwendet werden kann? § LinkedIntList speichert int Werte § LinkedDoubleList speichert double Werte § LinkedPointList speichert Verweise auf Point Exemplare § LinkedShapeList speichert Verweise auf Exemplare, die das Interface Shape implementieren § …. 9 Hilft eine Vererbungshierarchie? § Wir könnten versuchen die Klasse ListNode zu erweitern class ListNode { ???????? data; ListNode next; ListNode() { data = ????; next = null; } // ggf andere Konstruktoren } 10 class DoubleListNode extends ListNode { } public class LinkedDoubleList { private ListNode front; // Beispiel Methode public void removefirst() { if (front == null) {System.exit(-1);} front = front.next; } } § Könnten damit Liste und Operationen der Liste definieren 12 Was für ein Typ für das data Attribut? § (Mindestens) drei Probleme: § Typen (der Daten in der Liste) müssen in einer Vererbungshierarchie sein wenn data auf Exemplare verschiedener Typen verweisen will § Vererbung nur für Klassen definiert, nicht für Basistypen § Was sollte der Typ der Rückgabe von get(), remove(), ... sein? § Was für einen Typ sollte Konstruktor akzeptieren? § Müssen immer noch explizit XXXListNode erstellen und Code für LinkedXXXList kopieren 13 Was für ein Typ für das data Attribut? § Referenzen auf Object Exemplare können auf Exemplare beliebiger Klassen verweisen § Zur Erinnerung: in Point: equal(Object other) { ... } § ... aber Basistypen sind nicht Exemplare einer Klasse § Für jeden Basistyp gibt es eine besondere Klasse (die Wrapper Klasse («wrapper» class, Verschalungsklasse [dt])) deren Exemplare Werte des Basistyps speichern können § Für int ist das Integer § Für double ist das Double 14 10.1.1 Wrapper Klassen 15 10.1.1 Wrapper Klassen § Ein «wrapper» (Umschlag, Verschalung) ist ein Objekt dessen einziger Zweck es ist, einen Wert eines Basistyps zu speichern. § Exemplare dieser Klassen sind Objekte Primitive Type Wrapper Type int Integer double Double char Character boolean Boolean 161718und viele mehr .... 19 Integer kennen wir (vielleicht) schon § Wenn wir den grössten (kleinsten) Wert brauchen, den wir in einer int Variable speichern können, dann helfen uns Integer.MAX_VALUE Integer.MIN_VALUE § Denn Integer Exemplare können jeden int Wert speichern (auch umgekehrt) 2021 Was fehlt? § Was sind die Attribute? § Was würden wir erwarten? § Attribut («field») um den Wert zu speichern …. § An object of type Integer contains a single field whose type is int. (steht in der Beschreibung für Class Integer) 22 Integer § Es gibt kein Attribut welches den Wert speichert ... und sichtbar ist § Daher kann der Wert auch nicht verändert werden § Keine der Methoden lässt das zu. § Integer Examplare sind immutable (unveränderbar) 23 Arbeiten mit Wrapper Exemplaren 1. Automatische Umwandlung: Das Umwandeln eines Basis- typs in den entsprechenden Wrapper Typ heisst «boxing» Integer myI = 5; int j = 7; myI = j; System.out.println(\"myI = \" + myI); //toString! 24 55 Boxing! j7 Boxing! 5 7myI Arbeiten mit Wrapper Exemplaren Wenn man eine Referenz auf ein Integer Exemplar braucht (und es kann eine Referenz auf irgendein Exemplar mit diesem Wert sein – Integer ist immutable) 2. Methode valueOf der Klasse Integer liefert Referenz auf Integer Exemplar mit (int) Wert value Integer myI = Integer.valueOf(5); System.out.println(\"myI = \" + myI); //toString! 2731 Wrapper Klassen § Was wir nicht verwenden sollten: new Operator § Geht noch, wird aber irgendwann nicht mehr erlaubt sein § Stattdessen: 32 Integer Parameter § Was gibt diese Anweisung (in einem Program) aus? Integer myI = Integer.valueOf(777); test(myI); System.out.println(myI); public static void test(Integer bigI) { System.out.println(bigI); Integer someI; someI = 333; System.out.println(someI); bigI = Integer.valueOf(666); System.out.println(bigI); } 34 Poll§ Was gibt diese Anweisung (in einem Program) aus? Integer myI = Integer.valueOf(777); test(myI); System.out.println(myI); public static void test(Integer xI) { System.out.println(xI); Integer someI; someI = 333; System.out.println(someI); xI = Integer.valueOf(666); System.out.println(xI); } 35 Poll§ Was gibt diese Anweisung (in einem Program) aus? Integer myI = Integer.valueOf(777); test(myI); System.out.println(myI); public static void test(Integer xI) { System.out.println(xI); Integer someI; someI = 333; System.out.println(someI); xI = Integer.valueOf(666); System.out.println(xI); } 36 Output: 777 333 666 777 Poll 777 333 666 37 data Attribut: (Referenz auf) Object § Wir könnten versuchen Referenzen auf Object zu verwenden class ListNode { Object data; ListNode next; ListNode() { data = null; next = null; } ListNode(Object value) { data = value; next = null; } ListNode(Object value, ListNode connect) { data = value; next = connect; } } 43 public class LinkedDoubleList { private ListNode front; // Beispiel Methode public void removefirst() { if (front == null) {System.exit(-1);} front = front.next; } } [Footnote] Könnten Klasse statt LinkedDoubleList auch einfach LinkedList nennen da data Verweise auf alle Arten von Exemplaren zulässt. § (Mindestens) drei Probleme: § Typen (der Daten in der Liste) müssen in einer Vererbungshierarchie sein wenn data auf Exemplare verschiedener Typen verweisen will Vererbung nur für Klassen definiert, nicht für Basistypen § Was sollte der Typ der Rückgabe von get(), remove(), ... sein? § Wenn data auf ein Object Exemplar verweist, dann kann nur eine Object Referenz zurückgegeben werden public Object remove() { ..} public Object get(int index) { .. } 44 Jetzt «vergisst» die Liste den Typ! § Dieses Programm kann nicht übersetzt werden LinkedDoubleList list = new LinkedDoubleList(); Double d = Double.valueOf(30.0); list.add(d); System.out.println(list); double f = d / 2; System.out.println(\"Result = \" + f); System.out.println(\"Erstes Element = \" + list.get(0)); f = list.get(0) / 2; § Denn get() liefert eine Referenz auf ein Object Exemplar und unboxing geht nur für Double Exemplare 45 Test.java:64: error: bad operand types for binary operator '/' f = list.get(0) / 2; ^ first type: Object second type: int Was wir wirklich wollen § Wenn wir eine LinkedList erstellen dann soll der Typ der Elemente ein Parameter sein § Dann könnten wir sagen: § Liste von Double Exemplaren § Liste von Point Exemplaren § Liste von Integer Exemplaren § Liste von ... Exemplaren ...: irgendeine Klasse 46 10.1.2 Typparameter 47 Typparameter § Typparameter («type parameter») in der Definition einer Klasse durch < > gekennzeichnet < TypParameter > Verwende den Typ TypParameter in der Definition der Klasse § Beispiel class MyType<T> { } oder class MyType<TypeParameter> { } 48 Typparameter Einsatz § Mit der Klasse Point: MyType<Point> mine; // Referenzvariable mine = new MyType<Point>(); // Erstellen eines Exemplars § Mit der Klasse Integer: MyType<Integer> mine; // Referenzvariable mine = new MyType<Integer>(); // Erstellen eines Exemplars 49 Typparameter Beispiel § Die Klasse MyType<T> könnte so aussehen: class MyType<T> { T intern; String s; public MyType() {} // default constructor public MyType(T i) { // another constructor, one T param, sets fields intern = i; s = i.toString(); } public String toString() { return s; } } 5051 Typparameter Beispiel, Fortsetzung § Mit der Klasse Point: MyType<Point> mine; // Referenzvariable Point p = new Point(7, 3); mine = new MyType<Point>(p); // Erstellen eines Exemplars § Mit der Klasse Integer: MyType<Integer> mine; // Referenzvariable Integer bI = Integer.valueOf(5); mine = new MyType<Integer>(bI); // Erstellen eines Exemplars 54 \"( 7, 3 )\" Typparameter Einsatz § Typparameter erlaubt Entwicklung einer generischen Klasse ListNode<T> class ListNode <T> { T data; ListNode next; ListNode() { data = null; next = null; } ListNode(T value) {...} // ggf andere Konstruktoren } 55 class DoubleListNode extends ListNode { } public class LinkedList <T> { private ListNode<T> front; // Beispiel Methoden public void add(T value) {...} public void add(T value, int index){..} public T get(int index) {...} public void removefirst() {...} }§ Könnten so generische Liste für alle Typen definieren Nicht mehr nötig Typparameter § Wir werden uns zuerst mit dem Gebrauch einer generischen Klasse («generic class») beschäftigen § Entwicklung generischer Klassen muss warten § Was für Listen wollen wir? 56 Listen von ... § Typparameter erlaubt Flexibilität für Elemente § Können Klasse mit Typparameter wiederverwenden § Gibt es weitere Dimension für Flexibilität? § Wie werden Listen verwendet? 57 Listen von Integer Objekten § Verschiedene int Werte (ganze Zahlen) – Referenzen von Integer Objekten § Menge (Mathematik): Reihenfolge unwichtig, keine Duplikate § Menge (Umgangssprache): Duplikate erlaubt § Der Grösse nach sortierte int Werte § Grösse bestimmt durch Integer Objekt ... § int Werte in der Reihenfolge des Einfügens 61 Listen von Point Objekten § Menge von Point Referenzen (2D Punkte) § Sortierte Point Referenzen § Sortiert nach Eigenschaften der Objekte ... § Sortiert entlang der X-Achse (oder Y-Achse, oder Abstand von (0,0)) § Sortiert in der Reihenfolge in der sie gezeichnet werden sollen § Point Referenzen in der Reihenfolge des Einfügens 62 Gemeinsam ist diesen (und anderen) Listen? § Unbegrenzte Anzahl Elemente § Operationen um Element hinzuzufügen, zu entfernen, prüfen ob vorhanden, ... 63 (Mögliche) Unterschiede § Typ der Elemente § Definition der Ordnung/Reihenfolge, Zugriffsmuster (Häufigkeit, Art, ...) § Duplikate erlaubt/verboten § Listen und ähnliche Datenstrukturen werden häufig gebraucht § Java stellt Klassen und Interfaces zur Verfügung § Typ der Elemente: Typparameter § Details der Operationen: Polymorphismus (Overriding) 6464 Gemeinsam: Arbeiten mit Ansammlung («Collection») von Referenzen auf Elemente § Listen und ähnliche Datenstrukturen werden häufig gebraucht § Java stellt Klassen und Interfaces zur Verfügung § Typ der Elemente: Typparameter § Details der Operationen: Polymorphismus (Overriding) 6565 Gemeinsam: Arbeiten mit Ansammlung («Collection») von Referenzen auf Elemente § Java Collection Interface Collection § «collection» (Sammlung, Ansammlung): ein Objekt das (eine Sammlung von) Daten speichert; eine «Datenstruktur» § Die Objekte die gespeichert werden heissen Elemente § Einige Collections sind geordnet; einige erlauben Duplikate § Typische Operationen: add, remove, clear, contains (search), size § D.h. hinzufügen, entfernen, zurücksetzen, enthält?, Grösse § Begriff für eine Vielzahl von Datenstrukturen § Aber für uns stehen die Operationen im Vordergrund, nicht die Implementation 66 Collection Java Interface public interface Collection < T > { public void add (T element); public void clear(); public boolean contains(T element); public T remove(int index); public int size(); … } T ist Typparameter 68 Java Collections Interface 69 <<Interface> Collection <<Interface> List <<Interface> Set <<Interface> SortedSet Collection Beispiele § Collection Interface Basis für diverse Sub-Interfaces § «Collection Klassen» implementieren (Sub)-Interface(s) § (dazu gleich mehr) § Beispiele aus den Java Bibliotheken: LinkedList, ArrayList, HashMap, TreeSet, PriorityQueue § Collection Interface (und Subinterfaces) plus «Collection Klassen» bilden das (Java) Collections Framework § Collections Framework ist in java.util – Klassen und Interfaces müssen also importiert werden, z.B. import java.util.PriorityQueue; 71 Java Collections Framework § Flexibilität (und Code Wiederverwendung) in zwei Dimensionen: § Art (Typ) der Elemente § Definition der Operationen für die Ansammlung («Collection») § Diverse Klassen für häufige Datenstrukturen § Erlauben Anpassung in Definition (z.B., wie wird sortiert?) und in Effizienz (z.B., Zugriff O(1) vs. O(n)) der Operationen 72 Listen – das Minimum § Liste: eine Ansammlung von Objekten die als geordnete Folge von Elementen gespeichert wird § Jedes Element kann über einen 0-basierten Index erreicht werden § Eine Liste hat eine Grösse (Anzahl Elemente in der Liste) § Elemente können am Anfang, am Ende, oder irgendwo hinzugefügt werden. 75 Listenobjekte (wie LinkedIntList ...) § Eine Liste hat mehr Zustand als nur die Elemente § Müssen auch festhalten, was das 1. Element ist (und sinnvoll ist es auch, das letzte Element zu kennen) § Eine Liste besteht daher aus mehr als nur den Elementen § Wir erstellen daher ein Objekt, das die «Liste» der (verknüpften) Elemente representiert § Am Anfang eine leere Liste [] 77 Listenobjekte § Zu einer solchen Liste können Elemente hinzugefügt werden. § default Verhalten: Elemente am Ende der Liste hinzufügen. § Beispiel: Liste von String Exemplaren [hello, ABC, goodbye] à [hello, ABC, goodbye, okay] § Das Listenobjekt hält fest, welche Elemente hinzugefügt wurden, den Index, die Anzahl der Elemente, die Reihenfolge. 78 add(\"okay\") Listen – das Minimum § Ist der Einsatz eines (internen) «Knotens» (wie ListNode) vorgeschrieben? § Stellen wir uns vor nach Erstellen der Liste lesen wir oft die Elemente aber fügen keine neuen Elemente hinzu § Wie können wir die Implementation verbessern? (effizienter machen) 79 Listen – das Minimum § Ist der Einsatz eines (internen) «Knotens» (wie ListNode) vorgeschrieben? § Wir könnten einen Array verwenden um die Elemente zu speichern § Dann ist der Zugriff get(index) in konstanter Zeit möglich § Müssen aber (unerwartete) Operation wie add() erlauben 80 index 0 1 2 3 4 5 6 7 get(3) ArrayList<T> § Java stellt die Klasse ArrayList für solche Listenobjekte zur Verfügung § «Array» erinnert daran, dass die Elemente effizient über einen Index erreicht werden können § «List» sagt dass die Anzahl der Elemente unbegrenzt ist (im Prinzip) § Eine ArrayList ist wie ein dynamischer Array (der die Grösse an die Anzahl Elemente anpasst) § Die Implementation basiert auf einem Array und einem Attribut für die aktuelle Grösse (Anzahl Elemente) 81 Später sehen wir wie so eine Klasse implementiert werden kann 10.2 ArrayList <T> 83 ArrayList<T> § Java stellt die Klasse ArrayList für solche Listenobjekte zur Verfügung § Generische Klasse § Diese Listenobjekte können (Verweise auf) Objekte eines deklarierten Typs T speichern § T: Klasse oder Interface 84 ArrayList Methoden add(value) appends value at end of list add(index, value) inserts given value just before the given index, shifting subsequent values to the right clear() removes all elements of the list indexOf(value) returns first index where given value is found in list (-1 if not found) get(index) returns the value at given index remove(index) removes/returns value at given index, shifting subsequent values to the left set(index, value) replaces value at given index with given value size() returns the number of elements in list toString() returns a string representation of the list such as \"[3, 42, -7, 15]\" 85 ArrayList Methoden addAll(list) addAll(index, list) adds all elements from the given list to this list (at the end of the list, or inserts them at the given index) contains(value) returns true if given value is found somewhere in this list containsAll(list) returns true if this list contains every element from given list equals(list) returns true if given other list contains the same elements iterator() listIterator() returns an object used to examine the contents of the list (seen later) lastIndexOf(value) returns last index value is found in list (-1 if not found) remove(value) finds and removes the given value from this list removeAll(list) removes any elements found in the given list from this list retainAll(list) removes any elements not found in given list from this list subList(from, to) returns the sub-portion of the list between indexes from (inclusive) and to (exclusive) toArray() returns the elements in this list as an array 86 Erstellen eines ArrayList Exemplars § Wie bisher ... ArrayList<Type> name = new ArrayList<Type>(); § Wenn wir ein ArrayList Objekt konstruieren (oder eine Referenzvariable deklarieren) dann müssen wir den Typ der Elemente der Liste angeben § Der Typ der Elemente muss zwischen < und > angegeben werden. § Beispiel einer generischen Klasse («generic» class) 8788 ArrayList<Type> name = new ArrayList<Type>(); § Mit einem Typparameter kann die ArrayList Klasse verwendet werden, um Listen für verschiedene Typen zu verwalten § new ArrayList<Type>() erstellt neue ArrayList für Type § Type muss ein Referenztyp sein § Dazu später mehr § Beispiele: ArrayList<String> names = new ArrayList<String>(); names.add(\"ETH Zurich\"); names.add(\"Imperial College\"); 8990 names empty .size() à 0 names.add(\"ETH Zurich\"); ArrayList<String> names = new ArrayList<String>(); 91 names empty .size() à 1 \"ETH Zurich\" ArrayList<String> names = new ArrayList<String>(); names.add(\"Imperial College\"); 92 names empty .size() à 2 \"ETH Zurich\" \"Imperial College\" ArrayList<String> names = new ArrayList<String>(); names.get(0); //\"ETH Zurich\" ArrayList<Type> name = new ArrayList<Type>(); § Beispiele: ArrayList<Point> figureA = new ArrayList<Point>(); Point p = new Point(1,3); figureA.add(new Point()); figureA.add(p); System.out.println(figureA.size()); ArrayList<Shape> figureB = new ArrayList<Shape>(); Shape s = new Circle(); figureB.add(s); figureB.add(new Rectangle()); 94 Java Collections Framework 95 <<Interface> Collection <<Interface> List <<Interface> Set LinkedListArrayList TreeSet <<Interface> SortedSet HashSet Interfaces: Collection, List, Set, … Klassen: ArrayList, LinkedList, HashSet, … Service Klasse: Collections (ähnlich wie Arrays) Wo kann ich mehr erfahren? § Die Java® Platform Version 17 API Specification (nur Framework) enthält Informationen über die Java Umgebung § «Core Java» – Sprache + java.* + jdk.* § Sehr praktisch – wer kann sich schon alle Methoden merken § Konvention für Typparameter § E – Element (häufig im Java Collections Framework) § K – Key (später mehr) § N – Number § T – Type (irgendwo) 9799 https://docs.oracle.com/en/java/javase/17/d ocs/api/java.base/java/util/ArrayList.html Später mehr 100 Supertyp: Collection 101102103104105106 Später mehr Was ist der richtige Weg eine ArrayList list zu erstellen, die ganze Zahlen speichert? (D.h. int i = list.get(k) und list.add(i) sollen möglich sein (k < size) ) 107 Poll Was ist der richtige Weg eine ArrayList list zu erstellen, die ganze Zahlen speichert? (D.h. int i = list.get(k) und list.add(i) sollen möglich sein (k < size) ) § Nur diese Option ist richtig ArrayList<Integer> list = new ArrayList<Integer>(); § Es geht auch ArrayList<Integer> list = new ArrayList<>(); 111 PollArrayList – Methoden § Hinzufügen eines Elements // [\"A\", \"B\", \"C\"] list.add(\"X\"); // [\"A\", \"B\", \"C\", \"X\"] § Einfügen eines Elements list.add(2, \"Y\"); // [\"A\", \"B\", \"Y\", \"C\", \"X\"] § Zugriff auf ein Element String s = list.get(3); // \"C\" § Entfernen eines Elements list.remove(2); // [\"A\", \"B\", \"C\", \"X\"] § Entfernen eines Elements list.remove(\"B\"); // [\"A\", \"C\", \"X\"] 113 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 Beispiel import java.util.ArrayList; public class ListTest { public static void main (String[] args) { ArrayList<String> schools = new ArrayList<String>(); schools.add(\"ETH Zurich\"); schools.add(\"Imperial College\"); schools.add(\"ETH Lausanne\"); for (int i = 0; i < schools.size(); i++) { if (schools.get(i).startsWith(\"ETH\")) { System.out.println(schools.get(i)); } } } } 115 Output: 116 Legale und illegale Indize § Gegeben sei ArrayList<String> names = new ArrayList<String>(); § Index für Zugriff auf ein Element der Liste (z.B. names.get(i)) muss zwischen 0 und (Grösse der Liste – 1) liegen (einschliesslich) § 0 ≤ index ≤ names.size()-1 § 0 ≤ index < names.size() § Ein Zugriff auf ein Element ausserhalb dieses Bereichs hat eine IndexOutOfBoundsException zur Folge. 117 ArrayList<String> names = new ArrayList<String>(); names.add(\"Bob\"); names.add(\"Pete\"); names.add(\"Vicki\"); names.add(\"Sue\"); System.out.println(names.get(0)); // okay: Bob System.out.println(names.get(3)); // okay: Sue System.out.println(names.get(-1)); // exception names.add(9, \"Aimee\"); // exception 118 index 0 1 2 3 value Bob Pete Vicki Sue names.size(): 4names Legale und illegale Indize § Gegeben sei ArrayList<String> names = new ArrayList<String>(); § Beim Einfügen eines Elements muss der (angegebene) Index für das neue Element legal sein names.size(): 3 names.add(3, \"Sue\"); 0 ≤ index ≤ names.size() § Index ausserhalb dieses Bereichs: IndexOutOfBoundsException names.add(9, \"Aimee\"); // exception 119 index 0 1 2 value Bob Pete Vicki index 0 1 2 3 value Bob Pete Vicki Sue ArrayList «Rätsel» ArrayList<Integer> list = new ArrayList<Integer>(); for (int i = 1; i <= 10; i++) { list.add(10 * i); // [10, 20, 30, 40, ..., 100] } § Was gibt dieses Programmsegment aus? for (int i = 0; i < list.size(); i++) { list.remove(i); } System.out.println(list); 122124 ArrayList «Rätsel» ArrayList<Integer> list = new ArrayList<Integer>(); for (int i = 1; i <= 10; i++) { list.add(10 * i); // [10, 20, 30, 40, ..., 100] } § Was gibt dieses Programmsegment aus? for (int i = 0; i < list.size(); i++) { list.remove(i); } System.out.println(list); § Antwort: [20, 40, 60, 80, 100] 126128 [2, 4, 6, 8, 10]Loop ctr i size list.size() ArrayList «Rätsel» 2 ArrayList<Integer> list = new ArrayList<Integer>(); for (int i = 1; i <= 5; i++) { list.add(2 * i); // [2, 4, 6, 8, 10] } § Was gibt dieses Programmsegment aus? int size = list.size(); for (int i = 0; i < size; i++) { list.add(i, 42); // add 42 at index i } System.out.println(list); § Antwort: [42, 42, 42, 42, 42, 2, 4, 6, 8, 10] 130 ArrayList «Rätsel» 3 ArrayList<Integer> list = new ArrayList<Integer>(); for (int i = 1; i <= 5; i++) { list.add(2 * i); // [2, 4, 6, 8, 10] } § Was gibt dieses Programmsegment aus? for (int i = 0; i < list.size(); i++) { list.add(i, 777); // add 777 at index i } System.out.println(list); 131 252-0027 Einführung in die Programmierung 10.0 Generische Programmierung Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016—2021 All rights reserved. Übersicht § 10.1 Einleitung § 10.2 ArrayList<T> § 10.3 Vergleichen von Objekten § 10.4 Mengen § 10.5 Abbildungen § 10.6 Iteratoren und Comparatoren § 10.7 Implementation eines einfachen generischen Typs 2 ArrayList «Rätsel» 3 ArrayList<Integer> list = new ArrayList<Integer>(); for (int i = 1; i <= 5; i++) { list.add(2 * i); // [2, 4, 6, 8, 10] } § Was gibt dieses Programmsegment aus? for (int i = 0; i < list.size(); i++) { list.add(i, 777); // add 777 at index i } System.out.println(list); 45 ArrayList<T> ist ein neuer Typ § Generischer Typ einer Liste von T Elementen § Basiert auf Array unbegrenzter Grösse, dazu Listen Operationen § Kann in der Definition anderer Klassen verwendet werden § Kann als Parameter verwendet werden § Kann als Rückgabewert verwendet werden … § Bequem § Effizienter Zugriff/Einfügen/Entfernen basierend auf Index § Einfügen/Entfernen «verschiebt» Elemente mit höherem Index – Vorsicht 7 ArrayList im Vergleich mit Array § Konstruktion String[] names = new String[5]; ArrayList<String> list = new ArrayList<String>(); § Speichern eines Wertes names[0] = \"Jessica\"; list.add(\"Jessica\"); § Zugriff auf ein Element String s = names[0]; String s = list.get(0); 8 ArrayList im Vergleich mit Array § Zugriff auf alle Elemente die mit «B» anfangen: for (int i = 0; i < names.length; i++) { if (names[i].startsWith(\"B\")) { ... } } for (int i = 0; i < list.size(); i++) { if (list.get(i).startsWith(\"B\")) { ... } } 9 ArrayList im Vergleich mit Array § Prüfen ob der String \"Ben\" dabei ist: for (int i = 0; i < names.length; i++) { if (names[i].equals(\"Ben\")) { ... } } if (list.contains(\"Ben\")) { ... } 10 ArrayList als Attribut von Objekten § Ein Objekt kann (z.B.) eine ArrayList als Attribut haben public class Course { private String[] locations; private ArrayList<String> studentNames; public Course() { locations = new String[5]; studentNames = new ArrayList<String>(); ... } § Jedes Exemplar enthält jetzt (Referenzen auf) § einen Array von String Referenzen § ein Collection Objekt (ArrayList mit Referenzen auf String) 13 ArrayList als Parameter public void name(ArrayList<Type> name) { … } Beispiel: Schreiben Sie eine Methode, die alle Elemente einer ArrayList bearbeitet // Works with all elements of the parameter list public void removeNouns(ArrayList<String> list) { ... } 14 ArrayList als Rückgabewert § Eine Liste kann auch als Ergebnis zurückgegeben werden: ArrayList<Type> methodName(parameter) § Oder auch public ArrayList<Type> methodName(parameter) static ArrayList<Type> methodName(parameter) public static ArrayList<Type> methodName(parameter) § u.s.w. 15 Übung § Schreiben Sie ein Programm das eine Datei (numbers.txt) mit ganzen Zahlen (Anzahl ist unbestimmt) liest § und dann die Zahlen druckt § und dann alle geraden Zahlen (Zahlen die durch 2 ohne Rest teilbar sind) filtert (d.h. entfernt) 16 Lösung (Auszug) ArrayList<Integer> numbers = new ArrayList<Integer>(); Scanner input = new Scanner(new File(\"numbers.txt\")); while (input.hasNextInt()) { int n = input.nextInt(); numbers.add(n); } System.out.println(numbers); 21 Zur Erinnerung § Referenzvariable für Supertyp kann Referenzen auf Subtyp speichern § Supertyp: Interface oder SuperKlasse § Beispiel Boat b = new WaterCar(); Car c = new WaterCar(); WaterCar w = new WaterCar(); Angestelle chefin = new Arzt(); 22 <<interface>> Car start() stop() cruise() setDirection() <<interface>> Boat start() stop() swim() WaterCar start() { ..} stop() { ..} swim() { ..} cruise() { ..} setDirection() { ..} (Generische) Super- und Subtypen § Referenzvariable für Supertyp<E> kann Referenzen auf Subtyp<E> speichern § ArrayList<E> implementiert List<E> § List<E> erweitert Collection<E> § Für das selbe E! § Beispiel Collection<String> = new ArrayList<String>; List<Integer> = new ArrayList<Integer>; 23 <<Interface> Collection<E> <<Interface> List<E> ArrayList<E> Andere Lösung (Auszug) List<Integer> numbers = new ArrayList<Integer>(); Scanner input = new Scanner(new File(\"numbers.txt\")); while (input.hasNextInt()) { int n = input.nextInt(); numbers.add(n); } System.out.println(numbers); 24 Vorsicht § new Operator nur für Klassen, nicht Interfaces § Wenn Klasse X die Klasse B erweitert, dann ist B ein Supertyp für X B b = new X(); aber ArrayList<B> ist kein Supertyp für ArrayList<X> § ArrayList<B> kann als Element(e) Exemplare der Klasse X enthalten 25 B X Übung § Schreiben Sie ein Programm das eine Datei mit ganzen Zahlen (Anzahl ist unbestimmt) liest § und dann die Zahlen druckt § und dann alle geraden Zahlen (Zahlen die durch 2 ohne Rest teilbar sind filtert (d.h. entfernt) 26 Lösung (Auszug) List<Integer> numbers = new ArrayList<Integer>(); Scanner input = new Scanner(new File(\"numbers.txt\")); while (input.hasNextInt()) { int n = input.nextInt(); numbers.add(n); } System.out.println(numbers); filterEven(numbers); System.out.println(numbers); 27 Lösung (Auszug) // Removes all elements w/ even values from the list. public static void filterEven(List<Integer> list) { for (int i = list.size() - 1; i >= 0; i--) { int n = list.get(i); if (n % 2 == 0) { list.remove(i); } } } 2930 Übung § Schreiben Sie eine Methode addStars die eine ArrayList von Strings als Parameter hat und einen * (genauer \"*\") nach jedem Element einfügt. § Beispiel : Wenn die ArrayList list am Anfang enthält: [die, schnelle, graue, Schlange] § Dann ist der Effekt des Aufrufs addStars(list) diese Liste: [die, *, schnelle, *, graue, *, Schlange, *] 32 Lösungen public static void addStars(ArrayList<String> list) { for (int i = 0; i < list.size(); i += 2) { list.add(i+1, \"*\"); } } 33 Lösungen public static void addStars(ArrayList<String> list) { for (int i = 0; i < list.size(); i += 2) { list.add(i+1, \"*\"); } } 34 § Schreiben Sie eine Methode removeStars die eine ArrayList von Strings als Parameter hat in der jedes zweite Element der String \"*\" ist, und entfernen Sie diese Sterne (machen also den Effekt der Methode addStars rückgängig). 35 Lösungen public static void removeStars(ArrayList<String> list) { for (int i = 0; i < list.size(); i += 2) { list.add(i+1, \"*\"); } } 36 Lösungen public static void addStars(ArrayList<String> list) { for (int i = 0; i < list.size(); i += 2) { list.add(i+1, \"*\"); } } public static void removeStars(ArrayList<String> list) { for (int i = 1; i < list.size(); i++) { list.remove(i); } } 37 Übung § Schreiben Sie eine Methode intersect die zwei ArrayListen mit ganzen Zahlen als Parameter akzeptiert und eine neue ArrayList zurückgibt, die nur die Elemente enthält, die in beiden Listen vorhanden sind. § Beispiel: list1 und list2 enthalten: [1, 4, 8, 9, 11, 15, 17, 28, 41, 59] [4, 7, 11, 17, 19, 20, 23, 28, 37, 59, 81] § Dann ergibt der Aufruf von intersect(list1, list2) die Liste: [4, 11, 17, 28, 59] 39 Lösung (Teil 1) ArrayList<Integer> list1 = new ArrayList<Integer>(); Scanner input = new Scanner(new File(\"list1.txt\")); while (input.hasNext()) { int i = input.nextInt(); list1.add(i); } ArrayList<Integer> list2 = new ArrayList<Integer>(); input = new Scanner(new File(\"list2.txt\")); while (input.hasNext()) { int i = input.nextInt(); list2.add(i); } 40424344 Lösung (Teil 2) ArrayList<Integer> intersect(ArrayList<Integer> list1, ArrayList<Integer> list2) { ArrayList<Integer> list3 = new ArrayList<Integer>(); list3.addAll(list1); list3.retainAll(list2); return list3; } 45 Andere Übungen § Schreiben Sie eine Methode reverse die die Reihenfolge der Elemente einer ArrayList für Strings umkehrt. § Schreiben Sie eine Methode capitalizeAdverbs die als Parameter eine ArrayList von String Objekten entgegen nimmt und jedes Wort eines englischen Textes, das mit «ly» endet, mit Grossbuchstaben schreibt. 46 Eine andere Aufgabe Schreiben Sie ein Programm das eine Datei Wort für Wort einliest und die Wörter der Datei als Liste speichert. 1. Zuerst sollen Sie alle eingelesenen Wörter ausgeben. 2. Dann sollen Sie alle Wörter in der umgekehrten Reihenfolge ausgeben. 3. Dann geben Sie alle Substantive (fangen mit Grossbuchstaben an) in Grossbuchstaben aus. § Also Haus à HAUS 4. Dann geben Sie alle Wörter ohne die Substantive aus 47 Lösung (Gerüst) import java.util.*; import java.io.* ; public class Example1 { public static void main(String[] args) throws FileNotFoundException { ArrayList<String> allWords = new ArrayList<String>(); Scanner input = new Scanner(new File(\"words.txt\")); while (input.hasNext()) { String word = input.next(); allWords.add(word); } System.out.println(allWords); } } 49 Lösung (Gerüst) import java.util.*; import java.io.* ; public class Example1 { public static void main(String[] args) throws FileNotFoundException { ArrayList<String> allWords = new ArrayList<String>(); Scanner input = new Scanner(new File(\"words.txt\")); while (input.hasNext()) { String word = input.next(); allWords.add(word); } System.out.println(allWords); } } 50 Teil 2 Schreiben Sie ein Programm das eine Datei Wort für Wort einliest und die Wörter der Datei als Liste speichert. 1. Zuerst sollen Sie alle eingelesenen Wörter ausgeben. ✅ 2. Dann sollen Sie alle Wörter in der umgekehrten Reihenfolge ausgeben. 3. Dann geben Sie alle Substantive (fangen mit Grossbuchstaben an) in Grossbuchstaben aus. § Also Haus à HAUS 4. Dann geben Sie alle Wörter ohne die Substantive aus 51 Lösung (Ausschnitt) public static void main(String[] args) throws FileNotFoundException { ArrayList<String> allWords = new ArrayList<String>(); Scanner input = new Scanner(new File(\"words.txt\")); ... for (int i = allWords.size()-1; i >= 0; i-- ) { System.out.println(allWords.get(i)); } } 52 Teil 3 Schreiben Sie ein Programm das eine Datei Wort für Wort einliest und die Wörter der Datei als Liste speichert. 1. Zuerst sollen Sie alle eingelesenen Wörter ausgeben. ✅ 2. Dann sollen Sie alle Wörter in der umgekehrten Reihenfolge ausgeben. ✅ 3. Dann geben Sie alle Substantive (fangen mit Grossbuchstaben an) in Grossbuchstaben aus. § Also Haus à HAUS 4. Dann geben Sie alle Wörter ohne die Substantive aus 53 ➡ 5455 Lösung (Ausschnitt) public static void main(String[] args) throws FileNotFoundException { ArrayList<String> allWords = new ArrayList<String>(); Scanner input = new Scanner(new File(\"words.txt\")); ... for (int i=0; i < allWords.size(); i++ ) { String s = allWords.get(i); if (Character.isUpperCase(s.charAt(0))) { System.out.println(s.toUpperCase()); } } } 56 Teil 4 § Schreiben Sie ein Programm das eine Datei Wort für Wort einliest und die Wörter der Datei als Liste speichert. 1. Zuerst sollen Sie alle eingelesenen Wörter ausgeben. ✅ 2. Dann sollen Sie alle Wörter in der umgekehrten Reihenfolge ausgeben. ✅ 3. Dann geben Sie alle Substantive (fangen mit Grossbuchstaben an) in Grossbuchstaben aus. ✅ § Also Haus à HAUS 4. Dann geben Sie alle Wörter ohne die Substantive aus 57 Lösung (Ausschnitt) public static void main(String[] args) throws FileNotFoundException { ArrayList<String> allWords = new ArrayList<String>(); Scanner input = new Scanner(new File(\"words.txt\")); ... for (int i=0; i < allWords.size(); i++ ) { String s = allWords.get(i); if (!Character.isUpperCase(s.charAt(0))) { System.out.println(s); } } } 58 Eine (leicht) veränderte Aufgabe Schreiben Sie ein Programm das eine Datei Wort für Wort einliest und die Wörter der Datei als Liste speichert. 1. Zuerst sollen Sie alle eingelesenen Wörter ausgeben. 2. Dann sollen Sie alle Wörter in der umgekehrten Reihenfolge ausgeben. 3. Dann geben Sie alle Substantive (fangen mit Grossbuchstaben an) in Grossbuchstaben aus. § Also Haus à HAUS 4. Entfernen Sie alle Substantive und geben Sie die übriggebliebenen Wörter aus 59 ArrayList als Parameter // Removes all nouns from the given list public static void removeNouns(ArrayList<String> list) { for (int i = 0; i < list.size(); i++ ) { String s = list.get(i); if (Character.isUpperCase(s.charAt(0))) { list.remove(i); i--; } } } 6062 \"ein\" \"die\" \"Aar\" \"Hut\" \"der\" \"Ei\" \"das\"size() counter i 7 0 0 1 2 3 4 5 6 7 1 0 1 2 3 4 5 6 7 2 T 0 1 2 3 4 5 6 \"ein\" \"die\" \"Hut\" \"der\" \"Ei\" \"das\" 6 3 0 1 2 3 4 5 6 4 T 0 1 2 3 4 5 \"ein\" \"die\" \"Hut\" \"der\" \"das\" 5 5 0 1 2 3 4 // Removes all nouns from the given list public static void removeNouns(ArrayList<String> list) { for (int i = 0; i < list.size(); i++ ) { String s = list.get(i); if (Character.isUpperCase(s.charAt(0))) { list.remove(i); i--; // don't overlook shifted element! } } } § Warum müssen wir i in der Schleife dekrementieren? § Ändert sich list.size() während der Ausführung der Schleife? 6364 \"ein\" \"die\" \"Aar\" \"Hut\" \"der\" \"Ei\" \"das\"size() counter i 0 1 2 3 4 5 6 65 \"ein\" \"die\" \"Aar\" \"Hut\" \"der\" \"Ei\" \"das\"size() counter i 7 0 0 1 2 3 4 5 6 7 1 0 1 2 3 4 5 6 7 2 T 0 1 2 3 4 5 6 \"ein\" \"die\" \"Hut\" \"der\" \"Ei\" \"das\" 6 2 0 1 2 3 4 5 6 2 T 0 1 2 3 4 5 \"ein\" \"die\" \"der\" \"Ei\" \"das\" 5 2 0 1 2 3 4 i--; à i == 1 i++; à i ==2 … // remove all nouns public static void removeNouns(ArrayList<String> list) { for (int i = 0; i < allWords.size(); i++ ) { String s = allWords.get(i); if (Character.isUpperCase(s.charAt(0))) { allWords.remove(i); i--; // don't overlook shifted element! } } § Vorsicht bei Veränderungen der Liste 66 static void mix(ArrayList<String> list) { for (int i = list.size()-1; i >= 0; i--) { if (i % 2 == 0 ) { list.add(list.get(i)); } else { list.add(0, list.get(i)); } } System.out.println(list); } 71 Poll§ Was ist die Ausgabe von mix mit Parameter [ \"t\", \"o\", \"r\"] (eine ArrayList<String>) ? 72 static void mix(ArrayList<String> list) { for (int i = list.size()-1; i >= 0; i--) { if (i % 2 == 0 ) { list.add(list.get(i)); } else { list.add(0, list.get(i)); } } System.out.println(list); } Poll§ Was ist die Ausgabe von mix mit Parameter [ \"t\", \"o\", \"r\"] (eine ArrayList<String>) ? § Antwort [o, t, o, r, r, o] 74 static void mix(ArrayList<String> list) { for (int i = list.size()-1; i >= 0; i--) { if (i % 2 == 0 ) { list.add(list.get(i)); } else { list.add(0, list.get(i)); } } System.out.println(list); } Poll 75 Antwort Prozent otorro 72 63.16% otorrt 11 9.65% ootorr 6 5.26% totorr 5 4.39% rot 3 2.63% other 17 14.91% Andere … 0torr0 torrttt or, rto, … OOTORRT 76 \"t\" \"o\" \"r\" size() counter i 0 1 2 3 4 5 Poll 3 2 i%2==0 Insert Position : String T Ende: r \"t\" \"o\" \"r\" \"r\" 4 1 F 0: o \"o\" \"t\" \"o\" \"r\" \"r\" 5 0 T Ende: o \"o\" \"t\" \"o\" \"r\" \"r\" \"o\" 10.3 Vergleichen von Objekten 82 Die compareTo Methode § Um das Vergleichen von Exemplaren zu ermöglichen sollte eine Java Klasse eine Methode compareTo definieren, die auf der Menge der Exemplare eine (totale) Ordnungs- relation ≤ definiert § Diese erlaubt es dann zwei Exemplare zu vergleichen. § A ≤ B oder B ≤ A § A ≤ B und B ≤ A: A = B § Beispiel: in der String Klasse gibt es die Methode public int compareTo(String other) 83 compareTo für String § Beispiel: in der String Klasse gibt es die Methode public int compareTo(String other) § Ein Aufruf someS.compareTo(otherS) liefert: einen Wert < 0 wenn someS «vor» otherS in der Ordnungsrelation ist, einen Wert > 0 wenn someS «nach» otherS in der Ordnungsrelation ist, einen Wert > 0 wenn someS und otherS in der Ordnungsrelation «gleich» sind 84 Gebrauch von compareTo § compareTo kann im Test einer if Anweisung gebraucht werden. String a = \"alice\"; String b = \"bob\"; if (a.compareTo(b) < 0) { // true ... } 8687 Gebrauch von compareTo Primitive Type Objects if (a < b) { ... if (a.compareTo(b) < 0) { ... if (a <= b) { ... if (a.compareTo(b) <= 0) { ... if (a == b) { ... if (a.compareTo(b) == 0) { ... if (a != b) { ... if (a.compareTo(b) != 0) { ... if (a >= b) { ... if (a.compareTo(b) >= 0) { ... if (a > b) { ... if (a.compareTo(b) > 0) { ... compareTo und Collections § Die Methode für binäre Suche (binarySearch) funktioniert für die Klasse Arrays da diese Methode (intern) die compareTo Methode aufruft. String[] a = {\"al\", \"bob\", \"cari\", \"dan\", \"mike\"}; int index = Arrays.binarySearch(a, \"dan\"); // 3 § Auch sortieren ist deswegen möglich String [] s = {\"my\", \"dog\", \"has\", \"fleas\"}; Arrays.sort(s); System.out.println(Arrays.toString(s)); § Output: [dog, fleas, has, my] 8889 This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. § Arrays hilft bei Arrays mit beliebigen Objekten. Aber wie können wir mit einer ArrayList arbeiten? § Wie die Klasse Arrays gibt es auch eine Klasse Collections die nützliche Methoden für Collections enthält 9091 ⚠ Unvollständig § Wie die Klasse Arrays gibt es auch eine Klasse Collections die nützliche Methoden für Collections enthält § z.B. sort § Braucht compareTo um die Elemente der ArrayList zu vergleichen § Wollen ArrayList<A> mit Elementen der Klasse A sortieren § Wir müssen 2 Fälle unterscheiden: § Klasse A (der Elemente der ArrayList) enthält compareTo § Entweder von Entwickler definiert oder geerbt § Klasse A enthält compareTo nicht automatisch 92 § Fall 1: Die Elemente der ArrayList stellen compareTo automatisch zur Verfügung String [] s = {\"my\", \"dog\", \"has\", \"fleas\"}; ArrayList<String> list = new ArrayList<String>(); for (int i = 0; i < s.length; i++) { list.add(new String(s[i])); } Collections.sort(list); System.out.println(list); § Output: [dog, fleas, has, my] 93 § Fall 1: Die Elemente der ArrayList stellen compareTo automatisch zur Verfügung String [] s = {\"my\", \"dog\", \"has\", \"fleas\"}; ArrayList<String> list = new ArrayList<String>(Arrays.asList(s)); for (int i = 0; i < s.length; i++) { list.add(new String(s[i])); } Collections.sort(list); System.out.println(list); § Output: [dog, fleas, has, my] 94 § Wie können wir mit einer ArrayList mit Exemplaren einer beliebigen Klasse arbeiten? § Fall 2: Selbstdefinierte Klassen – diese stellen compareTo nicht automatisch zur Verfügung Beispiel: Wir halten zu jedem Wort die Position des ersten Auftretens in einem Text fest public class Word { String item; int position; int count; ... } 95 Beispiel: Wir halten zu jedem Wort die Position des ersten Auftretens in einem Text fest public class Word { String item; int position; int count; Word(String s) { item = s; } Word(String s, int p) { item = s; position = p; } } 97 ArrayList<Word> list0; list0 = new ArrayList<Word>(); list0.add(new Word(\"bob\", 17)); list0.add(new Word(\"alice\", 35)); § Wie können wir mit einer ArrayList mit Exemplaren einer beliebigen Klasse arbeiten? § Fall 2: Selbstdefinierte Klassen String [] s = {\"my\", \"dog\", \"has\", \"fleas\"}; ArrayList<Word> list1 = new ArrayList<Word>(); for (int i=0; i<s.length; i++) { list1.add(new Word(s[i], i)); } Collections.sort(list1); 101 Sieht gut aus, aber wird nicht übersetzt //javac Example7aa.java Example7aa.java:15: cannot find symbol symbol : method sort(java.util.ArrayList<Word>) location: class java.util.Collections Collections.sort(list1); ^ 1 error 102 Selbstdefinierte Typen ordnen § Wir können eine beliebige ArrayList nicht sortieren da Java nicht weiss, wie die Elemente zu ordnen sind. § Unsere Klasse (Word) muss klar machen, wie die Elemente geordnet sind § Dafür gibt es ein Interface das compareTo enthält 103 Comparable<E> public interface Comparable<E> { public int compareTo(E other); } § Eine Klasse kann das Interface Comparable implementieren und so eine natürliche Ordnung für ihre Exemplare definieren. § Natürliche Ordnung: es gibt nur eine Ordnungsrelation § Wenn wir mehrere Relationen zulassen wollen dann wird es komplizierter 104 Comparable § Ein Aufruf someE.compareTo(otherE) liefert: einen Wert < 0 wenn someE «vor» otherE in der OrdnungsrelaQon ist, einen Wert > 0 wenn someE «nach» otherE in der OrdnungsrelaQon ist, einen Wert > 0 wenn someE und otherE in der OrdnungsrelaQon «gleich» sind 106 Comparable Muster public class nameC implements Comparable<nameC> { ... public int compareTo(nameC other) { ... } } 107 Comparable Beispiel class Word implements Comparable<Word> { String item; int position; int count; … //constructor(s) public int compareTo(Word otherword) { String compareItem = otherword.item; return (item.compareTo(compareItem)); } } 110 list1.get(0).compareTo(list1.get(1)) 123 // > 0 Comparable Beispiel – andere Ordnung class Word implements Comparable<Word> { String item; int position; int count; … //constructor(s) public int compareTo(Word otherword) { int comparePosition = otherword.position; return (position - comparePosition); } } 111 list1.get(0).compareTo(list1.get(1)) -456 // < 0 Comparable Beispiel class Word implements Comparable<Word> { String item; int position; int count; Word(String s) { item = s; } Word(String s, int p) { item = s; position = p; } public int compareTo(Word ow) { int cp = ow.position; return (position - cp); } } 112 import java.util.ArrayList; public class Example2 { public static void main(String[] args) { ArrayList<Word> list1; list1 = new ArrayList<Word>(); list1.add(new Word(\"bob\", 17)); list1.add(new Word(\"alice\", 35)); Word w1 = list1.get(0); Word w2 = list1.get(1); if (w1.compareTo(w2) > 0) { System.out.println(\"Groesser:\"); } else { System.out.println(\"Kleiner:\"); } } } Comparable Beispiel § Was wenn wir jetzt die Exemplare sowohl nach der Position oder der Häufigkeit ordnen wollen? § Dann hätten wir drei mögliche Ordnungsrelationen 1. Lexikographisch auf Grund des Namens 2. Nach Häufigkeit (falls count diese festhält) 3. Nach der Position des 1. Auftretens § Geht auch aber dazu müssen wir ein besonderes Objekt konstruieren, einen Comparator<T> § Später 114 Aufgabe § Sie erinnern sich an die Klasse Point 115 Klasse Point public class Point { private int x; private int y; // Constructs a Point at the given x/y location. public Point(int initialX, int initialY) { x = initialX; y = initialY; } // Methods ... } 116 Aufgabe § Sie erinnern sich an die Klasse Point § Wir wollen die Point Exemplare sortieren können § Das X Attribut entscheidet, ob ein Point vor einem anderen ist, und wenn die X Attribute gleich sind, dann entscheidet das Y Attribut 117 Aufgabe § Sie erinnern sich an die Klasse Point § Wir wollen die Point Exemplare sortieren § point1 «vor» point2 wenn § point1.x < point2.x oder § point1.x == point2.x und point1.y < point2.y § point1 «nach» point2 wenn § point1.x > point2.x oder § point1.x == point2.x und point1.y > point2.y § sonst point1 «gleich» point2 119 compareTo für Point § Ein Aufruf A.compareTo(B) liefert: einen Wert < 0 wenn A «vor» B in der Ordnungsrelation ist, einen Wert > 0 wenn A «nach» B in der Ordnungsrelation ist, einen Wert > 0 wenn A und B in der Ordnungsrelation «gleich» sind 120 Comparable Beispiel public class Point implements Comparable<Point> { private int x; private int y; // unchanged // must implement compareTo(Point other) } 122 Comparable für Point // sort by x and break ties by y public int compareTo(Point other) { if (x < other.x) { return -1; } else if (x > other.x) { return 1; } else if (y < other.y) { return -1; // same x, smaller y } else if (y > other.y) { return 1; // same x, larger y } else { return 0; // same x and same y } } 123 compareTo Diskussion § Subtraktion – Manchmal kann man durch Subtraktion entsprechender Werte den für compareTo gewünschten Rückgabewert erhalten: // sort by x and break ties by y public int compareTo(Point other) { if (x != other.x) { return x - other.x; // different x } else { return y - other.y; // same x; compare y } } § Müssen sicher sein dass es keinen Overflow/Underflow gibt124 compareTo Diskussion § Subtraktion – Manchmal kann man durch Subtraktion entsprechender Werte den für compareTo gewünschten Rückgabewert erhalten: § Die Idee: § if x > other.x, then x - other.x > 0 § if x < other.x, then x - other.x < 0 § if x == other.x, then x - other.x == 0 § Achtung: Dieser Weg funktioniert nicht für reelle Zahlen (doubles) aber siehe Math.signum(double) 125 compareTo Diskussion § Stal einer Subrakmon kann man auch Integer.compare(int1, int2) § verwenden (funkmoniert auch bei grossen int Werten) // sort by x and break ties by y public int compareTo(Point other) { if (x != other.x) { return Integer.compare(x, other.x); // different x } else { return Integer.compare(y, other.y); // same x; compare y } } 126 compareTo Diskussion § compareTo für eine Klasse K ist konsistent mit equals wenn ∀ Exemplare e1 und e2 von K gilt e1.compareTo(e2)==0 ergibt den selben (booleschen) Wert wie e1.equals(e2) § Empfehlung: compareTo sollte mit equals konsistent sein § Keine Bedingung – aber eine gute Empfehlung der Java Entwickler § Achtung: Bedingung für ∀ e1,e2 der Klasse K aber null ist nicht Exemplar von K, daher kann e1.compareTo(null) eine NullPointerException werfen, hingegen e1.equals(null) ergibt false 127 Fine PointcompareTo Diskussion § toString - Wenn die toString Darstellung der Exemplare der Ordnungsrelation entspricht, dann können wir so vergleichen: // sort by date, e.g. \"09/19\" > \"04/01\" public int compareTo(Date other) { return toString().compareTo(other.toString()); } § Delegation – Wenn die Exemplare Attribute haben, die verglichen werden können (z.B. Strings) dann kann man deren compareTo Methode verwenden : // sort by employee name, e.g. \"Jim\" < \"Susan\" public int compareTo(Employee other) { return name.compareTo(other.getName()); } 128 compareTo und Collections Framework § Die Methode compareTo (im Interface Comparable<E>) ist zweckmässig für die Klassen, deren Exemplare wir in einer ArrayList<E> speichern und vergleichen wollen § z.B. um die Elemente zu sortieren § … in einer List speichern wollen § d.h. einer Klasse, die das List<E> Interface implementiert § Bisher kennen wir nur ArrayList<E> § … in einem Array speichern wollen 129130 d.h. Vergleich mittels compareTo d.h. sortiert eine Liste (die das List Interface implementiert) für Elemente eines Typs der compareTo entweder definiert oder erbt Integer b1 = 12; Integer b2 = 7; Was ergibt b1.compareTo(b2)? Answer 1: 0 (int Wert) Answer 2: int Wert > 0 Answer 3: int Wert < 0 Answer 4: true Answer 5: false Answer 6: 0 (Integer) Answer 7: Integer mit Wert > 0 Answer 8: Integer mit Wert < 0 Answer 9: Etwas anderes 133 String s1 = b1.toString(); String s2 = b2.toString(); Was ergibt s1.compareTo(s2)? Answer 1: 0 (int Wert) Answer 2: int Wert > 0 Answer 3: int Wert < 0 Answer 4: true Answer 5: false Answer 6: 0 (Integer) Answer 7: Integer mit Wert > 0 Answer 8: Integer mit Wert < 0 Answer 9: Etwas anderes Poll Integer b1 = 12; Integer b2 = 7; Was ergibt b1.compareTo(b2) ? Answer 1: 0 (int Wert) Answer 2: int Wert > 0 Answer 3: int Wert < 0 Answer 4: true Answer 5: false Answer 6: 0 (Integer) Answer 7: Integer mit Wert > 0 Answer 8: Integer mit Wert < 0 Answer 9: Etwas anderes 134 Poll String s1 = b1.toString(); String s2 = b2.toString(); Was ergibt s1.compareTo(s2) ? Answer 1: 0 (int Wert) Answer 2: int Wert > 0 Answer 3: int Wert < 0 Answer 4: true Answer 5: false Answer 6: 0 (Integer) Answer 7: Integer mit Wert > 0 Answer 8: Integer mit Wert < 0 Answer 9: Etwas anderes 135 Poll 138 53 % 5 % 9 % 15 % 7 % 58 % in ML D 28 42 % Live Stream 149 total ArrayList<T> ist ein neuer Typ § Generischer Typ einer Liste von T Elementen § Basiert auf Array unbegrenzter Grösse, dazu Listen Operationen § Kann in der Definition anderer Klassen verwendet werden § Kann als Parameter verwendet werden § Kann als Rückgabewert verwendet werden … § Bequem § Effizienter Zugriff/Einfügen/Entfernen basierend auf Index § Einfügen/Entfernen «verschiebt» Elemente mit höherem Index – Vorsicht 139 Comparable<T> wichtiges Interface § Erfordert Implementation von compareTo(E other) § Erlaubt Vergleichen von Exemplaren der Klasse T § Ermöglicht dadurch diverse Service Operationen der Klasse Collections § Sortieren: sort(List<T> list) § Zählen: frequency(Collection<?> c, Object o) 140 252-0027 Einführung in die Programmierung 10.0 Generische Programmierung Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016—2021 All rights reserved. Ergebnisse Bonusaufgaben 6 Bonus U04 U05 U06 U07 U08 Studierende (IDs) 598 599 602 602 602 > 0.00 Punkte 448 358 440 439 379 > 4.00 Punkte 297 244 376 417 308 Durchschnitt 3.12 2.48 3.42 4.69 2.77 Durchschnitt (wenn > 0) 4.16 4.15 4.67 4.69 4.40 Übersicht § 10.1 Einleitung § 10.2 ArrayList<Type> § 10.3 Vergleichen von Objekten § 10.4 Mengen § 10.5 Abbildungen § 10.6 Iteratoren und Comparatoren § 10.7 Implementation eines einfachen generischen Typs 7 Mengen § Menge («set»): Eine Sammlung eindeutiger und einzigartiger Elemente (d.h., wir können für zwei beliebige Elemente feststellen, ob sie gleich oder ungleich sind und es gibt keine Duplikate) für die folgende Operationen ausgeführt werden können: § Hinzufügen («add»), Entfernen («remove»), Suche («contains») § Bei einer Menge erwarten wir keinen Zugriff über einen Index und eine Reihenfolge spielt keine Rolle 8 Mengen § Menge («set»): Eine Sammlung eindeutiger und einzigartiger Elemente (d.h., wir können für zwei beliebige Elemente feststellen, ob sie gleich oder ungleich sind und es gibt keine Duplikate) für die folgende Operationen ausgeführt werden können: § Hinzufügen («add»), Entfernen («remove»), Suche («contains») § Bei einer Menge erwarten wir keinen Zugriff über einen Index und eine Reihenfolge spielt keine Rolle 910 set.contains(\"to\") true set.contains(\"be\") false Menge (set) \"the\" \"of\" \"from\" \"to\" \"she\" \"you\" \"him\"\"why\" \"in\" \"by\" \"down\" \"if\" § Elemente einer Menge: Referenztyp! § Keine Basistypen (int, double, …) § Typ entscheidet wie Exemplare erstellt werden § Integer: Integer a = Integer.valueOf(5); § Integer b = Integer.valueOf(5); § // oft [nicht immer] selbes Exemplar wie a § String: String s = \"Hello\"; § String t = \"Hello\"; § // oft [nicht immer] selbes Exemplar wie s § Aber s.equals(t) und a.equals(b) immer true – daher ist \"hallo\" bzw. 5 nur einmal im Set 11 Menge(n) § Kein Zugriff via Index (wie für ArrayList) § Um auf ein Element zuzugreifen müssen wir es zuerst finden (d.h. suchen ist wichtig) § Keine Duplikate § Auch hinzufügen erfordert eine Suche (denn wir müssen feststellen ob das Element schon in der Menge ist) § Auch für ArrayList ist suchen möglich – mussten dann alle Elemente inspizieren (d.h. O(N)) – geht es für Mengen besser?? 13 Interface Set § Enthält die für Mengen wichtigen Operationen § Abstrakte Methoden § Keinen konkreten Methoden § Frage: «für ArrayList O(N) – geht es für Mengen besser??» kann nur von Implementationen (des Interfaces) beantwortet werden 14 Set Implementierungen § Set wird (unter anderem) durch die Klassen HashSet und TreeSet implementiert § Die Unterschiede diskutieren wir gleich § Polymorphe Methoden akzeptieren (möglichst) viele Klassen § Klassen einer Vererbungshierarchie oder Klassen mit Interface § In Java können Mengen durch Klassen, die das Set Interface (aus java.util) implementieren, realisiert werden § Daher (wo sinnvoll) das Interface (Set) als Parametertyp verwenden § Methode für alle Arten von Mengen 15 Set Implementierungen § Verwenden andere Datenstrukturen (nicht Arrays oder verknüpfte Listenelemente) § Sonst wieder O(N)! § TreeSet: Implementierung basiert auf einem «binären Baum» § Zugriff ist ziemlich schnell: O(log N) für alle Operationen § Elemente sind sortiert gespeichert 16 TreeSet<E> braucht Ordnungsrelation § Java's TreeSet braucht intern compareTo um eine Ordnung zu definieren String[] a = {\"dan\", \"al\", \"mike\", \"cari\", \"bob\"}; Set<String> set = new TreeSet<String>(); for (int i = 0; i < a.length; i++) { set.add(a[i]); } System.out.println(set); //natural order //Output: [al, bob, cari, dan, mike] 17 Set Implementierungen § Verwenden andere Datenstrukturen (nicht Arrays oder verknüpfte Listenelemente) § TreeSet: Implementierung basiert auf einem «binären Baum» § HashSet: Implementierung basiert auf einem «hash table» mit einem Array der schnelle Zugriffe erlaubt : O(1) für alle Operationen (mit bestimmten Annahmen) § Elemente werden in irgendeiner (nicht bekannten) Reihenfolge gespeichert § Kein compareTo() nötig (aber erlaubt …) 18 HashSet<E> ohne Ordnungsrelation § Java's HashSet speichert Werte in einer beliebigen Reihenfolge String[] a = {\"dan\", \"al\", \"mike\", \"cari\", \"bob\"}; Set<String> set = new HashSet<String>(); for (int i = 0; i < a.length; i++) { set.add(a[i]); } System.out.println(set); //some order //Output: [dan, bob, mike, al, cari] 19 Hashtable (nur die Idee …) § HashTree<E> unterhält einen Array HA der Länge K § Die Array Elemente nennen wir Buckets («Eimer») – im Unterschied zu den Elementen des Hashtables § Jeder Bucket verweist auf eine Liste von Elementen (vom Typ E) § Wenn ein Element S im HashTree gespeichert werden soll, so berechnen wir für S einen Wert zwischen 0 .. (K-1) § Index in den Array HA – genannt der «hash» von S § Nehmen wir als Beispiel HashTree<String>, K = 256 § hash(\"John Smith\")à 152, hash(\"Lisa Smith\")à 1, … 20 Hash Table (nur die Idee …) 21 x From: https://en.wikipedia.org/wiki/Hash_table Hashtable (nur die Idee …) § Solange die Hashfunktion für jeden String einen anderen Index liefert ist der Zugriff einfach § Vorausgesetzt die Hashfunktion braucht nicht zu lange … § O(1) Schritte § Sollte die Hashfunktion aber für S1 und S2 den selben Index liefern, so haben wir eine Kollision § hash(\"John Smith\")à 152, hash(\"Sandra Dee\")à 152 § Deshalb verweist jeder Bucket auf eine Liste – und S1 und S2 sind in der Liste gespeichert § In der Liste O(n) – aber die Liste hat vielleicht nur 2 .. 4 Elemente 22 Hash Table (nur die Idee …) 23From: https://en.wikipedia.org/wiki/Hash_table Set Implementierungen § Manchmal braucht man aber schnellen Zugriff und die Reihenfolge, in der Elemente zur Menge hinzugefügt wurden § LinkedHashSet: Zugriff schnell O(1), speichert Elemente in der Reihenfolge in der sie zur Menge hinzugefügt wurden. 25 Java Collections Framework 26 <<Interface> Collection <<Interface> List <<Interface> Set LinkedListArrayList TreeSet <<Interface> SortedSet HashSet LinkedHashSet Set Objekte § Wie für ArrayList<E> können wir Exemplare der Klassen TreeSet<E> und HashSet<E> erstellen § E muss ein Referenztyp sein § Brauchen (oft) auch passende Referenzvariable Set<Integer> set1 = new TreeSet<Integer>(); // empty Set<String> set2 = new HashSet<String>(); // empty § Referenzvariable vom Typ Set<String> kann auf Exemplare der Klassen TreeSet<String> und HashSet<String> verweisen 27 Set Objekte § Defaultkonstruktor liefert die leere Menge; andere erstellen die Menge basierend auf einer anderen Collection. Set<Integer> set1 = new TreeSet<Integer>(); // empty Set<String> set2 = new HashSet<String>(list); // init § Muss List<String> list = new ArrayList<String>() geben § Auch geht TreeSet<Integer> set1 = new TreeSet<Integer>(); HashSet<String> set2 = new HashSet<String>(list); 28 Set Objekte § Defaultkonstruktor liefert die leere Menge, andere erstellen die Menge basierend auf einer anderen Collection. Set<Integer> set1 = new TreeSet<Integer>(); // empty Set<String> set2 = new HashSet<String>(list); // init § Muss List<String> list = new ArrayList<String>() geben § Nicht geht Set<Integer> set1 = new TreeSet<String>(); Set<String> set2 = new HashSet<Integer>(list); 29 Set Methoden 30 add(value) adds the given value to the set contains(value) returns true if the given value is found in this set remove(value) removes the given value from the set clear() removes all elements of the set isEmpty() returns true if the set's size is 0 toString() returns a string such as \"[3, 42, -7, 15]\" Beispiel Set<String> names = new TreeSet<String>(); names.add(\"MIT\"); names.add(\"ETH Zuerich\"); names.add(\"Imperial College\"); names.add(\"EPFL\"); names.add(\"Imperial College\"); System.out.println(names); 31[EPFL, ETH Zuerich, Imperial College, MIT] 32 Beispiel Set<String> names = new TreeSet<String>(); System.out.println(names.add(\"MIT\")); System.out.println(names.add(\"ETH Zuerich\")); System.out.println(names.add(\"Imperial College\")); System.out.println(names.add(\"EPFL\")); System.out.println(names.add(\"Imperial College\")); 33 Operationen mit Mengen addAll(collection) adds all elements from the given collection to this set containsAll(coll) returns true if this set contains every element from given set equals(set) returns true if given other set contains the same elements iterator() returns an object used to examine set's contents (später mehr) removeAll(coll) removes all elements in the given collection from this set retainAll(coll) removes elements not found in given collection from this set toArray() returns an array of the elements in this set addAll retainAll removeAll 34 Mengen und Ordnungsrelationen § HashSet : Elemente sind in irgendeiner Reihenfolge gespeichert Set<String> names = new HashSet<String>(); names.add(\"Jake\"); names.add(\"Robert\"); names.add(\"Marisa\"); names.add(\"Kasey\"); System.out.println(names); // [Kasey, Robert, Jake, Marisa] 35 Mengen und Ordnungsrelationen § TreeSet : Elemente gemäss compareTo Ordnung gespeichert Set<String> names = new TreeSet<String>(); names.add(\"Jake\"); names.add(\"Robert\"); names.add(\"Marisa\"); names.add(\"Kasey\"); System.out.println(names); // [Jake, Kasey, Marisa, Robert] § LinkedHashSet : in der Reihenfolge des Hinzufügens gespeichert Set<String> names = new LinkedHashSet<String>(); ... // [Jake, Robert, Marisa, Kasey] 36 ∀ Elemente der Menge § Da die Ordnung der Elemente in der Menge nicht bekannt ist müssen wir einen (stabilen) Weg finden, Operationen mit allen Elemente einer Menge auszuführen. § Die Operation kann einen Test einschliessen der dann – je nach Ergebnis – die Operationen genauer definiert § Wenn element.hasProperty() dann element.moreOps() § Idee: Schleife über alle Elemente einer (An)Sammlung § Menge Spezialfall § Zwingend da es keinen «Index» für Mengen gibt § Für jedes («for each») Element …. 37 Die «for-each» Schleife Syntax: for (type name : collection) { statements; } type: Typ der Elemente der Ansammlung collection name: Variable (nur innerhalb des Loops definiert) dieses Typs collection: Ansammlung von Elementen des Typs type § Definiert einen Loop über alle Elemente einer Ansammlung (z.B., Set, ArrayList) die das Interface Collection implementiert/erweitert oder alle Elemente eines Arrays 3839 Beispiel Set<String> names = new HashSet<String>(); names.add(\"MIT\"); names.add(\"ETH Zuerich\"); names.add(\"Imperial College\"); names.add(\"EPFL\"); names.add(\"Imperial College\"); for (String n : names) { System.out.println(\"Another university is \" + n); } Output: Another university is ETH Zuerich Another university is EPFL Another university is MIT Another university is Imperial College 40 Beispiel Set<String> names = new LinkedHashSet<String>(); names.add(\"MIT\"); names.add(\"ETH Zuerich\"); names.add(\"Imperial College\"); names.add(\"EPFL\"); names.add(\"Imperial College\"); System.out.println(names); Output: [MIT, ETH Zuerich, Imperial College, EPFL] 41 Beispiel Set<Double> scores = new HashSet<Double>(); scores.add(21.0); scores.add(20.0); scores.add(24.0); scores.add(0.0); //Double ist ein Wrapper Typ! for (Double score : scores) { System.out.println(\"The score is \" + score); } Output: The score is 0.0 The score is 20.0 The score is 21.0 The score is 24.0 42 Beispiel Set<Double> scores = new HashSet<Double>(); scores.add(21.0); scores.add(20.0); scores.add(24.0); scores.add(0.0); //double geht wegen unboxing! for (double score : scores) { System.out.println(\"The score is \" + score); } Output: The score is 0.0 The score is 20.0 The score is 21.0 The score is 24.0 43 Beispiel Set<Double> scores = new LinkedHashSet<Double>(); scores.add(21.0); scores.add(20.0); scores.add(24.0); scores.add(0.0); System.out.println(scores); Output: [21.0, 20.0, 24.0, 0.0] Reihenfolge der (impliziten) Iteration Wird ein Collection Objekt ausgegeben, dann werden die Elemente in dieser Reihenfolge ausgegeben: § HashSet – nicht definiert. § LinkedHashSet – wie eingefügt. § ArrayList – wie im Array gespeichert, entsprechend dem Index § LinkedList – wie in der Liste gespeichert. § TreeSet – aufsteigend nach natürlicher Ordnung (definiert durch compareTo). 4445 Beispiel 1 Set<String> names = new LinkedHashSet<String>(); names.add(\"MIT\"); names.remove(\"ETH Zuerich\"); names.add(\"Imperial College\"); names.add(\"EPFL\"); names.remove(\"Imperial College\"); names.add(\"ETH Zuerich\"); names.add(\"Imperial College\"); System.out.println(names); 46 Beispiel 1 Set<String> names = new LinkedHashSet<String>(); names.add(\"MIT\"); names.remove(\"ETH Zuerich\"); names.add(\"Imperial College\"); names.add(\"EPFL\"); names.remove(\"Imperial College\"); names.add(\"ETH Zuerich\"); names.add(\"Imperial College\"); System.out.println(names); Was ist der Output? Poll 47 Beispiel 2 String[] a = { \"two\", \"three\", \"101\", \"2\", \"1010\"}; Set<String> s2; s2 = new TreeSet<String>(Arrays.asList(a)); System.out.println(s2); Was ist der Output? Poll 48 Beispiel Set<String> names = new LinkedHashSet<String>(); names.add(\"MIT\"); names.remove(\"ETH Zuerich\"); names.add(\"Imperial College\"); names.add(\"EPFL\"); names.remove(\"Imperial College\"); names.add(\"ETH Zuerich\"); names.add(\"Imperial College\"); System.out.println(names); Output [MIT, EPFL, ETH Zuerich, Imperial College] Poll 49 Beispiel 2 String[] a = { \"two\", \"three\", \"101\", \"2\", \"1010\"}; Set<String> s2; s2 = new TreeSet<String>(Arrays.asList(a)); System.out.println(s2); Output [101, 1010, 2, three, two] PollDetails \"two\".compareTo(\"three\"); // 15 \"two\".compareTo(\"1010\"); // 67 \"101\".compareTo(\"1010\"); // -1 \"1010\".compareTo(\"two\"); // -67 \"101\".compareTo(\"two\"); // -67 \"1101\".compareTo(\"two\"); // -67 50 Output [101, 1010, 2, three, two] PollÜbersicht § 10.1 Einleitung § 10.2 ArrayList<Type> § 10.3 Vergleichen von Objekten § 10.4 Mengen § 10.5 Abbildungen § 10.5.1 Arbeiten mit Abbildungen § 10.5.2 Umkehrabbildung § 10.6 Iteratoren und Comparatoren § 10.7 Implementation eines einfachen generischen Typs 52 Mengen (Sets) § Eine Menge ist eine Abbildung («map») der Elemente auf bool’sche Werte. § Set: Ist \"ETH\" in der Menge? (true/false) § Oft sind wir nicht nur an einer Ja/Nein Antwort interessiert § Was ist die Postleitzahl der ETH? § Wo sitzt die Hauptverwaltung der ETH? § Was ist die Hauptstadt der Schweiz? Set \"ETH\" true false 55 true Set<String>: Menge von String Exemplaren Mengen (Sets) und Abbildungen (Maps) § Eine Menge ist eine Abbildung («map») der Elemente auf bool’sche Werte. § Set: Ist \"ETH\" in der Menge? (true/false) § Map: Was ist die Postleitzahl der \"ETH\"? Set \"ETH\" true false 56 Map \"ETH\" 8092 true Set<String>: Menge von String Exemplaren Abbildung (Map) von String auf Postleitzahl Brauchen einen String Abbildungen («Map») § Abbildung: enthält eine Menge Schlüssel («keys») und eine (An)Sammlung von Werten («values»), wobei jeder Schlüssel mit einem Wert assoziiert ist. § Auch als «dictionary», «associative junkjunkjunkjunkjnuknunk array», «hash» bekannt. William Shakespeare: «Romeo and Juliet» myMap.get(\"Juliet\") returns \"Capulet\" 58Abbildung von Vorname auf Familie Einsatz von Abbildungen § Eine Abbildung stellt eine Assoziation zwischen Schlüssel(«key») und Werten her. § Speichert einen Wert für jeden Key (Schlüssel). § Später brauchen wir nur einen Schlüssel angeben und erhalten den entsprechenden Wert zurück: Dann können wir fragen: Was ist die ETH Telefonnummer? Map get(\"ETH\") \"044-632-1111\" Map // key value put(\"ETH\", \"044-632-1111\") 60 Abbildung (Map) von String auf String Abbildungen § Wichtigste Operationen: § put(key, value): Hinzufügen eines Schlüssels mit einem Wert § get(key): Lesen des Wertes der mit dem Schlüssel assoziiert ist. § remove(key): Entfernen des Schlüssels (und des mit ihm assoziierten Wertes) 61 Map Implementation § In Java werden Abbildungen («maps») durch das Map Interface in java.util unterstützt § Muss importiert werden § Verschiedene Implementationen durch Klassen § Wie bei Mengen gibt es keinen Index § Hinzufügen, Lesen, Entfernen – müssen «suchen» § Klassen unterscheiden sich wie gesucht wird § Wichtige Klassen die Map implementieren sind HashMap, LinkedHashMap und TreeMap 62 Java Collections Framework 63 <<Interface> Collection <<Interface> List <<Interface> Set LinkedListArrayList TreeSet <<Interface> SortedSet HashSet <<Interface> Map TreeMap <<Interface> SortedMap HashMap LinkedHashSet LinkedHashMap Map Implementationen § HashMap: Schlüssel sind in einem Array, dem «hash table», in irgendeiner Reihenfolge gespeichert § Ähnlich wie HashSet § Zugriff sehr effizient: O(1) § LinkedHashMap: Zugriff schnell O(1), speichert Elemente in Reihenfolge des Hinzufügens in die Abbildung § TreeMap: Schlüssel in einem binärem Baum gespeichert § Schlüssel sind sortiert gespeichert § Zugriff ziemlich effizient: O(log N) 64 LinkedHashMap LinkedHashMap schützt Klienten vor Details der HashMap (Reihenfolge – Ordnung – nicht definiert und vielleicht «chaotisch») ohne die (nicht-trivialen) Kosten der TreeMap. Kann gebraucht werden um eine Kopie einer Map zu erstellen die die selbe Reihenfolge hat wie das Original, unabhängig von den Details dieser Ordnung. void foo(Map m) { Map copiedMap = new LinkedHashMap(m); ... } 65 Konstruktion von Abbildungen § Eine Abbildung erfordert zwei Typ Parameter: einen für die Schlüssel, einen für die Werte Map<KeyType, ValueType> name = new TreeMap<KeyType, ValueType>() § Abbildung von KeyType Exemplaren auf ValueType Exemplare ( key à value ) § KeyType und ValueType: beides Referenztypen § Default Konstruktor lieferte leere Abbildung 66 Konstruktion von Abbildungen: Beispiele // maps from String keys (first name) to String values (family) Map<String, String> family = new LinkedHashMap<String, String>(); // maps from String keys (candidates) to Integer values (votes) Map<String, Integer> votes = new HashMap<String, Integer>(); § Könnte auch auch spezifische Implementation für Referenzvariable wählen TreeMap<KeyType, ValueType> name = … 67 TreeMap § TreeMap speichert die Schlüssel in einem Binärbaum gemäss der natürlichen Ordnung für den Typ der Schlüssel § Bestimmt durch die compareTo() Methode Map<String, Integer> ages = new TreeMap<String, Integer>(); § Es gibt auch Konstruktoren (für TreeMap) die es erlauben, andere Ordnungsrelationen als die natürliche Ordnung auszuwählen § Kein Thema für diese Vorlesung 68 Map Methoden put(key, value) adds a mapping from the given key to the given value; if the key already exists, replaces its value with the given one get(key) returns the value mapped to the given key (null if not found) containsKey(key) returns true if the map contains a mapping for the given key remove(key) removes any existing mapping for the given key clear() removes all key/value pairs from the map size() returns the number of key/value pairs in the map isEmpty() returns true if the map's size is 0 toString() returns a string such as \"{a=90, d=60, c=70}\" 69 Abbildungen § Wichtigste Operationen: § put(key, value): Hinzufügen eines Schlüssels mit einem Wert § get(key): Lesen des Wertes der mit dem Schlüssel assoziiert ist. § remove(key): Entfernen des Schlüssels (und des mit ihm assoziierten Wertes) § Es gibt kein «add» -- ein Paar (K, V) muss mit «put» zur Abbildung hinzugefügt werden 70 Map Verhalten § Diese Abbildung speichert einen Wert (Integer) für einen Schlüssel (ein String, der «Name») Map<String, Integer> ages = new TreeMap<String, Integer>(); ages.put(\"Roland\", 19); ages.put(\"Clara\", 2); ages.put(\"Sarah\", 57); 71 Roland Clara SarahTyp ist String – daher entscheidet compareTo der Klasse String die Ordnung Boxing! Map<String, Integer> ages = new TreeMap<String, Integer>(); ages.put(\"Roland\", 19); ages.put(\"Clara\", 2); ages.put(\"Sarah\", 57); System.out.println(ages); 72 Roland Clara Sarah Output {Clara=2, Roland=19, Sarah=57} 19 572 Map Verhalten § Die «put» Operation mit Argumenten (K, V) fügt die Assoziation K à V zur Abbildung hinzu § Wenn es schon eine Assoziation K à V' in der Abbildung gab so wird diese überschrieben Map<String, Integer> ages = new TreeMap<String, Integer>(); ages.put(\"Roland\", 17); ages.put(\"Roland\", 19); // only Roland=19 is kept 73 put(…) überschreibt! § Diese Abbildung speichert einen Wert (Integer) für einen Schlüssel (ein String, der \"Name\") Map<String, Integer> ages = new TreeMap<String, Integer>(); ages.put(\"Roland\", 19); ages.put(\"Clara\", 2); ages.put(\"Sarah\", 57); ages.put(\"Clara\", 3); // Clara had her birthday 74 Roland Clara Sarah 19 572 put(…) überschreibt! § Diese Abbildung speichert einen Wert (Integer) für einen Schlüssel (ein String, der \"Name\") Map<String, Integer> ages = new TreeMap<String, Integer>(); ages.put(\"Roland\", 19); ages.put(\"Clara\", 2); ages.put(\"Sarah\", 57); ages.put(\"Clara\", 3); // Clara had her birthday System.out.println(ages); 75 Roland Clara Sarah 19 573 Output {Clara=3, Roland=19, Sarah=57} 2 10.5.1 Arbeiten mit Abbildungen § Das Map Interface schreibt Methoden vor, die es einfach (möglich) machen, mit Abbildungen zu arbeiten § Eine Methode liefert die Menge aller Schlüsselwerte («keys«) § Eine andere Methode liefert alle die Ansammlung aller Werte («values»), auf die ein Schlüsselwert abgebildet ist § Keine Menge – Duplikate möglich 77 Weitere Map Methoden 78 keySet() returns a set of all keys in the map values() returns a collection of all values in the map putAll(map) adds all key/value pairs from the given map to this map equals(map) returns true if given map has the same mappings as this one keySet() § Die Methode keySet() liefert eine Referenz auf die Menge aller «Keys» (Schlüssel) in der Abbildung (Map) § Kann die Menge aller Keys in einer for-each-Schleife bearbeiten § Kann den Wert, der zu einem Key gehört, durch Aufruf von get für die Map erhalten § Für Map<KeyType, ValueType> name heisst das dass name.keySet() eine Referenz auf eine Menge Set<KeyType> liefert Set<String> ns = ages.keySet(); // ages previous slide 79 keySet() Beispiel Die Methode keySet() liefert eine Referenz auf die Menge aller «Keys» in der Abbildung Map<String, Integer> ages = new TreeMap<String, Integer>(); ages.put(\"Roland\", 19); ages.put(\"Clara\", 2); ages.put(\"Sarah\", 57); // ages.keySet() returns Set<String> Set<String> as = ages.keySet(); // get elements w/o for-each 80 keySet() Beispiel Die Methode keySet() liefert eine Referenz auf die Menge aller «Keys» in der Abbildung Map<String, Integer> ages = new TreeMap<String, Integer>(); ages.put(\"Roland\", 19); ages.put(\"Clara\", 2); ages.put(\"Sarah\", 57); // ages.keySet() returns Set<String> Set<String> as = ages.keySet(); System.out.println(as); Reihenfolge in ns bestimmt durch natürliche Ordnung der Schlüssel 81 Output [Clara, Roland, Sarah] keySet() Beispiel Die Methode keySet() liefert eine Referenz auf die Menge aller «Keys» in der Abbildung Map<String, Integer> ages = new TreeMap<String, Integer>(); ages.put(\"Roland\", 19); ages.put(\"Clara\", 2); ages.put(\"Sarah\", 57); // ages.keySet() returns Set<String> Set<String> as = ages.keySet(); for (String name : as) { // Clara -> 2 int age = ages.get(name); // Roland -> 19 System.out.println(name + \" -> \" + age); // Sarah -> 57 } 82 keySet() Beispiel Die Methode keySet() liefert eine Referenz auf die Menge aller «Keys» in der Abbildung Map<String, Integer> ages = new TreeMap<String, Integer>(); ages.put(\"Roland\", 19); ages.put(\"Clara\", 2); ages.put(\"Sarah\", 57); // ages.keySet() returns Set<String> // use directly w/o variable for (String name : ages.keySet()) { // Clara -> 2 int age = ages.get(name); // Roland -> 19 System.out.println(name + \" -> \" + age); // Sarah -> 57 } 83 values() § Die Methode values() liefert eine Referenz auf die Ansammlung aller in der Map auftretenden Werte § Kann diese Werte mit einer for-each Schleife abarbeiten § Aber: Es gibt keinen einfachen Weg den oder die Schlüssel (Keys) für einen Wert zu finden § Beispiel: // setup see previous slide System.out.println(ages.values()); 84 Output [2, 19, 57] keySet und values § Eine Abbildung ist eine Menge von Assoziationen (K à V) § Der «normale» Blick (view) ist diese Menge § keySet() und values() erlauben einen anderen Blick – aber die Abbildung ist noch immer eine Einheit 85 K1 à V1 K2 à V2 K3 à V3 K4 à V4 K1, K2, … sind immer unterschiedlich, aber V1, V2, … nicht unbedingt keySet und values § Eine Abbildung ist eine Menge von Paaren (Key, Value) § Der «normale» Blick (view) ist diese Menge § keySet() und values() erlauben einen anderen Blick – aber die Abbildung ist noch immer eine Einheit Icons made by <a href=\"https://www.flaticon.com/authors/kiranshastry\" title=\"Kiranshastry\">Kiranshastry</a> from <a href=\"https://www.flaticon.com/\" title=\"Flaticon\"> www.flaticon.com</a> 86 K1 à V1 K2 à V2 K3 à V3 K4 à V4 K1, K2, … sind immer unterschiedlich, aber V1, V2, … nicht unbedingt keySet und values § Eine Abbildung ist eine Menge von Paaren (Key, Value) § Der «normale» Blick (view) ist diese Menge § keySet() und values() erlauben einen anderen Blick – aber die Abbildung ist noch immer eine Einheit Icons made by <a href=\"https://www.flaticon.com/authors/kiranshastry\" title=\"Kiranshastry\">Kiranshastry</a> from <a href=\"https://www.flaticon.com/\" title=\"Flaticon\"> www.flaticon.com</a> 87 K1 à V1 K2 à V2 K3 à V3 K4 à V4 K1, K2, … sind immer unterschiedlich, aber V1, V2, … nicht unbedingt keySet und values § keySet() und values() erlauben einen anderen jbdsaf Blick – aber die Abbildung ist noch immer eine Einheit § Deshalb müssen wir eine Referenzvariable eines Interfacetyps (Collection<ValueTyp> oder Set<KeyTyp>) verwenden wenn wir Referenz speichern wollen // setup see previous slide Collection<Integer> av = ages.values(); Set<String> ak = ages.keySet(); 88 K1 à V1 K2 à V2 K3 à V3 K4 à V4 keySet und values § Referenzvariable einer konkreten Klasse (z.B. vom Typ HashSet<KeyTyp>) sind nicht erlaubt. HashSet<String> ak = ages.keySet(); | Error: | incompatible types: java.util.Set<java.lang.String> cannot | be converted to java.util.HashSet<java.lang.String> § Modifikationen sind auch nicht zulässig Set<String> ak = ages.keySet(); ak.add(\"Sarah\"); | Error: | Exception java.lang.UnsupportedOperationException | at AbstractCollection.add (AbstractCollection.java:251)89 void mumble(Map<String,String> map) { Map<String, String> result = new TreeMap<String,String>(); for (String key : map.keySet()) { if (key.compareTo(map.get(key)) < 0){ result.put(key, map.get(key)); } else { result.put(map.get(key), key); } } System.out.println(result); } Gegeben sei die Abbildung myMap: {z=n, o=e, t=z, f=v, a=e} Was wird für mumble(myMap) ausgegeben? 91 Pollvoid mumble(Map<String,String> map) { Map<String, String> result = new TreeMap<String,String>(); for (String key : map.keySet()) { if (key.compareTo(map.get(key)) < 0){ result.put(key, map.get(key)); } else { result.put(map.get(key), key); } } System.out.println(result); } Was wird für mumble(myMap) ausgegeben? Kurzform mit Anfangsbuchstaben bitte, z.B. x=y, k=m, ... 95 Poll MyMap vereinfacht: { z=n, o=e, t=z, f=v, a=e } void mumble(Map<String,String> map) { Map<String, String> result = new TreeMap<String,String>(); for (String key : map.keySet()) { if (key.compareTo(map.get(key)) < 0){ result.put(key, map.get(key)); } else { result.put(map.get(key), key); } } System.out.println(result); } Was wird für mumble(myMap) ausgegeben? {a=e, e=o, f=v, n=z, t=z} 96 Poll MyMap vereinfacht: { z=n, o=e, t=z, f=v, a=e } void mumble(Map<String,String> map) { Map<String, String> result = new TreeMap<String,String>(); for (String key : map.keySet()) { // [ z, o, t, f, a ] if (key.compareTo(map.get(key)) < 0){ result.put(key, map.get(key)); } else { result.put(map.get(key), key); } } System.out.println(result); } Was wird für mumble(myMap) ausgegeben? {a=e, e=o, f=v, n=z, t=z} 97 Poll MyMap vereinfacht: { z=n, o=e, t=z, f=v, a=e } compareTo: false false true true true 98 Antwort Anzahl Prozent a=e, d=t, e=o, f=v, t=z 15 12.30% a=e, e=o, f=v, n=z, t=z 25 20.49% e=o, t=z, d=t, f=v, a=e 16 13.11% n=z, e=o, t=z, f=v, a=e 31 25.41% Andere 35 28.69% 122 Abbildungen Map<K,V> § K (KeyType) und V (ValueType) müssen beide Referenztypen sein § Keine weiteren Einschränkungen § Typ kann durch Interface definiert sein Map<Shape, Double> umfang = new TreeMap<Shape, Double>(); Map<Set<Shape>, Integer> anzahl = new TreeMap<Set<Shape>, Integer>(); // for Set of instances that implement Shape: max area § Beliebige Konstruktionen 101 252-0027 Einführung in die Programmierung 10.0 Generische Programmierung Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016—2021 All rights reserved. void mumble(Map<String,String> map) { Map<String, String> result = new TreeMap<String,String>(); for (String key : map.keySet()) { // [ z, o, t, f, a ] if (key.compareTo(map.get(key)) < 0){ result.put(key, map.get(key)); } else { result.put(map.get(key), key); } } System.out.println(result); } Was wird für mumble(myMap) ausgegeben? {a=e, e=o, f=v, n=z, t=z} 3 Poll MyMap vereinfacht: { z=n, o=e, t=z, f=v, a=e } compareTo: false false true true true 4 Antwort Anzahl Prozent a=e, d=t, e=o, f=v, t=z 15 12.30% a=e, e=o, f=v, n=z, t=z 25 20.49% e=o, t=z, d=t, f=v, a=e 16 13.11% n=z, e=o, t=z, f=v, a=e 31 25.41% Andere 35 28.69% 122 EduApp Problem: Zeigte nicht die richtige Input Abbildung (1. Zeile auch OK) Abbildungen Map<K,V> § K (KeyType) und V (ValueType) müssen beide Referenztypen sein § Keine weiteren Einschränkungen § Typ kann durch Interface definiert sein Map<Shape, Double> umfang = new TreeMap<Shape, Double>(); Map<Set<Shape>, Integer> anzahl = new TreeMap<Set<Shape>, Integer>(); // for Set of instances that implement Shape: max area § Beliebige Konstruktionen 78 class Record { String telNr; Integer plz; } Map<String, Record> directory = new TreeMap<String, Record>(); directory.put(\"ETH\", new Record(\"044 632 1111\", 8092)); 9 class Record { String telNr; Integer plz; public String toString() { return telNr+\" -- \"+plz; } } Map<String, Record> directory = new TreeMap<String, Record>(); directory.put(\"ETH\", new Record(\"044 632 1111\", 8092)); directory.put(\"EPFL\", new Record(\"021 693 1111\", 1015)); System.out.println(directory); Record(String s, Integer i) { telNr = s; plz = i; } Abbildungen Map<K,V> § K (KeyType) und V (ValueType) müssen beide Referenztypen sein § Keine weiteren Einschränkungen § Typ kann durch Interface definiert sein Map<Shape, Double> umfang = new TreeMap<Shape, Double>(); Map<Set<Shape>, Integer> anzahl = new TreeMap<Set<Shape>, Integer>(); // for Set of instances that implement Shape: count // Sorted by «area» (define compareTo and equals …) § Beliebige Konstruktionen 1011 Eine solche Abbildung ist die Umkehrabbildung f : String à Integer (Name à Alter) f–1 : Integer à String (Alter à Name) Geht das immer? Wie? Übersicht § 10.1 Einleitung § 10.2 ArrayList<Type> § 10.3 Vergleichen von Objekten § 10.4 Mengen § 10.5 Abbildungen § 10.5.1 Arbeiten mit Abbildungen § 10.5.2 Umkehrabbildung § 10.6 Iteratoren und Comparatoren § 10.7 Implementation eines einfachen generischen Typs 13 Arbeiten mit Abbildungen § Wir wollen für jede/n Assistierende/n die Durchschnittsnote festhalten. § Abbildung Name (String) à Note (Double) Map<String, Double> note = new LinkedHashMap<String, Double>(); note.put(\"Jared\", 4.6); note.put(\"Alyssa\", 5.0); note.put(\"Steve\", 5.9); note.put(\"Stef\", 4.6); note.put(\"Rob\", 4.0); ... 1415 4.0 4.6 5.0 5.9 \"Rob\" \"Alyssa\" \"Jared\" \"Stef\" \"Steve\" § Für jeden Key (String) können wir den zugeordneten Wert (Double) erfragen System.out.println(\"Jareds Note ist \" + note.get(\"Jared\")); // 4.6 § Aber die Abbildung erlaubt es nicht, einfach nach allen Assistenten zu fragen, die eine bestimmte Note erreichten. § Was für eine Abbildung bräuchten wir dafür? § Was für einen Typ müsste die Antwort haben? 16 Umkehrabbildung § Wir könnten die Abbildung umkehren so dass sie eine Abbildung von Noten auf Assistenten ist. Map<Double, String> invNote = new HashMap<Double, String>(); invNote.put(4.6, \"Jared\"); invNote.put(5.0, \"Alyssa\"); invNote.put(5.9, \"Steve\"); invNote.put(4.6, \"Stef\"); invNote.put(4.0, \"Rob\"); ... 17 Umkehrabbildung § Wir könnten die Abbildung umkehren so dass sie eine Abbildung von Noten auf Assistenten ist. // note as before Map<Double, String> invNote = new HashMap<Double, String>(); for (String s : note.keySet()) { invNote.put(note.get(s), s); } ... 18 Umkehrabbildung § Wir könnten die Abbildung umkehren so dass sie eine Abbildung von Noten auf Assistenten ist. Map<Double, String> invNote = new HashMap<Double, String>(); invNote.put(4.6, \"Jared\"); invNote.put(5.0, \"Alyssa\"); invNote.put(5.9, \"Steve\"); invNote.put(4.6, \"Stef\"); invNote.put(4.0, \"Rob\"); ... System.out.println(\"Wer hatte eine 4.6? \" + invNote.get(4.6)); // ??? 1921 4.0 4.6 5.0 5.9 \"Rob\" \"Alyssa\" \"Jared\" \"Stef\" \"Steve\" 4.0 5.0 5.9 invNote.put(4.6, \"Jared\"); 22 4.0 4.6 5.0 5.9 \"Rob\" \"Alyssa\" \"Jared\" \"Stef\" \"Steve\" 4.0 4.6 5.0 5.9 \"Jared \" invNote.put(5.0, \"Alyssa\"); 23 4.0 4.6 5.0 5.9 \"Rob\" \"Alyssa\" \"Jared\" \"Stef\" \"Steve\" 4.0 4.6 5.0 \"Alyssa\" \"Jared \" invNote.put(5.9, \"Steve\"); 24 4.0 4.6 5.0 5.9 \"Rob\" \"Alyssa\" \"Jared\" \"Stef\" \"Steve\" 4.0 4.6 5.0 5.9 \"Alyssa\" \"Jared \" \"Steve\" invNote.put(4.6, \"Stef\"); 25 4.0 4.6 5.0 5.9 \"Rob\" \"Alyssa\" \"Jared\" \"Stef\" \"Steve\" 4.0 4.6 5.0 5.9 \"Alyssa\" \"Stef \" \"Steve\" invNote.put(4.0, \"Rob\"); 26 4.0 4.6 5.0 5.9 \"Rob\" \"Alyssa\" \"Jared\" \"Stef\" \"Steve\" 4.0 4.6 5.0 5.9 \"Alyssa\" \"Stef\" \"Steve\" \"Rob\" System.out.println(invNote.keySet()); // [4.0, 4.6, 5.0, 5.9] System.out.println(invNote); System.out.println(\"Wer hatte eine 4.6?\" + invNote.get(4.6)); // \"Stef\" § Dieser Ansatz ist keine Lösung. § Wo ist das Problem? § Mehrere Assistierende können den selben Notendurchschnitt haben. § Die Map speichert nur den letzten Eintrag 27 Korrekte Umkehrabbildung § Jede Note muss auf eine Ansammlung (Collection) von Assistierenden abgebildet werden § Eine Menge (Exemplar einer Klasse die Set implementiert) § Einer ArrayList § … Map<Double, Set<String>> invNote = new HashMap<Double, Set<String>>(); 28 Korrekte Umkehrabbildung § Jede Note muss auf eine Ansammlung (Collection) von Assistierenden abgebildet werden Map<Double, Set<String>> invNote = new HashMap<Double, Set<String>>(); § ... im Beispiel 29 Abbildung: note Umkehrabbildung: invNote note.put( \"Rob\", 4.0 ); invNote.put( 4.0, { \"Rob\" } ); Korrekte Umkehrabbildung § put(K, V) ersetzt Eintrag § Was wenn es schon einen Eintrag gibt? § Lösung: zur Menge hinzufügen § Eintrag finden dann \"Rob\" dazu: invNote.get(4.0).add(\"Rob\") § Es muss eine Menge geben zu der \"Rob\" hinzugefügt werden kann § Daher muss Eintrag mit leerer Menge initalisieren invNote( 4.0, new TreeSet<String>() ); 30 Umkehrabbildung: invNote invNote.put( 4.0, { \"Rob\" } ); Umkehrabbildung Map<Double, Set<String>> invNote = new HashMap<Double, Set<String>>(); invNote.put(4.6, new TreeSet<String>()); invNote.get(4.6).add(\"Jared\"); invNote.put(5.0, new TreeSet<String>()); invNote.get(5.0).add(\"Alyssa\"); invNote.put(5.9, new TreeSet<String>()); invNote.get(5.9).add(\"Steve\"); invNote.get(4.6).add(\"Stef\"); invNote.put(4.0, new TreeSet<String>()); invNote.get(4.0).add(\"Rob\"); 353738394041424344 Umkehrabbildung Map<Double, Set<String>> invNote = new HashMap<Double, Set<String>>(); invNote.put(4.6, new TreeSet<String>()); invNote.get(4.6).add(\"Jared\"); invNote.put(5.0, new TreeSet<String>()); invNote.get(5.0).add(\"Alyssa\"); invNote.put(5.9, new TreeSet<String>()); invNote.get(5.9).add(\"Steve\"); invNote.get(4.6).add(\"Stef\"); invNote.put(4.0, new TreeSet<String>()); invNote.get(4.0).add(\"Rob\"); ... System.out.println(\"Wer hatte eine 4.6? \" + invNote.get(4.6)); // [Jared, Stef] 45 Korrekte Umkehrabbildung (aus Abbildung) // note as before Map<Double, Set<String>> invNote = new HashMap<Double, Set<String>>(); for (String s : note.keySet()) { if (!invNote.containsKey(note.get(s))) { invNote.put(note.get(s), new HashSet<String>()); } invNote.get(note.get(s)).add(s); } ... System.out.println(\"Wer hatte eine 4.6? \" + invNote.get(4.6)); // [Jared, Stef] 48 Wichtig: Menge initialisieren bevor das 1. Element hinzugefügt wird. 50 Variation der Umkehrabbildung TreeMap<Double, Set<String>> invNote = new TreeMap<Double, Set<String>>(); invNote.put(4.6, new TreeSet<String>()); invNote.get(4.6).add(\"Jared\"); invNote.put(5.0, new TreeSet<String>()); invNote.get(5.0).add(\"Alyssa\"); invNote.put(5.9, new TreeSet<String>()); invNote.get(5.9).add(\"Steve\"); invNote.get(4.6).add(\"Stef\"); invNote.put(4.0, new TreeSet<String>()); invNote.get(4.0).add(\"Rob\"); System.out.println(\"…wenigstens 4.5? \" + invNote.ceilingEntry(4.5)); // 4.6=[Jared, Stef] System.out.println(\"…wenigstens 5.0? \" + invNote.ceilingEntry(5.0)); // 5.0=[Alyssa] Liefert kleinsten Key der grösser oder gleich ist, mit assoziiertem Wert 515253 Menge und Abbildungen § Interface Map und Set Grundlage für diverse Klassen § Beispiele: § TreeSet/HashSet/LinkedHashSet § TreeMap/HashMap/LinkedHashMap § und einige mehr § Auch Implementation durch eigene Klassen § Einschränkungen bzgl. Modifikation der Elemente der Menge/Abbildung § Änderungen die compareTo bzw den Hash betreffen werden nicht nachgeführt 54 Reihenfolge der Iteration Wird ein Collection Objekt ausgegeben oder in einem for-each Loop bearbeitet, dann gilt für die Reihenfolge: § HashSet – nicht definiert. § LinkedHashSet – wie eingefügt. § ArrayList – wie im Array gespeichert, entsprechend dem Index § LinkedList – wie in der Liste gespeichert. § TreeSet – aufsteigend nach natürlicher Ordnung (definiert durch compareTo). 55 Reihenfolge der Iteration (Fortsetzung) § HashMap – nicht definiert. § TreeMap – aufsteigend nach natürlicher Ordnung (definiert durch compareTo). § LinkedHashMap – wie eingefügt. 56 10.6.1 Iteratoren 58 Motivation – eine Übungsaufgabe 1. Schreiben Sie ein Programm, das zählt wieviele verschiedene Wörter in einem Text auftauchen. § Speichern Sie die Wörter in einer (An)Sammlung und halten Sie fest wie oft ein Wort in dem Text auftritt. § Nach dem Einlesen des Textes sollte es möglich sein, festzustellen wie oft ein bestimmtes Wort im Text auftritt. 2. Geben Sie jedes Wort das mindestens 1000mal auftritt aus (a) und entfernen es aus der Menge (b) 59 Lösung des 1. Teils der Übungsaufgabe // read file into a map of [word --> number of occurrences] Map<String, Integer> wordCount = new TreeMap<String, Integer>(); Scanner input = new Scanner(new File(\"mobydick.txt\")); while (input.hasNext()) { String word = input.next(); if (wordCount.containsKey(word)) { // seen this word before; increase count by 1 int count = wordCount.get(word); wordCount.put(word, count + 1); } else { // never seen this word before wordCount.put(word, 1); } } 60 Scanner console = new Scanner(System.in); System.out.print(\"Word to search for? \"); String word = console.next(); if (wordCount.get(word)!=null) { System.out.println(\"Freq: \" + wordCount.get(word)); } else { System.out.println(\"Does not appear in text\"); } 61 Übung (Fortsetzung) 2. Geben Sie jedes Wort das mindestens 1000mal auftritt aus (a) und entfernen es aus der Menge (b) § Wie finden wir diese Wörter? § Wie können wir alle Wörter besuchen (dann können wir abfragen wie oft das Wort aufgetreten ist)? 62 Übung (Fortsetzung) 2. Geben Sie jedes Wort das mindestens 1000mal auftritt aus (a) und entfernen es aus der Menge (b) § Wie finden wir diese Wörter? § Wie können wir alle Wörter besuchen (dann können wir abfragen wie oft das Wort aufgetreten ist)? Map<String, Integer> wordCount = new TreeMap<String, Integer>(); Set<String> inText = wordCount.keySet(); for (String s : inText) { ... } 63 Übung (Fortsetzung) 2. (a) Geben Sie jedes Wort das mindestens 1000mal auftritt aus Map<String, Integer> wordCount = new TreeMap<String, Integer>(); Set<String> inText = wordCount.keySet(); for (String s : inText) { if ((wordCount.get(s) > 999) { System.out.println(s); } } 64 Mit den Elementen einer Menge (Set) arbeiten § Bei Abbildungen (Map) liefern keySet() und values() eine Referenz auf § Menge der Keys (Schlüssel) § Ansammlung der Werte § Können wir diese Mengen verwenden um die Abbildung zu verändern? § z.B. um Einträge zu entfernen wenn der Wert eine Bedingung erfüllt? § Nein. Was passiert wenn wir es versuchen? 67 Lösungsversuch (Teil 2.b) 2. (b) Entfernen Sie jedes Wort das mindestens 1000mal auftritt Set<String> inText = wordCount.keySet(); for (String s : inText) { if ((wordCount.get(s) > 999) { wordCount.remove(s); } } 68 Lösungsversuch (Teil 2.b) 2. (b) Entfernen Sie jedes Wort das mindestens 1000mal auftritt Set<String> inText = wordCount.keySet(); for (String s : inText) { if ((wordCount.get(s) > 999) { wordCount.remove(s); } } § Leider tritt während der Ausführung (wenn es Wörter gibt die > 999 auftreten) eine Exception auf 69 Exception in thread \"main\" java.util.ConcurrentModificationException at java.base/java.util.HashMap$HashIterator.nextNode(HashMap. java:1493) at java.base/java.util.HashMap$KeyIterator.next(HashMap.java: 1516) at Example2a.main(Example2a.java:35) § Problem: Die for-each-Schleife ist «read-only», d.h. die Ansammlung darf nicht modifiziert werden während der Loop ausgeführt wird § Die Ansammlung ist hier eine Abbildung 7071 Auch Änderungen von Mengen unterliegen den selben Einschränkungen Set<Double> scores = new TreeSet<Double>(); scores.add(21.0); scores.add(20.0); scores.add(24.0); scores.add(0.0); for (Double score : scores) { System.out.println(\"The score is \" + score); } for (Double score : scores) { if (score < 4.0) { // throws a ConcurrentModificationException scores.remove(score); } } Die for-each-Schleife § Problem: Die for-each-Schleife ist «read-only», d.h. die Menge darf nicht modifiziert werden während der Loop ausgeführt wird § Müssen wir immer eine neue Abbildung konstruieren nur weil wir eine Assoziation entfernen wollen? 72 Zur Erinnerung § Die Methoden keySet() und values() geben eine Referenz auf die Keys bzw. Werte zurück § Keine Kopie! § Diese Methoden ändern den «Blick» (view) auf die Abbildung § Daher können wir nicht in einer for-each-Schleife über die Keys einen Eintrag in der Abbildung entfernen 73 Noch ein Lösungsversuch (Teil 2) § Eine explizite Referenzvariable hilft nicht: Map<String, Integer> wordCount; //init as before Set<String> inText = wordCount.keySet(); for (String s : inText) { if ((wordCount.get(s) > 999) { inText.remove(s); } } § Auch hier tritt während der Ausführung (wenn es Wörter gibt die > 999 auftreten) eine Exception auf 74 Iteration (for-each) und Abbildung Map<String, Integer> sMap = new TreeMap<String, Integer>(); § Speichert Keys in Binärbaum 75 Paul Ivo Sarah 19 2021 Roland 19 Peter Shawn 1820 for (String s: sMap.keySet()) {…} § Arbeitet mit Keys in dieser Ordnung: RolandIvo SarahPeterPaul Shawn Iteration (for-each) und Abbildung § Entfernen eines Schlüssels hat (evtl.) weitreichende Folgen 76 Peter Ivo Sarah 20 2021 Roland Shawn 1819 for (String s: sMap.keySet()) {…} § Arbeitet mit Keys in dieser Ordnung: RolandIvo SarahPeterPaul Shawn✘ 76 Iteration und Modifikation der Abbildung § Müssen Iteration (Abarbeiten/Besuchen der Schlüssel einer Abbildung) modellieren § Dann wissen wir was «das nächste Element» ist, das besucht werden soll § Können Entfernen eines Schlüssels während der Iteration mit der Modifikation der Abbildung koordinieren § Modellierung im Programm durch ein Objektexemplar § Exemplar eines Typs der Iteration repräsentiert: Iterator 77 Iteratoren § Iterator («iterator»): Ein Objekt das einem Klienten erlaubt, die Elemente einer Ansammlung zu besuchen § Erinnert sich an die (aktuelle) Position and erlaubt es § auf das Element an dieser Position zuzugreifen § das Element an dieser Position zu entfernen § abzufragen ob es weitere Elemente gibt § zur nächsten Position vorzurücken § Liefert einen Weg eine Iteration zu kontrollieren 78 Beispiel § Gegeben sei eine ArrayList list mit 6 Elementen (Integer Objekte) § Wir wollen alle Elemente besuchen § Im Augenblick bearbeiten wir Element 9 79 index 0 1 2 3 4 5 value 3 8 9 7 5 1 2 size 6 list Beispiel § Im Augenblick bearbeiten wir Element 9 § Iterator hält fest: aktuelles Element: 9, nächstes Element: 7 80 iterator Aktuelles Element: 9 Nächstes Element: 7 index 0 1 2 3 4 5 value 3 8 9 7 5 1 2 size 6 list Beispiel § Danach geht es weiter zu Element 7 § Iterator hält fest: aktuelles Element: 7, nächstes Element: 5 81 Aktuelles Element: 7 Nächstes Element: 5iterator index 0 1 2 3 4 5 value 3 8 9 7 5 1 2 size 6 list Beispiel § Danach geht es weiter zu Element 5 § Iterator hält fest: aktuelles Element: 5, nächstes Element: 12 82 Aktuelles Element: 5 Nächstes Element: 12iterator index 0 1 2 3 4 5 value 3 8 9 7 5 1 2 size 6 list Beispiel § Die selbe Idee können wir bei einer Menge einsetzen § Bei einer Liste bietet sich der Index an, die Reihenfolge festzulegen § Bei einer Menge brauchen wir einen anderen Weg § Z.B. natürliche Ordnung, Hash-Werte, Reihenfolge des Einfügens 83 set \"the\" \"to\" \"from\" \"we\" Aktuelles Element: \"from\" Nächstes Element: \"the\" iterator \"a\" Beispiel § Je nach Art der Menge sind verschiedene Ordungsrelationen (Reihenfolgen) möglich 84 set \"the\" \"to\" \"from\" \"we\" \"a\" \"a\" \"to\" \"from\" \"the\" \"we\" Mögliche Reihenfolge iterator Aktuelles Element: \"from\" Nächstes Element: \"the\" 85 set \"the\" \"to\" \"from\" \"we\" \"a\" \"from\" \"the\" \"to\" \"we\" \"a\"iterator Andere mögliche Reihenfolge Aktuelles Element: \"from\" Nächstes Element: \"the\" § Je nach Art der Menge sind verschiedene Ordungsrelationen (Reihenfolgen) möglich Iterator § Ein Objekt das einem Klienten erlaubt, eine Iteration über die Elemente einer Ansammlung durchzuführen § Erinnert sich an die (aktuelle) Position and erlaubt es § auf das Element an dieser Position zuzugreifen § das Element an dieser Position zu entfernen § abzufragen ob es weitere Elemente gibt § zur nächsten Position vorzurücken § Iterator<T> ist ein Interface in java.util § Brauchen also Exemplar einer Klasse, die Iterator implementiert 86 Erstellen eines Iterator Objekts § Iterator<T> ist ein Interface in java.util § und Klassen des Collection Frameworks implementieren Iterator und § Das Collections Framework enthält die iterator() Methode, die einen Iterator liefert mit dem die Elemente besucht werden können. Set<String> set = new HashSet<String>(); ... Iterator<String> itr = set.iterator(); 87 Iterator Methoden § remove() darf nur aufgerufen werden, nachdem next() aufgerufen wurde – das aktuelle Element wird entfernt § Exception wenn 2-mal ohne neues next() aufgerufen § Veränderungen sind nur via Iterator möglich 88 hasNext() returns true if there are more elements to examine next() returns the next element from the collection (throws a NoSuchElementException if there are none left to examine) remove() removes the last value returned by next() (throws an IllegalStateException if you haven't called next() yet) Iterator enthält Zustand der Iteration Set<String> set = new HashSet<String>(); Iterator<String> itr = set.iterator(); itr.hasNext(); // true itr.next(); // from 89 \"the\" \"to\" \"from\" \"we\" \"a\" \"from\" \"the\" \"to\" \"we\" \"a\" current next hasNext \"from\" \"the\" true \"the\" \"to\" true \"to\" \"we\" true \"we\" \"a\" true \"a\" false Aktuelles Element: \"from\" Nächstes Element: \"the\" itr set Iterator enthält Zustand der Iteration Set<String> set = new HashSet<String>(); Iterator<String> itr = set.iterator(); itr.hasNext(); // true itr.next(); // from itr.next(); // the 90 \"the\" \"to\" \"from\" \"we\" \"a\" \"from\" \"the\" \"to\" \"we\" \"a\" current next hasNext \"from\" \"the\" true \"the\" \"to\" true \"to\" \"we\" true \"we\" \"a\" true \"a\" false Aktuelles Element: \"the\" Nächstes Element: \"to\" itr set Iterator enthält Zustand der Iteration Set<String> set = new HashSet<String>(); Iterator<String> itr = set.iterator(); itr.hasNext(); // true itr.next(); // from itr.next(); // the itr.remove(); 91 \"the\" \"to\" \"from\" \"we\" \"a\" \"from\" \"the\" \"to\" \"we\" \"a\" current next hasNext \"from\" \"the\" true \"the\" \"to\" true \"to\" \"we\" true \"we\" \"a\" true \"a\" false Aktuelles Element: \"the\" Nächstes Element: \"to\" itr set Iterator enthält Zustand der Iteration Set<String> set = new HashSet<String>(); Iterator<String> itr = set.iterator(); itr.hasNext(); // true itr.next(); // from itr.next(); // the itr.remove(); 92 set \"to\" \"from\" \"we\" \"a\" \"from\" \"to\" \"we\" \"a\" current next hasNext \"from\" \"to\" true \"to\" \"we\" true \"we\" \"a\" true \"a\" false itr Aktuelles Element: Nächstes Element: \"to\" 93 Iterator Beispiel 1 Nehmen wir eine Menge von Prüfungsergebnissen (Integer)…. Set<Integer> scores = new TreeSet<Integer>(); scores.add(94); // Lisa scores.add(38); // Kim scores.add(87); // Roy scores.add(43); // Marty scores.add(72); // Marisa 95 Iterator Beispiel 1 (Teil 2) Iterator<Integer> itr = scores.iterator(); System.out.println(scores); // [38, 43, 72, 87, 94] Wollen alle < 50 aus der Menge entfernen while (itr.hasNext()) { int score = itr.next(); if (score < 50) { // eliminate any failing grades itr.remove(); } } System.out.println(scores); // [72, 87, 94] 96 Iterator Methoden § Ein Iterator Exemplar kann einmal für eine Iteration (über alle Elemente) verwendet werden («single use») § Wenn hasNext() das Resultat false zurückgegeben hat (also die Ansammlung abgearbeitet wurde) kann der Iterator nicht weiterverwendet werden um Elemente zu bearbeiten § Neue Iteration? neuer Iterator. § Unterbrechungen (Abarbeiten einer Teilmenge, später fortfahren, etc.) erlaubt 99 hasNext() returns true if there are more elements to examine Iterator Beispiel 2 Nehmen wir eine Abbildung von Namen (String) auf Resultate (Integer)…. Map<String, Integer> scores; scores = new TreeMap<String, Integer>(); scores.put(\"Kim\", 38); scores.put(\"Lisa\", 94); scores.put(\"Roy\", 87); scores.put(\"Marty\", 43); scores.put(\"Marisa\", 72); 100 Iterator Beispiel 2 Map<String, Integer> scores; scores = new TreeMap<String, Integer>(); scores.put(\"Kim\", 38); scores.put(\"Lisa\", 94); scores.put(\"Roy\", 87); scores.put(\"Marty\", 43); scores.put(\"Marisa\", 72); 38 43 72 87 94 \"Marisa\" \"Kim\" \"Lisa\" \"Marty\" \"Roy\" 101 Iterator Beispiel 2 38 43 72 87 94 \"Marisa\" \"Kim\" \"Lisa\" \"Marty\" \"Roy\" scores.keySet(): [Kim, Lisa, Marisa, Marty, Roy] 102 Iterator Beispiel 2 (Teil 2) Iterator<String> itr = scores.keySet().iterator(); System.out.println(scores.keySet()); // [Kim, Lisa, Marisa, Marty, Roy] while (itr.hasNext()) { String name = itr.next(); int score = scores.get(name); System.out.println(name + \" got \" + score); if (score < 50) { // eliminate any failing students itr.remove(); // removes name and score } } System.out.println(scores); // {Lisa=94, Marisa=72, Roy=87} 104105 Iterator Beispiel 2 – HashMap Variation scores = new HashMap<String, Integer>(); Programm unverändert – und gleiches Resultat aber andere Reihenfolge der Iteration Iterator<String> itr = scores.keySet().iterator(); System.out.println(scores.keySet()); // [Marisa, Marty, Roy, Kim, Lisa] while (itr.hasNext()) { String name = itr.next(); int score = scores.get(name); System.out.println(name + \" got \" + score); if (score < 50) { // eliminate any failing students itr.remove(); // removes name and score } } System.out.println(scores); // 107 Was heisst «ändern»? § Eine Abbildung besteht aus Assoziationen (Key à Value). § Mittels eines Iterators können wir in einem Loop (über alle Keys) eine Assoziation (k à v) entfernen § Wir können auch eine Assoziation (k à v) verändern («replace»), d.h. für den Key k wird der Wert v durch w ersetzt so dass nun (k à w) in der Abbildung ist. § Auch in for-each-Loop 108 Was heisst «ändern»? § Wir können auch die Assoziation (k à v) verändern – dann ist (k à w) in der Abbildung § Veränderungen haben keinen Einfluss auf die Reihenfolge des Einfügens. scores = new LinkedHashMap<String, Integer>(); // init as before System.out.println(scores.keySet()); scores.replace(\"Marty\", 55); System.out.println(scores); 109 Iterator Beispiel 3 Variation (Rest wie vorher) while (itr.hasNext()) { String name = itr.next(); int score = scores.get(name); System.out.println(name + \" got \" + score); if (score < 50) { // raise any failing students scores.replace(name, score+10); } } 111 scores: Referenzvariable der Abbildung Nicht möglich wäre neuer Eintrag while (itr.hasNext()) { String name = itr.next(); int score = scores.get(name); System.out.println(name + \" got \" + score); if (score < 50) { //raise grade, record old one scores.replace(name, score+10); scores.put(\"OLD \" + name, score); } } 113 Ergibt wieder Laufzeit- fehler da es keinen Eintrag für diesen String gibt!| Exception java.util.ConcurrentModificationException | at TreeMap$PrivateEntryIterator.nextEntry (TreeMap.java:1208) | at TreeMap$KeyIterator.next (TreeMap.java:1262) | at (#48:2) Nicht möglich wäre neuer Eintrag while (itr.hasNext()) { String name = itr.next(); int score = scores.get(name); System.out.println(name + \" got \" + score); if (score < 50) { //raise grade, record old one itr.remove(); scores.put(name, score+10); } } 114 Ergibt wieder Laufzeit-fehler. | Exception java.util.ConcurrentModificationException | at TreeMap$PrivateEntryIterator.nextEntry (TreeMap.java:1208) | at TreeMap$KeyIterator.next (TreeMap.java:1262) | at (#70:2) Zusammenfassung Iterator § Iterator entkoppelt Abarbeiten/Besuchen der Elemente einer Ansammlung von den Details der Darstellung § Klient muss nicht geändert werden wenn sich die Darstellung ändert § … oder die Ordnungsrelation § Iterator erlaubt Entfernen oder Verändern einer Assoziation in der Schleife § … aber keine neuen Einträge 116 Übersicht § 10.4 Mengen § 10.5 Abbildungen § 10.6 Iteratoren und Comparatoren § 10.7 Implementation eines einfachen generischen Typs 117 10.6 Iteratoren und Comparatoren 118 10.6.2 Comparatoren 119 Kontrolle der Programmausführung § Iterator Objekt modelliert Iteration über alle Elemente einer Ansammlung § D.h. Klienten kann eine Iteration über die Elemente einer Ansammlung durchzuführen § Guter Service: Collection enthält (abstrakte) Methode iterator() § Implementiert von allen Klassen die das Interface implementieren § Diese Idee (ein Objekt modelliert einen Aspekt der Programmausführung) können wir auch in anderen Situationen einsetzen 120 Wir erinnern uns … Reihenfolge der Iteration Wird ein Collection Objekt ausgegeben oder in einem for- each Loop bearbeitet, dann gilt für die Reihenfolge: § TreeSet – aufsteigend nach natürlicher Ordnung (definiert durch compareTo). Wie können wir das ändern? 121 § Die «natürliche Ordnung» ist durch compareTo() definiert § Könnten also diese Methode neu/anders definieren § Diese Änderung gilt dann aber überall (für Exemplare dieser Klassen) § Anderer Ansatz: Objekt Exemplar das «Vergleich» modelliert § Interface Comparator<T> § Exemplar das Comparator implementiert bestimmte Ordnungsrelation § Ähnlich wie Iterator für Iteration 122 Interface Comparator<T> § Muss Methode compare() implementieren die zwei Objekte vergleicht (Returnvalue: int) § compare(A, B) liefert: einen Wert < 0 wenn A «vor» B in der Ordnungsrelation ist, einen Wert > 0 wenn A «nach» B in der Ordnungsrelation ist, einen Wert > 0 wenn A und B in der Ordnungsrelation «gleich» sind 123 compare(T o1, T o2) Compares its two arguments for order. Beispiel § Eine Menge von Datensätzen mit Prüfungsergebnissen § Statt in einer Abbildung speichern wir eine Menge von Paaren (Name, Punkte) § Wollen vielleicht den Datensatz auf Noten (1 .. 6.0) abbilden … 124 public class Student { String name; Integer points; Student() { name = null; points = null; } Student(String n, Integer p) { name=n; points=p; } public String toString() { return name + \":\" + points; } } // end Student Ordnung nach Punkten § Wollen die Datensätze den Punkten nach ordnen import java.util.*; public class StudentComparatorPoints implements Comparator<Student> { public int compare(Student s1, Student s2) { return s1.points - s2.points; } } § Exemplar dieser Klasse Parameter des TreeSet Konstruktors 125126 Ordnung nach Punkten § Exemplar dieser Klasse Parameter des TreeSet Konstruktors Comparator<Student> htc; // how to compare htc = new StudentComparatorPoints(); Set<Student> scores = new TreeSet<Student>(htc); § Dann weiter wie vorher 127 scores.add(new Student(\"Kim\", 38)); scores.add(new Student(\"Lisa\", 94)); scores.add(new Student(\"Roy\", 87)); scores.add(new Student(\"Marty\", 43)); scores.add(new Student(\"Marisa\", 72)); Ordnung nach Punkten, Fortsetzung System.out.println(scores); for (Student s : scores) { System.out.println(s.name + \" got \" + s.points + \" points\"); } § Reihenfolge (der Iteration) blankblankblankblankblankbla jetzt nach erzielten Punkten 128 Ordnung nach Namen § compare() für natürliche (String) Ordung: public class StudentComparatorName implements Comparator<Student> { public int compare(Student s1, Student s2) { return s1.name.compareTo(s2.name); } } § Ordnung jetzt wie mit compareTo() basierend auf String: Comparator<Student> htc; // how to compare htc = new StudentComparatorName(); Set<Student> scores = new TreeSet<Student>(htc); //init omitted System.out.println(scores); 129 § Und wenn wir die Länge des Namens verwenden wollen? public class StudentComparatorLength implements Comparator<Student> { public int compare(Student s1, Student s2) { return s1.name.length() - s2.name.length(); } } § Neue Ordnung: Comparator<Student> htc; // how to compare htc = new StudentComparatorLength(); Set<Student> scores = new TreeSet<Student>(htc); System.out.println(scores); 130 scores.add(new Student(\"Kim\", 38)); scores.add(new Student(\"Lisa\", 94)); scores.add(new Student(\"Roy\", 87)); scores.add(new Student(\"Marty\", 43)); scores.add(new Student(\"Marisa\", 72)); § Was wird ausgegeben? public class StudentComparatorLength implements Comparator<Student> { public int compare(Student s1, Student s2) { return s1.name.length() - s2.name.length(); } } Comparator<Student> htc; // how to compare htc = new StudentComparatorLength(); Set<Student> scores = new TreeSet<Student>(htc); System.out.println(scores); 131 scores.add(new Student(\"Kim\", 38)); scores.add(new Student(\"Lisa\", 94)); scores.add(new Student(\"Roy\", 87)); scores.add(new Student(\"Marty\", 43)); scores.add(new Student(\"Marisa\", 72)); Poll§ Und wenn wir die Länge des Namens verwenden wollen? public class StudentComparatorLength implements Comparator<Student> { public int compare(Student s1, Student s2) { return s1.name.length() - s2.name.length(); } } § Neue Unordnung: Comparator<Student> htc; // how to compare htc = new StudentComparatorName(); Set<Student> scores = new TreeSet<Student>(htc); System.out.println(scores); § denn \"Kim\" und \"Roy\" sind «gleich» und der Eintrag für \"Roy\" wird ignoriert da \"Kim\" schon in der Menge ist. § Oooops. 132 Poll Bemerkungen § compareTo(T other) hat einen Parameter § Der andere ist der implizite Parameter des Exemplars für das die Methode aufgerufen wird § compare(T o1, T o2) hat zwei Parameter § Comparable<T> muss von der Klasse (der Examplare, die sortiert werden sollen) implementiert werden § Für diese Exemplare immer die selbe Ordnungsrelation § Comparator<T> eigene Klasse, Exemplar für Collection Konstruktor § Kann (z.B.) TreeMap und TreeSet unterschiedlich sortieren 133 Anonyme Objekte § Der Comparator existiert nur, um als Parameter an den TreeSet Konstruktor übergeben zu werden § Oft sehen Sie in Programmen dass ein «anonymes» Objekt dafür erstellt wird scores = new TreeSet<Student>(new Comparator<Student>() { public int compare(Student s1, Student s2) { return s1.points - s2.points; } }); § Dann brauchen wir (evtl.) keine separate Klasse 134 § Iterator erlaubt Modifikationen der Elemente der Menge bzw. Einträge der Abbildung § Einschränkungen § Comparator bietet Flexibilität bei Auswahl der Ordnung § Mehrere Ordnungsrelationen möglich 135 252-0027 Einführung in die Programmierung 10.0 Generische Programmierung Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016—2022 All rights reserved. Übersicht § 10.1 Einleitung § 10.2 ArrayList<Type> § 10.3 Vergleichen von Objekten § 10.4 Mengen § 10.5 Abbildungen § 10.6 Iteratoren § 10.7 Implementation eines einfachen generischen Typs 2 List + Array à ArrayList à ArrayList<T> § Abstraktion der Liste § Implementation mit fixem Array § Flexible Arrays § Typparameter 3 ArrayIntList à ArrayList<E> § Wir wollen diskutieren wie eine ArrayList<E> implemen- tiert werden könnten § Ziel: die prinzipiellen Schritte, nicht alle Details § Beschränkung auf einige wichtige Aspekte § Nur einzelne Methoden § Deckt sich nicht immer mit ArrayList<E> aus dem Collections Framework § Einige Aspekte sind auch nicht festgelegt bzw. öffentlich 4 Die Klasse LinkedIntList § Wir entwickelten eine Klasse die die Knoten mit int Werten versteckt: LinkedIntList § Verwendet ListNode Objekte zur Darstellung der Liste front LinkedIntList ListNode ListNode ListNode data next 42 data next -3 data next 17 5 LinkedIntList Klasse public class ListNode { int data; ListNode next; } public class LinkedIntList { private ListNode front; public LinkedIntList() { front = null; } // Methoden front = LinkedIntList 6 Methoden der Klasse LinkedIntList int get(int index) { … } void set(int index, int value) { … } boolean isEmpty() { … } void add(int value) { … } int removeFirst() { … } int removeLast() { … } void clear() { … } int[] toArray() { … } String toString() { … } 8 § Jetzt: ein Interface (IntList) und eine Klasse (LinkedIntList), die dieses Interface implementiert § Interface IntList enthält die Methoden, die eine LinkedIntList ausmachen. § Methoden müssen dann Sichtbarkeit public haben – kein Problem 9 Methoden des Interfaces IntList public interface IntList { public int get(int index) ; public void set(int index, int value) ; public boolean isEmpty() ; public void add(int value) ; public int removeFirst() ; public int removeLast() ; public void clear() ; public int[] toArray() ; public String toString() ; } 10 LinkedIntList mit Interface /** * A singly-linked list of integer values */ public class LinkedIntList implements IntList { public int get(int index) { .. } public void set(int index, int value) { .. } public void add(int value) { .. } … // constructors … /** * For internal use only. */ private ListNode getNode(int index) { .. } private ListNode front; public ListNode last; } 11 Eine andere Implementation … § Statt einer Kette von Knoten könnten wir einen Array benutzen § Der Array speichert die Werte § Wir machen den Array am Anfang genügend gross § Nur die Arrayelemente [0 .. (size-1)] sind relevant, der Rest ungenutzt § Nennen wir die Klasse ArrayIntList 12 Neue Klasse class ArrayIntList implements IntList {…} § Andere Implementation aller Methoden § Klienten sind davon nicht betroffen § Denn sie sollten mit dem Interface IntList arbeiten, nicht mit der Klasse § IntList myList = new LinkedIntList(); § IntList myList = new ArrayIntList(); 13 Neue Klasse class ArrayIntList implements IntList {…} § Andere Implementation aller Methoden § Klienten sind davon nicht betroffen § Denn sie sollten mit dem Interface IntList arbeiten, nicht mit der Klasse § IntList myList = new ArrayIntList(); § Vielleicht brauchen Operationen weniger Zeit § Manchmal nur konstanter Faktor für Big-O – aber wichtig in der Praxis 14 ArrayIntList public class ArrayIntList implements IntList { /** * For internal use only. */ private int[] data = new int[100]; private int size = 0; // constructors … // methods 15 add(int v) Wie würden wir einen Wert am Ende der Liste hinzufügen? add(42) 16 index 0 1 2 3 4 5 6 7 8 9 data 3 8 9 7 5 12 0 0 0 0 size 6 index 0 1 2 3 4 5 6 7 8 9 data 3 8 9 7 5 12 42 0 0 0 size 7 add(int v) public void add(int value) { data[size] = value; size++; } 17 add(int pos, int v) Wie würden wir einen Wert in der Mitte der Liste hinzufügen? add(3, 42) 18 index 0 1 2 3 4 5 6 7 8 9 data 3 8 9 7 5 12 0 0 0 0 size 6 index 0 1 2 3 4 5 6 7 8 9 data 3 8 9 42 7 5 12 0 0 0 size 7 add(int pos, int v) § Elemente in der Mitte einfügen ist nicht einfach § «rechts» der Einfügeposition müssen die Elemente verschoben werden § Reihenfolge ist kritisch public void add(int pos, int v) { for (int i = size; i > pos; i--) { data[i] = data[i - 1]; } data[pos] = v; size++; } 19 remove(int pos) § Wie können wir ein Element aus der Liste entfernen? remove(2) 20 index 0 1 2 3 4 5 6 7 8 9 data 3 8 9 7 5 12 0 0 0 0 size 6 index 0 1 2 3 4 5 6 7 8 9 data 3 8 7 5 12 0 0 0 0 0 size 5 remove(int pos) § Wir müssen (wieder) Elemente verschieben § Nach «links» § In welcher Reihenfolge? public void remove(int pos) { for (int i = pos; i < size; i++) { data[i] = data[i + 1]; } size--; data[size] = 0; // optional (why?) } 21 Weitere Methoden … public int get(int index) { … } public void set(int index, int value) { … } public boolean isEmpty() { … } public int size() { … } public String toString() { … } 22 Ausgangslage: Klasse ArrayIntList public class ArrayIntList { /** * For internal use only. **/ private int[] data = new int[100]; private int size = 0; // constructors … // methods 24 Problem: § Initialisierung durch «Initializer Block» § Unveränderbar Lösung: § Konstruktor Konstruktor(en) § Default (parameterloser) Konstruktor (fast) immer eine gute Idee 25 Klasse ArrayIntList class ArrayIntList implements IntList { /** * For internal use only. **/ private int[] data; private int size; ArrayIntList() { data = new int[100]; size = 0; } // methods 26 Konstruktor(en) § Dieses Design erlaubt dem Klienten nicht, Einfluss auf die Anfangsgrösse zu nehmen § Was wenn der Klient «weiss» dass 1000 Elemente gespeichert werden müssen? § Wir sehen (später) wie wir die Grösse des Arrays data anpassen können, aber Anpassungen sind nicht umsonst § Also definieren wir einen weiteren Konstruktor § Und definieren eine Standard(anfangs)kapazität § Soll nicht veränderbar sein: static final § Kann dann public sein 27 ArrayIntList public class ArrayIntList implements IntList { public static final int DEFAULT_CAPACITY = 100; private int[] data; private int size; ArrayIntList() { this(DEFAULT_CAPACITY); } ArrayIntList(int capacity) { data = new int[capacity]; size = 0; } 28 ArrayIntList (Basis Zusammenfassung) // Adds value to end of List // For now: no checks public void add (int value) { data[size] = value; size++; } //Adds value to position, shifts values with higher index public void add(int position, int value) { for (int i = size; i > position; i--) { data[i] = data[i - 1]; } data[position] = value; size++; } // Removes first item selected by index // List must not be empty public void remove(int position) { for (int i = position; i < size; i++) { data[i] = data[i + 1]; } data[size-1] = 0; // optional (why?) size--; } 31 ArrayIntList (Basis Teil 2) // uses -1 as indication of failure public int indexOf(int value) { for (int i = 0; i < size; i++) { if (data[i] == value) { return i; } } return -1; } // Returns value in list // at given index // 0 <= index < size() public int get(int index) { return data[index]; } 32 public String toString() { if (size == 0) { return \"[]\"; } else { String result = \"[\" + data[0]; //fencepost for (int i=1; i<size; i++) { result += \", \" + data[i]; } result += \"]\"; return result; } } Service Methoden § Ein Klient kann auf jedes Element zugreifen § Mittels get(index) § Aber wie weiss der Klient wieviele Elemente in der Liste sind? § Klient könnte/müsste Anzahl Elemente nachführen § Einschränkung für Klienten § Kann nicht das size Attribut lesen (ist aus guten Gründen private) § Darum Accessor Funktion size() 33 Mit ArrayIntList Exemplaren arbeiten § Eine sinnvolle Methode ist, die Elemente einer Liste an eine andere Liste anzuhängen § Method addAll(ArrayIntList other) 34 ArrayIntList // Accessor for size public int size() { return size; } // Liste other darf nicht null sein public void addAll(ArrayIntList other) { for (int i = 0; i< other.size; i++) { add(other.data[i]); } } } //ArrayIntList 35 Wenn es keinen Platz mehr gibt … add(15) 36 index 0 1 2 3 4 5 6 7 8 9 data 3 8 9 7 5 12 4 8 1 6 size 10 index 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 data 3 8 9 7 5 12 4 8 1 6 15 0 0 0 0 0 0 0 0 0 size 11 add(int v) public void add(int value) { data[size] = value; size++; } 37 § Wenn size==data.length dann gibt es zur Laufzeit eine (ArrayIndexOutOfBounds)Exception Anpassen der Grösse § Müssen die Grösse anpassen bevor versucht wird, in einem nicht-existierendes Element des Arrays data einen Wert zu speichern § Schritt 1: Wenn kein Platz ist: Ende der Programmausführung § Schritt 2: Wenn kein Platz ist: mehr Platz schaffen 38 Schritt 1: Kontrollierter Abbruch § Programm will über Grund des Abbruchs informieren § Nicht einfach auf nicht-vorhandenes Arrayelement in data zugreifen § Hätte ArrayIndexOutOfBoundsException zur Folge § Lösung: selber Exception werfen bevor illegaler Zugriff erfolgt § Welche Exception? § Eigene: muss dann angekündigt werden § Besser: IllegalStateException: Ein Methodenaufruf ist illegal oder wird zur Unzeit gemacht 3940 checkCapacity(int target) § Methode die prüft ob noch genügend Platz im data Array ist § Sichtbarkeit sollte private sein § Zweck ist Vereinfachung der Implementation, nicht für Klienten § Wirft IllegalStateException wenn nicht genug Platz private void checkCapacity(int target) { if (target > data.length) { throw new IllegalStateException(); } } 41 Betroffene Methoden § Einige Methoden müssen jetzt checkCapacity aufrufen: § add(value) public void add (int value) { checkCapacity(size+1); data[size++] = value; } § add(position, value) – genauso § addAll(other) public void addAll(ArrayIntList other) { checkCapacity(size+other.size); for (int i = 0; i< other.size; i++) { add(other.data[i]); } } 42 Bessere Implementation checkCapacity § Statt des parameterlosen Defaultkonstruktors können wir den Konstruktor nehmen der einen String akzeptiert private void checkCapacity(int target) { if (target > data.length) { throw new IllegalStateException( \"Insufficient capacity of list. Needed: \" + target + \" Elements\"); } } § Beispiel Exception in thread \"main\" java.lang.IllegalStateException: Insufficient capacity of list. Needed: 14 Elements at ArrayIntList.checkCapacity(ArrayIntListDriver.java:138) at ArrayIntList.addAll(ArrayIntListDriver.java:130) at ArrayIntListDriver.main(ArrayIntListDriver.java:42) 43 Schritt 2: mehr Platz schaffen Anstatt checkCapacity(target) eine Methode die einen neuen Array data erstellt: public void ensureCapacity(int target) { if (target > data.length) { int newCapacity = data.length * 2 + 1; if (target > newCapacity) { newCapacity = target; } data = Arrays.copyOf(data, newCapacity); } } 44 int[] newData = new int[newCapacity]; for (int i = 0; i<size; i++) { newData[i] = data[i]; } data = newData; 45 § Mehr Platz schaffen erfordert Kopieren der alten Werte § Daher Verdoppelung der Grösse § Aber auch anderes Strategien möglich (z.B. * 1.5) § Amortisieren des Overheads § Klient könnte diese Methode benutzen § Wenn der Klient weiss, wieviele Elemente (demnächst) hinzugefügt werden sollen § Daher Sichtbarkeit public § Siehe ensureCapacity(target) in ArrayList<E> aus java.util 46 ArrayList<E> § Statt ArrayIntList eine generische Klasse definieren § Ersetze int durch <E> wo Elemente betroffen sind § Nicht Position oder Grösse (also E[] data etc.) § ArrayIntList() Konstruktor wird ArrayList() § ArrayIntList(int capacity) wird zu ArrayList(int capacity) { data = new E[capacity]; //see next slide size = 0; } § Überarbeitetes addAll: addAll(ArrayList<E> other) § Fast alles … denn es gibt ein Problem 47 Arrays mit generischen Typen § Java lässt nicht zu einen generischen Array zu erstellen ArrayListDriver.java:66: error: generic array creation data = new E[capacity]; ^ § Es ist aber möglich einen Array Object[] zu erstellen und diesen mittels Cast in einen Array E[] zu verwandeln ArrayList(int capacity) { data = (E[]) new Object[capacity]; size = 0; } 48 Bemerkung § Auch das Erstellen eines generischen Objekts ist nicht möglich class Test<T> { T foo() { return new T(); //not allowed } } § Ein Cast ist notwendig class Test<T> { T foo() { return (T) new Object(); //allowed } } 49 Das ist fast alles … § Das Java keine generischen Arrays direkt erstellen kann hat kleinere Folgen – Programm wird mit Warnung übersetzt: ArrayListDriver.java:67: warning: [unchecked] unchecked cast data = (E[]) new Object [capacity]; | ^ | required: E[] | found: Object[] | where E is a type-variable: E extends Object declared in class ArrayList § Beschränkung des Java Typ Systems: ignorieren § Auch dafür gibt es eine Annotation @SuppressWarnings(\"unchecked\") ArrayList(int capacity) { … } 50 Weitere Anpassungen § Die Methode contains(value) liefert die Position des ersten Auftretens (oder -1 wenn value nicht in der Liste) § Der Test wurde mit == gemacht § Gute Wahl für int, nicht aber für Referenzen § Müssen equals(Object) verwenden // uses -1 as indication of failure public int indexOf(E value) { for (int i = 0; i < size; i++) { if (data[i].equals(value)) { return i; } } return -1; } 51 § In Methode remove(position) war überschreiben des alten Arrayelements optional data[size-1] = 0; // optional (why?) § Jetzt muss dieser Schritt durchgeführt werden data[size-1] = null; // mandatory 52 0 1 2 3 4 5 6 7 8 9 3 -5 7 42 0 0 0 0 0 0 § Was passierte wenn das int Element nicht überschrieben wird? remove(1) § In Methode remove(position) war überschreiben des alten Arrayelements optional data[size-1] = 0; // optional (why?) § Jetzt muss dieser Schritt durchgeführt werden data[size-1] = null; // mandatory 53 0 1 2 3 4 5 6 7 8 9 3 -5 7 42 0 0 0 0 0 0 § Was passierte wenn das int Element nicht überschrieben wird? remove(1) § In Methode remove(position) war überschreiben des alten Arrayelements optional data[size-1] = 0; // optional (why?) § Jetzt muss dieser Schritt durchgeführt werden data[size-1] = null; // mandatory 54 0 1 2 3 4 5 6 7 8 9 3 7 42 42 0 0 0 0 0 0 § Was passierte wenn das int Element nicht überschrieben wird? remove(1) § Zweimal 42 im Array § In Methode remove(position) war überschreiben des alten Arrayelements optional data[size-1] = 0; // optional (why?) § Jetzt muss dieser Schritt durchgeführt werden data[size-1] = null; // mandatory 55 0 1 2 3 4 5 6 7 8 9 null null null null null null § Was passiert wenn das <E> Element nicht überschrieben wird? remove(1) A someE B someT C someT D someT § In Methode remove(position) war überschreiben des alten Arrayelements optional data[size-1] = 0; // optional (why?) § Jetzt muss dieser Schritt durchgeführt werden data[size-1] = null; // mandatory 56 0 1 2 3 4 5 6 7 8 9 null null null null null null § Was passiert wenn das <E> Element nicht überschrieben wird? remove(1) A someT B someT C someT D someT § In Methode remove(position) war überschreiben des alten Arrayelements optional data[size-1] = 0; // optional (why?) § Jetzt muss dieser Schritt durchgeführt werden data[size-1] = null; // mandatory 57 0 1 2 3 4 5 6 7 8 9 null null null null null null § Was passiert wenn das <E> Element nicht überschrieben wird? remove(1) § Zwei Verweise auf Objekt D A someT B someT uner- reichbar C someT D someT § Mehrere Verweise auf Objekt D sind problematisch wenn später D auch entfernt werden soll § Garbage Collector kann nicht feststellen dass D unerreichbar ist § Elemente des Arrays data verweisen auf Exemplar und der Garbage Collector «weiss» nicht, dass kein Zugriff (durch diese Elemente) erfolgen kann 58 ArrayList<E> public class ArrayList<E> { public static final int DEFAULT_CAPACITY = 100; private E[] data; private int size; ArrayIntList() { this(DEFAULT_CAPACITY); } ArrayIntList(int capacity) { data = (E[]) new Object[capacity]; size = 0; } public void add (E value) {..} public void add(int pos, E value) { .. } public E get(int index) { .. } public void addAll(ArrayList<E> other) { .. } public int indexOf(E value) { for (int i = 0; i < size; i++) { if (data[i].equals(value)) { return i; } } return -1; } 60 Diskussion § ArrayList<E> enthält wichtig(st)e Methoden § Ist diese Implementation brauchbar? § Möchten Sie mir ihr arbeiten? § D.h. möchten Sie Klienten entwickeln? 61 Was fehlt? § Keine Absicherung gegen Fehler der Klienten § Was soll passieren wenn der Klient einen illegalen Wert für den Index angibt? § index == -1 ? § index >= size ? § index >= data.length ? 62 § Methode get(int index) ist nur sinnvoll wenn index legal ist § Dokumentation sollte festhalten was für Bedingungen erfüllt sein müssen damit die Operation ausgeführt werden kann § Wir nennen dies eine Precondition § Bedingungen die vor der Ausführung erfüllt sein muss // Pre : 0 <= index < size public E get(int index) { return data[index]; } § Auf was muss sich get(int index) verlassen können? 63 § Damit die Methode get(int index) ohne Probleme ausgeführt werden kann muss (für alle Exemplare von ArrayList<E>) gelten § data != null § size <= data.length § Diese Invarianten für das Objektexamplar müssen von allen Methoden garantiert werden § Was passiert wenn ein Klient diesen Code enthält ArrayList<String> a = new ArrayList<String>(0); a.get(0); //capacity 0 § Invarianten erfüllt aber get(0) erfüllt nicht die Precondition § Also kann die Methode nicht ausgeführt werden 64 § Die Implementation von ArrayList<E> muss sich absichern § Wenn die Precondition nicht erfüllt ist dann darf die Methode nicht ausgeführt werden § Wenn index illegal ist gibt es einen Fehler (in der Logik des Klienten) § (Beste) Antwort auf Anfragen die nicht erfüllt werden können: Exception werfen public E get(int index) { if (index >= size) { throw new IllegalArgumentException(\"Index \" + index +\" illegal\"); } return data[index]; } 65 Was fehlt? § Keine Absicherung gegen Fehler der Klienten § Dokumentation des Ergebnisses/Rückgabewertes § Was bewirkt diese Methode (Annahme: die Precondition ist erfüllt) § Dies nennen wir die Postcondition: Zustand des Exemplars nach der Ausführung // Post : returns element at given index public E get(int index) { … } 66 get(index) § (Objekt)invarianten und Pre-Condition(s) müssen ausreichen, Post-condition am Ende der Methode sicher zu stellen § // Inv: data != null § // Inv: size <= data.length // Pre : 0 <= index < size public E get(int index) { return data[index]; } // Post: get returns data[index], no other changes § Invarianten müssen am Ende gelten, nicht an beliebigen Punkten in der Methode § Brauchen aber manchmal weitere Aussagen in der Methode um folgern zu können 67 Arbeiten mit Aussagen § Für jeden Punkt im Programm (in der Methode) können wir Aussagen machen § Die dann entweder wahr oder nicht wahr sind § Vorsicht bei Schleifen: Punkt wird mehrfach erreicht § Eine Aussage kann einmal wahr sein (z.B. beim ersten Durchlauf durch den Rumpf der Schleife) und einmal nicht wahr sein (z.B. beim letzten Durchlauf) 68 Arbeiten mit Aussagen § Wenn wir entscheiden ob eine Aussage falsch oder wahr ist dann müssen wir konservativ sein, d.h. nur Annahmen machen die in jedem Fall erfüllt sind § Drei Optionen § Aussage ist immer wahr § Aussage ist niemals wahr § Aussage ist manchmal wahr (und manchmal nicht wahr) 69 Arbeiten mit Aussagen § Nehmen wir dieses Code Beispiel if (x > 3) { // Point A x--; } else { // Point B x++; // Point C } // Point D § Was können wir über den Wert von x an den 4 Stellen sagen? § Ist x > 3? IMMER? MANCHMAL? NIE? 70 x > 3 Point A Point B Point C Point D x > 3 Point A IMMER Point B NIE Point C MANCHMAL Point D MANCHMAL Aussagen und Programme § Wir können Aussagen über das Programm machen und fragen ob sie an bestimmten Stellen wahr sind. § Gültige Antworten sind IMMER, NIE, oder MANCHMAL. System.out.print(\"Type a nonnegative number: \"); double number = console.nextDouble(); // Point A: is number < 0.0 here? while (number < 0.0) { // Point B: is number < 0.0 here? System.out.print(\"Negative; try again: \"); number = console.nextDouble(); // Point C: is number < 0.0 here? } // Point D: is number < 0.0 here? MANCHMAL IMMER MANCHMAL NIE 72 Mit Aussagen arbeiten … § Direkt nachdem eine Variable initialisiert wurde, ist ihr Wert bekannt: int x = 3; // is x > 0? IMMER § Über die Werte von Parametern wissen wir i. A. nichts: public static void mystery(int a, int b) { // is a == 10? MANCHMAL § Innerhalb eines if, while, usw. wissen wir evtl. etwas: public static void mystery(int a, int b) { if (a < 0) { // is a == 10? NIE ... } } 73 Aussagen und Schleifen § Zu Beginn des Rumpfes einer Schleife muss der Test true , ergeben haben: while (y < 10) { // is y < 10? IMMER ... } § Direkt nach einer Schleife muss der Test false sein: while (y < 10) { ... } // is y < 10? NIE 74 Aussagen und Schleifen § Im Rumpf einer Schleife kann der Test false ergeben: while (y < 10) { y++; // is y < 10? MANCHMAL } 75 «Manchmal» § Verschiedene Aktivitäten können dazu führen, dass der Wert einer Variable unbekannt ist (diese führen dann zu «MANCHMAL» Antworten): § Eingabe von Scanner lesen § Lesen einer Zahl von einem Random Objekt § Übergabe eines Parameters § Wenn für eine Stelle im Programm sowohl die Antwort «ja» also auch «nein» möglich ist, dann ist die richtige Antwort «manchmal». § Wenn man sich nicht sicher ist dann ist «Manchmal» eine gute Vermutung 76 Beispiel 1 public static void mystery(int x, int y) { int z = 0; // Point A while (x >= y) { // Point B x = x - y; z++; if (x != y) { // Point C z = z * 2; } // Point D } // Point E System.out.println(z); } x < y x == y z == 0 Point A Point B Point C Point D Point E Welche Aussagen sind an diesen Stellen wahr? Möglich sind IMMER, NIE oder MANCHMAL. 77 Beispiel 1 public static void mystery(int x, int y) { int z = 0; // Point A while (x >= y) { // Point B x = x - y; z++; if (x != y) { // Point C z = z * 2; } // Point D } // Point E System.out.println(z); } x < y x == y z == 0 Point A Point B Point C Point D Point E MANCHMAL MANCHMAL IMMER NIE MANCHMAL MANCHMAL MANCHMAL NIE NIE MANCHMAL MANCHMAL NIE IMMER NIE MANCHMAL Welche Aussagen sind an diesen Stellen wahr? Möglich sind IMMER, NIE oder MANCHMAL. 78 Beispiel 2 public static int mystery(Scanner console) { int prev = 0; int count = 0; int next = console.nextInt(); // Point A while (next != 0) { // Point B if (next == prev) { // Point C count++; } prev = next; next = console.nextInt(); // Point D } // Point E return count; } next == 0 prev == 0 next == prev Point A Point B Point C Point D Point E Welche Aussagen sind an diesen Stellen wahr? Möglich sind IMMER, NIE oder MANCHMAL. 79 Beispiel 2 public static int mystery(Scanner console) { int prev = 0; int count = 0; int next = console.nextInt(); // Point A while (next != 0) { // Point B if (next == prev) { // Point C count++; } prev = next; next = console.nextInt(); // Point D } // Point E return count; } next == 0 prev == 0 next == prev Point A Point B Point C Point D Point E MANCHMAL IMMER MANCHMAL NIE MANCHMAL MANCHMAL NIE NIE IMMER MANCHMAL NIE MANCHMAL IMMER MANCHMAL MANCHMAL Welche Aussagen sind an diesen Stellen wahr? Möglich sind IMMER, NIE oder MANCHMAL. 80 Logische Aussagen für Liste § Wollen Elemente einer Liste (mit ListNode Knoten) ausgeben 83 § Müssen sicher sein dass temp (Referenz für ListNode Knoten) nicht null ist Von Aussagen zu Pre/Post-Conditions § Ist wahr am Punkt … ? (B: Loop test) 84 temp != null A B C E D temp!=null Point A Point B Point C Point D Point E Logische Aussagen für Liste § Ist wahr am Punkt … ? (B: Loop test) 85 temp != null A B C E D temp!=null Point A MANCHMAL Point B MANCHMAL Point C MANCHMAL Point D IMMER Point E MANCHMAL Logische Aussagen für Liste § Wollen Elemente einer Liste (mit ListNode Knoten) ausgeben 86 temp != null (gefordert) Logische Aussagen für Liste § Wollen Elemente einer Liste (mit ListNode Knoten) ausgeben 87 temp != null (gefordert) (garantiert) Logische Aussagen für Liste § Wollen Elemente einer Liste (mit ListNode Knoten) ausgeben 88 temp != null (garantiert) (garantiert) Zweite und weitere Ausführung(en) Logische Aussagen für Liste § Wollen Elemente einer Liste (mit ListNode Knoten) ausgeben 89 temp != null (gefordert) Erste Ausführung Logische Aussagen für Liste § Wollen Elemente einer Liste (mit ListNode Knoten) ausgeben 90 front != null (gefordert) Erste Ausführung Logische Aussagen für Liste § Wollen Elemente einer Liste (mit ListNode Knoten) ausgeben 91 Pre: front != null Pre- und Post-Conditions § (Objekt)invarianten und Pre-Condition(s) müssen ausreichen, Post-condition am Ende der Methode sicher zu stellen § «Rückwärts» schliessen: was muss beim Aufruf der Methode gelten damit die Post-Condition erfüllt wird? 92 ArrayList: Weitere Pre- und Postconditions // Pre : capacity >= 0 // Post: created empty list with requested capacity @SuppressWarnings(\"unchecked\") ArrayList(int capacity) { if (capacity < 0) { throw new IllegalArgumentException(\"Illegal length \" + capacity); } data = (E[]) new Object[capacity]; size = 0; } // Pre : size <= data.length // Post: value added to end of list public void add (E value) { ensureCapacity(size+1); data[size++] = value; } 93 // Pre : other != null // Post: list appended to end of list public void addAll(ArrayList<E> other) { if (other == null) { throw new IllegalArgumentException(\"Null list\"); //throw new NullPointerException(); } ensureCapacity(size+other.size); for (int i = 0; i< other.size; i++) { add(other.data[i]); } } 94 ArrayList: Weitere Pre- und Postconditions10.7.1 Overloading and generische Typen § Generische Typen wurden zu Java hinzugefügt (1.5, 2004) -- 8 Jahre nach erster Release § Tradeoff zwischen Schwierigkeit der Implementation, Kompatibilität mit exisitierenden Programmen, Ausführungskosten, …. § Retrofit einiger Klassen (Vector, ArrayList, …) § Augenmerk auf parallele Ausführung § Java Entwickler wollten rückwärts Kompatibilität § ... und möglichst wenige Änderungen der JVM etc. § Folgen (leider) noch sichtbar 95 (Stark) Vereinfacht § Compiler prüft Typen § Dann wird Information über Generics entfernt § «Type erasure» § JVM erfährt nicht die (generischen) Typen § Folge: Overloading funktioniert nicht wenn zwei (oder mehr) Methoden eine «ähnliche» Signatur haben § Selber generischer Typ mit unterschiedlichen Typparametern 96 class Test { public static void main(String[] args) { ArrayList<Number> fn = new ArrayList<Number>(); ArrayList<String> fs = new ArrayList<String>(); Test tester = new Test(); tester.myTest(fs); tester.myTest(fn); } void myTest(ArrayList<String> fs) { System.out.println(\"myTest::String\"); } void myTest(ArrayList<Number> fn) { System.out.println(\"myTest::Number\"); } } 97 class Test { public static void main(String[] args) { ArrayList<Number> fn = new ArrayList<Number>(); ArrayList<String> fs = new ArrayList<String>(); Test tester = new Test(); tester.myTest(fs); tester.myTest(fn); } void myTest(ArrayList<String> fs) { System.out.println(\"myTest::String\"); } void myTest(ArrayList<Number> fn) { System.out.println(\"myTest::Number\"); } } 98 class Test { public static void main(String[] void myTest(ArrayList<String> fs) { System.out.println(\"myTest::String\"); } void myTest(ArrayList<Number> fn) { System.out.println(\"myTest::Number\"); } } Error: | name clash: myTest(java.util.ArrayList<java.lang.Number>) and | myTest(java.util.ArrayList<java.lang.String>) have the same | erasure | void myTest(ArrayList<Number> fn) { | ^----------------------------------... Das System «sieht» ein Problem: void myTest(ArrayList) void myTest(ArrayList) haben die selbe Signatur 99 10.7.2 Typen und Subtypen 100 Zuweisungen (Basistypen) § xref und yref sind Variable der Basistypen X und Y xref = yref zulässig wenn Typ Y automatisch umgewandelt werden kann § Oder die Typen identisch sind § Automatische Umwandlung («cast») für kompatible Typen § Selbe Logik falls auf der RHS ein Ausdruck steht 101 Kombatibilität der Basistypen § Wichtige Basistypen: boolean, int, long, double § boolean ist inkompatibel mit int, long, double § Aber int, long und double sind kompatibel 102 int long double int long double explizite Konvertierung implizite Konvertierung implizite Konvertierung – potenziell mit Genauigkeitsverlust Zuweisungen (Referenzvariable) § aref und bref sind Referenzvariable für Typ A und Typ B aref = bref zulässig wenn Typ B mit Typ A kompatibel ist 103 Kompatibilität der Referenztypen § (Vereinfacht) Kompatibel wenn im selben «Zweig» der Typ Hierarchie § Entweder bestimmt durch Vererbung (bei Klassen) oder § Bestimmt durch Erweiterung (bei Interfaces) § Beispiel: Typ A ist Object und Typ B ist Integer dann ist aref = bref wegen class extends Object { … } erlaubt (Integer ist Subtyp von Object) 104 Basis- und Referenztypen § Variable der Basistypen können nicht in einem (arithmetischen) Ausdruck mit Referenztypen kombiniert werden § Ausnahme: Wrapper Typen und + Operator für String, z.B. \"\" + 3 § Für Wrapper Typen und Basistypen gilt: § Unboxing für Verwendung in Ausdruck § Boxing wenn Wert in Wrapper Exemplar gespeichert wird 105 Wie geht die Programmiersprache mit neuen Typen um? § Gegeben sind zwei Typen A und B, mit B Subtyp von A. § A und B bilden die Basis für zwei neue Typen, N(A) und N(B). § Was soll für N(A), N(B) gelten? § N(B) Subtyp von N(A)? § N(A) Subtyp von N(B)? § N(A) und N(B) stehen in keiner Beziehung § Ähnliche Überlegungen für Methoden der Typen A und B 106 Wie geht die Programmiersprache mit neuen Typen um? § Gegeben sind zwei Typen A und B, mit B Subtyp von A. § A und B bilden die Basis für zwei neue Typen, N(A) und N(B). § Was soll für N(A), N(B) gelten? § N(B) Subtyp von N(A)? -- Covarianz § N(A) Subtyp von N(B)? -- Contravarianz § N(A) und N(B) stehen in keiner Beziehung -- Invarianz § Ähnliche Überlegungen für Methoden der Typen A und B 107 Wo ist das wichtig? § Sei der neue Typ N(T) der Typ «Array von T» oder«T-Array», d.h. T[] in Java § Array Typen in Java sind covariant § jshell> ia = new Integer[5]; § ia ==> Integer[5] { null, null, null, null, null } § jshell> Object[] oa = ia; § oa ==> Integer[5] { null, null, null, null, null } § Zuweisung Object[] oa = ia ist erlaubt 108 § Methode foo(Object[] ox) kann mit einem Integer Array als Argument aufgerufen werden § Polymorphismus in Aktion § Nicht umsonst § Java JVM muss für jede Zuweisung zu einem Array Element prüfen ob diese Zuweisung erlaubt ist 109 § Java JVM muss für jede Zuweisung zu einem Array Element prüfen ob diese Zuweisung erlaubt ist § jshell> oa[0] = Integer.valueOf(7); // nach oa = ia; § $112 ==> 7 § jshell> oa[1] = \"String\"; § | Exception java.lang.ArrayStoreException: java.lang.String § | at (#113:1) § Mit einem Array mit Object Referenzen wäre das erlaubt § jshell> Object[] x = new Object[5]; § x ==> Object[5] { null, null, null, null, null } § jshell> x[1] = \"Test\"; § $115 ==> \"Test\" 110 Wo ist das wichtig? § Sei der neue Typ N(T) der Typ «ArrayList von T» oder«T-Array», d.h. ArrayList<T> in Java § Generische Typen sind invariant jshell> ArrayList<Integer> ai = new ArrayList<Integer>(); ai ==> [] jshell> ArrayList<Object> ao = ai; | Error: | incompatible types: java.util.ArrayList<java.lang.Integer> | cannot be converted to java.util.ArrayList<java.lang.Object> | ArrayList<Object> ao = ai; | ^^ § Bessere Compiler könnten Covariance erlauben … 111 Kompatibilität der Referenztypen § (Vereinfacht) Kompatibel wenn im selben «Zweig» der Typ Hierarchie § Entweder bestimmt durch Vererbung (bei Klassen) oder § Bestimmt durch Erweiterung (bei Interfaces) § Gilt auch für Arrays (von kompatiblen Typen), aber nicht für generische Typen 112 § Deswegen sind Arrays mit generischen Typen in Java «umständlich» § Siehe Konstruktor für (unsere) ArrayList<T> wie früher implementiert § Möglich aber nur mit Massage des Typ Systems § Nicht unser Thema § Sie wollen einen Array von Mengen? HashSet<Integer>[]? § Versuchen Sie es doch mit einer ArrayList § Eine ArrayList<Set<Integer>> ist leicht möglich 113 jshell> ArrayList<Set<Integer>> aset; aset ==> null jshell> aset = new ArrayList<Set<Integer>>(); aset ==> [] // leere Menge von Mengen jshell> aset.add(new HashSet<Integer>()); aset ==> [[]] // Menge enthaelt nur leere Menge aset.add(new HashSet<Integer>(Arrays.asList(1, 2, 3))); aset ==> [[], [1, 2, 3]] // zwei Mengen: {} und {1, 2, 3} aset.add(new HashSet<Integer>(Arrays.asList(3, 2, 1))); aset ==> [[], [1, 2, 3], [1, 2, 3]] // ha! «equals« ... aset.add(new TreeSet<Integer>(Arrays.asList(3, 2, 1))); aset ==> [[], [1, 2, 3], [1, 2, 3], [1, 2, 3]] // auch TreeSet 114 Warum? § Jedes «Feature» einer Programmiersprache ist Ergebnis einer Abwägung («Tradeoff») § Schwierigkeit der Implementation, Kompatibilität mit exisitierenden Programmen, Ausführungskosten, …. 115 Schlussbemerkungen § Entwickeln von generischen Klassen nicht Thema der Vorlesung § Sie sollten mit dem Collections Framework arbeiten können aber wir erwarten (und prüfen) nicht, dass Sie solche Klassen entwickeln könn(t)en § Sie sollten wissen wann Wrapper Typen gebraucht werden § Vorsicht bei (vermeintlichen) Overloading Problemen § Kein direktes Erstellen eines generischen Typs/generischen Arrays mit new 116 static Nested Classes 117 LinkedIntList/ ListNode Beispiel class LinkedIntList { private ListNode front; public String toString() {} //Adds value to end of List void add (int value) { } int remove() { } ... } // LinkedIntList class ListNode { int data; ListNode next; ListNode() { } ListNode(int v) { } ListNode(int v, ListNode c){} public String toString() {} } // ListNode 118 LinkedIntList/ ListNode Beispiel class LinkedIntList { private ListNode front; public String toString() {} //Adds value to end of List void add (int value) { } int remove() { } ... } // LinkedIntList class ListNode { int data; ListNode next; ListNode() { } ListNode(int v) { } ListNode(int v, ListNode c){} public String toString() {} } // ListNode 119 next = new ListNode(...) LinkedIntList/ ListNode Beispiel class LinkedIntList { private ListNode front; public String toString() {} class ListNode { int data; ListNode next; ListNode() { } ListNode(int v) { } ListNode(int v, ListNode c){} public String toString() {} } // ListNode //Adds value to end of List void add (int value) { } int remove() { } ... } // LinkedIntList 120 next = new ListNode(...) LinkedIntList/ ListNode Beispiel class LinkedIntList { private ListNode front; public String toString() {} class ListNode { int data; ... } // ListNode //Adds value to end of List void add (int value) { } int remove() { } ... public static void main(String[] a) { LinkedIntList myList; myList = new LinkedIntList(); } } // LinkedIntList 121 next = new ListNode(...) LinkedIntList/ ListNode Beispiel class LinkedIntList { private ListNode front; public String toString() {} class ListNode { int data; ... } // ListNode //Adds value to end of List void add (int value) { } int remove() { } ... public static void main(String[] a) { LinkedIntList myList; myList = new LinkedIntList(); ListNode n = new ListNode(); } } // LinkedIntList 122 next = new ListNode(...) Nicht erlaubt! Kein umschliessendes Exemplar von LinkedIntList LinkedIntList_3.java:117: error: non-static variable this cannot be referenced from a static context ListNode n = new ListNode(); ^ 1 error § Exemplare der Klasse ListNode können nur in einem Exemplar der Klasse LinkedIntList existieren § Kann daher nicht in static Methode erstellt werden § Wie Attribute (eines Exemplars): nur sichtbar wenn es Exemplar gibt § Einfache «Lösung»: Klasse static deklarieren § Kann dann von allen static Methoden verwendet werden 123 Fehlermeldung LinkedIntList/ ListNode Beispiel class LinkedIntList { private ListNode front; public String toString() {} static class ListNode { int data; ... } // ListNode //Adds value to end of List void add (int value) { } int remove() { } ... public static void main(String[] a) { LinkedIntList myList; myList = new LinkedIntList(); ListNode n = new ListNode(); } } // LinkedIntList 124 next = new ListNode(...) Nun erlaubt! Kein Exemplar von LinkedIntList nötig Zusammenfassung § static «nested classes» können verwendet werden § Von (non-static) Methoden der umschliessenden (outer) Klasse § Denn diese werden für ein Exemplar der Outer Klasse ausgeführt § Von static Methoden der Outer Klasse § non-static «nested classes» («inner classes») können nur von (non-static) Methoden der umschliessenden (outer) Klasse verwendet werden § Verwendet: new Operator, Referenzvariable, ... 125 Anderes Beispiel class Main { static class Tuple implements Comparable<Tuple> { } // Tuple public static int getMinimumCost( int n, int[][] A) { } public static void main(String[] a){ } } // Main 126 Kann mit Tuple arbeiten Kein Exemplar von Main nötig Zusammenfassung § Eine static (Klassen-)Variable (die wir nicht oder selten verwenden sollten) existiert einmal für alle Exemplare der Klasse § ... und auch ohne Exemplare der Klasse § Eine static «nested class» ist den static Methoden und den non-static Methoden bekannt (d. h. kann verwendet werden) § Ob die Exemplare (der «nested class») gelesen/geschrieben werden können hängt von den Referenzvariablen ab § Muss Exemplar erreichen können um es zu lesen/schreiben 127 252-0027 Einführung in die Programmierung 11.0 Systematisches Programmieren Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016--2022 All rights reserved. Übersicht § 11.1 Abstrakte Datentypen (ADT) in Java § 11.2 Objekt Invarianten § 11.3 Entwurf von Klassen § 11.4 Kompatible Anweisungen § 11.6 Reale Probleme § 11.7 Beispiel(e) 2 11.1 Abstrakte Datentypen in Java … im Kontext des Collections Frameworks 3 Abstrakte Daten Typen (ADT) § Abstrakter Daten Typ (ADT): Spezifikation einer Ansammlung von Daten und der Operationen, die mit diesen Daten ausgeführt werden können. § Beschreibt was eine Ansammlung macht (oder mir ihr getan werden kann), nicht wie sie es macht § Wissen nicht wie eine bestimmte Ansammlung implementiert ist – und brauchen dies auch nicht zu wissen. § Wir müssen nur das Konzept der Ansammlung verstehen, sowie die Operationen, die damit ausgeführt werden können. Abstrakte Daten Typen (ADT) § In Java (insbesondere im Collections Framework) beschreiben wir ADTs mit Interfaces: § Collection, Deque, List, Map, Queue, Set, SortedMap § Ein ADT kann dann durch verschiedene Klassen realisiert sein: § ArrayList und LinkedList implementiert List § HashSet und TreeSet implementiert Set § LinkedList , ArrayDeque, etc. implementiert Queue Arbeiten mit ADT Interfaces § Es ist eine gute Idee die Variablen für Ansammlungen als Variable des ADT Interface Typs zu deklarieren: List<String> list = new ArrayList<String>(); § Genauso sollten Methoden entsprechende Parameter mit ADT Interface Typen deklarieren: public void process(List<String> list) { ... } Arbeiten mit ADT Interfaces § Es ist eine gute Idee die Variablen für Ansammlungen als Variable des ADT Interface Typs zu deklarieren: List<String> list = new ArrayList<String>(); § Genauso sollten Methoden entsprechende Parameter mit ADT Interface Typen deklarieren: public void process(List<String> list) { ... } § Flexibilität! Wir können diesen Code wiederverwenden Warum sollten wir ADT verwenden? § Wer will mehr als eine Art von Listen, Warteschlangen, etc? § Jede Implementation kann für bestimmte Aufgaben effizienter sein 11.1.1 Laufzeitverhalten 9 ArrayList<Type> – was wollen wir mehr? § List Operationen: § add(value): default ist Einfügen am Ende § Mit add(index, value): in der Mitte möglich § Unbegrenzte Grösse § Lesen eines beliebigen Elemente in O(1) 10 add(value) add(index, value) get(index) remove(index) set(index, value) size() toString() Beispiel § Schreiben Sie ein Programm das «eine grosse Anzahl» von Werten einliest und dann in der umgekehrten Reihenfolge ausgibt § Grosse Anzahl: 100'000, 1'000'000, …. § Keine weiteren Operationen (für dieses Beispiel) § Wir wollen eine Klasse des Collections Frameworks benutzen § Wollen offen halten welche Klasse verwendet werden soll 12 Beispiel § Mögliche Methode public static void task() { CollectionType c = ... process(c); } § Wirkliche Arbeit wird in Methode process erledigt public static void process(CollectionType c) { // get input // output in reverse order } 13 Beispiel – Fortsetzung § Nehmen wir an wir haben es mit Integer Werten zu tun List<Integer> c = new ArrayList<Integer>(); public static void process(List<Integer> c) { // … } § Diese Methode kann mit ArrayList<Integer> Exemplaren verwendet werden § Aber ist ArrayList der beste Typ für diese Aufgabe? § Was gibt es denn noch? 14 Java Collections Framework 15 <<Interface> Collection <<Interface> List <<Interface> Set LinkedListArrayList TreeSet <<Interface> SortedSet HashSet <<Interface> Map TreeMap <<Interface> SortedMap HashMap LinkedList<E> § Benutzt einen Knoten Typ ähnlich den ListNodes aus früheren Vorlesungen § Enthält Referenz auf ein Objektexemplar vom Typ E § In der Praxis doppelt-verlinkte Liste mit Verweisen auf das erste und letzte Element der Liste § Eine andere Implementation des List Interfaces § Evtl. unterschiedliche Implementationen in verschiedenen Java Systemen oder für verschiedene Anwendungen 16 List<E> 1718 LinkedList Methoden add(value) appends value at end of list add(index, value) inserts given value just before the given index, shifting subsequent values to the right clear() removes all elements of the list indexOf(value) returns first index where given value is found in list (-1 if not found) get(index) returns the value at given index remove(index) removes/returns value at given index, shifting subsequent values to the left set(index, value) replaces value at given index with given value size() returns the number of elements in list toString() returns a string representation of the list such as \"[3, 42, -7, 15]\" 19 Kommt uns diese Liste bekannt vor? 20 Kommt uns diese Liste bekannt vor? § Die selben Methoden sind für ArrayList definiert. 21 ArrayList Methoden add(value) appends value at end of list add(index, value) inserts given value just before the given index, shifting subsequent values to the right clear() removes all elements of the list indexOf(value) returns first index where given value is found in list (-1 if not found) get(index) returns the value at given index remove(index) removes/returns value at given index, shifting subsequent values to the left set(index, value) replaces value at given index with given value size() returns the number of elements in list toString() returns a string representation of the list such as \"[3, 42, -7, 15]\" 22 Beispiel – Fortsetzung § Nehmen wir an wir haben es mit Integer Werten zu tun public static void process(List<Integer> c) { // … } § Diese Methode kann für ArrayList<Integer> und LinkedList<Integer> Exemplare verwendet werden § Welche Klasse ist besser? 23 Das Kleingedruckte § LinkedList: get(index) braucht O(n) Zeit § ArrayList: get(index) braucht O(1) Zeit 24 All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. The size, isEmpty, get, [and] set [..] operations run in constant time. The add operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation. Das Kleingedruckte § Ist also eine ArrayList immer besser als eine LinkedList? § Sicher wenn das Programm überwiegend get(index) Operationen ausführt § Gibt es auch Operationen für die eine LinkedList schneller sind als für eine ArrayList? 25 Das Kleingedruckte § LinkedList: add(0, value) braucht O(1) Zeit § ArrayList: add(0, value) braucht O(n) Zeit 26 All of the operations perform as could be expected for a doubly-linked list. The add operation (default: add at the end) runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations (including add at position index) run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation. Was passiert bei add(position, value) bei einer ArrayList? 27 add(int pos, int v) Wie würden wir einen Wert in der Mitte der Liste hinzufügen? add(3, 42) 28 index 0 1 2 3 4 5 6 7 8 9 data 3 8 9 7 5 12 0 0 0 0 size 6 add(int pos, int v) Wie würden wir einen Wert in der Mitte der Liste hinzufügen? add(3, 42) 29 index 0 1 2 3 4 5 6 7 8 9 data 3 8 9 7 5 12 0 0 0 0 size 6 index 0 1 2 3 4 5 6 7 8 9 data 3 8 9 42 7 5 12 0 0 0 size 7 § Was passiert bei add(0, value) bei einer ArrayList mit 100'000 Elementen? 30 public void add(int pos, int v) { for (int i = size; i > pos; i--) { nums[i] = nums[i - 1]; } nums[pos] = v; size++; }§ (Fast) 100'000 Elemente müssen verschoben werden! Ansammlungen § Was für eine Ansammlung (collection) ist die beste für dieses Problem? § Das hängt vom Programm ab. § Wie kann man diese Frage beantworten? Was müssen wir wissen? § Idealerweise schreiben wir Methode process so dass wir sie für möglichst viele Ansammlungstypen verwenden können 31 Praktische Analyse § Müssen das Laufzeitverhalten für realistischen Input messen § Was ist «realistischer» Input? § Zeitmessungen nicht einfach § Java System hat viele Komponenten (einige haben wir noch garnicht kennengelernt) und verschiedene Compiler § Einfache Messung gibt uns «end-to-end» Übersicht § System.currentTimeMillis() oder System.nanoTime() § Eingebaut 32 System.currentTimeMillis() § Gibt die Zeit (in ms) seit 00:00, 1. Januar 1970. § Typ des Rückgabewertes ist long § 64 Bits § Kann wiederholt aufgerufen werden um die Ausführungszeit einer (genügend lange laufenden) Methode zu messen 33 System.nanoTime() The java.lang.System.nanoTime() method returns the current value of the most precise available system timer, in nanoseconds. The value returned represents nanoseconds since some fixed but arbitrary time (perhaps in the future, so values may be negative) and provides nanosecond precision, but not necessarily nanosecond accuracy. § Typ des Rückgabewertes ist long § Kann wiederholt aufgerufen werden um die Ausführungszeit einer (genügend lange laufenden) Methode zu messen 34 List<Integer> aList = new ArrayList<Integer>(); long startTime = System.nanoTime(); for (int i = 0; i < 100000; i++) { aList.add(0, Integer.valueOf(i)); } long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(\"ArrayList add: \" + duration); 36 Beispiel – Fortsetzung public static void process(List<Integer> c) { // get input // print in reverse order } § Diese Methode kann für ArrayList<Integer> und LinkedList<Integer> Examplare verwendet werden § Welche Klasse ist besser? 37 Beispiel – Messungen § 100'000 Integer Werte hinzufügen list.add(Integer.valueOf(i)) § Messungen § Durchschnitt von 4 Ausführungen ( ! Vorsicht!! ) § Intel(R) Xeon(R) CPU E5-4640 0 @ 2.40GHz, OpenJDK (1.8.0_161-b14) 38 Klasse Zeit (ns) LinkedList 9'312'254 9.312E+06 ArrayList 11'972'638 1.197E+07 § Ernsthafte Evaluationen müssen viele Aspekte berücksichtigen § Mehrfache Ausführung des selben Programms § Durchschnitt (arithmetisch, harmonisch, geometrisch) § k-out-of-N § Prozessoren sind komplex § Speicher Hierarchie § Echte Clock Rate § Java Umgebung ist komplex 40 Messungen (für Durchschnitt auf letztem Slide) § ArrayList: 41 Time (ns) 12'881'027 11'416'029 11'446'881 12'146'617 Time (ns) 8'711'755 10'547'642 9'001'888 8'987'733 § LinkedList: § Grosse Variationen (Low Precision) § Einfügen/Entfernen am Anfang geht sehr schnell in einer LinkedList – bei vielen anderen Operationen gewinnt die ArrayList haushoch Messungen (openjdk version \"17.0.4.1\" 2022-08-12) § ArrayList (ns): 42 5.6695E+08 6.2218E+08 5.1743E+08 5.3626E+08 5.9327E+08 4.9550E+08 4.8707E+08 7.1691E+08 § LinkedList (ns): § Mac (2017, 16 GB 2133 MHz LPDDR3) 2.8 GHz Quad-Core Intel Core i7 7.6516E+06 7.8430E+06 7.1460E+06 7.9119E+06 7.8321E+06 7.1287E+06 7.9476E+06 7.7520E+06 Durchschnitt Vorsicht § Trauen Sie nur Daten die Sie selbst gemessen haben ... § LinkedList ist oft langsamer als ArrayList § Messungen für add(Integer.valueOf(i)) § Einfügen am Ende 43 Klasse Zeit (ns) LinkedList 6'001'076 6.0011E+06 ArrayList 5'546'068 5.5461E+06 Vorsicht § Trauen Sie nur Daten die Sie selbst gemessen haben ... § LinkedList ist oft langsamer als ArrayList § Messungen für add(Integer.valueOf(i)) § Einfügen am Ende 44 Klasse Zeit (ns) LinkedList 6'001'076 6.0011E+06 ArrayList 5'546'068 5.5461E+06 P. Geoffrey Lowney et al., \"The Multiflow Trace Scheduling Compiler\" Beispiel § Schreiben Sie ein Programm, das zählt wie viele verschiedene Wörter in einem Text auftauchen (z.B., Tolstois «Krieg und Frieden» [Война и мир] oder Goethes «Faust»). § Speichern Sie die Wörter in einer (An)Sammlung und geben Sie die Anzahl der aufgetretenen Wörter aus. § Sind «[das] Gute», «gute», «gut», «guter», «guten» verschieden? § Nach dem Einlesen des Textes sollte es möglich sein, festzustellen ob ein bestimmtes Wort im Text auftritt. 45 Beispiel § Input: Thomas Mann, Die Buddenbrooks, 1'602'177 Bytes § Quelle: Projekt Guttenberg § Lesen der Datei, Einfügen in Collection § Intel(R) Xeon(R) CPU E5-4640 0 @ 2.40GHz, OpenJDK (1.8.0_161-b14) 46 Klasse Zeit (ms) LinkedList 662 ArrayList 615 § Nach dem Einlesen des Textes sollte es möglich sein, festzustellen ob ein bestimmtes Wort im Text auftritt. § Was für eine Methode brauchen wir? § Frage im Chat: From to trg2 (Direct Message) : Wie schnell funktioniert contains? O(1)? All of the other operations run in linear time (roughly speaking). 48 contains(value) returns true if given value is found somewhere in this list Messungen § Input: Thomas Mann, Die Buddenbrooks, 236'239 Wörter § Quelle: Projekt Guttenberg § Suche (1000 x, 18 Wörter) § Intel(R) Xeon(R) CPU E5-4640 0 @ 2.40GHz, OpenJDK (1.8.0_161-b14) 49 Klasse Zeit (ms) LinkedList 31'520 ArrayList 8'083 Mehr Messungen für andere Klassen § Input: Thomas Mann, Die Buddenbrooks, 236'239 Wörter § Quelle: Projekt Guttenberg § Suche (1000 x, 18 Wörter) § Intel(R) Xeon(R) CPU E5-4640 0 @ 2.40GHz, OpenJDK (1.8.0_161-b14) 52 Klasse Zeit (ms) LinkedList 31'520 ArrayList 8'083 HashSet 2 TreeSet 10 Noch mehr Kleingedrucktes 55 Wo finden wir die Information? Jetzt 5657 Auszug ... 58Weitere Details Warum sollten wir ADT verwenden? § Wer will mehr als eine Art von Listen, Warteschlangen, etc? § Jede Implementation kann für bestimmte Aufgaben effizienter sein § ArrayList ist schneller wenn wir Elemente am Ende einfügen/entfernen; LinkedList ist schneller wenn wir Elemente in der Mitte oder am Anfang einfügen/entfernen; § HashSet findet einen Wert in einer grossen Menge in kurzer Zeit; TreeSet speichert die Werte sortiert. Deshalb: Variable möglichst mit ADT Interfaces § Es ist eine gute Idee die Variablen für Ansammlungen als Variable des ADT Interface Typs zu deklarieren: List<String> list = new ArrayList<String>(); § Können später konkreten Typ für Darstellung anpassen/auswählen § Und das Programm funktioniert immer noch § Vorteil der Abstraktion Abstraktion § Prozedural: § Details des Verhaltens (Prozeduren, z.B. der Methoden) nicht sichtbar § Spezifikation des Verhaltens ist die Abstraction § Müssen die Spezifikation mit einer Implementation erfüllen § Darstellung: § Details der Datendarstellung nicht sichtbar § Auch ein Weg Eigenschaften zu spezifizieren § Ein Ansatz über Programm + Daten zu folgern § Standard Terminologie: Abstrakte Data Typen, oder ADT 61 Warum ist Daten Abstraktion so wichtig § Arbeiten mit Daten zentrales Thema vieler Anwendungen § «Datenverarbeitung» § Data Science § Entwickeln (und Beschreiben) von Algorithmen seltener § Überlegen Sie sich welche Datenstrukturen Sie brauchen § Wie werden die wichtigen Daten organisiert? § Welche Operationen dürfen/müssen Klienten mit den Daten machen? 62 Warum ist Daten Abstraktion so wichtig § Mögliche Probleme die sich beim Ausarbeiten der Abstraktion der Datendarstellung ergeben können: § Entscheidungen für/gegen eine Datenstruktur werden zu früh gemacht § Unnötige Wiederholungen (insbesondere wenn Transformationen gemacht werden) § Spätere Änderungen der (Kern) Datenstrukture(n) oft schwierig bzw aufwendig § Gliederung in Module hilft ist aber nicht einfach 63 Ein ADT definiert Operationen § ADT abstrahiert die Organization und betont die Bedeutung der Daten § ADT ändert Fokus von Struktur auf Gebrauch § Darstellung sollte für den Klienten nicht wichtig sein § Daher sollte sie nicht sichtbar sein! § Denken im Raum der Operationen § Erstellen eines Exemplars, getBase, getAngle, …. 64 class RightTriangle { double base, altitude; } class RightTriangle { double base, hypot, angle; } Ein ADT definiert Operationen § ADT abstrahiert die Organization und betont die Bedeutung der Daten § ADT ändert Fokus von Struktur auf Gebrauch § Darstellung sollte für den Klienten nicht wichtig sein § Daher sollte sie nicht sichtbar sein! § Denken im Raum der Schnittstellen (d.h. interface) § Erstellen eines Exemplars, getBase, getAngle, …. 65 class RightTriangle { double base, altitude; } class RightTriangle { double base, hypot, angle; } Vorteile eines Fokus auf ADTs § Wenn Klienten die Datenabstraktion respektieren (oder respektieren müssen) § z.B. Klient arbeitet mit einem «Punkt in einer 2-dim Ebene mit diesen Operationen» § Entscheidung über die Implementation des ADT kann aufgeschoben werden § Können Fehler durch Änderung der Darstellung beheben § Algorithmen können geändert werden § Um (bessere) Leistung zu erhalten § Um besondere Situationen auszunutzen 66 Collections Framework Drei wichtige Interfaces: List, Map und Set Abstrakte Datentypen (ADT) mit unterschiedlichen Vor- und Nachteilen 67 ADT Implementationen Vorteile Nachteile Einsatzbeispiel List ArrayList LinkedList Elemente in Reihenfolge des Einfügens gespeichert, Operationen am Ende schnell Langsame suche, langsames hinzufügen oder entfernen irgendwelcher (beliebiger) Elemente Zeilen einer Datei, GUI Elemente, Liste von Konten Set HashSet TreeSet Menge von Unikaten die schnell durchsucht werden kann Kein Index, kein Zugriff auf beliebige Elemente Unterschiedliche Wörter in Text, Lotteriezahlen Map HashMap TreeMap Speichert Beziehungen zwischen «key» und «value» Paaren von Objekten Spezielle Ansammlung, keine Umkehrung der Beziehungen Zählen von Wörtern oder anderen Objekten, Telefonbuch, Adressbuch Weitere (interessante) ADT § Wir haben eine Liste § Interface List § Werte werden nur am Anfang hinzugefügt oder entfernt § Können die Operationen schlecht add(v) und remove() nennen § Wollen auch nicht immer add(0, v) oder remove(0) verwenden § Brauchen neue Namen § push(v): füge am Anfang hinzu § pop(): liefert Wert am Anfang 68 Stack: besondere Liste § Weitere (mögliche) Operationen § peek(): Erstes Element ansehen (statt get(0) oder top()) § isEmpty() existiert schon (aus Collection) 69 Deque: besondere Listen § Einfügen und Entfernen an beiden Enden der Liste 70 11.1.2 Abstrakte Klassen 71 LinkedList und ArrayList § Gleiches Verhalten (Menge von Methoden, Effekt der Methoden), unterschiedliche Implementation § Einige Methoden können für beide Klassen (evtl) durch den selben Code implementiert werden § size() § contains() § isEmpty() 72 public int size() { return size; } public boolean contains(int value) { return (indexOf(value) >= 0); } public boolean isEmpty() { return (size() == 0); } § Diese Methoden könnten im Interface List implementiert werden § Muss aber dann eine Klasse sein wenn auf Attribute zugegriffen wird Methoden von ArrayList und LinkedList § Sollten wir List in eine Klasse umwandeln? Warum/Warum nicht? § Können wir auf andere Weise diese (häufige) Situation behandeln? 77 Abstrakte Klassen («Abstract Classes») § abstract class: Eine spezielle Klasse die eine Mischform zwischen Interface und Klasse ist. § Definiert einen Superclass-Typ mit Methodendeklarationen (wie ein Interface) und vollständigen Methoden (mit Rumpf/Body) (wie eine Klasse). § Definiert Attribute (wie eine Klasse) oder Konstanten (wie ein Interface oder Klassen) § Für abstrakte Klassen können keine Exemplare erstellt werden (d.h. der new Operator kann nicht Exemplare dieses Typs generieren). § Klassen die nicht abstrakt sind (wie unsere bisherigen Klassen) heissen konkrete («concrete») Klassen § Abstrakte Klassen können erweitert werden § Erweiterte Klasse ist entweder auch abstrakt oder konkret (wenn es für alle Methoden eine Implementation gibt) § Regeln für Erweiterung wie bei konkreten Klassen § Was gehört in eine abstrakte Klasse? § Implementation gemeinsamen Zustandes (Attribute) oder gemeinsamen Verhaltens die von allen Subclasses geerbt werden soll (abstrakte Klassen sind Superclasses in der Vererbungshierarchie) § Abstrakte Methoden die die Subclasses implementieren müssen § Schreiben Verhalten vor (Rolle eines Interfaces) 79 Abstract Class Syntax § Keyword abstract // declaring an abstract class public abstract class name { ... // declaring an abstract method // (any subclass must implement it) public abstract type methodName(parameters); } Methoden: Deklaration – Definition § Deklaration (in abstrakter Klasse) § Mit Keyword abstract § Muss Parameter, Rückgabewert und Sichtbarkeit festlegen § Definition (in konkreter Unterklasse/Subclass) § Mit Rumpf § Kann in abgeleiteten Klassen überschrieben werden § Es gelten die Sichtbarkeitsregeln für überschriebene Methoden 81 § Können Referenzvariable eines abstrakten Typs deklarieren (aber nicht Objektexemplare generieren) § Wie bei Interfaces § Eine Erweiterung (mittels extends) ist auch wieder abstrakt (und muss als abstract deklariert sein) sofern nicht alle abstrakten Methoden implementiert sind § Eine Klasse kann als abstract deklariert werden, auch wenn sie keine abstrakten Methoden enhält § Verhindert Konstruktion von Exemplaren 82 Abstract Classes vs. Interfaces § Normale Klassen die behaupten, ein Interface zu implementieren, müssen alle Methoden des Interfaces implementieren: public class Empty implements IntList {} // error § Abstrakte Klassen können behaupten, ein Interface zu implementieren ohne Code für die Methoden zu enthalten – eine Subclass muss die Methoden implementieren. public abstract class Empty implements IntList {} // ok public class Child extends Empty {} // error Abstrakte Klassen § Erlauben Wiederverwendung von (partiellen) Lösungen § Vielfach in der Implementation des Java Systems eingesetzt 84 Java Collection Framework 85 <<Interface> Collection <<Interface> List <<Interface> Set AbstractCollection AbstractList AbstractSet AbstractSequentialList LinkedListArrayList TreeSet <<Interface> SortedSet HashSet <<Interface> Map AbstractMap TreeMap <<Interface> SortedMap HashMap Java Evolution § Ursprünglich durfte ein interface nur abstrakte Methoden (ohne Rumpf) und Konstanten enthalten § Spätere Revisionen der Sprache erlauben auch, in einem interface konkrete Methoden anzugeben § Müssen aber immer public sein § Für uns kein Thema (unsere Programme sind nicht so umfangreich ...) 86 Übersicht § 11.1 Abstrakte Datentypen (ADT) in Java § 11.2 Objekt Invarianten § 11.3 Entwurf von Klassen § 11.4 Kompatible Anweisungen § 11.6 Reale Probleme § 11.7 Beispiel(e) 87 11.2 Objekt Invarianten § Manchmal können/müssen alle Exemplare eine Bedingung erfüllen § Diese Bedingung muss vor und nach der Ausführung aller Methoden gelten § Aber nicht (unbedingt) während der Ausführung § So wie es Invarianten für Schleifen gibt so kann man Invarianten für Objekte definieren § Müssen für jedes Exemplar gelten § Müssen gelten wenn Zugriff auf Exemplar möglich ist 88 Objekt Invarianten § Muss nach der Konstruktion des Exemplars gelten § Verantwortung des Konstruktors § Objekt Invariante: Precondition und Postcondition jeder Methode § Sollten in der Klassendefinition aufgeführt werden § Gute Dokumentation auch wenn nicht für Beweise verwendet § Manchmal Klasseninvarianten («class invariants») genannt 899193 Klasse ZeitSpanne // Darstellung eines Zeit Intervals von Stunden und Minuten public class ZeitSpanne { private int stunden; private int minuten; … } 96 Konstruktor(en) § Ein Konstruktor für ZeitSpanne Objekte wird Stunden und Minuten als Parameter akzeptieren und ein entsprechendes Objektexemplar konstruieren § Evtl. brauchen wir auch den parameterlosen Konstruktor – aber was ist eine gute Defaultzeitspanne? § Damit aber ergeben sich zwei Probleme 97 Problem 1: ZeitSpanne(int stunden, int minuten) § Ist es zulässig dass minuten >= 60 ist? § Was machen wir wenn z.B. der Klient eine ZeitSpanne von 0 Stunden und 147 Minuten konstruieren will? Konvertieren nach 2 Std und 27 Min? § Wer ist dafür verantwortlich? § Klient § ZeitSpanne Klasse 100 Problem 2: ZeitSpanne(int stunden, int minuten) § Was sollten wir machen wenn stunden<0 oder minuten<0 ? § Negative Werte sind nicht erlaubt § Wie darauf reagieren? § Auf 0 setzen? § IllegalArgumentException werfen 103 Klasse ZeitSpanne § Attribut minuten für ZeitSpanne Exemplare muss zwischen 0 und 59 (einschliesslich) liegen § Illegale Argumente für den Konstruktor haben eine IllegalArgumentException zur Folge § Wenn für den Konstruktor der Wert für die Minuten des ZeitSpanne Objekts ≥ 60 ist so wird der Wert in Stunden und Minuten umgewandelt 104 // Darstellung eines Zeit Intervals von Stunden und Minuten // public class ZeitSpanne { private int stunden; private int minuten; public ZeitSpanne(int stunden, int minuten){ if (stunden < 0 || minuten < 0) { throw new IllegalArgumentException(); } this.stunden = stunden + minuten/60; this.minuten = minuten % 60; } } 105 Objekt Invariante § Attribut minuten für ZeitSpanne Exemplare muss zwischen 0 und 59 (einschliesslich) liegen 106 // Darstellung eines Zeit Intervals von Stunden und Minuten // Invariante: stunden >= 0, 0 <= minuten <= 59 public class ZeitSpanne { private int stunden; private int minuten; public ZeitSpanne(int stunden, int minuten){ if (stunden < 0 || minuten < 0) { throw new IllegalArgumentException(); } this.stunden = stunden + minuten/60; this.minuten = minuten % 60; } } 107 Verhalten § Sinnvolle Operation mit ZeitSpanne: verlängern § Addition von Stunden und Minuten § Operation: add(int stunden, int minuten) § Inkorrekte Version public void add(int stunden, int minuten) { this.stunden += stunden; this.minuten += minuten; } 110 Verhalten § Diese Implementation der add Operation verletzt evtl. die Invariante § Ausserdem müssen wir illegale Argumente behandeln 111 public void add(int stunden, int minuten) { if (stunden < 0 || minuten < 0) { throw new IllegalArgumentException(); } this.stunden += stunden; this.minuten += minuten; // stellt Invariante wieder her this.stunden += this.minuten/60; this.minuten = this.minuten % 60; } 112 Redundanz § Wir müssen die Invariante an 2 Stellen sicherstellen § Im Konstruktor § In der add Methode § Was wenn wir später einmal die Darstellung ändern wollen? 113 Redundanz § Wir müssen die Invariante an 2 Stellen sicherstellen § Im Konstruktor § In der add Methode § Was wenn wir später einmal die Darstellung ändern wollen? § Besser wäre es, nur an einer Stelle mit der Invariante zu arbeiten 114 Redundanz § Der Konstruktor soll die add Methode verwenden § Nach Initialisierung § add Methode garantiert Invariante public ZeitSpanne(int stunden, int minuten){ this.stunden = 0; this.minuten = 0; add(stunden, minuten); } 115 Weitere Methoden § toString ist (fast) immer eine wichtige Methode // liefert String für diese Zeitspanne // z.B. \"3h 10m\" public String toString() { return \"\" + stunden + \"h \" + minuten + \"m\"; } 116 Abkapselung und Invarianten § Ohne Abkapselung ist es schwierig oder unmöglich, Invarianten sicherzustellen § Irgend ein Klient könnte die Invariante verletzten § Abkapselung gibt der Klasse die Kontrolle über die Operationen, die Klienten mit den Exemplaren machen können § Vorraussetzung für Evolution (der Klasse) 117 Eine andere Implementation § Interne Darstellung muss nicht der extern sichtbaren entsprechen § Brauchen wir stunden und minuten als Attribute? 118 Eine andere Implementation § Interne Darstellung muss nicht der extern sichtbaren entsprechen § Brauchen wir stunden und minuten als Attribute? § Die Aufteilung der Länge in Stunden und Minuten ist nicht zwingend public class ZeitSpanne { private int minutenInsgesamt; … } 119 Alternative Implementation § Änderung der Darstellung möglich solange Klienten nicht betroffen sind § Vereinfachung der add Methode public void add(int stunden, int minuten) { if (stunden < 0 || minuten < 0) { throw new IllegalArgumentException(); } minutenInsgesamt += 60*stunden + minuten; } 120 // Darstellung eines Zeit Intervals von Stunden und Minuten // Invariante: minutenInsgesamt >= 0 public class ZeitSpanne { … public ZeitSpanne(int stunden, int minuten){ minutenInsgesamt = 0; add(stunden, minuten); } public String toString() { return \"\" + (minutenInsgesamt / 60) + \"h \" + (minutenInsgesamt % 60) + \"m\"; } 121 252-0027 Einführung in die Programmierung 11.0 Systematisches Programmieren Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016--2022 All rights reserved. Übersicht § 11.1 Abstrakte Datentypen (ADT) in Java § 11.2 Objekt Invarianten § 11.3 Entwurf von Klassen § 11.4 Kompatible Anweisungen und Methodenaufruf § 11.5 Reale Probleme § 11.6 Beispiel(e) 2 11.3 Entwurf von Klassen § Verschiedene Heuristiken § Keine festen Regeln § Arthur J. Riel, Object-Oriented Design Heuristics © Addison-Wesley, 1996 (online via ETH Library) 3 § Daten sollten innerhalb einer Klasse geschützt sein (vor Zugriff oder Modifikation) (A.1) § Was muss wirklich von Klienten gesehen werden können? § Was wollen Klienten mit den Daten machen? Kann das nicht die Klasse machen? (z.B. eine add Methode für ZeitSpanne anbieten) 4 § Eine Klasse sollte eine Aufgabe übernehmen. § Eine Klasse soll eine (nur eine) Abstraktion erfassen (A.8) § Eine solche Klasse hat eine hohe Kohäsion § Frage: Hat die Klasse eine eindeutige Aufgabe/Zuständigkeit? 5 § Klassen sollten klein sein (A.3) § Wenige Methoden/Operationen § Leichter zu verstehen § Klienten(entwickler) verlieren nicht die Übersicht § Es gibt Ausnahmen … 6 § Vererbung setzt Klassen in eine Beziehung – diese sollte früh in der Entwicklung berücksichtigt werden § Vererbungshierarchien sollten tief sein – je tiefer desto besser (D.39) § Struktur des Daten/Objekt Raumes § Vererbungshierarchien sollten nur so tief sein dass ein Mensch sie im Kurzzeitgedächtnis speichern kann (D.40) § D.h. 5-7 Ebenen; oft wird 6 als maximaler Wert genannt 7 § Vererbung kann gut sein. Muss es aber nicht sein. § Vererbung erlaubt die Spezialisierung von Klassen (bzw. Objekten) (D.36) § Drückt eine «ist-ein» Beziehung aus § Vererbung ohne «ist-ein» Beziehung often problematisch 8 § Manchmal klingt Vererbung nach einer guten Idee, aber bringt später Probleme! § Beispiel: Erweiterung der Point-Klasse für 3. Dimension § Wollen die Höhe über NN hinzufügen § Wollen Software für Point Exemplare wiederverwenden Slides mit Material von Michael Faes 9 Point Klasse public class Point { private int x; private int y; // constructors // methods } § Dieser Code definiert einen Typ mit Namen Point. § Jedes Point Objekt enthält zwei Attribute: eine ganze Zahl (int) mit Namen x, und eine ganze Zahl (int) mit Namen y 10 equals Methode in Point // Returns whether obj refers to a Point object with // the same (x, y) coordinates as this Point. public boolean equals(Object obj) { if (obj instanceof Point) { // obj is a Point; cast and compare it Point other = (Point) obj; return x == other.x && y == other.y; } else { // obj is not a Point; cannot be equal return false; } } 11 § Manchmal klingt Vererbung nach einer guten Idee, aber macht später Probleme! § Beispiel: Erweiterung der Point-Klasse für 3. Dimension. 13 Point x: int y: int Point3D z: int public class Point3D extends Point { private int z; public Point3D(int x, int y, int z) { super(x, y); this.z = z; } public int getZ() { return z; } } § Implementation sieht nicht schlecht aus! Aber Achtung bei equals: § Point: § Point3D: 14 public boolean equals(Object obj) { if (obj instanceof Point) { Point other = (Point) obj; return x == other.x && y == other.y; } else { return false; } } public boolean equals(Object obj) { if (obj instanceof Point3D) { Point3D p = (Point3D) obj; return getX() == p.getX() && getY() == p.getY() && z == p.z; } else { return false; } } x und y sind private in Superklasse… § Verhalten von instanceof: § instanceof fragt, ob ein Objekt «ein Point ist»! § Verhalten der equals-Methoden: 15 new Point(4, 3) instanceof Point new Point(4, 3) instanceof Point3D new Point3D(4, 3, 2) instanceof Point true false true ! Point Point3D ist ein Point p = new Point(12, 7); Point p3d = new Point3D(12, 7, 11); …println(\"p.equals(p3d) = \" + p.equals(p3d)); …println(\"p3d.equals(p) = \" + p3d.equals(p)); p.equals(p3d) = true p3d.equals(p) = false equals sollte symmetrisch sein! § Aber Achtung bei equals: Point: Point3D 16 public boolean equals(Object obj) { if (obj instanceof Point) { Point other = (Point) obj; return x == other.x && y == other.y; } else { return false; } } public boolean equals(Object obj) { if (obj instanceof Point3D) { Point3D p = (Point3D) obj; return getX() == p.getX() && getY() == p.getY() && z == p.z; } else { return false; } } p.equals(p3d) p3d.equals(p) Liskov-sches Substitutionsprinzip § Schlechtes Design! § Code der mit Point-Objekten funktioniert sollte auch mit Objekten von Subklassen, inkl. Point3D, funktionieren. § Substituierbarkeit: Ein Objekt einer Subklasse kann überall erfolgreich verwendet werden, wo ein Objekt der Superklasse erwartet wird. 17 Barbara Liskov Liskov-sches Substitutionsprinzip § Ein Point3D ist kein Point. Also sollte keine Vererbung, d.h. keine «ist-ein» -Beziehung, verwendet werden! § Besser neu implementieren, trotz Code-Duplizierung… 18 Point Point3D 20 «hat-ein» – Beziehung § Statt Vererbung (ist-ein–Beziehung) gibt es auch andere Wege, «verwandte» Objekte zu verknüpfen. § Beispiel: Eine Circle-Klasse. Definiert durch Radius und Zentrum, d.h. x- und y-Koordinate. § Wir könnten von Point erben und radius-Attribut hinzufügen… § Nein. Ein Kreis ist kein Punkt. Auch wenn der Zustand eines Kreises zum Teil aus dem Zustand eines Punkts besteht. r (x, y) 21 «hat-ein»– Beziehung § Besser: Ein Attribut vom Typ Point hinzufügen. § «hat-ein»– Beziehung: Eine Verknüpfung zwischen zwei Objekten wobei eines ein Attribute hat, welches eine Referenz auf das andere enthält. Das enthaltene Objekt ist Teil des Zustands. § Klassen-Diagramm: § Code: § Objekt-Struktur: 22 Circle 11 Point hat ein Circle center radius 2.5 Point 4x y 3 public class Circle { private Point center; private double radius; public Circle(Point center, double radius) { this.center = new Point(center); this.radius = radius; } } Point-Objekt kopieren, damit… Point -6x y 12 Circle center radius 4.7 …jedes Circle-Objekt sein eigenes hat! Übersicht § 11.1 Abstrakte Datentypen (ADT) in Java § 11.2 Objekt Invarianten § 11.3 Entwurf von Klassen § 11.4 Kompatible Anweisungen und Methodenaufruf § 11.5 Reale Probleme § 11.6 Beispiel(e) 23 Kompatibilität der Referenztypen § (Vereinfacht) Kompatibel wenn im selben «Zweig» der Typ Hierarchie § Entweder bestimmt durch Vererbung (bei Klassen) oder § Bestimmt durch Erweiterung (bei Interfaces) § Beispiel: Typ A ist Object und Typ B ist Integer dann ist aref = bref wegen class Integer extends Object { … } erlaubt (Integer ist Subtyp von Object) § Zuweisung erlaubt wenn kompatibel 24 11.4 Kompatible Anweisungen und Methodenaufruf § (Immer noch) vereinfacht … spätere Vorlesungen vertiefen dieses Thema § Stichwort: Typ Systeme (sind neue Typen covariant, contravariant, invariant?) § Mein Tip: keine unnötige Komplexität in ihren Programmen § Aber Sie wollen verstehen welche Methodenversion aufgerufen wird § Und dazu müssen Sie alle Regeln für Zuweisung(en) verstehen 2526 Überblick § Zuerst nochmal Zuweisungen mit Referenzvariablen § Erst mal ohne Java interface Konstrukt § Bezug zu Methodenaufruf mit Parametern § Finden der «am besten passenden» Version einer Methode § Wenn es mehrere Methoden zur Auswahl gibt § Overloading (mit Überraschungen) § Methodenaufruf Beispiel § (extra) Interfaces und Klassen 27 Überblick § Zuerst nochmal Zuweisungen mit Referenzvariablen § Erst mal ohne Java interface Konstrukt § Bezug zu Methodenaufruf mit Parametern § Finden der «am besten passenden» Version einer Methode § Wenn es mehrere Methoden zur Auswahl gibt § Overloading (mit Überraschungen) § Methodenaufruf Beispiel 28 Warum? § Compiler und Laufzeitsystem arbeiten zusammen § Bei Auswahl der «am besten passenden» Methode § Bei Aufruf der Methode § Compiler: arbeitet vor der Ausführung des Programms § Kennt deklarierten Typ von Variablen § Kennt nicht den aktuellen Typ (des Objekts auf das die Variable verweist) § Kennt nicht den Pfad zur Zuweisung/zum Aufruf 29 Warum? § Compiler und Laufzeitsystem arbeiten zusammen § Bei Auswahl der «am besten passenden» Methode § Bei Aufruf der Methode § Laufzeitsystem: kontrolliert während der Ausführung § Kennt den aktuellen Typ (des Objekts auf das die Variable verweist) § Kennt alle aktuellen Werte § Approximiert deklarierten Typ von Variablen (für generische Typen) 30 Vererbungshierarchie § Die Vererbunghierarchie bestimmt, welche Zuweisungen kompatibel sind § Mit expliziter oder impliziter Konvertierung § Implizite Konvertierung § superReferenz = subklasseReferenz § Immer erlaubt – Compiler prüft ob legal § Explizite Konvertierung 31 Snow Rain Fog Sleet § subklasseReferenz = (Subklasse) superReferenz § Nur mit Cast § Laufzeitcheck dass superReferenz auf Subklasse Exemplar verweist Kompatible Zuweisungen Snow a; Sleet b; Fog c; Rain r; 32 Snow Rain Fog Sleet a = b; // compatible, implizit conversion a = new Fog(); // compatible, implizit conversion c = (Fog) a; // compatible, explizit conversion // check at runtime Kompatible Zuweisungen Snow a; Sleet b; Fog c; Rain r; 33 Snow Rain Fog Sleet b = new Sleet(); c = (Fog) b; // compatible but exception during execution Kompatible Zuweisungen Snow a; Sleet b; Fog c; Rain r; 34 Snow Rain Fog Sleet a = b; // compatible, implizit conversion b = r; // incompatible, cannot be converted b = (Sleet) r; // incompatible, cannot be converted r = (Rain) b; // incompatible, cannot be converted (In)kompatible Zuweisungen Drei mögliche Fehler 1. Zuweisung von Typ der nicht Subtyp ist – vom Compiler entdeckt: incompatible types 2. Cast zu Typ der nicht Sub- oder Supertyp ist – vom Compiler entdeckt: inconvertible types 3. Cast und der aktuelle Typ ist nicht (Sub)Typ – zur Laufzeit entdeckt: cast exception 35 Snow Rain Fog Sleet // see last slide for context b = r; // 1, Rain not subtype of Sleet b = (Sleet) r; // 2, Sleet not subtype of Rain b = new Sleet(); c = (Fog) a; // 3, a refers to Sleet –not Fog- object Methoden Bindung § Zwei Schritte 1. Compiler findet Methode(n) die in Frage kommt/en § Gesucht wird aufgrund des Typs der Referenzvariable und Name § Gefunden wird «die am besten passende» Methode M (foo in Klasse oder Interface Base) § Entschieden wird auf Grund der Parameter 2. Zur Laufzeit wird die Version von M (foo) für den aktuellen Typ aufgerufen § Annahme: Methode(n) sichtbar 36 Base bref; bref.foo( ... ); 1. Compiler findet Methode(n) die in Frage kommt/en § Einfacher Fall: es gibt nur eine Methode und die Parameter passen § Parameter passen: Zuweisung des aktuellen Parameters zum formalen Parameter erlaubt class A { void foo(int i) { System.out.println(\"foo\"); } } A aref = new A() aref.foo(3); // foo 37 1. Compiler findet Methode(n) die in Frage kommt/en § Einfacher Fall: es gibt nur eine Methode und die Parameter passen § Parameter passen: Zuweisung des aktuellen Parameters zum formalen Parameter erlaubt class B { void foo(Integer i) { System.out.println(\"foo\"); } } B bref = new B(); bref.foo(Integer.valueOf(3)); // foo 38 1. Compiler findet Methode(n) die in Frage kommt/en § Einfacher Fall: es gibt nur eine Methode und die Parameter passen nicht § Fall A: Implizite Konvertierung ist möglich und Parameter passt dann class C { void foo(Object o) { System.out.println(\"foo\"); } } C cref = new C(); cref.foo(Integer.valueOf(3)); // foo 39 1. Compiler findet Methode(n) die in Frage kommt/en § Einfacher Fall: es gibt nur eine Methode und die Parameter passen nicht § Fall B: (Un)Boxing ist möglich und Parameter passt dann (evtl. mit impliziter Konvertierung) class A { void foo(int i) { System.out.println(\"foo\"); } } A aref = new A() aref.foo(Integer.valueOf(8)); // foo 40 1. Compiler findet Methode(n) die in Frage kommt/en § Einfacher Fall: es gibt nur eine Methode und die Parameter passen nicht § Fall C: Weder Cast noch Boxing ist möglich: Fehler (Error) vor Ausführung A aref = new A() aref.foo(\"hello\"); | Error: | incompatible types: java.lang.String cannot be converted to int | aref.foo(\"hello\"); | ^-----^ 41 1. Compiler findet Methode(n) die in Frage kommt/en § Einfacher Fall: es gibt nur eine Methode und die Parameter passen nicht § Fall C: Weder Cast noch Boxing ist möglich: Fehler (Error) vor Ausführung B bref = new B(); bref.foo(true); | Error: | incompatible types: boolean cannot be converted to java.lang.Integer | bref.foo(true); | ^--^ 42 Was passiert hier? § Fall A, B, oder C ? class C { void foo(Object o) { System.out.println(\"foo\"); } } C cref = new C(); cref.foo(true); // foo – Fall B: Boxing! Impliziter Cast // boolean -> Boolean -> Object 43 Compiler – Reihenfolge der Schritte § Annahme: Methode M mit richtigem Namen und richtiger Anzahl/Reihenfolge Parameter § Es gibt eine Methode die in Frage kommt § Passt Parameter direkt? § Passt passt Parameter nach Cast (Fall A)? § Passt Parameter nach (Un)Boxing (und ggf. Cast)? (Fall B)? § Geht nicht (Fall C) 44 1. Compiler findet Methode(n) die in Frage kommt/en § Etwas komplizierter: Es gibt mehr als eine Methode für die der/die Parameter direkt passt/en § Overloading § Nicht erlaubt. class X { void foo(int j) { .. } void foo(int k) { .. } } | Error: | method foo(int) is already defined in class X | abstract void foo(int k); | ^-----------------------^ 45 1. Compiler findet Methode(n) die in Frage kommt/en § Etwas komplizierter: Es gibt mehr als eine Methode für die der/die Parameter direkt passt/en § Overloading § Nicht erlaubt. Eine solche Klasse wird garnicht übersetzt! class X { void foo(int j) { .. } void foo(int k) { .. } } | Error: | method foo(int) is already defined in class X | void foo(int k); | --------------^ 46 Methodendefinition § Die Definition einer Methode besteht aus § Name der Methode § Typ (und Reihenfolge) der Parameter § Typ des Rückgabewertes (bzw. void) § Ggf. throws Liste der möglichen Exceptions § Modifizierer § public, private, protected, static und weitere § Keine zwei Methoden dürfen selben Namen und Parameterliste haben 47 «signature» public static void foo(int x, Object o) throws IOException Gilt auch für Methodendeklaration in Interface oder abstrakter Klasse 1. Compiler findet Methoden die in Frage kommen § Komplizierter: Es gibt mehr als eine Methode für die der/die Parameter nach Boxing und/oder Casts passt/en § Keine Methode passt direkt § Overloading mit unterschiedlichen Signaturen § Eine solche Klasse wird übersetzt! class X { void foo(int i, double d) { System.out.println(\"Option 1\"); } void foo(double d, int i) { System.out.println(\"Option 2\"); } } 48 § Komplizierter: Es gibt mehr als eine Methode für die der/die Parameter nach Boxing und/oder Casts passt/en § Eine solche Klasse wird übersetzt! § Aufruf nur gestattet wenn Methode eindeutig bestimmt X xref = new X(); xref.foo(1, 1.0); // Option 1 xref.foo(0.0, 1); // Option 2 xref.foo(1, Double.valueOf(0.0)); // Option 1 xref.foo(0, 1); | Error: | reference to foo is ambiguous | both method foo(int,double) in X and [..] foo(double,int) in X match | xref.foo(0, 1); | ^------^ 49 Compiler findet Error in Methode die Aufruf von foo() enthält § Der Typ der Referenzvariable entscheidet welche Methode aufgerufen werden soll § Overriding überschreibt in einer Erweiterung eine Methode der Superklasse wenn die Signatur identisch ist. 50 2.) Aufruf (zur Laufzeit) der Version für aktuellen Typ § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. 51 Base foo(int) foo(Object)Base bref = new Base(); bref.foo(7); 2.) Aufruf (zur Laufzeit) der Version für aktuellen Typ § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Diese Methode wird zur Laufzeit aufgerufen 52 Base foo(int) foo(Object)Base bref = new Base(); bref.foo(7); 2.) Aufruf (zur Laufzeit) der Version für aktuellen Typ § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. 53 Base foo(int) foo(Object)Base bref = new Base(); bref.foo(Integer.valueOf(7)); 2.) Aufruf (zur Laufzeit) der Version für aktuellen Typ § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Diese Methode wird zur Laufzeit aufgerufen 54 Base foo(int) foo(Object)Base bref = new Base(); bref.foo(Integer.valueOf(7)); 2.) Aufruf (zur Laufzeit) der Version für aktuellen Typ § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen 55 Base foo(int) foo(Object) Base bref = new ExtB(); bref.foo(7); ExtB foo(int) foo(Object) 2.) Aufruf (zur Laufzeit) der Version für aktuellen Typ § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen 56 Base foo(int) foo(Object) Base bref = new ExtB(); bref.foo(7); ExtB foo(int) foo(Object) Warum spielt die Reihenfolge der Schritte eine Rolle? § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen § Aber 1. Schritt wird abhängig von Typ der Referenzvariable gemacht 57 Base foo(double) foo(Object) ExtB foo(int) foo(Object) Warum spielt die Reihenfolge der Schritte eine Rolle? § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen § Aber 1. Schritt wird abhängig von Typ der Referenzvariable gemacht 58 Base foo(double) foo(Object) Base bref = new Base(); bref.foo(7); ExtB foo(int) foo(Object) Warum spielt die Reihenfolge der Schritte eine Rolle? § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen § Aber 1. Schritt wird abhängig von Typ der Referenzvariable gemacht 59 Base foo(double) foo(Object) Base bref = new Base(); bref.foo(7); ExtB foo(int) foo(Object) Warum spielt die Reihenfolge der Schritte eine Rolle? § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen § Aber 1. Schritt abhängig von Typ der Referenzvariable gemacht § Erweiterung unwichtig ... 60 Base foo(double) foo(Object) Base bref = new Base(); bref.foo(7); Warum spielt die Reihenfolge der Schritte eine Rolle? § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen § Aber 1. Schritt abhängig von Typ der Referenzvariable gemacht 61 Base foo(double) foo(Object) Base bref = new Base(); bref.foo(7); ExtB foo(int) foo(Object) Warum spielt die Reihenfolge der Schritte eine Rolle? § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen § Aber 1. Schritt abhängig von Typ der Referenzvariable gemacht 62 Base foo(double) foo(Object) Base bref = new ExtB(); bref.foo(7); ExtB foo(int) foo(Object) Warum spielt die Reihenfolge der Schritte eine Rolle? § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen § Aber 1. Schritt abhängig von Typ der Referenzvariable gemacht § Welche Version? 63 Base foo(double) foo(Object) Base bref = new ExtB(); bref.foo(7); ExtB foo(int) foo(Object) oder Warum spielt die Reihenfolge der Schritte eine Rolle? § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen § Aber 1. Schritt abhängig von Typ der Referenzvariable gemacht § Welche Version? 64 Base foo(double) foo(Object) Base bref = new ExtB(); bref.foo(7); ExtB foo(int) foo(Object) Poll oder Warum spielt die Reihenfolge der Schritte eine Rolle? § Der 1. Schritt bestimmte, welche Methode aufgerufen werden soll. § Wenn eine Erweiterung eine Methode überschreibt, dann wird die Version des aktuellen Typs aufgerufen § Aber 1. Schritt abhängig von Typ der Referenzvariable gemacht § Welche Version? 65 Base foo(double) foo(Object) Base bref = new ExtB(); bref.foo(7); ExtB foo(int) foo(Object) Poll 66 Methoden Overloading und Overriding § Können genaues hinsehen verlangen § Wir wollen Sie nicht hereinlegen aber Sie müssen Unterschied von Overloading und Overriding kennen § Sie müssen verstehen, welche Methode in einem Programm ohne Overloading aufgerufen wird 67 Overloading § Overloading in Kombination mit Casts und Wrapping erfordert genaues hinsehen § Overloading hat aber auch hilfreiche Aspekte 68 Overloading § Vereinfacht das Lesen und die Klienten § Könnte neue Namen einführen void foo (int j, double d) { … } void foo (double d, int j) { … } § wäre dann void foo_1 (int j, double d) { … } void foo_2 (double d, int j) { … } 69 Overloading § Overloading kann eingesetzt werden § Für Methoden die in der selben Klasse definiert sind § Für Methoden die in unterschiedlichen Klassen einer Inheritance Hierarchie definiert sind § Für Methoden die in Interfaces oder abstrakten Klassen definiert sind § Auch für Konstruktoren … § «Überladene» Methoden können (wie alle Methoden) überschrieben werden 70 Overriding und Overloading § Um eine Methode aus der Superklasse T in der Subklasse S zu überschreiben müssen die Parameterlisten in T und S identisch sein. § Sonst handelt es sich um Overloading § Gefahr bei Overloading: implizite Konvertierungen § Einziger erlaubter Unterschied: der Rückgabewert TR in T muss mit Rückgabewert SR in S kompatibel sein § D.h. Zuweisung variableTR = variableSR ist erlaubt 71 Overloading und Overriding § Machen Sie sich das Leben nicht unnötig schwer § Verlassen Sie sich nicht auf implizite Konvertierungen § Stellen Sie sicher dass eine Methode eine andere überschreibt wenn Sie das wollen class C extends B { @Override String foo(Y yref) { return \"foo 1 C\"; } } 72 method does not override or implement a method from a supertype @Override ^ Overloading soll dem Klienten helfen § Gutes Beispiel: System.out.print( Argument ) § Methode print ist «overloaded» – 9-fach § Methode println sogar 10-fach 7374757677 Zurück zu unserem Beispiel 78 Zurück zu unserem Beispiel ArrayList<Integer> al = new ArrayList<Integer>(Arrays.asList(1, 2, 3)); al ==> [1, 2, 3] al.remove(Integer.valueOf(1)) al ==> [2, 3] ArrayList<Integer> al = new ArrayList<Integer>(Arrays.asList(1, 2, 3)); al ==> [1, 2, 3] al.remove(1) al ==> [1, 3] ArrayList<Integer> al = new ArrayList<Integer>(Arrays.asList(1, 2, 3)); al ==> [1, 2, 3] long q = 1; al.remove(q); al ==> [1, 2, 3] 79 Zurück zu unserem Beispiel, Teil 2 ArrayList<Integer> al = new ArrayList<Integer>(Arrays.asList(1, 2, 3)); al ==> [1, 2, 3] short s = 1; al.remove(s); al ==> [1, 3] ArrayList<String> al = new ArrayList<String>(Arrays.asList(\"a\",\"b\", \"c\")); al ==> [a, b, c] al.remove(1) al ==> [a, c] 80 Zurück zu unserem Beispiel, Teil 3 ArrayList<String> al = new ArrayList<String>(Arrays.asList(\"a\",\"b\", \"c\")); al ==> [a, b, c] al.remove(Integer.valueOf(0)) al ==> [a, b, c] al.remove(0+Integer.valueOf(0)) al ==> [b, c] 81 252-0027 Einführung in die Programmierung Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016,2018 All rights reserved. 1 252-0027 Einführung in die Programmierung 11.0 Systematisches Programmieren Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016--2021 All rights reserved. 252-0027 Einführung in die Programmierung 12.0 Finale Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016--2021 All rights reserved. Informationen zur Prüfung § Alle Angaben ohne Gewähr. Änderungen möglich. 4 Prüfung § Was ich weiss: § Am 3. 2. 2023, 14:00 – 16:40 § Wo? In Zürich, verschiedene Orte § Programmierprüfung (am Computer) und (schriftliche) Grundlagen § Schriftlich (1/3 Punkte, 40 Min) § Programmierprüfung (2/3 Punkte, 80 Min + 40 Min «extra») § Keine Pause zwischen den Blöcken 5 Alle Angaben ohne Gewähr. Änderungen möglich. Ein Problem. § HS 2020/21 § Studierende: 592 § Anmeldungen: 551 (Stand Dez. 2020): § Anmeldungen: 475 (Stand 1 Woche vor Prüfung) § Prüfungen: 452 6 § Plätze: 513 in 12 Räumen Ein Problem -- Eine Verbesserung § HS 2020/21 § Studierende: 592 § Anmeldungen: 551 (Stand Dez. 2020): § Anmeldungen: 475 (Stand 1 Woche vor Prüfung) § Prüfungen: 452 10 § Plätze: 513 § HS 2022/23 § Studierende: 602 § Anmeldungen: 572 (Stand Dez. 2022): § Anmeldungen: 510 (Vermutung 1 Woche vor Prüfung) § Prüfungen: 480 § Plätze: 531 in 4 Räumen Wo?? § HG und ONA § ONA § Neunbrunnenstrasse 50, 8050 Zürich § Während des Semesters für Vorlesungen genutzt § Daher leider keine Probeprüfung § HG 16 Jan 2020 17 Photo: T. Moser, LET, ETH ONA E7 Jan 2020 18 HG G1 (Bild: Th. Gross Aug 2020 Jan 2021 Aug 2021 19(Bild: ETH/Stefan Geissler ID SDL) ONA E7 Feb 2023 § Vermutlich meiste Räume wie im Jan 2020, ein Raum wie in Aug 2020/Aug2021 20 ONA Gebäude -- Hinweis § 373 Plätze, ein Eingang § Schlange(n) möglich § Kein Vordach, keine Lobby, keine Halle … § Nehmen Sie einen Regenschirm mit wenn das Wetter unfreundlich ist § Die Prüfungssession geht weiter … 21 Prüfungsumgebung § Eclipse (wie in Studentenarbeitsräumen, HG ) § Liste (nur Englisch verfügbar) § Projekte im workspace § Linux (aber brauchen Sie nicht wirklich) § Java 17 Dokumentation in Eclipse [Englisch!] § Kein git – Projektdateien lokal speichern genügt § Üben Sie mit Eclipse § Viele gute Features § Aber wichtiger ist dass Sie Ihre Programme durchdenken 23 Weitere Informationen § Standard: deutsch-schweizerische Tastatur § (wie in Studentenarbeitsräumen, HG ) § Üben Sie … wenn Sie \"{\" in der Prüfung suchen müssen vergeht Zeit! § (Hoffentlich) US Tastaturen verfügbar § eMail Mitte Januar 2023 § Nicht garantiert und auch nicht wirklich entscheidend § Keine Mobiltelefone, Tablets, Smartwatches etc in den Prüfungsräumen (zuhause oder in Rucksack lassen) § Vielleicht andere Regelung wenn früher Einlass in Räume 24 Weitere Informationen § Prüfung auf Deutsch § Antworten auf Englisch akzeptiert § LibreTranslate (Open Source Machine Translation) während der Programmierprüfung § Nicht während der (schriftlichen) Grundlagenprüfung § Wörterbuch erlaubt (gilt für alle ETH Prüfungen) 25 Weitere Informationen § Raumeinteilung kurz (1-2 Tage) vor der Prüfung per eMail § Evtl. auch schon früher (Tradeoff – Abmeldungen kommen vor) § Zufällige Einteilung § Stellen Sie sicher dass eMail Sie erreicht 26 Weitere Informationen § Weitere Informationen später § Genauer Ablauf § Regeln – bitte Lesen! § Die Disziplinarordnung kennt drakonische Strafen § Gehen Sie zum richtigen Raum zur richtigen Zeit § Web Seite beobachten § Side-Channel: In «Ankündigungen …» sehen Sie wenn wichtige eMail verschickt wurde 27 Prüfungsablauf (Änderungen möglich) § Türöffnung um … (mindestens 30 Min vor Prüfungsbeginn) § Sie müssen nicht vorher erscheinen § Wer sich bis zum Prüfungsbeginn einreiht hat die volle Zeit! § Sie dürfen nach Eintritt den Prüfungsraum nicht verlassen § Ausnahme: Besuch von WC § Nie mehr als ein Student/in zur selben Zeit (Kontrolle durch Aufsicht)28 Prüfungsablauf (Änderungen möglich) § Eingangskontrolle (mit Legi) § Platz nehmen § Ca. 10 Min vor Start machen wir eine Durchsage § Letzter Zeitpunkt Internet-fähige Geräte zu versorgen § Letzte Chance Toilettenbesuch ohne Aufsicht § Schriftliche Prüfung § Legen Sie die Legi auf Ihren Arbeitsplatz (evt. Kontrolle gefordert von ETH) § Ende schriftliche Prüfung § Legen Sie die Legi auf die Prüfung – wir sammeln die Prüfung ein § Kein Weiterarbeiten an der schriftlichen Prüfung 29 § Beginn Programmierprüfung § Nach Anweisungen: § Anmelden am Computer § Hilfreich: nethz Konto Name (aber nicht zwingend …) § Eclipse starten § Ende nach 2 Std oder wenn Sie fertig sind § Computer sperren § ggf. Raum verlassen § Keine Internet-fähigen Geräte zugelassen § Keine Smartwatches etc. § Nehmen Sie eine (einfache) Uhr mit § Evtl. ist eine Uhr im Raum nicht einfach sichtbar … 30 Wenn der Prüfungscomputer spinnt … § Melden Sie sich bei der Aufsicht § Wenn es mit dem System ein Hardware/Software Problem gibt erhalten Sie einen neuen Arbeitsplatz § und eine Zeitgutschrift § Aber: wenn Sie 100 JVMs laufen lassen (und Ihr System langsam läuft) dann ist das Ihr Problem § Auch das Finden einer Endlos-Schleife ist Ihr Problem 32 Prüfungsablauf § Nach der Prüfung dürfen Sie den Prüfungsraum bis 20 Minuten vor Ende verlassen. § Wollen ruhige Atmosphäre bis zum Ende § Bitte Raum leise verlassen – evtl. haben andere Studierende eine Zeitgutschrift § Wir sammeln die Aufgabenstellungen (und die schriftliche Prüfung) ein § Nehmen Sie Lesestoff mit … § Kein Handy etc nach Start der Prüfung bis nach Verlassen des Raums 33 Ein (un)wichtiger Aspekt § Wenn Sie «geringfügig» verspätet sind dürfen Sie evtl. die Prüfung noch ablegen § Kein Anrecht aber auch in der Schweiz kann es Verspätungen geben § Extra Zeit am Ende § Geringfügig: < 30 Minuten § Hängt ab von Raumbelegung, IT (LET) Personal § Informieren Sie bei Verspätungen (oder Erkrankungen) schnellstens die Prüfungsplanstelle!! (+41 44 632 20 68) § Nicht den Dozenten 36 Prüfung § Umfang: § Inhalt der Vorlesung § Probeprüfungen im Archiv des VIS § Mitbringen: § Legi § Stift (wir stellen Papier) § ggf Wörterbuch (E-D, F-D, F-E, I-E, I-D, ….) § Ohne Java Notizen! 37 Prüfungsstoff § Inhalt der Vorlesung § Inklusive EBNF, weakest preconditions, Schleifen Invarianten und den behandelten Java Konzepten § Verständnis, nicht Details § Zeigen Sie, dass Sie programmieren können § Evaluation der Programmierprüfung primär durch Test Suite § Ihr Programm muss übersetzt werden können! § Kommentare wie Sie das Problem lösen könnten helfen nicht (viel) § Die abgegebene Lösung zählt § Graphische Benutzeroberfläche nicht Prüfungsstoff 38 Prüfungsstoff § Regeln wie für die Bonusaufgaben § Sie bekommen genaue Anweisungen § Zwei Mal: § Ein paar Tage vor der Prüfung (zu Hause lesen, nicht mitbringen) § Mit der Prüfung § Sie dürfen alle Klassen/Bibliotheken nach Wunsch importieren es sei denn es ist explizit verboten § Importieren Sie aber nur was Sie brauchen § Wenn Import verboten dann ist auch Import mit vollständigem Namen verboten (java.util.Scanner) 39 Prüfungsstoff § Sie dürfen Klassen verändern/hinzufügen es sei denn es ist explizit verboten § Ändern Sie nicht die Signaturen von vorgegebenen Methoden oder Konstruktoren! § Vorsicht mit static Variablen (mein Ratschlag: nur wenn nötig) § Wandeln Sie nicht Interfaces in Klassen um oder umgekehrt 40 Bewertung § Programmieraufgaben müssen Testsuite behandeln können § Wir geben einige Tests vor, andere sollten Sie selbst schreiben § Das Programm muss übersetzt und ausgeführt werden können. § Wie bei den Bonusaufgaben 41 Bewertung § Programmieraufgaben müssen Testsuite behandeln können § Es gibt weitere Tests für die Bewertung § Ähnlich wie bei Bonusaufgaben (je mehr Tests korrekt behandelt werden desto besser) § Korrektheit – nicht Laufzeit (innerhalb vernüftiger Grenzen) § Stellen Sie sicher dass Ihr Programm terminiert § Wir stellen «grosse» Testsets zur Verfügung § Lösung muss auch für grosses Testset funktionieren § In 10 sec sollte jeder Test (bequem) ausgeführt werden können 45 Vorbereitung § Sie können Fragen an eprog-hilfe@inf.ethz.ch schicken § Oder auch an mich direkt § Nicht an die Assistent*innen (die haben auch Prüfungen) § Für interessante Fragen werden wir die Antwort auf der Web Seite publizieren § Fragen nach dem 26. Januar werden (evtl) nicht beantwortet § Keine Verwirrung in den letzten N Stunden 46 Vorbereitung § Study Center für Hilfe im Januar § Woche vom 16. Jan. § Woche vom 23. Jan. § .... aber nicht später § Fangen Sie rechtzeitig an § Programmieren erfordert Übung 47 Details folgen per eMail. Evtl. mit vorheriger Anmeldung. Bezüglich der Prüfung habe ich ein paar Fragen: Kann man an den alten Prüfungen üben --- JA bzw. verändert sich z.B. im Theorieteil der Aufgabentyp für EBNF? --- Möglich (siehe unten) Konkret: Müssen wir schwerpunktmässig verifizieren ob eine Zeichenfolge mittels EBNF Regeln legal ist, oder müssen wir schwerpunktmässig EBNF Regeln erstellen? --- beides ist möglich Sollte man die Aufgaben in den Serien erneut lösen oder eher in die Breite gehen und andere Aufgabentypen aus vorherigen Jahren üben? -- lernen Sie mit den Konzepten zu arbeiten -- eine neue Aufgabe ist vielleicht sinnvoller als eine alte (schon einmal gelöste) 48 Bemerkungen eines Studierenden Häufig habe ich lange an den Aufgaben gesessen und manchmal viel Zeit im Debugging verbracht. Wie \"schnell\" sollte man Praxisaufgaben lösen können? Gehen Sie inkrementell vor. Was ist verlangt? Was sagen die Tests? Was habe ich vielleicht übersehen? Eine lange Beschreibung hilft Ihnen. Sie sollten nicht raten müssen. 49 Bemerkungen einer Assistierenden § Programmieren erfordert Übung § Üben Sie § Bonusprüfungen und alte Prüfungen im VIS Archiv § VIS hilfsbereit – melden Sie fehlende Dateien etc. § Lesen Sie die Aufgabenstellung erst wenn Sie die Aufgaben lösen wollen § Lösen Sie die letzten Probeprüfungen mit Zeitfenster 50 ETH Prüfungen sind nicht einfach § Anders als Gymi § Melden Sie sich ab wenn Sie nicht vorbereitet sind § Setzen Sie sich in der Prüfung nicht unter Druck. Aufgaben haben (fast immer) Teilaufgaben – auch eine partielle Lösung zählt 51 Bewertung: Punkte à Note § Viele Optionen (für den Dozenten) § 0 % Pkt –> 1.0, 100 % Pkt –> 6.0 § 0 % Pkt –> 1.0, 90 % Pkt –> 6.0 § 0 % Pkt –> 1.0, 40 % Pkt –> 4.0, 90 % Pkt –> 6.0 § Wir versuchen fair zu sein § Sollte eine Aufgabe zu schwierig sein dann passen wir die Benotung an 52 Vorlesung § Experiment mit Fokus Gruppen § Was ist Ihre Erfahrung? § Sollten wir so etwas auch im nächsten Jahr machen? § Lassen Sie es uns wissen § Wie war es in den «gemischten Gruppen»? § Der VSETH macht dazu eine Umfrage § https://evaluation-app1.let.ethz.ch/eval# § (Fragen an den VSETH) 53 Vorlesung 2023 § Werbung § Wir suchen (wieder) [Hilfs]Assistierende § Bei Interesse schicken Sie mir Mail (Ende Feb'23, nach Prüfungssession) § Voraussetzungen § Interesse am Unterrichten/Helfen/Erklären § Spass am Programmieren § Keine feste Grenze für Note § Aber Sie sollten das Material beherrschen § Beide Teile der Basisprüfung müssen bestanden sein 5456 252-0027 Einführung in die Programmierung 11.0 Systematisches Programmieren Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016--2022 All rights reserved. Übersicht § 11.1 Abstrakte Datentypen (ADT) in Java § 11.2 Objekt Invarianten § 11.3 Entwurf von Klassen § 11.3.1 Beispiel – Feststellen von Eigenschaften § 11.3.2 Beispiel – Klassenentwurf § 11.3.3 Beispiel – Ähnliches Verhalten § 11.4 Kompatible Anweisungen und Methodenaufruf § 11.5 Reale Probleme 59 11.3.* Bemerkungen zu Programmieraufgaben § Lesen Sie die Aufgabenstellung aufmerksam durch § Was soll Ihr Programm machen? § Skizieren Sie Beispiel Tests/Sehen Sie sich die angegebenen Tests an § Wenn Sie Aufgabenstellung verstehen, skizzieren Sie eine Lösung § Werden die Unit Tests behandelt? Vielleicht mehr Tests skizzieren § Danach können Sie Java Code schreiben 60 11.3.1 Beispiel – Feststellen von Eigenschaften 6162636465 11.3.2 Beispiel – Klassenentwurf 66 Heuristik für Entwurf 1. Klassen identifizieren 2. Beziehung zwischen Klassen erarbeiten 3. Attribute 4. Methoden Iterativ: mehrere Male durchspielen Entwurf verfeinern 676870 Beispiel 71 Vereinfachungen 7273 Was für Fragen hätte ein/e Entwickler/in? 74 Fragen? Annahmen § Alle Fahrstühle sind unabhängig von einander § Fahrstühle bewegen sich nur nach oben oder unten, d.h. die Kabinen bewegen sich nur vertikal, nicht horizontal § Zeit zum Öffnen/Schliessen der Türen kann vernachlässigt werden § Wenn Fahrstuhlkabinen sich nicht bewegen dann steht der Fahrstuhl auf einer Etage 7677 From Wikimedia Commons under the creative commons cc-by-sa 3.0 license. From YouTube video by ThyssenKrupp (accessed 12/20/19) 1.) Klassen finden § Heuristik: Nomen im Text finden 7879 Beispiel 8081 Beispiel 82 Klassen finden § Heuristik: Nomen im Text finden und ordnen Fahrstuhl, Lift Stockwerk, Etage, Einstiegsetage, Zieletage Simulator Gebäude Reisewunsch. Liftbewegung, Ruf Position, Richtung 85 Knöpfe, Ruf Passagiere § Nicht jedes Nomen ist relevant § Knöpfe § Manche Nomen können wir nicht einordnen § Überblick, Zustand, Einsatz § Abgrenzung zwischen Nomen nicht immer klar § Ruf, Reisewunsch, Position § Position, Zieletage, Richtung 86 Erste Klassen Liste § Gebäude § besteht aus Etagen [Stockwerken] (Anzahl ist Parameter) und Fahrstühlen (Anzahl ist Parameter) § Passagier § generiert Reisewünsche (auf einer Ausgangsetage, zu einer Zieletage) § Fahrstuhl § bewegt sich nach oben bzw unten oder steht still § hat Position und Ziel 87 Fortsetzung § Simulator § für Gebäude mit N Stockwerken und M Fahrstühlen § 1-Sekunde Granularität § führt Buch § Logbuch § hält Ereignisse fest 88 2.) Beziehung zwischen Klassen erarbeiten § Passagiere rufen Fahrstuhl § Fahrstuhl reist zur Ausgangsetage, öffnet sich, fährt zur Zieletage § Logbuch hält Ereignisse fest 91 verwendet 92 GebaeudeSimulator FahrstuhlStockwerk 1..* 1 11 1..* 1+ main(args) Beziehung zwischen Klassen erarbeiten § Passagiere rufen Fahrstuhl § Fahrstuhl reist zur Ausgangsetage, öffnet sich, fährt zur Zieletage § Logbuch hält Ereignisse fest § Etwas fehlt: wer entscheidet (wählt Fahrstuhl aus, findet nächste Ausgangsetage)? § Kontroller als Abstraktion der Fahrstuhlkontrolle 93 verwendet § Rest der Beschreibung fügt noch mehr Elemente hinzu… 94 Gebaeude- KontrollerSimulator FahrstuhlStockwerk 1..* 1 11 1..* 1+ main(args)§ Brauchen wir Passagiere? 95 3.) Attribute § Stockwerk: § Passagiere warten auf Reise nach oben § Passagiere warten auf Reise nach unten § Fahrstuhl § Position § Zieletage § Zustand: fahrend, wartend 96 4.) Methoden § Simulator § einSchritt § verarbeiteWuensche § Stockwerk § resetWunsch(Richtung) § Fahrstuhl § setZiel § getPosition, getRichtung § moveCabin 97 11.3.3 Beispiel – Ähnliches Verhalten 99100 11.5 Reale Probleme § Mögliche Ursachen § Endliche Darstellung von (im Prinzip) ungegrenzten Werten § z.B. 32-bit int repräsentiert ganze Zahl § Illusionen der Programmiersprache § z.B. == Operator für double (Repräsentation von reellen Zahlen) obwohl Berechnungen ungenau sind § Optimierungen der Java Software Platform die zu unterschiedlichem Verhalten (z.B. abhängig von Konfiguration) führen § Siehe nächste Slides 101 11.5.1 Java und die JVM § Vorsicht bei equals, ==, und Boxing § Java Virtuelle Machine (JVM) führt Java Programm aus – und versucht Optimierungen § Viele Optimierungen sind nicht (im Programm) sichtbar § Aber manche schon … 102 Für Referenztypen benutzen wir equals § Sie erinnern sich 103 Die equals Methode § String Objekte werden mit einer Methode mit Namen equals verglichen. Scanner console = new Scanner(System.in); System.out.print(\"Wie heissen Sie? \"); String name = console.next(); if (name.equals(”Hase\")) { System.out.println(\"Wissen Sie mehr? \"); ... } Vergleiche von String Objekten § Vergleichsoperatoren wie < und == funktionieren nicht wie vielleicht erwartet für Objekte. Scanner console = new Scanner(System.in); System.out.print(”Wie heissen Sie? \"); String name = console.next(); if (name == ”Hase\") { System.out.println(”Wissen Sie mehr? \"); } else { System.out.println(\"Gehen Sie!\"); } § Dieses Programm wird übersetzt aber der Test ergibt nie true. Wie heissen Sie? Gehen Sie! Hase Gilt für alle Referenztypen Point p1 = new Point(4,5); Point p2 = new Point(4,5); if (p1==p2) { // always false! } if (p1.equals(p2)) { // true! mit richtigem equals … § Wir müssen Methode equals() aus Object überschreiben 106 Für alle Referenztypen § Der Vergleichsoperator == testet für Objektreferenzen ob es sich um das selbe Exemplar handelt ListNode front, current; ... if (front == current) { // circular list } § Kann auch (je nach Problem) sinnvoll sein 107 Das selbe Exemplar vs. gleiche Exemplar § Für Basistypen gibt es keinen Unterschied int x = 5; int y = x; if (x==5) { … } if (x==y) { … } § Die Zahl «5» gibt es nur einmal § Und wir könnten equals() nicht verwenden da es kein Objektexemplar gibt 108 (Automatisches Un-)Boxing § … wurde zu Java hinzugefügt nachdem man Erfahrungen mit Wrapper Typen (Integer, Double, …) hatte § Automatisches Boxing/Unboxing kann zu Überraschungen führen, denn die Java Laufzeitumgebung versucht, den Speicherplatz sparsam zu benutzen 109 Arbeiten mit Wrapper Typen § Für Exemplare eines Wrapper Typs gelten die üblichen Regeln für Referenzvariable 113 Integer i1 = Integer.valueOf(128); Integer i2 = Integer.valueOf(128); System.out.print(\"Integer \"+ i1+\" and \"+i2+\" :\"); if (i1 == i2){ System.out.println(\" Equal\"); } else { System.out.println(\" Not Equal\"); } § Output wie (?) erwartet Integer 128 and 128 : Not Equal Ohne deprecated Konstruktor Arbeiten mit Wrapper Typen 114 Integer i1 = Integer.valueOf(0); Integer i2 = Integer.valueOf(0); System.out.print(\"Integer \"+ i1+\" and \"+i2+\" :\"); if (i1 == i2){ System.out.println(\" Equal\"); } else { System.out.println(\" Not Equal\"); } § Output wie (?) erwartet Integer 0 and 0 : Equal Ohne deprecated Konstruktor § Für Exemplare eines Wrapper Typs gelten die üblichen Regeln manchmal nicht Boxing von Wrapper Typen § Für Exemplare eines Wrapper Typs gelten die üblichen Regeln manchmal nicht 115 Integer i1 = 0; Integer i2 = 0; System.out.print(\"Integer \"+ i1+\" and \"+i2+\" :\"); if (i1 == i2){ System.out.println(\" Equal\"); } else { System.out.println(\" Not Equal\"); } § Output wie erwartet Integer 0 and 0 : Equal Verwendung einer int Variable ändert nichts Boxing von Wrapper Typen § Für Exemplare eines Wrapper Typs gelten die üblichen Regeln manchmal doch 116 Integer i1 = 128; Integer i2 = 128; System.out.print(\"Integer \"+ i1+\" and \"+i2+\" :\"); if (i1 == i2){ System.out.println(\" Equal\"); } else { System.out.println(\" Not Equal\"); } § Output wie erwartet Integer 128 and 128 : Not Equal Verwendung einer int Variable ändert nichts Vorsicht bei automatischem (Un)Boxing § Ausdrücke mit Integer Exemplaren, die durch Boxing entstanden, können zu Überraschungen führen 117 ArrayList<Integer> list = new ArrayList<Integer>(); int n = 420; list.add(n); list.add(n); if (list.get(0) == list.get(1)) { System.out.println(\"Equal\"); } else { System.out.println(\"Not Equal\"); } int n = 42; list.add(n); list.add(n); if (list.get(0) == list.get(1)) { System.out.println(\"Equal\"); } else { System.out.println(\"Not Equal\"); } Vorsicht bei automatischem (Un)Boxing § Ausdrücke mit Integer Exemplaren, die durch Boxing entstanden, können zu Überraschungen führen 118 ArrayList<Integer> list = new ArrayList<Integer>(); int n = 420; list.add(n); list.add(n); if (list.get(0).equals(list.get(1))) { System.out.println(\"Equal\"); } else { System.out.println(\"Not Equal\"); } Vorsicht bei automatischem (Un)Boxing § Ausdrücke mit Integer Exemplaren, die durch Boxing entstanden, können zu Überraschungen führen 119 ArrayList<Integer> list = new ArrayList<Integer>(); list.add(Integer.valueOf(420)); if (list.get(0) == 420) { System.out.println(\"Equal\"); } else { System.out.println(\"Not Equal\"); } list.add(new Integer(42)); if (list.get(0) == 42) { System.out.println(\"Equal\"); } else { System.out.println(\"Not Equal\"); } Vorsicht bei Wrapper Typen § Auch Integer.valueOf(int value) schützt nicht immer vor Überraschungen § Siehe vorherige Beispiele 121 § Für manche Werte wird beim Boxing das Integer Exemplar wiederverwendet (hier für 42) und bei anderen nicht (für 420). § «Ideally, boxing a primitive value would always yield an identical reference. In practice, this may not be feasible using existing implementation techniques. [..] [C]ertain common values [should] always be boxed into indistinguishable objects.» Oracle Java Doc (jls-5.1.7) § «Common values» wird vom Compiler/Laufzeitsystem definiert, d.h. ist «implementation dependent» § Unterschiedliche Systeme haben evtl. unterschiedliche Werte § Das System kann konfiguriert werden java -Djava.lang.Integer.IntegerCache.high=420 Boxing § d.h. an unterschiedlichen Tagen/Systemen kann es ein anderes Verständnis von «common values» geben. 122 java -Djava.lang.Integer.IntegerCache.high=130 § Damit stellen wir sicher dass Integer i1 = Integer.valueOf(128); Integer i2 = Integer.valueOf(128); § auf das selbe Exemplar verweisen System.out.print(\"Integer \"+ i1+\" and \"+i2+\" :\"); if (i1 == i2){ System.out.println(\" Equal\"); } else { System.out.println(\" Not Equal\"); } § Output wie (?) erwartet Integer 128 and 128 : Equal 123 Mein Ratschlag § Für Objektexemplare benutzen wir equals()– auch für Wrapper Typen 124 ArrayList<Integer> list = new ArrayList<Integer>(); int n = 420; list.add(n); list.add(n); if ( (list.get(0)).equals(list.get(1)) ) { System.out.println(\"Equal\"); } else { System.out.println(\"Not Equal\"); } 11.5.2 Realität und Abstraktion § long und int sind Basistypen für die Darstellung von ganzen Zahlen § Java kennt keine «unsigned» Zahlen (d.h., Zahlen ohne Vorzeichen, d.h. nicht-negative Zahlen) § double ist ein Basistyp für reelle Zahlen § Alle Zahlendarstellungen sind endlich § 32 bit für int § 64 bit für long und double 125 Realität und Abstraktion § Gegeben int i; Gilt i*i >= 0 ? 126 Realität und Abstraktion § Gegeben int i; Gilt i*i >= 0 ? 127 jshell> int i = 40000; i ==> 40000 jshell> int j = 50000; j ==> 50000 jshell> i*i $3 ==> 1600000000 jshell> j*j $4 ==> -179496729 Was ist hier passiert? 128 Endliche Darstellung(en) § Eine natürliche Zahl X wird durch 32 Bits dargestellt § Allgemein: X hat w Bits xw-1 xw-2 .. x1 x0 § Eine Darstellung weist jedem Bit ein Gewicht zu § Gewicht von Bit wi : 2i (für alle Bits 0 .. w-1) § Wir hatten (vielleicht) früher schon gesehen die Integer Darstellung von X gesehen: § Eine Abbildung von 32 Bits in die natürlichen Zahlen § Integer(X) heisst hier: natürliche ganze Zahl, kein Bezug zur Java Klasse 129 Integer(X) = xi ⋅ 2i i=0 w−1 ∑ Natürliche Zahlen: ℕ0 = {0, 1, 2, ...}Endliche Darstellung § Mit dieser Abbildung können wir mit w Bits Zahlen in Bereich von 0 … 2w – 1 darstellen § Zahlen ohne Vorzeichen («unsigned») § Seit Java 8 auch in Java möglich (später mehr) ... § Die Abbildung nennen wir daher B2U (Binary-to-Unsigned) 130 B2U(X ) = xi ⋅2 i i=0 w−1 ∑ 131 Bits B2U 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 8 1001 9 1010 10 1011 11 1100 12 1101 13 1110 14 1111 15 § Um uns ein Bild zu verschaffen arbeiten wir mit w == 4 § Unsigned Bereich: 0 … 15 Negative Zahlen § Der Speicher im Computer hat kein «Vorzeichen» § Nur Bits …. § Negative Zahlen sind (auch) sehr wichtig § Eine Weg negative Zahlen darzustellen ist, das Gewicht eines Bits zu ändern: § Gewicht von Bit 0 .. w-2: 2i (wie bisher) § Gewicht von Bit w-1: –2w-1 132 X hat w Bits xw-1 xw-2 .. x1 x0 Negative Zahlen § Diese Darstellung heisst das Zweierkomplement («Two's Complement») § B2T – Binary-to-Two's complement § Bit w-1 ist das «Vorzeichenbit» – «signed integers» § 0: Zahl positiv § 1: Zahl negativ § Aber Vorsicht: hat Gewicht –2w-1 § Die Darstellung für Java int Werte und Variable (long genauso mit 64 bit)133 B2T (X ) = − xw−1 ⋅2w−1 + xi ⋅2i i=0 w−2 ∑ 134 Bits B2U B2T 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 -8 1001 9 -7 1010 10 -6 1011 11 -5 1100 12 -4 1101 13 -3 1110 14 -2 1111 15 -1 § Um uns ein Bild zu verschaffen arbeiten wir mit w == 4 § «Signed» Bereich: –8 … 7 135 Bits B2U B2T 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 -8 1001 9 -7 1010 10 -6 1011 11 -5 1100 12 -4 1101 13 -3 1110 14 -2 1111 15 -1 § Um uns ein Bild zu verschaffen arbeiten wir mit w == 4 § Unsigned Bereich: 0 … 15 § Signed Bereich: –8 ... 7 § (– 2w-1) … (2w-1 – 1) § Addition/Subtraktion können effizient implementiert werden § Identische Hardware für signed und unsigned Positive & negative Zahlen 136 Bits B2U B2T 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 -8 1001 9 -7 1010 10 -6 1011 11 -5 1100 12 -4 1101 13 -3 1110 14 -2 1111 15 -1 § Um uns ein Bild zu verschaffen arbeiten wir mit w == 4 § Unsigned Bereich: 0 … 15 § Signed Bereich: –8 ... 7 § (– 2w-1) … (2w-1 – 1) § Addition/Subtraktion können effizient implementiert werden § Identische Hardware für signed und unsigned Positive & negative ZahlenPositive & negative Zahlen § Beispiel Addition: 2 + 4 2: 0010 4: 0100 6:0110 137 Bits B2T 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 -8 1001 -7 1010 -6 1011 -5 1100 -4 1101 -3 1110 -2 1111 -1 Positive & negative Zahlen § Beispiel Addition: 2 + 4 2: 0010 4: 0100 6:0110 138 Bits B2T 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 -8 1001 -7 1010 -6 1011 -5 1100 -4 1101 -3 1110 -2 1111 -1 Positive & negative Zahlen § Beispiel Addition: –7 + 2 –7: 1001 2: 0010 2: 1011 139 Bits B2T 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 -8 1001 -7 1010 -6 1011 -5 1100 -4 1101 -3 1110 -2 1111 -1 Positive & negative Zahlen § Beispiel Addition: –7 + 2 –7: 1001 2: 0010 –5: 1011 140 Bits B2T 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 -8 1001 -7 1010 -6 1011 -5 1100 -4 1101 -3 1110 -2 1111 -1 Positive & negative Zahlen § Was passiert wenn unser Ergebnis nicht dargestellt werden kann? § Wrap-around § Beispiel Addition: 5 + 4 5: 0101 4: 0100 6: 1001 141 Bits B2T 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 -8 1001 -7 1010 -6 1011 -5 1100 -4 1101 -3 1110 -2 1111 -1 Wäre 9 wenn wir kein Vorzeichen hätten (also mit unsigned Zahlen arbeiteten) Positive & negative Zahlen § Was passiert wenn unser Ergebnis nicht dargestellt werden kann? § Wrap-around § Beispiel Addition: 5 + 4 5: 0101 4: 0100 6: 1001 142 Wäre 9 wenn wir kein Vorzeichen hätten (also mit unsigned Zahlen arbeiteten) Bits B2U B2T 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 -8 1001 9 -7 1010 10 -6 1011 11 -5 1100 12 -4 1101 13 -3 1110 14 -2 1111 15 -1 Positive & negative Zahlen § Was passiert wenn unser Ergebnis nicht dargestellt werden kann? § Wrap-around § Beispiel Addition: 5 + 4 5: 0101 4: 0100 –7: 1001 143 Bits B2U B2T 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 -8 1001 9 -7 1010 10 -6 1011 11 -5 1100 12 -4 1101 13 -3 1110 14 -2 1111 15 -1 Aber wir arbeiten mit Zahlen mit Vorzeichen (signed) Positive & negative Zahlen § Was passiert wenn unser Ergebnis nicht dargestellt werden kann? § Wrap-around § Beispiel Addition: –8 – 1 -8: 1000 1: 0001 6: 0111 144 Bits B2U B2T 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 -8 1001 9 -7 1010 10 -6 1011 11 -5 1100 12 -4 1101 13 -3 1110 14 -2 1111 15 -1 Positive & negative Zahlen § Was passiert wenn unser Ergebnis nicht dargestellt werden kann? § Wrap-around § Beispiel Addition: –8 – 1 -8: 1000 1: 0001 7: 0111 145 Bits B2U B2T 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 -8 1001 9 -7 1010 10 -6 1011 11 -5 1100 12 -4 1101 13 -3 1110 14 -2 1111 15 -1 § Daher gilt: MAX_VALUE + 1 == MIN_VALUE § 7 + 1 == – 8 (für 4-Bit Addition) int myInt = Integer.MAX_VALUE; System.out.println(myInt); System.out.println(myInt+1); § aber …. (seit Java 8!) unsigned Operationen in Integer String sInt = Integer.toUnsignedString(myInt+1); System.out.println(sInt); 146 2147483648 2147483647 -2147483648 § Daher gilt: MAX_VALUE + 1 == MIN_VALUE § 7 + 1 == – 8 (für 4-Bit Addition) int myInt = Integer.MAX_VALUE; System.out.println(myInt); System.out.println(myInt+1); 147 2147483647 -2147483648 § Wenn für eine int Variable x das Resultat von (x+k) < x (mit k>0) dann liegt ein Overflow vor § Oder Underflow wenn (x-k) > x (mit k>0) 148 Warum ist das wichtig? § Für int gilt daher (leider) nicht § intA > intB ⇒ (intA + 1) > (intB + 1) § Oder § intA < (intA + 1) 149 Massnahmen § Müssen sicherstellen dass unser Programm nur Werte im Bereich von (– 2w-1) … (2w-1 – 1) produziert. § Mit int arbeiten aber bei möglichem Overflow/Underflow long verwenden § Kann so feststellen ob Overflow/Underflow auftrat 150 Das ist aber nicht alles … § Gilt denn wenigstens (a + b) + c == a + (b + c) ? § Für int/long ja. 151 Realität und Abstraktion § Gegeben double d, e, f; Gilt (d + e) + f == d + (e + f) ? class Weird { public static void main (String[] args) { double d = 1e308; System.out.println( (d + -d) + 3.14); System.out.println(d + (-d + 3.14)); } } 152 Realität und Abstraktion § Gegeben double d, e, f; Gilt (d + e) + f == d + (e + f) ? class Weird { public static void main (String[] args) { double d = 1e308; System.out.println( (d + -d) + 3.14); // 3.14 System.out.println(d + (-d + 3.14)); // 0.0 } } 153 Das ist aber nicht alles … § Gilt denn wenigstens (a + b) + c == a + (b + c) ? § Für int/long ja. § Für float/double nein. 154 Vorsicht § wenn Ihr Programm mit numerischen Daten rechnet § Mehr Bits (long, double vs float) helfen nur begrenzt § Skalieren Sie die Daten, überdenken Sie Ihr Modell § Was wollen Sie berechnen? 155156 “There’s\tno\tsense\tin\tbeing\tprecise\twhen\tyou\tdon’t\teven\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tknow\twhat\tyou’re\ttalking\tabout.”\t J.\tvon\tNeumann\t 157 “There’s\tno\tsense\tin\tbeing\tprecise\twhen\tyou\tdon’t\teven\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tknow\twhat\tyou’re\ttalking\tabout.”\t J.\tvon\tNeumann\t Aber … er war ein Student an der ETH (Chemie) bevor es das Departement Informatik gab! 252-0027 Einführung in die Programmierung Thomas R. Gross Department Informatik ETH Zürich Copyright (c) Pearson 2013 and Thomas Gross 2016,2018 All rights reserved. 158","libVersion":"0.3.2","langs":""}