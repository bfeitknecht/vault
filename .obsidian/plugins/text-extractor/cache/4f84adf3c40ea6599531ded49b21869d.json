{"path":"sem4/FMFP/PV/FMFP-FS18.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Part II Midterm Exam, SS18 May 15th, 2018, 10:15 – 10:45 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 9 pages. After the exam begins, check that your exam papers are complete (2 assignments and 1 page of background material). 2. Only write on the exam paper and extra paper sheets which are given by the assis- tants. Do not take any of this paper out of the exam: submit it all. Write your ﬁrst and last name and your student number on every sheet of paper that you write on. 3. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 4. Write clearly in the sense of logic, language, and readability. Label all rule applica- tions in your derivation trees. The clarity of your arguments and explanations aﬀects your grade. 5. You have 30 minutes to complete the exam. Assignment 1 2 ∑ Max. points 5 15 20 Your points Formal Methods and Functional Programming, Part II Midterm Exam, SS18 2 Assignment 1 (5 points) Consider the following IMP statement s: while y > 0 do y := x - y; x := x - y end Using the natural (big-step) semantics, prove that: ∀σ. ((σ(y) > 0 and σ(x) ≤ σ(y)) ⇒ ∃σ′.( σ′(x) = σ(y) and Ø `s, σe → σ′ )) Solution: Let σ be arbitrary. We assume σ(y) > 0 and σ(x) ≤ σ(y). We construct the derivation tree shown on the following page, where σ′′ stands for σ[y ( σ(x)−σ(y)]. Thus, choosing σ′ to be σ′′[x ( σ(y)], we have σ′(x) = σ(y) and Ø `s, σe → σ′, as required. Formal Methods and Functional Programming, Part II Midterm Exam, SS18 3(AssNS)`y:=x-y,σe→σ′′(AssNS)`x:=x-y,σ′′e→σ′′[x(σ(y)](SeqNS)`y:=x-y;x:=x-y,σe→σ′′[x(σ(y)](WhFNS)`whiley>0doy:=x-y;x:=x-yend,σ′′[x(σ(y)]e→σ′′[x(σ(y)](WhTNS)`whiley>0doy:=x-y;x:=x-yend,σe→σ′′[x(σ(y)] Formal Methods and Functional Programming, Part II Midterm Exam, SS18 4Formal Methods and Functional Programming, Part II Midterm Exam, SS18 5Formal Methods and Functional Programming, Part II Midterm Exam, SS18 6 Assignment 2 (15 points) In this assignment, we are considering an extension of the IMP programming language with a swap(x, y) statement that swaps the values of two variables x and y. The inference rule in natural semantics is as follows: (SwapNS) `swap(x, y), σe → σ[x ( σ(y)][y ( σ(x)] Let S be the set of all programs that consist of a sequence of k swap statements. That is, each program s ∈ S is of the form swap(x1, y1);swap(x2, y2); . . . ;swap(xk, yk), for some variables x1, x2, . . . , xk, y1, y2, . . . , yk, and some positive integer k. Using natural (big-step) semantics, prove the following property of such programs: ∀s ∈ S, σ, σ′, x. Ø `s, σe → σ′ Ô⇒ ∃y. σ′(y) = σ(x) Solution: We deﬁne P (T ) ≡ ∀s ∈ S, σ, σ′, x. root(T ) ≡ (`s, σe → σ′) Ô⇒ ∃y. σ′(y) = σ(x) and prove ∀T. P (T ) by induction on the shape of the derivation tree T . Therefore, our induction hypothesis is ∀T ′ X T. P (T ′). Let the program s ∈ S, the states σ, σ′, and the variable x be arbitrary. In order to show the implication, we assume root(T ) ≡ (`s, σe → σ′) and show that ∃y. σ′(y) = σ(x). We distinguish all possible cases for the last rule applied in T : Case (SwapNS): In this case, the tree T must be of the form (SwapNS) `swap(a, b), σe → σ[a ( σ(b)][b ( σ(a)] for some variables a and b. Thus, we have σ′ = σ[a ( σ(b)][b ( σ(a)]. In the following cases, we show that it is always possible to pick a variable y such that σ′(y) = σ(x): Case x ≡ a: We pick y ≡ b and get σ′(y) y≡b = σ′(b) = (σ[a ( σ(b)][b ( σ(a)])(b) = σ(a) x≡a = σ(x) Case x ≡ b ∧ x y a: We pick y ≡ a and get σ′(y) y≡a = σ′(a) = (σ[a ( σ(b)][b ( σ(a)])(a) bya = (σ[a ( σ(b)])(a) = σ(b) x≡b = σ(x) Case x y a ∧ x y b: Finally, we pick y ≡ x and get σ′(y) y≡x = σ′(x) = (σ[a ( σ(b)][b ( σ(a)])(x) xyb = (σ[a ( σ(b)])(x) xya = σ(x) Formal Methods and Functional Programming, Part II Midterm Exam, SS18 7 Case (SeqNS): In this case, the tree T must be of the form A A AA \u0001 \u0001 \u0001\u0001 T1 `s1, σe → σ′′ A A AA \u0001 \u0001 \u0001\u0001 T2 `s2, σ′′e → σ′(SeqNS) `s1;s2, σe → σ′ for some subprograms s1 ∈ S and s2 ∈ S, some state σ′′, and some derivation trees T1 and T2. Since T1 X T and T2 X T , we can apply the induction hypothesis twice to obtain P (T1) and P (T2), respectively. After instantiating the universally quantiﬁed variables s, σ, σ′, and x in P (T1) with s1, σ, σ′′, and x, respectively, together with root(T1) ≡ (`s1, σe → σ′′), we get that there is a variable z such that σ′′(z) = σ(x). Moreover, after instantiating the variables s, σ, σ′, and x in P (T2) with s2, σ′′, σ′, and z, respectively, together with root(T2) ≡ (`s2, σ′′e → σ′), we get that there is a variable y such that σ′(y) = σ′′(z). Thus, we have proven the existence of a variable y with σ′(y) = σ(z)′′ = σ(x), as required. Formal Methods and Functional Programming, Part II Midterm Exam, SS18 8Formal Methods and Functional Programming, Part II Midterm Exam, SS18 9 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ∶∶= skip T x := e T s; s T if b then s else s end T while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). Natural Semantics (Big-Step Semantics) (SkipNS) `skip, σe → σ (AssNS) `x := e, σe → σ[x ( A[[e]]σ] `s1, σe → σ′ `s2, σ′e → σ′′ (SeqNS) `s1;s2, σe → σ′′ `s1, σe → σ′ (IfTNS) `if b then s1 else s2 end, σe → σ′ if B[[b]]σ = tt `s2, σe → σ′ (IfFNS) `if b then s1 else s2 end, σe → σ′ if B[[b]]σ = ﬀ `s, σe → σ′ `while b do s end, σ′e → σ′′ (WhTNS) `while b do s end, σe → σ′′ if B[[b]]σ = tt (WhFNS) `while b do s end, σe → σ if B[[b]]σ = ﬀ","libVersion":"0.5.0","langs":""}