{"path":"sem2/AuW/VRL/slides/AuW-L19-convex-hulls.pdf","text":"Vorlesung Algorithmen und Wahrscheinlichkeit, D-INFK, ETH Zürich Angelika Steger & Emo Welzl Konvexe Hülle: Jarvis Wrap 0 / 15 Problemstellung ConvexHull-Problem. Gegeben eine endliche Punktemenge P ⊆ R2, bestimme die konvexe Hülle von P. ▶ Was ist die konvexe Hülle? ▶ Wie stellt man die konvexe Hülle dar? ▶ Wie geht man mit Spezialfällen und numerischen Problemen um? 1 / 15 Problemstellung ConvexHull-Problem. Gegeben eine endliche Punktemenge P ⊆ R2, bestimme die konvexe Hülle von P. ▶ Was ist die konvexe Hülle? ▶ Wie stellt man die konvexe Hülle dar? ▶ Wie geht man mit Spezialfällen und numerischen Problemen um? 1 / 15 Problemstellung ConvexHull-Problem. Gegeben eine endliche Punktemenge P ⊆ R2, bestimme die konvexe Hülle von P. ▶ Was ist die konvexe Hülle? ▶ Wie stellt man die konvexe Hülle dar? ▶ Wie geht man mit Spezialfällen und numerischen Problemen um? 1 / 15 Konvexe Menge, konvexe Hülle Sei d ∈ N. ▶ Für v0, v1 ∈ Rd sei v0v1 := {(1 − λ)v0 + λv1 | λ ∈ R, 0 ≤ λ ≤ 1} , das v0 und v1 verbindende Liniensegment. ▶ Eine Menge C ⊆ Rd heisst konvex, falls ∀v0, v1 ∈ C : v0v1 ⊆ C . ▶ Die konvexe Hülle, conv(S), einer Menge S ⊆ Rd ist der Schnitt aller konvexen Mengen, die S enthalten, d.h. conv(S) := ⋂ S⊆C ⊆Rd , C konvex C . siehe „Diskrete Mathematik“, „Analysis“, „Lineare Algebra“. 2 / 15 Konvexe Menge, konvexe Hülle Sei d ∈ N. ▶ Für v0, v1 ∈ Rd sei v0v1 := {(1 − λ)v0 + λv1 | λ ∈ R, 0 ≤ λ ≤ 1} , das v0 und v1 verbindende Liniensegment. ▶ Eine Menge C ⊆ Rd heisst konvex, falls ∀v0, v1 ∈ C : v0v1 ⊆ C . ▶ Die konvexe Hülle, conv(S), einer Menge S ⊆ Rd ist der Schnitt aller konvexen Mengen, die S enthalten, d.h. conv(S) := ⋂ S⊆C ⊆Rd , C konvex C . siehe „Diskrete Mathematik“, „Analysis“, „Lineare Algebra“. 2 / 15 Konvexe Menge, konvexe Hülle Sei d ∈ N. ▶ Für v0, v1 ∈ Rd sei v0v1 := {(1 − λ)v0 + λv1 | λ ∈ R, 0 ≤ λ ≤ 1} , das v0 und v1 verbindende Liniensegment. ▶ Eine Menge C ⊆ Rd heisst konvex, falls ∀v0, v1 ∈ C : v0v1 ⊆ C . ▶ Die konvexe Hülle, conv(S), einer Menge S ⊆ Rd ist der Schnitt aller konvexen Mengen, die S enthalten, d.h. conv(S) := ⋂ S⊆C ⊆Rd , C konvex C . siehe „Diskrete Mathematik“, „Analysis“, „Lineare Algebra“. 2 / 15 Konvexe Menge, konvexe Hülle Sei d ∈ N. ▶ Für v0, v1 ∈ Rd sei v0v1 := {(1 − λ)v0 + λv1 | λ ∈ R, 0 ≤ λ ≤ 1} , das v0 und v1 verbindende Liniensegment. ▶ Eine Menge C ⊆ Rd heisst konvex, falls ∀v0, v1 ∈ C : v0v1 ⊆ C . ▶ Die konvexe Hülle, conv(S), einer Menge S ⊆ Rd ist der Schnitt aller konvexen Mengen, die S enthalten, d.h. conv(S) := ⋂ S⊆C ⊆Rd , C konvex C . siehe „Diskrete Mathematik“, „Analysis“, „Lineare Algebra“. 2 / 15 Darstellung der konvexen Hülle Für eine endliche Punktemenge P in der Ebene wird die konvexe Hülle durch ein Polygon, der Rand von conv(P), bestimmt, dessen Ecken Punkte aus P sind. Wenn wir von der Berechnung von conv(P) sprechen, so meinen wir die Bestimmung einer Folge (q0, q1, . . . , qh−1), h ≤ n, der Ecken dieses Polygons, beginnend bei einer beliebiger Ecke q0 und dann entgegen dem Uhrzeigersinn entlang dieses Polygons. Beachte: Q := {q0, q1, . . . , qh−1} ⊆ P ist die kleinste Teilmenge von P mit conv(Q) = conv(P). 3 / 15 Darstellung der konvexen Hülle Für eine endliche Punktemenge P in der Ebene wird die konvexe Hülle durch ein Polygon, der Rand von conv(P), bestimmt, dessen Ecken Punkte aus P sind. Wenn wir von der Berechnung von conv(P) sprechen, so meinen wir die Bestimmung einer Folge (q0, q1, . . . , qh−1), h ≤ n, der Ecken dieses Polygons, beginnend bei einer beliebiger Ecke q0 und dann entgegen dem Uhrzeigersinn entlang dieses Polygons. Beachte: Q := {q0, q1, . . . , qh−1} ⊆ P ist die kleinste Teilmenge von P mit conv(Q) = conv(P). 3 / 15 Problemstellung p7p5p1p3p6p2p4 Punktemenge P, p7p5p1p3p6p2p4 konvexe Hülle conv(P), p7p5p1p3p6p2p4 Polygon (p4, p1, p5, p7). ConvexHull-Problem. Gegeben eine endliche Punktemenge P ⊆ R2, bestimme die Ecken des conv(P) umrandenden Polygons, in der Reihenfolge gegen den Uhrzeigersinn. Vereinfachende Annahme: Allgemeine Lage, d.h. keine 3 Punkte auf einer gemeinsamen Geraden, keine 2 Pkt gleiche x-Koordinate. 4 / 15 Problemstellung p7p5p1p3p6p2p4 Punktemenge P, p7p5p1p3p6p2p4 konvexe Hülle conv(P), p7p5p1p3p6p2p4 Polygon (p4, p1, p5, p7). ConvexHull-Problem. Gegeben eine endliche Punktemenge P ⊆ R2, bestimme die Ecken des conv(P) umrandenden Polygons, in der Reihenfolge gegen den Uhrzeigersinn. Vereinfachende Annahme: Allgemeine Lage, d.h. keine 3 Punkte auf einer gemeinsamen Geraden, keine 2 Pkt gleiche x-Koordinate. 4 / 15 Problemstellung p7p5p1p3p6p2p4 Punktemenge P, p7p5p1p3p6p2p4 konvexe Hülle conv(P), p7p5p1p3p6p2p4 Polygon (p4, p1, p5, p7). ConvexHull-Problem. Gegeben eine endliche Punktemenge P ⊆ R2, bestimme die Ecken des conv(P) umrandenden Polygons, in der Reihenfolge gegen den Uhrzeigersinn. Vereinfachende Annahme: Allgemeine Lage, d.h. keine 3 Punkte auf einer gemeinsamen Geraden, keine 2 Pkt gleiche x-Koordinate. 4 / 15 Problemstellung p7p5p1p3p6p2p4 Punktemenge P, p7p5p1p3p6p2p4 konvexe Hülle conv(P), p7p5p1p3p6p2p4 Polygon (p4, p1, p5, p7). ConvexHull-Problem. Gegeben eine endliche Punktemenge P ⊆ R2, bestimme die Ecken des conv(P) umrandenden Polygons, in der Reihenfolge gegen den Uhrzeigersinn. Vereinfachende Annahme: Allgemeine Lage, d.h. keine 3 Punkte auf einer gemeinsamen Geraden, keine 2 Pkt gleiche x-Koordinate. 4 / 15 Problemstellung p7p5p1p3p6p2p4 Punktemenge P, p7p5p1p3p6p2p4 konvexe Hülle conv(P), p7p5p1p3p6p2p4 Polygon (p4, p1, p5, p7). ConvexHull-Problem. Gegeben eine endliche Punktemenge P ⊆ R2, bestimme die Ecken des conv(P) umrandenden Polygons, in der Reihenfolge gegen den Uhrzeigersinn. Vereinfachende Annahme: Allgemeine Lage, d.h. keine 3 Punkte auf einer gemeinsamen Geraden, keine 2 Pkt gleiche x-Koordinate. 4 / 15 Randkanten p7p5p1p3p6p2p4 Ein Paar qr ∈ P 2, q ̸= r , heisst Randkante von P, falls alle Punkte in P \\ {q, r } links von qr liegen, d.h. auf der linken Seite der gerichteten Geraden durch q und r , gerichtet von q nach r , liegen. Lemma (q0, q1, . . . , qh−1) ist die Eckenfolge des conv(P) umschliessenden Polygons gegen den Uhrzeigersinn genau dann wenn alle Paare (qi−1, qi ), i = 1, 2, . . . , h, Randkanten von P sind (Indizes modh). 5 / 15 Randkanten p7p5p1p3p6p2p4 Ein Paar qr ∈ P 2, q ̸= r , heisst Randkante von P, falls alle Punkte in P \\ {q, r } links von qr liegen, d.h. auf der linken Seite der gerichteten Geraden durch q und r , gerichtet von q nach r , liegen. Lemma (q0, q1, . . . , qh−1) ist die Eckenfolge des conv(P) umschliessenden Polygons gegen den Uhrzeigersinn genau dann wenn alle Paare (qi−1, qi ), i = 1, 2, . . . , h, Randkanten von P sind (Indizes modh). 5 / 15 Orientierungstest Wie entscheiden wir „p liegt links von qr “? Lemma Seien p = (px , py ), q = (qx , qy ), und r = (rx , ry ) Punkte in R2. Es gilt q ̸= r und p liegt links von qr genau dann wenn det(p, q, r ) := \f \f \f \f \f \f px py 1 qx qy 1 rx ry 1 \f \f \f \f \f \f = \f \f \f \f qx − px qy − py rx − px ry − py \f \f \f \f > 0 ⇔ (qx − px )(ry − py ) > (qy − py )(rx − px ) 1 2 | det(p, q, r )| = die Fläche des Dreiecks pqr Das Vorzeichen von det(p, q, r ) bestimmt, wie die Punkte p, q, r den Rand dieses Dreiecks durchlaufen. 6 / 15 Orientierungstest Wie entscheiden wir „p liegt links von qr “? Lemma Seien p = (px , py ), q = (qx , qy ), und r = (rx , ry ) Punkte in R2. Es gilt q ̸= r und p liegt links von qr genau dann wenn det(p, q, r ) := \f \f \f \f \f \f px py 1 qx qy 1 rx ry 1 \f \f \f \f \f \f = \f \f \f \f qx − px qy − py rx − px ry − py \f \f \f \f > 0 ⇔ (qx − px )(ry − py ) > (qy − py )(rx − px ) 1 2 | det(p, q, r )| = die Fläche des Dreiecks pqr Das Vorzeichen von det(p, q, r ) bestimmt, wie die Punkte p, q, r den Rand dieses Dreiecks durchlaufen. 6 / 15 Orientierungstest Wie entscheiden wir „p liegt links von qr “? Lemma Seien p = (px , py ), q = (qx , qy ), und r = (rx , ry ) Punkte in R2. Es gilt q ̸= r und p liegt links von qr genau dann wenn det(p, q, r ) := \f \f \f \f \f \f px py 1 qx qy 1 rx ry 1 \f \f \f \f \f \f = \f \f \f \f qx − px qy − py rx − px ry − py \f \f \f \f > 0 ⇔ (qx − px )(ry − py ) > (qy − py )(rx − px ) 1 2 | det(p, q, r )| = die Fläche des Dreiecks pqr Das Vorzeichen von det(p, q, r ) bestimmt, wie die Punkte p, q, r den Rand dieses Dreiecks durchlaufen. 6 / 15 Erster naiver Ansatz Gehe durch jedes der n(n − 1) geordneten Paare qr , und prüfe, ob dies eine Randkante ist, indem man für alle n − 2 Punkte p in P \\ {q, r } feststellt, ob p links von qr liegt. So haben wir die Randkanten in O(n3) gefunden, die wir nur mehr richtig aneinanderreihen müssen. 7 / 15 Erster naiver Ansatz Gehe durch jedes der n(n − 1) geordneten Paare qr , und prüfe, ob dies eine Randkante ist, indem man für alle n − 2 Punkte p in P \\ {q, r } feststellt, ob p links von qr liegt. So haben wir die Randkanten in O(n3) gefunden, die wir nur mehr richtig aneinanderreihen müssen. 7 / 15 Finden des nächsten Punkts q0 := Punkt mit kleinster x-Koordinate in P. q0 ist sicher eine Ecke der konvexen Hülle, also Teil der gesuchten Folge und wir können insbesondere die Folge auch mit q0 beginnen. Wie ﬁnden wir den Punkt q1, der die Randkante q0q1 bildet? FindNext(q) 1: Wähle p0 ∈ P \\ {q} beliebig 2: qnext ← p0 3: for all p ∈ P \\ {q, p0} do 4: if p rechts von qqnext then 5: qnext ← p 6: return qnext q 8 / 15 Ordnung um einen Punkt Gegeben q ∈ P, sei ≺q eine Relation auf P \\ {q} mittels p1 ≺q p2 :⇔ p1 rechts von qp2 qp5p1p3p6p2p4 p4 ≺q p2 ≺q p6 ≺q p1 ≺q p3 ≺q p5 qp4 ist Randkante. Lemma Ist q eine Ecke der konvexen Hülle von P, so ist die Relation ≺q eine totale Ordnung auf P \\ {q}. Für das Minimum pmin dieser Ordnung gilt, dass qpmin eine Randkante ist. 9 / 15 Ordnung um einen Punkt Gegeben q ∈ P, sei ≺q eine Relation auf P \\ {q} mittels p1 ≺q p2 :⇔ p1 rechts von qp2 qp5p1p3p6p2p4 p4 ≺q p2 ≺q p6 ≺q p1 ≺q p3 ≺q p5 qp4 ist Randkante. Lemma Ist q eine Ecke der konvexen Hülle von P, so ist die Relation ≺q eine totale Ordnung auf P \\ {q}. Für das Minimum pmin dieser Ordnung gilt, dass qpmin eine Randkante ist. 9 / 15 Ordnung um einen Punkt Gegeben q ∈ P, sei ≺q eine Relation auf P \\ {q} mittels p1 ≺q p2 :⇔ p1 rechts von qp2 qp5p1p3p6p2p4 p4 ≺q p2 ≺q p6 ≺q p1 ≺q p3 ≺q p5 qp4 ist Randkante. Lemma Ist q eine Ecke der konvexen Hülle von P, so ist die Relation ≺q eine totale Ordnung auf P \\ {q}. Für das Minimum pmin dieser Ordnung gilt, dass qpmin eine Randkante ist. 9 / 15 Jarvis Wrap (Einwickeln) JarvisWrap(P) 1: h ← 0 2: pnow ← Punkt in P mit kleinster x-Koordinate 3: repeat 4: qh ← pnow 5: pnow ← FindNext(qh) 6: h ← h + 1 7: until pnow = q0 8: return (q0, q1, . . . , qh−1) Satz Für eine Menge P von n Punkten in allgemeiner Lage in R2 berechnet der Algorithmus JarvisWrap die konvexe Hülle in Zeit O(nh), wobei h die Anzahl der Ecken der konvexen Hülle von P ist. 10 / 15 Jarvis Wrap (Einwickeln) JarvisWrap(P) 1: h ← 0 2: pnow ← Punkt in P mit kleinster x-Koordinate 3: repeat 4: qh ← pnow 5: pnow ← FindNext(qh) 6: h ← h + 1 7: until pnow = q0 8: return (q0, q1, . . . , qh−1) Satz Für eine Menge P von n Punkten in allgemeiner Lage in R2 berechnet der Algorithmus JarvisWrap die konvexe Hülle in Zeit O(nh), wobei h die Anzahl der Ecken der konvexen Hülle von P ist. 10 / 15 Einwickeln (wrap) 11 / 15 Einwickeln (wrap) 11 / 15 Jarvis Wrap – Laufzeit Satz Für eine Menge P von n Punkten in allgemeiner Lage in R2 berechnet der Algorithmus JarvisWrap die konvexe Hülle in Zeit O(nh), wobei h die Anzahl der Ecken der konvexen Hülle von P ist. ▶ Da h ≤ n, läuft JarvisWrap in O(n2) (statt O(n3)). ▶ Ist h = O(1), z.B. conv(P) ist ein Dreieck, läuft der Algorithmus in O(n) Zeit. Für Punkte zufällig in einem Quadrat: Erwartete #Ecken O(log n). Für Punkte zufällig in einer Kreisscheibe: Erwartete #Ecken O( 3√n). 12 / 15 Jarvis Wrap – Laufzeit Satz Für eine Menge P von n Punkten in allgemeiner Lage in R2 berechnet der Algorithmus JarvisWrap die konvexe Hülle in Zeit O(nh), wobei h die Anzahl der Ecken der konvexen Hülle von P ist. ▶ Da h ≤ n, läuft JarvisWrap in O(n2) (statt O(n3)). ▶ Ist h = O(1), z.B. conv(P) ist ein Dreieck, läuft der Algorithmus in O(n) Zeit. Für Punkte zufällig in einem Quadrat: Erwartete #Ecken O(log n). Für Punkte zufällig in einer Kreisscheibe: Erwartete #Ecken O( 3√n). 12 / 15 Jarvis Wrap – Laufzeit Satz Für eine Menge P von n Punkten in allgemeiner Lage in R2 berechnet der Algorithmus JarvisWrap die konvexe Hülle in Zeit O(nh), wobei h die Anzahl der Ecken der konvexen Hülle von P ist. ▶ Da h ≤ n, läuft JarvisWrap in O(n2) (statt O(n3)). ▶ Ist h = O(1), z.B. conv(P) ist ein Dreieck, läuft der Algorithmus in O(n) Zeit. Für Punkte zufällig in einem Quadrat: Erwartete #Ecken O(log n). Für Punkte zufällig in einer Kreisscheibe: Erwartete #Ecken O( 3√n). 12 / 15 Jarvis Wrap – Laufzeit Satz Für eine Menge P von n Punkten in allgemeiner Lage in R2 berechnet der Algorithmus JarvisWrap die konvexe Hülle in Zeit O(nh), wobei h die Anzahl der Ecken der konvexen Hülle von P ist. ▶ Da h ≤ n, läuft JarvisWrap in O(n2) (statt O(n3)). ▶ Ist h = O(1), z.B. conv(P) ist ein Dreieck, läuft der Algorithmus in O(n) Zeit. Für Punkte zufällig in einem Quadrat: Erwartete #Ecken O(log n). Für Punkte zufällig in einer Kreisscheibe: Erwartete #Ecken O( 3√n). 12 / 15 Implementierung – Degeneriertheiten Kollinearitäten (3 Punkte auf Gerade), gleiche x-Koord., . . . ▶ Anfangspunkt q0 als den Punkt mit lexikographisch kleinster Koordinate (unter allen mit kleinster x-Koordinate, den mit kleinster y -Koordinate). (Adaption der x-Ordnung der Punkte) ▶ Der Test “p rechts von qqnext” muss ersetzt werden durch (p rechts von qqnext) oder (p auf der Geraden durch qqnext und |qp| > |qqnext|). (Adaption der Ordnung ≺q) ▶ In der Regel können wir nicht einmal annehmen, dass die Punkte verschieden sind (z.B. gegeben in einem Feld)! Software ohne Berücksichtigung dieser Fälle hat geringen Nutzen! 13 / 15 Implementierung – numerische Probleme “(qx − px )(ry − py ) > (qy − py )(rx − px )” ist in einer Implementierung mit Fliesskommazahlen nicht exakt. Es geht oft nicht um die absolute Genauigkeit des Ergebnisses (z.B. bei Eingaben, die selbst schon mit Fehlern behaftet sind). Vielmehr kann der Algorithmus völlig falsche Ergebnisse liefern oder in eine unendliche Schleife laufen. Zum Beispiel Vorbeilaufen am Startpunkt (wegen numerischer Probleme, weil Startpunkt doppelt auftritt). Programmbibliotheken bieten exakte Datentypen (für spezielle Operationen). 14 / 15 Implementierung – numerische Probleme “(qx − px )(ry − py ) > (qy − py )(rx − px )” ist in einer Implementierung mit Fliesskommazahlen nicht exakt. Es geht oft nicht um die absolute Genauigkeit des Ergebnisses (z.B. bei Eingaben, die selbst schon mit Fehlern behaftet sind). Vielmehr kann der Algorithmus völlig falsche Ergebnisse liefern oder in eine unendliche Schleife laufen. Zum Beispiel Vorbeilaufen am Startpunkt (wegen numerischer Probleme, weil Startpunkt doppelt auftritt). Programmbibliotheken bieten exakte Datentypen (für spezielle Operationen). 14 / 15 Implementierung – numerische Probleme “(qx − px )(ry − py ) > (qy − py )(rx − px )” ist in einer Implementierung mit Fliesskommazahlen nicht exakt. Es geht oft nicht um die absolute Genauigkeit des Ergebnisses (z.B. bei Eingaben, die selbst schon mit Fehlern behaftet sind). Vielmehr kann der Algorithmus völlig falsche Ergebnisse liefern oder in eine unendliche Schleife laufen. Zum Beispiel Vorbeilaufen am Startpunkt (wegen numerischer Probleme, weil Startpunkt doppelt auftritt). Programmbibliotheken bieten exakte Datentypen (für spezielle Operationen). 14 / 15 Untere Schranke für ConvexHull Betrachte eine Folge (x1, x2, . . . , xn) von Zahlen in R. Wir setzen pi = (xi , x 2 i ), i = 1, 2, . . . , n (vertikale Projektion von der x-Achse im R2 auf die Einheitsparabel y = x 2). x1x5x4x2x3p1p5p4p2p3 Aus der Folge der Ecken der konvexen Hülle von P := {p1, p2, . . . , pn} ergibt sich (in linearer Zeit) auch die aufsteigend sortierte Reihenfolge der xi ’s. Wir haben eine sogenannte Reduktion gezeigt: Kann man ConvexHull in t(n) lösen, so kann man in t(n)+O(n) Zeit sortieren. 15 / 15 Untere Schranke für ConvexHull Betrachte eine Folge (x1, x2, . . . , xn) von Zahlen in R. Wir setzen pi = (xi , x 2 i ), i = 1, 2, . . . , n (vertikale Projektion von der x-Achse im R2 auf die Einheitsparabel y = x 2). x1x5x4x2x3p1p5p4p2p3 Aus der Folge der Ecken der konvexen Hülle von P := {p1, p2, . . . , pn} ergibt sich (in linearer Zeit) auch die aufsteigend sortierte Reihenfolge der xi ’s. Wir haben eine sogenannte Reduktion gezeigt: Kann man ConvexHull in t(n) lösen, so kann man in t(n)+O(n) Zeit sortieren. 15 / 15 Untere Schranke für ConvexHull Betrachte eine Folge (x1, x2, . . . , xn) von Zahlen in R. Wir setzen pi = (xi , x 2 i ), i = 1, 2, . . . , n (vertikale Projektion von der x-Achse im R2 auf die Einheitsparabel y = x 2). x1x5x4x2x3p1p5p4p2p3 Aus der Folge der Ecken der konvexen Hülle von P := {p1, p2, . . . , pn} ergibt sich (in linearer Zeit) auch die aufsteigend sortierte Reihenfolge der xi ’s. Wir haben eine sogenannte Reduktion gezeigt: Kann man ConvexHull in t(n) lösen, so kann man in t(n)+O(n) Zeit sortieren. 15 / 15","libVersion":"0.3.1","langs":""}