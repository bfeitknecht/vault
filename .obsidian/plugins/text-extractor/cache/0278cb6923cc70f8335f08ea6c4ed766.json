{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w04.pdf","text":"(weiter auf der nächsten Seite →) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Woche 4 – Übersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder Vollständigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne Gewähr.) Anmerkungen zu den Code-Expert Abgaben: Anmerkungen zu den Theorie Abgaben aus dem letzten Jahr: Noch einmal zur Erinnerung die Definition von fibLouis. Oft habe ich nun diesen Umformungsschritt gesehen (nächstes Bild). Hier auch direkt die richtige Lösung: • OTP sehr schön (später im 6. Semester in InfoSec mehr dazu). • Prime Numbers auch sehr schön gelöst (am effizientesten mit List Compr.). • Words habe ich teilweise sehr schöne & kurze Ergebnisse gesehen. • Palindromes teilweise sehr mühsam gelöst. So geht es am schnellsten: • Gemischte Ergebnisse bei 1a): Guckt euch alle noch einmal die Musterlösung an, sollte dann aber selbsterklärend sein. (Auch in diesem Jahr ein guter Hinweis 😉) • Einige kleinere Probleme bei 1b), die aber sehr wichtig sind: 1. Wichtig: Jede Umformung benötigt eine Begründung, egal wie trivial 2. Viele illegale Umformungen. Hier eine Erklärung: (weiter auf der nächsten Seite →) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Eine weitere Problematik ist folgende gewesen: Das waren aber beides typische Anfängerfehler, und ansonsten waren die Beweise sehr schön, also macht euch keine grossen Sorgen – aber achtet auf die benannten Probleme! Abschliessend kann noch erwähnt werden, dass sich die zu beweisende Aussage ganz einfach in wenigen Zeilen direkt beweisen lässt (ohne Induktion zu verwenden), sobald man das Hilfslemma 𝑎𝑢𝑥 𝑛 = (𝑓𝑖𝑏𝐿𝑜𝑢𝑖𝑠 𝑛, 𝑓𝑖𝑏𝐿𝑜𝑢𝑖𝑠 (𝑛 + 1)) per Induktion bewiesen hat (hier geht es nicht ohne Induktion). (weiter auf der nächsten Seite →) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Induktion über Listen in Haskell: In der letzten Woche haben wir Induktionsbeweise über natürliche Zahlen eingeführt. In dieser Woche wollen wir uns mit Induktionsbeweisen über Listen in Haskell beschäftigen. Von der grundlegenden Idee sind diese sehr ähnlich, allerdings gibt es einige Tricks und Fallen die man kennen und beachten muss. Diese sind: • Man muss die richtige Induktionsvariable auswählen • Man muss häufig erst ein Hilfslemma aufstellen • Man muss häufig „generalisieren“ Das gucken wir uns gleich anhand eines Beispiels genauer an. Zunächst die allgemeine Syntax für Induktionsbeweise, dieses Mal im CYP-Style: Ganz wichtig, eure Prädikate, die an die „grünen“ Stellen kommen, dürfen kein“=“ enthalten, sondern: „.=.“ (kp warum ehrlich gesagt). Hier ein Beispiel mit der korrekten Syntax aus der Übungsstunde (zu finden auch auf CodeExpert, Demoaufgaben CYP): (weiter auf der nächsten Seite →) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Nun wollen wir uns ein Beispiel ansehen, anhand dessen wir erkennen, wieso wir die oben genannten Tricks benötigen. Dafür definieren wir zunächst folgende Haskell-Funktionen: Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Wir wollen nun folgendes beweisen: ∀𝑥𝑠 ∷ [𝑎] . rev xs = qrev xs [] Wir verwenden dafür zunächst unseren allgemeinen Ansatz: Wir kommen mit diesem Proof nicht weiter. Egal von welcher Seite wir versuchen, den Step-Case zu beweisen, haben wir keine Chance, den Beweis fortzusetzen, weil uns die Definitionen/Regeln fehlen. Genauer: Wir können ∀𝑥 ∷ 𝑎 . ∀𝑥𝑠 ∷ [𝑎] . 𝑟𝑒𝑣 𝑥𝑠 + + [𝑥] = 𝑞𝑟𝑒𝑣 𝑥𝑠 [𝑥] nicht beweisen. Nun zu dem Trick (bzw. wie ich bei so einer Aufgabe vorgehen würde): Ich versuche mir immer erst einmal die Induktion (insbesondere den Step-Case) einmal im Kopf durchzudenken und zu überlegen, an welchem Punkt ich an ein Problem kommen könnte. Hier ist das Problem offensichtlich, dass ich 𝑟𝑒𝑣 𝑥𝑠 + + [𝑥] = 𝑞𝑟𝑒𝑣 𝑥𝑠 [𝑥] nicht beweisen kann. Also verwende ich folgenden Trick: Ich überlege mir ein „Extra-Lemma“, dass sich beweisen lässt, und beweise es extern: Hier wollen wir 𝑟𝑒𝑣 𝑥𝑠 + + [𝑥] = 𝑞𝑟𝑒𝑣 𝑥𝑠 [𝑥] zeigen können, das können wir als Extra (oder Hilfs-) Lemma definieren: ∀𝑥𝑠 ∷ [𝑎] . ∀𝑧𝑠 ∷ [𝑎] . 𝑟𝑒𝑣 𝑥𝑠 + + 𝑧𝑠 = 𝑞𝑟𝑒𝑣 𝑥𝑠 𝑧𝑠 Um so ein Hilfs-Lemma aufzustellen, hilft es, sich immer anzugucken, woran der „naive“ Approach scheitert und wie genau die Funktionen, die man in seinem Beweis benutzt, überhaupt funktioniert. Ich gebe jetzt hier einen ganz inoffiziellen Tipp, der aber so gut wie immer hinkommt: Wenn eine Funktion, die ihr in eurem Prädikat P benutzt für allgemeine Listen definiert ist, z.B. hier 𝑞𝑟𝑒𝑣 𝑥𝑠 𝑧𝑠, ihr in eurem Prädikat aber eine der beiden Listen durch die leere Liste (oder bspw. bei natürlichen Zahlen eine Funktion 𝑓 𝑛 𝑘 = ⋯ im Prädikat durch 𝑓 𝑛 0 ersetzt wird) oder ein anderes „spezifisches Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Objekt“ ersetzt wird, funktioniert der naive Approach nicht und ihr müsst euch ein Hilfslemma überlegen, bei dem im Prädikat das „spezifische Objekt“ generalisiert wird, also für eine beliebige Liste oder eine beliebige natürliche Zahl gilt. Dabei geht man so vor, dass man in seinem Prädikat das „spezifische Objekt“ durch den allgemeinen Typen ersetzt (also hier in unserem Beispiel 𝑞𝑟𝑒𝑣 𝑥𝑠 [] durch 𝑞𝑟𝑒𝑣 𝑥𝑠 𝑧𝑠 für ein allg. 𝑧𝑠 ersetzt und sich überlegt, wie man die „andere Seite“ der Gleichung im Prädikat anpassen muss: Dafür guckt man sich am besten die Funktionen an und überlegt, was genau diese machen. Konkret hier in diesem Beispiel: 𝑞𝑟𝑒𝑣 nimmt sich (so lange möglich), das je erste Element vom ersten Argument, der ersten Liste 𝑥𝑠 und hängt es vorne an das zweite Argument, die Liste 𝑧𝑠 an. Dabei wird natürlich die Liste 𝑥𝑠 „reversed“ vorne an 𝑦𝑠 rangehängt, also macht 𝑞𝑟𝑒𝑣 𝑥𝑠 𝑧𝑠 eigentlich folgendes: 𝑣𝑜𝑟𝑛𝑒_𝑟𝑎𝑛ℎä𝑛𝑔𝑒𝑛(𝑟𝑒𝑣𝑒𝑟𝑠𝑒𝑑(𝑥𝑠), 𝑧𝑠) und – naja, das ist jetzt bestimmt klar – 𝑟𝑒𝑣 reversed einfach eine beliebige Liste 𝑥𝑠, also können wir „𝑣𝑜𝑟𝑛𝑒_𝑟𝑎𝑛ℎä𝑛𝑔𝑒𝑛(𝑟𝑒𝑣𝑒𝑟𝑠𝑒𝑑(𝑥𝑠), 𝑧𝑠)“ auch folgendermassen mit 𝑟𝑒𝑣 ausdrücken: 𝑟𝑒𝑣 𝑥𝑠 + + 𝑧𝑠, denn aus meiner ersten Übungsstunde wissen wir, dass „xs ++ zs“ einfach xs „vorne an zs ranhängt“ (oder wie der Profi sagt: „diE liStEn xs uNd ys kOnKatTiNieRt“). Also wissen wir, was 𝑞𝑟𝑒𝑣 𝑥𝑠 𝑧𝑠 macht und wie wir das mit 𝑟𝑒𝑣 ausdrücken können, nämlich: 𝑞𝑟𝑒𝑣 𝑥𝑠 𝑦𝑠 = 𝑟𝑒𝑣 𝑥𝑠 + + 𝑧𝑠 So und wir wollten das für ein allgemeines 𝑦𝑠 beweisen (deshalb ja auch der ganze Aufriss), also schreiben wir: 𝑃 ∶= ∀𝑦𝑠 ∷ [𝑎] . 𝑞𝑟𝑒𝑣 𝑥𝑠 𝑧𝑠 = 𝑟𝑒𝑣 𝑥𝑠 + + 𝑧𝑠 Und dieses Prädikat beweisen wir nun nach gewohntem Schema. Wichtig: Jetzt haben wir ein „forall“ in unserem Prädikat. Wie drücken wir das in CYP aus? Mit dem Wörtchen „generalizing“, also so: \"Proof by induction on List xs generalizing zs“. Der fertige Proof sieht dann so aus: Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Hier noch ein weiteres, vergleichbar einfaches Beispiel zur Übung: Ein paar foldr-Übungen: Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Higher-Order-Programming in Haskell: Vorneweg ein neues Mantra (nach „Implication associates to the right”): \"Function Application associates to the left.” Bis jetzt haben wir immer so getan, als würden unsere Funktionen mehrere Argumente nehmen können, bspw. 𝑠𝑢𝑚 𝑎 𝑏 = 𝑎 + 𝑏 – eine Funktion, die scheinbar die beiden Argumente 𝑎, 𝑏 nimmt und deren Summe zurückgibt. Tatsächlich gibt es das in Haskell aber nicht: Jede Funktion kann höchstens ein Argument entgegennehmen. Aber wie funktioniert dann 𝑠𝑢𝑚 𝑎 𝑏 = 𝑎 + 𝑏? 𝑠𝑢𝑚 𝑎 𝑏 = (𝑠𝑢𝑚 𝑎) 𝑏 − gem. Assoc. von Func. Application Das bedeutet folgendes: Wenn wir bspw. 𝑠𝑢𝑚 2 4 schreiben, wird erst die Funktion (𝑠𝑢𝑚 2) erstellt, die den Parameter 2 entgegennimmt und eine Funktion zurückgibt, die ein Argument nimmt und dieses mit 2 addiert, also eigentlich ist 𝑠𝑢𝑚 2 = (2 + __). Also wird die Funktion 𝑠𝑢𝑚 2 zurückgegeben, die ein Argument nimmt und dieses mit 2 addiert, und da wir als „zweites“ Argument 4 gegeben haben, steht da also: (𝑠𝑢𝑚 2) 4, also übergeben wir der Funktion \"𝑠𝑢𝑚 2\" nun die 4 und wir wissen: (𝑠𝑢𝑚 2) 4 = 6. Falls das nun noch unintuitiv ist, kann man es sich auch folgendermassen denken: (𝑠𝑢𝑚 2) ist wie eine ganz neue Funktion, nennen/definieren wir sie 𝑎𝑑𝑑𝑤𝑖𝑡ℎ𝑇𝑤𝑜 𝑥 = 2 + 𝑥. Wenn wir nun 𝑎𝑑𝑑𝑤𝑖𝑡ℎ𝑇𝑤𝑜 4 schreiben, sehen wir direkt, was das Ergebnis ist (6). Und das passiert auch, wenn wir eine Funktion schreiben, die (logisch betrachtet) mehrere Argumente nimmt: Die Funktion „schluckt“ das erste Argument und gibt dann eine neue Funktion zurück. Diese neue Funktion hat keinen Namen und wir schreiben sie bspw. bei 𝑎𝑑𝑑 𝑎 𝑏 einfach als (𝑎𝑑𝑑 2) 𝑏 = 2 + 𝑏, aber theoretisch könnten wir ihr auch einen Namen geben (wie vorhin mit addwithTwo). Gucken wir uns mal den type von 𝑠𝑢𝑚 an: (𝑁𝑢𝑚 𝑎) ⇒ 𝑎 → 𝑎 → 𝑎 Nun gilt für diesen Pfeil bei types die gleiche Assoziativität wie bei Implikationen, also steht da: (𝑁𝑢𝑚 𝑎) ⇒ 𝑎 → (𝑎 → 𝑎) Und das passt zu unserer neuen Erklärung: 𝑠𝑢𝑚 ist also eine Funktion, die ein Argument vom Typen 𝑎 (wobei 𝑎 ein Numerischer Typ ist) entgegennimmt und eine Funktion zurückgibt (Erinnere dich: Funktionen in Haskell dürfen auch Funktionen zurückgeben), die ein weiteres Argument vom Typen 𝑎 entgegennimmt und ein Return-Value vom Typen 𝑎 zurückgibt. Wozu das Ganze nun? Wir können Funktionen absichtlich mit weniger Parametern aufrufen, um keine „fertigen“ Ergebnisse zu erhalten, sondern Funktionen zurückzuerhalten, wie vorhin bei addWithTwo. Zeit für ein Beispiel (aus learnyouahaskell.com): (weiter auf der nächsten Seite →) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Der einzige Weg, wie wir in Haskell wirklich zwei oder mehrere Argumente „auf einmal“ übergeben können, ist, indem wir sie als Tupel übergeben: 𝑠𝑢𝑚 (𝑎, 𝑏) = 𝑎 + 𝑏 Um damit besser arbeiten zu können, gibt es in der Prelude die Funktion curry und uncurry: So und jetzt verstehen wir auch, wieso wir bspw. so etwas schreiben dürfen: Eigentlich braucht die Funktion „map“ ja eine Funktion und eine Liste. Aber wir wissen jetzt, dass bei zwei Argumenten eigentlich folgendes passiert: 𝑚𝑎𝑝 𝑓 𝑥𝑠 = (𝑚𝑎𝑝 𝑓) 𝑥𝑠 Das heisst eigentlich wird erst eine Funktion (𝑚𝑎𝑝 𝑓) erstellt, die eine Liste nimmt und dann eine modifizierte Liste (jedes Element mit 𝑓 „bearbeitet“) zurückgibt. Das heisst, wir können auch einfach nur (𝑚𝑎𝑝 𝑓) schreiben – und wissen, dass es sich um eine Funktion handelt, die eine Liste nimmt und eine Liste zurückgibt. Wir haben also eine eigene coole Funktion erstellt, indem wir einer anderen Funktion einfach nicht genug Argumente gegeben haben. So können wir in funktionalen Programmiersprachen sehr praktisch bereits gebaute Funktionen „anders verwenden“ indem wir quasi nur „Teile“ von ihnen verwenden. Beim obigen Beispiel mit 𝑓𝑢𝑛𝑐3 wissen wir nun, dass 𝑓𝑢𝑛𝑐3 eine Funktion ist, die eine Liste aus numerischen Werten entgegennimmt und eine Liste mit numerischen Werten zurückgibt, wobei jeder Wert mit 2 addiert wurde. Typen von Haskell Funktionen bestimmen – Grundlagen: Mit ghci können wir ganz einfach mit dem command „:t <function>“ den typ einer Funktion bestimme, bspw.: : 𝑡 (\\𝑥 𝑦 → 𝑥 + 𝑦) gibt uns: (Num a) => a -> a -> a, wie erwartet. Nun wollen wir das gleiche aber auch alleine und von Hand schaffen. Das lernen wir am Besten mit ein paar Beispielen:","libVersion":"0.5.0","langs":""}