{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w04.pdf","text":"(weiter auf der nÃ¤chsten Seite â†’) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Woche 4 â€“ Ãœbersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder VollstÃ¤ndigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne GewÃ¤hr.) Anmerkungen zu den Code-Expert Abgaben: Anmerkungen zu den Theorie Abgaben aus dem letzten Jahr: Noch einmal zur Erinnerung die Definition von fibLouis. Oft habe ich nun diesen Umformungsschritt gesehen (nÃ¤chstes Bild). Hier auch direkt die richtige LÃ¶sung: â€¢ OTP sehr schÃ¶n (spÃ¤ter im 6. Semester in InfoSec mehr dazu). â€¢ Prime Numbers auch sehr schÃ¶n gelÃ¶st (am effizientesten mit List Compr.). â€¢ Words habe ich teilweise sehr schÃ¶ne & kurze Ergebnisse gesehen. â€¢ Palindromes teilweise sehr mÃ¼hsam gelÃ¶st. So geht es am schnellsten: â€¢ Gemischte Ergebnisse bei 1a): Guckt euch alle noch einmal die MusterlÃ¶sung an, sollte dann aber selbsterklÃ¤rend sein. (Auch in diesem Jahr ein guter Hinweis ğŸ˜‰) â€¢ Einige kleinere Probleme bei 1b), die aber sehr wichtig sind: 1. Wichtig: Jede Umformung benÃ¶tigt eine BegrÃ¼ndung, egal wie trivial 2. Viele illegale Umformungen. Hier eine ErklÃ¤rung: (weiter auf der nÃ¤chsten Seite â†’) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Eine weitere Problematik ist folgende gewesen: Das waren aber beides typische AnfÃ¤ngerfehler, und ansonsten waren die Beweise sehr schÃ¶n, also macht euch keine grossen Sorgen â€“ aber achtet auf die benannten Probleme! Abschliessend kann noch erwÃ¤hnt werden, dass sich die zu beweisende Aussage ganz einfach in wenigen Zeilen direkt beweisen lÃ¤sst (ohne Induktion zu verwenden), sobald man das Hilfslemma ğ‘ğ‘¢ğ‘¥ ğ‘› = (ğ‘“ğ‘–ğ‘ğ¿ğ‘œğ‘¢ğ‘–ğ‘  ğ‘›, ğ‘“ğ‘–ğ‘ğ¿ğ‘œğ‘¢ğ‘–ğ‘  (ğ‘› + 1)) per Induktion bewiesen hat (hier geht es nicht ohne Induktion). (weiter auf der nÃ¤chsten Seite â†’) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Induktion Ã¼ber Listen in Haskell: In der letzten Woche haben wir Induktionsbeweise Ã¼ber natÃ¼rliche Zahlen eingefÃ¼hrt. In dieser Woche wollen wir uns mit Induktionsbeweisen Ã¼ber Listen in Haskell beschÃ¤ftigen. Von der grundlegenden Idee sind diese sehr Ã¤hnlich, allerdings gibt es einige Tricks und Fallen die man kennen und beachten muss. Diese sind: â€¢ Man muss die richtige Induktionsvariable auswÃ¤hlen â€¢ Man muss hÃ¤ufig erst ein Hilfslemma aufstellen â€¢ Man muss hÃ¤ufig â€generalisierenâ€œ Das gucken wir uns gleich anhand eines Beispiels genauer an. ZunÃ¤chst die allgemeine Syntax fÃ¼r Induktionsbeweise, dieses Mal im CYP-Style: Ganz wichtig, eure PrÃ¤dikate, die an die â€grÃ¼nenâ€œ Stellen kommen, dÃ¼rfen keinâ€œ=â€œ enthalten, sondern: â€.=.â€œ (kp warum ehrlich gesagt). Hier ein Beispiel mit der korrekten Syntax aus der Ãœbungsstunde (zu finden auch auf CodeExpert, Demoaufgaben CYP): (weiter auf der nÃ¤chsten Seite â†’) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Nun wollen wir uns ein Beispiel ansehen, anhand dessen wir erkennen, wieso wir die oben genannten Tricks benÃ¶tigen. DafÃ¼r definieren wir zunÃ¤chst folgende Haskell-Funktionen: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Wir wollen nun folgendes beweisen: âˆ€ğ‘¥ğ‘  âˆ· [ğ‘] . rev xs = qrev xs [] Wir verwenden dafÃ¼r zunÃ¤chst unseren allgemeinen Ansatz: Wir kommen mit diesem Proof nicht weiter. Egal von welcher Seite wir versuchen, den Step-Case zu beweisen, haben wir keine Chance, den Beweis fortzusetzen, weil uns die Definitionen/Regeln fehlen. Genauer: Wir kÃ¶nnen âˆ€ğ‘¥ âˆ· ğ‘ . âˆ€ğ‘¥ğ‘  âˆ· [ğ‘] . ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  + + [ğ‘¥] = ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  [ğ‘¥] nicht beweisen. Nun zu dem Trick (bzw. wie ich bei so einer Aufgabe vorgehen wÃ¼rde): Ich versuche mir immer erst einmal die Induktion (insbesondere den Step-Case) einmal im Kopf durchzudenken und zu Ã¼berlegen, an welchem Punkt ich an ein Problem kommen kÃ¶nnte. Hier ist das Problem offensichtlich, dass ich ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  + + [ğ‘¥] = ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  [ğ‘¥] nicht beweisen kann. Also verwende ich folgenden Trick: Ich Ã¼berlege mir ein â€Extra-Lemmaâ€œ, dass sich beweisen lÃ¤sst, und beweise es extern: Hier wollen wir ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  + + [ğ‘¥] = ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  [ğ‘¥] zeigen kÃ¶nnen, das kÃ¶nnen wir als Extra (oder Hilfs-) Lemma definieren: âˆ€ğ‘¥ğ‘  âˆ· [ğ‘] . âˆ€ğ‘§ğ‘  âˆ· [ğ‘] . ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  + + ğ‘§ğ‘  = ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  ğ‘§ğ‘  Um so ein Hilfs-Lemma aufzustellen, hilft es, sich immer anzugucken, woran der â€naiveâ€œ Approach scheitert und wie genau die Funktionen, die man in seinem Beweis benutzt, Ã¼berhaupt funktioniert. Ich gebe jetzt hier einen ganz inoffiziellen Tipp, der aber so gut wie immer hinkommt: Wenn eine Funktion, die ihr in eurem PrÃ¤dikat P benutzt fÃ¼r allgemeine Listen definiert ist, z.B. hier ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  ğ‘§ğ‘ , ihr in eurem PrÃ¤dikat aber eine der beiden Listen durch die leere Liste (oder bspw. bei natÃ¼rlichen Zahlen eine Funktion ğ‘“ ğ‘› ğ‘˜ = â‹¯ im PrÃ¤dikat durch ğ‘“ ğ‘› 0 ersetzt wird) oder ein anderes â€spezifisches Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Objektâ€œ ersetzt wird, funktioniert der naive Approach nicht und ihr mÃ¼sst euch ein Hilfslemma Ã¼berlegen, bei dem im PrÃ¤dikat das â€spezifische Objektâ€œ generalisiert wird, also fÃ¼r eine beliebige Liste oder eine beliebige natÃ¼rliche Zahl gilt. Dabei geht man so vor, dass man in seinem PrÃ¤dikat das â€spezifische Objektâ€œ durch den allgemeinen Typen ersetzt (also hier in unserem Beispiel ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  [] durch ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  ğ‘§ğ‘  fÃ¼r ein allg. ğ‘§ğ‘  ersetzt und sich Ã¼berlegt, wie man die â€andere Seiteâ€œ der Gleichung im PrÃ¤dikat anpassen muss: DafÃ¼r guckt man sich am besten die Funktionen an und Ã¼berlegt, was genau diese machen. Konkret hier in diesem Beispiel: ğ‘ğ‘Ÿğ‘’ğ‘£ nimmt sich (so lange mÃ¶glich), das je erste Element vom ersten Argument, der ersten Liste ğ‘¥ğ‘  und hÃ¤ngt es vorne an das zweite Argument, die Liste ğ‘§ğ‘  an. Dabei wird natÃ¼rlich die Liste ğ‘¥ğ‘  â€reversedâ€œ vorne an ğ‘¦ğ‘  rangehÃ¤ngt, also macht ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  ğ‘§ğ‘  eigentlich folgendes: ğ‘£ğ‘œğ‘Ÿğ‘›ğ‘’_ğ‘Ÿğ‘ğ‘›â„Ã¤ğ‘›ğ‘”ğ‘’ğ‘›(ğ‘Ÿğ‘’ğ‘£ğ‘’ğ‘Ÿğ‘ ğ‘’ğ‘‘(ğ‘¥ğ‘ ), ğ‘§ğ‘ ) und â€“ naja, das ist jetzt bestimmt klar â€“ ğ‘Ÿğ‘’ğ‘£ reversed einfach eine beliebige Liste ğ‘¥ğ‘ , also kÃ¶nnen wir â€ğ‘£ğ‘œğ‘Ÿğ‘›ğ‘’_ğ‘Ÿğ‘ğ‘›â„Ã¤ğ‘›ğ‘”ğ‘’ğ‘›(ğ‘Ÿğ‘’ğ‘£ğ‘’ğ‘Ÿğ‘ ğ‘’ğ‘‘(ğ‘¥ğ‘ ), ğ‘§ğ‘ )â€œ auch folgendermassen mit ğ‘Ÿğ‘’ğ‘£ ausdrÃ¼cken: ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  + + ğ‘§ğ‘ , denn aus meiner ersten Ãœbungsstunde wissen wir, dass â€xs ++ zsâ€œ einfach xs â€vorne an zs ranhÃ¤ngtâ€œ (oder wie der Profi sagt: â€diE liStEn xs uNd ys kOnKatTiNieRtâ€œ). Also wissen wir, was ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  ğ‘§ğ‘  macht und wie wir das mit ğ‘Ÿğ‘’ğ‘£ ausdrÃ¼cken kÃ¶nnen, nÃ¤mlich: ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  ğ‘¦ğ‘  = ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  + + ğ‘§ğ‘  So und wir wollten das fÃ¼r ein allgemeines ğ‘¦ğ‘  beweisen (deshalb ja auch der ganze Aufriss), also schreiben wir: ğ‘ƒ âˆ¶= âˆ€ğ‘¦ğ‘  âˆ· [ğ‘] . ğ‘ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  ğ‘§ğ‘  = ğ‘Ÿğ‘’ğ‘£ ğ‘¥ğ‘  + + ğ‘§ğ‘  Und dieses PrÃ¤dikat beweisen wir nun nach gewohntem Schema. Wichtig: Jetzt haben wir ein â€forallâ€œ in unserem PrÃ¤dikat. Wie drÃ¼cken wir das in CYP aus? Mit dem WÃ¶rtchen â€generalizingâ€œ, also so: \"Proof by induction on List xs generalizing zsâ€œ. Der fertige Proof sieht dann so aus: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Hier noch ein weiteres, vergleichbar einfaches Beispiel zur Ãœbung: Ein paar foldr-Ãœbungen: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Higher-Order-Programming in Haskell: Vorneweg ein neues Mantra (nach â€Implication associates to the rightâ€): \"Function Application associates to the left.â€ Bis jetzt haben wir immer so getan, als wÃ¼rden unsere Funktionen mehrere Argumente nehmen kÃ¶nnen, bspw. ğ‘ ğ‘¢ğ‘š ğ‘ ğ‘ = ğ‘ + ğ‘ â€“ eine Funktion, die scheinbar die beiden Argumente ğ‘, ğ‘ nimmt und deren Summe zurÃ¼ckgibt. TatsÃ¤chlich gibt es das in Haskell aber nicht: Jede Funktion kann hÃ¶chstens ein Argument entgegennehmen. Aber wie funktioniert dann ğ‘ ğ‘¢ğ‘š ğ‘ ğ‘ = ğ‘ + ğ‘? ğ‘ ğ‘¢ğ‘š ğ‘ ğ‘ = (ğ‘ ğ‘¢ğ‘š ğ‘) ğ‘ âˆ’ gem. Assoc. von Func. Application Das bedeutet folgendes: Wenn wir bspw. ğ‘ ğ‘¢ğ‘š 2 4 schreiben, wird erst die Funktion (ğ‘ ğ‘¢ğ‘š 2) erstellt, die den Parameter 2 entgegennimmt und eine Funktion zurÃ¼ckgibt, die ein Argument nimmt und dieses mit 2 addiert, also eigentlich ist ğ‘ ğ‘¢ğ‘š 2 = (2 + __). Also wird die Funktion ğ‘ ğ‘¢ğ‘š 2 zurÃ¼ckgegeben, die ein Argument nimmt und dieses mit 2 addiert, und da wir als â€zweitesâ€œ Argument 4 gegeben haben, steht da also: (ğ‘ ğ‘¢ğ‘š 2) 4, also Ã¼bergeben wir der Funktion \"ğ‘ ğ‘¢ğ‘š 2\" nun die 4 und wir wissen: (ğ‘ ğ‘¢ğ‘š 2) 4 = 6. Falls das nun noch unintuitiv ist, kann man es sich auch folgendermassen denken: (ğ‘ ğ‘¢ğ‘š 2) ist wie eine ganz neue Funktion, nennen/definieren wir sie ğ‘ğ‘‘ğ‘‘ğ‘¤ğ‘–ğ‘¡â„ğ‘‡ğ‘¤ğ‘œ ğ‘¥ = 2 + ğ‘¥. Wenn wir nun ğ‘ğ‘‘ğ‘‘ğ‘¤ğ‘–ğ‘¡â„ğ‘‡ğ‘¤ğ‘œ 4 schreiben, sehen wir direkt, was das Ergebnis ist (6). Und das passiert auch, wenn wir eine Funktion schreiben, die (logisch betrachtet) mehrere Argumente nimmt: Die Funktion â€schlucktâ€œ das erste Argument und gibt dann eine neue Funktion zurÃ¼ck. Diese neue Funktion hat keinen Namen und wir schreiben sie bspw. bei ğ‘ğ‘‘ğ‘‘ ğ‘ ğ‘ einfach als (ğ‘ğ‘‘ğ‘‘ 2) ğ‘ = 2 + ğ‘, aber theoretisch kÃ¶nnten wir ihr auch einen Namen geben (wie vorhin mit addwithTwo). Gucken wir uns mal den type von ğ‘ ğ‘¢ğ‘š an: (ğ‘ğ‘¢ğ‘š ğ‘) â‡’ ğ‘ â†’ ğ‘ â†’ ğ‘ Nun gilt fÃ¼r diesen Pfeil bei types die gleiche AssoziativitÃ¤t wie bei Implikationen, also steht da: (ğ‘ğ‘¢ğ‘š ğ‘) â‡’ ğ‘ â†’ (ğ‘ â†’ ğ‘) Und das passt zu unserer neuen ErklÃ¤rung: ğ‘ ğ‘¢ğ‘š ist also eine Funktion, die ein Argument vom Typen ğ‘ (wobei ğ‘ ein Numerischer Typ ist) entgegennimmt und eine Funktion zurÃ¼ckgibt (Erinnere dich: Funktionen in Haskell dÃ¼rfen auch Funktionen zurÃ¼ckgeben), die ein weiteres Argument vom Typen ğ‘ entgegennimmt und ein Return-Value vom Typen ğ‘ zurÃ¼ckgibt. Wozu das Ganze nun? Wir kÃ¶nnen Funktionen absichtlich mit weniger Parametern aufrufen, um keine â€fertigenâ€œ Ergebnisse zu erhalten, sondern Funktionen zurÃ¼ckzuerhalten, wie vorhin bei addWithTwo. Zeit fÃ¼r ein Beispiel (aus learnyouahaskell.com): (weiter auf der nÃ¤chsten Seite â†’) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Der einzige Weg, wie wir in Haskell wirklich zwei oder mehrere Argumente â€auf einmalâ€œ Ã¼bergeben kÃ¶nnen, ist, indem wir sie als Tupel Ã¼bergeben: ğ‘ ğ‘¢ğ‘š (ğ‘, ğ‘) = ğ‘ + ğ‘ Um damit besser arbeiten zu kÃ¶nnen, gibt es in der Prelude die Funktion curry und uncurry: So und jetzt verstehen wir auch, wieso wir bspw. so etwas schreiben dÃ¼rfen: Eigentlich braucht die Funktion â€mapâ€œ ja eine Funktion und eine Liste. Aber wir wissen jetzt, dass bei zwei Argumenten eigentlich folgendes passiert: ğ‘šğ‘ğ‘ ğ‘“ ğ‘¥ğ‘  = (ğ‘šğ‘ğ‘ ğ‘“) ğ‘¥ğ‘  Das heisst eigentlich wird erst eine Funktion (ğ‘šğ‘ğ‘ ğ‘“) erstellt, die eine Liste nimmt und dann eine modifizierte Liste (jedes Element mit ğ‘“ â€bearbeitetâ€œ) zurÃ¼ckgibt. Das heisst, wir kÃ¶nnen auch einfach nur (ğ‘šğ‘ğ‘ ğ‘“) schreiben â€“ und wissen, dass es sich um eine Funktion handelt, die eine Liste nimmt und eine Liste zurÃ¼ckgibt. Wir haben also eine eigene coole Funktion erstellt, indem wir einer anderen Funktion einfach nicht genug Argumente gegeben haben. So kÃ¶nnen wir in funktionalen Programmiersprachen sehr praktisch bereits gebaute Funktionen â€anders verwendenâ€œ indem wir quasi nur â€Teileâ€œ von ihnen verwenden. Beim obigen Beispiel mit ğ‘“ğ‘¢ğ‘›ğ‘3 wissen wir nun, dass ğ‘“ğ‘¢ğ‘›ğ‘3 eine Funktion ist, die eine Liste aus numerischen Werten entgegennimmt und eine Liste mit numerischen Werten zurÃ¼ckgibt, wobei jeder Wert mit 2 addiert wurde. Typen von Haskell Funktionen bestimmen â€“ Grundlagen: Mit ghci kÃ¶nnen wir ganz einfach mit dem command â€:t <function>â€œ den typ einer Funktion bestimme, bspw.: : ğ‘¡ (\\ğ‘¥ ğ‘¦ â†’ ğ‘¥ + ğ‘¦) gibt uns: (Num a) => a -> a -> a, wie erwartet. Nun wollen wir das gleiche aber auch alleine und von Hand schaffen. Das lernen wir am Besten mit ein paar Beispielen:","libVersion":"0.5.0","langs":""}