{"path":"sem3/TIN/UE/c/TI-c-u02.pdf","text":"Basil Feitknecht, 23-922-099 Camil Schmid, 23-944-234 Dennis Küenzi, 21-559-315 4 (a) First, we construct a program, that takes n as input and prints wn. The only variable part of this program is n, the rest can be represented by a constant c. The binary lenght of this program can then be upperbounded by ⌊log2(n)⌋ + 1  +  c The Kolmogorov complexity in respect to n can then be upperbounded. We use c′ since simplifying can slightly change the constant. To express this with respect to wn we ﬁrst have to calculate the lenght of wn. Now we solve for n. Replacing n in (1) and simplifying yields our ﬁnal result. □ be\u0000in M := n; M \u0000\u0000 4 \u0000 \u0000M ^ 2\u0000; for i = 1 t\u0000 100_000 w\u0000i\u0000e(0); for i = 1 t\u0000 M w\u0000i\u0000e(0101\u0000; end 1 2 3 4 5 6 7 8 9 K(wn) ≤ log2(n) + c′ (1) |wn| = |0| ⋅ 100′000 + |0101| ⋅ 4n2 = 100′000 + 16n2 n = √ |wn| − 100′000 16 = √|wn| − 100′000 4 K(wn) ≤ log2 ( 2√|wn| − 100′000 4 ) + c′ ≤ log2 log2 |wn| + c′′ (b) Let's deﬁne the sequence y0 < y1 < y2 < … with yi = 03i for all i ∈ N. Since |yi| < |yi+1|, the required order follows. We have i = log3(|yi|) for some  i ≥ 0. We show a program, that takes i as an input and prints yi: The only variable part of this program is i, everything else is of constant length. Accordingly, the length of the program can be upper bounded for a constant c′ by ⌊log2(i)⌋ + 1 + c′. Thus follows, for some constant c. □ be\u0000in M := i; M \u0000\u0000 3 ^ M; for I \u0000 0 t\u0000 M; w\u0000i\u0000e(0); end 1 2 3 4 5 6 K(yi) ≤ log2(i) + c ≤ log2 log3(|yi|) + c 5 Let L = {{0, 1}n ∣ n ∈ N}. For the sake of contradiction, lets' assume that less than 99% of words w ∈ L fulﬁll K(w) > n − 8. Since every word in L is unique, it has to have a unique program generating it. There are |L| = 2n unique words of lenght n and ∑n−8 i=0 2i = 2n−7 − 1 unique programs. The total number of words minus the number of words that fulﬁll the assumed requirement divided by the total number of words, yields the ratio of words that fulﬁll the requirement to the total amount of words. The ratio between words fulﬁlling the requirement K(w) and all existing programs is more than 99%, thus we arrive at a contradiction which proves the statement. □ 2n − 2n−7 2n = 1 − 20 27 = 1 − 1 128 = 127 128 ! > 99 100 6 For the sake of contradiction, let's assume there exists some program P that takes any arbitrary number n ∈ N and prints a bitstring w ∈ {0, 1}n, where KP (w) > n − 8 denotes the kolmogorov complexity of w generated with P . We deﬁne another program, Q, which takes as input some n ∈ N and returns the word w that P (n) generates. The kolmogorov complexity of the generated word w with Q is denoted by KQ(w) = ⌊log2(n)⌋ + 1 + c = ⌊log2(n)⌋ + c′. This follows from the fact that we only need to encode the variable part n in binary, plus some constant c independent of the input size n, which denotes the encoding length of the invariable part of Q. Per our initial assumption, the two complexities must be equal, i.e. KP (w) = KQ(w), since the kolmogorov complexity of w is deﬁned as the length of the shortest program generating it and we assume that the length of this shortest program is greater than n − 8. This leaves us with the inequality, that some constant c′′ (independent from n) must be greater than n − ⌊log2(n)⌋. The RHS is unbounded, since the asymptotic growth of a linear function dominates the logarithmic growth, however the LHS is constant. This results in a contradiction, as c′′ ! > ∞ is impossible and thus there exists no such program P . □ be\u0000in x := n; P(x); end 1 2 3 4 KP (w) > n − 8 (substitute complexity) KQ(w) > n − 8 (definition of KQ) ⌊log2(n)⌋ + c′ > n − 8 (absorb additive constants) ⌊log2(n)⌋ + c′′ > n (rearrange terms) c′′ > n − ⌊log2(n)⌋","libVersion":"0.3.2","langs":""}