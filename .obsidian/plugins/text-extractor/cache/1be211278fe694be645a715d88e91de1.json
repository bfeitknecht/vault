{"path":"sem2/PProg/PV/exams/PProg-HS20-exam.pdf","text":"Vor und Nachname (Druckbuchstaben): Legi Nummer: 252-0029-00L Parallele Programmierung ETH/CS: FS 2020 Semesterpr¨ufung Mittwoch, 19.08.2020 120 Minuten Diese Pr¨ufung enth¨alt 28 Seiten (inklusive Deckblatt) und 13 Aufgaben. ¨Uberpr¨ufen Sie nach Beginn der Pr¨ufung, dass keine Seiten fehlen. Schreiben Sie die Legi-Nummer oben auf jede einzelne Seite. Sie haben 120 Minuten Zeit f¨ur die L¨osung der Pr¨ufung. Falls Sie sich durch irgendjemanden oder irgendetwas gest¨ort f¨uhlen, melden Sie dies einer Auf- sichtsperson. Wir sammeln die Pr¨ufung zum Schluss ein, stellen Sie sicher, dass Ihre Pr¨ufung von einem Assistenten eingezogen wird. Wenn Sie fr¨uher abgeben wollen melden Sie sich und wir holen die Pr¨ufung ab. Vorzeitige Abgaben sind nur bis 15 Minuten vor Pr¨ufungsende m¨oglich. Wenn Sie zur Toilette m¨ussen, melden Sie dies einer Aufsichtsperson durch Handzeichen. Es darf zur gleichen Zeit immer nur eine Person zur Toilette. ‹ L¨osungen m¨ussen lesbar sein. L¨osungen mit unklarer Reihenfolge oder anderweitig un- verst¨andlicher Pr¨asentation k¨onnen zu Punktabz¨ugen f¨uhren. Verwenden Sie keinen Blei- stift und keine rot oder orange-farbenen Stifte. ‹ Falls mehr Platz ben¨otigt wird, schreiben Sie auf die leeren Seiten am Ende der Pr¨ufungsunterlagen. Versehen Sie die Aufgabe mit einem klaren Hinweis, falls das der Fall ist. ‹ Multiple-choice Fragen werden minimal mit 0 Punkten bewertet, es werden keine negativen Punkte erteilt. ‹ Die Aufgabenstellungen sind in Deutsch und Englisch gegeben. Die Aufgaben k¨onnen auf Deutsch oder Englisch beantwortet werden. ‹ Legen Sie ihre ETH Karte zur Identit¨ats¨uberpr¨ufung gut sichtbar vor sich auf den Tisch. ‹ In dieser Pr¨ufung sind keine Hilfsmittel oder mitgebrachte Unterlagen erlaubt, ausser ein W¨orterbuch f¨ur fremdsprachige Studierende. Insbesondere alle kommunikationsf¨ahigen, pro- grammierbaren und/oder speicherf¨ahigen Ger¨ate wie bspw. Smartphones, Smartwatches, etc. sind nicht erlaubt. Bei unehrlichem Handeln gelten die Strafnormen der Disziplinarordnung der ETH. ‹ Eine pl¨otzlich auftretende Erkrankung muss bei der Pr¨ufungsaufsicht explizit angezeigt wer- den — ebenso zwingend erforderlich ist eine Mitteilung, die Pr¨ufung aus medizinischen Gr¨unden nicht beenden zu k¨onnen. Studierende mit Fieber, Husten, Atemnot, Verlust des Geschmacksinns, Muskelschmerzen d¨urfen nicht an der Pr¨ufung teilnehmen. Die Pr¨ufungsaufsicht ist befugt, Studierende, die oﬀensichtliche Krankheitssym- ptome zeigen, aus der Pr¨ufung zu weisen. Question: 1 2 3 4 5 6 7 8 9 10 11 12 13 Total Points: 5 7 11 6 4 13 14 16 16 5 7 8 8 120 Score: Parallele Programmierung - Semesterpr¨ufung - Seite 2 von 28 Mittwoch, 19.08.2020 Diese Seite ist absichtlich leer. This page is intentionally left blank. Parallele Programmierung - Semesterpr¨ufung - Seite 3 von 28 Mittwoch, 19.08.2020 Speedup, Amdahl, Gustafson (12 points) 1. (5)Nehmen Sie an ein Programm besteht zu 20% aus nicht-parallelisierbarer Arbeit. Wir wollen einen Speedup von 4 gem¨ass Gustafson’s Ge- setz erlangen. Wie viele Prozessoren sind not- wendig? Geben Sie alle Rechenschritte an. Assume a program consisting of 20% non- parallelizable work. We want to achieve a speed up of 4 according to Gustafson’s law. How many processors are necessary? Show all calculation steps. 2. (7)Nehmen Sie an ein Programm besteht zu 50% aus nicht-parallelisierbarer Arbeit und die Gesamtmenge der Arbeit ist konstant. Wir m¨ochten mit einem ﬁxen Budget einen von zwei Computern kaufen um das Programm aus- zuf¨uhren: ‹ A: 2 Prozessoren, Taktfrequenz 3 GHz. ‹ B: 5 Prozessoren, Taktfrequenz 2 GHz. Angenommen der aktuelle Computer hat einen Prozessor mit einer Taktfrequenz von 1 GHz. ‹ Berechnen Sie den Speedup, wenn das Programm auf A ausgef¨uhrt wird. ‹ Berechnen Sie den Speedup, wenn das Programm auf B ausgef¨uhrt wird. ‹ Auf welchem Computer wird das Pro- gramm schneller sein? Begr¨unden Sie ihre Antwort und geben Sie alle Rechenschritte an. Assume we have a program consisting of 50% of non-parallelizable work and that the total amount of work is ﬁxed. We are given a ﬁxed budget to buy one of the fol- lowing two machines to run the program: ‹ A: 2 processors, frequency 3 GHz. ‹ B: 5 processors, frequency 2 GHz. Assuming that the current machine has 1 processor running at frequency 1 GHz: ‹ compute the speedup of executing the program on machine A. ‹ compute the speedup of executing the program on machine B. ‹ Which machine will run the program faster? Justify your answer and show all calcula- tion steps. Parallele Programmierung - Semesterpr¨ufung - Seite 4 von 28 Mittwoch, 19.08.2020 Pipelining (17 points) 3. Vier Konditoren in einer B¨ackerei teilen vier Arbeitsger¨ate miteinander. Um eine Schach- tel Brownies herzustellen ben¨otigt jeder die Ger¨ate in folgender Reihenfolge: Die Mikrowel- le (“microwave”), den Mixer (“blender”), den Ofen (“oven”) und das Schneidebrett (“cutting board”). Nehmen Sie f¨ur alle nachfolgen- den Fragen an, dass vier Konditoren je eine Schachtel Brownies herstellen. Four pastry chefs in a bakery share four ap- pliances with each other. Preparing a box of brownies requires everyone to use the appliances in the following order: the mi- crowave, the blender, the oven, and ﬁnally the cutting board. For all the questions below, assume there are four chefs, each making one box of brownies. i) microwave 5 min blender 5 min oven 10 min cutting board 5 min ii) microwave 5 min blender 5 min oven 10 min cutting board 10 min iii) microwave 15 min blender 5 min oven 5 min cutting board 10 min (a) (3)Was ist der Durchsatz (“throughput”) der einzelnen Pipelines? What is the throughput of each pipeline? i) ii) iii) (b) (4)Welche Pipeline sollte verwendet werden, wenn das Ziel ist vier Schachteln Brownies (eine von jedem Konditor) so schnell wie m¨oglich herzustellen? Zeigen Sie alle Rech- nenschritte. Which pipeline should be used if the goal is to prepare four boxes of brownies (one by each chef) as fast as possible? Show all the calculation steps. (c) (4)F¨ur Pipeline iii): Was ist der Speedup vergli- chen mit der streng sequentiellen Reihenfolge (d.h. wenn jeder Konditor erst anf¨angt, wenn der Andere mit dem Schneidebrett fertig ist)? Zeigen Sie alle Rechenschritte. Consider pipeline iii). What is the pipeline speedup compared to the strictly sequential order (that is, one chef starting only after the other has ﬁnished using the cutting board)? Show all the calculation steps. Parallele Programmierung - Semesterpr¨ufung - Seite 5 von 28 Mittwoch, 19.08.2020 4. Betrachten Sie die unten abgebildete Metho- de mulVectors. Nehmen Sie an, dass Multi- plikation eine Latenz von 6 Prozessorzy- klen (cycles) hat. Das heisst, der Prozessor ben¨otigt 6 Zyklen um eine einzelene Multipli- kation zu beenden. Betrachten Sie nur mathe- matische Operationen innerhalb der Schleife (also in diesm Fall a[i] * b[i]) und ignorieren Sie alle anderen Operation (z.B. das Speichern des Resultates, das Erh¨ohen der Laufvariable, und das Testen der Abbruchbedingung). Consider the method mulVectors shown below. Assume that multiplication has a latency of 6 cycles. That is, the proces- sor needs 6 cycles to ﬁnish a single multipli- cation. Further, consider only arithmetic operations performed in the loop body (i.e., in this case a[i] * b[i]) and ignore all the other operations (e.g, storing the re- sult, incrementing the loop counter, evalu- ating the loop termination condition). public void mulVectors(int[] a, int[] b) { for (int i = 0; i < 30; i++) { a[i] = a[i] * b[i]; } } (a) (3)Berechnen Sie, wie viele Zyklen der Prozessor ben¨otigt um die Schleife auszuf¨uhren, wenn kein “instruction level parallelism” verwen- det wird. Assuming instruction level parallelism is not used, calculate how many cycles the processor needs to execute the loop. (b) (3)Angenommen der Prozessor startet in je- dem Zyklus eine neue Multiplikation und der Compiler kann die Schleife so optimie- ren, dass Piplelining voll ausgenutzt wird. Berechnen Sie, wie viele Zyklen der Prozes- sor ben¨otigt um die optimierte Schleife aus- zuf¨uhren. Assume that the processor can in each cycle start executing a new multiplica- tion instruction. Assuming the compiler optimizes the loop to take full advantage of pipelining, calculate how many cycles the processor needs to execute the opti- mized loop. Parallele Programmierung - Semesterpr¨ufung - Seite 6 von 28 Mittwoch, 19.08.2020 Threads (4 points) 5. Kreuzen Sie alle korrekten Aussagen an. Check all correct statements. (a) (2)F¨ur einen Thread t = new Thread();, was ist der Unterschied zwischen den Aufrufen t.run() und t.start()? For a given thread t = new Thread();, what is the diﬀerence between calling t.run() and t.start()? ⃝ Beide werden die override void run() Methode ausf¨uhren. Both will result in executing the override void run() method. ⃝ Beide, t.run() und t.start(), k¨onnen mehrmals aufgerufen werden. Both t.run() and t.start() can be called multiple times. ⃝ t.start() sollte bevorzugt werden, da es immer zu einer schnelleren Ausf¨uhrung f¨uhrt. Using t.start() is preferred as it al- ways leads to faster execution. ⃝ t.start() kann nur auf einem Computer mit mehreren Prozessoren aufgerufen wer- den. t.start() can be called only on a com- puter with multiple processors. (b) (2)Kreuzen Sie alle korrekten Aussagen ¨uber das Joinen von mehrereren Java Threads an. Check all correct statements regarding joining multiple Java Threads. ⃝ Threads sollten immer in der umgekehrten Reihenfolge gejoint werden in der sie erstellt wurden. Threads should always be joined in the reverse order they were created. ⃝ Threads sollten immer in der gleichen Rei- henfolge gejoint werden in der sie erstellt wurden. Threads should always be joined in the same order as they were created. ⃝ Die Reihenfolge in der Threads gejoint wer- den ist wichtig um Data Races zu vermei- den. The order of joining Threads is impor- tant to avoid data races. ⃝ Die Reihenfolge in der Threads gejoint wer- den ist wichtig um Deadlocks zu vermeiden. The order of joining Threads is impor- tant to avoid deadlocks. Parallele Programmierung - Semesterpr¨ufung - Seite 7 von 28 Mittwoch, 19.08.2020 Wait/Notify (13 points) 6. Ein beliebter Foodtruck bedient die Kunden einzeln nacheinander in der Reihenfolge, in der sie ankommen. Da der Foodtruck von einer einzigen Person betrieben wird, kann nur ei- ne Mahlzeit gleichzeitig gekocht werden. Der Foodtruck und die Kunden werden als Threads modelliert. A popular food truck serves customers one at a time, in the order they arrive. How- ever, because the food truck is operated by a single person, only one meal can be pre- pared at a time. Both the food truck and each customer are modeled as threads. (a) (13)Vervollst¨andigen Sie das folgende Code- Skelett gem¨ass der Beschreibung in den Kommentaren. Ihre L¨osung sollte notify(), notifyAll(), wait() und das synchronized-Schl¨usselwort verwenden um das Programm korrekt zu synchronisieren, aber Sie sollen keine unn¨otige Synchronisa- tion einf¨uhren. In dieser Aufgabe m¨ussen Sie Exceptions nicht behandeln. Complete the following code skeleton ac- cording to the description in the com- ments. Make sure that your solu- tion is properly synchronized by using notify(), notifyAll(), wait() and the synchronized keyword where re- quired, but do not introduce unneces- sary synchronization. For this task, you do not need to handle exceptions. public class Customer extends Thread { private final FoodTruck foodTruck; public Customer(FoodTruck foodTruck) { this.foodTruck = foodTruck; } public void run() { ................................................. // Add this customer to the line /* Ein Kunde stellt sich in die Reihe */ foodTruck.addCustomer(this); ................................................. ................................................. // Wait until it is the customers turn /* Warte, bis der Kunde dran ist */ ................................................. ................................................. while(!foodTruck.isCustomersTurn(this)) { ................................................. ................................................. } ................................................. ................................................. // Customer gets served /* Kunde wird bedient */ foodTruck.serveCustomer(this); ................................................. ................................................. } } Parallele Programmierung - Semesterpr¨ufung - Seite 8 von 28 Mittwoch, 19.08.2020 public class FoodTruck extends Thread { private ArrayList<Customer> customersLine = new ArrayList<Customer>(); private boolean mealReady = false; public void run() { while (true) { ................................................. ................................................. ................................................. // wait if there are no customers or // the current meal has not been served /* warte, falls keine Kunden anstehen oder die * aktulle Mahlzeit noch nicht serviert wurde */ ................................................. ................................................. ................................................. ................................................. ................................................. ................................................. // cook food for the next customer /* Kochen der Mahlzeit f¨ur den n¨achsten Kunden */ mealReady = true; ................................................. ................................................. // notify the next customer (only the next customer) /* Benachrichtigung des n¨achsten Kunden (nur der N¨achste) */ ................................................. ................................................. ................................................. ................................................. ................................................. ................................................. } } public synchronized void addCustomer(Customer customer) { this.customersLine.add(customer); ................................................. ................................................. } public synchronized void serveCustomer(Customer customer) { if (!isCustomersTurn(customer)) { System.out.println(\"Customer is trying to cut in line!\"); ................................................. return; } removeCustomer(customer); this.mealReady = false; ................................................. Parallele Programmierung - Semesterpr¨ufung - Seite 9 von 28 Mittwoch, 19.08.2020 } private void removeCustomer(Customer customer) { for (int i = 0; i < customersLine.size(); i++) { if (customersLine.get(i).equals(customer)) { customersLine.remove(i); return; } } } public synchronized boolean isCustomersTurn(Customer customer) { if (!mealReady) { return false; } if (customersLine.isEmpty()) { return false; } return customersLine.get(0).equals(customer); } } Parallele Programmierung - Semesterpr¨ufung - Seite 10 von 28 Mittwoch, 19.08.2020 Fork/Join Framework (14 points) 7. In einer Folge von Zahlen v0, . . . , vn, wollen wir jede Zahl durch einen gleitenden Durchschnitt ersetzen. Das heisst, der Wert vi an Position i wird durch vi ← 1 3 (vi−1 + vi + vi+1) ersetzt. Nicht existierende Elemente am Anfang oder Ende werden als 0 behandelt. Hier ﬁnden Sie einige Beispiele und eine sequentielle Implemen- tierung: Given a sequence of numbers v0, . . . , vn, we want to update each number by a moving average. That is, the value vi at position i should be updated as vi ← 1 3 (vi−1 + vi + vi+1). Non-existing elements at the begin- ning and end are treated as 0. A few exam- ples and a sequential implementation are provided below: [0, 1, 2, 3] → [ 1 3 , 1, 2, 5 3 ] [0, 1, 0, 2, 1, 3, 0] → [ 1 3 , 1 3 , 1, 1, 2, 4 3 , 1] public void seqAvg(double[] data) { double left = 0; for (int i = 0; i < data.length; ++i) { double sum = left + data[i]; if (i + 1 < data.length) sum += data[i + 1]; left = data[i]; data[i] = sum / 3; } } (a) (10)Vervollst¨andigen Sie das Code-Skelett auf der n¨achsten Seite mit Hilfe des ForkJoin Fra- meworks. Ihre L¨osung muss die Berech- nung direkt auf dem Array data (in- place) vornehmen. Verwenden Sie kei- ne zus¨atzlichen Datenstrukturen (z.B. Arrays, Listen, Hashmaps, etc.). Stel- len Sie sicher, dass die Daten so auf die Sub-Tasks verteilt werden, dass alle ungef¨ahr gleich viel Arbeit haben und dass die Sub- Tasks parallel ausgef¨uhrt werden. Sie erhal- ten keine Punkte f¨ur absichtlich sequentielle L¨osungen. In dieser Aufgabe m¨ussen Sie Ex- ceptions nicht behandeln. Complete the code skeleton on the next page using the ForkJoin framework. The solution has to perform the computation in-place (i.e., directly update the data array) without us- ing any auxiliary data structures (e.g., arrays, lists, hashmaps, etc.). Make sure to split the data such that subtasks have roughly the same amount of work and to execute subtasks in par- allel. Intentionally sequential solutions will not receive any points. For this task, you do not need to handle exceptions. Parallele Programmierung - Semesterpr¨ufung - Seite 11 von 28 Mittwoch, 19.08.2020 public void fjAvg(double[] data) { ForkJoinPool fjp = new ForkJoinPool(); AvgFJ task = new AvgFJ(data, 0, data.length, ..................); fjp.invoke(task); } class AvgFJ extends .......................... { private double[] data; private int start; private int length; .......................... .......................... .......................... public AvgFJ( double[] data, int start, int length, .......................... .......................... .......................... ) { this.data = data; this.start = start; this.length = length; .......................... .......................... .......................... } protected void compute() { if (length == 1) { ................................................................. ................................................................. ................................................................. } else { ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. } } } Parallele Programmierung - Semesterpr¨ufung - Seite 12 von 28 Mittwoch, 19.08.2020 (b) (2)Kreuzen Sie alle korrekten Aussagen an. Check all correct statements. ⃝ Die Funktionen seqAvg und fjAvg in der vorhergehenden Aufgabe beschreiben eine “map”-Operation. The functions seqAvg and fjAvg in the previous task describes a map opera- tion. ⃝ Die Funktionen seqAvg und fjAvg in der vorhergehenden Aufgabe beschreiben eine “reduce”-Operation (Reduktion). The functions seqAvg and fjAvg in the previous task describes a reduce (re- duction) operation. ⃝ Das ForkJoin Framework erm¨oglicht eine Art von “task parallelism” (Aufgabenpar- allelismus) . The ForkJoin framework oﬀers a form of task parallelism. ⃝ Das ForkJoin Framework erstellt intern einen gerichteten azyklischen Graph (“di- rected acyclic graph (DAG)”) von Tasks. The ForkJoin framework internally cre- ates a directed acyclic graph (DAG) of the tasks. (c) (2)Kreuzen Sie alle korrekten Aussagen ¨uber die Java ForkJoin und ExecutorService Frame- works an. Check all correct statements about the Java ForkJoin and ExecutorService frameworks. ⃝ Beide Frameworks, ForkJoin und Executor- Service, koordienieren die Zuordnung von Tasks zu Threads. Both, ForkJoin and ExecutorService, schedule tasks to threads. ⃝ Beide Frameworks, ForkJoin und Executor- Service, unterhalten eine Liste von laufen- den Threads, die f¨ur mehrere Tasks wieder- verwendet werden. Both, ForkJoin and ExecutorService, maintain a pool of threads that is reused for multiple tasks. ⃝ ForkJoin erstellt neue Threads f¨ur jeden Task, w¨ahrend ExecutorService Threads wiederverwendet. ForkJoin creates a new thread for each task, while ExecutorService reuses threads. ⃝ ExecutorService ist besser geigenet als ForkJoin wenn es Abh¨angigkeiten zwischen Tasks gibt. ExecutorService is better suited than ForkJoin if there are dependencies be- tween tasks. Parallele Programmierung - Semesterpr¨ufung - Seite 13 von 28 Mittwoch, 19.08.2020 Locks (16 points) 8. (a) (4)Nennen Sie drei Anforderungen, die eine kor- rekete Implementierung eines Locks bzw. kri- tischen Abschnittes, erf¨ullen muss. Erkl¨aren Sie kurz die Bedeutung der genannten Begrif- fe, d.h. geben Sie eine kurze Deﬁnition an. Name three conditions a correct lock / critical section implementation must fullﬁll. Brieﬂy explain the meaning of each condition, i.e., give a short deﬁni- tion. Parallele Programmierung - Semesterpr¨ufung - Seite 14 von 28 Mittwoch, 19.08.2020 (b) (5)Zeichnen Sie ein Zustandsdiagramm um die Korrektheit / Inkorrektheit der folgenden Lock-Implementierung f¨ur zwei Threads zu beweisen. Draw a state-space diagram to prove / disprove the correctness of the following implementation of a lock for two threads. volatile boolean flag[2]; int tid = ThreadID(); //returns 0/1, different for both threads while (flag[1-tid]) {/*wait*/} flag[tid] = true // Critical Section flag[tid] = false Parallele Programmierung - Semesterpr¨ufung - Seite 15 von 28 Mittwoch, 19.08.2020 (c) (4)Implementieren Sie ein Lock f¨ur N threads welches ausschliesslich atomare Register be- nutzt, d.h., benutzen Sie weder CAS noch an- dere Synchronisationsprimitive. Sie k¨onnen Pseudocode benutzen. Implement a lock for N threads that only makes use of atomic registers, i.e., do not use CAS or other synchronization prim- itives. You can use pseudo-code. (d) (3)Implementieren Sie ein Lock f¨ur N threads welches nur ein atomares Register benutzt. Benutzen Sie die CAS Synchronisationspri- mitive. Sie k¨onnen Pseudocode benutzen. Implement a lock for N threads that only uses one atomic register. Use the CAS synchronization primitive. You can use pseudo-code. Parallele Programmierung - Semesterpr¨ufung - Seite 16 von 28 Mittwoch, 19.08.2020 Linearizability (16 points) 9. (a) (3)Geben Sie eine Historie f¨ur zwei Threads an, welche sequentiell konsistent und nicht linea- risierbar ist. Nutzen Sie ein atomares Regis- ter r welches initial den Wert null enth¨alt und die Operationen read und write unterst¨utzt. Give a two-thread history that is se- quentially consistent, but not lineariz- able. Use a single atomic register r that initially contains the value zero and sup- ports the operations read and write. (b) (3)Wieviele Historien gibt es, welche das Krite- rium “well formed” erf¨ullen und die zu der untenstehenden Historie “equivalent” sind (nach Deﬁnition aus der Vorlesung), jedeoch nicht identisch. Geben Sie zwei solche Histo- rien an. How many histories are “well-formed” and “equivalent” (by the deﬁnition shown in the lecture), but not identical to the one given below. Give two such histories. A: r.write(1) A: void() B: q.write(2) B: void Parallele Programmierung - Semesterpr¨ufung - Seite 17 von 28 Mittwoch, 19.08.2020 (c) (4)Geben Sie f¨ur jede der untenstehenden His- torien an, ob diese linearisierbar ist. Nehmen Sie an r sein ein atomares Register, s ein Kel- lerspeicher. For each of the histories below, indi- cate if it is linearizable, assuming r is an atomic register and s is a stack. A:r.write(1) B:r.write(2) A:void A:r.write(3) B:void B:r.read() B:3 A:void ⃝ Die obige Historie ist linearisierbar. The history above is linearizable. ⃝ Die obige Historie ist nicht linearisierbar. The history above is not linearizable. A:r.write(1) A:void B:r.write(2) B:void B:r.read() B:1 ⃝ Die obige Historie ist linearisierbar. The history above is linearizable. ⃝ Die obige Historie ist nicht linearisierbar. The history above is not linearizable. Parallele Programmierung - Semesterpr¨ufung - Seite 18 von 28 Mittwoch, 19.08.2020 A:r.write(1) B:r.write(2) A:void B:void B:r.read() B:1 ⃝ Die obige Historie ist linearisierbar. The history above is linearizable. ⃝ Die obige Historie ist nicht linearisierbar. The history above is not linearizable. A:s.push(1) C:s.push(3) C:void B:s.push(2) A:void B:void A:s.pop() A:1 A:s.pop() A:3 ⃝ Die obige Historie ist linearisierbar. The history above is linearizable. ⃝ Die obige Historie ist nicht linearisierbar. The history above is not linearizable. Parallele Programmierung - Semesterpr¨ufung - Seite 19 von 28 Mittwoch, 19.08.2020 (d) (2)Geben Sie alle Werte an welche das “?” im untenstehenden Bild annehmen kann, so dass die Historie linearisierbar ist. List all possible values that the “?” can take in the picture below, so that the shown history is linearizable. (e) (2)In einem shared-memory System werden alle Zugriﬀe auf geteilte Daten durch ein einziges globales Lock gesch¨utzt. Markieren Sie alle zutreﬀenden Aussagen: In a shared memory system all accesses to shared data are protected by a single, global lock. Mark all true statements: ⃝ Alle “well-formed” Historien, welche die- ses System produziert sind linearisierbar. All well-formed histories produced by this system are linearizable. ⃝ Alle “well-formed” Historien, welche die- ses System produziert sind sequentiell konsistent. All well-formed histories produced by this system are sequentially consis- tent. ⃝ Alle “well-formed” Historien, welche die- ses System produziert sind sequentiell. All well-formed histories produced by this system are sequential. (f) (2)In einem shared-memory System werden alle Zugriﬀe auf geteilte Daten durch ein einziges globales Lock gesch¨utzt. Markieren Sie alle zutreﬀenden Aussagen: In a shared memory system all accesses to shared data are made on atomic regis- ters, i.e., volatile variables in Java. Mark all true statements: ⃝ Alle “well-formed” Historien, welche die- ses System produziert sind linearisierbar. All well-formed histories produced by this system are linearizable. ⃝ Alle “well-formed” Historien, welche die- ses System produziert sind sequentiell konsistent. All well-formed histories produced by this system are sequentially consis- tent. ⃝ Alle “well-formed” Historien, welche die- ses System produziert sind sequentiell. All well-formed histories produced by this system are sequential. Parallele Programmierung - Semesterpr¨ufung - Seite 20 von 28 Mittwoch, 19.08.2020 Barriers (5 points) 10. (a) (5)Implementieren Sie eine Semaphore in Ja- va, nutzen Sie wait/notify um sicherzustel- len, dass Threads welche keinen Fortschritt machen k¨onnen, nicht unn¨otig CPU Zyklen verschwenden. Implement a Semaphore in Java. Use wait/notify to ensure threads which can- not make progress do not spin. 1 public class CountingSemaphore { 2 private int tickets = 0; 3 4 public synchronized void accquire() { 5 6 7 8 9 10 } 11 12 public synchronized void release() throws InterruptedException{ 13 14 15 16 17 18 19 } 20 } Parallele Programmierung - Semesterpr¨ufung - Seite 21 von 28 Mittwoch, 19.08.2020 Wait-free (7 points) 11. (a) (3)Benennen und erkl¨aren Sie drei Kriteri- en, welche ein korrektes wartefreies Konsen- susprotokoll erf¨ullen muss. Name and brieﬂy explain three criteria that a valid wait-free consensus protocol must fulﬁll. (b) (4)Nehmen Sie an, dass das Zustandsdiagramm eines Konsensusprotokolls f¨ur N Threads die H¨ohe h hat, und sich der Initialzustand auf H¨ohe 0 beﬁndet. Beweisen oder wiederlegen Sie folgendes Lemma: Wenn das Consensus- Protokoll einen kritischen Zustand auf der H¨ohe x f¨ur 1 ≤ x ≤ h − 1 hat, dann kann es keinen zweiten kritischen Zustand in H¨ohe x + 1 geben. Assume the state diagram of a binary consensus protocol for N threads has height h, the initial state is at height 0. Proof or disprove the following Lemma: If the consensus protocol has a critical state at height x for 1 ≤ x ≤ h − 1 then it cannot have a second critical state at height x + 1. Parallele Programmierung - Semesterpr¨ufung - Seite 22 von 28 Mittwoch, 19.08.2020 Message passing (8 points) 12. (a) (2)Ist das folgende MPI Programm korrekt wenn es mit zwei Prozessen ausgef¨uhrt wird? Begr¨unden Sie Ihre Antwort. Is the following MPI program correct when executed with two processes? Jus- tify your answer. int compute(int x) { int sbuf[1]; int rbuf[1]; MPI.Init(args); //ignore args int r = MPI.COMM_WORLD.Rank(); sbuf[0] = x; rbuf if (r==0) { MPI.COMM_WORLD.Send(sbuf, 0, 1, MPI.INT, 1, 42); MPI.COMM_WORLD.Recv(rbuf, 0, 1, MPI.INT, 0, 42); } if (r==1) { MPI.COMM_WORLD.Send(sbuf, 0, 1, MPI.INT, 1, 42); MPI.COMM_WORLD.Recv(sbuf, 0, 1, MPI.INT, 0, 42); } MPI.Finalize(); return(x + rbuf[0]); } Parallele Programmierung - Semesterpr¨ufung - Seite 23 von 28 Mittwoch, 19.08.2020 (b) (3)Vervollst¨andigen Sie das untenstehende Pro- gramm so, dass es die Summe ∑ p∈P xp in jedem Prozess berechnet, wobei P die Menge der MPI Prozesse, und xp die lokale Variable x auf jedem Prozess p ∈ P bezeichnet. Complete the code below so that it uses two diﬀerent MPI group communica- tion operations / collectives to compute∑ p∈P xp on each process, where P de- notes the set of MPI processes, xp the local variable x on each process p ∈ P . int compute(int x) { int sbuf[1]; int rbuf[2]; MPI.Init(args); //ignore args int r = MPI.COMM_WORLD.Rank(); MPI.Finalize(); return(rbuf[r]); } // some MPI collectives for reference Allgather(sendbuf, sendoffset, sendcount, sendtype, recvbuf, recvoffset, recvcount, recvtype) Allreduce(sendbuf, sendoffset, recvbuf, recvoffset, count, datatype, Op op) Alltoall(sendbuf, sendoffset, sendcount, sendtype, recvbuf, recvoffset, recvcount, recvtype) Bcast(buf, offset, count, type, root) Gather(sendbuf, sendoffset, sendcount, sendtype, recvbuf, recvoffset, recvcount, recvtype, root) Reduce(sendbuf, sendoffset, recvbuf, recvoffset, count, datatype, Op op, root) Scatter(sendbuf, sendoffset, sendcount, sendtype, recvbuf, recvoffset, recvcount, recvtype, root) Parallele Programmierung - Semesterpr¨ufung - Seite 24 von 28 Mittwoch, 19.08.2020 (c) (3)In der Vorlesung haben Sie zwei wichtige Konzepte kennen gelernt, welche die Basis f¨ur Message Passing darstellen: Communicating Sequential Processes (CSP) und das Aktor- Modell. Was ist der Hauptunterschied zwi- schen den beiden? Beschreiben Sie jeweils ei- ne Gemeinsamkeit, welche MPI mit diesen Konzepten teilt. In the lecture we saw two important concepts that form the basis of mes- sage passing: Communicating Sequen- tial Processes (CSP) and the Actor Model. What is the main diﬀerence be- tween the two? Brieﬂy describe a sim- ilarity MPI has with each of these con- cepts. Parallele Programmierung - Semesterpr¨ufung - Seite 25 von 28 Mittwoch, 19.08.2020 Mixer (8 points) 13. (a) (3)Zeichnen Sie ein Sortiernetzwerk f¨ur f¨unf Ein- gaben. Dieses Netzwerk muss nicht optimal sein, jedoch darf es nicht mehr als 10 Kom- peratoren enthalten. Draw a sorting network for ﬁve inputs. This network does not have to be mini- mal but cannot use more than 10 com- parators. (b) (3)Kann das ABA Problem in allen F¨allen durch Pointer-Tagging gel¨ost werden? Begr¨unden Sie ihre Antwort. Does pointer tagging solve the ABA problem for all cases? Justify your an- swer. (c) (2)Beschreiben Sie zwei Verbesse- rungsm¨oglichkeiten f¨ur die untenstehende Lock Implementierung. Achten Sie auf Leis- tungsprobleme wenn dieser Lock von einer grossen Anzahl Threads verwendet wird. Describe two possible improvements for the lock implemented below. Consider possible performance problems when this lock is used by a large number of threads. public class MyLock implements Lock { Atomic Boolean l = new AtomicBoolean(false); public void lock() { while(l.getAndSet(true)) {/*wait*/} } public void unlock() { l.set(false); } } Parallele Programmierung - Semesterpr¨ufung - Seite 26 von 28 Mittwoch, 19.08.2020 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu ﬁnden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found. Parallele Programmierung - Semesterpr¨ufung - Seite 27 von 28 Mittwoch, 19.08.2020 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu ﬁnden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found. Parallele Programmierung - Semesterpr¨ufung - Seite 28 von 28 Mittwoch, 19.08.2020 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu ﬁnden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found.","libVersion":"0.3.2","langs":""}