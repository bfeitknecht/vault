{"path":"sem3/TI/VRL/extra/nwehrl/TI-nwehrl-w03.pdf","text":"Theoretische Informatik HS24 Nicolas Wehrli ¨Ubungsstunde 03 8. Oktober 2024 ETH Z ¨urich nwehrl@ethz.ch 1 Heute 1 Feedback zur Serie 2 Endliche Automaten - Einf ¨uhrung 3 Beweise f ¨ur Nichtregularit¨at Theorie f ¨ur Nichtregularit¨atsbeweise 2 Feedback zur Serie Feedback - Falsche Annahme zur Kolmogorov Komplexit¨at von nat ¨urlichen Zahlen K(n) ̸= ⌈log2(n + 1)⌉ + c - Ihr m ¨usst Pascal Programme schreiben! - Kolmogorov Komplexit¨at ist definiert ¨uber Pascal-Programme die keinen Input nehmen. 3 Feedback Sei Σ ein Alphabet und x ∈ Σ∗. Wir sagen, dass ein Algorithmus A das Wort x generiert, falls A f ¨ur die Eingabe λ die Ausgabe x liefert. Kolmogorov-Komplexit¨at F ¨ur jedes Wort x ∈ (Σbool)∗ ist die Kolmogorov-Komplexit¨at K(x) des Wortes x das Minimum der bin¨aren L¨angen, der Pascal-Programme, die x generieren. =⇒ Kolmogorov Komplexit¨at eines Wortes ist die L¨ange des k ¨urzesten Programms, dass keinen Input nimmt und das Wort ausgibt! 4 Endliche Automaten - Einf ¨uhrung Erster Ansatz zur Modellierung von Algorithmen Ein (deterministischer) endlicher Automat (EA) ist ein Quintupel M = (Q, Σ, δ, q0, F), wobei (i) Q eine endliche Menge von Zust¨anden ist, (ii) Σ ein Alphabet, genannt Eingabealphabet, ist, (iii) q0 ∈ Q der Anfangszustand ist, (iv) F ⊆ Q die Menge der akzeptierenden Zust¨ande ist und (v) δ : Q × Σ → Q die ¨Ubergangsfunktion ist. 5 Konfigurationen Eine Konfiguration von M ist ein Tupel (q, w) ∈ Q × Σ∗. - ”M befindet sich in einer Konfiguration (q, w) ∈ Q × Σ∗, wenn M im Zustand q ist und noch das Suffix w eines Eingabewortes lesen soll.” - Die Konfiguration (q0, x) ∈ {q0} × Σ∗ heisst die Startkonfiguration von M auf x. - Jede Konfiguration aus Q × {λ} nennt man Endkonfiguration. Ein Schritt von M ist eine Relation (auf Konfigurationen) M ⊆ (Q × Σ∗) × (Q × Σ∗), definiert durch (q, w) M (p, x) ⇐⇒ w = ax, a ∈ Σ und δ(q, a) = p. 6 Berechnungen Eine Berechnung C von M ist eine endliche Folge C = C0, C1, ..., Cn von Konfi- gurationen, so dass Ci M Ci+1 f ¨ur alle 0 ≤ i ≤ n − 1. C ist die Berechnung von M auf einer Eingabe x ∈ Σ∗, falls C0 = (q0, x) und Cn ∈ Q × {λ} eine Endkonfiguration ist. Falls Cn ∈ F × {λ}, sagen wir, dass C eine akzeptierende Berechnung von M auf x ist, und dass M das Wort x akzeptiert. Falls Cn ∈ (Q \\ F) × {λ}, sagen wir, dass C eine verwerfende Berechnung von M auf x ist, und dass M das Wort x verwirft (nicht akzeptiert). 7 Transitivit¨at von M und δ Sei M = (Q, Σ, δ, q0, F) ein endlicher Automat. Wir definieren M ∗ als die refle- xive und transitive H ¨ulle der Schrittrelation M von M; daher ist (q, w) M ∗ (p, u) ⇐⇒ (q = p ∧ w = u) oder ∃k ∈ N \\ {0}, so dass (i) w = a1a2...aku, ai ∈ Σ f ¨ur i = 1, 2, ..., k, und (ii) ∃r1, r2, ..., rk−1 ∈ Q, so dass (q, w) M (r1, a2...aku) M ... M (rk−1, aku) M (p, u) 8 Transitivit¨at von M und δ Wir definieren ˆδ : Q × Σ∗ → Q durch: (i) ˆδ(q, λ) = q f ¨ur alle q ∈ Q und (ii) ˆδ(q, wa) = δ(ˆδ(q, w), a) f ¨ur alle a ∈ Σ, w ∈ Σ∗, q ∈ Q. ˆδ(q, w) = p ⇐⇒ (q, w) M ∗ (p, λ) 9 Regul¨are Sprachen Die von M akzeptierte Sprache L(M) ist definiert als L(M) = {w ∈ Σ ∗ | Berechnung von M auf w endet in (p, λ) ∈ F × {λ}} = {w ∈ Σ∗ | (q0, w) M ∗ (p, λ) ∧ p ∈ F} = {w ∈ Σ ∗ | ˆδ(q0, w) ∈ F} LEA = {L(M) | M ist ein EA} ist die Klasse der Sprachen, die von endlichen Automaten akzeptiert werden. LEA bezeichnet man auch als die Klasse der regul¨aren Sprachen, und jede Sprache L ∈ LEA wird regul¨ar genannt. 10 Klassen f ¨ur alle Zust¨ande im Endlichen Automaten F ¨ur alle p ∈ Q definieren wir die Klasse Kl[p] = {w ∈ Σ ∗ | ˆδ(q0, w) = p} = {w ∈ Σ ∗ | (q0, w) M ∗ (p, λ)} Wir bemerken dann ⋃ q∈Q Kl[q] = Σ ∗ Kl[q] ∩ Kl[p] = ∅, ∀p, q ∈ Q, p ̸= q L(M) = ⋃ q∈F Kl[q] 11 EA Konstruktion - Beispielaufgabe Entwerfen sie f ¨ur folgende Sprache einen Endlichen Automat und geben Sie eine Beschreibung von Kl[q] f ¨ur jeden Zustand q ∈ Q. L1 = {xbbya ∈ {a, b} ∗ | x, y ∈ {a, b}∗} 12 EA Konstruktion - Beispielaufgabe q0start q1 q2 q3 a b b a b a a b 13 EA Konstruktion - Beispielaufgabe Wir beschreiben nun die Klassen f ¨ur die Zust¨ande q0, q1, q2, q3: Kl[q0] = {wa ∈ {a, b}∗ | Das Wort w enth¨alt nicht die Teilfolge bb} ∪ {λ} Kl[q1] = {wb ∈ {a, b}∗ | Das Wort w enth¨alt nicht die Teilfolge bb} Kl[q3] = {wa ∈ {a, b}∗ | Das Wort w enth¨alt die Teilfolge bb} = L1 Kl[q2] = {a, b}∗ − (Kl[q0] ∪ Kl[q1] ∪ Kl[q3]) 14 Produktautomaten - Lemma 3.2 Sei Σ ein Alphabet und seien M1 = (Q1, Σ, δ1, q01, F1) und M2 = (Q2, Σ, δ2, q02, F2) zwei EA. F ¨ur jede Mengenoperation ⊙ ∈ {∪, ∩, −} existiert ein EA M, so dass L(M) = L(M1) ⊙ L(M2). Sei M = (Q, Σ, δ, q0, F⊙), wobei (i) Q = Q1 × Q2 (ii) q0 = (q01, q02) (iii) f ¨ur alle q ∈ Q1, p ∈ Q2 und a ∈ Sigma, δ((q, p), a) = (δ1(q, a), δ2(p, a)), (iv) falls ⊙ = ∪, dann ist F = F1 × Q2 ∪ Q1 × F2 falls ⊙ = ∩, dann ist F = F1 × F2, und falls ⊙ = −, dann ist F = F1 × (Q2 − F2). 15 Produktautomat - Beispielaufgabe Verwenden Sie die Methode des modularen Entwurfs (Konstruktion eines Produktautomaten), um einen endlichen Automaten (in Diagrammdarstellung) f ¨ur die Sprache L = {w ∈ {a, b} ∗ | |w|a = 2 oder w = ya} zu entwerfen. Zeichnen Sie auch jeden der Teilautomaten und geben Sie f ¨ur die Teilautomaten f ¨ur jeden Zustand q die Klasse Kl[q] an. 16 Produktautomat - Beispielaufgabe Wir teilen L wie folgt auf: L = L1 ∪ L2 wobei gilt: L1 = {w ∈ {a, b}∗ | w = ya} L2 = {w ∈ {a, b}∗ | |w|a = 2} Zuerst zeichnen wir die 2 einzelnen Teilautomaten und geben f ¨ur jeden Zustand q bzw. p die Klasse Kl[q] respektive Kl[p] an: 17 Produktautomat - Beispielaufgabe erster Teilautomat: L1 = {w ∈ {a, b}∗ | w = ya} q0start q1 b a b a Kl[q0] = {yb | y ∈ {a, b}∗} ∪ {λ} Kl[q1] = {ya | y ∈ {a, b}∗} 18 Produktautomat - Beispielaufgabe zweiter Teilautomat: L2 = {w ∈ {a, b}∗ | |w|a = 2} p0start p1 p2 ptrash b a a b a b a b 19 Produktautomat - Beispielaufgabe Wir beschreiben nun die Zust¨ande f ¨ur die Klassen p0, p1, p2, ptrash: Kl[p0] = {w ∈ {a, b}∗ | |w|a = 0} Kl[p1] = {w ∈ {a, b}∗ | |w|a = 1} Kl[p2] = {w ∈ {a, b}∗ | |w|a = 2} Kl[ptrash] = {w ∈ {a, b}∗ | |w|a > 2} 20 Produktautomat - Beispielaufgabe Zum Schluss kombinieren wir diese Teilautomaten zu einem Produktautomaten: Produktautomat: L = L1 ∪ L2 (q0, p0)start (q0, p1) (q0, p2) (q0, ptrash) (q1, p0) (q1, p1) (q1, p2) (q1, ptrash) b a b a b a b ab a b a b a b a 21 Beweise f ¨ur Nichtregularit¨at Einf ¨uhrung und grundlegende Tipps i. Wichtiges Unterkapitel. Kommt fast garantiert am Midterm. ii. Um L /∈ LEA zu zeigen, gen ¨ugt es zu beweisen, dass es keinen EA gibt, der L akzeptiert. iii. Nichtexistenz ist generell sehr schwer zu beweisen, da aber die Klasse der endlichen Automaten sehr eingeschr¨ankt ist, ist dies nicht so schwierig. iv. Wir f ¨uhren Widerspruchsbeweise. v. Es gibt 3 Arten Nichtregularit¨atsbeweise zu f ¨uhren (Lemma 3.3, Pumping-Lemma und Kolmogorov-Komplexit¨at). vi. Ihr m ¨usst alle 3 Methoden k ¨onnen. Ist aber halb so wild. 22 Theorie f ¨ur Nichtregularit¨atsbeweise - Lemma 3.3 Sei A = (Q, Σ, δA, q0, F) ein EA. Seien x, y ∈ Σ∗, x ̸= y, so dass ˆδA(q0, x) = p = ˆδA(q0, y) f ¨ur ein p ∈ Q (also x, y ∈ Kl[p]). Dann existiert f ¨ur jedes z ∈ Σ∗ ein r ∈ Q, so dass xz und yz ∈ Kl[r], also gilt insbesondere xz ∈ L(A) ⇐⇒ yz ∈ L(A) 23 Theorie f ¨ur Nichtregularit¨atsbeweise - Lemma 3.3 Beweis: Aus der Existenz der Berechnungen (q0, x) A ∗ (p, λ) und (q0, y) A ∗ (p, λ) von A folgt die Existenz der Berechnungen auf xz und yz: (q0, xz) A ∗ (p, z) und (q0, yz) A ∗ (p, z) f ¨ur alle z ∈ Σ∗. Wenn r = ˆδA(p, z) ist, dann ist die Berechnung von A auf xz und yz: (q0, xz) A ∗ (p, z) A ∗ (r, λ) und (q0, yz) A ∗ (p, z) A ∗ (r, λ). Wenn r ∈ F, dann sind beide W ¨orter xz und yz in L(A). Falls r /∈ F, dann sind xz, yz /∈ L(A). ■ 24 Theorie f ¨ur Nichtregularit¨atsbeweise - Lemma 3.3 Bemerkungen - Von den 3 vorgestellten Methoden, ist diese Methode die einzige, die (unter der richtigen Anwendung) garantiert f ¨ur jede nichtregul¨are Sprache funktioniert. - Um die Nichtregularit¨at von L zu beweisen, verwenden wir die Endlichkeit von Q und das Pigeonhole-Principle. Betrachten wir mal eine Beispielaufgabe mit dieser Methode am Paradebeispiel L = {0 n1 n | n ∈ N} 25 Beispielaufgabe - Lemma 3.3 Nehmen wir zum Widerspruch an L sei regul¨ar. Dann existiert ein EA A = (Q, Σ, δ, q0, F) mit L(A) = L. Wir betrachten die W ¨orter 01, . . . , 0|Q|+1. Per Pigeonhole-Principle existiert O.B.d.A. i < j, so dass ˆδ(q0, 0i) = ˆδ(q0, 0 j) Nach Lemma 3.3 gilt 0 iz ∈ L ⇐⇒ 0jz ∈ L f ¨ur alle z ∈ (Σbool)∗. Dies f ¨uhrt aber zu einem Widerspruch, weil f ¨ur z = 1i das Wort 0i1i ∈ L aber 0j1i /∈ L. 26 Theorie f ¨ur Nichtregul¨arit¨atsbeweise - Pumping Lemma Sei L regul¨ar. Dann existiert eine Konstante n0 ∈ N, so dass jedes Wort w ∈ Σ∗ mit |w| ≥ n0 in drei Teile x, y und z zerlegen l¨asst, das heisst w = yxz, wobei (i) |yx| ≤ n0 (ii) |x| ≥ 1 (iii) entweder {yxkz | k ∈ N} ⊆ L oder {yxkz | k ∈ N} ∩ L = ∅. 27 Theorie f ¨ur Nichtregul¨arit¨atsbeweise - Pumping Lemma Beweis Sei L ∈ Σ∗ regul¨ar. Dann existiert ein EA A = (Q, Σ, δA, q0, F), so dass L(A) = L. Sei n0 = |Q| und w ∈ Σ∗ mit |w| ≥ n0. Dann ist w = w1w2...wn0u, wobei wi ∈ Σ f ¨ur i = 1, ..., n0 und u ∈ Σ∗. Betrachten wir die Berechnung auf w1w2...wn0: (q0, w1w2w3...wn0) A (q1, w2w3...wn0) A ... A (qn0−1, wn0) A (qn0, λ) 28 Theorie f ¨ur Nichtregul¨arit¨atsbeweise - Pumping Lemma In dieser Berechnung kommen n0 + 1 Zust¨ande q0, q1, ..., qn0 vor. Da |Q| = n0, existieren i, j ∈ {0, 1, ..., n0}, i < j, so dass qi = qj. Daher haben wir in der Berechnung die Konfigurationen (q0, w1w2w3...wn0) A ∗ (qi, wi+1wi+2...wn0) A ∗ (qi, wj+1...wn0) A ∗ (qn0, λ) Dies impliziert (qi, wi+1wi+2...wj) A ∗ (qi, λ) (1) Wir setzen nun y = w1...wi, x = wi+1...wj und z = wj+1...wn0u, so dass w = yxz. 29 Theorie f ¨ur Nichtregul¨arit¨atsbeweise - Pumping Lemma Wir ¨uberpr ¨ufen nun die Eigenschaften (i),(ii) und (iii): (i) yx = w1...wiwi+1...wj und daher |yx| = j ≤ n0. (ii) Da |x| ≥ j − i und i < j, ist |x| ≥ 1. (iii) (1) impliziert (qi, xk) A ∗ (qi, λ) f ¨ur alle k ∈ N. Folglich gilt f ¨ur alle k ∈ N: (q0, yx kz) A ∗ (qi, x kz) A ∗ (qi, z) A ∗ (ˆδA(qi, z), λ) Wir sehen, dass f ¨ur alle k ∈ N die Berechnungen im gleichen Zustand qend = ˆδA(qi, z) enden. Falls also qend ∈ F, akzeptiert A alle W ¨orter aus {yxkz | k ∈ N}. Falls qend /∈ F, dann akzeptiert A kein Wort aus {yxkz | k ∈ N}. ■ 30 Beispielaufgabe - Pumping Lemma Versuchen wir zu beweisen, dass L2 = {wabw R | w ∈ {a, b} ∗} nicht regul¨ar ist. 31 Beispielaufgabe - Pumping Lemma Wir nehmen zum Widerspruch an, dass L2 regul¨ar ist. Das Pumping-Lemma (Lemma 3.4) besagt, dass dann eine Konstante n0 ∈ N existiert, so dass sich jedes Wort w ∈ Σ∗ mit |w| ≥ n0 in drei Teile y, x, und z zerlegen l¨asst. ( =⇒ w = yxz). Wobei folgendes gelten muss: (i) |yx| ≤ n0 (ii) |x| ≥ 1 (iii) entweder {yxkz | k ∈ N} ⊆ L2 oder {yxkz | k ∈ N} ∩ L2 = ∅ 32 Beispielaufgabe - Pumping Lemma Wir w¨ahlen w = an0aban0. Es ist leicht zu sehen das |w| = 2n0 + 2 ≥ n0. Da nach (i), |yx| ≤ n0 gelten muss, haben wir y = al und x = am f ¨ur beliebige l, m ∈ N, l + m ≤ n0. Somit gilt z = an0−(l+m)aban0 Nach (ii) ist m ≥ 1. Wir haben also {yxkz | k ∈ N} = {an0−m+kmaban0 | k ∈ N} 33 Beispielaufgabe - Pumping Lemma Da yx1z = an0aban0 und an0aban0 ∈ {an0−m+kmaban0 | k ∈ N} ∧ an0aban0 ∈ L2 gilt, folgt {a n0−m+kmaba n0 | k ∈ N} ∩ L2 ̸= ∅ Wenn wir nun k = 0 w¨ahlen und uns daran erinnern, dass m ≥ 1, erhalten wir folgendes ⇒ yx 0z = yz = an0−maba n0 /∈ L2 Daraus folgt, {a n0−m+kmaba n0 | k ∈ N} ⊈ L2 Somit gilt (iii) nicht. Dies ist ein Widerspruch! Somit haben wir gezeigt, dass die Sprache L2 = {wabwR | w ∈ {a, b}∗} nicht regul¨ar ist. 34","libVersion":"0.3.2","langs":""}