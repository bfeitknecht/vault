{"path":"sem4/FMFP/UE/e/FMFP-u12-optional-e.pdf","text":"P. M¨uller, D. Basin and R. Jung Formal Methods and Functional Programming Optional Exercises 12: Axiomatic Semantics As usual, the solutions can be found at the end of the file. Assignment 1 (Zune Bug) This question concerns termination and the Zune bug, as discussed in the lectures. Task 1.1. Suppose that, for some statement s, the triple { true } s { ⇓ true } can be derived. What does this tell us about s? Task 1.2. Let s be the following (corrected) IMP statement: while ((L(year) and 366 < days) or (not L(year) and 365 < days)) do if (L(year)) then days := days - 366 else days := days - 365 end; year := year + 1 end Show that ⊢ { true } s { ⇓ true }. Assignment 2 (Total Correctness of Division) Consider the following IMP program s: 1 while r >= 0 do r := r - d; q := q + 1 end; r := r + d; q := q - 1 The program s computes the quotient q and remainder r resulting from the division of a given non-negative integer N (initially stored in the variable r) by a given positive integer D (stored in the variable d). Task 2.1. Find a suitable loop invariant and variant Task 2.2. Show that ⊢ { N ≥ 0 ∧ D > 0 ∧ d = D ∧ r = N ∧ q = 0 } s { ⇓ N = q×D +r ∧ r ≥ 0 ∧ r < D }. Assignment 3 (Logarithm) Let s be the following IMP program: a := 1; b := 0; while a < n do a := a * 10; if (a <= n) then b := b + 1 else skip end end The function computes ⌊log10(n)⌋, storing the result in z. To express the floor of the logarithm, we will use two inequalities involving exponentiation. Task 3.1. Try to find a loop invariant for this program. Task 3.2. Using the loop invariant from the previous task, prove that the program computes log10(n) rounded down, i.e., that ⊢ { n = N ∧ n ≥ 1 } s { 10 b ≤ N ∧ N < 10 b+1 } Hint: If you are not able come up with an invariant, do a handstand: (a≤n⇒a=10 b)∧(a>n⇒a=10 b+1)∧10 b≤n∧n=N 2 Solution of assignment 1 (Zune Bug) Task 1.1. If the triple { true } s { ⇓ true } can be derived, this means that the statement s is guaranteed to terminate (regardless of the initial state). Task 1.2. We use true as the invariant for the loop, and days for the variant. The proof outline is: {true} while ((L(year) and 366 < days) or (not L(year) and 365 < days)) do∗ {((L(year) ∧ 366 < days) ∨ (¬L(year) ∧ 365 < days)) ∧ true ∧ days = V } if (L(year)) then {L(year) ∧ ((L(year) ∧ 366 < days) ∨ (¬L(year) ∧ 365 < days)) ∧ true ∧ days = V } ⊨ {days − 366 < V } days := days - 366 {days < V } else {¬L(year) ∧ ((L(year) ∧ 366 < days) ∨ (¬L(year) ∧ 365 < days)) ∧ true ∧ days = V } ⊨ {days − 365 < V } days := days - 365 {days < V } end; {days < V } y:=y+1 {⇓ days < V } ⊨ {⇓ true ∧ days < V } end {⇓ ¬((L(year) ∧ 366 < days) ∨ (¬L(year) ∧ 365 < days)) ∧ true} ⊨ {⇓ true} (∗) side-condition: the while condition entails ( ⊨ ) days ≥ 0 Solution of assignment 2 (Total Correctness of Division) Task 2.1. A suitable loop invariant is N = q × d + r ∧ r + d ≥ 0 ∧ d = D ∧ d > 0 and the loop variant is r. Task 2.2. The proof outline is: 3 {N ≥ 0 ∧ D > 0 ∧ d = D ∧ r = N ∧ q = 0} |= {N = q × d + r ∧ r + d ≥ 0 ∧ d = D ∧ d > 0} while r >= 0 do∗ {r ≥ 0 ∧ N = q × d + r ∧ r + d ≥ 0 ∧ d = D ∧ d > 0 ∧ r = Z } |= {N = (q + 1) × d + r − d ∧ r − d + d ≥ 0 ∧ d = D ∧ d > 0 ∧ r − d < Z} r := r - d; {N = (q + 1) × d + r ∧ r + d ≥ 0 ∧ d = D ∧ d > 0 ∧ r < Z} q := q + 1 {⇓ N = q × d + r ∧ r + d ≥ 0 ∧ d = D ∧ d > 0 ∧ r < Z} end; {⇓ ¬(r ≥ 0) ∧ N = q × d + r ∧ r + d ≥ 0 ∧ d = D ∧ d > 0} |= (1) {⇓ N = (q − 1) × d + r + d ∧ r + d ≥ 0 ∧ r + d < d ∧ d = D ∧ d > 0} r := r + d; {⇓ N = (q − 1) × d + r ∧ r ≥ 0 ∧ r < d ∧ d = D ∧ d > 0} q := q - 1 {⇓ N = q × d + r ∧ r ≥ 0 ∧ r < d ∧ d = D ∧ d > 0} |= {⇓ N = q × D + r ∧ r ≥ 0 ∧ r < D} (∗) side-condition: (r ≥ 0 ∧ N = q × d + r ∧ r + d ≥ 0 ∧ d = D ∧ d > 0) |= r ≥ 0 (1) ¬(r ≥ 0) implies r + d < d. Solution of assignment 3 (Logarithm) Task 3.1. Our loop invariant is as follows: (a ≤ n ⇒ a = 10 b) ∧ (a > n ⇒ a = 10 b+1) ∧ 10 b ≤ n ∧ n = N Task 3.2. Then the proof outline is: 4 {n = N ∧ n ≥ 1} ⊨ {n = N ∧ n ≥ 1 ∧ 1 = 1 ∧ 0 = 0} a := 1; {n = N ∧ n ≥ 1 ∧ a = 1 ∧ 0 = 0} b := 0; {n = N ∧ n ≥ 1 ∧ a = 1 ∧ b = 0} ⊨(⋆) {(a ≤ n ⇒ a = 10b) ∧ (a > n ⇒ a = 10b+1) ∧ 10b ≤ n ∧ n = N } while a<n do {a < n ∧ (a ≤ n ⇒ a = 10b) ∧ (a > n ⇒ a = 10b+1) ∧ 10b ≤ n ∧ n = N } ⊨ {a ∗ 10 = 10b+1 ∧ 10b < n ∧ n = N } a := a*10; {a = 10b+1 ∧ 10b < n ∧ n = N } if (a <= n) then {a ≤ n ∧ a = 10b+1 ∧ 10b < n ∧ n = N } ⊨ {a = 10b+1 ∧ 10b+1−1 < n ∧ n = N ∧ a ≤ n} b := b+1 {a = 10b ∧ 10b−1 < n ∧ n = N ∧ a ≤ n} ⊨(⋆) {(a ≤ n ⇒ a = 10b) ∧ (a > n ⇒ a = 10b+1) ∧ 10b ≤ n ∧ n = N } else {¬(a ≤ n) ∧ a = 10b+1 ∧ 10b < n ∧ n = N } skip {¬(a ≤ n) ∧ a = 10b+1 ∧ 10b < n ∧ n = N } ⊨(⋆) {(a ≤ n ⇒ a = 10b) ∧ (a > n ⇒ a = 10b+1) ∧ 10b ≤ n ∧ n = N } end {(a ≤ n ⇒ a = 10b) ∧ (a > n ⇒ a = 10b+1) ∧ 10b ≤ n ∧ n = N } end {¬(a < n) ∧ (a ≤ n ⇒ a = 10b) ∧ (a > n ⇒ a = 10b+1) ∧ 10b ≤ n ∧ n = N } ⊨(1) {10b ≤ N ∧ N < 10b+1} (⋆) For these steps we use that P ∧ R entails (P ⇒ R) ∧ (¬P ⇒ Q) for arbitrary assertions P, R, Q. (1) To justify this step, use the fact that a ≥ n, and case split on a = n or a > n: In the case where a = n holds, from the first implication we deduce a = 10b. Therefore, in this case, we have 5 N = n = a = 10b, from which the post-condition follows directly. In the case where a > n holds, we use the second implication to deduce a = 10b+1. Our assumption is that a > n, and so we have N < 10b+1. From 10b ≤ n, we deduce 10b ≤ N as required. 6","libVersion":"0.5.0","langs":""}