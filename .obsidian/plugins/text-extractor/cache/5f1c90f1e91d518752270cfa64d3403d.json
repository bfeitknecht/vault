{"path":"sem3/TI/UE/s/TI-s-u08.pdf","text":"Departement Informatik Theoretische Informatik Prof. Dr. Dennis Komm Prof. Dr. Juraj Hromkoviˇc Dr. Hans-Joachim B¨ockenhauer Exemplary Solutions – Sheet 8 Z¨urich, November 22, 2024 Solution to Task 22 We show Lreach /∈ LR by proving LU ≤m Lreach. To this end, we construct an algorithm F that transforms an input for LU into an input for Lreach. The algorithm F proceeds as follows: • F checks if the input x has the form Kod(M )#w. • If the input does not have this form, then F outputs a word that is not in Lreach, e.g., the empty word λ. • If the input has the form Kod(M )#w, then F constructs a TM NM,w that ignores its own input and, on every input, simulates the TM M on w. • F determines the number i of qaccept in Kod(NM,w) and outputs Kod(NM,w)#0 i. Now we show that x ∈ LU ⇐⇒ F (x) ∈ Lreach. Let x ∈ LU. Then the input has the form Kod(M )#w for some w ∈ L(M ), i.e., the computation of M on w terminates in qaccept. Since NM,w simulates on every own input the computation of M on w, NM,w accepts every input, i.e., the computation of M terminates in qaccept = qi, and, by definition of codes for Turing machines from Section 4.5 in the textbook, NM,w has at least i + 1 states. Hence, Kod(NM,w)#0 i ∈ Lreach. Let x /∈ LU. Then either x is an invalid input or w /∈ L(M ). If x is an invalid input, then F (x) = λ /∈ Lreach. Otherwise, F (x) = Kod(NM,w)#0 i /∈ Lreach since the computation of NM,w on no input reaches qaccept (i.e., the i-th state). As the mapping reduction is a special case of a recursive reduction, LU /∈ LR and LU ≤m Lreach immediately imply Lreach /∈ LR. Solution to Task 23 (a) We check that Lall is a semantically nontrivial decision problem about Turing machines. Thus, L /∈ LR follows from Rice’s Theorem. Evidently we have Lall ⊆ KodTM. For the Turing machine M1 over Σ that ignores its input and immediately moves to qaccept, we have Kod(M1) ∈ Lall and hence Lall ̸= ∅. For the Turing machine M2 that also ignores its input and immediately moves to qreject, we have Kod(M2) /∈ Lall and hence Lall ̸= KodTM. Finally, for all Turing machines M and M ′ with L(M ) = L(M ′): L(M ) = Σ ∗ ⇐⇒ L(M ′) = Σ ∗ and therefore Kod(M ) ∈ Lall ⇐⇒ Kod(M ′) ∈ Lall. (b) To prove L∁ H ≤m Lall, we describe an algorithm F that transforms an input x for L∁ H into an input f (x) for Lall. The algorithm F first checks if x has the form Kod(M )#w, for a Turing machine M and a word w ∈ {0, 1} ∗. If this is not the case, then F outputs the code of a Turing machine Mall that accepts every input, i.e., f (x) = Kod(Mall). Otherwise, F computes the code of a Turing machine M ′ that works as follows. On an input y, M ′ simulates |y| steps of the machine M on w. (If M halts in less steps during the simulation, then M ′ simulates less than |y| steps.) If M halts on w during the simulation of at most |y| steps, then M ′ rejects the input y. Otherwise, M ′ accepts the input y. The output of F is thus f (x) = Kod(M ′). Now we prove the correctness of the reduction, i.e., x ∈ L ∁ H ⇐⇒ f (x) ∈ Lall, for all x ∈ {0, 1, #}∗. Let us first suppose that x ∈ L∁ H and distinguish the following two cases. If x does not have the form Kod(M )#w, for any Turing machine M and any word w ∈ {0, 1}∗, then f (x) = Kod(Mall) and thus f (x) ∈ Lall. Otherwise, if x = Kod(M )#w, for a Turing machine M and a word w ∈ {0, 1} ∗, then M does not halt on w because x ∈ L ∁ H. This further implies that M ′ accepts every input y ∈ Σ ∗ because M never halts on w during the simulation, in particular not within |y| steps. Hence, f (x) ∈ Lall holds. Let us suppose that x /∈ L∁ H, i.e., x ∈ LH. Then x has the form Kod(M )#w, for a Turing machine M and a word w ∈ {0, 1} ∗, and M halts on w after a certain number of steps k. Let y be an arbitrary word in Σ k. On the input y, M ′ simulates |y| = k steps of M on w. Because M halts on w during |y| = k steps, M ′ rejects the input y, i.e., y /∈ L(M ′). Hence, f (x) = Kod(M ′) /∈ Lall. Solution to Task 24 The idea behind the construction of A is to simulate 12 steps of M in 6 steps of A. To this end, every 12 cells of the working tape of M are combined into one cell of A. The same compression is applied to the input as well, A uses its second working tape for that. We note that A can simulate a constant number of M ’s computation steps in a single step if A has saved the symbols read by M in those steps in its state in advance. We thus pay for optimizing the running time by a significant blow-up of the working alphabet and the set of states. The MTM A has the same input on its input tape as M . To shorten the computation, A first compresses this input to the second working tape. To this end, it always reads 12 cells of the input tape and writes the 12-tuple of input symbols in one cell of the second working tape. This clearly requires n + 1 steps on an input of length n since the head on the input tape reaches the right endmarker $ at the (n + 1)-th step. Afterwards, A moves the head on the second working tape back to the start. Because ⌈n/12⌉ cells are used on that tape, this requires ⌈n/12⌉ steps. Hence, A needs 13n 12 + c1 steps in total for the preprocessing, for a small constant c1, e.g., c1 = 2. The actual simulation of M 2 by A proceeds in rounds of up to 6 computation steps. In every round, A simulates 12 computation steps of M . This yields a running time of the simulation at most ⌈ TimeM (n) 12 ⌉ · 6 ≤ TimeM (n) 2 + c2 , for some small constant c2, e.g., c2 = 6. At the beginning of every round, A reads the contents of its two working tapes at the current cell and the two neighbouring cells at the left and right and saves these 3 · 12 = 36 cells of the input and working tape of M in its states. This requires 4 steps: one step to the left, two steps to the right, and one step back to the original position. Hence, A now has enough information to simulate 12 steps of M in its states since M can move by at most 12 positions in 12 steps and A knows at least 12 cells to the left and right of the current position of M . In the 12 simulated steps, M can only change the contents of two of the three blocks of 12 cells. These changes can be performed by A in at most 2 steps on its tapes as follows: We only describe the modification of the first working tape, changing the head position on the simulated input tape can be performed analogously. In the fifth step of the round, A changes the content of the current cell of the working tape according to the 12 computation steps of M and moves the head to the left or right if changes are required in the corresponding part of M ’s tape simulated there. In the sixth step, A performs modifications on the neighbouring cell and potentially returns back. If changes are only necessary on the current position of both working tapes of A, then the sixth step is not needed. Overall, this yields the claimed upper bound on the total running time of A. 3","libVersion":"0.5.0","langs":""}