{"path":"sem2/AuW/VRL/slides/AuW-L20-autorepair.pdf","text":"Wahrscheinlichkeit Al gor i thm e n und Wa h r s c h e i n l i c h k e i t A n g e l i ka S t e g e r I n st i t u t f ü r T h e o r e t i sch e I n f o r m a t i k Kapitel 3.2.2 Konvexe Hülle Konvexe Hülle Gegeben: Punkte x 1 ,…,x n in R 2 Annahme Vorlesung: keine drei Punkte auf einer Gerade, keine zwei Punkte mit gleicher x-Koordinate (allg. Fall: siehe Skript ) „links von“ q r p Konvexe Hülle ➤ Es gibt n(n-1) Paare von Knoten, für jedes Paar können wir in O(n) prüfen ob das Paar eine Randkante ist. ➤ Die Menge aller Randkanten kann in O(n 3 ) bestimmt werden. Frage: Wie ﬁnden wir die konvexe Hülle? Konvexe Hülle: Jarvis Wrap Idee: Betrachtete Punkt mit kleinster x Koordinate Wie können wir (efﬁzient) ausgehende Randkante bestimmen? Jarvis’ (Einwickel-)Algorithmus Einwickelalgorithmus Ziel für heute: O(n log n) Konvexe Hülle Idee: Kantenzug von „links“ nach „rechts“ Algorithmus: sukzessives „ausbessern“ Konvexe Hülle Konvexe Hülle Konvexe Hülle Konvexe Hülle Konvexe Hülle Konvexe Hülle Konvexe Hülle blau: Ausgangs-Kantenzug von „links“ nach „rechts“ rot: neu gefundene Kanten Konvexe Hülle 2.Schritt: Kantenzug von „rechts“ nach „links“ Konvexe Hülle 2.Schritt: Kantenzug von „rechts“ nach „links“ Idee für Laufzeitabschätzung: Anzahl Verbesserungen = Anzahl Dreiecke Ebene Graphen Es gilt: - Die inneren Gebiete einer Triangulierung sind alles Dreiecke. - Das einzige äussere Gebiet ist das Komplement von conv(P) in R 2 und liegt genau an den Randkanten von P an. Ebene GraphenEbene Graphen Beweis : Betrachte Verbesserungsalgorithmus: zu Beginn: 2(n-1) gerichtete Kanten jeder Verbesserungsschritt: - zwei gerichtete Kanten werden zu ungerichteten Kanten - eine neue gerichtete Kante wird eingefügt am Ende: h gerichtete Kanten (die Kanten der konvexen Hülle) # Schritte = 2(n-1) - h , 0 Dreiecke , 1 Dreieck entsteht … ebenso viele Dreieck sind entstanden Ebene Graphen Beweis : Betrachte leicht modiﬁzierte Version des Verbesserungsalgorithmus: (nur ungerichtete Kanten) zu Beginn: n-1 Kanten jeder Verbesserungsschritt: - eine neue Kante wird eingefügt am Ende: h Kanten (die Kanten der konvexen Hülle) # Kanten = n-1 + #Schritte = 3n - 3 -h Exkurs: Eulersche Formel n Punkte h Punkte auf konvexer Hülle 2n-2-h Dreiecke 3n-3-h Kanten n - (3n-3-h) + (2n-2-h+1) = 1+1 planare Graphen Def: Ein Graph G = (V,E) heisst planar, wenn man ihn in der Ebene so zeichnen kann, dass sich keine zwei Kanten kreuzen. Man kann zeigen: planare Graphen kann man immer auch so zeichnen, dass alle Kanten gerade Linien sind: Satz: Für jeden planaren Graph G = (V,E) gibt es eine Einbettung P : V → ℝ 2 , so dass G = (P(V), E) ein ebener Graph ist. Kor: Für jeden planaren Graph G = (V,E) gilt |E| ≤ 3|V| - 6 zurück zu konvexer Hülle Idee: Kantenzug von „links“ nach „rechts“ Algorithmus: sukzessives „ausbessern“ Frage: Wie ﬁnden wir die „Ausbesserungen“ efﬁzient? zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ zurück zu konvexer Hülle Idee: Konstruiere untere Hülle von „links“ nach „rechts“ etc. LocalRepairLocalRepair Achtung: für das Sortieren der Punkte nach x-Koordinate benötigt man Zeit O(n log n) Man kann zeigen: Konvexe Hülle kann i.A. nicht schneller als Sortieren gelöst werden.","libVersion":"0.3.1","langs":""}