{"path":"sem4/FMFP/PV/exams/30-finals/FMFP-FS18.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Exam August 6th, 2018, 14:30 – 17:30 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud. No.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 32 pages; the back page of this booklet is page 32. After the exam begins, check that your exam papers are complete (4 assignments for the FP part, 4 assignments and 2 pages of background material for the FM part). 2. You may complete the assignments in any order. We recommend spending roughly half of your time on each of the two parts of the exam. 3. Only write on the exam paper and extra paper sheets which are given by the assis- tants. Do not take any of this paper out of the exam: submit it all. Write your ﬁrst and last name and your student number on every sheet of paper that you write on. 4. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 5. For the FP part of the exam, you may use any functions from the Haskell Prelude in your solutions (without giving their deﬁnitions), unless speciﬁed otherwise. You also may use any function from one subproblem to solve the subsequent subproblems, even if you have not provided a deﬁnition for the function itself. 6. Write clearly in the sense of logic, language, and readability. Label all rule applicati- ons in your derivation trees. The clarity of your arguments and explanations aﬀects your grade. 7. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 8 ∑ Max. points 10 10 10 10 5 12 9 14 80 Your points Formal Methods and Functional Programming, Exam, SS18 2 Part I: Functional Programming Formal Methods and Functional Programming, Exam, SS18 4 Assignment 1: Typing and Evaluation (10 points) 1. Recall the following constants and functions from the Haskell libraries. (2 points) (<) :: Ord a => a -> a -> Bool map :: (a -> b) -> [a] -> [b] filter :: (a -> Bool) -> [a] -> [a] 1,2,3,... :: Num a => a Determine whether the following expressions are well-typed or not. If so, then state the most general type; otherwise justify informally why the expression is not typable. (a) map (filter (<3)) (b) \\x -> x map Assignment 1 continues on the next page. Formal Methods and Functional Programming, Exam, SS18 5 2. Evaluate the following expression lazily and eagerly. (2 points) λx. λy. y (((λz. λx. x z) x) (λx. x)) Reminder: The lazy evaluation strategy works as follows. ‹ For an application t1 t2 – Evaluate t1 – t2 is substituted without evaluation ‹ No evaluation under a lambda abstraction The eager evaluation strategy works as follows. ‹ For an application t1 t2 – Evaluate t1 – t2 is evaluated prior to substitution ‹ Evaluation is carried out under a lambda abstraction Assignment 1 continues on the next page. Formal Methods and Functional Programming, Exam, SS18 6 3. Formally infer the most general type of the following expression using (6 points) the Mini-Haskell typing rules. Label every proof step with the name of the used rule and list the arising constraints explicitly. Ø (λy. λx. y (fst x) x) (λx. λy. y) ∶∶ . . . Recall the proof rules for the Mini-Haskell type system: Var . . . , x ∶ τ, . . . Ø x ∶∶ τ Γ, x ∶ σ Ø t ∶∶ τ Abs Γ Ø λx. t ∶∶ σ → τ Γ Ø t1 ∶∶ σ → τ Γ Ø t2 ∶∶ σ App Γ Ø t1 t2 ∶∶ τ Int Γ Ø n ∶∶ Int True Γ Ø T rue ∶∶ Bool False Γ Ø F alse ∶∶ Bool Γ Ø t ∶∶ Int iszero Γ Ø iszero t ∶∶ Bool Γ Ø t1 ∶∶ Int Γ Ø t2 ∶∶ Int BinOp Γ Ø (t1 op t2) ∶∶ Int for op ∈ {+, ∗} Γ Ø t0 ∶∶ Bool Γ Ø t1 ∶∶ τ Γ Ø t2 ∶∶ τ if Γ Ø if t0 then t1 else t2 ∶∶ τ Γ Ø t1 ∶∶ τ1 Γ Ø t2 ∶∶ τ2 Tuple Γ Ø (t1, t2) ∶∶ (τ1, τ2) Γ Ø t ∶∶ (τ1, τ2) fst Γ Ø fst t ∶∶ τ1 Γ Ø t ∶∶ (τ1, τ2) snd Γ Ø snd t ∶∶ τ2 Formal Methods and Functional Programming, Exam, SS18 7Formal Methods and Functional Programming, Exam, SS18 8 Assignment 2: Proofs about funct. programs (10 points) A ternary tree is a tree data structure in which each node has three children. Here, we consider ternary trees with unlabeled leaves and labeled nodes. data Ternary a = Leaf | Node a (Ternary a) (Ternary a) (Ternary a) 1. (a) Give the type of the canonical fold function foldTer on ternary trees. (1 point) (b) Deﬁne the canonical fold function foldTer on ternary trees. (1 point) (c) Using foldTer deﬁne the map function (1 point) mapTer :: (a -> b) -> Ternary a -> Ternary b on ternary trees. Assignment 2 continues on the next page. Formal Methods and Functional Programming, Exam, SS18 9 2. Consider the following Haskell declarations. (7 points) sum :: Ternary Int -> Int sum Leaf = 0 --sum.1 sum (Node v l c r) = v + sum l + sum c + sum r --sum.2 zsum :: Ternary Int -> Bool -> Int zsum Leaf _ = 0 --zsum.1 zsum (Node v l c r) b = (if b then v else 0) + zsum l (not b) + zsum r (not b) --zsum.2 zebra :: Ternary Int -> Bool -> Ternary Int zebra Leaf _ = Leaf --zebra.1 zebra (Node v l c r) b = Node (if b then v else 0) (zebra l (not b)) Leaf (zebra r (not b)) --zebra.2 Prove that for all ternary trees with integer nodes t :: Ternary Int the equality sum (zebra t False) = zsum t False holds. Structure your proof clearly and justify every proof step. Formal Methods and Functional Programming, Exam, SS18 10Formal Methods and Functional Programming, Exam, SS18 11 Assignment 3: Programming with lists (10 points) 1. (a) Deﬁne a function diags :: [[a]] -> [[a]] that extracts the main diagonals from a square matrix which is represented by its rows. The picture on the right shows a matrix with the two diagonals circled. This example corresponds to diags [[1,2,3],[4,5,6],[7,8,9]] = [[1,5,9],[3,5,7]] (3 points) 1 2 3 4 5 6 7 8 9 You may assume that the input xss to diags is a square matrix, i.e., map length xss = replicate (length xss) (length xss). (b) A magic square of size n is an arrangement of integers in an n × n (2 points) square matrix such that all rows, all columns, and the main diagonals sum to the same number. Deﬁne a function isMagic :: [[Int]] -> Bool that tests whether a square matrix represented by its rows is a magic square. For example: isMagic [[1,2],[3,4]] = False isMagic [[2,7,6],[9,5,1],[4,3,8]] = True You may assume that the input xss to isMagic is a square matrix, i.e., map length xss = replicate (length xss) (length xss). Hint: You may use the Data.List function transpose :: [[a]] -> [[a]]. Assignment 3 continues on the next page. Formal Methods and Functional Programming, Exam, SS18 12 2. (a) Deﬁne an inﬁnite list natPairs :: [(Integer, Integer)] (3 points) that consists of all pairs of positive integers. The list can be in any order, but make sure that every pair occurs in some ﬁnite preﬁx of natPairs. A possible strategy to enumerate the pairs is shown below: (1,1) (2,1) (3,1) (1,2) (2,2) (3,2) (1,3) (2,3) (3,3) ⋮ . . . (b) Deﬁne an inﬁnite list rationals :: [(Integer, Integer)] (2 points) that consists of all positive rational numbers represented as pairs of numerator and denominator. Each rational number must occur only once. For example, only one of (2,3) and (4,6) should be an element of rationals. Hint: You may ﬁnd the function gcd useful. Formal Methods and Functional Programming, Exam, SS18 13Formal Methods and Functional Programming, Exam, SS18 14 Assignment 4: A-lists and B-trees (10 points) An A-list is an alternating list of elements of two diﬀerent types: data AList a b = AEnd a | ACons a b (AList a b) Note that every A-list of type AList a b contains one more a than b. 1. Deﬁne the functions ahead and alast, both of type AList a b -> a, (2 points) that return the ﬁrst and last element of an AList, respectively. 2. Deﬁne the function aflat :: (a -> [b]) -> AList a b -> [b] (2 points) that transforms an A-list into a list of bs by translating the a-elements into lists of bs, while preserving the order. For example: aflat (\\x -> x) (ACons \"fm\" 'f' (ACons \"\" 'p' (AEnd \"!11\"))) = \"fmfp!11\" aflat (\\n -> replicate n 'f') (ACons 1 'm' (ACons 3 'p' (AEnd 0))) = \"fmfffp\" Assignment 4 continues on the next page. Formal Methods and Functional Programming, Exam, SS18 15 A B-tree is a basic search tree data structure, often used in database systems. A B- tree’s leaves are labeled with a list of keys. A B-tree’s (inner) nodes contain k keys and have k + 1 children, which are themselves B-trees. We use the following Haskell type to represent B-trees: data BTree key = Leaf [key] | Node (AList (BTree key) key) The following is an example element of type BTree Int (shown pictorially on the right): btree = Node (ACons (Leaf [1,2,3]) 4 (ACons (Leaf [4,6,6]) 6 (ACons (Node (ACons (Leaf [6]) 7 (ACons (Leaf []) 7 (AEnd (Leaf [7,8]))))) 8 (AEnd (Leaf [9]))))) 4 6 8 [4, 6, 6][1, 2, 3] 7 7 [9] [6] [7, 8][] ● ● ● ● ● ● ● 3. Deﬁne the function bsorted :: Ord key => BTree key -> Bool (6 points) that checks the following search invariant of B-trees: ‹ the list of keys in any leaf is sorted, and ‹ the keys contained in any inner node are sorted, and ‹ for any key k in any inner node the child to the left of k only contains smaller or equal keys and the child to the right of k only contains greater or equal keys. For example, bsorted btree should return True. Hint: The function aflat might be useful. Formal Methods and Functional Programming, Exam, SS18 16 Part II: Formal Methods Formal Methods and Functional Programming, Exam, SS18 18 Assignment 5 (5 points) Recall the extension of the small-step semantics of IMP with rules for parallelism: `s, σe →1 `s′′, σ′e (Par1SOS) `s par s′, σe →1 `s′′ par s′, σ′e `s′, σe →1 `s′′, σ′e (Par3SOS) `s par s′, σe →1 `s par s′′, σ′e `s, σe →1 σ′ (Par2SOS) `s par s′, σe →1 `s′, σ′e `s′, σe →1 σ′ (Par4SOS) `s par s′, σe →1 `s, σ′e 5.A (2.5 points) Let s be the statement x := y+1 par y := x+1 and let σ be a state such that σ(x) = σ(y) = 0. For how many states σ′ is it true that `s, σe → ∗ 1 σ′ ? Write down these states. For each one, provide a derivation sequence justifying your choice (you only need to show the steps; you do not need to write derivation trees to justify each step). Assignment 5 continues on the next page. Formal Methods and Functional Programming, Exam, SS18 19 5.B (2.5 points) Consider adding a new statement set(x, v) to IMP, where v is a value (rather than an expression). The small-step semantics of this statement is given by the following derivation rule: (SetSOS) `set(x, v), σe →1 σ[x ( v] Using this additional statement, we can deﬁne the following alternative derivation rule for assignment statements: (Ass ′ SOS) `x := e, σe →1 `set(x, A[[e]]σ), σe Using these new rules, would your answer to part 5.A change? In particular, using the same s and σ, are there fewer or more states σ′ such that `s, σe → ∗ 1 σ′ using these new rules? If there are fewer states, explain why. If there are more states, provide a derivation sequence to justify each additional state (again, you do not need to provide derivation trees to justify the individual steps). Formal Methods and Functional Programming, Exam, SS18 20 Assignment 6 (12 points) Consider the statement s ≡ while x > 0 do y := y + 1;x := x − 1 end. Using natural (big-step) semantics, prove the following property of this program: ∀σ, σ′. σ(x) ≥ 0 ∧ Ø `s, σe → σ′ Ô⇒ σ′(y) = σ(x) + σ(y) Formal Methods and Functional Programming, Exam, SS18 21Formal Methods and Functional Programming, Exam, SS18 22 Assignment 7 (9 points) Consider the following IMP statement s: a := x; y := 0; while (a # 0) do y := y + 1; a := a - 1 end 7.A (7 points) Construct a proof outline that proves the following Hoare triple: {x ≥ 0 ∧ x = X} s {⇓ y = X} Assignment 7 continues on the next page. Formal Methods and Functional Programming, Exam, SS18 23 Assignment 7 continues on the next page. Formal Methods and Functional Programming, Exam, SS18 24 7.B (1 point) Is the Hoare triple {x = X} s {⇓ y = X} valid? Brieﬂy justify your answer. If your answer is yes, it is suﬃcient to state which loop invariant and loop variant you would use in the proof outline. If your answer is no, provide a value for X that makes the triple invalid. 7.C (1 point) Is the Hoare triple {x = X} s {y = X} valid? Brieﬂy justify your answer. If your answer is yes, it is suﬃcient to state which loop invariant you would use in the proof outline. If your answer is no, provide a value for X that makes the triple invalid. Formal Methods and Functional Programming, Exam, SS18 25Formal Methods and Functional Programming, Exam, SS18 26 Assignment 8 (14 points) 0 1 2 3 4 5 6 7 The diagram above shows a train track, consisting of a main loop (on the right), which can be travelled in either direction, and a one-way loop on the left (used for turning the train around). On the far right side, there is a single end-point for the train, from which it cannot travel further; the train only moves forwards. The numbered arrows in the diagram indicate particular positions (and directions) of the train; we will use these to deﬁne the states of a model of the system above. The train is initially in state 0. 8.A (2 points) Consider the following incomplete Promela model for the train system: byte pos = 0; /* train position */ init { do :: pos >= 0 && pos <= 5 -> pos = pos + 1; :: pos == 7 -> break; /* end point */ od } Add appropriate cases to the do loop, to complete the modelling of the system in the diagram. Assignment 8 continues on the next page. Formal Methods and Functional Programming, Exam, SS18 27 8.B (2 points) Promela assert statements can be used to check certain properties of the model. When we use a model checker (such as Spin) to check for assertion violations, is the property we are checking of the model a safety property, a liveness property, neither or both? Brieﬂy explain your answer. 8.C (10 points) For each of the following four statements, answer the following ques- tions: can you use a model checker (such as Spin) to verify whether or not this property is true of the train system by modifying the code of the Promela model and checking for assertion violations? If your answer is “yes”, describe brieﬂy here what you would add or change in the code of the model, and why your approach works. If your answer is “no”, brieﬂy explain why the property cannot be checked in such a way. Statement 1: “The train will never reach position 6.” Statement 2: “The train is guaranteed to eventually reach position 7.” Assignment 8 continues on the next page. Formal Methods and Functional Programming, Exam, SS18 28 Statement 3: “It is possible for the train to reach position 7.” Statement 4: “The train cannot reach position 7 without ﬁrst visiting position 3 (the left-hand loop).” Formal Methods and Functional Programming, Exam, SS18 29Formal Methods and Functional Programming, Exam, SS18 30Formal Methods and Functional Programming, Exam, SS18 31 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ∶∶= skip T x := e T s; s T if b then s else s end T while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). Natural Semantics (Big-Step Semantics) (SkipNS) `skip, σe → σ (AssNS) `x := e, σe → σ[x ( A[[e]]σ] `s1, σe → σ′ `s2, σ′e → σ′′ (SeqNS) `s1;s2, σe → σ′′ `s1, σe → σ′ (IfTNS) `if b then s1 else s2 end, σe → σ′ if B[[b]]σ = tt `s2, σe → σ′ (IfFNS) `if b then s1 else s2 end, σe → σ′ if B[[b]]σ = ﬀ `s, σe → σ′ `while b do s end, σ′e → σ′′ (WhTNS) `while b do s end, σe → σ′′ if B[[b]]σ = tt (WhFNS) `while b do s end, σe → σ if B[[b]]σ = ﬀ Formal Methods and Functional Programming, Exam, SS18 32 Structural Operational Semantics (Small-Step Semantics) (SkipSOS) `skip, σe →1 σ (AssSOS) `x := e, σe →1 σ[x ( A[[e]]σ] `s1, σe →1 σ′ (Seq1SOS) `s1;s2, σe →1 `s2, σ′e `s1, σe →1 `s′ 1, σ′e (Seq2SOS) `s1;s2, σe →1 `s′ 1;s2, σ′e (IfTSOS) `if b then s1 else s2 end, σe →1 `s1, σe if B[[b]]σ = tt (IfFSOS) `if b then s1 else s2 end, σe →1 `s2, σe if B[[b]]σ = ﬀ (WhileSOS) `while b do s end, σe →1 `if b then s;while b do s end else skip end, σe Axiomatic Semantics (partial correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ( e] } x := e { P } { P } s1 { Q } { Q } s2 { R } (SeqAx) { P } s1;s2 { R } { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P′ } s { Q′ } (ConsAx) { P } s { Q } if P à P′ and Q′ à Q Axiomatic Semantics (total correctness) As for partial correctness above, except for the following rule, which replaces (WhAx) : { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P à 0 ≤ e","libVersion":"0.5.0","langs":""}