{"path":"sem5/SPCA/VRL/extra/SPCA-s02-C.pdf","text":"252-0061-00 V Systems Programming and Computer Architecture Chapter 2: Introduction to C © Systems Group | Department of Computer Science | ETH Zürich Systems Programming 2025 Ch. 2: Introduction to C 1 2.1: History and toolchain Systems Programming and Computer Architecture Systems Programming 2025 Ch. 2: Introduction to C 2 History • Developed 1969-1972 by Dennis Ritchie • CPL → BCPL → B → C • Highly influenced by DEC PDP-11 architecture • Portable across many architectures • Standards: • K&R C (standard was the compiler source!) • ANSI C • C99 (we’ll use this) • C11 (more recent, less used) • C17 (even more recent, bug fixes to C11…) • … and many C-like variants 3Systems Programming 2025 Ch. 2: Introduction to C 1941-2011 More than 50 years on, C is still ubiquitous… Systems Programming 2025 Ch. 2: Introduction to C 4 Compared to Java, C#, PHP, Python, etc… • Very fast • Almost impossible to write assembly as fast as a good C compiler • Pretty much impossible to compile Java to run as fast as C • Powerful macro pre-processor (cpp) • Close to the metal: you can know what the code is doing to the hardware  Remains the language of choice for • Operating System developers • Embedded systems • People who really care about speed • Authors of security exploits 5Systems Programming 2025 Ch. 2: Introduction to C Just some of what you don’t get • No objects, classes, traits, features, methods, or interfaces • Only functions/procedures • We will see function pointers later… • No fancy built-in types • Mostly just what the hardware provides • Type constructors to build structured types • No exception handling • convention is to use integer return codes 6Systems Programming 2025 Ch. 2: Introduction to C Most important difference • No automatic memory management • Lots of things on the stack • No garbage collection • Heap structures explicitly created and freed • Pointers: direct access to memory addresses • Weakly typed by what they point to C is about directly building and manipulating structures in main memory! 7Systems Programming 2025 Ch. 2: Introduction to C Syntax: the good news • Java, JavaScript, C++, and C# syntax almost entirely lifted from C • Comments (/*...*/, //) the same • Identifiers same as in Java • C# allows more characters in identifiers • Block structure using { … } Many other constructs the same or similar. 8Systems Programming 2025 Ch. 2: Introduction to C Syntax: main differences • List of reserved words is different • C is run through a macro preprocessor • String and file substitution • Conditional compilation • Although C# has preprocessor directives, it does not have a separate preprocessor. Moreover there are no macros. 9Systems Programming 2025 Ch. 2: Introduction to C Hello world #include <stdio.h> int main(int argc, char *argv[]) { printf(\"hello, world\\n\"); return 0; } “header file” – bit like an interface file in Java or C# Every program has to have a “main” function, which takes a list of command line arguments. Generic function for printing formatted strings. The “newline” is not included automatically! Returning 0 indicates everything is OK – C has no exceptions. 10Systems Programming 2025 Ch. 2: Introduction to C Source code: chapter 2 → hello Workflow foo.i foo.o bar bar bar.i bar.o libZ.a libc.so Editor (emacs, vi) or IDE (VSCode, Eclipse) pre-processed C source files (often .i) object files (.o) statically- linked libraries shared libraries execute, debug, profile, … executable edit compile link link link load process 11Systems Programming 2025 Ch. 2: Introduction to C foo.c foo.h bar.c source files (.c, .h) preprocess GNU gcc Toolchain cpp cc1 as ldC source executable 2. Compile each C file into assembly language1. Macro substitution, Include header files 3. Assemble each file into object code 4. Link object files into program binary .c,.h .c .s .o 12Systems Programming 2025 Ch. 2: Introduction to C GNU gcc Toolchain cpp cc1 as ldC source executable .c,.h .c .s .o gcc –S foo.c gcc –c foo.c gcc –o bar foo.c bar.c 13Systems Programming 2025 Ch. 2: Introduction to C gcc –E foo.c Summary • C is a systems programming language! • It is there to program the system. • Also useful for high performance • Understanding C is about understanding how • Your program • The C compiler • The present computer system … all interact with each other. Systems Programming 2025 Ch. 2: Introduction to C 14 2.2: Control flow in C Systems Programming and Computer Architecture Systems Programming 2025 Ch. 2: Introduction to C 15 Control flow statements (like Java or C# or C++) if (Boolean expression) Statement_when_true else Statement_when_false switch (Integer expression) { case Constant_1 : Statement; break; case Constant_2 : Statement; break; … case Constant_n: Statement; break; default: Statement; break; } return (Expression) 16Systems Programming 2025 Ch. 2: Introduction to C Control flow statements (like Java or C# or C++) for (Initial; Test; Increment) Statement while (Boolean expression) Statement do Statement while (Boolean expression) 17Systems Programming 2025 Ch. 2: Introduction to C Note: not like for .. In .. – instead, basically a while loop. Control flow statements (not like Java, same as C#) goto Label Controversial, but occasionally very useful indeed! break continue Like C#, but unlike Java, can’t give a label! 18Systems Programming 2025 Ch. 2: Introduction to C Functions: similar to Java • Name • Return type • Argument types • Body #include <stdio.h> // Compute factorial function // fact(n) = n * (n-1) * ... * 2 * 1 int fact(int n) { if (n == 0) { return(1); } else { return(n * fact(n-1)); } } int main(int argc, char *argv[]) { int n, m; printf(\"Enter a number: \"); scanf(\"%d\", &n); m = fact(n); printf(\"Factorial of %d is %d.\\n\", n, m); return 0; } 19Systems Programming 2025 Ch. 2: Introduction to C Source code: chapter 2 → factorial main(): also a function #include <stdio.h> int main(int argc, char *argv[]) { int i; // Print arguments from command line */ printf(\"argc = %d\\n\\n\", argc); for (i = 0; i < argc; ++i) { printf(\"argv[%d]: %s\\n\", i, argv[i]); } return 0; } 20Systems Programming 2025 Ch. 2: Introduction to C Source code: chapter 2 → printargs Basic I/O: printf() • Just another function, but very useful! • First argument is format string • see “man 3 printf” for all the (many) options • Remaining arguments are arbitrary • but must match the format • You will see other “printf-like” functions #include <stdio.h> int main(int argc, char *argv[]) { int i = 314; const char s[] = \"Mothy\"; printf(\"My name is %s and I work in STF H %d\\n\", s, i); return 0; } 21Systems Programming 2025 Ch. 2: Introduction to C printf is a variadic function! Source code: chapter 2 → printfdemo Summary: control flow in C • Functions • return (..) • Loops • for( ..; ..; ..) • do .. while (..) • while (..) .. • Conditionals • if (..) then .. else .. • switch (..) case .. : ..; default .. • Jumps • break, continue • goto .. • I/O: • printf() 22Systems Programming 2025 Ch. 2: Introduction to C 2.3: goto (or not) Computer Architecture and Systems Programming Systems Programming 2025 Ch. 2: Introduction to C 23 When to use goto 1. Don’t. • Almost never a good idea • Usually argued on performance grounds • E.g. implementing state machines • Often fast, but other ways are often just as fast • E.g. switches and function pointers 2. Early termination of multiple loops 3. Nested cleanup code Systems Programming 2025 Ch. 2: Introduction to C 24 Early termination of nested loops • But consider simply using return() • Other languages have break(label) Systems Programming 2025 Ch. 2: Introduction to C 25 int a[MAXROW][MAXCOL] int i,j; for(i=0; i< MAXROW; i++) { for(j=0; j < MAXCOL; j++) { if (a[i][j] == 0) { goto found; } } } <do some processing when not found> found: <do some processing on i and j> int a[MAXROW][MAXCOL] int i,j; bool found=false; for(i=0; i< MAXROW; i++) { for(j=0; j < MAXCOL; j++) { if (a[i][j] == 0) { found=true; break; } } if (found) break; } if (found) { <do processing on i and j> } else { <do processing when not found> } Compare: Cleanup conditions Goto is used for recovery code • General idea: • Code performs a sequence of operations • Any one can fail • If one fails, all previous operations must be undone • Canonical example: • Malloc’ing a sequence of buffers for data • If one fails, must free all previous generated buffers • Code is often (not always) auto-generated Systems Programming 2025 Ch. 2: Introduction to C 26 Cleanup code • Not easy to represent scalably in “structured programming” • Best effort: nested “if” statements • But can get arbitrarily deep in a complex function • “goto” version is highly stylized (undos can be paired with operations in reverse order) • Can also be modified to handle cases where one “undo” deals with several operations… Systems Programming 2025 Ch. 2: Introduction to C 27 Perform operation 1 If failure, goto exit 1 Perform operation 2 If failure, goto exit 2 Perform operation 3 If failure, goto exit 3 Return success Exit 3: Undo operation 2 Exit 2: Undo operation 1 Exit 1: Return an error Cleanup conditions • From the Linux NFS2 kernel code • Network marshalling code • canonical use-case for this style • Often generated by a stub compiler • though not in this case Systems Programming 2025 Ch. 2: Introduction to C 28 int nfs2_decode_dirent(struct xdr_stream *xdr, struct nfs_entry *entry, int plus) { __be32 *p; int error; p = xdr_inline_decode(xdr, 4); if (unlikely(p == NULL)) goto out_overflow; if (*p++ == xdr_zero) { p = xdr_inline_decode(xdr, 4); if (unlikely(p == NULL)) goto out_overflow; if (*p++ == xdr_zero) return -EAGAIN; entry->eof = 1; return -EBADCOOKIE; } p = xdr_inline_decode(xdr, 4); if (unlikely(p == NULL)) goto out_overflow; entry->ino = be32_to_cpup(p); error = decode_filename_inline(xdr, &entry->name, &entry->len); if (unlikely(error)) return error; entry->prev_cookie = entry->cookie; p = xdr_inline_decode(xdr, 4); if (unlikely(p == NULL)) goto out_overflow; entry->cookie = be32_to_cpup(p); entry->d_type = DT_UNKNOWN; return 0; out_overflow: print_overflow_msg(__func__, xdr); return -EAGAIN; } Summary • Don’t use goto! • Except maybe: • Early termination of multiple loops • Nested cleanup code Systems Programming 2025 Ch. 2: Introduction to C 29 2.4: Basic types in C Systems Programming and Computer Architecture Systems Programming 2025 Ch. 2: Introduction to C 30 Declarations • Are like Java: int my_int; double some_fp = 0.123; • Inside a block: • Scope is just the block • static → value persists between calls • Outside a block: • Scope is the entire program! • static → scope limited to the file (compilation unit) 31Systems Programming 2025 Ch. 2: Introduction to C #include <stdio.h> static int j = 0; int func(int j) { static int i = 0; i = i + 1; j = j + 1; printf(\"In func: i=%d, j=%d\\n\", i, j); return j; } int main(int argc, char *argv[]) { int i = 0; printf(\"In main: i=%d, j=%d\\n\", i, j); func(j); printf(\"In main: i=%d, j=%d\\n\", i, j); func(j); printf(\"In main: i=%d, j=%d\\n\", i, j); return 0; } Source code: chapter 2 → static Integers and floats • Types and sizes: • Integers are signed by default • use signed or unsigned to clarify C data type Typical 32-bit ia32 Intel x86-64 char 1 1 1 short 2 2 2 int 4 4 4 long 4 4 8 long long 8 8 8 float 4 4 4 double 8 8 8 long double 8 10/12 16 32Systems Programming 2025 Ch. 2: Introduction to C Most sizes are implementation defined! C99 extended integer types #include <stdint.h> int8_t a; int16_t b; int32_t c; int64_t d; uint8_t x; uint16_t y; uint32_t z; uint64_t w; Signed integers, precise size in bits Unsigned integers, 33 Integers and floats • Rules for arithmetic on integers and floats are complicated! • Implicit conversions between integer types • Implicit conversions between floating point types • Explicit conversions between anything (casts) • Behavior is either: • Determined by the hardware (implementation defined) • Was decided by hardware, a long time ago (standardized) • We’ll cover this more later… 34Systems Programming 2025 Ch. 2: Introduction to C Booleans • Historically, boolean values are just integers • False → zero • True → anything non-zero • Negation (“!”) turns zero into non-zero, and vice-versa • C99: new bool type supported • Completely optional, it’s still an integer • #include <stdbool.h> 35Systems Programming 2025 Ch. 2: Introduction to C Booleans • Any statement in C is also an expression, hence: 36 #include <stdio.h> #include <stdlib.h> #define ERR_OUT_OF_RANGE (-1) int test(int i) { if (i >= 0 && i < 10) { printf(\"Success: value is %d\\n\", i); return 0; } else { return ERR_OUT_OF_RANGE; } } int main(int argc, char *argv[]) { int rc; if (argc != 2) { fprintf(stderr,\"Usage: %s <number>\\n\", argv[0]); return 1; } if ( (rc = test(atoi(argv[1]))) ) { fprintf(stderr,\"Error: argument was out of range\\n\"); return 1; } return 0; } Source code: chapter 2 → booleans Booleans • Any statement in C is also an expression, hence: Systems Programming 2025 Ch. 2: Introduction to C 37 #include <stdio.h> #define ERR_OUT_OF_RANGE (-1) int main(int argc, char *argv[]) { FILE *f; if (argc != 2) { fprintf(stderr,\"Usage: %s <filename>\\n\", argv[0]); return 1; } if (!(f = fopen( argv[1], \"r\" ))) { perror(\"Failed to open file\"); return 1; } printf(\"Successfully opened %s\\n\", argv[0]); fclose(f); return 0; } Source code: chapter 2 → booleans void • There is a type called void. • It has no value. • Used for: • Untyped pointers (to raw memory): “void *” • Declaring functions with no return value (procedures) 38Systems Programming 2025 Ch. 2: Introduction to C const declarations • Declaring a variable const means that its value cannot be modified. • This will turn out to be very useful later with pointers as lvalues. Systems Programming 2025 Ch. 2: Introduction to C 39 $ cd chapter02/const $ cat const.c const int i = 0; int main(int argc, char *argv[]) { i = i + 1; return i; } $ gcc -o const const.c const.c: In function ‘main’: const.c:5:7: error: assignment of read-only variable ‘i’ 5 | i = i + 1; | ^ $ Source code: chapter 2 → const enum: declaring symbolic integer values Systems Programming 2025 Ch. 2: Introduction to C 40 $ cat enum.c #include <stdio.h> enum { CAB, CNB, OAT, STD, STF, WWA } dinfk_buildings; enum { CAB_N = 6, CNB_N = CAB_N + 1, STF_N = 114 } street_numbers; int main(int argc, char *argv[]) { printf(\"CAB is %d; OAT is %d\\n\", CAB, OAT); printf(\"CNB_N is %d, STF_N is %d\\n\", CNB_N, STF_N); return 0; } $ gcc -Wall -o enum enum.c $ ./enum CAB is 0; OAT is 2 CNB_N is 7, STF_N is 114 $ • values allocated sequentially • starts at 0 by default • values can be given explicitly • Compile-time expressions allowed Source code: chapter 2 → enum Summary: C basic types • Declarations • Scopes and static • Integers and floats, extended types • Booleans • void • const • enum 41Systems Programming 2025 Ch. 2: Introduction to C 2.5: Operators Systems Programming and Computer Architecture Systems Programming 2025 Ch. 2: Introduction to C 42 Operators: similar to Java, C++ Operator Associativity () [] -> . Left-to-right ! ~ ++ -- + - * & (type) sizeof Right-to-left * / % Left-to-right + - Left-to-right << >> Left-to-right < <= > >= Left-to-right == != Left-to-right & Left-to-right ^ Left-to-right | Left-to-right && Left-to-right || Left-to-right ?: Right-to-left = += -= *= /= %= &= ^= |= <<= >>= Right-to-left , Left-to-rightDecreasing precedence • () here is a function call • -> means struct pointer indirection • Unary +, -, * • * here is pointer indirection • Assignment operators 43 • Boolean operators • Ternary if-else operator Early termination Systems Programming 2025 Ch. 2: Introduction to C 44 Operators || (boolean-or) and && (boolean-and) don’t always evaluate their second operand! #include <stdio.h> #include <stdbool.h> bool less_than(int x, int y) { printf(\"Checking if %d < %d\\n\", x, y); return (x < y); } int main(int argc, char *argv[]) { if (less_than( argc, 4) && less_than( 1, argc)) { printf(\"Yes, 1 < argc (%d) < 4\\n\", argc); } return 0; } $ gcc -Wall -o early early.c $ ./early Checking if 1 < 4 Checking if 1 < 1 $ ./early a Checking if 2 < 4 Checking if 1 < 2 Yes, 1 < argc (2) < 4 $ ./early a a Checking if 3 < 4 Checking if 1 < 3 Yes, 1 < argc (3) < 4 $ ./early a a a Checking if 4 < 4 $ Source code: chapter 2 → early Ternary conditional operator 1. Evaluate boolean_expr 2. If it’s true: • Evaluate result_if, assign to result • Don’t evaluate result_else; 3. Else: • Evaluate result_else, assign to result • Don’t evaluate result_if; Systems Programming 2025 Ch. 2: Introduction to C 45 result = boolean_expr ? result_if : result_else ; #include <stdio.h> int main(int argc, char *argv[]) { printf(\"Passed %d argument%s.\\n\", argc - 1, argc == 2 ? \"\" : \"s\"); return 0; } Source code: chapter 2 → ternary Assignment operators • In many imperative languages x = foo(); - is an assignment statement. • In C, it is an expression! • Value is the value being assigned • Also: x += y  x = x + y • and so with -=, *=, <<=, etc. 46Systems Programming 2025 Ch. 2: Introduction to C • Left-to-right associativity: • A + B + C → (A + B) + C • A + B + C + D → ((A + B) + C) + D • Right-to-left: • A += B += C → A += (B += C) • Makes sense here, but elsewhere it’s rarely what you want… Systems Programming 2025 Ch. 2: Introduction to C 47 What is associativity again?Post-increment and pre-increment • i++ • Value: current value of i • Effect: i ← i+1 • ++i • Effect: i ← i+1 • Value: new value of i • Conversely i-- and --i • Works for any scalar type • Importantly: works for pointers! Historical: Digital PDP computers had pre- and post-increment and -decrement addressing modes 48Systems Programming 2025 Ch. 2: Introduction to C • Most C types can be cast to another:  i has value -559038737. • Bit-representation (usually…) does not change • Frequently used with pointer types… Casting unsigned int ui = 0xDEADBEEF; signed int i = (signed int)ui; Name of type in parentheses functions like an operator. 49Systems Programming 2025 Ch. 2: Introduction to C Summary: C operators • Operators and precedence • Early termination • Ternary conditional operator • Assignment operators • Post/pre inc/decrement • Casting 50Systems Programming 2025 Ch. 2: Introduction to C 2.6: Arrays in C Systems Programming and Computer Architecture Systems Programming 2025 Ch. 2: Introduction to C 51 Arrays • Finite vector of variables, all the same type • For an N-element array a: • First element is a[0] • last element is a[N-1] • C compiler does not check the array bounds! • Very typical bug! • Always check array bounds! 52Systems Programming 2025 Ch. 2: Introduction to C Source code: chapter 2 → array #include <stdio.h> float data[5]; // data to average and total float total; // total of the data items float average; // average of the items int main() { data[0] = 34.0; data[1] = 27.0; data[2] = 45.0; data[3] = 82.0; data[4] = 22.0; total = data[0] + data[1] + data[2] + data[3] + data[4]; average = total / 5.0; printf(\"Total %f Average %f\\n\", total, average); return (0); } Multi-dimensional arrays int mat[3][3]; int a = 1; for (i=0; i < 3; i++) for (j=0; j < 3; j++) mat[i][j] = a++; int a = 1; for (i=0; i < 3; i++) for (j=0; j < 3; j++) mat[j][i] = a++; 0 0 0 0 0 0 0 0 0 mat[0][0] mat[2][2]mat[1][0] mat[1][2] ……… 1 2 3 4 5 6 7 8 9 1 4 7 2 5 8 3 6 9 53 Array initializers • Arrays can be initialized when they are defined: #include <stdio.h> int main(int argc, char *argv[]) { int i, j; int a[3] = {3, 7, 9}; int b[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }, }; for(i = 0; i < 3; i++) { printf(\"a[%d] = %d\\n\", i, a[i] ); for(j = 0; j < 3; j++) { printf(\" b[%d][%d] = %d\\n\", i, j, b[i][j] ); } } return 0; } 54Systems Programming 2025 Ch. 2: Introduction to C Source code: chapter 2 → array Array initializers • Arrays can be initialized when they are defined: #include <stdio.h> #define ARRAY_SIZE 10 int main(int argc, char *argv[]) { int i; float lu[ARRAY_SIZE]; // Uninitialized float li[ARRAY_SIZE] = {}; // Initialized to 0.0 for(i = 0; i < ARRAY_SIZE; i++) { printf(\"li[%d] = %f, lu[%d] = %f\\n\", i, li[i], i, lu[i]); } return 0; } 55Systems Programming 2025 Ch. 2: Introduction to C Source code: chapter 2 → array Strings • C has no real string type! • Instead… • Array of char’s terminated with null byte • 0 or '\\0' 56Systems Programming 2025 Ch. 2: Introduction to C #include <stdio.h> int main(int argc, char *argv[]) { int i; // These strings are identical char s1[6] = \"hello\"; char s2[6] = { 'h', 'e', 'l', 'l', 'o', 0 }; printf(\"s1 = '%s'\\n\", s1); printf(\"s2 = '%s'\\n\", s2); for( i = 0; i < 6; i++ ) { printf(\"s1[%d] = %d, s2[%d] = %d\\n\", i, s1[i], i, s2[i]); } return 0; } Source code: chapter 2 → string 57 String library functions #include <stdio.h> #include <string.h> int main(int argc, char *argv[]) { char name1[12], name2[12]; char mixed[25], title[20]; strncpy(name1, \"Rosalinda\", 12); strncpy(name2, \"Zeke\", 12); strncpy(title, \"This is the title.\", 20); printf(\" %s\\n\\n\", title); printf(\"Name 1 is %s\\n\", name1); printf(\"Name 2 is %s\\n\", name2); … … /* returns 1 if name1 > name2 */ if (strncmp(name1, name2, 12) > 0) { strncpy(mixed, name1, 25); } else { strncpy(mixed, name2, 25); } printf(\"The biggest name alphabetically is %s\\n\", mixed); strncpy(mixed, name1, 25); strncat(mixed, \" & \", 25); strncat(mixed, name2, 25); printf(\"Both names are %s\\n\", mixed); return 0; } This is the title. Name1 is Rosalinda Name2 is Zeke The biggest name alphabetically is Zeke Both names are Rosalinda & Zeke Systems Programming 2025 Ch. 2: Introduction to C Source code: chapter 2 → string Generally named ‘strxxx()’ What’s happening with strings? Systems Programming 2025 Ch. 2: Introduction to C 58 'R' 0x52 'o' 0x6F 's' 0x73 'a' 0x61 'l' 0x6C 'i' 0x69 'n' 0x6E 'd' 0x64 'a' 0x61 '\\0' 0x00 ? ? ? ? ? ? ? ? ? ? ? ? char name1[12]; name1: <somewhere>: \"Rosalinda\" What’s happening with strings? Systems Programming 2025 Ch. 2: Introduction to C 59 <somewhere>: strncpy(name1, \"Rosalinda\", 12); 'R' 0x52 'o' 0x6F 's' 0x73 'a' 0x61 'l' 0x6C 'i' 0x69 'n' 0x6E 'd' 0x64 'a' 0x61 '\\0' 0x00 name1: '\\0' 0x00 '\\0' 0x00 'R' 0x52 'o' 0x6F 's' 0x73 'a' 0x61 'l' 0x6C 'i' 0x69 'n' 0x6E 'd' 0x64 'a' 0x61 '\\0' 0x00 What’s happening with strings? Systems Programming 2025 Ch. 2: Introduction to C 60 ' ' 0x20 '&' 0x26 ' ' 0x20 <somewhere>: '\\0' 0x00 name1: '\\0' 0x00 '\\0' 0x00 'R' 0x52 'o' 0x6F 's' 0x73 'a' 0x61 'l' 0x6C 'i' 0x69 'n' 0x6E 'd' 0x64 'a' 0x61 '\\0' 0x00 'Z' 0x5A 'e' 0x65 'k' 0x6B 'e' 0x65 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 name2: … strncpy(mixed, name1, 25); strncat(mixed, \" & \", 25); strncat(mixed, name2, 25); … … 'Z' 0x5A 'e' 0x65 'k' 0x6B 'e' 0x65 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 mixed: '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 What’s happening with strings? Systems Programming 2025 Ch. 2: Introduction to C 61 … mixed: 'R' 0x52 'o' 0x6F 's' 0x73 'a' 0x61 'l' 0x6C 'i' 0x69 'n' 0x6E 'd' 0x64 'a' 0x61 ' ' 0x20 '&' 0x26 ' ' 0x20 'Z' 0x5A 'e' 0x65 'k' 0x6B 'e' 0x65 '\\0' 0x00 '\\0' 0x00 … mixed: 'R' 0x52 'o' 0x6F 's' 0x73 'a' 0x61 'l' 0x6C 'i' 0x69 'n' 0x6E 'd' 0x64 'a' 0x61 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 … mixed: 'R' 0x52 'o' 0x6F 's' 0x73 'a' 0x61 'l' 0x6C 'i' 0x69 'n' 0x6E 'd' 0x64 'a' 0x61 ' ' 0x20 '&' 0x26 ' ' 0x20 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 strncpy(mixed, name1, 25); strncat(mixed, \" & \", 25); strncat(mixed, name2, 25); … 'Z' 0x5A 'e' 0x65 'k' 0x6B 'e' 0x65 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 mixed: '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 '\\0' 0x00 Summary: C arrays • Arrays of basic types • Multidimensional arrays • Initializers • Strings • Arrays of ASCII characters • Null-terminated • String library 62Systems Programming 2025 Ch. 2: Introduction to C We’ll see a lot more C as the course progresses… 2.7: The C Preprocessor Computer Architecture and Systems Programming Systems Programming 2025 Ch. 2: Introduction to C 63 GNU gcc Toolchain cpp cc1 as ldC source executable .c,.h .i .s .o gcc –S foo.c gcc –c foo.c gcc –o bar foo.c bar.c 64 gcc –E foo.c Systems Programming 2025 Ch. 2: Introduction to C The C Preprocessor #include <file1.h> #include \"file2.h\" • Include the “header” file inline in the source code • Basic mechanism for defining APIs • Use of <> or \"\" determines where to look for the file • Use <> for system headers • Use \"\" for your own headers • Included files can include other files • Beware of including files twice! Systems Programming 2025 Ch. 2: Introduction to C 65 Macro definitions #define FOO BAZ #define BAR(x) (x+3) … #undef FOO #define QUX • Token-based macro substitution • Any subsequent occurrence of FOO is replaced with BAZ • Until a #undef FOO • BAR(4) is replaced with (4+3) • Not 7! • BAR(hello) is replaced with (hello+3) • QUX is replaced with “” (null string, without quotes) Systems Programming 2025 Ch. 2: Introduction to C 66 Macros can be large • Macro expanding to a compound statement: • Problem: a semicolon is a null statement: 67 #define SKIP_SPACES(p, limit) \\ { char *lim = (limit); \\ while (p < lim) { \\ if (*p++ != ' ') { \\ p--; break; }}} if (*p != 0) SKIP_SPACES (p, my_limit); else ... Invalid C (expand it and see!) See: http://gcc.gnu.org/onlinedocs/cpp/Swallowing-the-Semicolon.html Systems Programming 2025 Ch. 2: Introduction to C Solution: swallow the semicolon • Make macro expand to single statement: • Previous example expands to: • Compiler will remove the loop 68 #define SKIP_SPACES(p, limit) \\ do { char *lim = (limit); \\ while (p < lim) { \\ if (*p++ != ' ') { \\ p--; break; }}} \\ while (0) if (*p != 0) do { .. } while(0); else ... Systems Programming 2025 Ch. 2: Introduction to C Preprocessor conditionals #if expression … (text 1) #else … (text 2) #endif • Text 1 is used if the expression evaluates to \"true\" (non-zero), otherwise Text 2 • #else and #elif are optional • CPP has to evaluate expression • Literals, operators • Other macros • defined(m) Systems Programming 2025 Ch. 2: Introduction to C 69 Preprocessor conditionals #ifdef FOO … (text 1) #else … (text 2) #endif #ifndef BAR … (text 1) #else … (text 2) #endif • Text 1 is used if a macro FOO is defined, otherwise Text 2 • Opposite for BAR • #else is optional • Shorthand for • #if defined(FOO) • #if !defined(BAR) Systems Programming 2025 Ch. 2: Introduction to C 70 Token manipulation in the preprocessor • Example: a table mapping commands to their functions. • But: {\"quit\", quit_command} - seems redundant; better might be: COMMAND(quit) • How can we define this macro? Systems Programming 2025 Ch. 2: Introduction to C 71 struct command { char *name; void (*function) (); }; struct command commands[] = { { \"quit\", quit_command}, { \"help\", help_command}, ... }; Stringizing and token pasting (concatenation) 1. #define COMMAND(c) { \"c\", c_command } ? No: COMMAND(quit)  { \"c\", c_command } 2. #define COMMAND(c) { #c, c _command } ? No: COMMAND(quit)  {\"quit\", quit _command } 3. #define COMMAND(c) { #c, c ## _command } ? Yes! COMMAND(quit)  {\"quit\", quit_command } Systems Programming 2025 Ch. 2: Introduction to C 72    Source code: chapter 2 → concat Predefined macros For example: • __FILE__ : The name of the file being processed. • __LINE__ : The line number of this usage of the macro. • __DATE__ : The date when the preprocessor is running • __TIME__ : The time at which the preprocessor is being run. __STDC__ : defined if this is an ANSI Standard C compiler • __STDC_VERSION__ : the version of Standard C being compiled. … and many other non-standard extensions. Systems Programming 2025 Ch. 2: Introduction to C 73 CPP Summary • Toolchain • #include \"\" and #include <> • #define • Swallowing the semicolon • #if, #ifdef, #ifndef • Stringizing with #, concatenating (token pasting) with ## • Predefined macros 74Systems Programming 2025 Ch. 2: Introduction to C 2.8: Modularity Computer Architecture and Systems Programming Systems Programming 2025 Ch. 2: Introduction to C 75 Declarations vs. Definitions • A declaration says something exists, somewhere: • A definition says what it is: 76 char *strncpy(char *dest, const char *src, size_t n); A \"prototype\" Systems Programming 2025 Ch. 2: Introduction to C char *strncpy(char *dest, const char *src, size_t n) { size_t i; for (i = 0; i < n && src[i] != '\\0'; i++) { dest[i] = src[i]; } for ( ; i < n; i++) { dest[i] = '\\0'; } return dest; } Declarations vs. Definitions • C deals with \"compilation units\" • A C file, plus everything it includes. • Declarations can be annotated with: • extern: definition is somewhere else, either in this compilation unit or another • static: definition (also static) is in this compilation unit, and can't be seen outside it. 77Systems Programming 2025 Ch. 2: Introduction to C Global variables are also declared 78 extern const char *banner; // Defined in some other file static int priv_count; // Defined in this file Declarations: static int priv_count = 0; // Only in scope in this unit Elsewhere in this compilation unit: const char *banner = \"Welcome to Barrelfish\"; In some other compilation unit: We'll see all this in more detail later when we look at Linking Systems Programming 2025 Ch. 2: Introduction to C Modularity in C • Module: self-contained piece of a larger program • Consists of: • Externally visible: • functions to be invoked • typedefs and perhaps global variables • cpp macros • Internal functions, types, global variables • That clients should not look at 79 The module's interface Systems Programming 2025 Ch. 2: Introduction to C C header files • Specify interfaces with header files • Module foo has interface in foo.h • Clients of foo #include \"foo.h\" • foo.h contains no definitions • only external declarations • Implementation typically in foo.c • Also includes foo.h • Contains no external declarations • only definitions and internal declarations 80Systems Programming 2025 Ch. 2: Introduction to C cpp idiom for header files #ifndef __FILE_H_ #define __FILE_H_ … (declarations, macros) #endif // __FILE_H_ • cpp boilerplate ensures file contents only appear once • Never #include a .c file! “file.h”: Systems Programming 2025 Ch. 2: Introduction to C 81 Summary • Declarations vs. definitions • extern and static • Modularity and header files • cpp idiom for header files 82Systems Programming 2025 Ch. 2: Introduction to C 2.9: Assertions Computer Architecture and Systems Programming Systems Programming 2025 Ch. 2: Introduction to C 83 Assertions assert( <scalar expression> ); • At run time, evaluate the expression. • If true, do nothing • If false: • Print “file.c:line: func: Assertion `expr' failed.“ • Abort (dump core) Systems Programming 2025 Ch. 2: Introduction to C 84 Assertion example #include <assert.h> // It’s a bug to call this with null a or b void array_copy(int a[], int b[], size_t count) { int i; assert(a != NULL); assert(b != NULL); for(i=0; i<count; i++) { a[i] = b[i]; } } int main(int argc, char *argv[]) { // This is not going to go well... array_copy(NULL, NULL, 0); return 0; } Systems Programming 2025 Ch. 2: Introduction to C 85 $ ./a.out a.out: assert_text.c:8: array_copy: Assertion `a != ((void *)0)' failed. Aborted $ Assertions • Almost a poor person’s contracts • Checked at runtime, not compile time • Can be compiled out (-DNDEBUG)  no runtime overhead in finished(!) code • It’s a macro (why?)  Should not contain side-effects! • Assertions are of no use to the user! Systems Programming 2025 Ch. 2: Introduction to C 86 Don’t use assertions like this: #include <assert.h> #include <stdio.h> int main(int argc, char *argv[]) { assert( argc != 2 ); ... FILE *f = fopen(argv[1]); assert( f != NULL ); ... } These conditions are not bugs! Systems Programming 2025 Ch. 2: Introduction to C 87 Assertions are for programmers to find bugs, not for programs to detect errors. What is assert(), then? • Several ways to do this, e.g.: • See also <assert.h> Systems Programming 2025 Ch. 2: Introduction to C 88 #define my_assert(_e) do { \\ if (!(_e)) { \\ fprintf(stderr,\"Assertion '%s' failed at %s:%d\\n\", #_e, __FILE__,__LINE__); \\ exit(1); \\ } \\ } while(0) Source code: chapter 2 → assert 2.10: Style Computer Architecture and Systems Programming Systems Programming 2025 Ch. 2: Introduction to C 89 Style advice • Pick a code style and follow it • Or use the existing one • Write clear code: • Indent to show structure • When in doubt, use parentheses • Break up complex expressions • Use good names: • Descriptive names for globals • Short names for locals • Active names for functions • Use character constants • No magic numbers • const, enum, or #define • Use C idioms • else if for multiway decisions • Canonical for() tests • Beware switch() fall-through • Avoid function macros • Functions are just as fast Systems Programming 2025 Ch. 2: Introduction to C 90 Don’t write C like this: • Although it has a certain kind of fascination… #define P(X)j=write(1,X,1) #define C 39 int M[5000]={2},*u=M,N[5000],R=22,a[4],l[]={0,-1,C-1,-1},m[]={1,-C,-1,C},*b=N, *d=N,c,e,f,g,i,j,k,s;main(){for(M[i=C*R-1]=24;f|d>=b;){c=M[g=i];i=e;for(s=f=0; s<4;s++)if((k=m[s]+g)>=0&&k<C*R&&l[s]!=k%C&&(!M[k]||!j&&c>=16!=M[k]>=16))a[f++ ]=s;if(f){f=M[e=m[s=a[rand()/(1+2147483647/f)]]+g];j=j<f?f:j;f+=c&-16*!j;M[g]= c|1<<s;M[*d++=e]=f|1<<(s+2)%4;}else e=d>b++?b[-1]:e;}P(\" \");for(s=C;--s;P(\"_\") )P(\" \");for(;P(\"\\n\"),R--;P(\"|\"))for(e=C;e--;P(\"_ \"+(*u++/8)%2))P(\"| \"+(*u/4)%2 );} (Carl Shapiro 1985, International Obfuscated C Code Contest “Grand prize for most well-rounded in confusion”) Systems Programming 2025 Ch. 2: Introduction to C 91 Don’t write C like this: Systems Programming 2025 Ch. 2: Introduction to C 92 #define P(X)j=write(1,X,1) #define C 39 int M[5000]={2},*u=M,N[5000],R=22,a[4],l[]={0,-1,C-1,-1},m[]={1,-C,-1,C},*b=N, *d=N,c,e,f,g,i,j,k,s;main(){for(M[i=C*R-1]=24;f|d>=b;){c=M[g=i];i=e;for(s=f=0; s<4;s++)if((k=m[s]+g)>=0&&k<C*R&&l[s]!=k%C&&(!M[k]||!j&&c>=16!=M[k]>=16))a[f++ ]=s;if(f){f=M[e=m[s=a[rand()/(1+2147483647/f)]]+g];j=j<f?f:j;f+=c&-16*!j;M[g]= c|1<<s;M[*d++=e]=f|1<<(s+2)%4;}else e=d>b++?b[-1]:e;}P(\" \");for(s=C;--s;P(\"_\") )P(\" \");for(;P(\"\\n\"),R--;P(\"|\"))for(e=C;e--;P(\"_ \"+(*u++/8)%2))P(\"| \"+(*u/4)%2 );} (Carl Shapiro 1985, International Obfuscated C Code Contest “Grand prize for most well-rounded in confusion”) Subtle use of C’s little- known comma operator! Strings are pointers too! An assignment is also an expression.","libVersion":"0.5.0","langs":""}