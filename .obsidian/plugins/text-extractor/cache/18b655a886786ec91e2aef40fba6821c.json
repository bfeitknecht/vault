{"path":"sem4/FMFP/VRL/extra/slides/04-axiomatic-semantics.pdf","text":"Formal Methods and Functional Programming Axiomatic Semantics Peter M¨uller Programming Methodology Group ETH Zurich Program Correctness Formal semantics can be used to prove the correctness of a program Partial correctness expresses that if a program terminates then there will be a certain relationship between the initial and the final state Total correctness expresses that a program will terminate and there will be a certain relationship between the initial and the final state The relationship is expressed by a formal specification total correctness = partial correctness + termination David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 142 4. Axiomatic Semantics 4.1 Motivation [N&N, p. 169–175] 4.2 Hoare Logic 4.3 Soundness and Completeness David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 143 Program Correctness: Example Consider the factorial statement y := 1; while not x = 1 do y := y * x; x := x - 1 end Specification: The final value of y is the factorial of the initial value of x The statement is partially correct It does not terminate for x < 1 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 144 Formal Specification Specification: The final value of y is the factorial of the initial value of x We can express the specification formally based on a formal semantics ∀σ, σ′. ⊢ ⟨y := 1;while not x = 1 do y := y * x;x := x - 1 end, σ⟩ → σ′ ⇒ σ′(y) = σ(x)! ∧ σ(x) > 0 This specification expresses partial correctness using big-step semantics We could have used small-step semantics to formulate the property, instead David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 145 Correctness Proof We prove partial correctness in three steps Step 1: The body of the loop satisfies ∀σ, σ′′. ⊢ ⟨y := y*x;x := x-1, σ⟩ → σ′′ ∧ σ′′(x) > 0 ⇒ σ(y) × σ(x)! = σ′′(y) × σ′′(x)! ∧ σ(x) > 0 Step 2: The loop satisfies ∀σ, σ′′. ⊢ ⟨while not x = 1 do y := y*x;x := x-1 end, σ⟩ → σ′′ ⇒ σ(y) × σ(x)! = σ′′(y) ∧ σ′′(x) = 1 ∧ σ(x) > 0 Step 3: The whole statement is partially correct ∀σ, σ′. ⊢ ⟨y := 1;while not x = 1 do y := y*x;x := x-1 end, σ⟩ → σ′ ⇒ σ′(y) = σ(x)! ∧ σ(x) > 0 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 146 Proof: Step 1—Loop Body Let σ and σ′′ be arbitrary. To prove the implication, we assume the left-hand-side and prove the right. Since we have ⊢ ⟨y := y*x;x := x-1, σ⟩ → σ′′, we can assume that both ⊢ ⟨y := y*x, σ⟩ → σ′ and ⊢ ⟨x := x-1, σ′⟩ → σ′′ for some σ′ (the last rule applied in the original derivation must be SeqNS ) Since these two derivations must end in the AssNS rule, we must have σ′ = σ[y ↦ A[[y*x]]σ] and σ′′ = σ′[x ↦ A[[x-1]]σ′], which together imply that σ′′ = σ[y ↦ σ(y) × σ(x)][x ↦ σ(x)-1] By σ′′(x) > 0, we calculate σ′′(y) × σ′′(x)! = σ(y) × σ(x) × (σ(x)-1)! = σ(y) × σ(x)! Finally, by σ′′(x) = σ(x)-1, we get σ(x) > 0 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 147 Proof: Step 2—Loop Step 2: The loop satisfies ∀σ, σ′′. ⊢ ⟨while not x = 1 do y := y*x;x := x-1 end, σ⟩ → σ′′ ⇒ σ(y) × σ(x)! = σ′′(y) ∧ σ′′(x) = 1 ∧ σ(x) > 0 We prove this property by induction on the shape of the derivation tree: Define P(T ): P(T ) ≡ ∀σ, σ′′. root(T ) ≡ ⟨while not x = 1 do y := y*x;x := x-1 end, σ⟩ → σ′′ ⇒ σ(y) × σ(x)! = σ′′(y) ∧ σ′′(x) = 1 ∧ σ(x) > 0 We prove P(T ) for arbitrary T , with the induction hypothesis ∀T ′ ⊏ T .P(T ′) (i.e., we can assume the property for all subderivations of the derivation tree T ). David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 148 Proof: Step 2—Loop (Case WhFNS) We prove P(T ) for arbitrary T , with the induction hypothesis ∀T ′ ⊏ T .P(T ′) (i.e., we can assume the property for all subderivations of the derivation tree T . Let σ, σ′′ be arbitrary. We assume the property above for root(T ), and need to show that σ(y) × σ(x)! = σ′′(y) ∧ σ′′(x) = 1 ∧ σ(x) > 0 We consider the two possible cases for the last rule applied in T : WhFNS and WhTNS Case WhFNS : From the form of the rule, we must have σ(x) = 1 and σ = σ′′ Since 1 = 1!, we get σ(y) × σ(x)! = σ(y) = σ′′(y) We also immediately get σ′′(x) = 1 and σ(x) > 0 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 149 Proof: Step 2—Loop (Case WhTNS) From the form of the rule, we know that two subderivations exist: for some σ′′′, (1) ⊢ ⟨y := y*x;x := x-1, σ⟩ → σ′′′ (2) ⊢ ⟨while not x = 1 do y := y*x;x := x-1 end, σ′′′⟩ → σ′′ Applying the induction hypothesis to (2) yields σ′′′(y) × σ′′′(x)! = σ′′(y) ∧ σ′′(x) = 1 ∧ σ′′′(x) > 0 By (1), σ′′′(x) > 0, and Proof Step 1, we get σ(y) × σ(x)! = σ′′′(y) × σ′′′(x)! ∧ σ(x) > 0 Combining these results yields, as required: σ(y) × σ(x)! = σ′′(y) ∧ σ′′(x) = 1 ∧ σ(x) > 0 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 150 Proof: Step 3—Factorial Statement Step 3: The whole statement is partially correct: ∀σ, σ′. ⊢ ⟨y := 1;while not x = 1 do y := y*x;x := x-1 end, σ⟩ → σ′ ⇒ σ′(y) = σ(x)! ∧ σ(x) > 0 Let σ, σ′ be arbitrary. The last rule applied in the assumed derivation must be SeqNS . From the form of the rule, we get, for some σ′′: (1) ⊢ ⟨y := 1, σ⟩ → σ′′ (2) ⊢ ⟨while not x = 1 do y := y*x;x := x-1 end, σ′′⟩ → σ′ By (1), we get σ′′ = σ[y ↦ 1] and, thus, σ′′(x) = σ(x) By (2), and Proof Step 2, we get σ′′(y) × σ′′(x)! = σ′(y) ∧ σ′(x) = 1 ∧ σ′′(x) > 0 We conclude, as required: 1 × σ(x)! = σ′(y) ∧ σ(x) > 0 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 151 Verification Example: Observations We can prove correctness of a program based on a formal semantics The proof would also be possible with the small-step semantics, but even more complicated Proofs are too detailed to be practical We have to consider how whole states are modified We would like to focus on certain properties of states We need to manually decompose the proof into suitable parts For each loop, we need to formulate a separate induction on derivations Axiomatic Semantics provides a way of constructing these proofs conveniently Proofs can focus only on essential properties of interest Decomposing the program into smaller parts happens naturally The induction for reasoning about loops is “built” into the semantic rule for loops David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 152 4. Axiomatic Semantics 4.1 Motivation 4.2 Hoare Logic 4.2.1 Hoare Triples and Assertions [N&N, p. 175–178] 4.2.2 Derivation System [N&N, p. 178–182] 4.2.3 Total Correctness (Termination) [N&N, p. 191–196] 4.3 Soundness and Completeness David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 153 Hoare Triples Properties of programs are specified as Hoare triples { P } s { Q } where s is a statement and P and Q are assertions (about the state) Terminology The assertion P is called the precondition of a triple { P } s { Q } The assertion Q is called the postcondition of a triple { P } s { Q } Assertions are boolean expressions, with some additional features (explained shortly). We use P, Q, R as meta-variables over assertions. David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 154 Meaning of Hoare Triples The informal meaning of { P } s { Q } is If P evaluates to true in an initial state σ, and if the execution of s from σ terminates in a state σ′ then Q will evaluate to true in σ′ This meaning describes partial correctness, that is, termination is not an essential property It is also possible to assign different meanings to Hoare Triples Total correctness interpretation (see later) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 155 Hoare Triples: Example Attempted specification of the factorial statement: { true } y := 1;while not x = 1 do y := y*x;x := x-1 end { y = x! ∧ x > 0 } In general, this Hoare triple is not correct. For example: Consider an initial state σzero[x ↦ 2][y ↦ 0] The final state will be σzero[x ↦ 1][y ↦ 2] We need to express that y in the final state is the factorial of x in the initial state We need a way for assertions to describe properties not just of the current state, but also of the initial state David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 156 Logical Variables We allow assertions to contain logical variables Logical variables may occur only in assertions Logical variables are not program variables and may, thus, not be accessed in programs; in particular, they are never assigned to Logical variables can be used to “save” values in the initial state, so that they can be referred to later { x = N } y := 1;while not x = 1 do y := y*x;x := x-1 end { y = N! ∧ N > 0 } States map logical variables (and program variables) to their values David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 157 Assertion Language Pre- and postconditions are assertions, that is, boolean expressions plus logical variables In particular, we will use program boolean expressions b as assertions It is common in practice to use a richer set of expressions for assertions, for instance, to include quantification We will use additional expressions when it is convenient (e.g., x!) We assume that the substitution lemma from the exercises still holds when we use an extended assertion language: B[[P[x ↦ e]]]σ = B[[P]]σ[x ↦ A[[e]]σ] We will use the following convenient notations “P1 ∧ P2” for “P1 and P2” “P1 ∨ P2” for “P1 or P2” “¬P” for “not P” David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 158 4. Axiomatic Semantics 4.1 Motivation 4.2 Hoare Logic 4.2.1 Hoare Triples and Assertions 4.2.2 Derivation System 4.2.3 Total Correctness (Termination) 4.3 Soundness and Completeness David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 159 Axiomatic Semantics: Derivation System We formalize an axiomatic semantics of IMP by describing the valid Hoare triples This is done by a derivation system The derivation rules specify which triples can be derived for each statement The premises and conclusions of the derivation rules are Hoare triples { P } s { Q } Derivation trees (using the rules presented next) are defined as before Similarly to the other derivation systems we have studied, we write ⊢ { P } s { Q } if and only if there exists a (finite) derivation tree ending in { P } s { Q } ⊢ { P } s { Q } ⇔ ∃T .root(T ) ≡ { P } s { Q } David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 160 Axiomatic Semantics of IMP skip does not modify the state (SkipAx ) { P } skip { P } x := e assigns the value of e to variable x (AssAx ) { P[x ↦ e] } x := e { P } Let σ be the initial state Precondition: B[[P[x ↦ e]]]σ, which is equivalent to B[[P]]σ[x ↦ A[[e]]σ] (substitution lemma) Final state: σ[x ↦ A[[e]]σ] Consequently, B[[P]] holds in the final state Reminder: these are rule schemes (they can be instantiated by replacing meta-variables) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 161 Axiomatic Semantics of IMP (cont’d) Sequential composition s;s ′ { P } s { Q } { Q } s ′ { R } (SeqAx ) { P } s;s ′ { R } Conditional statement if b then s1 else s2 end { b ∧ P } s { Q } { ¬b ∧ P } s ′ { Q } (IfAx ) { P } if b then s else s ′ end { Q } Loop statement while b do s end { b ∧ P } s { P } (WhAx ) { P } while b do s end { ¬b ∧ P } The assertion P is the loop invariant David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 162 Axiomatic Semantics of IMP (cont’d) The rules so far manipulate assertions syntactically For example, so far, we cannot derive the triple { x = 4 ∧ y = 5 } skip { y = 5 ∧ x = 4 } (assertions are not identical, so this is not an instance of the SkipAx rule) During proofs, we often need to perform semantic reasoning (e.g., applying mathematical properties of factorial, arithmetic rules, etc.) Semantic entailment expresses these reasoning steps: we write P ⊧ Q iff “for all states σ, B[[P]]σ = tt implies B[[Q]]σ = tt” The rule of consequence allows semantic entailments in derivations { P′ } s { Q ′ } (ConsAx ) { P } s { Q } if P ⊧ P′ and Q′ ⊧ Q We can strengthen preconditions (P cannot be weaker than P ′) We can weaken postconditions (Q cannot be stronger than Q′) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 163 Axiomatic Semantics of IMP (cont’d) The rules so far manipulate assertions syntactically For example, so far, we cannot derive the triple { x = 4 ∧ y = 5 } skip { y = 5 ∧ x = 4 } (assertions are not identical, so this is not an instance of the SkipAx rule) During proofs, we often need to perform semantic reasoning (e.g., applying mathematical properties of factorial, arithmetic rules, etc.) Semantic entailment expresses these reasoning steps: we write P ⊧ Q iff “for all states σ, B[[P]]σ = tt implies B[[Q]]σ = tt” The rule of consequence allows semantic entailments in derivations { P′ } s { Q ′ } (ConsAx ) { P } s { Q } if P ⊧ P′ and Q′ ⊧ Q We can strengthen preconditions (P cannot be weaker than P ′) We can weaken postconditions (Q cannot be stronger than Q′) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 163 Axiomatic Semantics of IMP (cont’d) The rules so far manipulate assertions syntactically For example, so far, we cannot derive the triple { x = 4 ∧ y = 5 } skip { y = 5 ∧ x = 4 } (assertions are not identical, so this is not an instance of the SkipAx rule) During proofs, we often need to perform semantic reasoning (e.g., applying mathematical properties of factorial, arithmetic rules, etc.) Semantic entailment expresses these reasoning steps: we write P ⊧ Q iff “for all states σ, B[[P]]σ = tt implies B[[Q]]σ = tt” The rule of consequence allows semantic entailments in derivations { P′ } s { Q ′ } (ConsAx ) { P } s { Q } if P ⊧ P′ and Q′ ⊧ Q We can strengthen preconditions (P cannot be weaker than P ′) We can weaken postconditions (Q cannot be stronger than Q′) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 163 Derivation Trees: Example 1 Prove that the following statement swaps the values in the variables x and y (z:=x; x:=y); y:=z We can build the following derivation tree (AssAx ) { P } z:=x { z = X0 ∧ y = Y0 } (ConsAx )∗ { P } z:=x { y = Y0 ∧ z = X0 } (AssAx ) { y = Y0 ∧ z = X0 } x:=y { Q′ } (SeqAx ) { P } z:=x; x:=y { Q′ } (AssAx ) { Q′ } y:=z { Q } (SeqAx ) { P } (z:=x; x:=y); y:=z { Q } ∗since P ⊧ P and z = X0 ∧ y = Y0 ⊧ y = Y0 ∧ z = X0 where we write: P for x = X0 ∧ y = Y0 Q for x = Y0 ∧ y = X0 Q′ for x = Y0 ∧ z = X0 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 164 Derivation Trees: Example 2 Consider the non-terminating loop while true do skip end We can build the following derivation tree (SkipAx ) { true } skip { true } (ConsAx ) 1 { true ∧ true } skip { true } (WhAx ) { true } while true do skip end { ¬true ∧ true } (ConsAx )2 { true } while true do skip end { ¬true } 1true ∧ true ⊧ true 2¬true ∧ true ⊧ ¬true This proof illustrates that we have partial correctness David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 165 Proof Outlines Derivation trees tend to get very large and are, thus, inconvenient to write Most statements are written many times Many assertions are written many times An alternative is to group the assertions around the program text We write assertions before and after each statement to indicate which properties hold in the states before and after the execution of this statement David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 166 Proof Outlines: Notation We write instances of the SkipAx and AssAx rules as: { P } skip { P } { P[x ↦ e] } x := e { P } We write an instance of the rule for sequential composition as: { P } s1; { Q } s2 { R } This expresses ⊢ { P } s1 { Q }, ⊢ { Q } s2 { R }, and ⊢ { P } s1;s2 { R } Note: we write each statement and the intermediate assertion Q once David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 167 Proof Outlines: Notation (cont’d) We write an instance of the rule for conditional statements as: { P } if b then { b ∧ P } s1 { Q } else { ¬b ∧ P } s2 { Q } end { Q } We write an instance of the rule for loops as: { P } while b do { b ∧ P } s { P } end { ¬b ∧ P } David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 168 Proof Outlines: Notation (cont’d) We write an instance of the rule of consequence as: { P } ⊧ { P′ } s { Q′ } ⊧ { Q } We omit the entailment step when P and P′ or Q and Q′ are syntactically identical. For example, we may also write: { P } s { Q′ } ⊧ { Q } { P } ⊧ { P ′ } s { Q } David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 169 Proof Outlines: Example Back to our swap-example: (z:=x; x:=y); y:=z Proof outline: { x = X0 ∧ y = Y0 } ⊧ { y = Y0 ∧ x = X0 } z := x; { y = Y0 ∧ z = X0 } x := y; { x = Y0 ∧ z = X0 } y := z { x = Y0 ∧ y = X0 } Proof outlines are often best developed bottom-up David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 170 Verification of Factorial Statement { x = N } y := 1;while not x = 1 do y := y*x;x := x-1 end { y = N! ∧ N > 0 } Determining the loop invariant Invariant: x > 0 ⇒ y*x! = N! ∧ N ≥ x David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 171 Verification of Factorial Statement { x = N } y := 1;while not x = 1 do y := y*x;x := x-1 end { y = N! ∧ N > 0 } Determining the loop invariant Iteration 0 1 2 i N-1 x N N-1 N-2 N-i 1 y 1 N N*(N-1) N*(N-1)* . . . *(N-i + 1) N! Invariant: x > 0 ⇒ y*x! = N! ∧ N ≥ x David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 171 Verification of Factorial Statement { x = N } y := 1;while not x = 1 do y := y*x;x := x-1 end { y = N! ∧ N > 0 } Determining the loop invariant Iteration 0 1 2 i N-1 x N N-1 N-2 N-i 1 y 1 N N*(N-1) N*(N-1)* . . . *(N-i + 1) N! Invariant: x > 0 ⇒ y*x! = N! ∧ N ≥ x David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 171 Proof Outline for Factorial Statement { x = N } ⊧ { x > 0 ⇒ 1*x! = N! ∧ N ≥ x } y := 1; { x > 0 ⇒ y*x! = N! ∧ N ≥ x } while not x = 1 do { x ≠ 1 ∧ (x > 0 ⇒ y*x! = N! ∧ N ≥ x) } ⊧ { x-1 > 0 ⇒ y*x*(x-1)! = N! ∧ N ≥ x-1 } y := y*x; { x-1 > 0 ⇒ y*(x-1)! = N! ∧ N ≥ x-1 } x := x-1 { x > 0 ⇒ y*x! = N! ∧ N ≥ x } end { x = 1 ∧ (x > 0 ⇒ y*x! = N! ∧ N ≥ x) } ⊧ { y = N! ∧ N > 0 } David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 172 4. Axiomatic Semantics 4.1 Motivation 4.2 Hoare Logic 4.2.1 Hoare Triples and Assertions 4.2.2 Derivation System 4.2.3 Total Correctness (Termination) 4.3 Soundness and Completeness David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 173 Total Correctness We introduce an alternative form of Hoare triple { P } s { ⇓ Q } The informal meaning of { P } s { ⇓ Q } is If P evaluates to true in the initial state σ then the execution of s from σ terminates and Q will evaluate to true in the final state This meaning describes total correctness, that is, termination is required We do not mix these triples with those of partial correctness; the two form two separate axiomatic semantics (and corresponding derivation systems) However, all total correctness derivation rules are analogous to those for partial correctness, except for the rule for loops David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 174 Loop Variants Termination is proved using loop variants A loop variant is an expression that evaluates to a value in a well-founded set (for instance, N) before each iteration Each loop iteration must decrease the value of the loop variant The loop has to terminate when a minimal value of the well-founded set is reached (or earlier than this) For example: x := 5; while x # 0 do x := x - 1 end x is a possible loop variant for this loop David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 175 While Rule for Total Correctness For simplicity, we consider loop variants that evaluate to values in N We use arithmetic expressions e of IMP to represent loop variants We prove explicitly that the value of e will be non-negative before each loop iteration Intuition: a correct loop variant provides an upper bound on the number of loop iterations Total correctness derivation rule for loops: { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx ) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ⊧ 0 ≤ e where Z is a fresh logical variable (not used in P) Note: in practice, other well-founded sets and orderings can be useful David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 176 Total Correctness of Factorial { x = N ∧ x > 0 } y := 1;while not x = 1 do y := y*x;x := x-1 end { ⇓ y = N! } Invariant: P ≡ x > 0 ∧ N > 0 ∧ y*x! = N! Variant: x In the proof outline (on the next slide) we explicitly note the side-condition for the while-rule, concerning the loop variant David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 177 Proof Outline for Factorial Statement { x = N ∧ x > 0 } ⊧ { x > 0 ∧ N > 0 ∧ 1*x! = N! } y := 1; { x > 0 ∧ N > 0 ∧ y*x! = N! } while not x = 1 do ∗ { x ≠ 1 ∧ x > 0 ∧ N > 0 ∧ y*x! = N! ∧ x = Z } ⊧ { x-1 > 0 ∧ N > 0 ∧ (y*x)*(x-1)! = N! ∧ x-1 < Z } y := y*x; { x-1 > 0 ∧ N > 0 ∧ y*(x-1)! = N! ∧ x-1 < Z } x := x-1 { ⇓ x > 0 ∧ N > 0 ∧ y*x! = N! ∧ x < Z } end { ⇓ ¬¬x = 1 ∧ x > 0 ∧ N > 0 ∧ y*x! = N! } ⊧ { ⇓ y = N! } ∗x ≠ 1 ∧ x > 0 ∧ N > 0 ∧ y*x! = N! ⊧ 0 ≤ x David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 178 4. Axiomatic Semantics 4.1 Motivation 4.2 Hoare Logic 4.3 Soundness and Completeness [N&N, p. 183–191] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 179 Motivation Developing an axiomatic semantics is difficult Soundness: If a property can be proved then it does indeed hold An unsound derivation system does not provide any guarantees Unsound verification may miss errors (false negatives) Completeness: If a property does hold then it can be proved With an incomplete derivation system, a program might be correct, but we cannot prove it Incomplete verification may produce spurious errors (false positives) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 180 Unsoundness: Example { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhUAx ) { P ∧ 0 ≤ e } while b do s end { ⇓ ¬b ∧ P } With e ≡ x, we can derive: (AssAx ) { true ∧ x-1 < Z } x := x-1 { ⇓ true ∧ x < Z } (ConsAx ) { true ∧ true ∧ x = Z } x := x-1 { ⇓ true ∧ x < Z } (WhUAx ) { true ∧ 0 ≤ x } while true do x := x-1 end { ⇓ ¬true ∧ true } (ConsAx ) { 0 ≤ x } while true do x := x-1 end { ⇓ true } This derivation is not sound (the derived triple does not hold) The rule does not ensure that the loop variant is non-negative before each loop iteration David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 181 Incompleteness: Example { b ∧ P } s { ⇓ P } { b ∧ e = Z } s { ⇓ e < Z } { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ⊧ 0 ≤ e This rule requires proving separately that the invariant is preserved and the variant is decreased a := 1; while 0 < x do x := x - a end With this rule, we cannot prove termination for the loop on the left Without assuming the loop invariant in the second premise, we have no information about the value of a If a was zero, the state would not change during an iteration, so no expression can possibly decrease and, thus, no variant can exist Even our earlier WhTotAx rule is incomplete because some examples require more complex variants, e.g., lexicographic ordering in the Ackermann function David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 182 Soundness and Completeness Soundness and completeness can be proved w.r.t. an operational semantics (here, big-step semantics) The partial correctness triple { P } s { Q } is valid, written as ⊧ { P } s { Q }, iff: ∀σ, σ′. B[[P]]σ = tt ∧ ⊢ ⟨s, σ⟩ → σ′ ⇒ B[[Q]]σ′ = tt This is the intuitive interpretation of triples: ⊧ { P } s { Q } is true if, whenever we start execution of s from a state in which P holds, if the execution terminates, then Q will hold in the final state Conversely, recall that ⊢ { P } s { Q } is defined purely in terms of the derivation rules of the axiomatic semantics Soundness: ⊢ { P } s { Q } ⇒ ⊧ { P } s { Q } Completeness: ⊧ { P } s { Q } ⇒ ⊢ { P } s { Q } David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 183 Theorem Soundness and Completeness Theorem (Partial Correctness): For all partial correctness triples { P } s { Q } of IMP we have ⊢ { P } s { Q } ⇔ ⊧ { P } s { Q } David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 184 Summary: Axiomatic Semantics Axiomatic semantics is concerned with specific properties of the effect of executing programs allows for succinct proofs about program properties Axiomatic semantics is used to verify programs Partial correctness Total correctness Other properties, e.g., resource consumption The derivation system for partial correctness of IMP programs is sound and complete David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 185","libVersion":"0.3.2","langs":""}