{"path":"sem4/DMDB/VRL/extra/slides/DMDB-s04-null,view.pdf","text":"Data Modeling and Databases Spring Semester 2025 Nulls and Views Nulls and Views Gustavo Alonso Institute of Computing Platforms Department of Computer Science ETH Zürich 1 Lessons learned so far • We have learned about: • Relational model • Relational algebra • Relational calculus • SQL • Entity Relationship model • This has given us the formal underpinnings of the language SQL and how data is managed in a database engine • Now we start looking into structuring data, the issues that arise outside formal models, and how to address them Nulls and Views 2 Missing data = Nulls Entity-Relationship Model 3 Incomplete Information • So far, we assume that all information in a relation is KNOWN. • But in practice, we often have Incomplete Information in the data. • E.g., in web forms => Not Applicable. • E.g., Missing data (keeping a cell “EMPTY”) • … • How can we model incomplete information? • How can we query over a DB with incomplete information? • Very deep topic; we will only scratch the surface. LectureID Title CP ProfNr 5041 Networks 4 2126 5043 Theory 4 2127 Nulls and Views 4 Incomplete Information: NULL • One way to model incomplete information is to mark the values that we do not know with a special state NULL. • (There are other ways of encode incomplete information, NULL is the most popular one used in practice) • Let’s first look at what, logically, we are trying to achieve. There is a bunch of smarter ways to achieve it. • Real-world systems are messier. LectureID Title CP ProfNr 5041 Networks 4 2126 5043 Theory 4 2127NULL Nulls and Views 5 Query over NULL – Formal Semantics • What is the formal semantics of NULL? • It is a whole chapter in the Alice book... • NULL is a state, not a value pid name age 1 John 32 2 Anna 29 3 Kevin NULL pid name age 1 John 32 2 Anna 29 3 Kevin 1 pid name age 1 John 32 2 Anna 29 3 Kevin 2 pid name age 1 John 32 2 Anna 29 3 Kevin 30 Relation with NULL Possible Worlds without NULL ... SELECT * FROM Person WHERE age < 30; SELECT * FROM Person WHERE age < 30; SELECT * FROM Person WHERE age < 30; pid name age 2 Anna 29 3 Kevin 1 pid name age 2 Anna 29 3 Kevin 2 pid name age 2 Anna 29 SELECT * FROM Person WHERE age < 30; “Sure answer ” 2. DB is conservative when it tries to give you an answer. ? 1. NULL means “I don’t know”, which means that it could take any value in the domain. pid name age 2 Anna 29 Nulls and Views 6 Operations over NULL • Arithmetic: • (NULL + 1) -> NULL • (NULL * 0) -> NULL • Comparisons • (NULL = NULL) -> Unknown • (NULL < 13) -> Unknown • (NULL > NULL) -> Unknown • 3-value Logic: LectureID Title CP ProfNr 5001 Databases 4 NULL 5041 Networks 4 2126 5043 Theory 4 2127 Lecture SELECT * FROM Lecture WHERE ProfNr > 2200 OR ProfNr <= 2200; LectureID Title CP ProfNr 5041 Networks 4 2126 5043 Theory 4 2127 Both eval to Unknown Nulls and Views 7 Query Over NULL LectureID Title CP ProfNr 5001 Databases 4 NULL 5041 Networks 4 2126 5043 Theory 4 2127 Lecture SELECT * FROM Lecture WHERE ProfNr > 2200 OR ProfNr <= 2200; LectureID Title CP ProfNr 5041 Networks 4 2126 5043 Theory 4 2127 ▪ NULL introduces many corner cases in SQL that one needs to be careful about. SELECT * FROM Lecture; LectureID Title CP ProfNr 5001 Databases 4 NULL 5041 Networks 4 2126 5043 Theory 4 2127 Nulls and Views 8 Operations over NULL • NULL is a state, not a value: • (NULL = NULL) -> Unknown • (NULL IS NULL) -> True LectureID Title CP ProfNr 5001 Databases 4 NULL 5041 Networks 4 2126 5043 Theory 4 2127 Lecture SELECT * FROM Lecture WHERE ProfNr = NULL; SELECT * FROM Lecture WHERE ProfNr IS NULL; LectureID Title CP ProfNr LectureID Title CP ProfNr 5001 Databases 4 NULL Nulls and Views 9 NULL in Aggregations Emplid Name Department Salary 100 John Smith IT 2000 101 Jean Pellu NULL 2500 102 Mary Popins FINANCES 2000 103 Blas Merrieu NULL NULL 104 Joan Piquet IT 1000 105 Jose Gomez IT NULL Employee https://academy.vertabelo.com/blog/null-values-group-clause/ SELECT department FROM employee GROUP BY department; NULL in Group By: => All NULLs form a single group. Department IT FINANCES NULL Nulls and Views 10 NULL in Aggregations Emplid Name Department Salary 100 John Smith IT 2000 101 Jean Pellu NULL 2500 102 Mary Popins FINANCES 2000 103 Blas Merrieu NULL NULL 104 Joan Piquet IT 1000 105 Jose Gomez IT NULL Employee https://academy.vertabelo.com/blog/null-values-group-clause/ NULL in Values: => Most operators will ignore the NULL value. Department max(salary) IT 2000 FINANCES 2000 NULL 2500 SELECT department, max(salary) FROM employee GROUP BY department; Nulls and Views 11 NULL in Aggregations Emplid Name Department Salary 100 John Smith IT 2000 101 Jean Pellu NULL 2500 102 Mary Popins FINANCES 2000 103 Blas Merrieu NULL NULL 104 Joan Piquet IT 1000 105 Jose Gomez IT NULL Employee https://academy.vertabelo.com/blog/null-values-group-clause/ NULL in Values: => COUNT(*) will not ignore NULL.Department COUNT IT 3 FINANCES 1 NULL 2 SELECT department, count(*) FROM employee GROUP BY department; Nulls and Views 12 NULL in Aggregations Emplid Name Department Salary 100 John Smith IT 2000 101 Jean Pellu NULL 2500 102 Mary Popins FINANCES 2000 103 Blas Merrieu NULL NULL 104 Joan Piquet IT 1000 105 Jose Gomez IT NULL Employee https://academy.vertabelo.com/blog/null-values-group-clause/ NULL in Values: => COUNT(salary) will ignore NULL.Department COUNT IT 2 FINANCES 1 NULL 1 SELECT department, count(salary) FROM employee GROUP BY department; Nulls and Views 13 NULL in Aggregations Emplid Name Department Salary 100 John Smith IT NULL 101 Jean Pellu NULL NULL 102 Mary Popins FINANCES NULL 103 Blas Merrieu NULL NULL 104 Joan Piquet IT NULL 105 Jose Gomez IT NULL Employee https://academy.vertabelo.com/blog/null-values-group-clause/ NULL in Values: => When there is nothing => NULLDepartment COUNT IT NULL FINANCES NULL NULL NULL SELECT department, max(salary) FROM employee GROUP BY department; Nulls and Views 14 Operators that Introduce NULL ▪ Left Outer Join (keep unmatched tuples on the left) A B C a1 b1 c1 a2 b2 c2 C D E c1 d1 e1 c3 d2 e2 ⟕ A B C D E a1 b1 c1 d1 e1 a2 b2 c2 NULL NULL = ▪ Right Outer Join (keep unmatched tuples on the right) A B C a1 b1 c1 a2 b2 c2 C D E c1 d1 e1 c3 d2 e2 ⟖ A B C D E a1 b1 c1 d1 e1 NULL NULL c3 d2 e2 = Nulls and Views 15 Operators that Introduce NULL ▪ Outer Join (keep unmatched tuple on both the left and the right) A B C a1 b1 c1 a2 b2 c2 C D E c1 d1 e1 c3 d2 e2 ⟗ A B C D E a1 b1 c1 d1 e1 a2 b2 c2 NULL NULL NULL NULL c3 d2 e2 = SELECT column_name(s) FROM table1 LEFT OUTER JOIN table2 ON table1.column_name = table2.column_name WHERE condition; SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name = table2.column_name WHERE condition; Nulls and Views 16 NULLS in real database engines • The semantics of NULLS in commercial engines is not uniform • Read the manual to understand the way the system you are using treats NULLS to avoid surprises and incorrect results • https://learn.microsoft.com/en-us/sql/t-sql/functions/isnull-transact-sql?view=sql-server-ver16 • https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Nulls.html#GUID-B0BA4751-9D88- 426A-84AD-BCDBD5584071 • https://www.postgresql.org/files/documentation/pdf/17/postgresql-17-A4.pdf Nulls and Views 17 Operating on relational Tables Entity-Relationship Model 18 Data Manipulation Language • (updating) data in a database: • INSERT • UPDATE • DELETE INSERT INTO attends SELECT ID, Nr FROM Student, Lecture WHERE Title= 'Database'; INSERT INTO Student (ID, Name) VALUES (28121, `Anna´); DELETE Student WHERE Semester > 13; UPDATE Student SET Semester = Semester + 1; Nulls and Views 19 Data Manipulation Language – Snapshot Semantics Prerequisite Follow-up 5001 5041 5001 5043 5001 5049 5041 5216 5043 5052 5041 5052 5052 5229 Requires DELETE FROM requires WHERE prerequisite in (SELECT follow-up FROM requires); How does SQL deals with this? ▪ Phase 1: Mark all tuples which are affected by the updates. ▪ Phase 2: Implement updates on the marked tuples. ▪ Mixing two phases would lead to non-deterministic results. p f a b b c c d p f a b b c c d p f a b c d p f a b Wrong Correct Nulls and Views 20 View • Schemas provide us physical data independence. • View aims at raising the level of abstraction even higher and provide us with logical data independence. • i.e., users can use View without caring about how relations are organized underneath the cover. • In a database, a view is the result set of a stored query on the data, which the database users can query just as they would in a persistent database collection object. Nulls and Views 21 Schemas • Schemas provide the basic organization of the data • Views allow to tailor that logical organization to the needs of particular applications without changing the basic schema: • Orders in a given district • Orders in a period of time • Orders from a customer • … 22 TPC-C schema Nulls and Views Analytics (TPC-H) • Databases for analytics often use a star schema: • Fact table (very big) with the central element of the schema • Dimension tables (typically smaller): with more data on the different attributes that are mentioned in the fact table • It helps separate the relevant operational data from information that might be needed but it is not central to processing, e.g., an order 23Nulls and Views Snowflake schema • In star schemas, the dimension tables and the fact table are not normalized • A snowflake schema is a star schema where the dimension tables are normalized (some or all of them). Normalization is applied to low cardinality attributes to remove redundancy 24Nulls and Views Modern analytics (TPC-DS): Snow-storm • Multiple snow-flake schemas linked to each other • TPC-DS • Large number of tables (26) • Large number of columns per table (38) • Multiple fact tables to enable joins between large tables (fact to fact joins) 25Nulls and Views View: Define a View • Then you can use <NAME_OF_VIEW> “just like a table”. • There are fundamental differences, we will see later. CREATE VIEW <NAME_OF_VIEW> AS <SQL QUERY> orig dest price PEK ZRH 100 PEK MUC 10 MUC ZRH 20 MUC LUX 30 PEK SFO 1000 SFO ZRH 1000 CREATE VIEW FlightFromPEK AS SELECT * FROM Flight WHERE orig=PEK; orig dest price PEK ZRH 100 PEK MUC 10 PEK SFO 1000 FlightFromPEK Logically, the table on the right has never been materialized. SELECT * FROM FlightFromPEK WHERE dest = ZRH; orig dest price PEK ZRH 100 Nulls and Views 26 View: View vs. Table orig dest price PEK ZRH 100 PEK MUC 10 MUC ZRH 20 MUC LUX 30 PEK SFO 1000 SFO ZRH 1000 CREATE TABLE FlightFromPEK AS SELECT * FROM Flight WHERE orig=PEK; CREATE VIEW FlightFromPEK AS SELECT * FROM Flight WHERE orig=PEK; INSERT INTO Flight VALUES (PEK, ZRH, 200); INSERT INTO Flight VALUES (PEK, ZRH, 200); SELECT * FROM FlightFromPEK WHERE dest = ZRH; SELECT * FROM FlightFromPEK WHERE dest = ZRH; orig dest price PEK ZRH 100 orig dest price PEK ZRH 100 PEK ZRH 200 View is logical (it does not get materialized) “alias” for a query Nulls and Views 27 View: Application 1 -- Privacy • Views can be used for access control and preserving privacy. • Relation Flight: The user having access to this knows the information of ALL of the flights • View FlightFromPEK: The user having access to this only knows the information of flights starting from PEK. • If for some reason MUC -> ZRH is a \"secret\" flight, this user does not know about it if s/he only has access to the view FlightFromPEK orig dest price PEK ZRH 100 PEK MUC 10 MUC ZRH 20 MUC LUX 30 PEK SFO 1000 SFO ZRH 1000 CREATE VIEW FlightFromPEK AS SELECT * FROM Flight WHERE orig=PEK; Flight Nulls and Views 28 View: Application 1 -- Privacy • Views can be used for access control and preserving privacy. • Table Tests: users can see the test score (e.g., Profs) • View testView: This user is only allowed to know which student took which lecture, but not the grade. PersNr LectureID Grade 26120 5001 3.0 27550 5001 5.5 26120 5041 5.75 Tests CREATE VIEW testView AS SELECT PersNr, LectureID FROM tests; Nulls and Views 29 View: Application 2 -- Usability • Views can be used to make writing of some queries easier. • E.g., Find all flights from PEK to ZRH. • Using the original table • Using the view • This may not look like a big saving, but in practice, the saving can be significant. CREATE VIEW FlightFromPEK AS SELECT * FROM Flight WHERE orig=PEK; SELECT * FROM Flight WHERE dest = ZRH and orig = PEK; SELECT * FROM FlightFromPEK WHERE dest = ZRH; orig dest price PEK ZRH 100 PEK MUC 10 MUC ZRH 20 MUC LUX 30 PEK SFO 1000 SFO ZRH 1000 Flight Nulls and Views 30 View: Application 2 – Is-a Relationship • Views can be used to implement generalization CREATE TABLE Employee (id integer not null, name varchar(30) not null); CREATE TABLE ProfData (id integer not null, room integer); CREATE TABLE AssiData (id integer not null, TAcourse integer); CREATE VIEW Professor AS SELECT * FROM Employee e, ProfData d WHERE e.id = d.id; CREATE VIEW Assistant AS SELECT * FROM Employee e, AssiData d WHERE e.id = d.id; Nulls and Views 31 View: Application 2 – Is-a Relationship • View can be used to implement generalization CREATE TABLE Professor (id integer not null, name varchar(30) not null, room integer); CREATE TABLE Assistant (id integer not null, name varchar(30) not null, TACourse integer); CREATE TABLE OtherEmps (id integer not null, name varchar(30) not null); CREATE VIEW Employee AS ( SELECT id, name FROM Professor UNION SELECT id, name FROM Assistant UNION SELECT id, name FROM OtherEmps ); Nulls and Views 32 View: How a view gets evaluated • Query Rewriting CREATE VIEW FlightFromPEK AS SELECT * FROM Flight WHERE orig=PEK; SELECT * FROM FlightFromPEK WHERE dest = ZRH; orig dest price PEK ZRH 100 PEK MUC 10 MUC ZRH 20 MUC LUX 30 PEK SFO 1000 SFO ZRH 1000 Flight SELECT * FROM (SELECT * FROM Flight WHERE orig=PEK;) WHERE dest = ZRH; SELECT * FROM Flight WHERE orig=PEK AND dest = ZRH; DMBS’ Job Nulls and Views 33 Anatomy of query processing 34 QUERY PARSER QUERY INTERMEDIATE REPRESENTATION (Abstract Syntax Tree) DB SCHEMA REWRITING OPERATOR TREE (PLAN) STATISTICS OPTIMIZATION CODE GENERATION QUERY EXECUTION QUERY PLAN CODE/ PLAN Validation, access control Check caches Interpretation Compilation Nulls and Views Views and base tables 35 CREATE VIEW emp_education (empno, firstnme, lastname, edlevel) AS SELECT empno, firstnme, lastname, edlevel FROM employee WHERE edlevel > 17 CREATE VIEW emp_salaries (empno, firstname, lastname, salary) AS SELECT empno, firstnme, lastname, salary FROM employee WHERE salary > 35000 SELECT e1.empno, e1.firstnme, e1.lastname, e1.edlevel, e2.salary FROM emp_education e1, emp_salaries e2 WHERE e1.empno = e2.empno SELECT e1.empno, e1.firstnme, e1.lastname, e1.edlevel, e2.salary FROM employee e1, employee e2 WHERE e1.empno = e2.empno and e1.edlevel > 17 and e2.salary > 35000 Merge views by joining base tables Eliminate join (same base table) SELECT empno, firstnme, lastname, edlevel, salary FROM employee WHERE edlevel > 17 and salary > 35000 https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5 .0/com.ibm.db2.luw.admin.perf.doc/doc/c0005294.html Nulls and Views View: Can we update a view? • What does this even mean? • Let there be base relations 𝑅_1,…,𝑅_𝑛 and a view 𝑉=𝑄(𝑅_1,…,𝑅_𝑛) defined over these relations. • If the user wants to update 𝑉 into 𝑉′, the task is to find a set of updates to the base relation 𝑅_1^′,…,𝑅_𝑛′ such that 𝑄(𝑅_1^′,…,𝑅_𝑛^′ )=𝑉′ 𝑅1, … , 𝑅𝑛 𝑅1 ′ , … , 𝑅𝑛′ 𝑉 𝑉′ orig dest price PEK ZRH 100 PEK MUC 10 MUC ZRH 20 MUC LUX 30 PEK SFO 1000 SFO ZRH 1000 Flight CREATE VIEW FlightFromPEK AS SELECT * FROM Flight WHERE orig=PEK; orig dest price PEK ZRH 100 PEK MUC 10 PEK SFO 1000 FlightFromPEK DELETE FROM FlightFromPEK WHERE price > 500 How does the view get updated?Nulls and Views 36 View: Can we update a view? • Example of views that are not updatable. • Projection can be hard. sID cName major decision 1 S CS Y 1 S EE N 1 B CS Y 1 C EE Y 2 B BIO N 3 M BIOE Y 3 C BIOE N 3 S CS Y 3 C EE N Apply CREATE VIEW CSaccept AS SELECT sID FROM Apply WHERE major = 'CS' and decision = 'Y'; INSERT INTO Csaccept VALUES (2); Problem? Don’t know what to fill in in the original table. Nulls and Views 37 View: Can we update a view? • Example of views that are not updatable. • Aggregation can be hard. r 1 2 3 4 5 6 7 8 9 R Problem? Updates on the base relations are not unique. CREATE VIEW V (v) AS SELECT SUM(r) FROM R; UPDATE V SET v = v + 1; Nulls and Views 38 View: Can we update a view? • Some views are easier to update. r c 1 A 2 B 3 C 4 D 5 E 6 F 7 G 8 H 9 I R Can find a unique tuple in the original table to delete (r is the key). CREATE VIEW V (v) AS SELECT r FROM R; DELETE FROM V WHERE r = 5; Nulls and Views 39 View: Updatable View • Principle: • SQL tries to avoid indeterminism. • SQL is conservative wrt view updates. • A SQL view is updatable iff: • The view involves only ONE base relation. • The view involves the key of that base relation. • The view does NOT involve aggregates, group by, or duplicate-elimination. • What's the intuition of these three rules? • Try to maintain one-to-one mapping between the view and the base relation All Views Updatable views Updatable views in SQL Nulls and Views 40 Lessons learned • Today we have seen: • How to deal with incomplete information • How incomplete information changes the semantics of operators • How to deal with NULLS in SQL • Given a schema, how to arrange it so that other interpretations of the data are possible • Views and queries • Materialized views • Next lecture we will look at recursion and integrity constrains Nulls and Views 41","libVersion":"0.3.2","langs":""}