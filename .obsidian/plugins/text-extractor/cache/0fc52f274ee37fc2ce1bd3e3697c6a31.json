{"path":"sem4/FMFP/PV/exams/finals/FMFP-FS21.pdf","text":"Formal Methods and Functional Programming Final Exam, 2021 August 16, 2021, 8:30 – 11:30 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 31 pages; the back page of this booklet is page 31. After the exam begins, check that your exam papers are complete (4 assignments for the FP part, 4 assignments and 2 pages of background material for the FM part). 2. You may complete the assignments in any order. We recommend spending roughly half of your time on each of the two parts of the exam. 3. Only write on the exam paper and extra paper sheets which are given by the assistants. Do not take any of this paper out of the exam: submit it all. Write your ﬁrst and last name and your student number on every sheet of paper that you write on. 4. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 5. For the FP part of the exam, you may use any functions from the Haskell Prelude in your solutions (without giving their deﬁnitions), unless speciﬁed otherwise. You also may use any function from one subproblem to solve the subsequent subproblems, even if you have not provided a deﬁnition for the function itself. 6. Write clearly in the sense of logic, language, and readability. Label all rule applications in your derivation trees. The clarity of your arguments and explanations aﬀects your grade. 7. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 8 ∑ Max 9 9 13 14 7 18 12 8 90 Points Part I Functional Programming Formal Methods and Functional Programming, Final Exam, 2021 3 Assignment 1: Typing (9 Points) Task 1.A (4 Points) Recall the following functions from the Haskell Prelude library. map :: (a -> b) -> [a] -> [b] (.) :: (b -> c) -> (a -> b) -> a -> c (,) :: a -> b -> (a, b) Determine whether the following expressions are well-typed or not, and if they are, state the most general type. No other justiﬁcation is needed. i) \\x y -> y y x ii) \\x y -> x y y iii) map . (,) Assignment 1 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 4 Task 1.B (5 Points) Recall the proof rules for the Mini-Haskell type system: Var . . . , x : τ, . . . ⊢ x :: τ Γ, x : σ ⊢ t :: τ Abs Γ ⊢ λx. t :: σ → τ Γ ⊢ t1 :: σ → τ Γ ⊢ t2 :: σ App Γ ⊢ t1 t2 :: τ Int Γ ⊢ n :: Int True Γ ⊢ True :: Bool False Γ ⊢ False :: Bool Γ ⊢ t :: Int iszero Γ ⊢ iszero t :: Bool Γ ⊢ t1 :: Int Γ ⊢ t2 :: Int BinOp Γ ⊢ (t1 op t2) :: Int for op ∈ {+, ∗} Γ ⊢ t0 :: Bool Γ ⊢ t1 :: τ Γ ⊢ t2 :: τ if Γ ⊢ if t0 then t1 else t2 :: τ Γ ⊢ t1 :: τ1 Γ ⊢ t2 :: τ2 Tuple Γ ⊢ (t1, t2) :: (τ1, τ2) Γ ⊢ t :: (τ1, τ2) fst Γ ⊢ fst t :: τ1 Γ ⊢ t :: (τ1, τ2) snd Γ ⊢ snd t :: τ2 Formally infer the most general type of the following Mini-Haskell expression. Label every step of the proof with the name of the used rule and list all the encountered type constraints explicitly. ⊢ (λy.λz. fst (z y)) 0 :: ... Formal Methods and Functional Programming, Final Exam, 2021 5 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2021 6 Assignment 2: Logic (9 Points) Task 2.A (4 Points) For each formula below, determine whether it is valid (satisﬁed with respect to all structures), contradictory (does not admit any models), or satisﬁable but not valid (satisﬁed with respect to some but not all structures). Use the semantics of ﬁrst-order logic with equality. valid contrad. satisﬁable but not valid EXAMPLE (∀x. x = x) ××× 1. (∀x. p(x)) → ¬(∃y. ¬p(y)) 2. ∀x.∀y.∀z. r(x, z) ∧ r(y, z) → x = y 3. (a → b) ∨ (b → a) There is exactly one correct choice for each formula. Mark your answer with a cross in the appropriate box. You do not need to justify your answer. Task 2.B (3 Points) Recall the following rules of natural deduction: axiom Γ, A ⊢ A Γ, A ⊢ B → -I Γ ⊢ A → B Γ ⊢ A[x/t] ∃-I Γ ⊢ ∃x.A Consider the following tree, which is an attempt to prove the formula (∀z. p(z, z)) → ∃x. ∀y. p(x, y) using the rules of natural deduction. axiom (3) ∀z. p(z, z) ⊢ ∀y. p(y, y) ∃-I (2) ∀z. p(z, z) ⊢ ∃x. ∀y. p(x, y) →-I (1) ⊢ (∀z. p(z, z)) → ∃x. ∀y. p(x, y) There must be a mistake because the formula is clearly not valid. Which is the wrong proof step? Give its number (1, 2, or 3) and brieﬂy explain the problem. Assignment 2 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 7 Task 2.C (2 Points) Find a structure that does not satisfy the formula (∀z. p(z, z)) → ∃x. ∀y. p(x, y) from Task B. Hint: Such a structure consists of a nonempty universe U and a binary relation I(p) over U that interprets the predicate symbol p. Formal Methods and Functional Programming, Final Exam, 2021 8 Assignment 3: Proofs about functional programs (13 Points) A linked multi-list is a variation of a linked list that stores multiple elements on each node. Its type deﬁnition is as follows: data Mlist a = Bot | Node [a] (Mlist a) Task 3.A (3 Points) 1. Give the type of the canonical fold function foldMlist on linked multi-lists. 2. Deﬁne the canonical fold function foldMlist on linked multi-lists. Assignment 3 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 9 Task 3.B (10 Points) Recall the following Haskell functions and properties: reverse :: [a] -> [a] reverse [] = [] --- rev.1 reverse (x:xs) = reverse xs ++ [x] --- rev.2 ∀ xs. xs ++ [] = xs --- app_empty.1 ∀ xs. [] ++ xs = xs --- app_empty.2 ∀ xs ys zs. xs ++ (ys ++ zs) = (xs ++ ys) ++ zs --- app_assoc ∀ xs ys. reverse (xs ++ ys) = reverse ys ++ reverse xs --- app_rev Now, recall the type deﬁnition of linked multi-lists: data Mlist a = Bot | Node [a] (Mlist a), and consider the following Haskell functions on them. mrev :: Mlist a -> Mlist a -> Mlist a mrev Bot p = p --- mrev.1 mrev (Node x n) p = mrev n (Node (reverse x) p) --- mrev.2 flat :: Mlist a -> [a] flat Bot = [] --- flat.1 flat (Node x n) = x ++ (flat n) --- flat.2 Prove that for all u :: Mlist a the equality flat (mrev u Bot) = reverse (flat u) holds. Structure your proof clearly and justify every proof step. Hint: you may want to generalize the statement ﬁrst. Formal Methods and Functional Programming, Final Exam, 2021 10 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2021 11 Assignment 4: Programming (14 Points) Task 4.A (5 Points) In this ﬁrst part of the exercise you will implement a data type that models a set. The type is deﬁned as: data Set h = Empty | Elem h (Set h) (Set h) The set should be implemented as a binary search tree. In other words, every set of the form Elem x lt rt should satisfy the search tree property: all elements in lt are strictly smaller than x, all elements in rt are strictly greater than x, and the same holds for lt and rt recursively. You may assume that the functions in this assignment will only be given arguments of type Set h that satisfy the search tree property (i.e. are already ordered). For the following, recall that the typeclass Ord provides the operators: (==), (/=), (<=), (<), (>=), (>). 1. Implement the function add that adds an element to the set and returns a well-formed binary search tree. The tree does not need to be balanced. It has the following signature: add :: Ord h => Set h -> h -> Set h 2. Implement the function query that checks set membership and has the following signature: query :: Ord h => Set h -> h -> Bool Assignment 4 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 12 Task 4.B (9 Points) Use the Set data type to implement a Bloom Filter. A Bloom Filter is a probabilistic representation of a set. Each Bloom Filter is parametrized by a collection of hash functions, and instead of storing elements directly, it stores their corresponding hash values in a single set. The Bloom Filter type is deﬁned for elements of type v and hash values of type h as follows: data BloomFilter v h = BloomFilter [v -> h] (Set h) Note that the collection of hash functions is represented by a list of type [v -> h] and the underlying set of hash values by a set of type Set h. 1. Implement the function insert that adds an element to a Bloom Filter. To add an element e, apply each of the hash functions to e and add the obtained outputs to the set of hash values. insert :: Ord h => BloomFilter v h -> v -> BloomFilter v h Hint: In your implementation, the following functions may be useful. map :: (a -> b) -> [a] -> [b] foldl :: (b -> a -> b) -> b -> [a] -> b Assignment 4 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 13 2. Implement the function check that checks for the presence of an element in the ﬁlter. This function should check whether every hash function’s output for the given element is in the underlying set (Set h). check :: Ord h => BloomFilter v h -> v -> Bool Hint: In your implementation, the following function may be useful. and :: [Bool] -> Bool 3. Implement the function fromList that transforms a given list of elements (of type [v]) into a Bloom Filter parametrized by a given list of hash functions (of type [v -> h]). fromList :: Ord h => [v] -> [v -> h] -> BloomFilter v h Hint: In you implementation, the following function may be useful. foldl :: (b -> a -> b) -> b -> [a] -> b Formal Methods and Functional Programming, Final Exam, 2021 14 This page is intentionally left blank. Part II Formal Methods Formal Methods and Functional Programming, Final Exam, 2021 16 Assignment 5: Big-Step Semantics (7 Points) In this assignment, we consider an extension to IMP adding input and output functionality. This extension makes use of two new statements: • read x reads a number into the variable x. This input should come from the user, which we model by assigning a non-deterministic value to variable x. • write e evaluates the value of the expression e and adds the result to the end of the output log. The output log is a list of numbers which we track as part of the state. Throughout this task, you may use the following notation for lists: • [ ] to represent an empty list and • vs :: v to represent element v appended to the end of the list vs. You may also use the above syntax to pattern match on values when providing new deﬁnitions. Assignment 5 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 17 Task 5.A (3 Points) Deﬁne a suitable extension to IMP states to accommodate a log of output values. Make sure to also deﬁne an appropriate initial state, τzero. Then deﬁne the big-step semantics for the read and write statements. Task 5.B (1 Point) Provide a new deﬁnition for the AssNS rule using the extended states deﬁned in the previous task. Assignment 5 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 18 Task 5.C (3 Points) Does the following program terminate successfully starting in state τzero? If so, prove termination for the program in big-step semantics. If not, explain why. x := 1; while x > 0 do read x end Formal Methods and Functional Programming, Final Exam, 2021 19 Assignment 6: Small-Step Semantics (18 Points) Consider an extension of the IMP programming language with the following statement: s1 alternate s2 This statement executes s1 and s2 in a round-robin fashion. It proceeds by repeatedly executing one step from s1 followed by one step from s2, until either s1 or s2 ﬁnishes executing. When one of the sub-statements ﬁnishes its execution, the other sub-statement continues until completion. Formally, the structural operational semantics of alternate is fully captured by the following derivation rules: ⟨s1, σ⟩ →1 σ′ (Alt1SOS) ⟨s1 alternate s2, σ⟩ →1 ⟨s2, σ′⟩ ⟨s1, σ⟩ →1 ⟨s′ 1, σ′⟩ (Alt2SOS) ⟨s1 alternate s2, σ⟩ →1 ⟨s2 alternate s′ 1, σ′⟩ Task 6.A (3 Points) Consider the following IMP statement s: (b := b − 1; a := a + 1) alternate a := a ∗ 10 Let σ be a state such that σ(a) = 1 and σ(b) = 2. Prove using the structural operational semantics that there is a state σ′ such that ⟨s, σ⟩ → ∗ 1 σ′. Provide the complete derivation sequence, as well as the derivation trees for the ﬁrst two steps. Assignment 6 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 20 This page is intentionally left blank. Assignment 6 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 21 Task 6.B (3 Points) Does the execution of s1 alternate s2 terminate successfully in every state if both s1 and s2 also terminate successfully in every state? If yes, explain why. Otherwise, provide two statements s1 and s2 for which this is not the case and an informal explanation why. Assignment 6 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 22 Task 6.C (12 Points) Prove that, for all statements s1 and s2 and states σ and σ′, if FV(s1) ∩ FV(s2) = ∅ and ⟨s1 alternate s2, σ⟩ → ∗ 1 σ′ then ⟨s1;s2, σ⟩ → ∗ 1 σ′. Assume that FV(s1 alternate s2) = FV(s1) ∪ FV(s2). Hint: you can assume the following lemmas without proving them: ∀s1, s2, σ, σ′ · FV(s1) ∩ FV(s2) = ∅ ∧ ⟨s1;s2, σ⟩ → ∗ 1 σ′ ⇒ ⟨s2;s1, σ⟩ → ∗ 1 σ′ (L1) ∀s1, s ′ 1, σ, σ′· ⊢ ⟨s1, σ⟩ →1 ⟨s′ 1, σ′⟩ ⇒ FV(s′ 1) ⊆ FV(s1) (L2) Formal Methods and Functional Programming, Final Exam, 2021 23 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2021 24 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2021 25 Assignment 7: Axiomatic Semantics (12 Points) Consider the following statement s: i := 1; r := 0; while i < n + n do r := r + i; i := i + 2 end Task 7.A (2 Points) Give a variant to prove (using the WhTotAx rule) that the program terminates successfully in any initial state. A proof is not required. Variant: Task 7.B (10 Points) Construct a proof outline that proves the Hoare triple { n ≥ 0 ∧ n = N } s { r = N 2 }. Note that you do not need to prove termination. Clearly state which loop invariant you are using in your proof outline. Hint: Your invariant should contain i mod 2 = 1. Invariant: Formal Methods and Functional Programming, Final Exam, 2021 26 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2021 27 Assignment 8: Linear Temporal Logic (8 Points) Consider the transition system depicted below, which models an authentication system (with only one account) that asks for a password and blocks the account if two wrong passwords are entered in a row. s0 {} s1 {w} s2 {w, b} s3 {c} The labels on each state indicate which of the 3 atomic propositions w (the last password that was entered was wrong), c (the user is connected), b (the account is blocked) are true in the corresponding state. The system is initially in state s0, where one mistake in the password is allowed. If the password is correct, the user gets connected for a short time, in state s3. Otherwise, if the user enters a wrong password, the system goes to state s1. In state s1, entering a wrong password leads to the account being blocked (state s2), while the right password leads again to state s3, where the user is connected for a short time. In state s3, after this short time, the system goes back to the initial state s0. Finally, the user may choose to not enter a password during some time in states s1 and s2. In these cases, the system transitions to the same state. Task 8.A (3 Points) Write down an LTL formula for each of the following properties. i) Eventually, it will be impossible for the user to be connected. Answer: ii) Once the account is blocked, it is blocked forever. Answer: iii) The user will be connected at least twice. Answer: Assignment 8 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 28 Task 8.B (3 Points) For each of the following LTL formulas, state whether or not the formula deﬁnes a property that is valid in the given transition system. Justify your answer by either brieﬂy explaining why it is valid or providing a counterexample if it is not. i) (⃝□w) ⇒ ♦c ii) □(c ⇒ ♦¬c) iii) □((w ∧ ♦¬w) ⇒ ♦c) Assignment 8 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2021 29 Task 8.C (2 Points) This question is independent of the transition system. Consider the formula □(♦X ⇒ ♦¬X), where X is an atomic proposition, and answer the following questions: 1. Is this formula a safety property? If yes, prove it. If no, give a counterexample and explain why it is a counterexample. 2. Is this formula a liveness property? If yes, prove it. If no, give a counterexample and explain why it is a counterexample. Formal Methods and Functional Programming, Final Exam, 2021 30 Syntax and Semantics of IMP Big-Step Semantics (SkipN S) ⟨skip, σ⟩ → σ (AssN S) ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ → σ′ ⟨s2, σ′⟩ → σ′′ (SeqN S) ⟨s1;s2, σ⟩ → σ′′ ⟨s1, σ⟩ → σ′ (IfTN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = tt ⟨s2, σ⟩ → σ′ (IfFN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = ﬀ ⟨s, σ⟩ → σ′ ⟨while b do s end, σ′⟩ → σ′′ (WhTN S) ⟨while b do s end, σ⟩ → σ′′ if B[[b]]σ = tt (WhFN S) ⟨while b do s end, σ⟩ → σ if B[[b]]σ = ﬀ Syntax The statements (Stm) of the programming language IMP are given by the grammar s ::= skip | x := e | s;s | if b then s else s end | while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). The free variables FV(s) of a statement s are deﬁned as FV(skip) = ∅ FV(x:=e) = {x} ∪ FV(e) FV(s1;s2) = FV(s1) ∪ FV(s2) FV(if b then s1 else s2 end) = FV(b) ∪ FV(s1) ∪ FV(s2) FV(while b do s end) = FV(b) ∪ FV(s) Formal Methods and Functional Programming, Final Exam, 2021 31 Small-Step Semantics (SkipSOS) ⟨skip, σ⟩ →1 σ (AssSOS) ⟨x := e, σ⟩ →1 σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ →1 σ′ (Seq1SOS) ⟨s1;s2, σ⟩ →1 ⟨s2, σ′⟩ ⟨s1, σ⟩ →1 ⟨s′ 1, σ′⟩ (Seq2SOS) ⟨s1;s2, σ⟩ →1 ⟨s′ 1;s2, σ′⟩ (IfTSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s1, σ⟩ if B[[b]]σ = tt (IfFSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s2, σ⟩ if B[[b]]σ = ﬀ (WhileSOS) ⟨while b do s end, σ⟩ →1 ⟨if b then s; while b do s end else skip end, σ⟩ Axiomatic Semantics (Partial Correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ↦→ e] } x := e { P } { P } s1 { R } { R } s2 { Q } (SeqAx) { P } s1;s2 { Q } { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P ′ } s { Q′ } (ConsAx) { P } s { Q } if P ⊨ P′ and Q′ ⊨ Q Axiomatic Semantics (Total Correctness) Rules are as for partial correctness above, except for the following rule, which replaces WhAx: { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ⊨ 0 ≤ e where Z is a fresh logical variable (not used in P).","libVersion":"0.5.0","langs":""}