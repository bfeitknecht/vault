{"path":"sem4/FMFP/PV/exams/20-midterms/FMFP-FS11.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Midterm Exam April 6th, 2011, 15:30 – 17:30 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Exam.-Nr.: 1 General Comments: 1. Check that your exam papers are complete (6 assignments). 2. Do not write on the exam sheets. Use a separate sheet of paper for every assignment and write your name on each of them. Additional sheets are available from the assistants. 3. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no prepared notes, etc. Do not use a pencil (Bleistift) and do not use the color red. 4. You may write your answers in English or German. Important: Write clearly in the sense of logic, language, and readability. 5. If you have a question regarding the meaning of a problem statement, you may ask one of the assistants in charge of the exam. Assignment 1 2 3 4 5 6 ∑ Max. points 8 4 9 4 7 10 44 Your points Formal Methods and Functional Programming, Midterm Exam, SS11, Exam-Nr. 1 1 Assignment 1: Typing (8 points) (a) Recall the following functions from the Haskell libraries. (:) :: a -> [a] -> [a] map :: (a -> b) -> [a] -> [b] inits :: [a] -> [[a]] 1 :: Num a => a (<) :: Ord a => a -> a -> Bool State the most general type of each of the following expressions. 1. (\\x y z -> (y x, x z)) 2. (\\x y -> x (\\z -> y)) 3. map (1 :) 4. (\\x ys -> inits (map (x <) ys)) (b) Recall the proof rules for the mini-Haskell type system: . . . , x : a, . . . ⊢ x :: a A ⊢ n :: Int A ⊢ True :: Bool A ⊢ False :: Bool A, x : σ ⊢ t :: τ A ⊢ (λx. t) :: σ → τ x /∈ A A ⊢ t1 :: σ → τ A ⊢ t2 :: σ A ⊢ (t1 t2) :: τ A ⊢ t1 :: Int A ⊢ t2 :: Int A ⊢ (t1 + t2) :: Int A ⊢ t1 :: τ1 A ⊢ t2 :: τ2 A ⊢ (t1, t2) :: (τ1, τ2) Formally prove the following typing judgement using the typing rules above: ⊢ (λy. (True, λx. 1 + x y)) :: a → (Bool , (a → Int) → Int) Formal Methods and Functional Programming, Midterm Exam, SS11, Exam-Nr. 1 2 Assignment 2: Natural Deduction (4 points) Recall the following rules from natural deduction for intuitionistic predicate logic. Γ, A ⊢ A Ax Γ, A ⊢ B Γ ⊢ A → B → I Γ ⊢ A → B Γ ⊢ A Γ ⊢ B → E Γ ⊢ ⊥ Γ ⊢ A ⊥E Γ, A ⊢ ⊥ Γ ⊢ ¬A ¬I Γ ⊢ ¬A Γ ⊢ A Γ ⊢ B ¬E Γ ⊢ A Γ ⊢ B Γ ⊢ A ∧ B ∧I Γ ⊢ A ∧ B Γ ⊢ A ∧EL Γ ⊢ A ∧ B Γ ⊢ B ∧ER Γ ⊢ A Γ ⊢ A ∨ B ∨IL Γ ⊢ B Γ ⊢ A ∨ B ∨IR Γ ⊢ A ∨ B Γ, A ⊢ C Γ, B ⊢ C Γ ⊢ C ∨E Γ ⊢ P (x) Γ ⊢ ∀x. P (x) ∀I ∗ Γ ⊢ ∀x. P (x) Γ ⊢ P (t) ∀E Γ ⊢ A(t) Γ ⊢ ∃x. A(x) ∃I Γ ⊢ ∃x. A(x) Γ, A(x) ⊢ B Γ ⊢ B ∃E∗∗ Side conditions: (*) x not free in Γ and (**) x not free in Γ or B. Also recall that the scope of the quantiﬁers extends as far to the right as possible. Prove (∃z. Q(z) ∧ P (z)) → ∃w. Q(w) using natural deduction and label each inference step with the name of the corresponding rule. Formal Methods and Functional Programming, Midterm Exam, SS11, Exam-Nr. 1 3 Assignment 3: Lists (9 points) (a) Write a Haskell function maximum :: Ord a => [a] -> a that computes the maxi- mum of a non-empty list and throws an error given the empty list. For example, the following should hold. maximum [1,2,3,1,3] = 3 (b) The function concatMap :: (a -> [b]) -> [a] -> [b] is deﬁned as follows. concatMap f = concat . map f Using foldr :: (a -> b -> b) -> b -> [a] -> b, another possible deﬁnition is based on concatMap’ f = foldr aux e assuming that aux and e are deﬁned appropriately. Give deﬁnitions for aux and e such that concatMap = concatMap’. Note that you do not have to prove this. (c) Write a Haskell function iter2 :: (a -> a) -> (a -> a) -> a -> a -> [a] such that iter2 f g x y returns an inﬁnite list of alternated iterated applications of f to x and g to y, i.e., the following should hold. iter2 f g x y = [x, y, f x, g y, f (f x), g (g y), ...] Formal Methods and Functional Programming, Midterm Exam, SS11, Exam-Nr. 1 4 Assignment 4: Proof by Induction (4 points) Consider the following functions. addShifted :: [Int] -> Int -> [Int] addShifted [] i = [i] -- addShifted.1 addShifted (x:xs) i = (x + i):addShifted xs x -- addShifted.2 sum :: [Int] -> Int sum [] = 0 -- sum.1 sum (x:xs) = x + sum xs -- sum.2 Prove that ∀xs :: [Int]. ∀i :: Int. sum (addShifted xs i) = i + 2 ∗ sum xs. Formal Methods and Functional Programming, Midterm Exam, SS11, Exam-Nr. 1 5 Assignment 5: Balanced Trees, (7 points) (a) Deﬁne an algebraic data type Tree a of binary trees, where only leaves are labeled with elements of type a. This means, elements of type a are stored at the leaves of the tree rather than at the inner nodes. (b) Assume that the root of a tree has depth 0. Write a Haskell function leafDepths :: Tree a -> [Int] that computes the list of depths of all leaves of a tree from left to right. (c) Write a Haskell function boundDepth :: Int -> (Tree a -> a) -> Tree a -> Tree a such that for all i ≥ 0, boundDepth i f t is the tree obtained from t by replacing all subtrees t’ at depth i with leaves labeled with f t’. For example, the following should hold. boundDepth 1 f (Node (Leaf \"a\") (Node (Node (Leaf \"b\") (Leaf \"c\")) (Leaf \"d\"))) = (Node (Leaf (f (Leaf \"a\"))) (Leaf (f (Node (Node (Leaf \"b\") (Leaf \"c\")) (Leaf \"d\"))))) Formal Methods and Functional Programming, Midterm Exam, SS11, Exam-Nr. 1 6 Assignment 6: Symbolic Expressions (10 points) We represent multivariate polynomials over variables of type a with Integer coeﬃcients using the following Haskell type. type Poly a = [(Integer, [a])] For example, the Haskell value [(3, [\"x\",\"y\"]), (1, [\"y\",\"y\"])] of type Poly String is a representation of the multivariate polynomial 3xy + y2. (a) Write a Haskell function evalPoly :: (a -> Integer) -> Poly a -> Integer such that evalPoly f p computes the value of the polynomial p where every variable x is replaced by the value f x. (b) We represent symbolic arithmetic expressions using the following Haskell type. data AExpr a = Var a | Lit Integer | Add (AExpr a) (AExpr a) | Mul (AExpr a) (AExpr a) Deﬁne the fold function foldAExpr :: (a -> b) -> (Integer -> b) -> (b -> b -> b) -> (b -> b -> b) -> AExpr a -> b for symbolic arithmetic expressions represented using AExpr a. (c) Use the foldAExpr function from (b) to write a Haskell function toPoly :: AExpr a -> Poly a that converts an arithmetic expression to an equivalent multivariate polynomial. For example, the arithmetic expression (3x + y) ∗ y can be converted to the multivariate polynomial 3xy + y2. Note that you do not have to prove the correctness of your solution.","libVersion":"0.5.0","langs":""}