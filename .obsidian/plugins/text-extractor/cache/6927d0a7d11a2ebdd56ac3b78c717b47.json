{"path":"sem4/FMFP/UE/s/FMFP-u12-s.pdf","text":"P. M¨uller, D. Basin and R. Jung Formal Methods and Functional Programming Exercise Sheet 12: Axiomatic Semantics (Hoare Logic) Submission deadline: May 20th/21st, 2025 Viper Viper (viper.ethz.ch) is a verification project, providing a language and tools for verifying func- tional properties of programs in that language. In particular, Viper supports verification of loops via loop invariants, as you have learned in the course. In this exercise session, you can try out Viper as a tool for helping to practice the important skill of finding loop invariants. There are two simple ways of running Viper: the recommended way is to download the VSCode plugin for Viper, as explained here: http://www.pm.inf.ethz.ch/research/viper/downloads.html (make sure to install the “Viper” plugin, and that you have the right dependencies, as explained in the in- structions). Alternatively, you can run the Viper tools through the (slower) web interface, available at http://viper.ethz.ch/examples/blank-example.html. The syntax of Viper programs is slightly different to that of IMP, but very similar. Syntax for assignments is the same (although local variables must be declared with an explicit type, using the syntax var x: Int. There is no skip command, but statement blocks (e.g., branches of conditionals) may be left empty. Viper uses C/Java-like syntax for conditionals and loops. For example, the IMP program if x > 0 then x := x - 1; while x > 0 do x := x - 1 end else skip end could be translated into Viper as follows: if (x > 0) { x := x - 1 while (x > 0) { x := x - 1 } } else { /* else branch can be omitted */ } Loop invariants can be written between the while-condition and the open brace {, e.g.: 1 while (x > 0) invariant x >= 0 { x := x - 1 } To help us improve Viper, you are welcome to voluntarily submit your Viper programs to our database. We do not store any data besides the submitted programs. If you would like to participate, please follow the steps below: 1. Go to VS Code Settings and search with the keyword “Viper”. Find Viper Settings: Verification Backends and click on Edit in settings.json. 2. In settings.json, locate the configuration for the backend that you are using — either the default Silicon or Carbon. Add the argument --submitForEvaluation to the beginning of the customArguments field for that backend. 2 Assignment 1 (Total Correctness of Exponentiation) Let s1 be the following statement: y := 1; z := 0; while z < x do y := y * 2; z := z + 1 end The Viper skeleton can be found on the website: program 3 exponentiation.vpr. Our goal is to prove that ⊢ { x = X ∧ X ≥ 0 } s1 { ⇓ y = 2 X }. Task 1.1. Find a suitable loop invariant and loop variant. You may use Viper to do so. Hint: The invariant should mention all variables used in the loop. Solution. A suitable loop invariant is x = X ∧ y = 2 z ∧ z ≤ x, where X is the initial value of x. Task 1.2. Give a proof outline for ⊢ { x = X ∧ X ≥ 0 } s { ⇓ y = 2 X }. 3 Solution. The proof outline is: {x = X ∧ X ≥ 0} ⊨(1) {x = X ∧ X ≥ 0 ∧ 1 = 1} y := 1; {x = X ∧ X ≥ 0 ∧ y = 1} ⊨(1) {x = X ∧ X ≥ 0 ∧ y = 1 ∧ 0 = 0} z := 0; {x = X ∧ X ≥ 0 ∧ y = 1 ∧ z = 0} ⊨(1) {x = X ∧ y = 2 z ∧ z ≤ x} while z < x do∗ {z < x ∧ x = X ∧ y = 2 z ∧ z ≤ x ∧ (x − z) = V } ⊨(2) {x = X ∧ y · 2 = 2z+1 ∧ z + 1 ≤ x ∧ (x − (z + 1)) < V } y := y * 2; {x = X ∧ y = 2 z+1 ∧ z + 1 ≤ x ∧ (x − (z + 1)) < V } z := z + 1 {⇓ x = X ∧ y = 2 z ∧ z ≤ x ∧ (x − z) < V } end {⇓ ¬(z < x) ∧ x = X ∧ y = 2 z ∧ z ≤ x} ⊨(3) {⇓ y = 2 X} ( ∗) The side condition holds as z < x ∧ x = X ∧ y = 2 z ∧ z ≤ x entails x − z > 0. (1) Trivial. (2) First, we multiply both sides of the equation y = 2 z by 2. Second, z < x and z ≤ x imply z < z + 1 ≤ x. (3) ¬(z < x) and z ≤ x imply z = x. Assignment 2 Consider the following IMP program s2: y := 0; z := 0; while y * y < n do y := y + 1; if y * y <= n then z := z + 1 4 else skip end end The Viper skeleton can be found on the website: program 4.vpr. Task 2.1. Assume n ≥ 0 as pre-condition. What does this function compute (hint: the result is stored in z)? Write a post-condition to ensure that z has the right value after termination. Also add the pre-condition to the program. Solution. The function computes ⌊√n ⌋, storing the result in z. To express the floor of the square root we use two inequalities. In Viper syntax, this can be written as: z * z <= n && (z + 1) * (z + 1) > n Note that the two conditions imply z ≥ 0, as z 2 > (z + 1)2 for negative z. Task 2.2. Find a suitable loop invariant which enables the verifier to prove the post-condition given the pre-condition. Solution. A suitable loop invariant is: (y 2 ≤ n ⇒ y = z) ∧ (y 2 > n ⇒ y = z + 1) ∧ (z 2 ≤ n) ∧ (z ≥ 0) We have a case distinction on y. As long as y 2 ≤ n, y equals z. Only if y 2 > n, we don’t update z and y is one bigger than z. Also we always guarantee that z 2 ≤ n, i.e., we never overshoot. z ≥ 0 ensures that we get the positive square root. Together with the negated loop condition we are able to prove the post-condition. Task 2.3. Prove that { n = N ∧ n ≥ 0 } s1 { z 2 ≤ N ∧ N < (z + 1)2 } Solution. We choose the invariant to be (y 2 ≤ n ⇒ y = z) ∧ (y 2 > n ⇒ y = z + 1) ∧ (z 2 ≤ n) ∧ (n = N ) ∧ (z ≥ 0) 5 Then the proof outline is: {n = N ∧ n ≥ 0} ⊨(1) {(0 2 ≤ n ⇒ 0 = 0) ∧ (02 > n ⇒ 0 = 0 + 1) ∧ 0 2 ≤ n ∧ n = N ∧ 0 ≥ 0} y := 0; {(y 2 ≤ n ⇒ y = 0) ∧ (y 2 > n ⇒ y = 0 + 1) ∧ 0 2 ≤ n ∧ n = N ∧ 0 ≥ 0} z := 0; {(y 2 ≤ n ⇒ y = z) ∧ (y 2 > n ⇒ y = z + 1) ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} while y*y < n do {y 2 < n ∧ (y 2 ≤ n ⇒ y = z) ∧ (y 2 > n ⇒ y = z + 1) ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} ⊨(2) {(y + 1 − 1) 2 < n ∧ y + 1 = z + 1 ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} y := y + 1; {(y − 1) 2 < n ∧ y = z + 1 ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} if y * y <= n then {y 2 ≤ n ∧ (y − 1) 2 < n ∧ y = z + 1 ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} ⊨(3) {y 2 ≤ n ∧ (y − 1) 2 < n ∧ y = z + 1 ∧ (z + 1 − 1) 2 ≤ n ∧ n = N ∧ z + 1 ≥ 0} z := z + 1 {y 2 ≤ n ∧ (y − 1) 2 < n ∧ y = z ∧ (z − 1) 2 ≤ n ∧ n = N ∧ z ≥ 0} ⊨(4) {(y 2 ≤ n ⇒ y = z) ∧ (y 2 > n ⇒ y = z + 1) ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} else {¬(y 2 ≤ n) ∧ (y − 1)2 < n ∧ y = z + 1 ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} skip {¬(y 2 ≤ n) ∧ (y − 1)2 < n ∧ y = z + 1 ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} ⊨(4) {(y 2 ≤ n ⇒ y = z) ∧ (y 2 > n ⇒ y = z + 1) ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} end {(y 2 ≤ n ⇒ y = z) ∧ (y 2 > n ⇒ y = z + 1) ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} end {¬(y 2 < n) ∧ (y 2 ≤ n ⇒ y = z) ∧ (y 2 > n ⇒ y = z + 1) ∧ z 2 ≤ n ∧ n = N ∧ z ≥ 0} ⊨(5) {z 2 ≤ N ∧ N < (z + 1)2} (1) Trivial. (2) y 2 < n and y ≤ n 2 ⇒ y = z imply y = z (3) Trivial. (4) As either y 2 > n or y 2 ≤ n are false, they vacuously imply the right hand side. (5) N < (z + 1)2 can be shown by a case distinction on y: case y2 < n: As y2 ≥ n, this case is not possible. 6 case y2 = n: y2 = n ∧ (y2 ≤ n ⇒ y = z) implies y2 = z2 and then N = n = y2 = z2 < (z + 1)2 The last step requires z ≥ 0 case y2 > n: y2 > n ∧ (y2 > n ⇒ y = z + 1) implies y2 = (z + 1)2 and then N = n < y2 = (z + 1)2 Task 2.4. Give a suitable variant (i.e., which can be used with the rule WhTotAx) to prove that the program terminates, and explain why it is suitable. Solution. Recall that the variant must be at least 0 (provided that the loop condition holds). n − y ∗ y is an easy variant, since y increases, so the variant clearly decreases, and we directly get from the loop condition that it is at least 0. n − y also works, but it requires more work to prove that it is not negative. 7","libVersion":"0.5.0","langs":""}