{"path":"sem4/FMFP/UE/e/FMFP-u08-e.pdf","text":"P. M¨uller, D. Basin and R. Jung Formal Methods and Functional Programming Exercise Sheet 8: Induction Submission deadline: Wednesday, April 16, 2025 Assignment 1 Let U be a sequence of integers, defined by U0 = U1 := −1, and, for all n ≥ 0, Un+2 = 5 × Un+1 − 6 × Un. Task 1.1: Prove that, for all natural numbers n, Un = 3 n−2 n+1 using strong induction. Task 1.2: Prove that, for all natural numbers n, Un = 3 n−2 n+1 using weak induction. Assignment 2 (Run-Length Encoding) The background of this assignment is a simple run-length encoding scheme 1. In our case, the input data is encoded as a list of natural numbers 2 of even length. The encoded representation has the form n1:v1:n2:v2:. . .:[], where each pair ni:vi denotes, that the input data contained ni consecutive occurrences of vi. For example, the input 1:1:1:5:5:5:5:[] will be encoded as 3:1:4:5:[]. The function enc computes the run-length encoding of a given list of natural numbers. It is de- fined in terms of the auxiliary function aux that performs the actual encoding. enc [] = [] -- (E1) enc (x:xs) = aux xs 1 x [] -- (E2) aux [] n v ys = ys ++ [n,v] -- (A1) aux (x:xs) n v ys 1http://en.wikipedia.org/wiki/Run-length_encoding 2We include zero in the natural numbers. 1 | x == v = aux xs (n+1) x ys -- (A2) | otherwise = aux xs 1 x (ys ++ [n,v]) -- (A3) The function dec decodes run-length encoded data represented as a list of natural numbers. The function rep n v creates a list of length n where each element is v. dec [] = [] -- (D1) dec [n] = [] -- (D2) dec (n:v:xs) = rep n v ++ dec xs -- (D3) rep 0 v = [] -- (R1) rep n v = v:(rep (n-1) v) -- (R2) The function srclen computes the length of the source data from the encoded representa- tion. srclen [] = 0 -- (S1) srclen [n] = 0 -- (S2) srclen (n:v:xs) = n + srclen xs -- (S3) Note: The pathological cases (D2) and (S2) are only there to make the corresponding functions total. Lemmas: For the tasks below, you may use the following lemmas without proving them. (L1) ∀x :: Nat · ∀xs, ys :: [Nat] · (x:xs) ++ ys = x:(xs ++ ys) (L2) ∀n, m, v :: Nat · ∀xs, ys :: [Nat]· aux (rep m v ++ xs) n v ys = aux xs (n+m) v ys (L3) ∀n, v :: Nat · ∀xs :: [Nat]· length xs % 2 = 0 =⇒ srclen (xs ++ [n,v]) = srclen xs + n (L4) ∀n, v :: Nat · ∀xs :: [Nat]· length xs % 2 = 0 =⇒ length (xs ++ [n,v]) % 2 = 0 Task 2.1: Prove the following statement: ∀n, v :: Nat · ∀xs, ys :: [Nat] · length ys % 2 = 0 =⇒ srclen (aux (dec xs) n v ys) = srclen xs + n + srclen ys Hint: We recommend using strong structural induction (as explained in the exercise session) on one of the list-typed variables. Alternatively, you could use a mathematical induction on the length of one of the lists. Task 2.2: Use the result of the previous task to prove the following statement: ∀xs :: [Nat] · srclen (enc (dec xs)) = srclen xs 2","libVersion":"0.5.0","langs":""}