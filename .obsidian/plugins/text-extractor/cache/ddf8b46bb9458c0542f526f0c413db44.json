{"path":"sem3/TI/VRL/extra/nwehrl/TI-nwehrl-w11.pdf","text":"Theoretische Informatik HS24 Nicolas Wehrli ¨Ubungsstunde 11 3. Dezember 2024 ETH Z ¨urich nwehrl@ethz.ch 1 Heute 1 Feedback zur Serie 2 NP-Vollst¨andigkeit 3 How To P-Reduktion 2 Feedback zur Serie Feedback Aufgabe 25: off by one errors, 0 ≤ j ≤ s(n) gives (s(n) + 1) possibilities for j. Aufgabe 26: forgot to copy input for (a)/ walk back the input band pointer for (b) before 2nd simulation. 3 NP-Vollst¨andigkeit Verifikation Verfizierer Sei L ⊆ Σ∗ eine Sprache und sei p : N → N eine Funktion. Ein Algorithmus A (MTM) ist ein p-Verfizierer f ¨ur L mit V(A) = L, falls A mit folgenden Eigenschaften auf allen Eingaben aus Σ∗ × (Σbool)∗ arbeitet: (i) TimeA(w, x) ≤ p(|w|) f ¨ur jede Eingabe (w, x) ∈ Σ∗ × (Σbool)∗. (ii) F ¨ur jedes w ∈ L existiert ein x ∈ (Σbool)∗, so dass |x| ≤ p(|w|) und (w, x) ∈ L(A). Das Wort x nennt man einen Beweis oder einen Zeugen der Behauptung w ∈ L. (iii) F ¨ur jedes y /∈ L gilt (y, z) /∈ L(A) f ¨ur alle z ∈ (Σbool)∗. 4 Polynomialzeitverifikation Falls p(n) ∈ O(nk) f ¨ur ein k ∈ N, so sagen wir, dass A ein Polynomialzeit- Verfizierer ist. Wir definieren die Klasse der in Polynomialzeit verifzierbaren Sprachen als VP = {V(A) | A ist ein Polynomialzeit-Verfizierer}. 5 Bezug zu NP Satz 6.8 VP = NP Die Klasse NP ist demnach die Klasse aller Sprachen L, die f ¨ur jedes x ∈ L einen in |x| polynomiell langen Beweis von ”x ∈ L” haben, welchen man deterministisch in polynomieller Zeit verifizieren bekann. Dies k ¨onnen wir benutzen, um L ∈ NP zu beweisen! 6 P-Reduktion Seien L1 ⊆ Σ∗ 1, L2 ⊆ Σ∗ 2 zwei Sprachen. Wir sagen, dass L1 polynomiell auf L2 reduzierbar ist, L1 ≤p L2, falls eine polynomieller Algorithmus A existiert, der f ¨ur jedes Wort x ∈ Σ∗ 1 ein Wort A(x) ∈ Σ∗ 2 berechnet, so dass x ∈ L1 ⇐⇒ A(x) ∈ L2 A wird eine polynomielle Reduktion von L1 auf L2 genannt. Bemerkung: Analog zur EE-Reduktion, nur das A jetzt noch polynomiell laufen muss. 7 Begrifflichkeiten Eine Sprache L ist NP-schwer, falls f ¨ur alle Sprachen L′ ∈NP gilt L′ ≤p L. Eine Sprache L ist NP-vollst¨andig, falls (i) L ∈NP und (ii) L ist NP-schwer. Lemma 6.7 Falls L ∈ P und L ist NP-schwer, dann gilt P = NP. 8 Satz von Cook Wir haben SAT = {x ∈ (Σlogic) ∗ | x kodiert eine erf ¨ullbare Formel in KNF} Satz 6.9 SAT ist NP-vollst¨andig. Da L1 ≤p L2 =⇒ (L2 ∈ P =⇒ L1 ∈ P) k ¨onnen wir mit diesem Resultat die NP-Schwere anderer Probleme einfacher beweisen. 9 Klassische Probleme SAT = {ϕ | ϕ ist eine erf ¨ullbare Formel in KNF} CLIQUE = {(G, k) | G ist ein ungerichteter Graph, der eine k-Clique enth¨alt} VC = {(G, k) | G ist ein ungerichteter Graph mit einer Knoten ¨uberdeckung (vertex cover) der M¨achtigkeit h ¨ochstens k} Higher-Level of Abstraction. Wir m ¨ussen uns nicht mehr ¨uberlegen, wie die Probleminstanzen als endliche W ¨orter kodiert sind! Das heisst auch, dass ihr nicht mehr explizit auf falsche Form ¨uberpr ¨ufen m ¨usst. Ihr k ¨onnt annehmen, dass die Eingabe jeweils schon eine wohlgeformte Instanz des Problems ist. 10 Aufgabe 6.22 Beweise VC ≤p CLIQUE Zur Erinnerung: CLIQUE = {(G, k) | G ist ein ungerichteter Graph, der eine k-Clique enth¨alt} VC = {(G, k) | G ist ein ungerichteter Graph mit einer Knoten ¨uberdeckung (vertex cover) der M¨achtigkeit h ¨ochstens k} Ein VC ist eine Knotenmenge C ⊆ V, so dass ∀{u, v}.v ∈ C ∨ u ∈ C. 11 Aufgabe 6.22 Wir beschreiben einen polynomiellen Algorithmus A: Eingabe (G = (V, E), k) f ¨ur VC 1. Findet G = (V, E) mit E = {{u, v} | u, v ∈ V, u ̸= v, {u, v} /∈ E} 2. Gibt (G, |V| − k) aus. Es sollte klar sein, dass A polynomiell l¨auft. Korrektheit Wir beweisen nun S ⊆ V ist ein Vertex Cover von G ⇐⇒ V \\ S ist eine Clique von G 12 Aufgabe 6.22 ( =⇒ ) : Sei S ⊆ V ein Vertex Cover von G. =⇒ Per Definition gilt f ¨ur jede Kante {u, v} ∈ E mindestens u ∈ S oder v ∈ S. =⇒ Also existiert keine Kante {u, v} ∈ E mit u, v ∈ V \\ S. =⇒ Deshalb gilt f ¨ur alle u, v ∈ V \\ S, u ̸= v, dass {u, v} ∈ E. =⇒ V \\ S ist eine Clique in G. 13 Aufgabe 6.22 ( ⇐= ) : Sei V \\ S eine Clique in G. =⇒ Per Definition gilt f ¨ur alle Knotenpaare u, v ∈ V \\ S, u ̸= v jeweils {u, v} ∈ E. =⇒ Also existiert keine Kante {u, v} ∈ E mit u, v ∈ V \\ S. =⇒ Deshalb gilt f ¨ur alle {u, v} ∈ E, dass u ∈ S oder v ∈ S. =⇒ S ist ein Vertex Cover in G. 14 Aufgabe 6.22 Mit der Aussage S ⊆ V ist ein Vertex Cover von G ⇐⇒ V \\ S ist eine Clique von G (1) k ¨onnen wir nun die Korrektheit beweisen. (G, k) ∈ VC ⇐⇒ ∃S ⊆ V : S ist ein VC von G und |S| ≤ k ⇐⇒ V \\ S ist eine Clique von G und |V \\ S| ≥ |V| − k ⇐⇒ (G, |V| − k) ∈ CLIQUE ⇐⇒ A((G, k)) ∈ CLIQUE ■ 15 How To P-Reduktion PROBLEM ∈ NP Beschreibung eine NTM M, die PROBLEM erkennt mit folgender Form: 1. M err¨at f ¨ur eine Eingabe x nicht deterministisch ein Zertifikat/Beweis (z.B. eine erf ¨ullende Belegung f ¨ur SAT oder eine Clique f ¨ur CLIQUE). 2. M verfiziert das Zertifikat deterministisch in Polynomialzeit. Korrektheit x ∈ PROBLEM ⇐⇒ Es existiert ein solches Zertifikat ⇐⇒ Es existiert eine akzept. Berechnung von M auf x ⇐⇒ x ∈ L(M) 16 PROBLEM ist NP-schwer Beweise OTHERPROBLEM ≤p PROBLEM f ¨ur ein anderes OTHERPROBLEM, dass NP-schwer ist (in der Vorlesung gezeigt oder ¨ahnl.). Alternativ k¨onnte man auch etwas wie den Beweis vom Satz von Cook machen. (Don’t) 17 PROBLEM ist NP-Vollst¨andig Zeige 1 PROBLEM ∈ NP 2 PROBLEM ist NP-schwer 18 OTHERPROBLEM ≤p PROBLEM 1. Beschreibung eines Algorithmus A, so dass x ∈ OTHERPROBLEM ⇐⇒ A(x) ∈ PROBLEM 2. Korrektsheitsbeweis von x ∈ OTHERPROBLEM ⇐⇒ A(x) ∈ PROBLEM (nichttrivial) 3. Polynomialzeit von A beweisen/argumentieren. Meistens recht einfach. 19 Idee finden f ¨ur Polynomialzeitreduktion Grunds¨atzlich 2 Typen von Problemen/Sprachen: 1 Satisifiability: Logische Formeln (deren Erf ¨ullbarkeit). Beispielsweise SAT und 3SAT, 4SAT... 2 Graphenprobleme: Eigenschaften von Graphen. Beispielsweise CLIQUE, VC, DS etc. 20 Satisfiablity zu Satisfiability Reduktionen Meist m ¨ussen wir einzelne Klauseln umschreiben. Ver¨anderung der Anzahl Literale. - Literale verringern. (F ¨ur allg. siehe im Buch, Lemma 6.11) Beispiel: 6SAT ≤p 4SAT (x1 ∨ x2 ∨ x3 ∨ x4 ∨ x5) ↦→ (y1 ∨ x1 ∨ x2 ∨ x3) ∧ (y1 ∨ x4 ∨ x5) (x1 ∨ x2 ∨ x3 ∨ x4 ∨ x5 ∨ x6) ↦→ (y1 ∨ x1 ∨ x2 ∨ x3) ∧ (y1 ∨ x4 ∨ x5 ∨ x6) Beispiel: E8SAT ≤p E4SAT (x1 ∨ x2 ∨ x3 ∨ x4 ∨ x5 ∨ x6 ∨ x7 ∨ x8) ↦→(y1 ∨ x1 ∨ x2 ∨ x3) ∧ (y1 ∨ x4 ∨ x5 ∨ y2) ∧ (y2 ∨ x6 ∨ x7 ∨ x8) 21 Satisfiability zu Satisfiability Reduktion - Mehr Literale. Beispiel: 5SAT ≤p E5SAT (x1 ∨ x2 ∨ x3 ∨ x4 ∨ x5) ↦→ (x1 ∨ x2 ∨ x3 ∨ x4 ∨ x5) (x1 ∨ x2 ∨ x3 ∨ x4) ↦→ (x1 ∨ x2 ∨ x3 ∨ x4 ∨ y1) ∧ (x1 ∨ x2 ∨ x3 ∨ x4 ∨ y1) (x1 ∨ x2 ∨ x3) ↦→(x1 ∨ x2 ∨ x3 ∨ y1 ∨ y2) ∧ (x1 ∨ x2 ∨ x3 ∨ y1 ∨ y2) ∧ (x1 ∨ x2 ∨ x3 ∨ y1 ∨ y2) ∧ (x1 ∨ x2 ∨ x3 ∨ y1 ∨ y2) etc. 22 Satisfiability zu Satisfiability Reduktion - Mehr erf ¨ullende Belegungen. F ¨uge Klausel hinzu. I.e. ϕ ↦→ ϕ ∧ (y1 ∨ y2) verdreifacht die Anzahl der erf ¨ullenden Belegungen. 23 Satisfiability zu Satisfiability Reduktion - OTHERPROBLEM ≤p PROBLEM Schema Sei F = F1 ∧ ... ∧ Fm eine KNF Formel vom Typ OTHERPROBLEM Eingabe f ¨ur A: F - A konstruiert B = B1 ∧ ... ∧ Bm mit einem der Tricks von oben. 24 Satisfiability zu Satisfiability Reduktion - OTHERPROBLEM ≤p PROBLEM Korrektheit F ∈ OTHERPROBLEM ⇐⇒ F erf ¨ullbar ⇐⇒ Es existiert eine Belegung φ : φ(F) = 1 ⇐⇒ ∃φ : φ(Fi) = 1∀i ∈ {1, ..., m} ... Argumentation f ¨ur beliebige Klausel ⇐⇒ ∃φ′ : φ ′(Bi) = 1∀i ∈ {1, ..., m} ⇐⇒ B erf ¨ullbar ⇐⇒ B ∈ PROBLEM 25 Graphproblem zu Graphproblem - Reduktion Patterns 1. Aus G = (V, E) Komplementgraph G bilden. I.e. G = (V, E) mit E = {{u, v} | u, v ∈ V, u ̸= v, {u, v} /∈ E} 2. Eingabetupel (G, k) zu (G, n − k) abbilden (n = |V|). 3. Beides davon (siehe CLIQUE zu VC). 4. Ersetzen einer Kante durch anderes Konstrukt - 2 Kanten mit Knoten dazwischen - Knoten hinzuf ¨ugen f ¨ur jede Kante und mit beiden Eckpunkten verbinden 26 Satisfiability zu Graphproblem Beispiel: Lemma 6.9 SAT ≤p CLIQUE Denkt ¨uber die Reduktion vom Satisfiability Problem zu SAT und von CLIQUE zum Graphproblem. Versucht diese Abbildungen zu verkn ¨upfen. 27 Graphenproblem zu Satisfiability Vielleicht Satz von Cook verwenden? Scheint sehr komplex eine konkrete Reduktion zu machen. 28 PROBLEM ≤p SAT Generelle Idee - Denke ¨uber Zertifikate f ¨ur PROBLEM nach. Welche Bestandteile haben sie? Beispielsweise im Fall von Clique ist das Zertifikat eine Knotenmenge (alle untereinander verbunden). - Kreiert eine Variablenmenge mit einer Variable pro m ¨ogliches Element f ¨ur das Zertifikat. I.e. im Fall von CLIQUE eine Variable pro Knoten - I.e. Wir werden dann f ¨ur eine Belegung der Formel wissen welche Knoten im Zertifikat enthalten sind. - Baue die Formel, die die Bedingungen kodiert, damit genau dann erf ¨ullt sein kann, falls es ein Zertifikat gibt. 29","libVersion":"0.5.0","langs":""}