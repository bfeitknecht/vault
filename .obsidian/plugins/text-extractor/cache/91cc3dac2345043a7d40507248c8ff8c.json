{"path":"sem2a/AuW/VRL/extra/nwehrli/AuW-w09-smallest-epi-circle.pdf","text":"Aufgabe 1 – Kleinster Umschliessender Ball In dieser Aufgabe sollen Sie den Algorithmus zum kleinsten umschliessenden Kreis auf den drei- dimensionalen Fall ¨ubertragen. (a) Zeigen Sie die dreidimensionale Variante des Sampling Lemma: Sei P ⊆ R3 eine Menge von n (nicht unbedingt verschiedenen) Punkten im dreidimensionalen Raum, r ∈ N, und sei R zuf¨allig gleichverteilt aus (P r ). Sei X die Anzahl Punkte von P , die ausserhalb des kleinsten umschliessenden Balles B(R) von R liegen. Dann ist E[X] ≤ 4 n−r r+1 . (b) Entwerfen Sie einen Algorithmus, der als Input eine Menge P ⊆ R3 von n Punkten im dreidi- mensionalen Raum bekommt, und der in erwarteter Zeit O(n log n) den kleinsten umschlies- senden Ball B(P ) von P bestimmt. Sie brauchen dabei nicht genau die Datenstrukturen zu spezifizieren, die Sie verwenden. Insbe- sondere d¨urfen Sie davon ausgehen, dass Sie f¨ur gegebene Zahlen d1, . . . , dn ∈ N in Zeit O(n) einen Index i mit Wahrscheinlichkeit proportional zu di ziehen k¨onnen, also mit Pr[i] = di D , wobei D = ∑n i=1 di ist. Hinweis: Sei P ⊆ R3 eine Menge von n (nicht unbedingt verschiedenen) Punkten im dreidimensio- nalen Raum. Sie d¨urfen f¨ur die Aufgabe die folgenden Fakten ohne weitere Begr¨undung verwenden. 1. B(P ) ist eindeutig bestimmt. 2. Ist Q ⊆ P , so ist Vol(B(Q)) ≤ Vol(B(P )). 3. F¨ur jede endliche Menge Q ⊆ R3 gibt es eine Teilmenge Q ′ ⊆ Q mit |Q ′| ≤ 4 sodass B(Q ′) = B(Q). Insbesondere kann essential(p, Q) = 1 nur f¨ur h¨ochstens vier Punkte p ∈ Q erf¨ullt sein. Hinweis zu (a): Gehen Sie wie im Beweis von Lemma 3.28 vor. Benutzen Sie daf¨ur insbesondere die Gr¨ossen out(p, R) := { 1 falls p ̸∈ B(R) 0 sonst und essential(p, Q) := {1 falls B(Q \\ {p}) ̸= B(Q) 0 sonst. 1 L¨osung zu Aufgabe 1 – Kleinster Umschliessender Ball (a) Proof. F¨ur den Beweis definieren wir uns zwei Hilfsfunktionen. F¨ur alle p ∈ P , R, Q ⊆ P sei out(p, R) := { 1 falls p ̸∈ B(R) 0 sonst und essential(p, Q) := { 1 falls B(Q \\ {p}) ̸= B(Q) 0 sonst. Man beachte, dass ∑ p∈P \\R out(p, R) die Anzahl der Punkte ausserhalb von B(R) ist. Leicht ¨uberzeugt man sich davon, dass beide Funktionen f¨ur alle p ∈ P \\ R in folgender Beziehung stehen. out(p, R) = 1 ⇐⇒ essential(p, R ∪ {p}) = 1. Da essential(p, Q) = 1 nur f¨ur h¨ochstens vier Punkte p ∈ Q erf¨ullt sein kann, erhalten wir f¨ur die Anzahl X der Punkte ausserhalb von B(R): E[X] = 1 (n r) ∑ R∈( P r ) ∑ s∈P \\R out(s, R) = 1 (n r) ∑ R∈( P r ) ∑ s∈P \\R essential(s, R ∪ {s}) = 1 (n r) ∑ Q∈( P r+1) ∑ p∈Q essential(p, Q) ︸ ︷︷ ︸ ≤4 ≤ 1 (n r) ∑ Q∈( P r+1) 4 = 4 · ( n r+1 ) (n r) = 4 n − r r + 1 , (b) Die Idee des Algorithmus ist auch hier eine kleine Menge an Punkten zuf¨allig auszuw¨ahlen und zu testen, ob dessen kleinste umschliessende Kugel die ganze Punktemenge P enth¨alt. Falls dies nicht der Fall ist, verdoppelt man alle Punkte ausserhalb der Kugel und wiederholt diesen Schritt. F¨ur eine endliche Punktemenge P ⊂ R3 ergibt dies folgenden Algorithmus: Algorithm 1 Umschliessender Ball Algorithmus(P) 1: repeat forever 2: w¨ahle R ⊆ P mit |R| = 21 zuf¨allig und gleichverteilt 3: bestimme B(R) 4: if P ⊆ B(R) then 5: return B(R) 6: verdoppele alle Punkte von P ausserhalb von B(R) Die Korrektheit des Algorithmus ist nach Konstruktion klar. Wir zeigen nun dass dieser Algorithmus eine erwartete Laufzeit von O(n log(n)) hat. Bei einem einzelnen Durchlauf der Wiederholungsschlaufe m¨ussen wir ein zuf¨alliges R ausw¨ahlen. Anstatt die Punkte wirklich zu verdoppeln k¨onnen wir wie im Skript bei jedem Punkt i ∈ P einen Index di hinzuf¨ugen, der besagt, wieviele Kopien dieses Punktes vorhanden sind. Dann k¨onnen wir in Zeit O(n) einen Punkt i ∈ P mit Wahrscheinlichkeit di/ ∑ i∈P di ziehen. Die eindeutige kleinste umschliessende Kugel wird in O(1) berechnet, da wir nur 21 Punkte be- trachten. Um zu ¨uberpr¨ufen ob P ⊂ B(R)gilt, durchlaufen wir alle Punkte i ∈ P und testen, 2 ob i ∈ B(R). Dies braucht ebenfalls Zeit O(n). Das verdoppeln der Indizes der Punkte aus- serhalb von B(R) braucht Zeit O(1) f¨ur jeden Punkt in P \\ B(R). Insgesamt brauchen wir folglich Zeit O(n) f¨ur jede Iteration des Algorithmus. Analog zum zweidimensionalen Fall definieren wir nun die Zufallsvariable T als die Anzahl Iterationen des Algorithmus. Des weiteren sei Xk gleich der Anzahl Punkte nach k Itera- tionen. Da wir in der k-ten Iteration zuf¨allig eine gleichverteilt zuf¨allige Menge R von 21 Punkten aus einer Menge von Xk−1 Punkten ausw¨ahlen, folgt aus Aufgabe (a), dass in Er- wartung weniger als 4 22 Xk−1 Punkte ausserhalb von B(R) liegen. Somit erwarten wir, dass Xk kleiner als (1 + 4 22 )Xk−1 ist. Dies gibt uns eine obere Schranke f¨ur den Erwartungswert E[Xk]. E[Xk] = ∑ t≥n E[Xk | Xk−1 = t] · Pr[Xk−1 = t] ≤ ∑ t≥n(1 + 4 22 )t · Pr[Xk−1 = t] = (1 + 2 11 ) · ∑ t≥n t · Pr[Xk−1 = t] = (1 + 2 11 ) · E[Xk−1]. Und per Induktion mit X0 = n gilt E[Xk] ≤ (1 + 2 11 )k · n. Wir benutzen nun, dass es 4 Punkte in P gibt, welche die kleinste umschliessende Kugel eindeutig bestimmen. Nennen wir die Menge dieser Punkte Q0, somit gilt B(P) = B(Q0). W¨ahlt unser Algorithmus eine Menge Q sodass dessen kleinste umschliessende Kugel B(Q) die Menge Q0 umschliesst, so ist B(Q) mindestens so gross wie B(Q0). Gleichzeitig gilt aber, dass B(Q) kleiner oder gleich B(P ) ist, da Q eine Teilmenge von P ist. Deshalb, da die kleinste umschliessende Kugel eindeutig bestimmt ist, gilt B(Q) = B(Q0) = B(P) und der Algorithmus terminiert. Entsprechend muss in jeder Runde, in denen der Algorithmus nicht terminiert, mindestens einer der 4 Punkte von Q0 ausserhalb von B(Q) liegen und wird in dieser Runde verdoppelt. Falls der Algorithmus l¨anger als k Runden l¨auft, gibt es somit mindestens einen Punkt der k/4 viele Runden ausserhalb der Kugel war und verdoppelt wurde. Also gibt es mindestens 2 k/4 Kopien von diesem Punkt. Das bedeutet aber, dass der Erwartungswert von Xk, der Gesamtanzahl Punkten nach k Runden, mindestens 2 k/4 ist, falls der Algorithmus nach k Iterationen noch nicht terminiert hat. Somit erhalten wir eine untere Schranke f¨ur den Erwartungswert E[Xk]. E[Xk] = E[Xk | T ≥ k] ︸ ︷︷ ︸ ≥ 2k/4 ·Pr[T ≥ k] + E[Xk | T < k] ︸ ︷︷ ︸ ≥ 0 ·Pr[T < k] ≥ 2 k/4 · Pr[T ≥ k]. Zusammen mit der obere Schranke an E[X], welche wir oben hergeleitet haben, erhalten wir nun eine Absch¨atzung f¨ur Pr[T ≥ k]: 2 k/4 · Pr[T ≥ k] ≤ E[Xk] ≤ (1 + 2 11 ) k · n ⇒ Pr[T ≥ k] ≤ (1 + 2 11 )k · n 2k/4 ≤ ( (1 + 2 11 ) 21/4 )k · n ≤ (0.994)k · n Und dieser Wert f¨allt exponentiell mit k. Die erwartete Anzahl Runden l¨asst sich jetzt gegen oben beschr¨anken. Daf¨ur benutzen wir 3 Pr[T ≥ k] ≤ min{1, 0.994kn} und k0 := ⌈− log0.994 n⌉: E[T ] = ∑ k≥1 Pr[T ≥ k] ≤ k0∑ k=1 1 + ∑ k>k0 0.994kn = k0∑ k=1 1 ︸ ︷︷ ︸ =k0 + ∑ k≥k0 0.994k−k0 · 0.994k0n︸ ︷︷ ︸ ≤1 = k0 + ∑ k′≥1 0.994k′ ≤ ⌈166.166 · log(n)⌉ + 166.667 = O(log(n)). Da wir in jeder Iteration des Algorithmus O(n) viele Operationen brauchen, haben wir hiermit gezeigt, dass der Algorithmus eine erwartete Laufzeit von O(n log(n)) hat. 4","libVersion":"0.3.2","langs":""}