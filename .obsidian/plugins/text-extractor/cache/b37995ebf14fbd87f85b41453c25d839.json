{"path":"sem4/DMDB/VRL/extra/slides/DMDB-s-w01-relational_algebra.pdf","text":"Data Modeling and Databases Spring Semester 2025 Relational Calculus Relational Calculus Gustavo Alonso Institute of Computing Platforms Department of Computer Science ETH Zürich 1 Relational Algebra II Relational Calculus 2 Practical Query Language The bigger picture Relational Algebra Relational Calculus Domain Independent Relational Calculus=More Powerful SPJR Algebra Conjunctive Query SELECT… FROM … WHERE… SQL Subset SQL = = = Relational Calculus 3 Relational Algebra is not perfect • Let’s look at one limitation of Relational Algebra. • Q: Find all ancestors of B • 𝑃𝑎𝑟𝑒𝑛𝑡𝑂𝑓𝐵 = Π𝑝𝑎𝑟𝑒𝑛𝑡(𝜎𝑐ℎ𝑖𝑙𝑑=𝐵𝑃𝑎𝑟𝑒𝑛𝑡) • 𝐺𝑟𝑎𝑛𝑑𝑃𝑎𝑟𝑒𝑛𝑡𝑂𝑓𝐵 = Π𝑃𝑎𝑟𝑒𝑛𝑡.𝑝𝑎𝑟𝑒𝑛𝑡(𝑃𝑎𝑟𝑒𝑛𝑡 ⋈𝑃𝑎𝑟𝑒𝑛𝑡.𝑐ℎ𝑖𝑙𝑑=𝑃𝑎𝑟𝑒𝑛𝑡𝑂𝑓𝐵.𝑝𝑎𝑟𝑒𝑛𝑡 𝑃𝑎𝑟𝑒𝑛𝑡𝑂𝑓𝐵) • 𝐺𝑟𝑒𝑎𝑡𝐺𝑟𝑎𝑛𝑑𝑃𝑎𝑟𝑒𝑛𝑡𝑂𝑓𝐵 = Π𝑃𝑎𝑟𝑒𝑛𝑡.𝑝𝑎𝑟𝑒𝑛𝑡(𝑃𝑎𝑟𝑒𝑛𝑡 ⋈𝑃𝑎𝑟𝑒𝑛𝑡.𝑐ℎ𝑖𝑙𝑑=𝑃𝑎𝑟𝑒𝑛𝑡𝑂𝑓𝐵.𝑝𝑎𝑟𝑒𝑛𝑡 𝐺𝑟𝑎𝑛𝑑𝑃𝑎𝑟𝑒𝑛𝑡𝑂𝑓𝐵) • … • It never ends – There is no “for loop” in Relational Algebra. • We will talk about the solution to this later in the course. parent child A B C A D C Parent Relational Calculus 4 Extensions to RA: Bags • So far, we are assuming the Set semantics for relational model and relational algebra. • Real-world database uses Bag semantics instead – • Each relation is a bag of tuples. • You can have duplicated tuples in the same relation. • Set: {1, 2, 3} • Bag: {1, 2, 1, 3, 1, 2} • We need to be careful when extending Relational Algebra to bags. • Note: Keys will still be unique Relational Calculus 5 RA for Bags • Operator semantics are different: • Bag Union: {1, 2, 1} ∪ {1, 2, 3} = {1, 1, 1, 2, 2, 3} • Bag Difference: {1, 2, 1} – {1, 2, 3, 3} = {1} • Laws are different too. • 𝑅 ∩ 𝑆 ∪ 𝑇 ≡? ≡ 𝑅 ∩ 𝑆 ∪ (𝑅 ∩ 𝑇) • Think about the case R = S = T = {1} • Also need new operators • Duplication elimination 𝛿 Relational Calculus 6 Other Extensions to RA • We can also extend RA with other operators: • Sorting: 𝜋 • Group-and-aggregation: 𝛾 • In SQL, relational Algebra is a subset of what SQL can do (the core data manipulation part, but a small subset) Relational Calculus 7 Relational Algebra is very visible in today’s systems • The impact of Relational Algebra goes beyond DBMS • You can see it in modern data analytics frameworks. • E.g., PANDAS & DataFrame Relational Calculus 8 Relational Calculus Relational Calculus 9 Recap: First-order Logic -- Syntax • To express: • Alice and Bob both know arithmetic => Knows(alice, arithmetic) ∧ Knows(bob, arithmetic) • All students know arithmetic => ∀𝑥. 𝑆𝑡𝑢𝑑𝑒𝑛𝑡 𝑥 ⇒ 𝐾𝑛𝑜𝑤𝑠(𝑥, 𝑎𝑟𝑖𝑡ℎ𝑚𝑒𝑡𝑖𝑐) • Terms, referring to objects • Constant: e.g., alice, bob • Variable: x • Function of terms: Sum(3, x) • Formula • Atomic formulas (atoms) -- Predicate applied to terms: 𝐾𝑛𝑜𝑤𝑠(𝑥, 𝑎𝑟𝑖𝑡ℎ𝑚𝑒𝑡𝑖𝑐) • Connectives applied to formulas: 𝑆𝑡𝑢𝑑𝑒𝑛𝑡 𝑥 ⇒ 𝐾𝑛𝑜𝑤𝑠(𝑥, 𝑎𝑟𝑖𝑡ℎ𝑚𝑒𝑡𝑖𝑐) • Quantifiers applied to formulas: ∀𝑥. 𝑆𝑡𝑢𝑑𝑒𝑛𝑡 𝑥 ⇒ 𝐾𝑛𝑜𝑤𝑠(𝑥, 𝑎𝑟𝑖𝑡ℎ𝑚𝑒𝑡𝑖𝑐) Relational Calculus 10 Recap: First-order Logic -- Syntax • There is a course that every student has taken ∃ 𝑦 𝐶𝑜𝑢𝑟𝑠𝑒 𝑦 ∧ [∀𝑥 𝑆𝑡𝑢𝑑𝑒𝑛𝑡(𝑥) ⇒ 𝑇𝑎𝑘𝑒𝑠(𝑥, 𝑦) ] • What does this sentence/formula mean? • => Semantics Relational Calculus 11 Recap: First-order Logic - Semantics • 𝜙 ≔ ∃ 𝑦 𝐶𝑜𝑢𝑟𝑠𝑒 𝑦 ∧ [∀𝑥 𝑆𝑡𝑢𝑑𝑒𝑛𝑡(𝑥) ⇒ 𝑇𝑎𝑘𝑒𝑠(𝑥, 𝑦) ] • Is this true? • In a database, depends on the data in the instance Course(Database) = True Course(Machine Learning) = True Student(Alice) = True Student(Bob) = True Takes(Alice, Database) Takes(Alice, Machine Learning) Takes(Bob, Database) ⊨ 𝜙 Course(Database) = True Course(Machine Learning) = True Student(Alice) = True Student(Bob) = True Takes(Alice, Machine Learning) Takes(Bob, Database) ⊭ 𝜙 ⊨ satisfies Relational Calculus 12 Recap: First-order Logic - Semantics • 𝜙 ≔ ∃ 𝑦 𝐶𝑜𝑢𝑟𝑠𝑒 𝑦 ∧ [∀𝑥 𝑆𝑡𝑢𝑑𝑒𝑛𝑡(𝑥) ⇒ 𝑇𝑎𝑘𝑒𝑠(𝑥, 𝑦) ] • Is this true? • It depends on the instance. • Domain: All possible symbols: • 𝔻 = {𝐷𝑎𝑡𝑎𝑏𝑎𝑠𝑒, 𝑀𝑎𝑐ℎ𝑖𝑛𝑒 𝐿𝑒𝑎𝑟𝑛𝑖𝑛𝑔, 𝐴𝑙𝑖𝑐𝑒, 𝐵𝑜𝑏, 𝐿𝑎𝑝𝑡𝑜𝑝 … } • Interpretation: Map each Predicate to tuples of elements that are true for this Predicate • 𝕀 𝐶𝑜𝑢𝑟𝑠𝑒 = 𝐷𝑎𝑡𝑎𝑏𝑎𝑠𝑒, 𝑀𝑎𝑐ℎ𝑖𝑛𝑒 𝐿𝑒𝑎𝑟𝑛𝑖𝑛𝑔 • 𝕀 𝑆𝑡𝑢𝑑𝑒𝑛𝑡 = {𝐴𝑙𝑖𝑐𝑒, 𝐵𝑜𝑏} • 𝕀 𝐴𝑡𝑡𝑒𝑛𝑑𝑠 = 𝐴𝑙𝑖𝑐𝑒, 𝐷𝑎𝑡𝑎𝑏𝑎𝑠𝑒 , 𝐴𝑙𝑖𝑐𝑒, 𝑀𝐿 , 𝐵𝑜𝑏 𝐷𝑎𝑡𝑎𝑏𝑎𝑠𝑒 • Model: ℳ = (𝔻, 𝕀) • ℳ ⊨ 𝜙. iff 𝜙 evaluates to True under ℳ • ℳ ⊭ 𝜙. iff 𝜙 evaluates to False under ℳ Course(Database) = True Course(Machine Learning) = True Student(Alice) = True Student(Bob) = True Takes(Alice, Database) Takes(Alice, Machine Learning) Takes(Bob, Database) ⊨ 𝜙 Relational Calculus 13 Recap: First-order Logic - Semantics • 𝜙′ ≔ 𝐶𝑜𝑢𝑟𝑠𝑒 𝑦 ∧ [∀𝑥 𝑆𝑡𝑢𝑑𝑒𝑛𝑡(𝑥) ⇒ 𝑇𝑎𝑘𝑒𝑠(𝑥, 𝑦) ] • Is this true under the model ℳ? • Well, depends on 𝑦 • If 𝑦 is “Database”, then 𝜙′ is true • If 𝑦 is “Machine Learning”, then 𝜙′ is false • Assignment: Map all free variables to a concrete constant. • E.g., Two possible assignments • 𝛼 = 𝑦 ⇒ ”𝐷𝑎𝑡𝑎𝑏𝑎𝑠𝑒” • 𝛼′ = {𝑦 ⇒ ”𝑀𝑎𝑐ℎ𝑖𝑛𝑒 𝐿𝑒𝑎𝑟𝑛𝑖𝑛𝑔”} • ℳ, 𝛼 ⊨ 𝜙. iff 𝜙 evaluates to True under ℳ and 𝛼 • ℳ, 𝛼′ ⊭ 𝜙. iff 𝜙 evaluates to False under ℳ and 𝛼′ Course(Database) = True Course(Machine Learning) = True Student(Alice) = True Student(Bob) = True Takes(Alice, Database) Takes(Alice, Machine Learning) Takes(Bob, Database) ℳ Relational Calculus 14 Relational Calculus as query language • We have seen how Relational Algebra queries the data in an imperative way – the system can follow step-by-step the expression and get the result. • We now show a query language that queries the data in a declarative way – it tells the system WHAT we want, instead of HOW to get it. • It is by using Logic: (Domain) Relational Calculus. • Relation as logic predicates. Relation instance as “facts”: • (0, John, Zurich) ∈ Customer => Customer(0, John, Zurich) = True • Example • (𝑝𝑖𝑑, 𝑐𝑖𝑑) ∃𝑛, 𝑝 𝑃𝑟𝑜𝑑𝑢𝑐𝑡 𝑝𝑖𝑑, 𝑛, 𝑝 ∧ ∃𝑐𝑛, 𝑐 𝐶𝑢𝑠𝑡𝑜𝑚𝑒𝑟 𝑐𝑖𝑑, 𝑐𝑛, 𝑐 ∧ ∃𝑠 (𝑃𝑢𝑟𝑐ℎ𝑎𝑠𝑒(𝑝𝑖𝑑, 𝑐𝑖𝑑, 𝑠))} • All (𝑝𝑖𝑑, 𝑐𝑖𝑑) tuples belonging to the above set are in the answer of this query. • It is easy to see that this query gets the same result as the following relational algebra query, but we never define the join order (i.e., declarative) • Π𝑝𝑖𝑑,𝑐𝑖𝑑((𝐶𝑢𝑠𝑡𝑜𝑚𝑒𝑟 ⋈ 𝑃𝑢𝑟𝑐ℎ𝑎𝑠𝑒) ⋈ 𝑃𝑟𝑜𝑑𝑢𝑐𝑡) Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva If you relation is a Set: (𝑝𝑖𝑑, 𝑐𝑖𝑑) ∃𝑛, 𝑝 𝑝𝑖𝑑, 𝑛, 𝑝 ∈ 𝑃𝑟𝑜𝑑𝑢𝑐𝑡 ∧ ∃𝑐𝑛, 𝑐 𝑐𝑖𝑑, 𝑐𝑛, 𝑐 ∈ 𝐶𝑢𝑠𝑡𝑜𝑚𝑒𝑟 ∧ ∃𝑠 ( 𝑝𝑖𝑑, 𝑐𝑖𝑑, 𝑠 ∈ 𝑃𝑢𝑟𝑐ℎ𝑎𝑠𝑒)} Relational Calculus 15 Relational Calculus as query language • Schema • Database Schema: 𝑆 = (𝑅1, … 𝑅𝑚) where each 𝑅𝑖 is a Relation. • Relation Schema: 𝑅(𝐴1: 𝐷1, … , 𝐴𝑛: 𝐷𝑛) • Domain: dom =∪𝑖 𝐷𝑖 -- Infinite set of constants • Instance • Instance of 𝑅(𝐴1: 𝐷1, … , 𝐴𝑛: 𝐷𝑛): 𝐼𝑅 ⊆ dom𝑛 and 𝐼𝑅 is finite • Instance of DB 𝑆(𝑅1, … , 𝑅𝑚): 𝕀 a function that maps 𝑅𝑖 to an instance of 𝑅𝑖, i. e. , 𝕀 𝑅𝑖 • An instance of a relation is a finite set of facts over the relation. • An instance of DB is a finite set of facts over all relations. Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 16 Relational Calculus as query language • (𝑝𝑖𝑑, 𝑐𝑖𝑑) ∃𝑛, 𝑝 𝑃𝑟𝑜𝑑𝑢𝑐𝑡 𝑝𝑖𝑑, 𝑛, 𝑝 ∧ ∃𝑐𝑛, 𝑐 𝐶𝑢𝑠𝑡𝑜𝑚𝑒𝑟 𝑐𝑖𝑑, 𝑐𝑛, 𝑐 ∧ ∃𝑠 (𝑃𝑢𝑟𝑐ℎ𝑎𝑠𝑒(𝑝𝑖𝑑, 𝑐𝑖𝑑, 𝑠))} • Syntax: • Let 𝜙 be a first-order logic formula with free variables 𝑥1, … , 𝑥𝑘, 𝑄𝜙 = {(𝑥1, … 𝑥𝑘)|𝜙} is a domain relational calculus query. • Semantics: • Each relation 𝑅 corresponds to a predicate 𝑅 in 𝜙 • Each instance 𝕀 corresponds to a first-order interpretation 𝕀. • An assignment is a mapping 𝛼: 𝑣𝑎𝑟 → dom • The answer of 𝑄 over 𝕀 is 𝑄 𝕀 = 𝛼 𝑥1 , … 𝛼 𝑥𝑘 𝕀, 𝛼 ⊨ 𝜙 • Is (0, 0) in the answer? Yes – (pid, n, p) = (0, iPhone, 110), (cid, cn, c) = (0, John, Zurich), s = A. If these variables take these values, the formula is true. • Is (0, 2) in the answer? No – Why? Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 17 Relational Calculus as query language - finite • Given a relational calculus query 𝑄𝜙 = {(𝑥1, … 𝑥𝑘)|𝜙}, is the answer always finite? • No – Think about the following query • 𝑄 = {(𝑝𝑖𝑑, 𝑛𝑎𝑚𝑒, 𝑝𝑟𝑖𝑐𝑒)|¬𝑃𝑟𝑜𝑑𝑢𝑐𝑡(𝑝𝑖𝑑, 𝑛𝑎𝑚𝑒, 𝑝𝑟𝑖𝑐𝑒)} • Given an empty instance, the answer of 𝑄({}) is… dom3 • Why? – Everything in dom3 satisfies 𝜙 when 𝑃𝑟𝑜𝑑𝑢𝑐𝑡 is empty • Recall that domain is infinite. The answer to this query is infinite. • We don’t want our DB to output infinite answers • We need to constrain the set of queries that we can ask. • Safe query vs. Unsafe query • Domain independent relational calculus – a safe semantic for queries. Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 18 Relational Calculus as query language – Safety • Let 𝑄𝜙 be a relational calculus query, we say 𝑄𝜙 is safe, if 𝑄𝜙(𝕀) is finite for all instances 𝕀. • All these queries safe? • 𝑥 ¬𝑅(𝑥)} • No • 𝑥 ∃𝑦. 𝑅 𝑥 ∨ 𝑅(𝑦)} • No • 𝑦 ∃𝑥. 𝑅(𝑥)} • No • 𝑥 𝑅 𝑥 ∨ ¬𝑅(𝑥)} • No Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 19 Relational Calculus as query language – Safety • Let 𝑄𝜙 be a relational calculus query, we say 𝑄𝜙 is safe, if 𝑄𝜙(𝕀) is finite for all instances 𝕀. • How hard is it to decide whether a query is safe? • Undecidable • Reduction: FO finite satisfiability • What should we do? • Constrain the syntax, • or Redefine the semantics • Let’s look at the semantics first Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 20 Domain Independent Relational Calculus • A query where the answer depends not only on (1) the interpretation of the relations (i.e., the DB instance), but also on (2) the domain is called domain dependent. • We hope to turn a RC query 𝑄𝜙 into something domain independent. • Active domain: 𝑎𝑑𝑜𝑚(𝑄𝜙, 𝕀)=all constants in 𝑄𝜙 and 𝕀. • Active Domain Semantics for 𝑄𝜙: 𝑄𝑎𝑑𝑜𝑚(𝜙,𝕀) = 𝑥1, … 𝑥𝑛 𝜙 ∧ ∀𝑖, 𝑥𝑖∈ 𝑎𝑑𝑜𝑚(𝜙, 𝕀)} (also all quantifier ∀𝑣𝑖, ∃𝑣𝑖 in 𝜙 becomes ∀𝑣𝑖 ∈ 𝑎𝑑𝑜𝑚 𝜙, 𝕀 , ∃𝑣𝑖 ∈ 𝑎𝑑𝑜𝑚 𝜙, 𝕀 ) • RC under Active Domain Semantics always return finite answer. • Why?𝑎𝑑𝑜𝑚(𝜙, 𝕀) is finite since both 𝜙 and 𝕀 are finite. Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 21 Relational Algebra vs Relational Calculus • From the theory side: • RC is more powerful than RA: • First prove that all queries in RA can be expressed in RC (induction over structure) • Then prove that some query in RC cannot be expressed in RA – RA always returns finite answers but RC can have unsafe query. • Codd’s Theorem: Domain-independent RC is as powerful as RA. • All RA expressions can be expressed in DI-RC • All DI-RC queries can be expressed as RA expressions. • From the system side – RC is declarative, RA is imperative • In DB – User writes RC, system automatically finds the best RA. Because of Codd’s theorem, this is always possible. • This is where the power of DBMS comes from!! Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Π𝑝𝑖𝑑,𝑐𝑖𝑑((𝑃𝑟𝑜𝑑𝑢𝑐𝑡 ⋈ 𝑃𝑢𝑟𝑐ℎ𝑎𝑠𝑒) ⋈ 𝑃𝑟𝑜𝑑𝑢𝑐𝑡)(𝑝𝑖𝑑, 𝑐𝑖𝑑) ∃𝑛, 𝑝 𝑃𝑟𝑜𝑑𝑢𝑐𝑡 𝑝𝑖𝑑, 𝑛, 𝑝 ∧ ∃𝑐𝑛, 𝑐 𝐶𝑢𝑠𝑡𝑜𝑚𝑒𝑟 𝑐𝑖𝑑, 𝑐𝑛, 𝑐 ∧ ∃𝑠 (𝑃𝑢𝑟𝑐ℎ𝑎𝑠𝑒(𝑝𝑖𝑑, 𝑐𝑖𝑑, 𝑠))} Relational Calculus Relational Algebra Relational Calculus 22 Relational DB vs. First-order Logic Query • So far, we focused on their similarities. But there are also differences. • DB Instance ~ First-order Interpretation… but: • First-order logic: Interpretation could be infinite. • Think about the predicate: Integer(x) • Database: DB instance is finite • Why? Well, we need to store them somewhere… • This seemly small difference leads to a whole field of study: finite model theory. Very different from what you see in first-order logic. https://dl.acm.org/doi/abs/10.1145/1559795.1559807 PODS’09 https://link.springer.com/book/10.1007/978-3-662-07003-1 (available for download at ETH) Relational Calculus 23 Summary so far Relational Algebra Relational Calculus Domain Independent Relational Calculus=More Powerful Relational Calculus 24 Conjunctive Query and SPJR algebra Relational Calculus 25 Conjunctive Query • Domain independent Relational Calculus is still tremendously difficult to analyze: • Given a DI-RC query 𝜙, does there exist a DB instance such that it outputs non-empty answers? – Satisfiability, Undecidable! • Given two DI-RC queries 𝜙1, 𝜙2, are they equivalent under all possible instances? – Equivalence, Undecidable! • We can constrain our query language such that checking these properties is easier. • Conjunctive Query: 𝜙 = ∃𝑦1, … , 𝑦𝑙(𝐴1 ∧ ⋯ ∧ 𝐴𝑚), 𝑄𝜙 = 𝑥1, … 𝑥𝑛 𝜙} each 𝐴𝑗 is an atom. • RC expressions with conjunction and existential quantification but without disjunction, negation, or universal quantification. • Example, given relation Professor(profID, name) and Lecture(lectureid, title, profID), get all pairs of Prof and Lectures in which the Prof teaches the Lecture: • 𝑛𝑎𝑚𝑒, 𝑡𝑖𝑡𝑙𝑒 ∃𝑝𝑖𝑑, 𝑙𝑖𝑑. 𝑃𝑟𝑜𝑓𝑒𝑠𝑠𝑜𝑟 𝑝𝑖𝑑, 𝑛𝑎𝑚𝑒 ∧ 𝐿𝑒𝑐𝑡𝑢𝑟𝑒(𝑙𝑖𝑑, 𝑡𝑖𝑡𝑙𝑒, 𝑝𝑖𝑑)} • Lots of good, and interesting properties, let’s see some examples Relational Calculus 26 Conjunctive Query • CQ is as expressive as RA with only Selection, Projection, Join, and Renaming (SPJR Algebra). • How to prove it? • Any SPJR expression can be expressed in CQ • Any CQ query can be expressed in SPJR expression • Establish one-to-one correspondence in structure ▪ 𝑅 ▪ 𝜎𝐶 𝐸1 ▪ Π𝐴1,…,𝐴𝑛 𝐸1 ▪ 𝐸1 × 𝐸2 ▪ 𝜌𝑎1,…,𝑎𝑛(𝐸1) ▪ 𝑥 𝑅(𝑥)} ▪ 𝑥 𝜙𝐸1(𝑥) ∧ 𝜙𝐶(𝑥)} ▪ 𝑥1, … 𝑥𝑛 ∃𝑜1, … 𝑜𝑘. 𝜙𝐸1(𝑥1, … 𝑥𝑛, 𝑜1, … 𝑜𝑘)} ▪ 𝑥, 𝑦 𝜙𝐸1 𝑥 ∧ 𝜙𝐸2(𝑦)} SPJR Algebra Conjunctive Query Relational Calculus 27 Conjunctive Query • CQ is Monotonic: 𝕀1 ⊆ 𝕀2 ⇒ 𝑄 𝕀1 ⊆ 𝑄(𝕀2) • How to prove it? • 𝑄 = 𝑥1, … 𝑥𝑛 ∃𝑜1, … 𝑜𝑛 𝑅1 𝑥1, ഥ𝑜1 ∧ ⋯ ∧ 𝑅𝑘 𝑥𝑘, 𝑜𝑘 } where ഥ𝑥𝑖 ⊆ 𝑥1, … , 𝑥𝑛 , ഥ𝑜𝑖 ⊆ 𝑜1, … , 𝑜𝑛 . • We prove that any tuple in the answer of 𝑄 𝕀1 will also be in the answer of 𝑄(𝕀2) • If (ෞ𝑥1, … , ෞ𝑥𝑛) ∈ 𝑄(𝕀1), we know that, there exists ෝ𝑜1, … , ෞ𝑜𝑘 such that • ∀𝑖. ෝ𝑥𝑖, ෝ𝑜𝑖 ∈ 𝕀1(𝑅𝑖) • We know that 𝕀1 ⊆ 𝕀2, therefore • ∀𝑖. ෝ𝑥𝑖, ෝ𝑜𝑖 ∈ 𝕀2(𝑅𝑖) • As a result, ෞ𝑥1, … , ෞ𝑥𝑛 ∈ 𝑄 𝕀2 . • Thus, 𝑄 𝕀1 ⊆ 𝑄 𝕀2 . Relational Calculus 28 Summary so far Relational Algebra Relational Calculus Domain Independent Relational Calculus=More Powerful SPJR Algebra Conjunctive Query = Relational Calculus 29 SQL: Structured Query Language Relational Calculus 30 SQL is a standard Relational Calculus 31 SQL is also a product: many dialects Relational Calculus 32 SQL (Structured Query Language) • Different DB engines might have an implementation that is slightly different from the SQL standard, in its own unique way. • Different DB engines might also have SQL extensions that are unique. • We use PostgreSQL as our reference. Relational Calculus 33 SQL is a programming language • We will now start to learn a language… learning from lectures is probably the worst way to do it. • There are only two ways: (1) Practice! (2) Deep Read Reference. • For Practice – Write SQL. • For Reference –Read Chapter 6 of the Stanford Book. • In the lecture, we will provide you the structure to cover things that it is not clear in the textbook, especially the connection between SQL, relational calculus, and logic, and common pitfalls. Relational Calculus 34 SQL (Structured Query Language) • SQL: A Family of Standards • Data definition language (DDL) – (#1) • Data manipulation language (DML) – (#2) • Query Language – (#3) • History • 1974: First paper by Chamberlin & Boyce (called SEQUEL) • SQL 92 (SQL 2): joins, outer-joins, ... • SQL 3 (1999), • SQL/XML (2006) • SQL: 2008 • SQL: 2011 • SQL: 2016 • SQL: 2019 Query Q (1) Define the schema of tables (2) Put info into the table (3) Query it Relational Calculus 35 Note • IMPORTANT: The Relational Calculus and Relational Algebra that we introduced all have SET semantics; while in SQL relations all have BAG semantics!! Each relation in SQL is a BAG; each relation in OUR relational model is a SET. Relational Calculus 36 SQL: Data Definition Language (DDL) Relational Calculus 37 SQL: Data Definition Language (DDL) • DDL provides statements to define the schema. • Recall that a Relation Schema looks like: 𝑅(𝑓1: 𝐷1, … , 𝑓𝑛: 𝐷𝑛) • In SQL, you need to provide (1) name, (2) set of columns, and (3) their types. • Data types: • char (n) • varchar (n) • integer • blob or raw for large binaries • date • … CREATE TABLE Professor( PersNr integer, Name varchar (30) Level character (2) default \"AP”, PRIMARY KEY (PersNr) ); (default – default value if not defined) (PRIMARY KEY – primary key attributes) Professor(PersNr: integer, Name: varchar(30), Level char(2)) Relational Calculus 38 SQL: Data Definition Language (DDL) • You can delete a relation. • Modify structure of a relation. • Add column. • What value will the DB fill for the new column? • If defined default value, set to default value • Otherwise, keep “empty” (it is a special state called NULL that we will learn in the next lecture) • Delete column. • There are more, the best way to learn it is to look it up when you need it. • Search for “SQL add column” DROP TABLE Professor; ALTER TABLE Professor ADD COLUMN (age integer); ALTER TABLE Professor DROP COLUMN age; Relational Calculus 39 SQL: DDL - Example PersNr LectureID Grade 26120 5001 5.0 27550 5001 5.5 26120 5041 5.75 Tests PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor PersNr Name Semester 24002 Peter 8 25403 Mary 6 26120 Frey 2 Student LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture Prerequisite Follow-up 5001 5041 5001 5043 Requires PersNr LectureID 26120 5001 27550 5001 26120 5041 Attends CREATE TABLE Professor( PersNr integer, Name varchar(100), Level varchar(2), Room integer, PRIMARY KEY (PersNr)); CREATE TABLE Student( PersNr integer, Name varchar(100), Semester integer, PRIMARY KEY (PersNr)); CREATE TABLE Lecture ( LectureID integer, Title varchar(100), CP integer, ProfNr integer, PRIMARY KEY (LectureID)); CREATE TABLE Requires ( Prerequisite integer, Follow-up integer, PRIMARY KEY (Prerequisite, Follow-up)); CREATE TABLE Attends ( PersNr integer, LectureID integer, PRIMARY KEY (PersNr, LectureID)); CREATE TABLE Tests ( PersNr integer, LectureID integer, Grade float, PRIMARY KEY (PersNr, LectureID)); Relational Calculus 40 SQL: Data Manipulation Language (DML) Relational Calculus 41 SQL: Data Manipulation Language (DML) PersNr Name Semester 24002 Peter 8 25403 Mary 6 Student INSERT INTO Student (PersNr, Name) VALUES (28121, `Frey`) (What should the DB do for the Semester column? - Either the default value - Or keep it “EMPTY” (the precise meaning of what “EMPTY” means will be clear later in the course) DELETE Student WHERE Semester > 13; UPDATE Student SET Semester = Semester + 1; Relational Calculus 42 SQL: Data Manipulation Language (DML) • ETL: Extract, Transform, Load (ETL) • Populating a real DB cannot be done manually tuple by tuple: cumbersome, error prone, inaccurate, often slow. • Automatic tools are used to • Extract: get data from some file • Transform: apply transformation to the data when needed (types, conversion, format) • Load: insert into the DB as a bulk operation Relational Calculus 43 SQL: Data Manipulation Language (DML) • Two ways to populate this relation. • Tuple by tuple. • Problem? Slow • Overhead of parsing the query • Checking Key-constraints for each query • … • Bulk load • Often faster when you have a large table to fill in. ▪ PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor INSERT INTO Professor VALUES (2125, ‘John’, ‘AP’, 226); INSERT INTO Professor VALUES (2126, ‘David’, ‘FP’, 232); INSERT INTO Professor VALUES (2127, ‘Anna’, ‘FP’, 310); COPY Professor FROM ‘/profs.csv’ WITH FORMAT csv; Relational Calculus 44 SQL: Data Manipulation Language (DML) Relational Calculus 45 • This is a whole industry by itself, specially in the cloud (more later in the course): SQL: Query Language Relational Calculus 46 SQL: Query Language ▪ SELECT … FROM … WHERE … ▪ Π𝑃𝑒𝑟𝑠𝑁𝑟,𝑁𝑎𝑚𝑒 𝜎𝐿𝑒𝑣𝑒𝑙=“𝐹𝑃”𝑃𝑟𝑜𝑓𝑒𝑠𝑠𝑜𝑟 ▪ Sometimes you don’t need to write down the whole list of projected attributes ▪ Π𝑃𝑒𝑟𝑠𝑁𝑟,𝑁𝑎𝑚𝑒,𝐿𝑒𝑣𝑒𝑙,𝑅𝑜𝑜𝑚 𝜎𝐿𝑒𝑣𝑒𝑙=“𝐹𝑃”𝑃𝑟𝑜𝑓𝑒𝑠𝑠𝑜𝑟 PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture SELECT PersNr, Name FROM Professor WHERE Level = `FP`; SELECT * FROM Professor WHERE Level = `FP`; Relational Calculus 47 SQL: Query Language ▪ SELECT … FROM … WHERE … ▪ Π𝑁𝑎𝑚𝑒൫ ൯ 𝜎𝑃𝑒𝑟𝑠𝑁𝑟=𝑃𝑟𝑜𝑓𝑁𝑟∧𝑇𝑖𝑡𝑙𝑒=“𝐷𝑎𝑡𝑎𝑏𝑎𝑠𝑒”(𝑃𝑟𝑜𝑓𝑒𝑠𝑠𝑜𝑟 × 𝐿𝑒𝑐𝑡𝑢𝑟𝑒 ) ➢ FROM defines the list of relations to do cross product ➢ WHERE defines the selection condition ➢ SELECT defines the projection ▪ 𝜌𝑎1…𝑎𝑛(Π𝐴1…𝐴𝑛(𝜎𝑃1∧⋯𝑃𝑚(𝑅1 × ⋯ × 𝑅𝑘))) PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture SELECT Name FROM Professor P, Lecture L WHERE P.PersNr = L.ProfNr AND L.Title = `Database`; SELECT A1 as a1 ... An as an FROM R1 ... Rk WHERE P1 AND P2 ... AND Pm Relational Calculus 48 SQL: Query Language ▪ Selection: 𝜎 ▪ Projection: Π ▪ Cross Product: × ▪ Rename: 𝜌 ▪ 𝜎𝐶(𝑅) ▪ Π𝐴1,…,𝐴𝑛𝑅 ▪ 𝑅1 × 𝑅2 ▪ 𝜌𝑎,𝑏,𝑐𝑅 SELECT * FROM (SQL1) WHERE c; SELECT A1,…,An FROM (SQL1); SELECT * FROM (SQL1), (SQL2); SELECT A as a,…,C as c FROM (SQL1); Every SPJR RA expression can be written in SELECT…FROM…WHERE form. … so does every Conjunctive Query! Relational Calculus 49 SQL: Query Language ▪ Union ➢ 𝑅1 ∪ 𝑅2 ▪ Intersection ➢ 𝑅1 ∩ 𝑅2 ▪ Difference ➢ 𝑅1 − 𝑅2 PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture (SELECT Name FROM Assistant) UNION (SELECT Name FROM Professor); (SELECT Name FROM Assistant) INTERSECT (SELECT Name FROM Professor); (SELECT Name FROM Assistant) EXCEPT (SELECT Name FROM Professor); Relational Calculus 50 SQL: Query Language PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor SELECT Level FROM Professor; Level AP FP FP SELECT DISTINCT Level FROM Professor; Level AP FP SELECT DISTINCT Name, Level FROM Professor; Name Level John AP David FP Anna FP▪ Bag => Set ➢ Again, SQL implements Bag semantics, not Set Relational Calculus 51 SQL: Query Language (SQL1) UNION (SQL2)▪ Union: ∪ ▪ Difference: − ▪ Selection: 𝜎 ▪ Projection: Π ▪ Cross Product: × ▪ Rename: 𝜌 ▪ 𝑅1 ∪ 𝑅2 ▪ 𝑅1 − 𝑅2 ▪ 𝜎𝐶(𝑅) ▪ Π𝐴1,…,𝐴𝑛𝑅 ▪ 𝑅1 × 𝑅2 ▪ 𝜌𝑎,𝑏,𝑐𝑅 (SQL1) EXCEPT (SQL2) SELECT * FROM (SQL1) WHERE c; SELECT A1,…,An FROM (SQL1); SELECT * FROM (SQL1), (SQL2); SELECT A as a,…,C as c FROM (SQL1); Every RA expression can be written in a subset of SQL. … so does every Domain-independent Relational Calculus Query! Relational Calculus 52 Summary so far Relational Algebra Relational Calculus Domain Independent Relational Calculus=More Powerful SPJR Algebra Conjunctive Query SELECT… FROM … WHERE… SQL Subset SQL Practial Query Language = = = Relational Calculus 53 SQL: Examples Relational Calculus 54 SQL: Query Language ▪ Sorting ▪ Tables are not sorted by default; if a result needs to be sorted, the query needs to specify it explicitly. SELECT PersNr, Name, Level FROM Professor ORDER BY Level DESC, Name DESC; PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor PersNr Name Level Room 2126 David FP 232 2127 Anna FP 310 2125 John AP 226 Relational Calculus 55 SQL: Query Language ▪ Grouping, Aggregation ▪ Can use different aggregation functions such as SUM, AVG, COUNT, etc. ▪ Group table by different values for attributes in GROUP BY, for each group, apply the aggregation function. PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor Level Count FP 2 AP 1 SELECT Level, COUNT(*) FROM Professor GROUP BY Level; SELECT COUNT(*) FROM Professor; Count 3 Relational Calculus 56 SQL: Query Language PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture SELECT p.PersNr, Name, sum (CP) FROM Lecture l, Professor p WHERE l.ProfNr= p.PersNr and level = ´FP´ GROUP BY p.PersNr, Name HAVING avg (CP) >= 3; Filter groups with condition AVG(CP) >= 3 Relational Calculus 57 SQL: Query Language PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture ▪ Existential Quantification SELECT p.Name FROM Professor p WHERE p.PersNr NOT IN (SELECT PersNr FROM Lecture); SELECT p.Name FROM Professor p WHERE NOT EXISTS (SELECT * FROM Lecture l WHERE l.PersNr = p.PersNr); Correlated Subquery Uncorrelated Subquery Return true when the subquery is empty (Logically) Eval subquery for every value of p Relational Calculus 58 SQL: Query Language PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture ▪ Existential Quantification ➢ DB often automatically conducts query rewriting to translate the query into a form that is easier to optimize SELECT p.Name FROM Professor p WHERE EXISTS (SELECT * FROM Lecture l WHERE l.PersNr = p.PersNr); SELECT p.Name FROM Professor p, Lecture l WHERE p.PersNr = l.PersNr; Relational Calculus 59 SQL: Query Language • Many clauses: • ANY, ALL, SOME … • We really want you to exercise the process of learning by yourself – Search and learn! • (It WILL be in the exam) https://www.postgresql.org/docs/8.1/functions-subquery.html https://www.postgresqltutorial.com/postgresql-any/ Relational Calculus 60 PersNr LectureID Grade 26120 5001 5.0 27550 5001 5.5 26120 5041 5.75 DB Instance Tests PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor PersNr Name Semester 24002 Peter 8 25403 Mary 6 26120 Frey 2 Student LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture Prerequisite Follow-up 5001 5041 5001 5043 Requires PersNr LectureID 26120 5001 27550 5001 26120 5041 Attends Q. All Students who take Databases Π𝑃𝑒𝑟𝑠𝑁𝑟𝜎𝑇𝑖𝑡𝑙𝑒=“𝐷𝑎𝑡𝑎𝑏𝑎𝑠𝑒”( ) 𝑆𝑡𝑢𝑑𝑒𝑛𝑡 ⋈ 𝐴𝑡𝑡𝑒𝑛𝑑𝑠 ⋈ 𝐿𝑒𝑐𝑡𝑢𝑟𝑒) {𝑝 ∶ ∃ 𝑛 , 𝑠. 𝑆𝑡𝑢𝑑𝑒𝑛𝑡 𝑝, 𝑛 𝑠 ∧ ∃ 𝑙, 𝑡, 𝑐, 𝑝𝑟. (𝐴𝑡𝑡𝑒𝑛𝑑𝑠 𝑝, 𝑙 . ∧ 𝐿𝑒𝑐𝑡𝑢𝑟𝑒 𝑙, 𝑡, 𝑐, 𝑝𝑟 ∧ 𝑡 = ”𝑇𝑖𝑡𝑙𝑒”)} SELECT S.PersNr FROM Student S, Attends A, Lecture L WHERE S.PersNr = A.PersNr AND A.LectureID = L.LectureID AND L.Title = 'Databases' Relational Calculus 61 PersNr LectureID Grade 26120 5001 5.0 27550 5001 5.5 26120 5041 5.75 DB Instance Tests PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor PersNr Name Semester 24002 Peter 8 25403 Mary 6 26120 Frey 2 Student LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture Prerequisite Follow-up 5001 5041 5001 5043 Requires PersNr LectureID 26120 5001 27550 5001 26120 5041 Attends Q. Profs who don’t teach. Π𝑃𝑒𝑟𝑠𝑁𝑟𝑃𝑟𝑜𝑓𝑒𝑠𝑠𝑜𝑟 − Π𝑃𝑒𝑟𝑠𝑁𝑟 𝑃𝑟𝑜𝑓𝑒𝑠𝑠𝑜𝑟 ⋈𝑃𝑒𝑟𝑠𝑁𝑟=𝑃𝑟𝑜𝑓𝑁𝑟 𝐿𝑒𝑐𝑡𝑢𝑟𝑒 {𝑝 ∶ ∃𝑛, 𝑙, 𝑟. 𝑃𝑟𝑜𝑓𝑒𝑠𝑠𝑜𝑟 𝑝, 𝑛, 𝑙, 𝑟 ∧ ¬∃𝑙𝑒, 𝑡, 𝑐𝑝. 𝐿𝑒𝑐𝑡𝑢𝑟𝑒(𝑙𝑒, 𝑡, 𝑐𝑝, 𝑝)} (SELECT PersNr FROM Professor) EXCEPT (SELECT P.PersNr FROM Professor P, Lecture L WHERE P.PersNr = L.ProfNr) Relational Calculus 62 PersNr LectureID Grade 26120 5001 3.0 27550 5001 5.5 26120 5041 5.75 DB Instance Tests PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor PersNr Name Semester 24002 Peter 8 25403 Mary 6 26120 Frey 2 Student LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture Prerequisite Follow-up 5001 5041 5001 5043 Requires PersNr LectureID 26120 5001 27550 5001 26120 5041 Attends Q. Course that Students cannot take because failing the pre-requisites. Π𝑃𝑒𝑟𝑠𝑁𝑟,𝐹𝑜𝑙𝑙𝑜𝑤−𝑢𝑝(൫ ൯ 𝜎𝐺𝑟𝑎𝑑𝑒<4.0( ) 𝑆𝑡𝑢𝑑𝑒𝑛𝑡 ⋈ 𝑇𝑒𝑠𝑡𝑠 ⋈𝐿𝑒𝑐𝑡𝑢𝑟𝑒𝐼𝐷=𝑃𝑟𝑒𝑟𝑒𝑞𝑢𝑖𝑠𝑖𝑡𝑒 𝑅𝑒𝑞𝑢𝑖𝑟𝑒𝑠) {(𝑠, 𝑙) ∶ ∃ 𝑛, 𝑠𝑒. 𝑆𝑡𝑢𝑑𝑒𝑛𝑡 𝑠, 𝑛, 𝑠𝑒 ∧ ∃ 𝑙𝑒, 𝑔, . (𝑇𝑒𝑠𝑡𝑠 𝑠, 𝑙𝑒, 𝑔 ∧ 𝑔 < 4.0 ∧ 𝑅𝑒𝑞𝑢𝑖𝑟𝑒𝑠 𝑙𝑒, 𝑙 )} SELECT S.PersNr, R.Follow-up FROM Student S, Tests T, Requires R WHERE S.PersNr = T.PersNr AND T.Grade < 4.0 AND T.LectureID = R.Prerequisite; Relational Calculus 63 Lessons learned • The basis for SQL are relational calculus and relational algebra • Relational calculus needs to be restricted to be practical in databases • Close world assumption in databases • SQL is a declarative programming language • States what tuples should be in the result • Basic operations are relational algebra operators • You need to program queries in SQL … Relational Calculus 64","libVersion":"0.3.2","langs":""}