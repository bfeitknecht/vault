{"path":"sem4/DMDB/VRL/extra/slides/DMDB-s-w01-relational_algebra.pdf","text":"Data Modeling and Databases Spring Semester 2025 Relational Calculus Relational Calculus Gustavo Alonso Institute of Computing Platforms Department of Computer Science ETH ZÃ¼rich 1 Relational Algebra II Relational Calculus 2 Practical Query Language The bigger picture Relational Algebra Relational Calculus Domain Independent Relational Calculus=More Powerful SPJR Algebra Conjunctive Query SELECTâ€¦ FROM â€¦ WHEREâ€¦ SQL Subset SQL = = = Relational Calculus 3 Relational Algebra is not perfect â€¢ Letâ€™s look at one limitation of Relational Algebra. â€¢ Q: Find all ancestors of B â€¢ ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘‚ğ‘“ğµ = Î ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğœğ‘â„ğ‘–ğ‘™ğ‘‘=ğµğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡) â€¢ ğºğ‘Ÿğ‘ğ‘›ğ‘‘ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘‚ğ‘“ğµ = Î ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡.ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ â‹ˆğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡.ğ‘â„ğ‘–ğ‘™ğ‘‘=ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘‚ğ‘“ğµ.ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘‚ğ‘“ğµ) â€¢ ğºğ‘Ÿğ‘’ğ‘ğ‘¡ğºğ‘Ÿğ‘ğ‘›ğ‘‘ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘‚ğ‘“ğµ = Î ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡.ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ â‹ˆğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡.ğ‘â„ğ‘–ğ‘™ğ‘‘=ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘‚ğ‘“ğµ.ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ ğºğ‘Ÿğ‘ğ‘›ğ‘‘ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘‚ğ‘“ğµ) â€¢ â€¦ â€¢ It never ends â€“ There is no â€œfor loopâ€ in Relational Algebra. â€¢ We will talk about the solution to this later in the course. parent child A B C A D C Parent Relational Calculus 4 Extensions to RA: Bags â€¢ So far, we are assuming the Set semantics for relational model and relational algebra. â€¢ Real-world database uses Bag semantics instead â€“ â€¢ Each relation is a bag of tuples. â€¢ You can have duplicated tuples in the same relation. â€¢ Set: {1, 2, 3} â€¢ Bag: {1, 2, 1, 3, 1, 2} â€¢ We need to be careful when extending Relational Algebra to bags. â€¢ Note: Keys will still be unique Relational Calculus 5 RA for Bags â€¢ Operator semantics are different: â€¢ Bag Union: {1, 2, 1} âˆª {1, 2, 3} = {1, 1, 1, 2, 2, 3} â€¢ Bag Difference: {1, 2, 1} â€“ {1, 2, 3, 3} = {1} â€¢ Laws are different too. â€¢ ğ‘… âˆ© ğ‘† âˆª ğ‘‡ â‰¡? â‰¡ ğ‘… âˆ© ğ‘† âˆª (ğ‘… âˆ© ğ‘‡) â€¢ Think about the case R = S = T = {1} â€¢ Also need new operators â€¢ Duplication elimination ğ›¿ Relational Calculus 6 Other Extensions to RA â€¢ We can also extend RA with other operators: â€¢ Sorting: ğœ‹ â€¢ Group-and-aggregation: ğ›¾ â€¢ In SQL, relational Algebra is a subset of what SQL can do (the core data manipulation part, but a small subset) Relational Calculus 7 Relational Algebra is very visible in todayâ€™s systems â€¢ The impact of Relational Algebra goes beyond DBMS â€¢ You can see it in modern data analytics frameworks. â€¢ E.g., PANDAS & DataFrame Relational Calculus 8 Relational Calculus Relational Calculus 9 Recap: First-order Logic -- Syntax â€¢ To express: â€¢ Alice and Bob both know arithmetic => Knows(alice, arithmetic) âˆ§ Knows(bob, arithmetic) â€¢ All students know arithmetic => âˆ€ğ‘¥. ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ ğ‘¥ â‡’ ğ¾ğ‘›ğ‘œğ‘¤ğ‘ (ğ‘¥, ğ‘ğ‘Ÿğ‘–ğ‘¡â„ğ‘šğ‘’ğ‘¡ğ‘–ğ‘) â€¢ Terms, referring to objects â€¢ Constant: e.g., alice, bob â€¢ Variable: x â€¢ Function of terms: Sum(3, x) â€¢ Formula â€¢ Atomic formulas (atoms) -- Predicate applied to terms: ğ¾ğ‘›ğ‘œğ‘¤ğ‘ (ğ‘¥, ğ‘ğ‘Ÿğ‘–ğ‘¡â„ğ‘šğ‘’ğ‘¡ğ‘–ğ‘) â€¢ Connectives applied to formulas: ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ ğ‘¥ â‡’ ğ¾ğ‘›ğ‘œğ‘¤ğ‘ (ğ‘¥, ğ‘ğ‘Ÿğ‘–ğ‘¡â„ğ‘šğ‘’ğ‘¡ğ‘–ğ‘) â€¢ Quantifiers applied to formulas: âˆ€ğ‘¥. ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ ğ‘¥ â‡’ ğ¾ğ‘›ğ‘œğ‘¤ğ‘ (ğ‘¥, ğ‘ğ‘Ÿğ‘–ğ‘¡â„ğ‘šğ‘’ğ‘¡ğ‘–ğ‘) Relational Calculus 10 Recap: First-order Logic -- Syntax â€¢ There is a course that every student has taken âˆƒ ğ‘¦ ğ¶ğ‘œğ‘¢ğ‘Ÿğ‘ ğ‘’ ğ‘¦ âˆ§ [âˆ€ğ‘¥ ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡(ğ‘¥) â‡’ ğ‘‡ğ‘ğ‘˜ğ‘’ğ‘ (ğ‘¥, ğ‘¦) ] â€¢ What does this sentence/formula mean? â€¢ => Semantics Relational Calculus 11 Recap: First-order Logic - Semantics â€¢ ğœ™ â‰” âˆƒ ğ‘¦ ğ¶ğ‘œğ‘¢ğ‘Ÿğ‘ ğ‘’ ğ‘¦ âˆ§ [âˆ€ğ‘¥ ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡(ğ‘¥) â‡’ ğ‘‡ğ‘ğ‘˜ğ‘’ğ‘ (ğ‘¥, ğ‘¦) ] â€¢ Is this true? â€¢ In a database, depends on the data in the instance Course(Database) = True Course(Machine Learning) = True Student(Alice) = True Student(Bob) = True Takes(Alice, Database) Takes(Alice, Machine Learning) Takes(Bob, Database) âŠ¨ ğœ™ Course(Database) = True Course(Machine Learning) = True Student(Alice) = True Student(Bob) = True Takes(Alice, Machine Learning) Takes(Bob, Database) âŠ­ ğœ™ âŠ¨ satisfies Relational Calculus 12 Recap: First-order Logic - Semantics â€¢ ğœ™ â‰” âˆƒ ğ‘¦ ğ¶ğ‘œğ‘¢ğ‘Ÿğ‘ ğ‘’ ğ‘¦ âˆ§ [âˆ€ğ‘¥ ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡(ğ‘¥) â‡’ ğ‘‡ğ‘ğ‘˜ğ‘’ğ‘ (ğ‘¥, ğ‘¦) ] â€¢ Is this true? â€¢ It depends on the instance. â€¢ Domain: All possible symbols: â€¢ ğ”» = {ğ·ğ‘ğ‘¡ğ‘ğ‘ğ‘ğ‘ ğ‘’, ğ‘€ğ‘ğ‘â„ğ‘–ğ‘›ğ‘’ ğ¿ğ‘’ğ‘ğ‘Ÿğ‘›ğ‘–ğ‘›ğ‘”, ğ´ğ‘™ğ‘–ğ‘ğ‘’, ğµğ‘œğ‘, ğ¿ğ‘ğ‘ğ‘¡ğ‘œğ‘ â€¦ } â€¢ Interpretation: Map each Predicate to tuples of elements that are true for this Predicate â€¢ ğ•€ ğ¶ğ‘œğ‘¢ğ‘Ÿğ‘ ğ‘’ = ğ·ğ‘ğ‘¡ğ‘ğ‘ğ‘ğ‘ ğ‘’, ğ‘€ğ‘ğ‘â„ğ‘–ğ‘›ğ‘’ ğ¿ğ‘’ğ‘ğ‘Ÿğ‘›ğ‘–ğ‘›ğ‘” â€¢ ğ•€ ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ = {ğ´ğ‘™ğ‘–ğ‘ğ‘’, ğµğ‘œğ‘} â€¢ ğ•€ ğ´ğ‘¡ğ‘¡ğ‘’ğ‘›ğ‘‘ğ‘  = ğ´ğ‘™ğ‘–ğ‘ğ‘’, ğ·ğ‘ğ‘¡ğ‘ğ‘ğ‘ğ‘ ğ‘’ , ğ´ğ‘™ğ‘–ğ‘ğ‘’, ğ‘€ğ¿ , ğµğ‘œğ‘ ğ·ğ‘ğ‘¡ğ‘ğ‘ğ‘ğ‘ ğ‘’ â€¢ Model: â„³ = (ğ”», ğ•€) â€¢ â„³ âŠ¨ ğœ™. iff ğœ™ evaluates to True under â„³ â€¢ â„³ âŠ­ ğœ™. iff ğœ™ evaluates to False under â„³ Course(Database) = True Course(Machine Learning) = True Student(Alice) = True Student(Bob) = True Takes(Alice, Database) Takes(Alice, Machine Learning) Takes(Bob, Database) âŠ¨ ğœ™ Relational Calculus 13 Recap: First-order Logic - Semantics â€¢ ğœ™â€² â‰” ğ¶ğ‘œğ‘¢ğ‘Ÿğ‘ ğ‘’ ğ‘¦ âˆ§ [âˆ€ğ‘¥ ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡(ğ‘¥) â‡’ ğ‘‡ğ‘ğ‘˜ğ‘’ğ‘ (ğ‘¥, ğ‘¦) ] â€¢ Is this true under the model â„³? â€¢ Well, depends on ğ‘¦ â€¢ If ğ‘¦ is â€œDatabaseâ€, then ğœ™â€² is true â€¢ If ğ‘¦ is â€œMachine Learningâ€, then ğœ™â€² is false â€¢ Assignment: Map all free variables to a concrete constant. â€¢ E.g., Two possible assignments â€¢ ğ›¼ = ğ‘¦ â‡’ â€ğ·ğ‘ğ‘¡ğ‘ğ‘ğ‘ğ‘ ğ‘’â€ â€¢ ğ›¼â€² = {ğ‘¦ â‡’ â€ğ‘€ğ‘ğ‘â„ğ‘–ğ‘›ğ‘’ ğ¿ğ‘’ğ‘ğ‘Ÿğ‘›ğ‘–ğ‘›ğ‘”â€} â€¢ â„³, ğ›¼ âŠ¨ ğœ™. iff ğœ™ evaluates to True under â„³ and ğ›¼ â€¢ â„³, ğ›¼â€² âŠ­ ğœ™. iff ğœ™ evaluates to False under â„³ and ğ›¼â€² Course(Database) = True Course(Machine Learning) = True Student(Alice) = True Student(Bob) = True Takes(Alice, Database) Takes(Alice, Machine Learning) Takes(Bob, Database) â„³ Relational Calculus 14 Relational Calculus as query language â€¢ We have seen how Relational Algebra queries the data in an imperative way â€“ the system can follow step-by-step the expression and get the result. â€¢ We now show a query language that queries the data in a declarative way â€“ it tells the system WHAT we want, instead of HOW to get it. â€¢ It is by using Logic: (Domain) Relational Calculus. â€¢ Relation as logic predicates. Relation instance as â€œfactsâ€: â€¢ (0, John, Zurich) âˆˆ Customer => Customer(0, John, Zurich) = True â€¢ Example â€¢ (ğ‘ğ‘–ğ‘‘, ğ‘ğ‘–ğ‘‘) âˆƒğ‘›, ğ‘ ğ‘ƒğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡ ğ‘ğ‘–ğ‘‘, ğ‘›, ğ‘ âˆ§ âˆƒğ‘ğ‘›, ğ‘ ğ¶ğ‘¢ğ‘ ğ‘¡ğ‘œğ‘šğ‘’ğ‘Ÿ ğ‘ğ‘–ğ‘‘, ğ‘ğ‘›, ğ‘ âˆ§ âˆƒğ‘  (ğ‘ƒğ‘¢ğ‘Ÿğ‘â„ğ‘ğ‘ ğ‘’(ğ‘ğ‘–ğ‘‘, ğ‘ğ‘–ğ‘‘, ğ‘ ))} â€¢ All (ğ‘ğ‘–ğ‘‘, ğ‘ğ‘–ğ‘‘) tuples belonging to the above set are in the answer of this query. â€¢ It is easy to see that this query gets the same result as the following relational algebra query, but we never define the join order (i.e., declarative) â€¢ Î ğ‘ğ‘–ğ‘‘,ğ‘ğ‘–ğ‘‘((ğ¶ğ‘¢ğ‘ ğ‘¡ğ‘œğ‘šğ‘’ğ‘Ÿ â‹ˆ ğ‘ƒğ‘¢ğ‘Ÿğ‘â„ğ‘ğ‘ ğ‘’) â‹ˆ ğ‘ƒğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡) Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva If you relation is a Set: (ğ‘ğ‘–ğ‘‘, ğ‘ğ‘–ğ‘‘) âˆƒğ‘›, ğ‘ ğ‘ğ‘–ğ‘‘, ğ‘›, ğ‘ âˆˆ ğ‘ƒğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡ âˆ§ âˆƒğ‘ğ‘›, ğ‘ ğ‘ğ‘–ğ‘‘, ğ‘ğ‘›, ğ‘ âˆˆ ğ¶ğ‘¢ğ‘ ğ‘¡ğ‘œğ‘šğ‘’ğ‘Ÿ âˆ§ âˆƒğ‘  ( ğ‘ğ‘–ğ‘‘, ğ‘ğ‘–ğ‘‘, ğ‘  âˆˆ ğ‘ƒğ‘¢ğ‘Ÿğ‘â„ğ‘ğ‘ ğ‘’)} Relational Calculus 15 Relational Calculus as query language â€¢ Schema â€¢ Database Schema: ğ‘† = (ğ‘…1, â€¦ ğ‘…ğ‘š) where each ğ‘…ğ‘– is a Relation. â€¢ Relation Schema: ğ‘…(ğ´1: ğ·1, â€¦ , ğ´ğ‘›: ğ·ğ‘›) â€¢ Domain: dom =âˆªğ‘– ğ·ğ‘– -- Infinite set of constants â€¢ Instance â€¢ Instance of ğ‘…(ğ´1: ğ·1, â€¦ , ğ´ğ‘›: ğ·ğ‘›): ğ¼ğ‘… âŠ† domğ‘› and ğ¼ğ‘… is finite â€¢ Instance of DB ğ‘†(ğ‘…1, â€¦ , ğ‘…ğ‘š): ğ•€ a function that maps ğ‘…ğ‘– to an instance of ğ‘…ğ‘–, i. e. , ğ•€ ğ‘…ğ‘– â€¢ An instance of a relation is a finite set of facts over the relation. â€¢ An instance of DB is a finite set of facts over all relations. Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 16 Relational Calculus as query language â€¢ (ğ‘ğ‘–ğ‘‘, ğ‘ğ‘–ğ‘‘) âˆƒğ‘›, ğ‘ ğ‘ƒğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡ ğ‘ğ‘–ğ‘‘, ğ‘›, ğ‘ âˆ§ âˆƒğ‘ğ‘›, ğ‘ ğ¶ğ‘¢ğ‘ ğ‘¡ğ‘œğ‘šğ‘’ğ‘Ÿ ğ‘ğ‘–ğ‘‘, ğ‘ğ‘›, ğ‘ âˆ§ âˆƒğ‘  (ğ‘ƒğ‘¢ğ‘Ÿğ‘â„ğ‘ğ‘ ğ‘’(ğ‘ğ‘–ğ‘‘, ğ‘ğ‘–ğ‘‘, ğ‘ ))} â€¢ Syntax: â€¢ Let ğœ™ be a first-order logic formula with free variables ğ‘¥1, â€¦ , ğ‘¥ğ‘˜, ğ‘„ğœ™ = {(ğ‘¥1, â€¦ ğ‘¥ğ‘˜)|ğœ™} is a domain relational calculus query. â€¢ Semantics: â€¢ Each relation ğ‘… corresponds to a predicate ğ‘… in ğœ™ â€¢ Each instance ğ•€ corresponds to a first-order interpretation ğ•€. â€¢ An assignment is a mapping ğ›¼: ğ‘£ğ‘ğ‘Ÿ â†’ dom â€¢ The answer of ğ‘„ over ğ•€ is ğ‘„ ğ•€ = ğ›¼ ğ‘¥1 , â€¦ ğ›¼ ğ‘¥ğ‘˜ ğ•€, ğ›¼ âŠ¨ ğœ™ â€¢ Is (0, 0) in the answer? Yes â€“ (pid, n, p) = (0, iPhone, 110), (cid, cn, c) = (0, John, Zurich), s = A. If these variables take these values, the formula is true. â€¢ Is (0, 2) in the answer? No â€“ Why? Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 17 Relational Calculus as query language - finite â€¢ Given a relational calculus query ğ‘„ğœ™ = {(ğ‘¥1, â€¦ ğ‘¥ğ‘˜)|ğœ™}, is the answer always finite? â€¢ No â€“ Think about the following query â€¢ ğ‘„ = {(ğ‘ğ‘–ğ‘‘, ğ‘›ğ‘ğ‘šğ‘’, ğ‘ğ‘Ÿğ‘–ğ‘ğ‘’)|Â¬ğ‘ƒğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡(ğ‘ğ‘–ğ‘‘, ğ‘›ğ‘ğ‘šğ‘’, ğ‘ğ‘Ÿğ‘–ğ‘ğ‘’)} â€¢ Given an empty instance, the answer of ğ‘„({}) isâ€¦ dom3 â€¢ Why? â€“ Everything in dom3 satisfies ğœ™ when ğ‘ƒğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡ is empty â€¢ Recall that domain is infinite. The answer to this query is infinite. â€¢ We donâ€™t want our DB to output infinite answers â€¢ We need to constrain the set of queries that we can ask. â€¢ Safe query vs. Unsafe query â€¢ Domain independent relational calculus â€“ a safe semantic for queries. Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 18 Relational Calculus as query language â€“ Safety â€¢ Let ğ‘„ğœ™ be a relational calculus query, we say ğ‘„ğœ™ is safe, if ğ‘„ğœ™(ğ•€) is finite for all instances ğ•€. â€¢ All these queries safe? â€¢ ğ‘¥ Â¬ğ‘…(ğ‘¥)} â€¢ No â€¢ ğ‘¥ âˆƒğ‘¦. ğ‘… ğ‘¥ âˆ¨ ğ‘…(ğ‘¦)} â€¢ No â€¢ ğ‘¦ âˆƒğ‘¥. ğ‘…(ğ‘¥)} â€¢ No â€¢ ğ‘¥ ğ‘… ğ‘¥ âˆ¨ Â¬ğ‘…(ğ‘¥)} â€¢ No Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 19 Relational Calculus as query language â€“ Safety â€¢ Let ğ‘„ğœ™ be a relational calculus query, we say ğ‘„ğœ™ is safe, if ğ‘„ğœ™(ğ•€) is finite for all instances ğ•€. â€¢ How hard is it to decide whether a query is safe? â€¢ Undecidable â€¢ Reduction: FO finite satisfiability â€¢ What should we do? â€¢ Constrain the syntax, â€¢ or Redefine the semantics â€¢ Letâ€™s look at the semantics first Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 20 Domain Independent Relational Calculus â€¢ A query where the answer depends not only on (1) the interpretation of the relations (i.e., the DB instance), but also on (2) the domain is called domain dependent. â€¢ We hope to turn a RC query ğ‘„ğœ™ into something domain independent. â€¢ Active domain: ğ‘ğ‘‘ğ‘œğ‘š(ğ‘„ğœ™, ğ•€)=all constants in ğ‘„ğœ™ and ğ•€. â€¢ Active Domain Semantics for ğ‘„ğœ™: ğ‘„ğ‘ğ‘‘ğ‘œğ‘š(ğœ™,ğ•€) = ğ‘¥1, â€¦ ğ‘¥ğ‘› ğœ™ âˆ§ âˆ€ğ‘–, ğ‘¥ğ‘–âˆˆ ğ‘ğ‘‘ğ‘œğ‘š(ğœ™, ğ•€)} (also all quantifier âˆ€ğ‘£ğ‘–, âˆƒğ‘£ğ‘– in ğœ™ becomes âˆ€ğ‘£ğ‘– âˆˆ ğ‘ğ‘‘ğ‘œğ‘š ğœ™, ğ•€ , âˆƒğ‘£ğ‘– âˆˆ ğ‘ğ‘‘ğ‘œğ‘š ğœ™, ğ•€ ) â€¢ RC under Active Domain Semantics always return finite answer. â€¢ Why?ğ‘ğ‘‘ğ‘œğ‘š(ğœ™, ğ•€) is finite since both ğœ™ and ğ•€ are finite. Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Relational Calculus 21 Relational Algebra vs Relational Calculus â€¢ From the theory side: â€¢ RC is more powerful than RA: â€¢ First prove that all queries in RA can be expressed in RC (induction over structure) â€¢ Then prove that some query in RC cannot be expressed in RA â€“ RA always returns finite answers but RC can have unsafe query. â€¢ Coddâ€™s Theorem: Domain-independent RC is as powerful as RA. â€¢ All RA expressions can be expressed in DI-RC â€¢ All DI-RC queries can be expressed as RA expressions. â€¢ From the system side â€“ RC is declarative, RA is imperative â€¢ In DB â€“ User writes RC, system automatically finds the best RA. Because of Coddâ€™s theorem, this is always possible. â€¢ This is where the power of DBMS comes from!! Product pid name price 0 iPhone 110 1 Blackberry 120 2 Android 130 Purchase pid cid store 0 0 A 0 1 B 1 1 C Customer cid name city 0 John Zurich 1 Anna Munich 2 Kevin Geneva Î ğ‘ğ‘–ğ‘‘,ğ‘ğ‘–ğ‘‘((ğ‘ƒğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡ â‹ˆ ğ‘ƒğ‘¢ğ‘Ÿğ‘â„ğ‘ğ‘ ğ‘’) â‹ˆ ğ‘ƒğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡)(ğ‘ğ‘–ğ‘‘, ğ‘ğ‘–ğ‘‘) âˆƒğ‘›, ğ‘ ğ‘ƒğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡ ğ‘ğ‘–ğ‘‘, ğ‘›, ğ‘ âˆ§ âˆƒğ‘ğ‘›, ğ‘ ğ¶ğ‘¢ğ‘ ğ‘¡ğ‘œğ‘šğ‘’ğ‘Ÿ ğ‘ğ‘–ğ‘‘, ğ‘ğ‘›, ğ‘ âˆ§ âˆƒğ‘  (ğ‘ƒğ‘¢ğ‘Ÿğ‘â„ğ‘ğ‘ ğ‘’(ğ‘ğ‘–ğ‘‘, ğ‘ğ‘–ğ‘‘, ğ‘ ))} Relational Calculus Relational Algebra Relational Calculus 22 Relational DB vs. First-order Logic Query â€¢ So far, we focused on their similarities. But there are also differences. â€¢ DB Instance ~ First-order Interpretationâ€¦ but: â€¢ First-order logic: Interpretation could be infinite. â€¢ Think about the predicate: Integer(x) â€¢ Database: DB instance is finite â€¢ Why? Well, we need to store them somewhereâ€¦ â€¢ This seemly small difference leads to a whole field of study: finite model theory. Very different from what you see in first-order logic. https://dl.acm.org/doi/abs/10.1145/1559795.1559807 PODSâ€™09 https://link.springer.com/book/10.1007/978-3-662-07003-1 (available for download at ETH) Relational Calculus 23 Summary so far Relational Algebra Relational Calculus Domain Independent Relational Calculus=More Powerful Relational Calculus 24 Conjunctive Query and SPJR algebra Relational Calculus 25 Conjunctive Query â€¢ Domain independent Relational Calculus is still tremendously difficult to analyze: â€¢ Given a DI-RC query ğœ™, does there exist a DB instance such that it outputs non-empty answers? â€“ Satisfiability, Undecidable! â€¢ Given two DI-RC queries ğœ™1, ğœ™2, are they equivalent under all possible instances? â€“ Equivalence, Undecidable! â€¢ We can constrain our query language such that checking these properties is easier. â€¢ Conjunctive Query: ğœ™ = âˆƒğ‘¦1, â€¦ , ğ‘¦ğ‘™(ğ´1 âˆ§ â‹¯ âˆ§ ğ´ğ‘š), ğ‘„ğœ™ = ğ‘¥1, â€¦ ğ‘¥ğ‘› ğœ™} each ğ´ğ‘— is an atom. â€¢ RC expressions with conjunction and existential quantification but without disjunction, negation, or universal quantification. â€¢ Example, given relation Professor(profID, name) and Lecture(lectureid, title, profID), get all pairs of Prof and Lectures in which the Prof teaches the Lecture: â€¢ ğ‘›ğ‘ğ‘šğ‘’, ğ‘¡ğ‘–ğ‘¡ğ‘™ğ‘’ âˆƒğ‘ğ‘–ğ‘‘, ğ‘™ğ‘–ğ‘‘. ğ‘ƒğ‘Ÿğ‘œğ‘“ğ‘’ğ‘ ğ‘ ğ‘œğ‘Ÿ ğ‘ğ‘–ğ‘‘, ğ‘›ğ‘ğ‘šğ‘’ âˆ§ ğ¿ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’(ğ‘™ğ‘–ğ‘‘, ğ‘¡ğ‘–ğ‘¡ğ‘™ğ‘’, ğ‘ğ‘–ğ‘‘)} â€¢ Lots of good, and interesting properties, letâ€™s see some examples Relational Calculus 26 Conjunctive Query â€¢ CQ is as expressive as RA with only Selection, Projection, Join, and Renaming (SPJR Algebra). â€¢ How to prove it? â€¢ Any SPJR expression can be expressed in CQ â€¢ Any CQ query can be expressed in SPJR expression â€¢ Establish one-to-one correspondence in structure â–ª ğ‘… â–ª ğœğ¶ ğ¸1 â–ª Î ğ´1,â€¦,ğ´ğ‘› ğ¸1 â–ª ğ¸1 Ã— ğ¸2 â–ª ğœŒğ‘1,â€¦,ğ‘ğ‘›(ğ¸1) â–ª ğ‘¥ ğ‘…(ğ‘¥)} â–ª ğ‘¥ ğœ™ğ¸1(ğ‘¥) âˆ§ ğœ™ğ¶(ğ‘¥)} â–ª ğ‘¥1, â€¦ ğ‘¥ğ‘› âˆƒğ‘œ1, â€¦ ğ‘œğ‘˜. ğœ™ğ¸1(ğ‘¥1, â€¦ ğ‘¥ğ‘›, ğ‘œ1, â€¦ ğ‘œğ‘˜)} â–ª ğ‘¥, ğ‘¦ ğœ™ğ¸1 ğ‘¥ âˆ§ ğœ™ğ¸2(ğ‘¦)} SPJR Algebra Conjunctive Query Relational Calculus 27 Conjunctive Query â€¢ CQ is Monotonic: ğ•€1 âŠ† ğ•€2 â‡’ ğ‘„ ğ•€1 âŠ† ğ‘„(ğ•€2) â€¢ How to prove it? â€¢ ğ‘„ = ğ‘¥1, â€¦ ğ‘¥ğ‘› âˆƒğ‘œ1, â€¦ ğ‘œğ‘› ğ‘…1 ğ‘¥1, à´¥ğ‘œ1 âˆ§ â‹¯ âˆ§ ğ‘…ğ‘˜ ğ‘¥ğ‘˜, ğ‘œğ‘˜ } where à´¥ğ‘¥ğ‘– âŠ† ğ‘¥1, â€¦ , ğ‘¥ğ‘› , à´¥ğ‘œğ‘– âŠ† ğ‘œ1, â€¦ , ğ‘œğ‘› . â€¢ We prove that any tuple in the answer of ğ‘„ ğ•€1 will also be in the answer of ğ‘„(ğ•€2) â€¢ If (à·ğ‘¥1, â€¦ , à·ğ‘¥ğ‘›) âˆˆ ğ‘„(ğ•€1), we know that, there exists à·ğ‘œ1, â€¦ , à·ğ‘œğ‘˜ such that â€¢ âˆ€ğ‘–. à·ğ‘¥ğ‘–, à·ğ‘œğ‘– âˆˆ ğ•€1(ğ‘…ğ‘–) â€¢ We know that ğ•€1 âŠ† ğ•€2, therefore â€¢ âˆ€ğ‘–. à·ğ‘¥ğ‘–, à·ğ‘œğ‘– âˆˆ ğ•€2(ğ‘…ğ‘–) â€¢ As a result, à·ğ‘¥1, â€¦ , à·ğ‘¥ğ‘› âˆˆ ğ‘„ ğ•€2 . â€¢ Thus, ğ‘„ ğ•€1 âŠ† ğ‘„ ğ•€2 . Relational Calculus 28 Summary so far Relational Algebra Relational Calculus Domain Independent Relational Calculus=More Powerful SPJR Algebra Conjunctive Query = Relational Calculus 29 SQL: Structured Query Language Relational Calculus 30 SQL is a standard Relational Calculus 31 SQL is also a product: many dialects Relational Calculus 32 SQL (Structured Query Language) â€¢ Different DB engines might have an implementation that is slightly different from the SQL standard, in its own unique way. â€¢ Different DB engines might also have SQL extensions that are unique. â€¢ We use PostgreSQL as our reference. Relational Calculus 33 SQL is a programming language â€¢ We will now start to learn a languageâ€¦ learning from lectures is probably the worst way to do it. â€¢ There are only two ways: (1) Practice! (2) Deep Read Reference. â€¢ For Practice â€“ Write SQL. â€¢ For Reference â€“Read Chapter 6 of the Stanford Book. â€¢ In the lecture, we will provide you the structure to cover things that it is not clear in the textbook, especially the connection between SQL, relational calculus, and logic, and common pitfalls. Relational Calculus 34 SQL (Structured Query Language) â€¢ SQL: A Family of Standards â€¢ Data definition language (DDL) â€“ (#1) â€¢ Data manipulation language (DML) â€“ (#2) â€¢ Query Language â€“ (#3) â€¢ History â€¢ 1974: First paper by Chamberlin & Boyce (called SEQUEL) â€¢ SQL 92 (SQL 2): joins, outer-joins, ... â€¢ SQL 3 (1999), â€¢ SQL/XML (2006) â€¢ SQL: 2008 â€¢ SQL: 2011 â€¢ SQL: 2016 â€¢ SQL: 2019 Query Q (1) Define the schema of tables (2) Put info into the table (3) Query it Relational Calculus 35 Note â€¢ IMPORTANT: The Relational Calculus and Relational Algebra that we introduced all have SET semantics; while in SQL relations all have BAG semantics!! Each relation in SQL is a BAG; each relation in OUR relational model is a SET. Relational Calculus 36 SQL: Data Definition Language (DDL) Relational Calculus 37 SQL: Data Definition Language (DDL) â€¢ DDL provides statements to define the schema. â€¢ Recall that a Relation Schema looks like: ğ‘…(ğ‘“1: ğ·1, â€¦ , ğ‘“ğ‘›: ğ·ğ‘›) â€¢ In SQL, you need to provide (1) name, (2) set of columns, and (3) their types. â€¢ Data types: â€¢ char (n) â€¢ varchar (n) â€¢ integer â€¢ blob or raw for large binaries â€¢ date â€¢ â€¦ CREATE TABLE Professor( PersNr integer, Name varchar (30) Level character (2) default \"APâ€, PRIMARY KEY (PersNr) ); (default â€“ default value if not defined) (PRIMARY KEY â€“ primary key attributes) Professor(PersNr: integer, Name: varchar(30), Level char(2)) Relational Calculus 38 SQL: Data Definition Language (DDL) â€¢ You can delete a relation. â€¢ Modify structure of a relation. â€¢ Add column. â€¢ What value will the DB fill for the new column? â€¢ If defined default value, set to default value â€¢ Otherwise, keep â€œemptyâ€ (it is a special state called NULL that we will learn in the next lecture) â€¢ Delete column. â€¢ There are more, the best way to learn it is to look it up when you need it. â€¢ Search for â€œSQL add columnâ€ DROP TABLE Professor; ALTER TABLE Professor ADD COLUMN (age integer); ALTER TABLE Professor DROP COLUMN age; Relational Calculus 39 SQL: DDL - Example PersNr LectureID Grade 26120 5001 5.0 27550 5001 5.5 26120 5041 5.75 Tests PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor PersNr Name Semester 24002 Peter 8 25403 Mary 6 26120 Frey 2 Student LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture Prerequisite Follow-up 5001 5041 5001 5043 Requires PersNr LectureID 26120 5001 27550 5001 26120 5041 Attends CREATE TABLE Professor( PersNr integer, Name varchar(100), Level varchar(2), Room integer, PRIMARY KEY (PersNr)); CREATE TABLE Student( PersNr integer, Name varchar(100), Semester integer, PRIMARY KEY (PersNr)); CREATE TABLE Lecture ( LectureID integer, Title varchar(100), CP integer, ProfNr integer, PRIMARY KEY (LectureID)); CREATE TABLE Requires ( Prerequisite integer, Follow-up integer, PRIMARY KEY (Prerequisite, Follow-up)); CREATE TABLE Attends ( PersNr integer, LectureID integer, PRIMARY KEY (PersNr, LectureID)); CREATE TABLE Tests ( PersNr integer, LectureID integer, Grade float, PRIMARY KEY (PersNr, LectureID)); Relational Calculus 40 SQL: Data Manipulation Language (DML) Relational Calculus 41 SQL: Data Manipulation Language (DML) PersNr Name Semester 24002 Peter 8 25403 Mary 6 Student INSERT INTO Student (PersNr, Name) VALUES (28121, `Frey`) (What should the DB do for the Semester column? - Either the default value - Or keep it â€œEMPTYâ€ (the precise meaning of what â€œEMPTYâ€ means will be clear later in the course) DELETE Student WHERE Semester > 13; UPDATE Student SET Semester = Semester + 1; Relational Calculus 42 SQL: Data Manipulation Language (DML) â€¢ ETL: Extract, Transform, Load (ETL) â€¢ Populating a real DB cannot be done manually tuple by tuple: cumbersome, error prone, inaccurate, often slow. â€¢ Automatic tools are used to â€¢ Extract: get data from some file â€¢ Transform: apply transformation to the data when needed (types, conversion, format) â€¢ Load: insert into the DB as a bulk operation Relational Calculus 43 SQL: Data Manipulation Language (DML) â€¢ Two ways to populate this relation. â€¢ Tuple by tuple. â€¢ Problem? Slow â€¢ Overhead of parsing the query â€¢ Checking Key-constraints for each query â€¢ â€¦ â€¢ Bulk load â€¢ Often faster when you have a large table to fill in. â–ª PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor INSERT INTO Professor VALUES (2125, â€˜Johnâ€™, â€˜APâ€™, 226); INSERT INTO Professor VALUES (2126, â€˜Davidâ€™, â€˜FPâ€™, 232); INSERT INTO Professor VALUES (2127, â€˜Annaâ€™, â€˜FPâ€™, 310); COPY Professor FROM â€˜/profs.csvâ€™ WITH FORMAT csv; Relational Calculus 44 SQL: Data Manipulation Language (DML) Relational Calculus 45 â€¢ This is a whole industry by itself, specially in the cloud (more later in the course): SQL: Query Language Relational Calculus 46 SQL: Query Language â–ª SELECT â€¦ FROM â€¦ WHERE â€¦ â–ª Î ğ‘ƒğ‘’ğ‘Ÿğ‘ ğ‘ğ‘Ÿ,ğ‘ğ‘ğ‘šğ‘’ ğœğ¿ğ‘’ğ‘£ğ‘’ğ‘™=â€œğ¹ğ‘ƒâ€ğ‘ƒğ‘Ÿğ‘œğ‘“ğ‘’ğ‘ ğ‘ ğ‘œğ‘Ÿ â–ª Sometimes you donâ€™t need to write down the whole list of projected attributes â–ª Î ğ‘ƒğ‘’ğ‘Ÿğ‘ ğ‘ğ‘Ÿ,ğ‘ğ‘ğ‘šğ‘’,ğ¿ğ‘’ğ‘£ğ‘’ğ‘™,ğ‘…ğ‘œğ‘œğ‘š ğœğ¿ğ‘’ğ‘£ğ‘’ğ‘™=â€œğ¹ğ‘ƒâ€ğ‘ƒğ‘Ÿğ‘œğ‘“ğ‘’ğ‘ ğ‘ ğ‘œğ‘Ÿ PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture SELECT PersNr, Name FROM Professor WHERE Level = `FP`; SELECT * FROM Professor WHERE Level = `FP`; Relational Calculus 47 SQL: Query Language â–ª SELECT â€¦ FROM â€¦ WHERE â€¦ â–ª Î ğ‘ğ‘ğ‘šğ‘’àµ« àµ¯ ğœğ‘ƒğ‘’ğ‘Ÿğ‘ ğ‘ğ‘Ÿ=ğ‘ƒğ‘Ÿğ‘œğ‘“ğ‘ğ‘Ÿâˆ§ğ‘‡ğ‘–ğ‘¡ğ‘™ğ‘’=â€œğ·ğ‘ğ‘¡ğ‘ğ‘ğ‘ğ‘ ğ‘’â€(ğ‘ƒğ‘Ÿğ‘œğ‘“ğ‘’ğ‘ ğ‘ ğ‘œğ‘Ÿ Ã— ğ¿ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’ ) â¢ FROM defines the list of relations to do cross product â¢ WHERE defines the selection condition â¢ SELECT defines the projection â–ª ğœŒğ‘1â€¦ğ‘ğ‘›(Î ğ´1â€¦ğ´ğ‘›(ğœğ‘ƒ1âˆ§â‹¯ğ‘ƒğ‘š(ğ‘…1 Ã— â‹¯ Ã— ğ‘…ğ‘˜))) PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture SELECT Name FROM Professor P, Lecture L WHERE P.PersNr = L.ProfNr AND L.Title = `Database`; SELECT A1 as a1 ... An as an FROM R1 ... Rk WHERE P1 AND P2 ... AND Pm Relational Calculus 48 SQL: Query Language â–ª Selection: ğœ â–ª Projection: Î  â–ª Cross Product: Ã— â–ª Rename: ğœŒ â–ª ğœğ¶(ğ‘…) â–ª Î ğ´1,â€¦,ğ´ğ‘›ğ‘… â–ª ğ‘…1 Ã— ğ‘…2 â–ª ğœŒğ‘,ğ‘,ğ‘ğ‘… SELECT * FROM (SQL1) WHERE c; SELECT A1,â€¦,An FROM (SQL1); SELECT * FROM (SQL1), (SQL2); SELECT A as a,â€¦,C as c FROM (SQL1); Every SPJR RA expression can be written in SELECTâ€¦FROMâ€¦WHERE form. â€¦ so does every Conjunctive Query! Relational Calculus 49 SQL: Query Language â–ª Union â¢ ğ‘…1 âˆª ğ‘…2 â–ª Intersection â¢ ğ‘…1 âˆ© ğ‘…2 â–ª Difference â¢ ğ‘…1 âˆ’ ğ‘…2 PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture (SELECT Name FROM Assistant) UNION (SELECT Name FROM Professor); (SELECT Name FROM Assistant) INTERSECT (SELECT Name FROM Professor); (SELECT Name FROM Assistant) EXCEPT (SELECT Name FROM Professor); Relational Calculus 50 SQL: Query Language PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor SELECT Level FROM Professor; Level AP FP FP SELECT DISTINCT Level FROM Professor; Level AP FP SELECT DISTINCT Name, Level FROM Professor; Name Level John AP David FP Anna FPâ–ª Bag => Set â¢ Again, SQL implements Bag semantics, not Set Relational Calculus 51 SQL: Query Language (SQL1) UNION (SQL2)â–ª Union: âˆª â–ª Difference: âˆ’ â–ª Selection: ğœ â–ª Projection: Î  â–ª Cross Product: Ã— â–ª Rename: ğœŒ â–ª ğ‘…1 âˆª ğ‘…2 â–ª ğ‘…1 âˆ’ ğ‘…2 â–ª ğœğ¶(ğ‘…) â–ª Î ğ´1,â€¦,ğ´ğ‘›ğ‘… â–ª ğ‘…1 Ã— ğ‘…2 â–ª ğœŒğ‘,ğ‘,ğ‘ğ‘… (SQL1) EXCEPT (SQL2) SELECT * FROM (SQL1) WHERE c; SELECT A1,â€¦,An FROM (SQL1); SELECT * FROM (SQL1), (SQL2); SELECT A as a,â€¦,C as c FROM (SQL1); Every RA expression can be written in a subset of SQL. â€¦ so does every Domain-independent Relational Calculus Query! Relational Calculus 52 Summary so far Relational Algebra Relational Calculus Domain Independent Relational Calculus=More Powerful SPJR Algebra Conjunctive Query SELECTâ€¦ FROM â€¦ WHEREâ€¦ SQL Subset SQL Practial Query Language = = = Relational Calculus 53 SQL: Examples Relational Calculus 54 SQL: Query Language â–ª Sorting â–ª Tables are not sorted by default; if a result needs to be sorted, the query needs to specify it explicitly. SELECT PersNr, Name, Level FROM Professor ORDER BY Level DESC, Name DESC; PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor PersNr Name Level Room 2126 David FP 232 2127 Anna FP 310 2125 John AP 226 Relational Calculus 55 SQL: Query Language â–ª Grouping, Aggregation â–ª Can use different aggregation functions such as SUM, AVG, COUNT, etc. â–ª Group table by different values for attributes in GROUP BY, for each group, apply the aggregation function. PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor Level Count FP 2 AP 1 SELECT Level, COUNT(*) FROM Professor GROUP BY Level; SELECT COUNT(*) FROM Professor; Count 3 Relational Calculus 56 SQL: Query Language PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture SELECT p.PersNr, Name, sum (CP) FROM Lecture l, Professor p WHERE l.ProfNr= p.PersNr and level = Â´FPÂ´ GROUP BY p.PersNr, Name HAVING avg (CP) >= 3; Filter groups with condition AVG(CP) >= 3 Relational Calculus 57 SQL: Query Language PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture â–ª Existential Quantification SELECT p.Name FROM Professor p WHERE p.PersNr NOT IN (SELECT PersNr FROM Lecture); SELECT p.Name FROM Professor p WHERE NOT EXISTS (SELECT * FROM Lecture l WHERE l.PersNr = p.PersNr); Correlated Subquery Uncorrelated Subquery Return true when the subquery is empty (Logically) Eval subquery for every value of p Relational Calculus 58 SQL: Query Language PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture â–ª Existential Quantification â¢ DB often automatically conducts query rewriting to translate the query into a form that is easier to optimize SELECT p.Name FROM Professor p WHERE EXISTS (SELECT * FROM Lecture l WHERE l.PersNr = p.PersNr); SELECT p.Name FROM Professor p, Lecture l WHERE p.PersNr = l.PersNr; Relational Calculus 59 SQL: Query Language â€¢ Many clauses: â€¢ ANY, ALL, SOME â€¦ â€¢ We really want you to exercise the process of learning by yourself â€“ Search and learn! â€¢ (It WILL be in the exam) https://www.postgresql.org/docs/8.1/functions-subquery.html https://www.postgresqltutorial.com/postgresql-any/ Relational Calculus 60 PersNr LectureID Grade 26120 5001 5.0 27550 5001 5.5 26120 5041 5.75 DB Instance Tests PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor PersNr Name Semester 24002 Peter 8 25403 Mary 6 26120 Frey 2 Student LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture Prerequisite Follow-up 5001 5041 5001 5043 Requires PersNr LectureID 26120 5001 27550 5001 26120 5041 Attends Q. All Students who take Databases Î ğ‘ƒğ‘’ğ‘Ÿğ‘ ğ‘ğ‘Ÿğœğ‘‡ğ‘–ğ‘¡ğ‘™ğ‘’=â€œğ·ğ‘ğ‘¡ğ‘ğ‘ğ‘ğ‘ ğ‘’â€( ) ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ â‹ˆ ğ´ğ‘¡ğ‘¡ğ‘’ğ‘›ğ‘‘ğ‘  â‹ˆ ğ¿ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’) {ğ‘ âˆ¶ âˆƒ ğ‘› , ğ‘ . ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ ğ‘, ğ‘› ğ‘  âˆ§ âˆƒ ğ‘™, ğ‘¡, ğ‘, ğ‘ğ‘Ÿ. (ğ´ğ‘¡ğ‘¡ğ‘’ğ‘›ğ‘‘ğ‘  ğ‘, ğ‘™ . âˆ§ ğ¿ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’ ğ‘™, ğ‘¡, ğ‘, ğ‘ğ‘Ÿ âˆ§ ğ‘¡ = â€ğ‘‡ğ‘–ğ‘¡ğ‘™ğ‘’â€)} SELECT S.PersNr FROM Student S, Attends A, Lecture L WHERE S.PersNr = A.PersNr AND A.LectureID = L.LectureID AND L.Title = 'Databases' Relational Calculus 61 PersNr LectureID Grade 26120 5001 5.0 27550 5001 5.5 26120 5041 5.75 DB Instance Tests PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor PersNr Name Semester 24002 Peter 8 25403 Mary 6 26120 Frey 2 Student LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture Prerequisite Follow-up 5001 5041 5001 5043 Requires PersNr LectureID 26120 5001 27550 5001 26120 5041 Attends Q. Profs who donâ€™t teach. Î ğ‘ƒğ‘’ğ‘Ÿğ‘ ğ‘ğ‘Ÿğ‘ƒğ‘Ÿğ‘œğ‘“ğ‘’ğ‘ ğ‘ ğ‘œğ‘Ÿ âˆ’ Î ğ‘ƒğ‘’ğ‘Ÿğ‘ ğ‘ğ‘Ÿ ğ‘ƒğ‘Ÿğ‘œğ‘“ğ‘’ğ‘ ğ‘ ğ‘œğ‘Ÿ â‹ˆğ‘ƒğ‘’ğ‘Ÿğ‘ ğ‘ğ‘Ÿ=ğ‘ƒğ‘Ÿğ‘œğ‘“ğ‘ğ‘Ÿ ğ¿ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’ {ğ‘ âˆ¶ âˆƒğ‘›, ğ‘™, ğ‘Ÿ. ğ‘ƒğ‘Ÿğ‘œğ‘“ğ‘’ğ‘ ğ‘ ğ‘œğ‘Ÿ ğ‘, ğ‘›, ğ‘™, ğ‘Ÿ âˆ§ Â¬âˆƒğ‘™ğ‘’, ğ‘¡, ğ‘ğ‘. ğ¿ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’(ğ‘™ğ‘’, ğ‘¡, ğ‘ğ‘, ğ‘)} (SELECT PersNr FROM Professor) EXCEPT (SELECT P.PersNr FROM Professor P, Lecture L WHERE P.PersNr = L.ProfNr) Relational Calculus 62 PersNr LectureID Grade 26120 5001 3.0 27550 5001 5.5 26120 5041 5.75 DB Instance Tests PersNr Name Level Room 2125 John AP 226 2126 David FP 232 2127 Anna FP 310 Professor PersNr Name Semester 24002 Peter 8 25403 Mary 6 26120 Frey 2 Student LectureID Title CP ProfNr 5001 Databases 4 2125 5041 Networks 4 2126 5043 Theory 4 2127 Lecture Prerequisite Follow-up 5001 5041 5001 5043 Requires PersNr LectureID 26120 5001 27550 5001 26120 5041 Attends Q. Course that Students cannot take because failing the pre-requisites. Î ğ‘ƒğ‘’ğ‘Ÿğ‘ ğ‘ğ‘Ÿ,ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤âˆ’ğ‘¢ğ‘(àµ« àµ¯ ğœğºğ‘Ÿğ‘ğ‘‘ğ‘’<4.0( ) ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ â‹ˆ ğ‘‡ğ‘’ğ‘ ğ‘¡ğ‘  â‹ˆğ¿ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’ğ¼ğ·=ğ‘ƒğ‘Ÿğ‘’ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ ğ‘…ğ‘’ğ‘ğ‘¢ğ‘–ğ‘Ÿğ‘’ğ‘ ) {(ğ‘ , ğ‘™) âˆ¶ âˆƒ ğ‘›, ğ‘ ğ‘’. ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ ğ‘ , ğ‘›, ğ‘ ğ‘’ âˆ§ âˆƒ ğ‘™ğ‘’, ğ‘”, . (ğ‘‡ğ‘’ğ‘ ğ‘¡ğ‘  ğ‘ , ğ‘™ğ‘’, ğ‘” âˆ§ ğ‘” < 4.0 âˆ§ ğ‘…ğ‘’ğ‘ğ‘¢ğ‘–ğ‘Ÿğ‘’ğ‘  ğ‘™ğ‘’, ğ‘™ )} SELECT S.PersNr, R.Follow-up FROM Student S, Tests T, Requires R WHERE S.PersNr = T.PersNr AND T.Grade < 4.0 AND T.LectureID = R.Prerequisite; Relational Calculus 63 Lessons learned â€¢ The basis for SQL are relational calculus and relational algebra â€¢ Relational calculus needs to be restricted to be practical in databases â€¢ Close world assumption in databases â€¢ SQL is a declarative programming language â€¢ States what tuples should be in the result â€¢ Basic operations are relational algebra operators â€¢ You need to program queries in SQL â€¦ Relational Calculus 64","libVersion":"0.3.2","langs":""}