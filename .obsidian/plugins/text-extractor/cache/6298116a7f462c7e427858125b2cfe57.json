{"path":"sem3/TI/UE/s/TI-s-u02.pdf","text":"Departement Informatik Theoretische Informatik Prof. Dr. Juraj Hromkoviˇc Dr. Hans-Joachim B¨ockenhauer Prof. Dr. Dennis Komm Exemplary Solutions – Sheet 2 Z¨urich, October 4, 2024 Solution to Task 4 (a) First, we give for each n ∈ N − {0} a Pascal program which produces wn: begin s:= n; s:= 4*s*s; for i:=1 to 100000 do write(0); for i:=1 to s do write(0101); end. This program first calculates s = 4n2. In the first for-loop, the program writes the prefix 0 100 000. In the second for-loop, the program writes the word 0101 4n2-times, which gives the word wn. The only part of the machine code of this program that depends on wn is the encoding of the value n in the second line. The rest of the machine code has constant length. Thus, the binary length of this program is at most ⌈log2(n + 1)⌉ + c for some constant c. With this, the Kolmogorov complexity of wn can be bounded from above by K(wn) ≤ ⌈log2(n + 1)⌉ + c. The length of wn is |wn| = |0 100 000| + |0101| · 4n2 = 16n 2 + 100 000. Hence, we have n = √|wn| − 100 000/4 and thus we obtain the upper bound K(wn) ≤ ⌈ log2 (1 + √|wn| − 100 000/4 )⌉ + c ≤ log2(|wn|)/2 + c′ for the Kolmogorov complexity of wn for some constant c′. (b) We define the sequence of words y0, y1, y2, . . . by yi := 03i+1 for all i ∈ N. Evidently we have y0 < y1 < y2 < . . . and i + 1 = log3 |yi| for all i ∈ N. We now define for each yi a Pascal program Pi that produces yi: begin k:= 3* 3^i; for j:=1 to k do write(0); end. In this program, first the value k = 3 i+1 is calculated. Then, the for-loop writes k zeroes. The only part of the machine code of Pi that depends on yi is the representation of i. The machine code representing the rest of the program has constant length, while the binary representation of i has length ⌈log2(i + 1)⌉ ≤ 1 + log2(i + 1). Hence, we have K(yi) ≤ log2(i + 1) + c = log2 log3(|yi|) + c for some constant c. Solution to Task 5 For n < 8, the statement of the exercise is trivial, hence we assume that n ≥ 8. We show that fewer than 1% of the words in {0, 1}n have Kolmogorov complexity ≤ n − 8. There are n−8∑ j=1 2 j = 2 n−7 − 2 < 2 n−7 non-empty binary words of length at most n − 8. Thus, there exist at most 2 n−7 different Pascal programs with machine codes of length at most n − 8. This implies that there are also at most 2 n−7 different words with Kolmogorov complexity ≤ n − 8, since we can assign to each such word w the machine code of a Pascal program that produces w and has length K(w). Finally, since |{0, 1} n| = 2 n, at most 2 n−7/2 n = 2 −7 < 1% of the words in {0, 1} n have Kolmogorov complexity at most n − 8. Solution to Task 6 We assume by contradiction that A is a Pascal program which takes as input some n ∈ N and produces a word A(n) ∈ {0, 1}n with K(A(n)) > n − 8. Using A, we can define for each n ∈ N the following Pascal program: begin m := n; s := A(m); write(s); end. Hence, this is simply the program A with fixed input n, i.e., this program writes the word A(n). The only part of the machine code that depends on A(n) is the representation of n in the second line. The remainder of the machine code has constant length c. Thus, we have for each word A(n), n ∈ N: K(A(n)) ≤ ⌈log2(n + 1)⌉ + c ≤ log2(n) + c′, for some constant c′. On the other hand, by assumption, we have that K(A(n)) > n − 8 for all n ∈ N. It follows that for all n ∈ N, n − 8 < log2(n) + c′, which is a contradiction for large enough n.","libVersion":"0.5.0","langs":""}