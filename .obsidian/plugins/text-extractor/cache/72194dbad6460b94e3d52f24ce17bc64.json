{"path":"sem3/TI/VRL/extra/nwehrl/TI-nwehrl-w06.pdf","text":"Theoretische Informatik HS24 Nicolas Wehrli ¨Ubungsstunde 06 29. Oktober 2024 ETH Z ¨urich nwehrl@ethz.ch 1 Heute 1 Feedback zur Serie 2 Recap: Turing Maschinen 3 Nichtdeterministische Turingmaschinen 4 Einstieg Berechnenbarkeit Diagonalisierung 5 Reduktion 2 Feedback zur Serie Feedback - Justification beim Widerspruch im Pumping Lemma - Davon abgesehen, relativ gut gel ¨ost 3 Recap: Turing Maschinen Turing Maschinen - Formalisierung von Algorithmen Informell Eine Turingmaschine besteht aus (i) einer endlichen Kontrolle, die das Programm enth¨alt, (ii) einem unendlichen Band, das als Eingabeband, aber auch als Speicher (Arbeitsband) zur Verf ¨ugung steht, und (iii) einem Lese-/Schreibkopf, der sich in beiden Richtungen auf dem Band bewegen kann. F ¨ur formale Beschreibung siehe Buch. 4 Turing Maschinen - Formalisierung von Algorithmen Abbildung 1: Abb. 4.1 vom Buch 5 Turing Maschinen - Formalisierung von Algorithmen Elementare Operation einer TM - Informell Input - Zustand der Maschine (der Kontrolle) - Symbol auf dem Feld unter dem Lese-/Schreibkopf Aktion (i) ¨andert Zustand (ii) schreibt auf das Feld unter dem Lese-/Schreibkopf (iii) bewegt den Lese-/Schreibkopf nach links, rechts oder gar nicht. Ausser wenn g , dann ist links nicht m ¨oglich. 6 Turing Maschinen - Formalisierung von Algorithmen Eine Konfiguration C von M ist ein Element aus Konf(M) = {g } · Γ∗ · Q · Γ + ∪ Q · {g } · Γ ∗ - Eine Konfiguration g w1qaw2 mit w1, w2 ∈ Γ∗, a ∈ Γ und q ∈ Q sagt uns: M im Zustand q, Inhalt des Bandes g w1aw2 ..., Kopf an Position |w1| + 1 und liest gerade a. - Eine Konfiguration pg w mit p ∈ Q, w ∈ Γ∗: Inhalt des Bandes g w ..., Zustand p und Kopf an Position 0. Bmk: Im Buch haben sie in der Definition von Konf Γ+ anstatt Γ∗ an ”letzter Stelle”. 7 Turing Maschinen - Formalisierung von Algorithmen Es gibt wieder eine Schrittrelation M ⊆ Konf(M) × Konf(M). Abbildung 2: Diagramm von Adeline 8 Turing Maschinen - Formalisierung von Algorithmen Berechnung von M, Berechnung von M auf einer Eingabe x etc. durch M definiert. Die Berechnung von M auf x heisst - akzeptierend, falls sie in einer akzeptierenden Konfiguration w1qacceptw2 endet (wobei g in w1 enthalten ist). - verwerfend, wenn sie in in einer verwerfenden Konfiguration w1qrejectw2 endet. - nicht-akzeptierend, wenn sie entweder eine verwerfende oder unendli- che Berechnung ist. 9 Turing Maschinen - Formalisierung von Algorithmen Die von der Turingmaschine M akzeptierte Sprache ist L(M) = {w ∈ Σ ∗ | q0g w M ∗ yqacceptz, f ¨ur irgendwelche y, z ∈ Γ ∗} 10 Wichtige Klassen Regul¨are Sprachen LEA = {L(A) | A ist ein EA} = LNEA Rekursiv aufz¨ahlbare Sprachen Eien Sprache L ⊆ Σ∗ heisst rekursiv aufz¨ahlbar, falls eine TM M existiert, so dass L = L(M). LRE = {L(M) | M ist eine TM} ist die Klasse aller rekursiv aufz¨ahlbaren Sprachen. 11 Wichtige Klassen Halten Wir sagen das M immer h¨alt, wenn f ¨ur alle Eingaben x ∈ Σ∗ (i) q0g x M ∗ yqacceptz, y, z ∈ Γ∗, falls x ∈ L und (ii) q0g x M ∗ uqrejectv, u, v ∈ Γ∗, falls x /∈ L. Rekusive Sprachen Eine Sprache L ⊆ Σ∗ heisst rekursiv (entscheidbar), falls L = L(M) f ¨ur eine TM M, die immer h¨alt. LR = {L(M) | M ist eine TM, die immer h¨alt} ist die Klasse der rekursiven (algorithmisch erkennbaren) Sprachen. 12 Mehrband-Turingmaschine Mehrband-TM - Informelle Beschreibung F ¨ur k ∈ N \\ {0} hat eine k-Band Turingmaschine - eine endliche Kontrolle - ein endliches Band mit einem Lesekopf (Eingabeband) - k Arbeitsb¨ander, jedes mit eigenem Lese-/Schreibkopf (nach rechts un- endlich) Insbesondere gilt 1-Band TM ̸= ”normale” TM Am Anfang der Berechnung einer MTM M auf w - Arbeitsb¨ander ”leer” und die k Lese-/Schreibk ¨opfe auf Position 0. - Inhalt des Eingabebands g w$ und Lesekopf auf Position 0. - Endliche Kontrolle im Zustand q0. 13 ¨Aquivalenz von Maschinen (TM, MTM) Seien A und B zwei Maschinen mit gleichem Σ. Wir sagen, dass A ¨aquivalent zu B ist, wenn f ¨ur jede Eingabe x ∈ Σ∗ (i) A akzeptiert x ⇐⇒ B akzeptiert x (ii) A verwirft x ⇐⇒ B verwirft x (iii) A arbeitet unendlich lange auf x ⇐⇒ B arbeitet unendlich lange auf x Wir haben A und B ¨aquivalent =⇒ L(A) = L(B) aber L(A) = L(B) ̸=⇒ A und B ¨aquivalent da A auf x unendlich lange arbeiten k ¨onnte, w¨ahrend B x verwirft. 14 ¨Aquivalenz von 1-Band TM zu TM Lemma 4.1 Zu jeder TM A existiert eine zu A ¨aquivalente 1-Band-TM B Beweisidee B kopiert die Eingabe zuerst aufs Arbeitsband und simuliert dann A. 15 ¨Aquivalenz von TM zu k-Band-TM Lemma 4.2 Zu jeder Mehrband-TM A existiert eine zu A ¨aquivalente TM B Beweisidee Vergr ¨osserung des Alphabets, jedes Zeichen enth¨alt jetzt 2(k + 1) Zeichen. B simuliert A einen Schritt von A indem es den ganzen Inhalt liest und dann durch die endliche Kontrolle von A jede Schreib und Bewegungsoperation einzeln ausf ¨uhrt. Dies verwendet immer nur endlich viele Schritte um einen Schritt von A zu simulieren. 16 ¨Aquivalenz Folgerung Aus Lemma 4.1 und 4.2 folgt direkt Satz 4.1 Die Maschinenmodelle von Turingmaschinen und Mehrband- Turingmaschinen sind ¨aquivalent. Note: ” ¨Aquivalenz” f ¨ur Maschinenmodelle wird in Definition 4.2 definiert. Maschinenmodelle sind Klassen von Maschinen (i.e. Mengen von Maschinen mit gewissen Eigenschaften). 17 Nichtdeterministische Turingmaschinen Definition von NTM Eine nichtdeterministische Turingmaschine (NTM) ist ein 7-Tupel M = (Q, Σ, Γ, δ, q0, qaccept, qreject), wobei (i) Q, Σ, Γ, qaccept, qreject die gleiche Bedeutung wie bei einer TM haben, und (ii) δ : (Q\\{qaccept, qreject})×Γ → P(Q×Γ×{L, R, N}) die ¨Ubergangsfunktion von M ist und die folgende Eigenschaft hat: δ(p, g ) ⊆ {(q, g , X) | q ∈ Q, X ∈ {R, N}} f ¨ur alle p ∈ Q Konfiguration ¨ahnlich wie bei TMs. Konfiguration akzeptierend ⇐⇒ enth¨alt qaccept Konfiguration verwerfend ⇐⇒ enth¨alt qreject 18 Die ¨ublichen Sachen - Schrittrelation M ”verbindet zwei Konfigurationen, wenn man von der einen in die andere kommen kann” - Reflexive und transitive H ¨ulle ist M ∗ . - Berechnung von M ist eine Folge von Konfigurationen C1, C2, ..., so dass Ci M Ci+1. - Eine Berechnung von M auf x ist beginnt in q0g x und endet entweder unendlich oder endet in {qaccept, qreject}. Akzeptierte Sprache L(M) = {w ∈ Σ∗ | q0g w M ∗ yqacceptz f ¨ur irgendwelche y, z ∈ Γ ∗} 19 Berechnungsbaum Sei M = (Q, Σ, Γ, δ, q0, qaccept, qreject) eine NTM und sei x ein Wort ¨uber dem Eingabealphabet Σ von M. Ein Berechnungsbaum TM,x von M auf x ist ein (potentiell unendlicher) gerichteter Baum mit einer Wurzel, der wie folgt defi- niert wird. (i) Jeder Knoten von TM,x ist mit einer Konfiguration beschriftet. (ii) Die Wurzel ist der einzige Knoten von TM,x mit dem Eingangsgrad 0 und ist mit der Startkonfiguration q0g x beschriftet. (iii) Jeder Knoten des Baumes, der mit einer Konfiguration C beschriftet ist, hat genauso viele Kinder wie C Nachfolgekonfigurationen hat, und diese Kinder sind mit diesen Nachfolgekonfigurationen C markiert. 20 ¨Aquivalenz NTM und TM Satz 4.2 Sei M eine NTM. Dann existiert eine TM A, so dass (i) L(M) = L(A) und (ii) falls M keine unendlichen Berechnungen auf W ¨ortern aus L(M)∁ hat, dann h¨alt A immer. Beweisidee: ”BFS im Berechnungsbaum”, i.e. wir simulieren einzelne Schritte der verschiedenen Berechnungsstr¨ange. 21 Einstieg Berechnenbarkeit Bijektion, Injektion, Schreibweise Seien A und B zwei Mengen. Wir sagen, dass i. |A| ≤ |B|, falls eine injektive Funktion f : A → B existiert. ii. |A| = |B|, falls |A| ≤ |B| und |B| ≤ |A|. iii. |A| < |B|, falls |A| ≤ |B| und keine injektive Abbildung von B nach A exis- tiert. Zur Erinnerung: f : A → B injektiv ⇐⇒ ∀x, y ∈ A, x ̸= y.f (x) ̸= f (y) 22 Abz¨ahlbarkeit Eine Menge A heisst abz¨ahlbar, falls A endlich ist oder |A| = |N|. Lemma 5.1 Sei Σ ein beliebiges Alphabet. Dann ist Σ∗ abz¨ahlbar. Beweisidee kanonische Ordnung gibt uns eine Bijektion zwischen N und Σ∗. 23 Abz¨ahlbarkeit Satz 5.1 Die Menge KodTM der Turingmaschinenkodierungen ist abz¨ahlbar. Beweisidee KodTM ⊆ (Σbool)∗ und Lemma 5.1 24 Abz¨ahlbarkeit Lemma 5.2 (N \\ {0}) × (N \\ {0}) ist abz¨ahlbar. Beweisidee Unendliche 2-dimensionale Tabelle, so dass an der i-ten Zeile und j-ten Spalte, sich das Element (i, j) ∈ (N \\ {0}) × (N \\ {0}) befindet. Formal definiert man dabei die lineare Ordnung (a, b) < (c, d) ⇐⇒ a + b < c + d oder (a + b = c + d und b < d) 25 Abz¨ahlbarkeit Abbildung 3: Abbildung 5.3 im Buch 26 Abz¨ahlbarkeit Die i-te Diagonale hat i Elemente. Ein beliebiges Element (a, b) ∈ (N \\ {0}) × (N \\ {0}) ist das b-te Element auf der (a + b − 1)-ten Diagonale. Auf den ersten a + b − 2 Diagonalen gibt es a+b−2∑ i=1 i = (a + b − 2) · ((a + b − 2) + 1) 2 = (a + b − 1 2 ) Elemente. Folglich ist f ((a, b)) = (a + b − 1 2 ) + b eine Bijektion von (N \\ {0}) × (N \\ {0}) nach N \\ {0}. 27 ¨Uberabz¨ahlbarkeit Satz 5.3 [0, 1] ist nicht abz¨ahlbar. Beweisidee Klassisches Diagonalisierungsargument. Aufpassen auf 0 und 9. I.e. 1 = 0.99. 28 ¨Uberabz¨ahlbarkeit 29 ¨Uberabz¨ahlbarkeit Satz 5.4 P((Σbool)∗) ist nicht abz¨ahlbar. Beweis: Wir definieren eine injektive Funktion von f : [0, 1] → P((Σbool)∗) und beweisen so |P((Σbool)∗)| ≥ |[0, 1]|. Sei a ∈ [0, 1] beliebig. Wir k ¨onnen a wie folgt bin¨ar darstellen: Nummer(a) = 0.a1a2a3a4... mit a = ∞∑ i=1 ai · 2−i. Hier ist zu beachten, dass wir f ¨ur eine Zahl a immer die lexikographisch letzte Darstellung w¨ahlen. 30 ¨Uberabz¨ahlbarkeit Dies tun wir, weil eine reelle Zahl 2 verschiedene Bin¨ardarstellungen haben kann. Beispiel: 1 2 = 0.10 = 0.01. F ¨ur jedes a definieren wir: f (a) = {a1, a2a3, a4a5a6, ..., a(n 2)+1a( n 2)+2...a(n+1 2 ), ...} Da f (a) ⊆ (Σbool)∗ gilt f (a) ∈ P((Σbool)∗). Wir haben f ¨ur alle n ∈ N \\ {0}, dass f (a) genau ein Wort dieser L¨ange enth¨alt. Nun k ¨onnen wir daraus folgendes schliessen: Weil die Bin¨ardarstellung zweier unterschiedlichen reellen Zahlen an mindestens einer Stelle unterschiedlich ist, gilt b ̸= c =⇒ f (b) ̸= f (c), ∀b, c ∈ [0, 1]. 31 ¨Uberabz¨ahlbarkeit Folglich ist f injektiv und wir haben |P((Σbool)∗)| ≥ |[0, 1]|. Da [0, 1] nicht abz¨ahlbar ist, folgt daraus: P((Σbool)∗) ist nicht abz¨ahlbar. ■ 32 Diagonalsprache Ldiag Zur Erinnerung: Rekursiv aufz¨ahlbare Sprachen Eien Sprache L ⊆ Σ∗ heisst rekursiv aufz¨ahlbar, falls eine TM M existiert, so dass L = L(M). LRE = {L(M) | M ist eine TM} ist die Klasse aller rekursiv aufz¨ahlbaren Sprachen. Wir zeigen jetzt per Diagonalisierung, die Existenz einer Sprache die nicht rekursiv aufz¨ahlbar ist. 33 Diagonalsprache Ldiag Sei w1, w2, ... die kanonische Ordnung aller W ¨orter ¨uber Σbool und sei M1, M2, M3, ... die Folge aller Turingmaschinen. Wir definieren eine unendliche (bool’sche) Matrix A = [dij]i,j=1,2,... mit dij = 1 ⇐⇒ Mi akzeptiert wj. Wir definieren Ldiag = {w | w = wi und Mi akzeptiert wi nicht f ¨ur ein i ∈ N \\ {0}} 34 Diagonalsprache Ldiag Satz 5.5 Ldiag /∈ LRE Beweis: Wir haben Ldiag = {w | w = wi und Mi akzeptiert wi nicht f ¨ur ein i ∈ N \\ {0}} Widerspruchsbeweis: Sei Ldiag ∈ LRE. Dann existiert eine TM M, so dass L(M) = Ldiag. Da diese TM eine TM in der Nummerierung aller TM ist, existiert ein i ∈ N, so dass Mi = M. 35 Diagonalsprache Ldiag Wir betrachten nun das Wort wi f ¨ur diese i ∈ N. Per Definition von Ldiag, gilt: wi ∈ Ldiag ⇐⇒ wi /∈ L(Mi) Da aber L(Mi) = Ldiag, haben wir folgenden Widerspruch: wi ∈ Ldiag ⇐⇒ wi /∈ Ldiag Folglich gilt Ldiag /∈ LRE. ■ 36 Klassifizierung verschiedener Sprachen LRE LR LEA {0n1n | n ∈ N} Ldiag LH LU Lempty (LH)C Lprim 37 Begrifflichkeiten F ¨ur eine Sprache L gilt folgendes L regul¨ar ⇐⇒ L ∈ LEA ⇐⇒ ∃ EA A mit L(A) = L L rekursiv ⇐⇒ L ∈ LR ⇐⇒ ∃ Alg. A mit L(A) = L L rekursiv aufz¨ahlbar ⇐⇒ L ∈ LRE ⇐⇒ ∃ TM M. L(M) = L ”Algorithmus” = TM, die immer h¨alt. L rekursiv = L entscheidbar L rekursiv aufz¨ahlbar = L erkennbar 38 Reduktion Things Reduktionen sind klassische Aufgaben an dem Endterm. Ein bisschen wie Nichtregularit¨atsbeweise. Ist aber auch nicht so schlimm. 39 R-Reduktion Definition 5.3 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. Wir sagen, dass L1 auf L2 rekursiv reduzierbar ist, L1 ≤R L2, falls L2 ∈ LR =⇒ L1 ∈ LR Bemerkung: Intuitiv bedeutet das ”L2 mindestens so schwer wie L1” (bzgl. algorithmischen L ¨osbarkeit). 40 EE-Reduktion Definition 5.4 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. Wir sagen, dass L1 auf L2 EE- reduzierbar ist, L1 ≤EE L2, wenn eine TM M existiert, die eine Abbildung fM : Σ∗ 1 → Σ∗ 2 mit der Eigenschaft x ∈ L1 ⇐⇒ fM(x) ∈ L2 f ¨ur alle x ∈ Σ∗ 1 berechnet. Wir sagen auch, dass die TM M die Sprache L1 auf die Sprache L2 reduziert. 41 EE-Reduktion Wir sagen, dass M eine Funktion F : Σ∗ → Γ∗ berechnet, falls f ¨ur alle x ∈ Σ∗: q0g x M ∗ qacceptg F(x). Abbildung 4: Abbildung 5.7 vom Buch 42 Verh¨altnis von EE-Reduktion und R-Reduktion Lemma 5.3 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. L1 ≤EE L2 =⇒ L1 ≤R L2 Beweis: L1 ≤EE L2 =⇒ ∃TM M. x ∈ L1 ⇐⇒ M(x) ∈ L2 Wir zeigen nun L1 ≤R L2, i.e. L2 ∈ LR =⇒ L1 ∈ LR. Sei L2 ∈ LR. Dann existiert ein Algorithmus A (TM, die immer h¨alt), der L2 entscheidet. 43 Verh¨altnis von EE-Reduktion und R-Reduktion Wir konstruieren eine TM B (die immer h¨alt) mit L(B) = L1 F ¨ur eine Eingabe x ∈ Σ∗ 1 arbeitet B wie folgt: (i) B simuliert die Arbeit von M auf x, bis auf dem Band das Wort M(x) steht. (ii) B simuliert die Arbeit von A auf M(x). Wenn A das Wort M(x) akzeptiert, dann akzeptiert B das Wort x. Wenn A das Wort M(x) verwirft, dann verwirft B das Wort x. A h¨alt immer =⇒ B h¨alt immer und somit gilt L1 ∈ LR ■ 44 L und L ∁ Lemma 5.4 Sei Σ ein Alphabet. F ¨ur jede Sprache L ⊆ Σ∗ gilt: L ≤R L∁ und L ∁ ≤R L Beweis: Es reicht L∁ ≤R L zu zeigen, da (L∁)∁ = L und somit dann (L∁)∁ = L ≤R L∁. Sei M′ ein Algorithmus f ¨ur L, der immer h¨alt (L ∈ LR). Dann beschreiben wir einen Algorithmus B, der L∁ entscheidet. B ¨ubernimmt die Eingaben und gibt sie an M′ weiter und invertiert dann die Entscheidung von M′. Weil M′ immer h¨alt, h¨alt auch B immer und wir haben offensichtlich L(B) = L. ■ 45 Anwendung vom Lemma 5.4 Korollar 5.2 (Ldiag) ∁ /∈ LR Beweis: Aus Lemma 5.4 haben wir Ldiag ≤R (Ldiag)∁. Daraus folgt Ldiag /∈ LR =⇒ (Ldiag)∁ /∈ LR. Da Ldiag /∈ LRE gilt auch Ldiag /∈ LR. Folglich gilt (Ldiag)∁ /∈ LR. ■ 46 Beispielaufgabe 17a HS22 Beweise LH ≤EE LU wobei LH = {Kod(M)#w | M h¨alt auf w ∧ w ∈ (Σbool) ∗} und LU = {Kod(M)#w | M akzeptiert w ∧ w ∈ (Σbool)∗} 47 Beispielaufgabe 17a HS22 Wir wollen LH ≤EE LU zeigen. Wir geben die Reduktion zuerst als Zeichnung an. Abbildung 5: EE-Reduktion von LH auf LU 48 Beispielaufgabe 17a HS22 Wir definieren eine Funktion M(x) f ¨ur ein x ∈ {0, 1, #}∗, so dass x ∈ LH ⇐⇒ M(x) ∈ LU (1) Falls x nicht die richtige Form hat, ist M(x) = λ, sonst ist M(x) = Kod(M′)#w wobei M′ gleich aufgebaut ist wie M, ausser dass alle Transitionen zu qreject zu qaccept umgeleitet werden. Wir sehen, dass M′ genau dann w akzeptiert, wenn M auf w h¨alt. Dieses M(x) ¨ubergeben wir dem Algorithmus f ¨ur LU. 49 Beispielaufgabe 17a HS22 Wir beweisen nun x ∈ LH ⇐⇒ M(x) ∈ LU: (i) x ∈ LH Dann ist x = Kod(M)#w von der richtigen Form, und M h¨alt auf w. Das heisst die Simulation von M auf w endet entweder in qreject oder in qaccept. Folglich wird M′ w immer akzeptieren, da alle Transitionen zu qreject zu qaccept umgeleitet wurden. x ∈ LH =⇒ M(x) ∈ LU (ii) x /∈ LH Dann unterscheiden wir zwischen zwei F¨allen: (a) x hat nicht die richtige Form, i.e. x ̸= Kod(M)#w. Dann ist M(x) = λ und da es keine Kodierung einer Turingmaschine M gibt, so dass Kod(M) = λ, gilt λ /∈ LU. 50 Beispielaufgabe 17a HS22 (i) x ∈ LH done above. (ii) x /∈ LH (a) falsche Form done above. (b) x = Kod(M)#w hat die richtige Form. Dann haben wir M(x) = Kod(M′)#w. Da aber x /∈ LH, h¨alt M nicht auf w. Da M nicht auf w h¨alt, erreicht es nie qreject oder qaccept in M und so wird w von M′ nicht akzeptiert. =⇒ M(x) /∈ LU So haben wir mit diesen F¨allen (a) und (b) x /∈ LH =⇒ M(x) /∈ LU bewiesen. Aus indirekter Implikation folgt M(x) ∈ LU =⇒ x ∈ LH 51 Beispielaufgabe 17a HS22 Aus (i) und (ii) folgt x ∈ LH ⇐⇒ M(x) ∈ LU (1) Somit ist die Reduktion korrekt. ■ 52 Beispielaufgabe 18b HS22 Sei Linfinite = {Kod(M) | M h¨alt auf keiner Eingabe} Zeige (Linfinite)C /∈ LR 53 Beispielaufgabe 18b HS22 Wir zeigen, dass (Linfinite)C /∈ LR mit einer geeigneten Reduktion. Wir beweisen LH ≤R (Linfinite)C Um dies zu zeigen nehmen wir an, dass wir einen Algorithmus A haben, der (Linfinite)C entscheidet. Wir konstruieren einen Algorithmus B, der mit Hilfe von A, die Sprache LH entscheidet. 54 Beispielaufgabe 18b HS22 Wir betrachten folgende Abbildung: Abbildung 6: R-Reduktion von LH auf (Linfinite) C 55 Beispielaufgabe 18b HS22 I. F ¨ur eine Eingabe x ∈ {0, 1, #}∗ berechnet das Teilprogramm C, ob x die richtige Form hat(i.e. ob x = Kod(M)#w f ¨ur eine TM M). II. Falls nicht, verwirft B die Eingabe x. III. Ansonsten, konstruiert C eine Turingmaschine M′, die Eingaben ignoriert und immer M auf w simuliert. Wir sehen, dass M′ genau dann h¨alt, wenn M auf w h¨alt. IV. Folglich h¨alt M′ entweder f ¨ur jede Eingabe (M h¨alt auf w) oder f ¨ur keine (M h¨alt nicht auf w). V. Da A genau dann akzeptiert, wenn die Eingabe keine g ¨ultige Kodierung ist(ausgeschlossen, da C das herausfiltert) oder wenn die Eingabe M(x) = Kod(M′) und M′ f ¨ur mindestens eine Eingabe h¨alt, akzeptiert A M(x) genau dann, wenn x = Kod(M)#w die richtige Form hat und M auf w h¨alt. 56 Beispielaufgabe 18b HS22 Folglich gilt x ∈ LH ⇐⇒ M(x) ∈ (Linfinite) C =⇒ LH ≤R (Linfinite)C Also folgt die Aussage (Linfinite)C ∈ LR =⇒ LH ∈ LR Da wir LH /∈ LR (Satz 5.8), folgt per indirekter Implikation: (Linfinite)C /∈ LR ■ 57","libVersion":"0.5.0","langs":""}