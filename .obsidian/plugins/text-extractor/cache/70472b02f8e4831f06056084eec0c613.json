{"path":"sem4/FMFP/PV/FMFP-finals/FMFP-FS22.pdf","text":"Formal Methods and Functional Programming Final Exam, 2022 August 19, 2022, 8:30 – 10:30 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 22 pages; the back page of this booklet is page 22. After the exam begins, check that your exam papers are complete (6 assignments and 2 pages of background material for the FM part). 2. You may complete the assignments in any order. 3. Only write on the exam paper and extra paper sheets which are given by the assistants. 4. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 5. Write clearly in the sense of logic, language, and readability. Label all rule applications in your derivation trees. The clarity of your arguments and explanations aﬀects your grade. 6. You have 120 minutes to complete the exam. Assignment 1 2 3 4 5 6 ∑ Max 18 17 12 30 30 13 120 Points Formal Methods and Functional Programming, Final Exam, 2022 2 Assignment 1: Typing (18 Points) Task 1.A (7 Points) Consider the following functions from the Haskell Prelude library. (==) :: Eq a => a -> a -> Bool foldl :: (b -> a -> b) -> b -> [a] -> b Determine whether the following expressions are well-typed or not. If they are, simply state the most general type. If they are not, brieﬂy explain why they cannot be typed. 1. foldl (==) 2. \\x y -> (y x, x y) Formal Methods and Functional Programming, Final Exam, 2022 3 Task 1.B (11 Points) Recall the proof rules for the Mini-Haskell type system: Var . . . , x : τ, . . . ⊢ x :: τ Γ, x : σ ⊢ t :: τ Abs Γ ⊢ λx. t :: σ → τ Γ ⊢ t1 :: σ → τ Γ ⊢ t2 :: σ App Γ ⊢ t1 t2 :: τ Int Γ ⊢ n :: Int True Γ ⊢ True :: Bool False Γ ⊢ False :: Bool Γ ⊢ t :: Int iszero Γ ⊢ iszero t :: Bool Γ ⊢ t1 :: Int Γ ⊢ t2 :: Int BinOp Γ ⊢ (t1 op t2) :: Int for op ∈ {+, ∗} Γ ⊢ t0 :: Bool Γ ⊢ t1 :: τ Γ ⊢ t2 :: τ if Γ ⊢ if t0 then t1 else t2 :: τ Γ ⊢ t1 :: τ1 Γ ⊢ t2 :: τ2 Tuple Γ ⊢ (t1, t2) :: (τ1, τ2) Γ ⊢ t :: (τ1, τ2) fst Γ ⊢ fst t :: τ1 Γ ⊢ t :: (τ1, τ2) snd Γ ⊢ snd t :: τ2 Formally infer the most general type of the following Mini-Haskell expression. Label every step of the proof with the name of the used rule and list all the encountered type constraints explicitly. ⊢ (λx.λy. (x y) ∗ (fst y)) :: ... Formal Methods and Functional Programming, Final Exam, 2022 4 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2022 5 Assignment 2: Axiomatic Semantics (17 Points) Consider the following statement s: i := 0; r := 0; while i < 2 * n do if (i < n) { r := r + 1 } else { r := r + 3 } ; i := i + 1 end A proof outline showing that {n ≥ 0 ∧ n = N }s{r = 4 ∗ N } is given on the next page (with justiﬁcations of some entailments below). Unfortunately, this proof outline contains mistakes. Precisely describe all mistakes. In particular, for each mistake, clearly write the rule wrongly applied, and explain why it is wrongly applied (note that any deviation from the rule is considered a mistake). There is at most one mistake per rule application. Justiﬁcations of some entailments 1. Left conjunct: r = 0 = i. Right conjunct: Since i = 0 and n ≥ 0, the right-hand side of the implication must only hold when n = 0, which is the case (r = 0 = 0 + (0 − 0) ∗ 3 = 0 + (i − 0) ∗ 3) 2. In the case where i = n − 1, we have (from the left conjunct) that r = i + 1 = n, and thus r = n = n + (n − 1 + 1 − n) ∗ 3 = n + (i + 1 − n) ∗ 3. 3. i is incremented by 1 at each iteration, and the last iteration happens when i = 2 ∗ n − 1, thus i = 2 ∗ n after the loop. 4. Since i = 2 ∗ n and 2 ∗ n ≥ n, the implication i ≥ n ⇒ r = n + (i − n) ∗ 3 gives us r = n + (i − n) ∗ 3, and thus r = n + (2 ∗ n − n) ∗ 3. Formal Methods and Functional Programming, Final Exam, 2022 6 {n ≥ 0 ∧ n = N } i := 0 {n ≥ 0 ∧ n = N ∧ i = 0} r := 0 {n ≥ 0 ∧ n = N ∧ i = 0 ∧ r = 0} |= (1) {(i < n ⇒ r = i) ∧ (i ≥ n ⇒ r = n + (i − n) ∗ 3)} while i < 2 * n do {i < 2 ∗ n ∧ (i < n ⇒ r = i) ∧ (i ≥ n ⇒ r = n + (i − n) ∗ 3)} if (i < n) { {i < n ∧ i < 2 ∗ n ∧ (i < n ⇒ r = i) ∧ (i ≥ n ⇒ r = n + (i − n) ∗ 3)} |= (trivial) {r + 1 = i + 1 ∧ i < 2 ∗ n} r := r + 1 {r = i + 1 ∧ i < 2 ∗ n} } else { {¬(i < n) ∧ i < 2 ∗ n ∧ (i < n ⇒ r = i) ∧ (i ≥ n ⇒ r = n + (i − n) ∗ 3)} |= (trivial) {r = n + (i − n) ∗ 3 ∧ i < 2 ∗ n} r := r + 3 {r − 3 = n + (i − n) ∗ 3 ∧ i < 2 ∗ n} |= (trivial) {r = n + (i + 1 − n) ∗ 3 ∧ i < 2 ∗ n} } ; {(i < n ⇒ r = i + 1 ∧ i < 2 ∗ n) ∧ (¬(i < n) ⇒ r = n + (i + 1 − n) ∗ 3 ∧ i < 2 ∗ n)} |= (2) {(i + 1 < n ⇒ r = i + 1) ∧ (¬(i + 1 < n) ⇒ r = n + (i + 1 − n) ∗ 3) ∧ i + 1 < 2 ∗ n + 1} i := i + 1 {(i < n ⇒ r = i) ∧ (¬(i < n) ⇒ r = n + (i − n) ∗ 3) ∧ i < 2 ∗ n + 1} end {¬(i < 2 ∗ n) ∧ (i < n ⇒ r = i) ∧ (i ≥ n ⇒ r = n + (i − n) ∗ 3)} |= (3) {i = 2 ∗ n ∧ (i < n ⇒ r = i) ∧ (i ≥ n ⇒ r = n + (i − n) ∗ 3)} |= (4) {r = n + (2 ∗ n − n) ∗ 3} |= (trivial) {r = 4 ∗ N } Formal Methods and Functional Programming, Final Exam, 2022 7 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2022 8 Assignment 3: Proofs about functional programs (12 Points) We deﬁne a Haskell datatype representing binary trees: data Tree = Leaf | Node Tree Tree Consider the following function declarations. height :: Tree -> Int height Leaf = 0 -- height.1 height (Node x y) = 1 + max (height x) (height y) -- height.2 graft :: Tree -> Tree -> Tree graft Leaf u = u -- graft.1 graft (Node x y) u = Node (graft x u) (graft y u) -- graft.2 Prove that for all t, u :: Tree the equality height (graft t u) = height t + height u holds. Structure your proof clearly and justify every proof step. You may use the following lemma without proof. Lemma max add: ∀a, b, c :: Int. max a b + c = max (a + c) (b + c) Formal Methods and Functional Programming, Final Exam, 2022 9 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2022 10 Assignment 4: Big-Step Semantics (30 Points) In this task, we extend IMP with a new loop construct called double-while, deﬁned according to the following rules: ⟨s, σ⟩ → σ′ ⟨double-while (b2|b1) do s end, σ′⟩ → σ′′ (Double-WhTN S) ⟨double-while (b1|b2) do s end, σ⟩ → σ′′ if B[[b1]]σ = tt (Double-WhFN S) ⟨double-while (b1|b2) do s end, σ⟩ → σ if B[[b1]]σ = ﬀ For the sake of shorter notation, consider using the following shorthands: w2(x1, x2) ≡ double-while (x1#0|x2#0) do s end sif ≡ if x2#0 then s else x1 := 0 end wif ≡ while x1#0 do s;sif end Recall that the operator # means ”not equal to”. Prove the following statement: ∀σ, σ′, s, x1, x2. (⟨w2(x1, x2), σ⟩ → σ′ =⇒ ⟨wif , σ⟩ → σ′[x1 ↦→ 0]) Hint: You can use the following lemmas: ∀σ, c, v. B[[c#v]]σ = ﬀ =⇒ σ = σ[c ↦→ v] (L1) ∀σ, c, v. B[[c#v]]σ[c ↦→ v] = ﬀ (L2) Formal Methods and Functional Programming, Final Exam, 2022 11 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2022 12 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2022 13 Assignment 5: Programming (30 Points) You may use any function from the Haskell Prelude and the Data.List library in your solutions (without giving their deﬁnitions). You also may use any function from one subproblem to solve the subsequent subproblems, even if you have not provided a deﬁnition for the function itself. Task 5.A (8 Points) In this exercise we will use lists to represent sets. We declare the following type synonym: type Set a = [a] Keep in mind that this is just a type synonym so that you may apply any function on lists also on elements of type Set a. In particular we will represent sets by normalized lists, i.e., ordered lists that do not contain duplicates. Recall the functions nub and sort from the Data.List library that, respectively, remove duplicates and sort lists: nub :: Eq a => [a] -> [a] sort :: Ord a => [a] -> [a] 1. Deﬁne a function that normalizes lists. In other words, remove the duplicates in the list and order its elements. It has the following signature: makeSet:: Ord a => [a] -> Set a For the rest of the exercise, you may assume that any element of type Set a is a normalized list. In particular, you should make sure that you always normalize lists (for example with the makeSet function) before returning an element of Set a. 2. Deﬁne a function that computes the union of two sets. union :: Ord a => Set a -> Set a -> Set a Formal Methods and Functional Programming, Final Exam, 2022 14 Finally, observe that the normalized list representation of sets allows us to use the usual operator (==) to check equality between elements of type Set a. 3. Given a function f :: Set a -> Set a on sets and an initial set A, deﬁne a function fixedPoint that repeatedly applies f until the output doesn’t change anymore. In other words, return the ﬁrst element in the sequence A, f A, f (f A), f (f (f A)), ... whose successor is equal to the element itself. If a ﬁxed point does not exist, or cannot be reached by such an iteration, fixedPoint is not expected to terminate. fixedPoint :: Ord a => (Set a -> Set a) -> Set a -> Set a Formal Methods and Functional Programming, Final Exam, 2022 15 Task 5.B (22 Points) In the rest of the exercise we will implement a datatype that repre- sents a labeled transition system (LTS). You may think of an LTS as a nondeterministic ﬁnite automaton over a possibly inﬁnite set of states, without accepting states. Formally, given an alphabet Σ and a set of states S, an LTS is a pair (δ, s0) where δ : (Σ ∪ {ϵ}) × S → P(S) and s0 ∈ S indicate the transition function and initial state respectively. For example, consider the following LTS: 1start 2 3 a,b b,ϵ f ϵ ϵ b,ϵ The initial state of the above LTS is s0 = 1. The transition δ(b, 1) = {1, 2} means there is a transition labeled b from state 1 to states 1 and 2. The ϵ-label indicates internal transitions. For example, this LTS can move from state 1 to state 2 without reading any characters. • We represent our states as integers (of type Int). • We represent the alphabet Σ as Char and the labels and the transition function as follows: data Label = Letter Char | Epsilon type Transition = Label -> Int -> Set Int Note that we have used our (Set a) type from task 3.A to represent sets of integers. Finally, we represent an LTS as: data LTS = LTS Transition Int 1. (1 point) Deﬁne a function that returns the start state of a given LTS. startstate :: LTS -> Int Formal Methods and Functional Programming, Final Exam, 2022 16 2. (5 points) Given an LTS, a label, and a set of states, deﬁne a function that returns the set of states to which the LTS can move in one transition from the given set of states using that label. In the example LTS above, given the label ϵ and the set of states {3}, this function should return {2}. oneStep :: LTS -> Label -> Set Int -> Set Int 3. (6 points) Given an LTS and a set of states, deﬁne a function that returns all states which are reachable with zero or more ϵ-transitions from the given set of states. In the example LTS above, given the set of states {3}, this function should return {1, 2, 3}. epsClosure :: LTS -> Set Int -> Set Int Formal Methods and Functional Programming, Final Exam, 2022 17 4. (4 points) Combine the functions above to deﬁne a function that, given an LTS, a character label and a set of states, returns the set of states which the LTS can reach reading the given character from the given set of states. Note that zero or more ϵ transitions may occur before and after the character transition. In the example LTS above, given the character b and the set of states {3}, this function should return {1, 2}. readChar :: LTS -> Char -> Set Int -> Set Int 5. (6 points) Now deﬁne a function that, given an LTS and a string (i.e. a sequence of character labels), returns the set of all states that are reachable from the initial state by the LTS after reading the given string. reach :: LTS -> String -> Set Int Formal Methods and Functional Programming, Final Exam, 2022 18 Assignment 6: Linear Temporal Logic (13 Points) Consider the transition system depicted below, which models a coﬀee vending machine oﬀering two types of coﬀee: Espresso and Americano. The labels at each state indicate which of the ﬁve atomic propositions SE (User selected Espresso), SA (User selected Americano), A (Americano gets dispensed), E (Espresso gets dispensed) and P (User has paid) hold in the respective states. The system is initially in state select where the user can select either Espresso or Americano. In either one, the machine will display an amount of money to be paid by the user. If the user pays, the user should get dispensed the coﬀee type of their choice in the dispense states dispA, dispE and dispE’, respectively. Otherwise, if the user has not paid, the machine will loop back to the select state. Note there is a bug in the vending machine: Choosing Americano, the user may get an Espresso for free (but no Americano). select {} Espresso {SE} dispE {E, P } Americano {SA} select’ {SA} dispE’ {E} dispA {A, P } Task 6.A (6 Points) For each of the following LTL formulas, state whether or not the formula deﬁnes a property that is valid in the given transition system. Justify your answer by either brieﬂy explaining why it is valid or providing a counterexample if it is not. i) □(♦SE ⇒ ♦E) ii) □(⃝A ⇒ SA) Formal Methods and Functional Programming, Final Exam, 2022 19 iii) □(⃝E ⇒ SE) iv) □(⃝(E ∧ ¬P ) ⇒ ♦SA) Task 6.B (3 Points) The manufacturer wants you to inspect the machine. Concretely, they ask you to write down an LTL formula for each of the following properties. i) Users should never be able to get an Americano/Espresso if they have not paid. ii) The machine will dispense an Americano at least twice. iii) The machine will dispense an Espresso inﬁnitely often. Formal Methods and Functional Programming, Final Exam, 2022 20 Task 6.C (4 Points) This question is independent of the transition system above. Decide for the two respective LTL formulas whether it is a safety property, a liveness property, both, or neither. Justify your answers. i) □(⃝A ⇒ ♦E) ii) A ∧ ♦(□E) Formal Methods and Functional Programming, Final Exam, 2022 21 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ::= skip | x := e | s;s | if b then s else s end | while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). The free variables FV(s) of a statement s are deﬁned as FV(skip) = ∅ FV(x:=e) = {x} ∪ FV(e) FV(s1;s2) = FV(s1) ∪ FV(s2) FV(if b then s1 else s2 end) = FV(b) ∪ FV(s1) ∪ FV(s2) FV(while b do s end) = FV(b) ∪ FV(s) Big-Step Semantics (SkipN S) ⟨skip, σ⟩ → σ (AssN S) ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ → σ′ ⟨s2, σ′⟩ → σ′′ (SeqN S) ⟨s1;s2, σ⟩ → σ′′ ⟨s1, σ⟩ → σ′ (IfTN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = tt ⟨s2, σ⟩ → σ′ (IfFN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = ﬀ ⟨s, σ⟩ → σ′ ⟨while b do s end, σ′⟩ → σ′′ (WhTN S) ⟨while b do s end, σ⟩ → σ′′ if B[[b]]σ = tt (WhFN S) ⟨while b do s end, σ⟩ → σ if B[[b]]σ = ﬀ Formal Methods and Functional Programming, Final Exam, 2022 22 Axiomatic Semantics (Partial Correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ↦→ e] } x := e { P } { P } s1 { R } { R } s2 { Q } (SeqAx) { P } s1;s2 { Q } { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P ′ } s { Q′ } (ConsAx) { P } s { Q } if P ⊨ P′ and Q′ ⊨ Q Axiomatic Semantics (Total Correctness) Rules are as for partial correctness above, except for the following rule, which replaces WhAx: { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ⊨ 0 ≤ e where Z is a fresh logical variable (not used in P).","libVersion":"0.5.0","langs":""}