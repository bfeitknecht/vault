{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w03.pdf","text":"Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Woche 3 – Übersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder Vollständigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne Gewähr.) Anmerkungen zu den Code-Expert Abgaben: Anmerkungen zu den Moodle Abgaben: • Insgesamt sehr schön gelöst. Mir sind keine besonderen Probleme aufgefallen. • Teilweise wurde die Coins-Aufgabe sehr aufwändig gelöst. Hier ist mein Lösungsvorschlag, der den gegebenen Hinweis einfach direkt (mit den Haskell-Tricks, die wir bis jetzt kennengelernt haben) implementiert: • Bis auf kleine Fehler wurde die Serie 2 sehr gut gelöst. Um die kleinen Fehler zu beheben, werde ich hier nun noch einmal kurz ein wichtiges Konzept genauer behandeln: o Implikationen sind rechts-assoziativ, also 𝐴 → 𝐵 → 𝐶 ≡ 𝐴 → (𝐵 → 𝐶) o Damit eine Implikation 𝐹𝑎𝑙𝑠𝑒 wird, muss ihre LHS 𝑇𝑟𝑢𝑒 und ihre RHS 𝐹𝑎𝑙𝑠𝑒 sein, also wird bspw. 𝐴 → 𝐵 → 𝐶 → 𝐷 ≡ 𝐴 → (𝐵 → (𝐶 → 𝐷)) genau dann 𝐹𝑎𝑙𝑠𝑒, wenn 𝐴 𝑇𝑟𝑢𝑒 wird und 𝐵 → (𝐶 → 𝐷) 𝐹𝑎𝑙𝑠𝑒 wird. Dies ist der Fall, wenn 𝐵 𝑇𝑟𝑢𝑒 und 𝐶 → 𝐷 𝐹𝑎𝑙𝑠𝑒 wird. Dies wiederum geschieht gdw. 𝐶 𝑇𝑟𝑢𝑒 und 𝐷 𝐹𝑎𝑙𝑠𝑒 ist. Also: 𝐴 = 𝐵 = 𝐶 = 1 und 𝐷 = 0 damit die Formel von oben 𝐹𝑎𝑙𝑠𝑒 wird. (Achtung, hinsichtlich der Formalität ist das hier jetzt nicht perfekt, es geht mir um die Intuition, damit ihr versteht, wie Formeln, die mehrere „verschachtelte“ Implikationen enthalten, bestimmte Wahrheitswerte annehmen können). Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Natural Deduction – Letzte Aufgabe (Midterm Prep.): Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Induktion über Natürliche Zahlen – Recap und Induktion mit Haskell-Funktionen: Ich hatte es in der ersten Übungsstunde ja schon einmal kurz angeschnitten, daher jetzt hier noch einmal: Allgemeine Regeln zur Induktion in FMFP: • Struktur: Prinzip der vollst. Induktion: (𝐴(𝑛0) ∧ [∀𝑛 ∈ ℕ, 𝑛 ≥ 𝑛0 ∶ 𝐴(𝑛) ⇒ 𝐴(𝑛 + 1)]) ⇒ ∀𝑛 ∈ ℕ, 𝑛 ≥ 𝑛0 ∶ 𝐴(𝑛) • Behauptung: ∀𝑛 ∈ ℕ, 𝑛 ≥ 𝑛0 : 𝐴(𝑛) • Induktionsanfang / Base Case (IA/BC): Zeige, dass A für kleinstes 𝑛0 gilt • “A(n) gilt für EIN konkretes n” • Induktionshypothese / Induktionsvorraussetzung (IH / IV) 𝐴(𝑚) gilt für bel. fixes 𝑛. “A(m) gilt für EIN allgemeines m” • Induktionsschritt (IS): Beweis von 𝐴(𝑚) ⇒ 𝐴(𝑚 + 1) • “Wenn A(m) für ein m gilt, dann gilt immer auch A(m+1), • da wir m allgemein gehalten haben” ⇒ Induktionsbehauptung (IB): ∀𝑛 ∈ ℕ, 𝑛 ≥ 𝑛0 : 𝐴(𝑛) Prinzip der Starken Induktion: (𝐴(𝑛0) ∧ [∀𝑛 ∈ ℕ, 𝑛 > 𝑛0 ∶ (∀𝑘 ∈ ℕ, 𝑛0 ≤ 𝑘 < 𝑛 ∶ 𝐴(𝑘)) ⇒ 𝐴(𝑛)]) ⇒ ∀𝑛 ∈ ℕ, 𝑛 > 𝑛0 ∶ 𝐴(𝑛) • Behauptung: ∀𝑛 ∈ ℕ, 𝑛 ≥ 𝑛0 : 𝐴(𝑛) • Induktionsanfang / Base Case (IA/BC): Zeige, dass A für kleinstes 𝑛0 ∈ ℕ (oder eine Menge an kleinsten 𝑛0, … , 𝑛𝑥 ∈ ℕ) gilt “A(n) gilt für EIN konkretes 𝑛0 (bzw. EINE konkrete Menge 𝑀 ≔ {𝑛0, … , 𝑛𝑥})” • Induktionshypths. / Induktionsvorstz. (IH / IV): Für bel. fix 𝑚 ≥ 𝑛0 : ∀𝑛0 ≤ 𝑘 < 𝑚 ∶ 𝐴(𝑘) “ “A(k) gilt für alle k < m für EIN allgemeines m” • Induktionsschritt (IS): Beweis von 𝐴(𝑚) ⇒ 𝐴(𝑚 + 1) • “Wenn A für alle 𝑘 ∈ {𝑛0, … , 𝑚} gilt, dann gilt immer auch A(m+1), da wir n allgemein gehalten haben” ⇒ Induktionsbehauptung (IB): ∀𝑛 ∈ ℕ : 𝐴(𝑛) (weiter auf der nächsten Seite →) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch • Ganz wichtig: Bei jedem Schritt die Begründung für diesen Schritt in Klammern angeben (üblicherweise am Ende der Zeile, auch wenn es noch so trivial wirken mag – es geht um das Einhalten von Formlt.). P[n->m] kann auch als P[n/m] (CYP-Syntax) geschrieben werden. Beispiel 1 – Induktionsbeweise mit Haskell-Funktionen: Wir beginnen mit einem vergleichsweise einfachen (und hoffentlich noch aus Algorithmen & Datenstrukturen bekannten) Beispiel zur Gauß-Summenformel: Wir nehmen an, uns wird diese Haskell-Funktion gegeben: Die Person, die uns diese Funktion gegeben hat, behauptet, dass sie die Gauß’sche Summenformel berechnet, also ∑ 𝑖 𝑛 𝑖=0 = 𝑛∗(𝑛+1) 2 für ein gegebenes 𝑛. Nun wollen wir d as formal korrekt beweisen, also: ∀n: Nat . gsum n = n ⋅ (n + 1)/2: (weiter auf der nächsten Seite →) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Beispiel 2 – Induktionsbeweise mit Haskell-Funktionen: Hier ein weiteres einfaches Beispiel, wir wollen beweisen, dass die Funktionen dasselbe berechnen, also ∀n ∶ Nat . flup n = flop n. Und hier der dazugehörige Proof: Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Haskell Rekursion 2: Die Funktionen, die wir in der Übungsstunde implementiert haben: (weiter auf der nächsten Seite →) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Haskell – List Comprehensions: In Haskell gibt es ein sehr mächtiges Werkzeug, um mit Listen zu arbeiten: Sogenannte List Comprehensions. Aus der (bspw. Diskreten) Mathematik wissen wir noch, dass wir Mengen sehr bequem mit folgender Schreibweise angeben können: 𝑀 ≔ {2 ∗ 𝑥 ∶ 𝑥 ∈ ℤ, 0 < 𝑥 < 5} (Beispiel) Genau das können wir in Haskell auch: List Comprehensions in Haskell haben die Form: (Kleiner Fehler hier: Wir müssten in Haskell natürlich den „mod“ Operator verwenden, statt „%“) Das Coole: Da links vom „|“ eine Expression stehen soll, können wir dort alles hinschreiben, was in Haskell nun mal eine Expression ist, bspw. auch „if … then … else …“ oder „let … in …“ etc. Da man das am besten mit Beispielen versteht, hier nun Einige: Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Auch lässt sich mithilfe von List-Comprehensions und einfachen List-Operationen der Quicksort- Algorithmus deutlich kürzer implementieren: Haskell Lists – List Functions Pt. 3: Wir haben bereits einige fundamentale Haskell Prelude Funktionen für Listen kennengelernt, bspw. head, tail, sum, max, etc.. Es gibt jedoch noch weitere sehr nützliche Funktionen, von denen wir uns hier nun drei genauer angucken wollen. List-Funktion 1: „map“: Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch List-Funktion 2: „filter“: List-Funktion 3: „foldr“:","libVersion":"0.5.0","langs":""}