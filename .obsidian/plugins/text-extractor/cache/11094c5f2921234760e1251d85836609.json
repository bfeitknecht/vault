{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w03.pdf","text":"Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Woche 3 â€“ Ãœbersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder VollstÃ¤ndigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne GewÃ¤hr.) Anmerkungen zu den Code-Expert Abgaben: Anmerkungen zu den Moodle Abgaben: â€¢ Insgesamt sehr schÃ¶n gelÃ¶st. Mir sind keine besonderen Probleme aufgefallen. â€¢ Teilweise wurde die Coins-Aufgabe sehr aufwÃ¤ndig gelÃ¶st. Hier ist mein LÃ¶sungsvorschlag, der den gegebenen Hinweis einfach direkt (mit den Haskell-Tricks, die wir bis jetzt kennengelernt haben) implementiert: â€¢ Bis auf kleine Fehler wurde die Serie 2 sehr gut gelÃ¶st. Um die kleinen Fehler zu beheben, werde ich hier nun noch einmal kurz ein wichtiges Konzept genauer behandeln: o Implikationen sind rechts-assoziativ, also ğ´ â†’ ğµ â†’ ğ¶ â‰¡ ğ´ â†’ (ğµ â†’ ğ¶) o Damit eine Implikation ğ¹ğ‘ğ‘™ğ‘ ğ‘’ wird, muss ihre LHS ğ‘‡ğ‘Ÿğ‘¢ğ‘’ und ihre RHS ğ¹ğ‘ğ‘™ğ‘ ğ‘’ sein, also wird bspw. ğ´ â†’ ğµ â†’ ğ¶ â†’ ğ· â‰¡ ğ´ â†’ (ğµ â†’ (ğ¶ â†’ ğ·)) genau dann ğ¹ğ‘ğ‘™ğ‘ ğ‘’, wenn ğ´ ğ‘‡ğ‘Ÿğ‘¢ğ‘’ wird und ğµ â†’ (ğ¶ â†’ ğ·) ğ¹ğ‘ğ‘™ğ‘ ğ‘’ wird. Dies ist der Fall, wenn ğµ ğ‘‡ğ‘Ÿğ‘¢ğ‘’ und ğ¶ â†’ ğ· ğ¹ğ‘ğ‘™ğ‘ ğ‘’ wird. Dies wiederum geschieht gdw. ğ¶ ğ‘‡ğ‘Ÿğ‘¢ğ‘’ und ğ· ğ¹ğ‘ğ‘™ğ‘ ğ‘’ ist. Also: ğ´ = ğµ = ğ¶ = 1 und ğ· = 0 damit die Formel von oben ğ¹ğ‘ğ‘™ğ‘ ğ‘’ wird. (Achtung, hinsichtlich der FormalitÃ¤t ist das hier jetzt nicht perfekt, es geht mir um die Intuition, damit ihr versteht, wie Formeln, die mehrere â€verschachtelteâ€œ Implikationen enthalten, bestimmte Wahrheitswerte annehmen kÃ¶nnen). Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Natural Deduction â€“ Letzte Aufgabe (Midterm Prep.): Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Induktion Ã¼ber NatÃ¼rliche Zahlen â€“ Recap und Induktion mit Haskell-Funktionen: Ich hatte es in der ersten Ãœbungsstunde ja schon einmal kurz angeschnitten, daher jetzt hier noch einmal: Allgemeine Regeln zur Induktion in FMFP: â€¢ Struktur: Prinzip der vollst. Induktion: (ğ´(ğ‘›0) âˆ§ [âˆ€ğ‘› âˆˆ â„•, ğ‘› â‰¥ ğ‘›0 âˆ¶ ğ´(ğ‘›) â‡’ ğ´(ğ‘› + 1)]) â‡’ âˆ€ğ‘› âˆˆ â„•, ğ‘› â‰¥ ğ‘›0 âˆ¶ ğ´(ğ‘›) â€¢ Behauptung: âˆ€ğ‘› âˆˆ â„•, ğ‘› â‰¥ ğ‘›0 : ğ´(ğ‘›) â€¢ Induktionsanfang / Base Case (IA/BC): Zeige, dass A fÃ¼r kleinstes ğ‘›0 gilt â€¢ â€œA(n) gilt fÃ¼r EIN konkretes nâ€ â€¢ Induktionshypothese / Induktionsvorraussetzung (IH / IV) ğ´(ğ‘š) gilt fÃ¼r bel. fixes ğ‘›. â€œA(m) gilt fÃ¼r EIN allgemeines mâ€ â€¢ Induktionsschritt (IS): Beweis von ğ´(ğ‘š) â‡’ ğ´(ğ‘š + 1) â€¢ â€œWenn A(m) fÃ¼r ein m gilt, dann gilt immer auch A(m+1), â€¢ da wir m allgemein gehalten habenâ€ â‡’ Induktionsbehauptung (IB): âˆ€ğ‘› âˆˆ â„•, ğ‘› â‰¥ ğ‘›0 : ğ´(ğ‘›) Prinzip der Starken Induktion: (ğ´(ğ‘›0) âˆ§ [âˆ€ğ‘› âˆˆ â„•, ğ‘› > ğ‘›0 âˆ¶ (âˆ€ğ‘˜ âˆˆ â„•, ğ‘›0 â‰¤ ğ‘˜ < ğ‘› âˆ¶ ğ´(ğ‘˜)) â‡’ ğ´(ğ‘›)]) â‡’ âˆ€ğ‘› âˆˆ â„•, ğ‘› > ğ‘›0 âˆ¶ ğ´(ğ‘›) â€¢ Behauptung: âˆ€ğ‘› âˆˆ â„•, ğ‘› â‰¥ ğ‘›0 : ğ´(ğ‘›) â€¢ Induktionsanfang / Base Case (IA/BC): Zeige, dass A fÃ¼r kleinstes ğ‘›0 âˆˆ â„• (oder eine Menge an kleinsten ğ‘›0, â€¦ , ğ‘›ğ‘¥ âˆˆ â„•) gilt â€œA(n) gilt fÃ¼r EIN konkretes ğ‘›0 (bzw. EINE konkrete Menge ğ‘€ â‰” {ğ‘›0, â€¦ , ğ‘›ğ‘¥})â€ â€¢ Induktionshypths. / Induktionsvorstz. (IH / IV): FÃ¼r bel. fix ğ‘š â‰¥ ğ‘›0 : âˆ€ğ‘›0 â‰¤ ğ‘˜ < ğ‘š âˆ¶ ğ´(ğ‘˜) â€œ â€œA(k) gilt fÃ¼r alle k < m fÃ¼r EIN allgemeines mâ€ â€¢ Induktionsschritt (IS): Beweis von ğ´(ğ‘š) â‡’ ğ´(ğ‘š + 1) â€¢ â€œWenn A fÃ¼r alle ğ‘˜ âˆˆ {ğ‘›0, â€¦ , ğ‘š} gilt, dann gilt immer auch A(m+1), da wir n allgemein gehalten habenâ€ â‡’ Induktionsbehauptung (IB): âˆ€ğ‘› âˆˆ â„• : ğ´(ğ‘›) (weiter auf der nÃ¤chsten Seite â†’) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch â€¢ Ganz wichtig: Bei jedem Schritt die BegrÃ¼ndung fÃ¼r diesen Schritt in Klammern angeben (Ã¼blicherweise am Ende der Zeile, auch wenn es noch so trivial wirken mag â€“ es geht um das Einhalten von Formlt.). P[n->m] kann auch als P[n/m] (CYP-Syntax) geschrieben werden. Beispiel 1 â€“ Induktionsbeweise mit Haskell-Funktionen: Wir beginnen mit einem vergleichsweise einfachen (und hoffentlich noch aus Algorithmen & Datenstrukturen bekannten) Beispiel zur GauÃŸ-Summenformel: Wir nehmen an, uns wird diese Haskell-Funktion gegeben: Die Person, die uns diese Funktion gegeben hat, behauptet, dass sie die GauÃŸâ€™sche Summenformel berechnet, also âˆ‘ ğ‘– ğ‘› ğ‘–=0 = ğ‘›âˆ—(ğ‘›+1) 2 fÃ¼r ein gegebenes ğ‘›. Nun wollen wir d as formal korrekt beweisen, also: âˆ€n: Nat . gsum n = n â‹… (n + 1)/2: (weiter auf der nÃ¤chsten Seite â†’) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Beispiel 2 â€“ Induktionsbeweise mit Haskell-Funktionen: Hier ein weiteres einfaches Beispiel, wir wollen beweisen, dass die Funktionen dasselbe berechnen, also âˆ€n âˆ¶ Nat . flup n = flop n. Und hier der dazugehÃ¶rige Proof: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Haskell Rekursion 2: Die Funktionen, die wir in der Ãœbungsstunde implementiert haben: (weiter auf der nÃ¤chsten Seite â†’) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Haskell â€“ List Comprehensions: In Haskell gibt es ein sehr mÃ¤chtiges Werkzeug, um mit Listen zu arbeiten: Sogenannte List Comprehensions. Aus der (bspw. Diskreten) Mathematik wissen wir noch, dass wir Mengen sehr bequem mit folgender Schreibweise angeben kÃ¶nnen: ğ‘€ â‰” {2 âˆ— ğ‘¥ âˆ¶ ğ‘¥ âˆˆ â„¤, 0 < ğ‘¥ < 5} (Beispiel) Genau das kÃ¶nnen wir in Haskell auch: List Comprehensions in Haskell haben die Form: (Kleiner Fehler hier: Wir mÃ¼ssten in Haskell natÃ¼rlich den â€modâ€œ Operator verwenden, statt â€%â€œ) Das Coole: Da links vom â€|â€œ eine Expression stehen soll, kÃ¶nnen wir dort alles hinschreiben, was in Haskell nun mal eine Expression ist, bspw. auch â€if â€¦ then â€¦ else â€¦â€œ oder â€let â€¦ in â€¦â€œ etc. Da man das am besten mit Beispielen versteht, hier nun Einige: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Auch lÃ¤sst sich mithilfe von List-Comprehensions und einfachen List-Operationen der Quicksort- Algorithmus deutlich kÃ¼rzer implementieren: Haskell Lists â€“ List Functions Pt. 3: Wir haben bereits einige fundamentale Haskell Prelude Funktionen fÃ¼r Listen kennengelernt, bspw. head, tail, sum, max, etc.. Es gibt jedoch noch weitere sehr nÃ¼tzliche Funktionen, von denen wir uns hier nun drei genauer angucken wollen. List-Funktion 1: â€mapâ€œ: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch List-Funktion 2: â€filterâ€œ: List-Funktion 3: â€foldrâ€œ:","libVersion":"0.5.0","langs":""}