{"path":"sem2/PProg/UE/s/PProg-u14-s.pdf","text":"Parallel Programming Assignment 14: Consensus Spring Semester 2024 Assigned on: 25.05.2024 Due by: 31.05.2024 Overview Consensus is a fundamental problem in parallel / distributed computing with many practical applications. Abstractly, the consensus problem is about agreeing on the same value among multiple agents, while allowing for agents to fail. The consensus problem for N threads can be phrased as follows: Each thread proposes a value. After a finite number of steps each thread must agree on the same value, which must also be equivalent to one of the proposed values. Since we allow threads to fail, the protocol must be wait-free (we cannot wait for another threads actions, since that thread might have failed and thus we could never make progress). Each thread has a unique integer id between 0 and N-1. Consensus is one of the pillars of distributed cryptocurrencies such as bitcoin: All ”participants” need to agree on who possesses how much money at some point in time. However, for distributed cryptocurrencies to work in the presence of malicious participants we cannot assume they always cooperate. Exercise 1 – Consensus Properties A consensus protocol must fulfil three properties: consistency (the return value is the same for all threads), validity (the result is equal to one of the values proposed), and wait-freedom (each thread must finish in a finite number of steps, independent of other threads). Below we show incorrect implementations of a consensus protocol in pseudocode. Which property does each snippet violate when used with two threads? int decide(int proposed, int thread_id) { return proposed; } Solution: This protocol is not consistent. If two threads propose different values they will also return different values. It is wait-free and valid. int decide(int proposed, int thread_id) { return 0; } Solution: This protocol is not valid, if none of the threads proposed 0, still all threads will agree on zero. It is wait-free and consistent. int shared = 0; //shared atomic register int decide(int proposed, int thread_id) { if (shared == 0) { shared = proposed; } return shared; } Solution: This protocol is not consistent, thread A might propose 0 and return 0, after that thread B proposes 1 and returns 1. It is valid and wait-free. int shared = 0; //shared atomic register synchronized int decide(int proposed, int thread_id) { if (shared == 0) { shared = proposed; } return shared; } Solution: In addition to the problem discussed above, this is not wait-free. A thread might ”fail” i.e., by not being scheduled, within the locked decide method, now no other thread can make progress. Exercise 2 – Consensus Hierarchy a) Some objects are unable to implement a valid consensus protocol for some number of threads. For example, we have shown you a proof for the impossibility of consensus for two threads using only atomic registers in the exercise session. However, a (wait-free) FIFO queue with the operations enqueue() and dequeue() can implement wait-free consensus among two threads. Implement a consensus protocol for two threads using a FIFO queue, assume enqueue and dequeue are wait-free atomic operations, writing pseudocode is sufficient here, since Java does not implement such a FIFO anyway. Hint: You can assume the FIFO queue is initialized in any way that helps. Solution: We show this by construction, i.e., the code below implements consensus for two threads. Note that this does not generalize, if we have two threads we know where to find the value to return, since there is only one other thread there is only one option. If we were to add a third thread, this information would be missing. int shared[2]; fifo q = {0,1}; //initialize the queue with two distinct values int decide(int proposed, int thread_id) { shared[thread_id] = proposed; if (q.dequeue() == 0) return shared[thread_id]; //I won else return shared[thread_id+1 % 2]; // I lost, return others value } We call the maximum number of threads for which an object (such as a FIFO queue) can implement consensus the consensus number of that object. 2 b) Show that a FIFO queue with the wait-free and atomic operations enqueue, dequeue, and peek (returns the same value dequeue would return, but does not modify the queue) has consensus number ∞. Solution: By construction, i.e., the code below implements consensus for an arbitrary number N of threads. We do this by enqueueing our thread ID after writing our proposed value to the shared array. Any thread can now peek() at the queue and find the position (in the shared array) of the value to return. int shared[N]; fifo q = {}; //initialize the queue as empty int decide(int proposed, int thread_id) { shared[thread_id] = proposed; q.enqueue(thread_id); return shared[q.peek()]; } Exercise 3 – Binary Consensus In our proof for the impossibility of consensus for two threads we used a simplified version of consensus, where the proposed values could only be zero or one. Show that binary consensus is equivalent to consensus for two threads, i.e., we can implement one from the other using only atomic registers. Solution: To show equivalence we must show two things: • We can implement binary consensus using the decide function of a normal consensus protocol. • We can implement normal consensus using the binary decide function of a binary consensus proto- col. The first is trivial, since the decide function does not care which values it is given, if they are 0 or 1 the output will also be zero or one. The second is more tricky. Both threads might propose arbitrary values, we can store them in a shared array. Then we use binary consensus to elect a winning thread (the thread id is either 0 or 1) and return its number. int shared[2]; int decide(int proposed, int thread_id) { shared[thread_id] = proposed; int winner = bin_decide(thread_id); return shared[winner]; } 3","libVersion":"0.3.2","langs":""}