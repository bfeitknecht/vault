{"path":"sem4/FMFP/UE/e/FMFP-u01-e.pdf","text":"Formal Methods and Functional Programming Exercise Sheet 1 252-0058-00L February 17, 2025 For the first part of the course, there will be both pen-and-paper exercises and programming exercises. The programming exercises are uploaded on Code Expert: https://expert.ethz.ch/enrolled/SS25/fmfp/exercises Happy coding! As for the pen-and paper exercises, each week you may hand in your solution to the exercise marked with a (⋆) and receive feedback from your TA. You are encouraged to do so. Of course, if you have any questions about the solutions of the other exercises, please also reach out to your TA! Exercises marked as weekly headaches are challenging bonus problems. They are just meant as supplements to test your FMFP skills. 1(⋆). Evaluation strategies The Fibonacci numbers are defined as F (n) =    0 if n = 0, 1 if n = 1, F (n − 1) + F (n − 2) otherwise. Louis Reasoner writes the following Haskell program for computing Fibonacci num- bers: fibLouis :: Int -> Int fibLouis 0 = 0 fibLouis 1 = 1 fibLouis n = fibLouis (n - 1) + fibLouis (n - 2) Eva La Tour writes another Haskell program for the Fibonacci numbers: fibEva :: Int -> Int fibEva n = fst (aux n) where aux 0 = (0, 1) aux n = next (aux (n - 1)) next (a, b) = (b, a + b) Recall that Haskell uses lazy evaluation, so that expressions will be evaluated from the outside in, instead of evaluating arguments first. Pattern matching may force the evaluation of function arguments (see slide 30 from the first lecture). (a) Complete the evaluation steps in Haskell given below for fibLouis 4. 1 Formal Methods and Functional Programming Exercise Sheet 1 252-0058-00L February 17, 2025 fibLouis 4 = (fibLouis (4-1) + fibLouis (4-2)) = (fibLouis 3 + fibLouis (4-2)) = ... (b) Complete the evaluation steps for fibEva 4. fibEva 4 = fst (aux 4) = ... 2. Natural Deduction Recall that → is right-associative, while ∧ and ∨ are left-associative. Moreover, ¬ binds stronger than ∧, which binds stronger than ∨, which in turn binds stronger than →. Hence, the formula A ∧ B ∨ C → ¬E → C ∨ A ∧ B is parenthesized as ((A ∧ B) ∨ C) → ((¬E) → (C ∨ (A ∧ B))). We recommend to always parenthesize formulas before proving them using natural deduction. This simplifies matching the inference rules and you avoid trivial parsing errors. (a) Parenthesize the following formulas. (a) A ∨ B → C → A ∧ C ∨ B ∧ C (b) (A → B → C) → A ∧ B → C (b) Prove that the formulas in (a) are tautologies in intuitionistic logic using natural deduction. Give complete proof trees and label each rule application with the rule’s name. We recall the rules for natural deduction in intuitionistic logic at the end of this sheet. (c) We define A ↔ B as (A → B) ∧ (B → A). Provide suitable introduction and elimination rules for ↔ and use them to prove the validity of (A ↔ B) → (B ↔ A). 2 Formal Methods and Functional Programming Exercise Sheet 1 252-0058-00L February 17, 2025 Headache of the week Recall that one way to make the above inference system complete for classical logic is to add an axiom formalizing the ”law of excluded middle” (lat. ”tertium non datur”): Γ ⊢ A ∨ ¬A TND Prove that the formula ((A → B) → A) → A is valid in classical logic. Hint: Consider first the simpler case where B is replaced by ⊥. Recall that ¬A is syntactic sugar for A → ⊥. Generalize your proof for (¬A → A) → A to ((A → B) → A) → A. We recall the rules of natural deduction below: Γ, A ⊢ A axiom Γ, A ⊢ B Γ ⊢ A → B →-I Γ ⊢ A → B Γ ⊢ A Γ ⊢ B →-E Γ ⊢ ⊥ Γ ⊢ A ⊥-E Γ, A ⊢ ⊥ Γ ⊢ ¬A ¬-I Γ ⊢ ¬A Γ ⊢ A Γ ⊢ B ¬-E Γ ⊢ A Γ ⊢ B Γ ⊢ A ∧ B ∧-I Γ ⊢ A ∧ B Γ ⊢ A ∧-EL Γ ⊢ A ∧ B Γ ⊢ B ∧-ER Γ ⊢ A Γ ⊢ A ∨ B ∨-IL Γ ⊢ B Γ ⊢ A ∨ B ∨-IR Γ ⊢ A ∨ B Γ, A ⊢ C Γ, B ⊢ C Γ ⊢ C ∨-E 3","libVersion":"0.5.0","langs":""}