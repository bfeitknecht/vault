{"path":"sem4/FMFP/UE/s/FMFP-u08-s.pdf","text":"P. M¨uller, D. Basin and R. Jung Formal Methods and Functional Programming Exercise Sheet 8: Induction Submission deadline: Wednesday, April 16, 2025 Assignment 1 Let U be a sequence of integers, defined by U0 = U1 := −1, and, for all n ≥ 0, Un+2 = 5 × Un+1 − 6 × Un. Task 1.1: Prove that, for all natural numbers n, Un = 3 n−2 n+1 using strong induction. Solution. We define P (n) ≡ Un = 3 n − 2 n+1, we prove ∀n ≥ 0. P (n) by strong induction. Let n ≥ 0 be arbitrary, and let us assume P (j) for all j such that 0 ≤ j < n. Our goal is to prove P (n). We distinguish three cases: Case 1 : n = 0. In this case, U0 = −1 = 1 − 2 = 30 − 2 0+1, which concludes the case. Case 2 : n = 1. In this case, U1 = −1 = 3 − 4 = 31 − 2 1+1, which concludes the case. Case 3 : n ≥ 2. In this case, Un = 5Un−1 − 6Un−2. Since n − 1 < n and n − 2 < n, we know that P (n − 1) and P (n − 2) hold. Thus, Un = 5Un−1 − 6Un−2 = 5(3 n−1 − 2 n) − 6(3 n−2 − 2 n−1) = (15 − 6) × 3 n−2 − (10 − 6) × 2 n−1 = 3 n − 2 n+1 which concludes the proof. 1 Task 1.2: Prove that, for all natural numbers n, Un = 3 n−2 n+1 using weak induction. Solution. We define Q(n) ≡ ∀k. 0 ≤ k ≤ n ⇒ P (k), and we prove ∀n. Q(n) by weak induction. Base case: Let us prove Q(0), i.e. ∀k. 0 ≤ k ≤ 0 ⇒ P (k). In this case, k must be 0, and we need to prove P (0), which holds by definition: U0 = −1 = 3 0 − 2 1. Induction step: Let n ≥ 0 be arbitrary. We assume Q(n), and prove Q(n + 1). To prove Q(n + 1), we need to prove P (k) for all k such that 0 ≤ k ≤ n + 1. If 0 ≤ k ≤ n, we get P (k) from Q(n). Thus, to prove Q(n + 1), we simply need to prove P (n + 1). To do so, we distinguish two cases: Case 1: n = 0. In this case, P (1) holds by definition: U1 = −1 = 31 − 2 2, which concludes the case. Case 2: n > 0. We do the same proof as in the induction step in the proof by strong induction (with n shifted by 1). In this case, Un+1 = 5Un − 6Un−1. Since n ≤ n and n − 1 ≤ n, we know that P (n) and P (n − 1) hold, from Q(n). Thus, Un+1 = 5Un − 6Un−1 = 5(3 n − 2 n+1) − 6(3 n−1 − 2 n) = (15 − 6) × 3 n−1 − (10 − 6) × 2 n = 3 n+1 − 2 n+2 which concludes the proof. Assignment 2 (Run-Length Encoding) The background of this assignment is a simple run-length encoding scheme 1. In our case, the input data is encoded as a list of natural numbers 2 of even length. The encoded representation has the form n1:v1:n2:v2:. . .:[], where each pair ni:vi denotes, that the input data contained ni consecutive occurrences of vi. For example, the input 1:1:1:5:5:5:5:[] will be encoded as 3:1:4:5:[]. The function enc computes the run-length encoding of a given list of natural numbers. It is de- fined in terms of the auxiliary function aux that performs the actual encoding. enc [] = [] -- (E1) enc (x:xs) = aux xs 1 x [] -- (E2) aux [] n v ys = ys ++ [n,v] -- (A1) aux (x:xs) n v ys | x == v = aux xs (n+1) x ys -- (A2) | otherwise = aux xs 1 x (ys ++ [n,v]) -- (A3) 1http://en.wikipedia.org/wiki/Run-length_encoding 2We include zero in the natural numbers. 2 The function dec decodes run-length encoded data represented as a list of natural numbers. The function rep n v creates a list of length n where each element is v. dec [] = [] -- (D1) dec [n] = [] -- (D2) dec (n:v:xs) = rep n v ++ dec xs -- (D3) rep 0 v = [] -- (R1) rep n v = v:(rep (n-1) v) -- (R2) The function srclen computes the length of the source data from the encoded representa- tion. srclen [] = 0 -- (S1) srclen [n] = 0 -- (S2) srclen (n:v:xs) = n + srclen xs -- (S3) Note: The pathological cases (D2) and (S2) are only there to make the corresponding functions total. Lemmas: For the tasks below, you may use the following lemmas without proving them. (L1) ∀x :: Nat · ∀xs, ys :: [Nat] · (x:xs) ++ ys = x:(xs ++ ys) (L2) ∀n, m, v :: Nat · ∀xs, ys :: [Nat]· aux (rep m v ++ xs) n v ys = aux xs (n+m) v ys (L3) ∀n, v :: Nat · ∀xs :: [Nat]· length xs % 2 = 0 =⇒ srclen (xs ++ [n,v]) = srclen xs + n (L4) ∀n, v :: Nat · ∀xs :: [Nat]· length xs % 2 = 0 =⇒ length (xs ++ [n,v]) % 2 = 0 Task 2.1: Prove the following statement: ∀n, v :: Nat · ∀xs, ys :: [Nat] · length ys % 2 = 0 =⇒ srclen (aux (dec xs) n v ys) = srclen xs + n + srclen ys Hint: We recommend using strong structural induction (as explained in the exercise session) on one of the list-typed variables. Alternatively, you could use a mathematical induction on the length of one of the lists. Solution. We define P (xs) ≡ ∀n, v :: Nat · ∀ys :: [Nat] · length ys % 2 = 0 =⇒ srclen (aux (dec xs) n v ys) = srclen xs + n + srclen ys 3 and prove ∀xs :: [Nat] · P (xs) by strong structural induction on xs: We have to show P (xs) for some arbitrary xs :: [Nat] and may assume that the proposition holds for all proper subterms of xs, i.e., our induction hypothesis (IH) is ∀ys ⊏ xs · P (ys). Let n, v :: Nat and ys :: [Nat] be arbitrary. We prove that the implication holds by as- suming its left-hand side and then showing that its right-hand side holds. That is, we assume length ys % 2 = 0 (in the elaborations below, we will refer to this assumption as (A)) and have to show srclen (aux (dec xs) n v ys) = srclen xs + n + srclen ys. We proceed by a case analysis on xs. • Case xs ≡ []: srclen (aux (dec []) n v ys) = srclen (aux [] n v ys) (D1) = srclen (ys ++ [n,v]) (A1) = srclen ys + n (L3) = 0 + n + srclen ys (arith) = srclen [] + n + srclen ys (S1) • Case xs ≡ [m], for some m :: Nat: Analogous to the previous case. • Case xs ≡ (m:u:zs), for some m, u :: Nat and zs :: [Nat]: We perform a further case distinction on the values of m and u: – Subcase u = v: srclen (aux (dec (m:v:zs)) n v ys) = srclen (aux (rep m v ++ dec zs) n v ys) (D3) = srclen (aux (dec zs) (n+m) v ys) (L2) = srclen zs + (n+m) + srclen ys (IH,A) = m + srclen zs + n + srclen ys (arith) = srclen (m:u:zs) + n + srclen ys (S3) – Subcase u ̸= v and m = 0: srclen (aux (dec (0:u:zs)) n v ys) = srclen (aux (rep 0 u ++ dec zs) n v ys) (D3) = srclen (aux ([] ++ dec zs) n v ys) (R1) = srclen (aux (dec zs) n v ys) (++) = srclen zs + n + srclen ys (IH,A) = 0 + srclen zs + n + srclen ys (arith) = srclen (0:u:zs) + n + srclen ys (S3) 4 – Subcase u ̸= v and m > 0: srclen (aux (dec (m:u:zs)) n v ys) = srclen (aux (rep m u ++ dec zs) n v ys) (D3) = srclen (aux ((u:(rep (m-1) u)) ++ dec zs) n v ys) (R2) = srclen (aux (u:(rep (m-1) u ++ dec zs)) n v ys) (L1) = srclen (aux (rep (m-1) u ++ dec zs) 1 u (ys ++ [n,v]) (A3) = srclen (aux (dec zs) ((m-1)+1) u (ys ++ [n,v])) (L2) = srclen (aux (dec zs) m u (ys ++ [n,v])) (arith) = srclen zs + m + srclen (ys ++ [n,v]) (*) = srclen zs + m + srclen ys + n (A,L3) = m + srclen zs + n + srclen ys (arith) = srclen (m:u:zs) + n + srclen ys (S3) Note that in the step marked with a (*), we combined (L4) and (A) to derive the fact length (ys ++ [n,v]) % 2 = 0 so that we could then use the induction hypoth- esis to get the desired equality. Task 2.2: Use the result of the previous task to prove the following statement: ∀xs :: [Nat] · srclen (enc (dec xs)) = srclen xs Solution. We define P (xs) ≡ srclen (enc (dec xs)) = srclen xs and prove ∀xs :: [Nat] · P (xs) by strong structural induction on xs. Again, we have to show P (xs) for some arbitrary x :: [Nat] and may assume ∀ys ⊏ xs · P (ys). We proceed by a case analysis on xs: • Case xs ≡ []: srclen (enc (dec [])) = srclen (enc []) (D1) = srclen [] (E1) • Case xs ≡ [n], for some n :: Nat: srclen (enc (dec [n])) = srclen (enc []) (D2) = srclen [] (E1) = 0 (S1) = srclen [n] (S2) 5 • Case: xs ≡ (n:v:ys), for some n, v :: Nat and ys :: [Nat]: We perform a further case distinction on the value of n: – Subcase n = 0: srclen (enc (0:v:ys)) = srclen (enc (rep 0 v ++ dec ys)) (D3) = srclen (enc ([] ++ dec ys)) (R1) = srclen (enc (dec ys)) (++) = srclen ys (IH) = 0 + srclen ys (arith) = srclen (0:v:ys) (S3) – Subcase n > 0: srclen (enc (dec (n:v:ys))) = srclen (enc (rep n v ++ dec ys)) (D3) = srclen (enc ((v:(rep (n-1) v)) ++ dec ys)) (R2) = srclen (enc (v:(rep (n-1) v ++ dec ys))) (L1) = srclen (aux (rep (n-1) v ++ dec ys) 1 v []) (E2) = srclen (aux (dec ys) (1+(n-1)) v []) (L2) = srclen (aux (dec ys) n v []) (arith) = srclen ys + n + srclen [] (Task 2.1) = srclen ys + n + 0 (S1) = n + srclen ys (arith) = srclen (n:v:ys) (S3) Note that we can apply the result of Task 2.1 because length [] % 2 = 0. 6","libVersion":"0.5.0","langs":""}