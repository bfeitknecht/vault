{"path":"sem4/FMFP/PV/exams/-30finals/FMFP-FS24.pdf","text":"Formal Methods and Functional Programming Final Exam, 2024 August 7, 2024, 14:00 – 17:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 32 pages; the back page of this booklet is page 32. 2. After the exam begins: check that your exam papers are complete (7 assignments and 2 pages of background material for the FM part). 3. You may complete the assignments in any order. We recommend spending roughly half of your time on each of the two parts of the exam. 4. Only write on the exam paper and extra paper sheets which are given by the assistants. Do not take any of this paper out of the exam: submit it all. Write your first and last name and your student number on every sheet of paper that you write on. 5. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 6. For the FP part of the exam, you may use any functions from the Haskell Prelude in your solutions (without giving their definitions), unless specified otherwise. You also may use any function from one subproblem to solve the subsequent subproblems, even if you have not provided a definition for the function itself. 7. Write clearly in the sense of logic, language, and readability. Label all rule applications in your derivation trees. The clarity of your arguments and explanations affects your grade. 8. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 ∑ Max 14 40 20 31 34 19 22 180 Points Formal Methods and Functional Programming, Final Exam, 2024 2 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2024 3 Assignment 1: Typing (14 Points) Task 1.A (9 Points) Recall the proof rules for the Mini-Haskell type system: Var . . . , x : τ, . . . ⊢ x :: τ Γ, x : σ ⊢ t :: τ Abs Γ ⊢ λx. t :: σ → τ Γ ⊢ t1 :: σ → τ Γ ⊢ t2 :: σ App Γ ⊢ t1 t2 :: τ Int Γ ⊢ n :: Int True Γ ⊢ True :: Bool False Γ ⊢ False :: Bool Γ ⊢ t :: Int iszero Γ ⊢ iszero t :: Bool Γ ⊢ t1 :: Int Γ ⊢ t2 :: Int BinOp Γ ⊢ (t1 op t2) :: Int for op ∈ {+, ∗} Γ ⊢ t0 :: Bool Γ ⊢ t1 :: τ Γ ⊢ t2 :: τ if Γ ⊢ if t0 then t1 else t2 :: τ Γ ⊢ t1 :: τ1 Γ ⊢ t2 :: τ2 Tuple Γ ⊢ (t1, t2) :: (τ1, τ2) Γ ⊢ t :: (τ1, τ2) fst Γ ⊢ fst t :: τ1 Γ ⊢ t :: (τ1, τ2) snd Γ ⊢ snd t :: τ2 Prove that the expression λx. λy. λz. if z then x y z + y z else 42 has type ((Bool → Int) → Bool → Int) → (Bool → Int) → Bool → Int. Label every step of the proof with the name of the rule used. Assignment 1 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2024 4 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2024 5 Task 1.B (5 Points) Are the following statements True or False? You get +1 point for each correct answer and −1 point for each incorrect answer. (The total points for this subtask cannot be negative.) True False 1. The Mini-Haskell term λx. x x is typable. 2. The term λx. (fst x) + 1 has the most general type (Int, Int) → Int. 3. The Mini-Haskell term 40+2 has type Int. 4. The Haskell term 40+2 has type Int. 5. There exists no Mini-Haskell term with type a → a → a. Formal Methods and Functional Programming, Final Exam, 2024 6 Assignment 2: Axiomatic Semantics (40 Points) In this task, we extend IMP with the flip statement that non-deterministically stores either 0 or 1 in the variable x: x ← flip To reason about the new statement, we extend the axiomatic semantics presented in the lectures with the rule FlipAx: (FlipAx) { P[x ↦→ 0] ∧ P[x ↦→ 1] } x ← flip { P } With this new statement, we write the following non-deterministic program s that computes 2 N +1 − 1 in a rather inefficient way, where N is the original value stored in variable n: a := 0 ; b := 1 ; while n # 0 do a := a ∗ 2 ; b := b ∗ 2 ; y ← flip ; a := a + y ; b := b + 1 − y ; n := n − 1 ; end The behavior of s is specified by the triple { n = N ∧ 0 ≤ N } s { a + b = 2 N +1 − 1 } . Task 2.A (6 Points) Provide a loop invariant that can be used to prove the given triple. Task 2.B (6 Points) Provide a loop variant that can be used to prove the termination of the only loop in the program. Is the invariant provided in task 2.A strong enough to prove total correctness for this program? If not, how could the invariant be strengthened to achieve that goal? Formal Methods and Functional Programming, Final Exam, 2024 7 Task 2.C (23 Points) With the invariant provided in task 2.A, provide a proof outline that shows the partial correctness of s. Include all necessary annotations in the outline and provide justifications for applications of the consequence rule. {n = N ∧ 0 ≤ N } a := 0 ; b := 1 ; while n # 0 do a := a ∗ 2 ; b := b ∗ 2 ; y ← flip ; a := a + y ; b := b + 1 − y ; n := n − 1 ; end {a + b = 2 N +1 − 1} Formal Methods and Functional Programming, Final Exam, 2024 8 Task 2.D (5 Points) The FlipAx rule repeats the assertion that occurs in the postcondition of x ← flip twice in the precondition, once for when x is assigned the value 0 and once for when it is assigned 1. In a vain attempt to avoid this duplication, we introduce the following alternative rule: (FlipAltAx) { P } x ← flip { P ∧ (x = 0 ∨ x = 1) } Unfortunately, this rule is unsound. Demonstrate this by deriving a triple that contradicts the semantics of the language. Note that the small-step semantics of flip is given by the following two rules: (Flip0SOS) ⟨x ← flip, σ⟩ →1 σ[x ↦→ 0] (Flip1SOS) ⟨x ← flip, σ⟩ →1 σ[x ↦→ 1] Formal Methods and Functional Programming, Final Exam, 2024 9 Assignment 3: Logic (20 Points) Recall the following rules for natural deduction in intuitionistic first-order logic: Γ, A ⊢ A Ax Γ, A ⊢ B Γ ⊢ A → B →I Γ ⊢ A → B Γ ⊢ A Γ ⊢ B →E Γ ⊢ ⊥ Γ ⊢ A ⊥E Γ, A ⊢ ⊥ Γ ⊢ ¬A ¬I Γ ⊢ ¬A Γ ⊢ A Γ ⊢ B ¬E Γ ⊢ A Γ ⊢ B Γ ⊢ A ∧ B ∧I Γ ⊢ A ∧ B Γ ⊢ A ∧EL Γ ⊢ A ∧ B Γ ⊢ B ∧ER Γ ⊢ A Γ ⊢ A ∨ B ∨IL Γ ⊢ B Γ ⊢ A ∨ B ∨IR Γ ⊢ A ∨ B Γ, A ⊢ C Γ, B ⊢ C Γ ⊢ C ∨E Γ ⊢ A Γ ⊢ ∀x. A ∀I∗ Γ ⊢ ∀x. A Γ ⊢ A[x ↦→ t] ∀E Γ ⊢ A[x ↦→ t] Γ ⊢ ∃x. A ∃I Γ ⊢ ∃x. A Γ, A ⊢ B Γ ⊢ B ∃E ∗∗ Side conditions: (∗) x is not free in any formula in Γ, (∗∗) x is neither free in B nor in any formula in Γ. We extend our natural deduction rules for set theory. Namely, we add the following rules: Γ ⊢ X ⊆ Y Γ ⊢ a ∈ X Γ, a ∈ Y ⊢ A Γ ⊢ A ⊆ E Γ, a ∈ X ⊢ a ∈ Y Γ ⊢ X ⊆ Y ⊆ I∗∗∗ Side conditions: (∗ ∗ ∗) a is not free in any formula in Γ Task 3.A (7 Points) Using the above rules prove that (∀a.(a ∈ X → a ∈ Y )) → X ⊆ Y Assignment 3 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2024 10 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2024 11 Task 3.B (13 Points) Using the above rules prove that (X ⊆ Y ∧ Y ⊆ Z) → ∀a.(a ∈ X → a ∈ Z) You may assume that a is not free in X, Y , and Z. Formal Methods and Functional Programming, Final Exam, 2024 12 Assignment 4: Big-Step Semantics (31 Points) In this task, we extend IMP with a new construct called a case loop, which has two loop conditions and two corresponding loop bodies: while b1 | b2 do s1 | s2 end where b1, and b2 are boolean expressions, and s1, and s2 are statements. Conceptually, a case loop executes the first statement for which the corresponding condition is true and iterates until no condition is true. The big-step semantics for this new statement is given by the following rules: ⟨s1, σ⟩ → σ′ ⟨while b1 | b2 do s1 | s2 end, σ′⟩ → σ′′ (CL1N S) ⟨while b1 | b2 do s1 | s2 end, σ⟩ → σ′′ if B[[b1]]σ = tt ⟨s2, σ⟩ → σ′ ⟨while b1 | b2 do s1 | s2 end, σ′⟩ → σ′′ (CL2N S) ⟨while b1 | b2 do s1 | s2 end, σ⟩ → σ′′ if B[[b1]]σ = ff B[[b2]]σ = tt (CLFN S) ⟨while b1 | b2 do s1 | s2 end, σ⟩ → σ if B[[b1]]σ = ff B[[b2]]σ = ff Task 4.A (7 Points) Show that this new construct is not semantically equivalent to the statement while b1 do s1 end; while b2 do s2 end by providing concrete values for b1, b2, s1, s2 and states σ, σ′, and σ′′ with σ′ ̸= σ′′ so that ⟨while b1 | b2 do s1 | s2 end, σ⟩ → σ′ and ⟨while b1 do s1 end; while b2 do end, σ⟩ → σ′′. Expression b1: Expression b2: Statement s1: Statement s2: State σ: State σ′: State σ′′: Formal Methods and Functional Programming, Final Exam, 2024 13 Task 4.B (24 Points) Prove that for all b1, b2, s1, s2, σ and σ′′, if ⊢ ⟨while b1 | b2 do s1 | s2 end, σ⟩ → σ′′ then ⊢ ⟨while (b1 or b2) do (if b1 then s1 else s2) end, σ⟩ → σ′′ For the sake of shorter notation, consider using the following shorthands: caseloop ≡ while b1 | b2 do s1 | s2 end ifloop ≡ while (b1 or b2) do (if b1 then s1 else s2) end Formal Methods and Functional Programming, Final Exam, 2024 14 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2024 15 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2024 16 Assignment 5: Programming (34 Points) A Horn clause is a disjunction of propositional variables of the form ¬a ∨ ¬b ∨ . . . ∨ ¬p ∨ q such that at most one variable in the disjunction appears in positive form (i.e., not negated) and all other variables are negated. This form makes Horn clauses particularly useful for logic programming and formal methods. In this exercise, we represent Horn clauses in Haskell using the following recursive data type: d a t a Horn = Neg S t r i n g Horn | N i l | Pos S t r i n g d e r i v i n g Eq The following are examples of Horn clauses and one of their possible representations in Haskell using our data type: Horn clause In Haskell as Horn ¬p ∨ ¬r ∨ ¬q Neg \"p\" (Neg \"r\" (Neg \"q\" Nil)) ¬s ∨ q Neg \"s\" (Pos \"q\") s Pos \"s\" When a Horn clause is a disjunction of only one variable and that variable is non-negated (e.g., the entire Horn clause is just q or just s), we say that this clause is a fact. Hint. In this exercise, you may want to use the following functions from the Prelude: f i l t e r : : ( a −> Bool ) −> [ a ] −> [ a ] map : : ( a −> b ) −> [ a ] −> [ b ] elem : : a −> [ a ] −> Bool notElem : : a −> [ a ] −> Bool −− notElem a x = n o t ( elem a x ) concat : : [ [ a ] ] −> [ a ] Task 5.A (3 Points) Fill in the gaps to implement onlyPos, which returns True when a Horn clause is a fact (i.e., consists of only a positive variable), and False otherwise. Sample Output. > o n l y P o s ( Neg ” a ” ( Pos ”b” ) ) F a l s e > o n l y P o s ( Pos ”b” ) True Formal Methods and Functional Programming, Final Exam, 2024 17 1 o n l y P o s : : Horn −> Bool 2 o n l y P o s = 3 o n l y P o s = Formal Methods and Functional Programming, Final Exam, 2024 18 Task 5.B (5 Points) Fill in the gaps to implement removeNegations, which produces a Horn clause where all the negated occurrences of a given variable have been removed. If there are no negated occurrences of the variable, the function returns the input clause unchanged. Sample Output. > r e m o v e N e g a t i o n s ”q” ( Neg ”p” ( Neg ”q” ( Pos ” r ” ) ) ) ( Neg ”p” ( Pos ” r ” ) ) > r e m o v e N e g a t i o n s ” r ” ( Neg ”p” ( Neg ”q” ( Pos ” r ” ) ) ) ( Neg ”p” ( Neg ”q” ( Pos ” r ” ) ) ) 1 r e m o v e N e g a t i o n s : : S t r i n g −> Horn −> Horn 2 r e m o v e N e g a t i o n s 3 | = 4 | = 5 r e m o v e N e g a t i o n s = 6 r e m o v e N e g a t i o n s = Formal Methods and Functional Programming, Final Exam, 2024 19 Task 5.C (8 Points) Given a Horn clause ϕ, we define vars(ϕ) to be the set of all variables appearing in the clause. Given a set of Horn clauses Φ = {ϕ1, . . . , ϕn}, we can also collect the variables appearing in any of the clauses, i.e., vars({ϕ1, . . . , ϕn}) = ⋃ i vars(ϕi). Fill in the gaps to implement this function in Haskell, returning a list without duplicate elements. Sample Output. > l e t h1 = Neg ”p” ( Neg ” r ” ( Neg ”q” N i l ) ) h2 = Neg ” s ” ( Pos ”q” ) h3 = Pos ”q” i n v a r s [ h1 , h2 , h3 ] [ ”p” , ” r ” , ”q” , ” s ” ] 1 v a r s : : [ Horn ] −> [ S t r i n g ] 2 v a r s hs = removeDups ( v a r s W i t h D u p s x ) 3 4 where 5 v a r s W i t h D u p s [ ] = [ ] 6 v a r s W i t h D u p s ( h : hs ) = 7 8 removeDups [ ] = [ ] 9 removeDups ( x : x s ) = 10 11 varsOfOne : : Horn −> [ S t r i n g ] 12 varsOfOne ( Neg x h ) = 13 varsOfOne ( Pos x ) = 14 varsOfOne N i l = Formal Methods and Functional Programming, Final Exam, 2024 20 HORNSAT. A valuation of a set of Horn clauses Φ is a mapping from its variables to Booleans ‘true’ or ‘false’. The problem of Horn satisfiability (HORNSAT) asks whether a given finite set of Horn clauses Φ = {ϕ1, . . . , ϕn} can all be satisfied simultaneously, i.e., whether there is some valuation of Φ that can make all the Horn clauses in the set true. For example, the set of Horn clauses Φ1 = {¬c ∨ ¬a, ¬c ∨ ¬b, c} is satisfiable by setting a and b to false and c to true. On the other hand, the set Φ2 = {¬c ∨ ¬a, ¬c ∨ a, c} is not satisfiable since the third clause requires c = true, but then satisfying the first two clauses would require both a = false and a = true, a contradiction. The HORNSAT algorithm. We now describe an algorithm for HORNSAT: 0. The initial state is the given set of Horn clauses. 1. If (a) you can find any fact clause (i.e., consisting of only a positive variable), pick it and then (b) remove that fact clause from the set, (c) remove all negated occurrences of that variable from all clauses. 2. Repeat step 1 until there are no more fact clauses. 3. Finally, (a) if any clause in the set is empty (i.e., is Nil), the set is not satisfiable. (b) if no clause in the set is empty, the set is satisfiable. Formal Methods and Functional Programming, Final Exam, 2024 21 Task 5.D (10 Points) Using the functions onlyPos and removeNegations, fill in the gaps to implement step 1 as described above, performing all substeps (a) to (c) once. Perform these steps for exactly one clause; if there are several eligible fact clauses, arbitrarily choose one. Sample Output. > l e t h1 = Neg ”p” ( Neg ” r ” ( Neg ”q” N i l ) ) h2 = Neg ” s ” ( Pos ”q” ) h3 = Pos ”q” i n s t e p [ h1 , h2 , h3 ] [ Neg ”p” ( Neg ” r ” N i l ) , Neg ” s ” ( Pos ”q” ) ] 1 s t e p : : [ Horn ] −> [ Horn ] 2 s t e p hs = aux hs 3 where 4 aux [ ] = 5 aux = 6 aux = Formal Methods and Functional Programming, Final Exam, 2024 22 Task 5.E (4 Points) Given some value v and a function f that transforms the value into one of the same type, the fixpoint is the value v′ = f (f (f (. . . f (v) . . .))) obtained by repeatedly applying f until f does not change the value anymore, i.e., until f (v′) = v′. Fill in the gaps to implement a recursive function that finds fixpoints in Haskell: Sample Output. > l e t r e d u c e ( x : x s ) = x s r e d u c e [ ] = [ ] i n f i x p o i n t r e d u c e [ 1 , 2 , 3 ] [ ] 1 f i x p o i n t : : Eq a => ( a −> a ) −> a −> a 2 f i x p o i n t f x 3 | = 4 | otherwise = Formal Methods and Functional Programming, Final Exam, 2024 23 Task 5.F (4 Points) Using step and fixpoint, fill the gaps to implement the function implementing the full HORNSAT algorithm, performing steps 1 to 3 as described above. This function returns True when the given set is satisfiable, and False otherwise. Sample Output. > l e t h1 = P o s C l a u s e ”q” h2 = N e g C l a u s e ”q” ( P o s C l a u s e ” s ” ) i n c h e c k S a t [ h1 , h2 ] True > l e t h1 = P o s C l a u s e ”q” hx = N e g C l a u s e ”q” N i l i n c h e c k S a t [ h1 , hx ] F a l s e 1 c h e c k S a t : : [ Horn ] −> Bool 2 c h e c k S a t hs = 3 where 4 f i n a l S t a t e : : [ Horn ] 5 f i n a l S t a t e = Formal Methods and Functional Programming, Final Exam, 2024 24 Assignment 6: Linear Temporal Logic (19 Points) Consider the following transition system which models an order processing system. The labels at each state indicate which of the 5 atomic propositions I (Order has been initialized), P (Order has been paid), B (Order is being prepared for shipment), S (Order is shipped) and C (Order is cancelled) hold in the respective states. The system is initially in state s0 where an order has been initialized. If the user successfully completes the payment for the order, the system transitions to state s1. In state s1, if all items in the paid order are verified to be in stock, the system goes to state s2 to prepare the order for shipment. Once the order is prepared, it will be shipped in state s3. If the payment fails or any items are out of stock, the system goes to state s4 for order cancellation. s0 {I} s1 {P } s2 {P, B} s3 {P, S} s4 {C} Task 6.A (6 Points) Write down an LTL formula for each of the following properties. i) An order eventually stays cancelled or stays shipped. ii) After an order is cancelled, it can no longer be shipped. iii) An order starts as initialized and becomes shipped in 2 or 3 steps. Formal Methods and Functional Programming, Final Exam, 2024 25 Task 6.B (6 Points) For each of the following LTL formulas, state whether or not the formula defines a property that is valid in the given transition system. Justify your answer by either briefly explaining why it is valid or providing a counterexample if it is not. i) ♢(S ∨ C) ii) □(⃝S ⇒ P ) iii) □((I ∨ P ) U S) Task 6.C (7 Points) This question is independent of the transition system above. Decide for each of the two respective LTL formulas whether it is a safety property, a liveness property or a conjunction of a safety and a liveness property. Provide a brief proof showing why your choice is correct. i) □(♢(P ⇒ B)) ∧ ⃝(¬B) Formal Methods and Functional Programming, Final Exam, 2024 26 ii) ♢(□P ⇒ □B) Formal Methods and Functional Programming, Final Exam, 2024 27 Assignment 7: Induction (22 Points) Task 7.A (10 Points) Recall the following functions: length :: [ a ] -> Int length [] = 0 -- length .1 length ( x : xs ) = 1 + length xs -- length .2 (++) :: [ a ] -> [ a ] -> [ a ] (++) [] ys = ys -- (++).1 (++) ( x : xs ) ys = x : ( xs ++ ys ) -- (++).2 Using structural induction, show the following lemma: ∀xs :: [a]. ∀ys :: [a]. length (xs ++ ys) = length xs + length ys You can perform any number of arithmetic operations in one step using the ‘arith’ rule. Formal Methods and Functional Programming, Final Exam, 2024 28 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2024 29 Task 7.B (12 Points) Consider the following data structure that represents trees with values of some type a stored in their leaves: data Tree a = Leaf a | Node ( Tree a ) ( Tree a ) We consider the following functions: size :: Tree a -> Int size ( Leaf i ) = 1 -- size .1 size ( Node l r ) = size l + size r -- size .2 collect :: Tree a -> [ a ] collect ( Leaf i ) = [ i ] -- collect .1 collect ( Node l r ) = collect l ++ collect r -- collect .2 Using structural induction, show that ∀t :: Tree a. length (collect t) = size t. You can use the lemma proven in the previous subtask, referring to it as ‘lemma’, even if you did not solve the previous question. Formal Methods and Functional Programming, Final Exam, 2024 30 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2024 31 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ::= skip | x := e | s;s | if b then s else s end | while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). The free variables FV(e) of an arithmetic expression e are defined as FV(e1 op e2) = FV(e1) ∪ FV(e2) FV(n) = ∅ FV(x) = {x} The free variables FV(s) of a statement s are defined as FV(skip) = ∅ FV(x:=e) = {x} ∪ FV(e) FV(s1;s2) = FV(s1) ∪ FV(s2) FV(if b then s1 else s2 end) = FV(b) ∪ FV(s1) ∪ FV(s2) FV(while b do s end) = FV(b) ∪ FV(s) Big-Step Semantics (SkipN S) ⟨skip, σ⟩ → σ (AssN S) ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ → σ′ ⟨s2, σ′⟩ → σ′′ (SeqN S) ⟨s1;s2, σ⟩ → σ′′ ⟨s1, σ⟩ → σ′ (IfTN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = tt ⟨s2, σ⟩ → σ′ (IfFN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = ff ⟨s, σ⟩ → σ′ ⟨while b do s end, σ′⟩ → σ′′ (WhTN S) ⟨while b do s end, σ⟩ → σ′′ if B[[b]]σ = tt (WhFN S) ⟨while b do s end, σ⟩ → σ if B[[b]]σ = ff Formal Methods and Functional Programming, Final Exam, 2024 32 Small-Step Semantics (SkipSOS) ⟨skip, σ⟩ →1 σ (AssSOS) ⟨x := e, σ⟩ →1 σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ →1 σ′ (Seq1SOS) ⟨s1;s2, σ⟩ →1 ⟨s2, σ′⟩ ⟨s1, σ⟩ →1 ⟨s′ 1, σ′⟩ (Seq2SOS) ⟨s1;s2, σ⟩ →1 ⟨s′ 1;s2, σ′⟩ (IfTSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s1, σ⟩ if B[[b]]σ = tt (IfFSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s2, σ⟩ if B[[b]]σ = ff (WhileSOS) ⟨while b do s end, σ⟩ →1 ⟨if b then s; while b do s end else skip end, σ⟩ Axiomatic Semantics (Partial Correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ↦→ e] } x := e { P } { P } s1 { R } { R } s2 { Q } (SeqAx) { P } s1;s2 { Q } { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P ′ } s { Q′ } (ConsAx) { P } s { Q } if P ⊨ P′ and Q′ ⊨ Q Axiomatic Semantics (Total Correctness) Rules are as for partial correctness above, except for the following rule, which replaces WhAx: { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ⊨ 0 ≤ e where Z is a fresh logical variable (not used in P).","libVersion":"0.5.0","langs":""}