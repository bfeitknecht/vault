{"path":"sem4/DMDB/VRL/extra/slides/DMDB-s20-cloud-databases.pdf","text":"Data Modeling and Databases Spring Semester 2025 Cloud Databases Cloud Databases Gustavo Alonso Institute of Computing Platforms Department of Computer Science ETH Zürich 1 Key Value Store Cloud Databases 2 Key Value Store • Blocks, files, and objects are pure storage based on a somewhat similar notion, but each one of them adds more information and more functionality at the price of latency • Internet scale created a demand for something slightly different: • Access a chunk of data that does not need to be parsed (unlike objects) but can be of various sizes (unlike blocks) and needs to be system supported names that simplifies finding the data (unlike file systems) • Data can be dynamic with many entries being created and deleted (not good for blocks, files, or objects) • The solution is Key Value Stores (KVS) Cloud Databases 3 A database engine • Data stored following a schema • Tables, constraints • Smaller addressable unit: tuple • Data accessed and manipulated through SQL • Relational algebra, well defined execution model • Well defined operators, optimizer • ACID through transactions • Maintain data consistency • Ensures recoverability and persistence Cloud Databases 4 Schemas • Organize the data • Through normal forms, avoid redundancy and structure the data in clear units (tables) • Through constraints guarantee data integrity • Must be done before data can be used in a database • Dominant decomposition a problem (views help but only so much) Cloud Databases 5 SQL • Well defined interface • Efficient implementations • Declarative language • Only limited set of operators • Impedance mismatch between SQL and regular programming languages Cloud Databases 6 ACID • Strong guarantees • Work done by the database engine, not the application • Well defined properties and understandable concurrency • Expensive, both in throughput and response time • Does not scale that well Cloud Databases 7 Get rid of everything to get a Key Value Store • No schema • Just a key and blob attached to it, whose structure is unknown • No SQL • Get and Set as the only operations • No ACID • Eventual consistency • Potentially no transactions • Keep keys to identify the data and an index to find it = Key Value Store Cloud Databases 8 KVS architecture • Data stored as a Key-Value pair • Key: identifier used to locate and retrieve the data • Value: a binary object of arbitrary size • Data organized as a distributed hash table • Hash the key => get the location for the value • KV pairs stored in several (3, 5, 7, … copies) places for availability • Access is quorum based for consistency • Typically, eventual consistency • Actual storage uses already reserved buckets of different sizes and objects are located in the corresponding buckets • Can be run in main memory for very fast access or with values in storage for large data items Cloud Databases 9 Key Value Stores • Schema: • Key + BLOB (or pointer to blob) • Index on key (hashing) • Deployment • Horizontal partitioning • Replication of partitions • Replication strategy • Quorums (simple majority) • Asynchronous replication across all copies (eventual consistency) Cloud Databases 10 KVS: Advantages • Very fast lookups (hashing) • Easy to scale to many machines (simply add more copies/machines) • Excellent match for the cloud’s elasticity • Can be implemented in main memory of machines (faster access) • Useful in many applications: • Lookup user profiles • Retrieve users web pages and info • Scalable and easy to get going (no schema) Cloud Databases 11 KVS: Disadvantages • No easy support for queries beyond point queries as data is treated as a BLOB • Ranges, joins • Queries on attributes (there are no attributes) • Depending on implementation, data can appear as being inconsistent • Application dependent correctness • Used for large scale deployments (worldwide) Cloud Databases 12 KVS: to keep in mind • As initially proposed (No-SQL movement), KVS and similar system had a major hidden problem: • Pushes complexity and responsibility to the application • That complexity will affect the development of applications • Some operations are very costly to implement • Range queries require to read all copies • Joins out of the question • Works well as cache or specialized system • Not a replacement for a full blown database Cloud Databases 13 KVS as caches • KVS are often used as main memory caches to avoid having to access cloud storage: • Higher throughput • Lower latency • Databases: store results of a query in a value, key is generated by hashing the query. When running queries, check first the KVS and answer form there if the query is stored • Web pages, pictures, adds, etc. • A very common use case for memcached Cloud Databases 14 Application KVS KVS KVS KVS Cloud Storage Data distribution in KVS ▪ Basic design of a KVS ➢ How should we maps hash(key) to machines? ➢ How should we manage different replicas? ➢ How should we answer queries given that we have replicas? ▪ Naïve strategy: ➢ 3 machines: (Hash mod 3) is the machine ID ➢ What if we remove one machine (M2)? we need to move all data from M2 to M0 and M1 ➢ What hash function should we use? ➢ (Hash mod 2)? key Hash Hash mod 3 \"john\" 163342856 2 2 \"bill\" 759463473 9 0 \"jane\" 500079912 4 1 \"steve\" 978717334 3 0 \"kate\" 342165799 5 2 key Hash Hash mod 3 \"john\" 163342856 2 2 \"kate\" 342165799 5 2 key Hash Hash mod 3 \"bill\" 759463473 9 0 \"steve\" 978717334 3 0 key Hash Hash mod 3 \"jane\" 50007 99124 1 Machine 0 Machine 1 Machine 2 15Cloud Databases Simple design and its problems ▪ Fundamental Questions: ➢ How should we maps hash(key) to machines? ➢ How should we manage different replicas? ➢ How should we answer queries given that we have replicas? ▪ Naïve strategy: ➢ 3 machines: (Hash mod 3) is the machine ID ▪ Problem? One machine fail, we need to move all data from M2 to M0 and M1 ▪ What hash function should we use? ▪ (Hash mod 2)? ▪ Rehashing Problem: A single machine failure can cause all data to be remapped to a different machine (in the worst case) key Hash Hash mod 3 Hash mod 2 \"john\" 163342856 2 2 0 \"bill\" 759463473 9 0 1 \"jane\" 500079912 4 1 0 \"steve\" 978717334 3 0 1 \"kate\" 342165799 5 2 1 All keys will change machine if we use Hash mod 3 then Hash mod 2 16Cloud Databases Consistent Hashing ▪ Idea: Horizontal partition the data with hashing ▪ Each machine deals with the data points in the clockwise direction, before the next machine. key Hash \"john\" 1633428562 \"bill\" 7594634739 \"jane\" 5000799124 \"steve\" 9787173343 \"kate\" 3421657995 John Bill Steve Kate Jane A B C 17Cloud Databases Removing nodes ▪ When machine A leaves the cluster ➢ B takes change of everything between A->C (A’s old responsibility) ➢ C’s responsibility does not change ▪ If there are K data points and n machines, on average, a single machine failure triggers K/n data redistribution. key Hash \"john\" 1633428562 \"bill\" 7594634739 \"jane\" 5000799124 \"steve\" 9787173343 \"kate\" 3421657995 John Bill Steve Kate Jane A B C 18Cloud Databases Adding nodes ▪ When machine D joins the cluster ➢ D takes charge of D->C ➢ A takes charge of A->D ➢ B and C’s responsibility does not change ▪ Potential problem? ➢ Load balancing is not good (A an D, on average, has 2x less data than C in this example) key Hash \"john\" 1633428562 \"bill\" 7594634739 \"jane\" 5000799124 \"steve\" 9787173343 \"kate\" 3421657995 John Bill Steve Kate Jane A B C D 19Cloud Databases Load balancing through finer partitioning ▪ Node A (physical node) becomes 10 “virtual nodes”: A0… A9 ▪ B0…B9, C0…C9 ▪ Then do the same exercise as if there were 30 “machines” John Bill Steve Kate Jane A B C D 20Cloud Databases Dealing with failures ▪ What if a node fails? (instead of join/leave which allows the time for data redistribution) ▪ We need to replicate data (store multiple copies) on 𝛾 machines. ➢ The example on the right, 𝛾 = 3 ➢ The next r - 1 nodes in clockwise direction store the same data. ▪ How can we guarantee consistency among replicas? ➢ Not trivial. ➢ Thought experiment: • T1: write master copy of object X on D • System: replicate to other nodes every 5 min • D crashes before T1's change on D being replicated • T2: read object X ➢ Problem? • T2 has access to a staled object. 21Cloud Databases Dealing with replication ▪ Using quorums ▪ Let: ➢ N: The number of replicas for the data. ➢ R: The number of machines contacted in read operations ➢ W: The number of machines that have to be blocked in write operations ▪ Make sure that R + W > N, Example: ➢ W = N, R = 1 ➢ W = 1, R = N ▪ Guarantee: Always being able to read a latest version. 22Cloud Databases Many variations • Cloud computing has given raise to many variations on these themes • Most serious system converging back towards a full transactional engine with some form of schema and SQL support • Specialized systems in use as accelerators (memcached) or concrete application stages (profile look up) • Lesson to learn = the concepts change relatively little, the use cases and the deployments can change substantially affecting the way given solutions are used and perceived. Cloud Databases 23 Cloud Native Databases Cloud Databases 24 The problem with traditional database engines in the cloud • In the cloud, the separation of storage and compute causes overhead if one is not careful • A traditional database generates too much traffic in terms of I/O, especially if it is mirrored for availability Cloud Databases 25 Amazon Aurora: Design Considerations for High Throughput Cloud-Native Relational Databases, SIGMOD 2017 Amazon Aurora • A modification of MySQL to make it work in the cloud: • Separate storage and cache management from transaction processing • Primary copy, asynchronous replication • 6 copies of the data in 3 different availability zones, continuous back- up on S3 • Updates with quorum (4 out of 6) • Primary copy and up to 15 read- only replicas (20 ms lag) Cloud Databases 26 https://aws.amazon.com/rds/auroraSnowflake • A data warehouse specialized for analytical queries developed entirely on the cloud (cloud native) • Separates compute (nodes running VMs with a local disk) from storage (Amazon’s S3) Cloud Databases 27 Documentation: https://docs.snowflake.com/en/user-guide-intro.html Paper: https://dl.acm.org/doi/10.1145/2882903.2903741 Amazon’s S3 • Simple Storage Service (S3) is an object storage service in the cloud that acts as the persistent storage that is available to applications • Unlike conventional local disks or distributed file system! • Object store (key-value) [object = file] • HTTP(S) PUT/GET/DELETE interface • No update in place (objects must be written in full) • Can read parts (ranges) of an object instead of the whole object • High CPU overhead (because of HTTP) • I/O is extra expensive (network bandwidth, latency, interface) Cloud Databases 28 Something familiar • A virtual warehouse is a collection of worker nodes (EC2 instances in Amazon) • Each worker node has a cache in its local disk where it stores the objects (table files or parts thereof) accessed before • The cache uses a simple LRU replacement policy Cloud Databases 29 Micro-partitions • Micro-partitions are Snowflake’s name for extents • What is interesting is how they are organized to facilitate query processing • Size ranges between 50 and 500 MB (before compression, the data is always compressed when in S3) • Each micro partition has metadata describing what is inside • The metadata can be read without reading the whole micro-partition • The metadata is used to read just the part of the micro-partition that is relevant • Data in the micro-partition is stored in columnar form (by columns not by rows) Cloud Databases 30Cloud Databases 31https://docs.snowflake.com/en/user-guide/tables-clustering-micropartitions.html A not so uncommon design • Snowflake is combining many tricks used before in different contexts: • Horizontal partitioning of the tables (by row): allows to read the table in parallel, to put different parts of the table in different processing nodes, and – if organized accordingly- allows to read only the needed tuples instead of all the table • Columnar format (storage by column): the preferred storage format for analytics, improves cache locality, enables vectorized processing, facilitates projection operations (SQL), allows to process only the part of the table that is relevant • Storage level processing to read only the part of the file that is needed (helped by the micro-partitions and the columnar format) Cloud Databases 32 Pruning based on metadata • The header for a micro-partition contains information about the data. SELECT * FROM T WHERE age > 45 • If header contains the min and max age in the data, we can decide we do not need that micro- partition simply by looking at the header Cloud Databases 33 Pruning • Snowflake does not use indexes • Indexes require a lot of space • Indexes induce random accesses (very bad for slow storage like S3) • Indexes need to be maintained and selected correctly • Instead, it uses the metadata to store information that allows to filter micro-partitions (min/max, #distinct values,#nulls, bloom filters, etc.) • The metadata is much smaller than an index and easier to load than a whole index • By splitting table in potentially many micro-partitions, it can significantly optimize the data movement to and from storage Cloud Databases 34 Writing to disk • S3 does not support update in place, a file is replaced in its entirety (immutable) • Snowflake uses this feature to implement snapshots of the data (like shadow paging): • When a micro-partition is modified, a new file is written • The old micro-partition can be kept or discarded • Allows time travel (read the data in the past up to 90 days) and provides fault-tolerance (the old data can be recovered from the old micro-partitions) Cloud Databases 35 An interesting future Cloud Databases 36 The IT industry • The IT industry is, above all, an industry: • Trends and developments driven by demand and market • For hardware, there is a high investment cost to new developments • New processors pay off only after they reach a high volume of sales • Hardware evolves, software evolves much slower: • Radical solutions are difficult because the entire stack needs to be created • Window of opportunity when new applications show up (the killer app) • Example: the parallel computing craze of the late 80’s • Currently undergoing profound changes for economic, scientific, and political reasons Cloud Databases 37 A theme since a couple of decades • 2011 Report • Exponential growth for several decades • Exponential growth no longer possible • Switch to multicore and parallelism • Energy consumption becomes an issue • Multicore introduces parallelism that we do not know how to exploit well • Situation will not change in near future • Alternative is specialization • Either somebody comes up with a new great invention or there is a problem Cloud Databases 38 General purpose computing Slow improvements lead to specialization Cloud Databases 39 Economic factors • It is not only Moore’s Law • The increase in unit cost for production was offset with the increase in demand • Smaller sizes are more complex and difficult to produce => more expensive => not longer economical • But the demand is still there, so what to do? Cloud Databases 40 Why is a CPU general purpose? CPUs designed for a wide range of tasks and use cases. Very different architecture than GPUs • CPU is low latency (very fast) but low throughput (parallelism) • GPUs are high latency (slow) but high throughput (parallelism) • CPUs designed for running several processes (a few) in a time-shared manner = context switching, isolation, state keeping, memory virtualization, etc. Cloud Databases 41 What to expect for databases • Higher degree of specialization at all levels of the architecture • CPU less relevant with heavy processing moving to accelerators (TPUs, DPUs, GOUs, etc.) • Heterogeneous computing • Widening of use cases (e.g., vector search = ANNS) • We have it covered in later courses: • Big Data • Cloud Computing Architecture • Data Management Systems Cloud Databases 42","libVersion":"0.5.0","langs":""}