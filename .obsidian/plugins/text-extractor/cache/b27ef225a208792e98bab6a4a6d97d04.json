{"path":"sem2/PProg/VRL/extra/kuhn/PProg-w09-kuhn.pdf","text":"Parallel Programming Session 9 Spring 2024, Sarah Kuhn Schedule Post-Discussion Assignment 8 : relations, orders & JMM Theory Recap Peterson lock, N-Thread locks, CAS,TAS,TATAS, Semaphores Exam Task Pre-Discussion Assignment 9 Kahoot VIS Teaching AwardsPost-Discussion Ex.8 Program Order, Transitive ClosureProgram Order, Transitive ClosureRelations and Code • When we execute code, ”actions” happen, i.e., a variable gets read or written • We can define relations for these actions, such as “is executed before” 7 Program Order, Transitive ClosureProgram Order • Actions in different threads are not in program order! • But ordering was good for proofs! • Want to allow the compiler / hardware to reorder sometimes for performance. 9 Program Order • Actions in different threads are not in program order! • But ordering was good for proofs! • Want to allow the compiler / hardware to reorder sometimes for performance. • Solution: Let compiler reorder whenever it is not “observable” – need to define a subset of special actions which are visible across threads 10 Synchronization ActionsSynchronization Actions 2 SA’s Synchronization Actions • For this lecture, the most important synchronization actions are • Start/End of a thread 13 Synchronization Actions • For this lecture, the most important synchronization actions are • Start/End of a thread • Read/Write of a volatile or atomic variable 14 Synchronization Actions • For this lecture, the most important synchronization actions are • Start/End of a thread • Read/Write of a volatile or atomic variable • Acquire / release of a monitor 15 Happens Before • If we combine (the transitive closure of) program order and “synchronizes with” we get the “happens before” order 17 Happens Before • If we combine (the transitive closure of) program order and “synchronizes with” we get the “happens before” order • Any output/result we see in a Java Program must be consistent with this happens before order 18 Happens Before Why ? To show if the given output is even valid/legal/possible Happens BeforeHappens BeforeHappens BeforeHappens BeforeConclusion of JMM We will do one last example to be safe. Since T2 keeps reading x, at some point, it will read AFTER T1 wrote x=1. Then we have: Java Memory Model Takeaways • If a (primitive) variable is volatile it behaves like an atomic register 27 Java Memory Model Takeaways • If a (primitive) variable is volatile it behaves like an atomic register • Can sometimes gain performance (and maintain correctness) by not marking everything volatile. 28 Java Memory Model Takeaways • If a (primitive) variable is volatile it behaves like an atomic register • Can sometimes gain performance (and maintain correctness) by not marking everything volatile. • But you are using Java, is performance really your focus? J - if in doubt declare shared variables as volatile 29 Theory Recap Yeay, the fun and interesting stuff starts imo :) Race Conditions • Race condition occurs if multiple accesses can happen concurrently and at least one access is a write 31 Essential Race Conditions • Race condition occurs if multiple accesses can happen concurrently and at least one access is a write • Thread 1 accesses x, v, y • Thread 2 accesses y, w, z 32 Race Conditions • Race condition occurs if multiple accesses can happen concurrently and at least one access is a write • Thread 1 accesses x, v, y • Thread 2 accesses y, w, z • Both write to y! Result depends on interleaving! 33 NO GUARANTEE ON WHAT WE WILL SEE FOR Y Race Conditions • Race condition occurs if multiple accesses can happen concurrently and at least one access is a write • Thread 1 accesses x, v, z • Thread 2 accesses y, w 34 Essential Race condition possible ? Race Conditions • Race condition occurs if multiple accesses can happen concurrently and at least one access is a write • Thread 1 accesses x, v, z • Thread 2 accesses y, w • No race condition, no bad interleaving possible 35 Essential Avoid race conditiond We can avoid race conditions when we synchronize our code correctly Locks Look at different lock implementations Via Atomic Register :: Peterson, Bakery, Filter Via atomic operations :: CAS, TAS, TATAS, BackOff N threads in CS:: Semaphores Look at different lock implementations Via Atomic Register :: Peterson, Bakery, Filter Atomic registers • Atomic registers => support read and write, nothing else 39 Atomic registers • Atomic registers => support read and write, nothing else • Usually we think of reads / writes as atomic, i.e., if we write a line such as x=1 in pseudocode we assume it happens atomically and is globally visible. 40 Atomic registers • Atomic registers => support read and write, nothing else • Usually we think of reads / writes as atomic, i.e., if we write a line such as x=1 in pseudocode we assume it happens atomically and is globally visible. • This is not true in Java (unless x is e.g., AtomicInteger) 41 Atomic registers • Atomic registers => support read and write, nothing else • Usually we think of reads / writes as atomic, i.e., if we write a line such as x=1 in pseudocode we assume it happens atomically and is globally visible. • This is not true in Java (unless x is e.g., AtomicInteger) • What do you think with volatile ? 42 volatile counter =0; counter ++; Atomic registers • Atomic registers => support read and write, nothing else • Usually we think of reads / writes as atomic, i.e., if we write a line such as x=1 in pseudocode we assume it happens atomically and is globally visible. • This is not true in Java (unless x is e.g., AtomicInteger) • Volatile makes it globally visible (but not atomic in all cases) 43 Confusion potential Atomic Register == “they register you intuitively think of” Confusion potential Atomic Register == “they register you intuitively think of” Just registers that you can read/write Confusion potential Atomic Register == “they register you intuitively think of” Just registers that you can read/write Read/write on the register happens atomic Confusion potential Atomic Register == “they register you intuitively think of” Just registers that you can read/write Read/write on the register happens atomic But doesn’t mean compound operations involving these registers are atomic, feg. Counter++ Atomic registers • An operation such as x++ (with x being an atomic register) is NOT atomic! • Three steps: v = read(x), increment v, write(x, v) 48 Atomic operations • An atomic action is one that effectively happens at once i.e. this action cannot stop in the middle nor be interleaved 49 Atomic operations • An atomic action is one that effectively happens at once i.e. this action cannot stop in the middle nor be interleaved • It either happens completely, or it doesn’t happen at all. • No side effects of an atomic action are visible until the action is complete 50 Hardware support for atomic operations Different atomic operations have been proposed, unclear which is best • Test-And-Set (TAS) • Compare-And-Swap (CAS) • Load Linked / Store Conditional • http://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html 51 Look at different lock implementations Via Atomic Register :: Peterson, Bakery, Filter Via atomic operations :: CAS, TAS, TATAS, BackOff Peterson Lock Set our flag : indicate that we are interested in entering the CS Peterson Lock Set our flag : indicate that we are interested in entering the CS Indicate that the other thread can go first. (I’m the victim) (first thread to execute this statement will go first) Peterson Lock Set our flag : indicate that we are interested in entering the CS Indicate that the other thread can go first. (I’m the victim) (first thread to execute this statement will go first) Wait until the other thread no longer interested or I can go first. Peterson Lock Set our flag : indicate that we are interested in entering the CS Indicate that the other thread can go first. (I’m the victim) (first thread to execute this statement will go first) Wait until the other thread no longer interested or I can go first. CS Peterson Lock Set our flag : indicate that we are interested in entering the CS Indicate that the other thread can go first. (I’m the victim) (first thread to execute this statement will go first) Wait until the other thread no longer interested or I can go first. CS Then indicate that we are not interested anymore Peterson Lock Set our flag : indicate that we are interested in entering the CS Indicate that the other thread can go first. (I’m the victim) (first thread to execute this statement will go first) Wait until the other thread no longer interested or I can go first. CS Then indicate that we are not interested anymore What’s is key that these lock implements even could work ? Peterson Lock Is the Peterson Lock a correct lock ? Peterson Lock What does the lock need to fulfill in order to be correct? Peterson Lock What does the lock need to fulfill in order to be correct? • Mutual exclusion • Deadlock freedom • Starvation freedom Peterson Lock What does the lock need to fulfill in order to be correct? • Mutual exclusion • Deadlock freedom • Starvation freedom Just because the lock is correct, does it mean we implemented the CS correctly ? Peterson Lock What does the lock need to fulfill in order to be correct? • Mutual exclusion • Deadlock freedom • Starvation freedom Just because the lock is correct, does it mean we implemented the CS correctly ? No, we as programmer can still mess up. So please use the locks correctly Peterson Lock Let’s prove correctness of the Peterson Lock : • Mutual exclusion • Deadlock freedom • Starvation freedom Peterson Lock Let’s prove correctness of the Peterson Lock : • Starvation freedom Proof assumes that: Threads CANNOT \"die\" here. As soon as they start the \"locking\". Make it out of CS What would it mean here that one thread is being starved by the other? What would it mean here that one thread is being starved by the other? It would mean that one thread is stuck here: What would it mean here that one thread is being starved by the other? It would mean that one thread is stuck here: Now let us exhaustively show that this cannot happen. Possibilities of what Q is doing while P spins: • Stuck in non-critical section. Possibilities of what Q is doing while P spins: • Stuck in non-critical section • Then, flag[Q]=false. Hence, P cannot spin. Contradiction. Possibilities of what Q is doing while P spins: • Stuck in non-critical section • Then, flag[Q]=false. Hence, P cannot spin. Contradiction. Possibilities of what Q is doing while P spins: • Stuck in while-loop itself • Stuck in non-critical section • Then, flag[Q]=false. Hence, P cannot spin. Contradiction. Possibilities of what Q is doing while P spins: • Stuck in while-loop itself • Victim=p=q cannot hold at the same time. Contradiction. • Stuck in non-critical section • Then, flag[Q]=false. Hence, P cannot spin. Contradiction. Possibilities of what Q is doing while P spins: • Stuck in while-loop itself • Victim=p=q cannot hold at the same time. Contradiction. • Repeatedly entering and leaving CS • Stuck in non-critical section • Then, flag[Q]=false. Hence, P cannot spin. Contradiction. Possibilities of what Q is doing while P spins: • Stuck in while-loop itself • Victim=p=q cannot hold at the same time. Contradiction. • Repeatedly entering and leaving CS • sets victim to Q when entering. Now, only P can enter. Contradiction. Peterson Lock Peterson lock is a correct lock. Okay, so does anyone see a problem with this lock ? What is a disadvantage ? N -Threads Lock In the course we have 2 implementations: filter lock bakery lock N -Threads Lock In the course we have 2 implementations: filter lock bakery lock !!! We assume for the implementation we only work with atomic registers. !!! Filter lock Mutex for n threads Define n-1 level a thread has to pass to get into CS Filter lock Mutex for n threads Define n-1 level a thread has to pass to get into CS Similar to Peterson just for N-threads Filter lock Mutex for n threads Define n-1 level a thread has to pass to get into CS Similar to Peterson just for N-threads flag array -> level array: level[T] = x means highest level Thread T wants to enter is x. Filter lock Mutex for n threads Define n-1 level a thread has to pass to get into CS Similar to Peterson just for N-threads flag array -> level array: level[T] = x means highest level Thread T wants to enter is x. victim array -> victim [k] = y, means y was the last thread trying to enter this level. Filter lock Mutex for n threads Define n-1 level a thread has to pass to get into CS Similar to Peterson just for N-threads flag array -> level array: level[T] = x means highest level Thread T wants to enter is x. victim array -> victim [k] = y means y was the last thread trying to enter this level. If thread is at level k, he passd k-1,….. etc. Filter lock When can a thread enter the next level ? When another thread wants to enter its level. or No more threads are in front of him. 90 Critical section One example: Filter lock (other is the bakery lock) Filter lock: proof You can find it in the book. Ideas: mutex: induction to show that at most n-k threads are at level k. therefore max. 1 thread at level (n-1) //level n- is the CS as we go from 0 to n-1. Filter lock: proof You can find it in the book. Ideas: mutex: induction to show that at most n-k threads are at level k. therefore max. 1 thread at level (n-1) //level n- is the CS as we go from 0 to n-1. again induction to show starvation free What is with deadlock-free? Filter lock: proof You can find it in the book. Ideas: mutex: induction to show that at most n-k threads are at level k. therefore max. 1 thread at level (n-1) //level n- is the CS as we go from 0 to n-1. again induction to show starvation free starvation-free -> deadlock-free Filter lock: proof Thoughts: Would you say the filter lock is a fair lock ? In general, what is a fair lock ? Filter lock: proof Thoughts: Would you say the filter lock is a fair lock ? In general, what is a fair lock ? Fair lock : First-come first serve principle -> we will look at this closer next week . . Filter lock: proof Thoughts: Would you say the filter lock is a fair lock ? In general, what is a fair lock ? Fair lock : First-come first serve principle -> we will look at this closer next week . Filter lock is not a fair lock, Peterson is a fair lock. Bakery lockBakery lock Think of the post office tickets : each thread has to get a ticket. Bakery lock Think of the post office tickets : each thread has to get a ticket. Flag array -> if the threads wants to enter the CS or not. Label array -> label [i] = label assigned to thread I, “ticket number” Bakery lock Think of the post office tickets : each thread has to get a ticket. Flag array -> if the threads wants to enter the CS or not. Label array -> label [i] = label assigned to thread I, “ticket number” If threads wants to enter: Bakery lock Think of the post office tickets : each thread has to get a ticket. Flag array -> if the threads wants to enter the CS or not. Label array -> label [i] = label assigned to thread I, “ticket number” If threads wants to enter: sets flag entry & increment the current highest ticket number by 1. Bakery lockBakery lockBakery lock Think of the post office tickets : each thread has to get a ticket. Flag array -> if the threads wants to enter the CS or not. Label array -> label [i] = label assigned to thread I, “ticket number” If threads wants to enter: sets flag entry & increment the current highest ticket number by 1. !! Threads can get same label : look at label and id of the thread Bakery lock proof Mutex : contradiction proof via ID’s Bakery lock proof Mutex : contradiction proof via ID’s Deadlock-free : increasing labels and unique ID’s ->always a thread allowed to enter Bakery lock Mutex : contradiction proof via ID’s Deadlock-free : increasing labels and unique ID’s ->always a thread allowed to enter First-come-first serve Bakery lock Mutex : contradiction proof via ID’s Deadlock-free : increasing labels and unique ID’s ->always a thread allowed to enter First-come-first serve First-come-first serve + deadlock-free = starvation- free (see lecture) Peterson, Filter, Bakery Lock ? What do you think, are locks implemented like this in real-life applications ? Peterson, Filter, Bakery Lock ? What do you think, are locks implemented like this in real-life applications ? Basically, everything was a lie -> locks are NOT implemented like this nowadays Peterson, Filter, Bakery Lock ? What do you think, are locks implemented like this in real-life applications ? Basically, everything was a lie -> locks are NOT implemented like this nowadays Does someone have an idea why not ? Peterson, Filter, Bakery Lock ? What do you think, are locks implemented like this in real-life applications ? Basically, everything was a lie -> locks are NOT implemented like this nowadays Does someone have an idea why not ? HINT: memory ? runtime ? Peterson, Filter, Bakery Lock ? What do you think, are locks implemented like this in real-life applications ? Basically, everything was a lie -> locks are NOT implemented like this nowadays Does someone have an idea why not ? HINT: memory ? runtime ? Require O(#threads) memory L Bakery lockPeterson, Filter, Bakery Lock ? What do you think, are locks implemented like this in real-life applications ? Basically, everything was a lie -> locks are NOT implemented like this nowadays Does someone have an idea why not ? HINT: memory ? runtime ? Require O(#threads) memory L They are slow L Peterson, Filter, Bakery Lock ? What do you think, are locks implemented like this in real-life applications ? Basically, everything was a lie -> locks are NOT implemented like this nowadays Does someone have an idea why not ? HINT: memory ? runtime ? Require O(#threads) memory L They are slow L How are the implement then ? What is behind lock.lock() in Java ? How is this executed in hardware ? Solution Fix: support more than read/write in an atomic operation 121 Hardware support for atomic operations Different atomic operations have been proposed, unclear which is best • Test-And-Set (TAS) • Compare-And-Swap (CAS) • Load Linked / Store Conditional • http://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html 122 Hardware Semantics boolean TAS(memref s) if (mem[s] == 0) { mem[s] = 1; return true; } else return false; int CAS (memref a, int old, int new) oldval = mem[a]; if (old == oldval) mem[a] = new; return oldval; 123atomicatomic Essential Modern CPUs support ATOMIC READ-MODIFY- WRITE operations. Modern CPUs support ATOMIC READ-MODIFY- WRITE operations. An operation where we READ Modern CPUs support ATOMIC READ-MODIFY- WRITE operations. An operation where we READ And after reading modify. Modern CPUs support ATOMIC READ-MODIFY- WRITE operations. An operation where we READ And after reading modify. This all in one atomic statement Modern CPUs support ATOMIC READ-MODIFY- WRITE operations. This one atomic instruction, Either happens completely or not at all Idea on how to implement a lock with it ? Lock via CASLock via CAS Think of 0 = free 1 = held by someone Lock via CAS if the mem location is zero, aka the lock is “free” Lock via CAS …then we write 1 to the mem location. “1 == lock is held now” Lock via CAS And we return the old value, Hence, 0 if was free before 1 if was already held. Lock via CAS And we return the old value, Hence, 0 if was free before 1 if was already held. If we return 1, we continue the looping… Bc lock wasn’t free. !!!! Lock via CAS In general think of CAS: Updating a memory location to a value you want Using this, we can implement locks: What about unlock with CAS? Using this, we can implement locks:Okay, how is it in Java ? We have something similar like CAS compareAndSet() // like CAS Okay, how is it in Java ? We have something similar like CAS compareAndSet() // like CAS Returns true if succeeded, not the old value like CAS Okay, how is it in Java ? We have something similar like CAS compareAndSet() // like CAS Returns true if succeeded, not the old value like CAS How would lock look like then ? Exercise Implement lock/ unlock with getAndSet() compareAndSet() boolean set(); boolean get(); boolean compareAndSet(boolean expect, boolean update); boolean getAndSet(boolean newValue); atomically set to value update iff current value is expect. Return true on success. sets newValue and returns previous value. So we can implement our own locks in Java J:So we can implement our own locks in Java J: Does someone see a problem with all of this ? Think of cost& atomics Bus Contention • TAS/CAS are read-modify-write operations: 146 Bus Contention • TAS/CAS are read-modify-write operations: • Processor assumes we modify the value even if we fail! 147 Bus Contention • TAS/CAS are read-modify-write operations: • Processor assumes we modify the value even if we fail! • Need to invalidate cache 148 Bus Contention • TAS/CAS are read-modify-write operations: • Processor assumes we modify the value even if we fail! • Need to invalidate cache • Threads serialize to read the value while spinning 149 TATAS • Idea: Use normal operation to read first, try TAS only if first read returns 0 152 TATAS • Idea: Use normal operation to read first, try TAS only if first read returns 0 • Helps a bit. But what about the case where we see 0 first, then 1 in TAS? Can this happen? 153 TATAS • Idea: Use normal operation to read first, try TAS only if first read returns 0 • Helps a bit. But what about the case where we see 0 first, then 1 in TAS? Can this happen? • Yes, and the more threads the more likely J 154 Exponential Backoff • Idea: Each time TAS fails, wait longer until you re-try 155 Exponential Backoff • Idea: Each time TAS fails, wait longer until you re-try • Works well, must tune parameters (how long to wait initially, when to stop increasing) 156 Exponential Backoff • Idea: Each time TAS fails, wait longer until you re-try • Works well, must tune parameters (how long to wait initially, when to stop increasing) • Same concept in networks, people talking in a high-latency zoom call, etc. 157 Exam task Optimistic concurrency control Use CAS, TAS in code Optimistic concurrency control int x; myMethod{ lock.lock(); int old =x; int next= randomNumber(); x=next; lock.unlock(); CAS, TAS ? Optimistic concurrency control myMethod{ do{ int old =x; int next= old+1; while( ! X.compareAndSet(old,next)); int x; myMethod{ lock.lock(); int old =x; int next= old+1; x=next; lock.unlock(); Optimistic concurrency control Use CAS, TAS in code Don’t explicitly call lock/unlock , just do the change and then check->optimistic Optimistic concurrency control Use CAS, TAS in code Don’t explicitly call lock/unlock , just do the change and then check->optimistic We just try and execute (optimistic) and only if it then fail’s we try again Optimistic concurrency control Use CAS, TAS in code Don’t explicitly call lock/unlock , just do the change and then check->optimistic We just try and execute (optimistic) and only if it then fail’s we try again don’t block per default like with other locks Preview Does someone still see a problem/limitation all the locks so far have ? Preview Does someone still see a problem/limitation all the locks so far have ? Allow only 1 thread to be in CS Imagine a server: want to allow 100 request at the same time Preview Does someone still see a problem/limitation all the locks so far have ? Allow only 1 thread to be in CS Imagine a server: want to allow 100 request at the same time Semaphores Preview Does someone still see a problem/limitation all the locks so far have ? Allow only 1 thread to be in CS Imagine a server: want to allow 100 request at the same time Semaphores = generalization of a lock Preview Does someone still see a problem/limitation all the locks so far have ? Allow only 1 thread to be in CS Imagine a server: want to allow 100 request at the same time Semaphores = generalization of a lock Acquire : blocked until N>0, else decrements it. Release : increment N Preview Does someone still see a problem/limitation all the locks so far have ? Allow only 1 thread to be in CS Imagine a server: want to allow 100 request at the same time Semaphores = generalization of a lock Acquire : blocked until N>0, else decrements it. Release : increment N What is important here when implementing ? Preview Does someone still see a problem/limitation all the locks so far have ? Allow only 1 thread to be in CS Imagine a server: want to allow 100 request at the same time Semaphores = generalization of a lock Acquire : blocked until N>0, else decrements it. Release : increment N What is important here when implementing ? Needs to be atomic -> Preview Does someone still see a problem/limitation all the locks so far have ? Allow only 1 thread to be in CS Imagine a server: want to allow 100 request at the same time Semaphores = generalization of a lock Acquire : blocked until N>0, else decrements it. Release : increment N What is important here when implementing ? Needs to be atomic Implement one and send it to me f.eg using locks Exam taskExam taskExam taskExam taskExam taskExam taskExam taskExam taskAssignment 8: Overview • Analyzing locks • Atomic operations 184 Analyzing locks • The sample code represents the behavior of a couple that are having dinner together, but they only have a single spoon. • Prove or disprove that the current implementation provides mutual exclusion. • HINT: Use State space diagram 185 Atomic operations • In this task, we will see and analyze: • the usage of atomic operations to perform concurrency control, and • the cost of using them when having data contention • For more details, please refer to the assignment sheet 186 Take-aways Volatile why we use CAS, TATAS instead of lock algo happens before, PO, SO, SA Peterson lock& properties N-thread locks (Filter & Bakery) 3 lock correctness conditions Detect conditions in state diagram fairness CAS, TAS, TATAS Backoff relationship btw deadlock-free, starv.-free& fair Let’s start KAHOOOOOOOOOT See you next week J","libVersion":"0.3.2","langs":""}