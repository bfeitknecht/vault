{"path":"sem4/CN/UE/e/CN-u02-e.pdf","text":"Exercise 2: DNS, HTTP/Web Pre-Note: This week contains lots of exercises about DNS and some about HTTP & Web. We still encourage you to try the “Hands-On” exercise (exercise 6) and experiment with DNS on your own. If you have questions, you can ask them on gitlab. You can find a visual explanation of the DNS systems here: https://howdns.works/ Question 1: DNS warmup a) Name one problem that DNS solves and name one advantage of the DNS system. b) Why should we always use trusted DNS servers? Question 2: DNS vs static “hosts.txt” file Before the DNS existed people used a static “hosts.txt” file to translate from domain names to IP addresses. This one-file-approach is luckily no longer used. Give 3 reasons why this is the case. Briefly explain your answers. Question 3: DNS Caching Given the DNS (caching) architecture explained during the lecture, assume a record change is issued. 1. To which address is an Internet user (who regularly browses the web) directed after the record changes? • The old address • The new address • Both are possible 2. Assume now a record removal (instead of record change). To which address is the user directed? • The old address • Timeout/translation error/no record found • Both are possible Question 4: DNS address translation In order to translate the domain name “netsec.ethz.ch” to an IP address you use the DNS system. 1. You, as the requesting host, contact your local DNS server for the transla- tion which then takes care of all further communication with other name servers to finally deliver you the result. Which answer is correct? Your request to the local DNS server can be considered a: • recursive query, or a • iterative query 1 2. Now consider the query from the perspective of your local DNS server. The table below lists the relevant authoritative name servers for the query. We here refer to the servers by their canonical hostname. Reminder about canonical hostnames: Every server has a canonical hostname and optionally multiple aliases. For example, a hostname such as relay1.west- coast.enterprise.com (canonical hostname) could have, say, two aliases such as enterprise.com and www.enterprise.com. Alias hostnames, when present, are typically more mnemonic than canonical hostnames. server information a.root-servers.net authoritative root server a.nic.ch authoritative name server for all .ch domains ns1.ethz.ch authoritative name server for the domain netsec.ethz.ch Assume there are no cached records, no additional information and the local DNS server only knows the IP of a single root server. a) How many messages are “handled” (sent or received) by the local DNS server when translating “netsec.ethz.ch” assuming an iterative query? Do not include the messages sent from or to the requesting host. b) How many messages are “handled” by the local DNS server assuming a recursive query instead? Question 5: DNS root servers In order to perform any iterative DNS query from scratch, one needs to contact a root DNS server. 1. How many root DNS servers are there? Are there more machines answering root DNS queries as there are root DNS servers? 2. Which mechanisms are in place for root DNS servers to deal with the traffic and to prevent future unnecessary traffic? Question 6: Hands on DNS Dig is a command line utility that allows you make DNS requests using the command line. You can install it through any package manager under linux. We strongly recommend to experiment with dig commands to solve the question and deepen your understanding of the topic. If you don’t have access to a linux machine or are unable to install it you can also use the online tool/gui: https://www.diggui.com. Hint: The section of a DNS response that is interesting for you is the “Answer” section (and maybe the “Additional Information” section). You might want to quickly read up on the answer format here: (https://phoenixnap.com/kb/linux- dig-command-examples). 2 Question 6.1 To start with, make a simple query to find the IP address of the domain www.ethz.ch using the command dig www.ethz.ch. • What is the result of the command? • What type of record is it and what is this type of record used for? • What is the TTL of this record and what does it indicate? You can write your answer in short bulletpoints. Question 6.2 There are recursive and iterative DNS queries. What kind of query do you expect in the current internet? Try out using +trace before the domain name. What kind of query type does this show? Question 6.3 We can now send a query to a specific DNS server by using the @dns.server flag. 1. If we create our simple query (dig @a.root-servers.net www.ethz.ch) and send it to the first root-server, we don’t get an www.ethz.ch IP in return. Why is this? 2. Create a query for netsec.ethz.ch, what kind of result do you expect? (you can check for yourself) 3. One DNS server of eth is called ns1.ethz.ch. Which result do you get when you query this server? (You may want to try this yourself) 4. Can you find out about the DNS name server “ns1.ethz.ch” on your own using dig? Do you find the IP of ethz.ch? 5. Does dig ethz.ch give the same result? Question 6.4 Dig can also be used to request the inverse query, requesting the domain name from an IP-address, which is called reverse IP lookup and is achieved with the -x flag. Which domains do the IP 1.1.1.1 and 8.8.8.8 belong to? Question 7: Browsing: TRUE or FALSE? 1. HTTP headers are usually human readable. 2. The critical path in the context of (web page element dependencies) is the shortest path in the dependency graph. 3. Having more compute power cannot speed up the page load time. 3 Question 8: Fetching Web Content Bob and Alice are trying to fetch the same n (with n being large) web page elements from different servers. In particular, Bob tries to fetch the contents from a server with RT TB = rtt, while Alice from one with RT TA = 3 * rtt. Bob uses a single non-persistent TCP connection for each object sequentially (one after the other), while Alice uses at most M parallel non-persistent TCP connections. Non-persistent means that for each object a new TCP connection is opened. Both Bob and Alice do not use pipelining. Assume infinite bandwidth and that each object is small enough that it can be transmitted in one go (without multiple rounds of packets and ACKs). Assume also there are no dependencies across the n objects. Question 8.1 How much time does Bob take to fetch the n web page elements? Question 8.2 What is the minimum number of parallel connections that Alice needs in order to be faster than Bob in downloading the objects? Question 8.3 If Bob would have used a persistent (kept-alive) TCP connection instead of opening a new connection for each object, what would his completion time have been? And if Alice would have used persistent kept-alive TCP connections? For n = 100, would Bob have been faster than Alice assuming Alice kept the same strategy of M non-persistent connections? Question 9: Critical path in a dependency graph Below you are given a dependency graph containing various tasks to be processed when loading a website. The nodes represent tasks that are processed and the edges are annotated with the processing time of the dependencies between these two tasks in milliseconds. For example, Task H depends on Task A and the processing time for this dependency is 50ms. 4 Dependency graph Recall that within a dependency graph, the critical path determines the minimum amount of time it takes to fully load all dependencies. Question 9.1 Calculate the final overall page-load time. In which order would the browser process the tasks in the dependency graph? Question 9.2 In the dependency graph above, can we reduce the total webpage load time by reducing the load time of any dependency on the Task A? If so, by how much can we reduce it before the final overall load time no longer decreases? 5","libVersion":"0.5.0","langs":""}