{"path":"sem2a/AuW/UE/u/c/AuW-u05-bf-c.pdf","text":"AuW-u05-bf (a) We use the LocalRepair algorithm with input which, per deﬁnition, is sorted by coordinates. Thus we have computed in . ~ (b) We split the set into two subsets, and . Since the set is non crossing, we now have two basically sorted subsets. We run LocalRepair on them and merge the two resulting convex hulls. Thus, we have computed in . ⑧ per & & ca .. · Cover => splitting the set into an upper & lower set is a solid approach (also part of th e Musterlosung bu t this doesn't sort the subsets. This is why yo u can't simply ru n LocalRepair. (c) Since the points in are sorted anticlockwise and P is a simple polygon (no crossing edges), we can turn every point's coordinates into their polar system equivalent ( ). This takes in total. We then start building a stack, where the top element is always the last point considered a potential candidates for the convex hull's edge points. While it may seem that the time complexity of the loop is , because for each point it goes back to check if any of the previous points make a \"right turn\", it is actually , because each point is considered at most twice in some sense. Each point can appear only once as a point  in a \"left turn\" (because the the poly -* Sinc e S isn't catered around the origin , we don't get am order based a magle We definitely can , but I don't quite get why we sho u ld b b what do these functions do ? ?? algorithm advances to the next point  after that), and as a point  in a \"right turn\" (because the point  is removed). Thus we have computed in .","libVersion":"0.3.2","langs":""}