{"path":"sem4/FMFP/UE/e/FMFP-u12-e.pdf","text":"P. M¨uller, D. Basin and R. Jung Formal Methods and Functional Programming Exercise Sheet 12: Axiomatic Semantics (Hoare Logic) Submission deadline: May 20th/21st, 2025 Viper Viper (viper.ethz.ch) is a verification project, providing a language and tools for verifying func- tional properties of programs in that language. In particular, Viper supports verification of loops via loop invariants, as you have learned in the course. In this exercise session, you can try out Viper as a tool for helping to practice the important skill of finding loop invariants. There are two simple ways of running Viper: the recommended way is to download the VSCode plugin for Viper, as explained here: http://www.pm.inf.ethz.ch/research/viper/downloads.html (make sure to install the “Viper” plugin, and that you have the right dependencies, as explained in the in- structions). Alternatively, you can run the Viper tools through the (slower) web interface, available at http://viper.ethz.ch/examples/blank-example.html. The syntax of Viper programs is slightly different to that of IMP, but very similar. Syntax for assignments is the same (although local variables must be declared with an explicit type, using the syntax var x: Int. There is no skip command, but statement blocks (e.g., branches of conditionals) may be left empty. Viper uses C/Java-like syntax for conditionals and loops. For example, the IMP program if x > 0 then x := x - 1; while x > 0 do x := x - 1 end else skip end could be translated into Viper as follows: if (x > 0) { x := x - 1 while (x > 0) { x := x - 1 } } else { /* else branch can be omitted */ } Loop invariants can be written between the while-condition and the open brace {, e.g.: 1 while (x > 0) invariant x >= 0 { x := x - 1 } To help us improve Viper, you are welcome to voluntarily submit your Viper programs to our database. We do not store any data besides the submitted programs. If you would like to participate, please follow the steps below: 1. Go to VS Code Settings and search with the keyword “Viper”. Find Viper Settings: Verification Backends and click on Edit in settings.json. 2. In settings.json, locate the configuration for the backend that you are using — either the default Silicon or Carbon. Add the argument --submitForEvaluation to the beginning of the customArguments field for that backend. 2 Assignment 1 (Total Correctness of Exponentiation) Let s1 be the following statement: y := 1; z := 0; while z < x do y := y * 2; z := z + 1 end The Viper skeleton can be found on the website: program 3 exponentiation.vpr. Our goal is to prove that ⊢ { x = X ∧ X ≥ 0 } s1 { ⇓ y = 2 X }. Task 1.1. Find a suitable loop invariant and loop variant. You may use Viper to do so. Hint: The invariant should mention all variables used in the loop. Task 1.2. Give a proof outline for ⊢ { x = X ∧ X ≥ 0 } s { ⇓ y = 2 X }. Assignment 2 Consider the following IMP program s2: y := 0; z := 0; while y * y < n do y := y + 1; if y * y <= n then z := z + 1 else skip end end The Viper skeleton can be found on the website: program 4.vpr. Task 2.1. Assume n ≥ 0 as pre-condition. What does this function compute (hint: the result is stored in z)? Write a post-condition to ensure that z has the right value after termination. Also add the pre-condition to the program. 3 Task 2.2. Find a suitable loop invariant which enables the verifier to prove the post-condition given the pre-condition. Task 2.3. Prove that { n = N ∧ n ≥ 0 } s1 { z 2 ≤ N ∧ N < (z + 1)2 } Task 2.4. Give a suitable variant (i.e., which can be used with the rule WhTotAx) to prove that the program terminates, and explain why it is suitable. 4","libVersion":"0.5.0","langs":""}