{"path":"sem4/FMFP/UE/s/FMFP-u14-s.pdf","text":"P. M¨uller, D. Basin and R. Jung Formal Methods and Functional Programming Exercise Sheet 14: LTL and Model Checking Submission deadline: June 3rd/4th, 2025 Assignment 1 (Dining Philosophers) This assginment is a conutination of Assignment 1 from Exercise Sheet 13. The problem of the dining philosophers illustrates common issues for concurrent programs: We consider n philosophers sitting around a circular table. Each philosopher spends their life thinking and eating. In the center of the table is a large platter of spaghetti. Because the spaghetti are long and tangled a philosopher must use two forks to eat them. Since the philosophers can only afford n forks, a single fork is placed between each pair of philosophers, which they have to share. Each philosopher can only reach the forks to their immediate left and right with their left or right hand, respectively. Note: For this exercise, you may not submit handwritten models. Only Promela files will be ac- cepted. While model checking you may use the fairness flag -f, but, if you do, be sure to mention it in your solution. The fairness flag causes spin to only explore traces which schedule the individ- ual processes in a weakly-fair manner; in particular, it cannot be the case that a process that is continually enabled (could make another step) is never scheduled. In the GUIs, this can be chosen by choosing “With Weak Fairness” in the Verification Options. Task 1.1. See Task 1.1 from Exercise Sheet 13. Task 1.2. See Task 1.2 from Exercise Sheet 13. 1 Task 1.3. Check whether your solution to Task 1.2 is starvation free, i.e., whether there are no paths in which a philosopher never eats. You must modify the model accordingly, add an LTL formula, and model-check it with Spin. Note: To model check a Promela file against an LTL formula f with Spin, you may express the LTL formula in an LTL block in the file (ltl {f }). The LTL formula is expressed us- ing: • [] <> ! && || -> U for operators □ ♢ ¬ ∧ ∨ ⇒ U resp. • The equality operator as a primitive propositional formula. For example, to express p, one should write (p==true). Spin should be executed (if running from the command-line) with the analysis option -a. Further- more, the final executable must also be executed with the -a option. For example: spin -a file.pml gcc -o ts.exe pan.c ./ts.exe -a In the GUIs (e.g. xspin), you can achieve the same thing by choosing (in Verification Parameters) Liveness, acceptance cycles and “Apply Never Claim”/”use claim” (ignore the warnings in xspin - these are because the gui doesn’t understand the ltl block syntax (but the underlying version of spin does)). Solution. See philosophers 3.pml. We introduce the boolean array eats and we ensure that eats[i] is true iff philosopher i is eating. Now we can check the LTL property □ ♢ eats[0] and find that it fails. Because this property fails, we know that the model is not starvation-free (of course, if we did not find a failure here, we would have to check a property about all philosophers to be sure of starvation-freedom). Task 1.4. Modify the solution to make it starvation free. Model-check the new model with your old LTL formula. You may introduce any restrictions you find appropriate to the behaviour of the philosophers. Note: This exercise is a bit more involved. Solution. See philosophers 4.pml. Starvation happens when one thread never blocks. In our example, it is possible for a philosopher to execute forever never allowing any other philosopher to do anything. We forbid this by introducing blocking conditions in our philosophers. In particular, each philosopher i has a counter called fair[i] that gets decreased when the philosopher thinks or eats. When the counter reaches 0, then the philosopher blocks. To avoid self-starvation, the philosopher has to eat at least once before fair[i] reaches zero; we define a flag eaten[i] for that purpose. When all counters are zero, then all philosophers block. Then a supervisor process takes effect, resetting all the counters to their initial value. The number of philosophers in the file is reduced to three. The initial value of the counters is two. These restrictions are to avoid the large state space that we get otherwise. The file model checks immediately, even without the fairness flag -f. 2 Assignment 2 (Linear Temporal Logic) Consider the transition system T over the set of atomic propositions P = {p, q, r}: s 1 s 3 s 4 s 2 s 5 { }q, r { }p, q, r { } { }rp { }q That is, T is the transition system (Γ, s1, →, L) with Γ = {s1, s2, s3, s4, s5} → = {(s1, s3), (s1, s4), (s2, s4), (s3, s4), (s4, s2), (s4, s3), (s4, s5), (s5, s4), (s5, s5) } L(si) =    {p} if i = 1 {r} if i = 2 {q, r} if i = 3 {q} if i = 4 {p, q, r} if i = 5. Task 2.1. Which of the following LTL formulas are satisfied in T , i.e., T |= φi? φ1 = ♢ □ r φ2 = □ ♢ r φ3 = ⃝¬r ⇒ ⃝ ⃝ r φ4 = □ p φ5 = p U □ (q ∨ r) φ6 = (⃝ ⃝ q) U (q ∨ r) φ7 = ♢ □ ⃝ q φ8 = (♢ □p) ⇒ (♢ □r) Justify your answer. If T ̸|= φi, provide a computation γ of T such that for the corresponding trace t, t ̸|= φi. Solution. i. We have T ̸|= φ1. A counter-example is γ = s1s4s5s4s5s4 . . . ii. We have T |= φ2 since there is no loop in which r does not hold at some point. iii. We have T |= φ3 because ¬r holds in s1 and s4, but s1 cannot be a next state, hence only s4 is of interest. In all states reachable in a single transition from s4 r holds, hence the formula holds. 3 iv. We have T ̸|= φ4. A counter-example is γ = s1s4s5s5s5 . . . v. We have T |= φ5 since p holds in s1, and s1 cannot be occur later in the computation (no transition arrows lead to it). In all states other than s1, with q or r holds. vi. We have T ̸|= φ6. A counter-example is γ = s1s4s2s4s2s4s2 . . . vii. We have T ̸|= φ7. A counter-example is γ = s1s4s2s4s2s4s2 . . . viii. We have T |= φ8. The only way to satisfy the antecedent is eventually to go into a loop s5s5s5..., and in this loop the consequent is also satisfied, hence the formula holds. In all traces that do not have an infinite suffix of s5’s, the antecedent is false, and the formula holds trivially. Therefore, the formula holds for all traces. Task 2.2. Formalize the following properties in LTL: i. Eventually, it will not be possible for the system to go to state s1. ii. Whenever the system is in a state that satisfies r, then the next state satisfies q. iii. p always implies r except perhaps in the initial state. iv. Whenever the system is in state s5, it will remain there until r becomes false. v. q will be true at least twice. vi. q will be true infinitely often. vii. If p is true only at the initial state of a trace, then r is false infinitely many times in that trace. viii. s4 can never be repeated (there is no transition from s4 to itself). Solution. The LTL-formulas are: i. ♢ □¬(p ∧ ¬q ∧ ¬r) ii. □(r ⇒ ⃝q) iii. ⃝ □(p ⇒ r) iv. □((p ∧ q ∧ r) ⇒ ((p ∧ q ∧ r) U ¬r)) v. ♢(q ∧ ⃝ ♢q) vi. □ ♢q vii. (p ∧ ⃝ □¬p) ⇒ (□ ♢¬r) viii. □(¬p ∧ q ∧ ¬r ⇒ ⃝¬(¬p ∧ q ∧ ¬r)) 4 Task 2.3. A Promela model for the transition system above is given in ts.pml. Use Spin to model-check all the properties φi that do not contain the ⃝ operator. Inspect ts.pml and answer the following question: Why are atomic statements used? Solution. The LTL-formulas can be found in ts ltl.pml. The state changes brought by the three assignments should be considered atomic. For example, consider what would happen if we removed the atomic block from state s3. Now consider property ϕ5, which holds in the transition graph, and in particular consider the transition from s1 to s3. Since the assignment p=false happens first, the state after it is one in which neither p nor q ∨ r hold. This falsifies ϕ5. With the atomic blocks, the change of the values of p,q,r happens without intermediate states, representing the transition graph faithfully. To convince yourself, model check ϕ5 with and without the atomic block. Assignment 3 (Liveness and Safety Properties) Task 3.1. Let A be a set of atomic propositions. Prove that a property is both a safety and liveness property if and only if it is equal to P(A)ω. Solution. • (⇒) Let P be a property. Assume that P ̸= P(A) ω. We will prove that P cannot be both a safety and a liveness property (by showing that if it is a safety property ̸= P(A)ω, then it is not a liveness property. Assume that P is a safety property. Since P ̸= P(A)ω, there exists an infinite sequence (of abstract states) t ̸∈ P . Since P is a safety property, there exists a finite prefix t ′ of t, such that for all infinite sequences t ′′, it is t′t ′′ ̸∈ P . Therefore P cannot be a liveness property. • (⇐) We will prove that P(A)ω is both a safety and a liveness property. There is no infinite sequence t ̸∈ P(A) ω, which makes P(A) ω trivially a safety property. Assume t ′ is any finite sequence. Then, there is guaranteed to exist an infinite sequence t ′′ such that t ′t′′ ∈ P(A) ω (in fact, any choice of t ′′ will do). Therefore, P(A) ω a liveness property. Task 3.2. Is ∅ a safety property, a liveness property, both, or neither? Solution. Let t be an infinite sequence such that t ̸∈ ∅ (any infinite sequence will do). For any finite prefix t ′ of t, and for any infinite sequence t ′′ we have t ′t ′′ ̸∈ ∅. Thus, ∅ is a safety property. Since P(A) ω ̸= ∅ (powersets are never empty), by the previous part of the question, we know that ∅ is not a liveness property. 5 Task 3.3. Is pUq a safety property, a liveness property, both, or neither? Solution. The property is neither a safety nor a liveness property. It is not a safety property because the infinite sequence t where t[i] = {p} for all i does not satisfy the property and there is no bad prefix. Any finite prefix {p}i can easily be extended with any sequence starting with {q} to satisfy the property. It is not a liveness property either because there are bad finite prefixes that cannot repaired; for instance {}{q} is such a prefix. 6","libVersion":"0.5.0","langs":""}