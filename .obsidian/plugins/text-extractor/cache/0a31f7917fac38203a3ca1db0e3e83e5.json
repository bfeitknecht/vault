{"path":"sem4/FMFP/PV/exams/midterms/FMFP-FS10.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Midterm Exam April 14th, 2010, 15:45 – 17:45 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Exam.-Nr.: 0 General Comments: 1. Check that your exam papers are complete (6 assignments). 2. Do not write on the exam sheets. Use a separate sheet of paper for every assignment and write your name on each of them. Additional sheets are available from the assistants. 3. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no prepared notes, etc. Do not use a pencil (Bleistift) and do not use the color red. 4. You may write your answers in English or German. Important: Write clearly in the sense of logic, language, and readability. 5. If you have a question regarding the meaning of a problem statement, you may ask one of the assistants in charge of the exam. Assignment 1 2 3 4 5 6 ∑ Max. points 4 4 3 5 6 9 31 Your points FM and FP, Midterm Exam, SS10, Exam-Nr. 0 1 Assignment 1: Typing, (4 points) Recall the following functions from the Haskell libraries. takeWhile :: (a -> Bool) -> [a] -> [a] zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] 1 :: Num a => a (==) :: Eq a => a -> a -> Bool State the most general type of each of the following expressions. 1. (\\x y z -> y z x) 2. zipWith (==) 3. (\\x y -> y ((==) x)) 4. takeWhile (\\x -> x 1) FM and FP, Midterm Exam, SS10, Exam-Nr. 0 2 Assignment 2: Natural Deduction, (4 points) Recall the following rules from natural deduction for intuitionistic predicate logic. Γ, A ⊢ A Ax Γ, A ⊢ B Γ ⊢ A → B → I Γ ⊢ A → B Γ ⊢ A Γ ⊢ B → E Γ ⊢ ⊥ Γ ⊢ A ⊥E Γ, A ⊢ ⊥ Γ ⊢ ¬A ¬I Γ ⊢ ¬A Γ ⊢ A Γ ⊢ B ¬E Γ ⊢ A Γ ⊢ A ∨ B ∨IL Γ ⊢ B Γ ⊢ A ∨ B ∨IR Γ ⊢ A ∨ B Γ, A ⊢ C Γ, B ⊢ C Γ ⊢ C ∨E Γ ⊢ P (x) Γ ⊢ ∀x. P (x) ∀I ∗ Γ ⊢ ∀x. P (x) Γ ⊢ P (t) ∀E Γ ⊢ A(t) Γ ⊢ ∃x. A(x) ∃I Γ ⊢ ∃x. A(x) Γ, A(x) ⊢ B Γ ⊢ B ∃E∗∗ Side conditions: (*) x not free in Γ and (**) x not free in Γ or B. Also recall that the scope of the quantiﬁers extends as far to the right as possible. Prove ⊢ ∀x. Q(x) ∨ P (x) → (∃y.Q(y)) ∨ P (x) using natural deduction and label each inference step with the name of the corresponding rule. FM and FP, Midterm Exam, SS10, Exam-Nr. 0 3 Assignment 3: Rose Trees, (3 points) A rose tree of elements of type a is a possibly inﬁnitely branching tree represented by the data type RoseTree a. data RoseTree a = Node a [RoseTree a] (a) Write a Haskell function dropFirstChild :: RoseTree a -> RoseTree a such that dropFirstChild t removes the ﬁrst child (if there is any) of each node in the rose tree t. For example given the rose tree tree1 = Node 1 [Node 2 [Node 3 []], Node 4 [Node 5 []]] we have dropFirstChild tree1 = Node 1 [Node 4 []] (b) Write a Haskell function mapRoseTree :: (a -> b) -> RoseTree a -> RoseTree b such that mapRoseTree f t applies the function f to the label of every node in t. For example mapRoseTree (+1) tree1 = Node 2 [Node 3 [Node 4 []], Node 5 [Node 6 []]] FM and FP, Midterm Exam, SS10, Exam-Nr. 0 4 Assignment 4: Proof by Induction, (5 points) Consider the following Haskell data type. data Nat = Zero | Succ Nat (a) Give the induction scheme for the data type Nat as an inference rule. (b) Assume given a function (+) :: Nat -> Nat -> Nat implementing addition on Nat. Consider the following Haskell function. mult x Zero = Zero -- mult.1 mult x (Succ y) = x + mult x y -- mult.2 Prove that ∀x, y, z :: Nat. mult (mult x y) z = mult x (mult y z). You can use the following lemma without proof. Lemma 1: ∀x, z, y :: N at. mult x y + mult x z = mult x (y + z) Note: The structure of your proof and a justiﬁcation for each step should be clearly given. FM and FP, Midterm Exam, SS10, Exam-Nr. 0 5 Assignment 5: Lists, (6 points) Note: You may use all Haskell library functions except for permutations and scanl. (a) Write a Haskell function insertions :: a -> [a] -> [[a]] such that insertions x ys computes all insertions of the s ingle element x in the list ys. For example: insertions 1 [2,3,4] = [[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,1]] Hint: There exists a two line solution. However, longer solutions are also ﬁne. (b) Write a Haskell function perms :: [a] -> [[a]] such that perms xs computes all permutations of the list xs. For example: perms [1,2,3] = [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]] Hint: There exists a two line solution. However, longer solutions are also ﬁne. (c) The function scanl :: (b -> a -> b) -> b -> [a] -> [b] is similar to foldl, but returns a list of successive reduced values from the left: scanl f z [x1, x2, ...] == [z, z ‘f‘ x1, (z ‘f‘ x1) ‘f‘ x2, ...] For example: scanl (+) 0 [1..10] = [0,1,3,6,10,15,21,28,36,45,55] Write the Haskell function scanl. FM and FP, Midterm Exam, SS10, Exam-Nr. 0 6 Assignment 6: Data Types, (9 points) Consider the following data types for modeling arithmetic expressions with integer con- stants, variables, addition, subtraction, and multiplication. data Op = Plus | Minus | Times data AExpr = Const Int | Var String | BinOp Op AExpr AExpr (a) Write a Haskell function evalOp :: Op -> (Int -> Int -> Int) such that evalOp op returns the function of type Int -> Int -> Int that corresponds to op. (b) Give the type signature and the implementation of the Haskell function foldAExpr that implements a fold on the data type AExpr. (c) Write a Haskell function eval :: (String -> Int) -> AExpr -> Int such that eval env aexp evaluates the arithmetic expression aexp in the environment env which maps variable names to integers. Consider the following data type modeling stack instructions. data Instr = BinOpI Op | ConstI Int | LoadI String (d) Write a Haskell function exec :: (String -> Int) -> [Instr] -> [Int] -> [Int] such that exec env instrs s executes the instructions in instrs using the integer stack s and the environment env. The stack instructions should be interpreted as follows. ConstI: Push the given integer onto the stack. LoadI: Look up the given variable in the environment and push it onto the stack. BinOpI: Pop an integer x and then an integer y from the stack, apply the given operator to x and y (in this order), and push the result back onto the stack. Note: Stacks can be modeled using a list where the push operation adds a new head to the list and and the pop operation removes the head of the list. (e) Write a Haskell function compile :: AExpr -> [Instr] that compiles arithmetic ex- pressions to lists of stack instructions such that head (exec env (compile aexp) []) = eval env aexp holds for all for all env::String -> Int and aexp::AExp. (Note that you do not have to prove that your function satisﬁes this property.) The following is an example of applying compile. compile (BinOp Minus (Const 1) (Const 2)) = [ConstI 2, ConstI 1, BinOpI Minus]","libVersion":"0.5.0","langs":""}