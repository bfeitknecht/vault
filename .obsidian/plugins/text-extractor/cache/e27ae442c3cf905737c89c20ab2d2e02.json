{"path":"sem2/PProg/VRL/slides/PProg-L25-linearizability.pdf","text":"spcl.inf.ethz.ch @spcl_eth TORSTEN HOEFLER Parallel Programming Theory, Linearizability 5/19/24 NVIDIA H100 4.3 TOP/W spcl.inf.ethz.ch @spcl_eth ▪ Memory (Node) pools ▪ A powerful concept to avoid OS overheads ▪ Memory reuse and the ABA problem ▪ Really an issue with CAS only (LL/SC and others not affected) ▪ CAS is still the most prevalent powerful atomic operation Why it’s powerful comes soon! ▪ Remedies: ▪ Pointer tagging ▪ Hazard pointers Summary/recap last lecture 2 spcl.inf.ethz.ch @spcl_eth Learning goals today 3 ▪ Finally, some theory ▪ Linearizability ▪ Histories ▪ Composability ▪ Sequential consistency (is not modular/composable) ▪ Maybe consensus ▪ Why is CAS considered more powerful than TAS? spcl.inf.ethz.ch @spcl_eth Linearizability 4 “What's the difference between theory and practice? Well, in theory there is none.” - folklore spcl.inf.ethz.ch @spcl_eth Each method should appear to take effect instantaneously between invocation and response events. An object for which this is true for all possible executions is called linearizable. The object is correct if the associated sequential behavior is correct. Linearizability 5 spcl.inf.ethz.ch @spcl_eth Is this particular execution linearizable? A q.enq(x) B q.deq() →y q.deq() →x time 6 q.enq(y) spcl.inf.ethz.ch @spcl_eth Yes A q.enq(x) B q.enq(y) q.deq() →y q.deq() →x time 7 spcl.inf.ethz.ch @spcl_eth Linearizable? A q.enq(x) B q.enq(y) q.deq() →y time 8 spcl.inf.ethz.ch @spcl_eth 9 No A q.enq(x) B q.enq(y) q.deq() →y time x is first in queue spcl.inf.ethz.ch @spcl_eth 10 Linearizable ? A q.enq(x) B q.eny(y) q.deq() →y q.deq() →x time spcl.inf.ethz.ch @spcl_eth 11 Yes A q.enq(x) B q.eny(y) q.deq() →y q.deq() →x time spcl.inf.ethz.ch @spcl_eth 12 And yes, another scenario. A q.enq(x) B q.eny(y) q.deq() →y q.deq() →x time spcl.inf.ethz.ch @spcl_eth 13 Read/Write Register Example A write(0) B time write(2) write(1) read()→1 spcl.inf.ethz.ch @spcl_eth 14 Linearizable! A write(0) B write(1) time write(2) read()→1 spcl.inf.ethz.ch @spcl_eth 15 Linearizable? A write(0) B time write(2)read()→1 write(1) read()→1 spcl.inf.ethz.ch @spcl_eth 16 No A write(0) B time write(2)read()→1 write(1) must have happened write(1) read()→1 spcl.inf.ethz.ch @spcl_eth ▪ We talk about executions in order to abstract away from actual method content. ▪ A simplification you need to revert (mentally) for analyzing codes ▪ The linearization points can often be specified, but they may depend on the execution (the state during execution, not only the source code). ▪ Example: if the queue is empty, a dequeue may fail, while it does not fail with a non-empty queue Remark public int deq() throws EmptyException { if (tail == head) throw new EmptyException(); int x = items.get(head++ % capacity); return x; } 17 spcl.inf.ethz.ch @spcl_eth Split method calls into two events. Notation: Invocation Response A q.enq(x) A q: void More formal thread object method arguments thread object result 18 spcl.inf.ethz.ch @spcl_eth History H = sequence of invocations and responses A q.enq(3) A q:void A q.enq(5) H B p.enq(4) B p:void B q.deq() B q:3 Invocations and response match, if thread names agree and object names agree An invocation is pending if it has no matching response. A subhistory is complete when it has no pending responses. 19 History spcl.inf.ethz.ch @spcl_eth Object projections A q.enq(3) A q:void A q.enq(5) B p.enq(4) B p:void B q.deq() B q:3 Thread projections A q.enq(3) A q:void A q.enq(5) B p.enq(4) B p:void B q.deq() B q:3 Projections H|q = H|B = 20 spcl.inf.ethz.ch @spcl_eth A q.enq(3) A q:void A q.enq(5) B p.enq(4) B p:void B q.deq() B q:3 Complete subhistory History H without its pending invocations. Complete subhistories complete (H) = 21 spcl.inf.ethz.ch @spcl_eth A q.enq(3) A q:void B p.enq(4) B p:void B q.deq() B q:3 A q:enq(5) Sequential history: ▪ Method calls of different threads do not interleave. ▪ A final pending invocation is ok. Sequential histories 22 spcl.inf.ethz.ch @spcl_eth H= A q.enq(3) B p.enq(4) B p:void B q.deq() A q:void B q:3 Well formed histories Well formed history: Per thread projections sequential H|A = A q.enq(3) A q:void H|B = B p.enq(4) B p:void B q.deq() B q:3 23 spcl.inf.ethz.ch @spcl_eth H= A q.enq(3) B p.enq(4) B p:void B q.deq() A q:void B q:3 G = A q.enq(3) A q:void B p.enq(4) B p:void B q.deq() B q:3 Equivalent histories H and G equivalent: H|A = G|A H|B = G|B 24 spcl.inf.ethz.ch @spcl_eth Sequential specification tells if a single-threaded, single object history is legal Example: pre- / post conditions A sequential history H is legal, if ▪ for every object x ▪ H|x adheres to the sequential specification of x Legal histories 25 spcl.inf.ethz.ch @spcl_eth A method call precedes another method call if the response event precedes the invocation event A q.enq(3) B p.enq(4) B p:void A q:void B q.deq() B q:3 if no precedence then method calls overlap A q.enq(3) B p.enq(4) B p:void B q.deq() A q:void B q:3 Precedence 26 spcl.inf.ethz.ch @spcl_eth Given: history 𝐻 and method executions 𝑚0 and 𝑚1 on 𝐻 Definition: 𝒎𝟎 →𝑯 𝒎𝟏 means 𝒎𝟎 precedes 𝒎𝟏 →𝑯 is a relation and implies a partial order on H. The order is total when H is sequential. Notation 27 spcl.inf.ethz.ch @spcl_eth History 𝐻 is linearizable if it can be extended to a history 𝐺 by ▪ appending zero or more responses to pending invocations that took effect ▪ discarding zero or more pending invocations that did not take effect such that G is equivalent to a legal sequential history 𝑆 with →𝑮 ⊂ →𝑺 Linearizability 28 spcl.inf.ethz.ch @spcl_eth 29 Invocations that took effect … ? A q.enq(x) B q.deq() →x C flag.read() → ? cannot be removed because B already took effect into account can be removed, nobody relies on this spcl.inf.ethz.ch @spcl_eth →𝑮 = 𝒂 → 𝒄, 𝒃 → 𝒄 →𝑺 = 𝒂 → 𝒃, 𝒂 → 𝒄, 𝒃 → 𝒄 →𝑮 ⊂ →𝑺 ? What does this mean? A a B b c time →𝑮 →𝑺 →𝑺 30 In other words: S respects the real-time order of G Linearizability: limitation on the possible choice of S spcl.inf.ethz.ch @spcl_eth Composability Theorem History H is linearizable if and only if for every object x H|x is linearizable Consequence: Modularity • Linearizability of objects can be proven in isolation • Independently implemented objects can be composed Composability 31 spcl.inf.ethz.ch @spcl_eth Memory location for values of primitive type (boolean, int, ...) • operations read and write Linearizable with a single linearization point, i.e., • sequentially consistent, every read operation yields most recently written value • for non-overlapping operations, the realtime order is respected. Recall: Atomic Registers 32 spcl.inf.ethz.ch @spcl_eth public T deq() throws EmptyException { lock.lock(); try { if (tail == head) throw new EmptyException(); T x = items[head % items.length]; head++; return x; } finally { lock.unlock(); } } Reasoning About Linearizability (Locking) head tail Linearization points are when locks are released 33 spcl.inf.ethz.ch @spcl_eth class WaitFreeQueue { volatile int head = 0, tail=0; AtomicReferenceArray<T>[] items = new AtomicReferenceArray<T>(capacity); public boolean enq (T x) { if (tail – head == capacity) return false; items.set((tail+1) % capacity, x); tail++; return true; } public T deq() { if (tail - head == 0) return null; int x = items.get((head+1) % capacity); head++; return x; } } Reasoning About Linearizability (Wait-free example) Linearization point for (only one) enqueuer Linearization point for (only one) dequeuer head tail 34 Linearization point Linearization point spcl.inf.ethz.ch @spcl_eth public T dequeue() { while (true) { Node first = head.get(); Node last = tail.get(); Node next = first.next.get(); if (first == last) { if (next == null) return null; else tail.compareAndSet(last, next); } else { T value = next.item; if (head.compareAndSet(first, next)) return value; } } } Reasoning About Linearizability (Lock-free example) Linearization point Linearization point Linearization point 35 spcl.inf.ethz.ch @spcl_eth Identify one atomic step where the method “happens” ▪ Critical section ▪ Machine instruction Does not always work ▪ Might need to define several different steps for a given method ▪ Linearizability summary: ▪ Powerful specification tool for shared objects ▪ Allows us to capture the notion of objects being “atomic” Linearizability Strategy & Summary 36 spcl.inf.ethz.ch @spcl_eth Sequential Consistency 37 spcl.inf.ethz.ch @spcl_eth History 𝐻 is sequentially consistent if it can be extended to a history 𝐺 by ▪ appending zero or more responses to pending invocations that took effect ▪ discarding zero or more pending invocations that did not take effect such that G is equivalent to a legal sequential history 𝑆. (Note that →𝐺 ⊂ →𝑆 is not required, i.e., no order across threads required) (Sequential Consistency is weaker than Linearizability) Alternative: Sequential Consistency 38 spcl.inf.ethz.ch @spcl_eth ▪ Require that operations done by one thread respect program order ▪ No need to preserve real-time order ▪ Cannot re-order operations done by the same thread ▪ Can re-order operations done by different threads ▪ Often used to describe multiprocessor memory architectures Alternative: Sequential Consistency 39 spcl.inf.ethz.ch @spcl_eth Example A q.enq(x) B q.enq(y) q.deq() →y time 40 spcl.inf.ethz.ch @spcl_eth Not linearizable A q.enq(x) B q.enq(y) q.deq() →y time x is first in queue 41 spcl.inf.ethz.ch @spcl_eth Yet sequentially consistent! A q.enq(x) B q.enq(y) q.deq() →y time 42 spcl.inf.ethz.ch @spcl_eth Sequential Consistency is not a local property (and thus we lose composability…) Theorem Can somebody remind me what “composability” meant? 43 spcl.inf.ethz.ch @spcl_eth Proof by Example: FIFO Queue H = A p.enq(x) B q.enq(y) A p:void A q.enq(x) B q:void B p.enq(y) A q:void A p.deq() B p:void B q.deq(); A p:y B q:x A p.enq(x) B q.enq(y) p.deq() →y p.enq(y) time q.enq(x) q.deq() →x 44 spcl.inf.ethz.ch @spcl_eth H|q sequentially consistent H = A p.enq(x) B q.enq(y) A p:void A q.enq(x) B q:void B p.enq(y) A q:void A p.deq() B p:void B q.deq(); A p:y B q:x A p.enq(x) B q.enq(y) p.deq() →y p.enq(y) time q.enq(x) q.deq() →x 45 spcl.inf.ethz.ch @spcl_eth H|p sequentially consistent H = A p.enq(x) B q.enq(y) A p:void A q.enq(x) B q:void B p.enq(y) A q:void A p.deq() B p:void B q.deq(); A p:y B q:x A p.enq(x) B q.enq(y) p.deq() →y p.enq(y) time q.enq(x) q.deq() →x 46 spcl.inf.ethz.ch @spcl_eth Ordering imposed by H|q and H|p ➔ H is not sequentially consistentA p.enq(x) B q.enq(y) p.deq() →y p.enq(y) time q.enq(x) q.deq() →x 47 spcl.inf.ethz.ch @spcl_eth Another example: Flags Each object update (H|x and H|y) is sequentially consistent Entire history is not sequentially consistent A x.write(1) B y.write(1) y.read()→0 x.read() →0 48 spcl.inf.ethz.ch @spcl_eth Reminder: Consequence for Peterson Lock (Flag Principle) Sequential Consistency → At least one of the processes A and B read flag[1-id] = true. If both processes read flag = true then both processes eventually read the same value for victim(). A flag[0].write(true) B flag[1].write(true) flag[1].read()→ ? flag[0].read() → ? flag[id] = true; victim = id; while (flag[1-id] && victim == id); victim.write(0) victim.write(1) victim.read() → ? victim.read() → ? 49 spcl.inf.ethz.ch @spcl_eth Another idea: Programs should respect real-time order of algorithms separated by periods of quiescence. Side Remark: Quiescent Consistency A q.deq() → X B q.size() → n q.enq(X) … quiescence… 50 In other words: quiescent consistency requires non-overlapping methods to take effect in their real-time order! spcl.inf.ethz.ch @spcl_eth Quiescent consistency is incomparable to sequential consistency: part I This example is sequentially consistent but not quiescently consistent Side Remark: Quiescent Consistency A B q.deq() → Xq.enq(Y) q.deq() → Yq.enq(X) 51 spcl.inf.ethz.ch @spcl_eth Quiescent consistency is incomparable to sequential consistency: part II This example is quiescently consistent but not sequentially consistent (note that initially the queue is empty) Side Remark: Quiescent Consistency A q.deq() → X B q.size() → 1 q.enq(X) 52 There is no quiescence, thus anything may happen (including a swap of deq and enq)! spcl.inf.ethz.ch @spcl_eth This pattern Write mine, read yours is exactly the flag principle Heart of mutual exclusion ▪ Peterson ▪ Bakery, etc. Sequential Consistency seems non- negotiable! … but: Many hardware architects think that sequential consistency is too strong Too expensive to implement in modern hardware Assume that flag principle Violated by default Honored by explicit request (e.g., volatile) Discussion Recall our discussions at the beginning! Recall our short discussion of caches 53 spcl.inf.ethz.ch @spcl_eth Memory hierarchy ▪ On modern multiprocessors, processors do not read and write directly to memory. ▪ Memory accesses are very slow compared to processor speeds. ▪ Instead, each processor reads and writes directly to a cache. While writing to memory ▪ A processor can execute hundreds, or even thousands of instructions. ▪ Why delay on every memory write? ▪ Instead, write back in parallel with rest of the program. Recall: Memories and caches 54 spcl.inf.ethz.ch @spcl_eth To read a memory location, load data into cache. To write a memory location update cached copy, lazily write cached data back to memory “Flag-violating” history is actually OK processors delay writing to memory until after reads have been issued. Otherwise unacceptable delay between read and write instructions. Writing to memory = mailing a letter Vast majority of reads & writes Not for synchronization No need to idle waiting for post office If you want to synchronize Announce it explicitly Pay for it only when you need it Recall: Memory operations 55 spcl.inf.ethz.ch @spcl_eth Explicit Memory barrier instruction Flush unwritten caches Bring caches up to date Compilers often do this for you Entering and leaving critical sections Implicit In Java, can ask compiler to keep a variable up-to-date with volatile keyword Also inhibits reordering, removing from loops & other optimizations Synchronization 56 spcl.inf.ethz.ch @spcl_eth Weaker than sequential consistency But you can get sequential consistency at a price [1] Concept of linearizability more appropriate for high-level software Real-World Hardware Memory [1]: H. Schweizer, M. Besta, T. Hoefler: Evaluating the Cost of Atomic Operations on Modern Architectures, ACM PACT’15 57 spcl.inf.ethz.ch @spcl_eth Linearizability Operation takes effect instantaneously between invocation and response Uses sequential specification, locality implies composablity Good for high level objects Sequential Consistency Not composable but simpler Harder to work with in software development Good way to think about hardware models Linearizability vs. Sequential Consistency 58 spcl.inf.ethz.ch @spcl_eth Consensus Literature: Herlihy: Chapter 5.1-5.4, 5.6-5.8 59","libVersion":"0.3.2","langs":""}