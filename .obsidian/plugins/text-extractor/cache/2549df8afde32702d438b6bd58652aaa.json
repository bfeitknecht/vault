{"path":"sem2/DDCA/VRL/slides/DDCA-L12b-MIPS-ASM.pdf","text":"C a r ne gi e M e l l on 1 D i g i t a l D e s i g n a nd C o m put e r A r c hi t e c t ur e M o ha m m a d S a dr o s a da t i F r a nk K . G ür k a y na k A d a p t e d f r o m D i g i t a l D e s i g n a n d C o m p u t e r A r c h i t e c t u r e , D a v i d M o n e y H a r r i s & S a r a h L . H a r r i s © 2 0 0 7 E l s e v i e r http:// safari.ethz.ch / ddca MI P S P r o g r a m m i ng C a r ne gi e M e l l on 2 In T h is Lec tu r e ¢ Sm al l r e vi e w f r o m l as t w e e k ¢ P r o gr a m m i n g ( c o n t i n u e d ) ¢ A d d r e s s i n g M o d e s ¢ L i gh t s , C a m e r a , A c t i o n : C o m p i l i n g, A s s e m b l i n g, a n d L o a d i n g ¢ Od d s an d E n d s C a r ne gi e M e l l on 3 As s e m bl y L a ngua ge ¢ T o c o m m a n d a c o m p u t e r , yo u m u s t u n d e r s t a n d i t s l a n gu a ge § In s t r u c t i o n s : w o r ds i n a c o m put e r ’ s l a ng ua g e § In s t r u c t i o n s e t : t he v o c a bul a r y o f a c o m put e r ’ s l a ng ua g e ¢ In s t r u ct ion s in d ica t e t h e op e r a t ion t o p e r f or m a n d t h e op e r a n d s t o u s e § As s e m b l y l a n g u a g e : hum a n - r e a da bl e f o r m a t o f i ns t r uc t i o ns § Ma c h i n e l a n g u a g e : c o m put e r - r e a da bl e f o r m a t ( 1 ’ s a nd 0 ’s ) ¢ MI P S ar c h i t e c t u r e : § D e v e l o pe d by J o hn H e nne s s y a nd c o l l e a g ue s a t S t a nf o r d i n t he 1 9 8 0 ’ s § U s e d i n m a ny c o m m e r c i a l s y s t e m s ( S i l i c o n G r a phi c s , N i nt e ndo , C i s c o ) ¢ O n c e yo u ’ v e l e a r n e d o n e a r c h i t e c t u r e , i t ’ s e a s y t o l e a r n o t h e r s C a r ne gi e M e l l on 4 Ope r a nds : R e g i s t e r s ¢ M a i n M e m o r y i s s l o w ¢ M o s t a r c h i t e c t u r e s h a v e a s m a l l s e t o f ( f a s t ) r e gi s t e r s § M I P S ha s t hi r t y - tw o 3 2 - bi t r e g i s t e r s ¢ MI P S i s c al l e d a 3 2 - bi t a rc hi t e c t ure be c a us e i t o pe ra t e s o n 32 - bi t da t a § A 6 4 - bi t v e r s i o n o f M I P S a l s o e x i s t s , but w e w i l l c o ns i de r o nl y t he 3 2 - bi t v e r s i o n C a r ne gi e M e l l on 5 The M I P S R e gi s t e r S e t Na m e Re g i s te r N u m b e r Us a g e $0 0 t he c o ns t a n t v a l ue 0 $at 1 a s s e m bl e r t e m po r a r y $v0 - $v1 2 - 3 pr o c e dur e r e t ur n v a l ue s $a0 - $a3 4 - 7 pr o c e dur e a r g um e n t s $t0 - $t7 8 - 15 t e m po r a r i e s $s0 - $s7 16 - 23 s a v e d v a r i a bl e s $t8 - $t9 24 - 25 m o r e t e m po r a r i e s $k0 - $k1 26 - 27 O S t e m po r a r i e s $ gp 28 g l o ba l po i n t e r $ sp 29 s t a c k po i n t e r $ fp 30 f r a m e po i n t e r $ ra 31 pr o c e dur e r e t ur n a ddr e s s C a r ne gi e M e l l on 6 Ope r a nds : Me m o r y ¢ T o o m u c h d a t a t o f i t i n o n l y 3 2 r e gi s t e r s ¢ St o r e m o r e d at a i n m e m o r y § M e m o r y i s l a r g e , s o i t c a n ho l d a l o t o f da t a § B ut i t ’s a l s o s l o w ¢ C o m m o n l y u s e d v a r i a b l e s k e p t i n r e gi s t e r s ¢ U s i n g a c o m b i n a t i o n o f r e gi s t e r s a n d m e m o r y, a p r o gr a m c a n a c c e s s a l a r ge a m o u n t o f d a t a f a i r l y q u i c k l y C a r ne gi e M e l l on 7 Ma c hi ne La ng ua g e ¢ C o m p u t e r s o n l y u n d e r s t a n d 1 ’ s a n d 0 ’s ¢ M a c h i n e l a n gu a ge : b i n a r y r e p r e s e n t a t i o n o f i n s t r u c t i o n s ¢ 32 - bi t i ns t ruc t i o ns § A g a i n, s i m pl i c i t y f a v o r s r e g ul a r i t y : 3 2 - bi t da t a , 3 2 - bi t i ns t r uc t i o ns , a nd po s s i bl y a l s o 3 2 - bi t a ddr e s s e s ¢ Thr e e i ns t r uc t i o n f o r ma t s : § R - Ty p e : r e g i s t e r o pe r a nds § I - Ty p e : i m m e di a t e o pe r a nd § J - Ty p e : f o r j um pi ng ( w e ’ l l di s c us s l a t e r ) C a r ne gi e M e l l on 8 R - Ty pe ¢ R e gi s t e r - t yp e , 3 r e gi s t e r o p e r a n d s : § rs , rt : s o ur c e r e g i s t e r s § rd : de s t i na t i o n r e g i s t e r ¢ Ot h e r f i e l d s : § op : t he o pe r a t i o n c o de o r o pc o de (0 f o r R - t y pe i ns t r uc t i o ns ) § fu n c t : t he f unc t i o n t o g e t he r , t he o pc o de a nd f unc t i o n t e l l t he c o m put e r w ha t o pe r a t i o n t o pe r f o r m § sh a m t : t he s hi f t a m o unt f o r s hi f t i ns t r uc t i o ns , o t he r w i s e i t ’s 0 op rs rt rdshamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits R-Type C a r ne gi e M e l l on 9 R - Ty pe E x a m pl e s add $s0, $s1, $s2 sub $t0, $t3, $t5 Assembly Code 0 17 18 16 0 32 Field Values 0 11 13 8 0 34 op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits5 bits 6 bits 000000 10001 10010 10000 00000 100000 op rs rt rd shamt funct 000000 01011 01101 01000 00000 100010 Machine Code 6 bits 5 bits 5 bits 5 bits5 bits 6 bits (0x02328020) (0x016D4022) No t e t he o r de r o f r e g i s t e r s i n t he a s s e m bl y c o de : add rd , rs , rt C a r ne gi e M e l l on 10 Re vi e w : I n s t ru c t i o n Fo rmat s op rs rt rdshamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits R-Type op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type op addr 6 bits 26 bits J-Type C a r ne gi e M e l l on 11 T h e P o w e r o f t h e S t o r e d P r o g r a m ¢ 32 - bi t i ns t ruc t i o ns a nd da t a s t o re d i n me mo ry ¢ S e q u e n c e o f i n s t r u c t i o n s : o n l y d i f f e r e n c e b e t w e e n t w o a p p l i c a t i o n s ( f o r e x a m p l e , a t e x t e d i t o r a n d a v i d e o ga m e ) ¢ T o r u n a n e w p r o gr a m : § N o r e w i r i ng r e qui r e d § S i m pl y s t o r e ne w pr o g r a m i n m e m o r y ¢ T h e p r o c e s s o r h a r d w a r e e x e c u t e s t h e p r o gr a m : § f e t c he s ( r e a ds ) t he i ns t r uc t i o ns f r o m m e m o r y i n s e que nc e § pe r f o r m s t he s pe c i f i e d o pe r a t i o n C a r ne gi e M e l l on 12 Pro g ram c o u n t e r ¢ T h e p r o c e s s o r h a r d w a r e e x e c u t e s t h e p r o gr a m : § f e t c he s ( r e a ds ) t he i ns t r uc t i o ns f r o m m e m o r y i n s e que nc e § pe r f o r m s t he s pe c i f i e d o pe r a t i o n § c o nt i nue s w i t h t he ne x t i ns t r uc t i o n ¢ T h e p r o gr a m c o u n t e r ( P C ) k e e p s t r a c k o f t h e c u r r e n t in s t ru ct ion § I n M I P S , pr o g r a m s t y pi c a l l y s t a r t a t m e m o r y a ddr e s s 0x00400000 C a r ne gi e M e l l on 13 Re vi e w : T h e St o re d Pro g ram addi $t0, $s3, -12 Machine CodeAssembly Code lw $t2, 32($0) add $s0, $s1, $s2 sub $t0, $t3, $t5 0x8C0A0020 0x02328020 0x2268FFF4 0x016D4022 Address Instructions 0040000C 016D4022 2268FFF4 02328020 8C0A0020 00400008 00400004 00400000 Stored Program Main Memory PC C a r ne gi e M e l l on 14 In ter p r etin g M a c h in e La n g u a g e C od e ¢ St ar t w i t h op cod e § O pc o de t e l l s ho w t o pa r s e t he r e m a i ni ng bi t s ¢ If op cod e is a ll 0 ’ s § R - t y pe i ns t r uc t i o n § F unc t i o n bi t s t e l l w ha t i ns t r uc t i o n i t i s ¢ Ot h e r w i s e § o pc o de t e l l s w ha t i ns t r uc t i o n i t i s 001000 10001 10111 1111 1111 1111 0001 op rs rt imm addi $s7, $s1, -15 Machine Code Assembly Code 8 17 23 -15 Field Values (0x2237FFF1) op rs rt imm 2 2 3 7 F F F 1 000000 10111 10011 01000 00000 100010 op rs rt rd shamt funct sub $t0, $s7, $s3 0 23 19 8 0 34(0x02F34022) op rs rt rd shamt funct 0 2 F 3 4 0 2 2 C a r ne gi e M e l l on 15 Br a n c h i n g ¢ A l l o w s a p r o gr a m t o e x e c u t e i n s t r u c t i o n s o u t o f s e q u e n c e ¢ Co n d i ti o n a l b ra n c h e s § br a nc h i f e qua l : beq (I - t y pe ) § br a nc h i f no t e qua l : bne (I - t y pe ) ¢ Un c o n di t i o n al br an c h e s § j um p: j (J - t y pe ) § j um p r e g i s t e r : jr (R - t y pe ) § j um p a nd l i nk : jal (J - t y pe ) th e se a r e th e o n l y tw o J - typ e i n s tru c ti o n s C a r ne gi e M e l l on 16 Co n d i t i o n al B ran c h i n g ( beq ) # MIPS assembly addi $s0, $0, 4 addi $s1, $0, 1 sll $s1, $s1, 2 beq $s0, $s1, target addi $s1, $s1, 1 sub $s1, $s1, $s0 target: add $s1, $s1, $s0 La b e ls i n d i c a t e i n s t r u c t i o n l o c a t i o n s i n a p r o gr a m . T h e y c a n n o t u s e r e s e r v e d w o r d s a n d m u s t b e f o l l o w e d b y a c o l o n ( :) . Bl a c k b o a r d C a r ne gi e M e l l on 17 Co n d i t i o n al B ran c h i n g ( beq ) # MIPS assembly addi $s0, $0, 4 # $s0 = 0 + 4 = 4 addi $s1, $0, 1 # $s1 = 0 + 1 = 1 sll $s1, $s1, 2 # $s1 = 1 << 2 = 4 beq $s0, $s1, target # branch is taken addi $s1, $s1, 1 # not executed sub $s1, $s1, $s0 # not executed target: # label add $s1, $s1, $s0 # $s1 = 4 + 4 = 8 La b e ls i n d i c a t e i n s t r u c t i o n l o c a t i o n s i n a p r o gr a m . T h e y c a n n o t u s e r e s e r v e d w o r d s a n d m u s t b e f o l l o w e d b y a c o l o n ( :) . C a r ne gi e M e l l on 18 The B r a nc h N o t Ta k e n ( bne ) # MIPS assembly addi $s0, $0, 4 # $s0 = 0 + 4 = 4 addi $s1, $0, 1 # $s1 = 0 + 1 = 1 sll $s1, $s1, 2 # $s1 = 1 << 2 = 4 bne $s0, $s1, target # branch not taken addi $s1, $s1, 1 # $s1 = 4 + 1 = 5 sub $s1, $s1, $s0 # $s1 = 5 – 4 = 1 target: add $s1, $s1, $s0 # $s1 = 1 + 4 = 5 C a r ne gi e M e l l on 19 Un c on d i ti on a l B r a n c h i n g / J u mp i n g ( j ) # MIPS assembly addi $s0, $0, 4 # $s0 = 4 addi $s1, $0, 1 # $s1 = 1 j target # jump to target sra $s1, $s1, 2 # not executed addi $s1, $s1, 1 # not executed sub $s1, $s1, $s0 # not executed target: add $s1, $s1, $s0 # $s1 = 1 + 4 = 5 C a r ne gi e M e l l on 20 Un c on d i ti on a l B r a n c h i n g ( jr ) # MIPS assembly 0x00002000 addi $s0, $0, 0x2010 # load 0x2010 to $s0 0x00002004 jr $s0 # jump to $s0 0x00002008 addi $s1, $0, 1 # not executed 0x0000200C sra $s1, $s1, 2 # not executed 0x00002010 lw $s3, 44($s1) # program continues C a r ne gi e M e l l on 21 Hig h - Lev el C od e C on str u c ts ¢ if sta tem en ts ¢ if/else sta tem en ts ¢ while loop s ¢ for loop s C a r ne gi e M e l l on 22 I f S t a t e m e n t if ( i == j) f = g + h; f = f – i ; # $s0 = f, $s1 = g, $s2 = h # $s3 = i, $s4 = j Hig h - lev el co d e MI P S as s e mbl y co d e C a r ne gi e M e l l on 23 I f S t a t e m e n t if ( i == j) f = g + h; f = f – i ; # $s0 = f, $s1 = g, $s2 = h # $s3 = i, $s4 = j bne $s3, $s4, L1 add $s0, $s1, $s2 L1: sub $s0, $s0, $s3 Hig h - lev el co d e MI P S as s e mbl y co d e ¢ N o t i c e t h a t t h e a s s e m b l y t e s t s f o r t h e o p p o s i t e c a s e ( i ! = j ) t h a n t h e t e s t i n t h e h i gh - le v e l cod e ( i == j ) C a r ne gi e M e l l on 24 I f / E l s e S t a t e m e n t if ( i == j) f = g + h; else f = f – i ; # $s0 = f, $s1 = g, $s2 = h # $s3 = i, $s4 = j Hig h - lev el co d e MI P S as s e mbl y co d e C a r ne gi e M e l l on 25 I f / E l s e S t a t e m e n t if ( i == j) f = g + h; else f = f – i ; # $s0 = f, $s1 = g, $s2 = h # $s3 = i, $s4 = j bne $s3, $s4, L1 add $s0, $s1, $s2 j done L1: sub $s0, $s0, $s3 done : Hig h - lev el co d e MI P S as s e mbl y co d e C a r ne gi e M e l l on 26 Wh ile Loop s // determines the power // of x such that 2x = 128 int pow = 1; int x = 0; while ( pow != 128) { pow = pow * 2; x = x + 1; } # $s0 = pow , $s1 = x Hig h - lev el co d e MI P S as s e mbl y co d e C a r ne gi e M e l l on 27 Wh ile Loop s // determines the power // of x such that 2x = 128 int pow = 1; int x = 0; while ( pow != 128) { pow = pow * 2; x = x + 1; } # $s0 = pow , $s1 = x addi $s0, $0, 1 add $s1, $0, $0 addi $t0, $0, 128 while: beq $s0, $t0, done sll $s0, $s0, 1 addi $s1, $s1, 1 j while done: Hig h - lev el co d e MI P S as s e mbl y co d e ¢ N o t i c e t h a t t h e a s s e m b l y t e s t s f o r t h e o p p o s i t e c a s e ( po w = = 1 2 8 ) t h a n t h e t e s t i n t h e h i gh - le v e l cod e ( po w != 1 2 8 ) C a r ne gi e M e l l on 28 Fo r L o o p s T h e ge n e r a l f o r m o f a f o r l o o p i s : for ( initialization ; condition ; loop operation ) loop body ¢ initialization : e x e c u t e s b e f o r e t h e l o o p b e gi n s ¢ condition: i s t e s t e d a t t h e b e gi n n i n g o f e a c h i t e r a t i o n ¢ loop operation: ex ec u tes a t th e en d o f ea c h i ter a ti o n ¢ loop body: ex ec u tes ea c h ti m e th e c o n d i ti o n i s m et C a r ne gi e M e l l on 29 Fo r L o o p s // add the numbers from 0 to 9 int sum = 0; int i; for (i = 0; i != 10; i = i+1) { sum = sum + i; } # $s0 = i , $s1 = sum Hig h - lev el co d e MI P S as s e mbl y co d e C a r ne gi e M e l l on 30 Fo r L o o p s // add the numbers from 0 to 9 int sum = 0; int i; for (i = 0; i != 10; i = i+1) { sum = sum + i; } # $s0 = i , $s1 = sum addi $s1, $0, 0 add $s0, $0, $0 addi $t0, $0, 10 for: beq $s0, $t0, done add $s1, $s1, $s0 addi $s0, $s0, 1 j for done: Hig h - lev el co d e MI P S as s e mbl y co d e ¢ N o t i c e t h a t t h e a s s e m b l y t e s t s f o r t h e o p p o s i t e c a s e ( i = = 1 0 ) t h a n t h e t e s t i n t h e h i gh - le v e l cod e ( i != 1 0 ) C a r ne gi e M e l l on 31 Less T h a n C om p a r ison s // add the powers of 2 from 1 // to 100 int sum = 0; int i ; for ( i = 1; i < 101; i = i *2) { sum = sum + i ; } # $s0 = i , $s1 = sum Hig h - lev el co d e MI P S as s e mbl y co d e C a r ne gi e M e l l on 32 Less T h a n C om p a r ison s // add the powers of 2 from 1 // to 100 int sum = 0; int i ; for ( i = 1; i < 101; i = i *2) { sum = sum + i ; } # $s0 = i , $s1 = sum addi $s1, $0, 0 addi $s0, $0, 1 addi $t0, $0, 101 loop: slt $t1, $s0, $t0 beq $t1, $0, done add $s1, $s1, $s0 sll $s0, $s0, 1 j loop done: Hig h - lev el co d e MI P S as s e mbl y co d e ¢ $t 1 = 1 i f i < 1 0 1 C a r ne gi e M e l l on 33 Ar r a y s ¢ U s e f u l f o r a c c e s s i n g l a r ge a m o u n t s o f s i m i l a r d a t a ¢ A r r a y e l e m e n t : a c c e s s e d b y i n d e x ¢ A r r a y s i z e : n u m b e r o f e l e m e n t s i n t h e a r r a y C a r ne gi e M e l l on 34 Ar r a y s ¢ 5 - el em en t a r r a y ¢ Ba s e a d d r e s s = 0x12348000 ( a d d r e s s o f t h e f i r s t a r r a y e l e m e n t , a r r a y[ 0 ] ) ¢ F i r s t s t e p i n a c c e s s i n g a n a r r a y: § L o a d ba s e a ddr e s s i nt o a r e g i s t e r array[4] array[3] array[2] array[1] array[0]0x12348000 0x12348004 0x12348008 0x1234800C 0x12340010 C a r ne gi e M e l l on 35 Ar r a y s // high - level code int array[5]; array[0] = array[0] * 2; array[1] = array[1] * 2; # MIPS assembly code # array base address = $s0 # Initialize $s0 to 0x12348000 Hig h - lev el c od e MI P S A s s e m b l y c o d e Ho w t o g e t a 3 2 - bi t a ddr e s s i n t o r e g i s t e r $ s 0 ? C a r ne gi e M e l l on 36 Ar r a y s // high - level code int array[5]; array[0] = array[0] * 2; array[1] = array[1] * 2; # MIPS assembly code # array base address = $s0 # Initialize $s0 to 0x12348000 lui $s0, 0x1234 # upper $s0 ori $s0, $s0, 0x8000 # lower $s0 Hig h - lev el c od e MI P S A s s e m b l y c o d e Ho w t o l o a d a [ 0 ] a n d a [ 1 ] i n t o a r eg i s t er ? C a r ne gi e M e l l on 37 Ar r a y s // high - level code int array[5]; array[0] = array[0] * 2; array[1] = array[1] * 2; # MIPS assembly code # array base address = $s0 # Initialize $s0 to 0x12348000 lui $s0, 0x1234 # upper $s0 ori $s0, $s0, 0x8000 # lower $s0 lw $t1, 0($s0) # $t1=array[0] sll $t1, $t1, 1 # $t1=$t1*2 sw $t1, 0($s0) # array[0]=$t1 lw $t1, 4($s0) # $t1=array[1] sll $t1, $t1, 1 # $t1=$t1*2 sw $t1, 4($s0) # array[1]=$t1 Hig h - lev el c od e MI P S A s s e m b l y c o d e C a r ne gi e M e l l on 38 Ar r a y s U s i ng F o r L o o ps // high - level code int arr [1000]; int i ; for ( i = 0; i < 1000; i = i + 1) arr [ i ] = arr [ i ] * 8; # $s0 = array base, $s1 = i lui $s0, 0x23B8 # upper $s0 ori $s0, $s0, 0xF000 # lower $s0 Hig h - lev el c od e MI P S A s s e m b l y c o d e C a r ne gi e M e l l on 39 Ar r a y s U s i ng F o r L o o ps // high - level code int arr [1000]; int i ; for ( i = 0; i < 1000; i = i + 1) arr [ i ] = arr [ i ] * 8; # $s0 = array base, $s1 = i lui $s0, 0x23B8 # upper $s0 ori $s0, $s0, 0xF000 # lower $s0 addi $s1, $0, 0 # i = 0 addi $t2, $0, 1000 # $t2 = 1000 loop: slt $t0, $s1, $t2 # i < 1000? beq $t0, $0, done # if not done sll $t0, $s1, 2 # $t0= i * 4 add $t0, $t0, $s0 # addr of arr [ i ] lw $t1, 0($t0) # $t1= arr [ i ] sll $t1, $t1, 3 # $t1= arr [ i ]*8 sw $t1, 0($t0) # arr [ i ] = $t1 addi $s1, $s1, 1 # i = i + 1 j loop # repeat done: Hig h - lev el c od e MI P S A s s e m b l y c o d e C a r ne gi e M e l l on 42 Pro c e d u re s // High level code void main() { int y; y = sum(42, 7); ... } int sum( int a, int b) { return (a + b); } ¢ De f i n i t i o n s § Ca l l e r : c a l l i ng pr o c e dur e ( i n t hi s c a s e , m a i n) § Ca l l e e : c a l l e d pr o c e dur e ( i n t hi s c a s e , s um ) C a r ne gi e M e l l on 43 Pro c e d u re Cal l i n g Co n ve n t i o n s ¢ Ca l l er : § pa s s e s a r g um e nt s t o callee § j um ps t o t he callee ¢ Ca l l ee : § pe r f o r m s t he pr o c e dur e § r e t ur ns t he r e s ul t t o c a l l e r § r e t ur ns t o t he po i nt o f c a l l § m us t no t o v e r w r i t e r e g i s t e r s o r m e m o r y ne e de d by t he c a l l e r C a r ne gi e M e l l on 44 MI P S P r o c e dur e C a l l i ng C o nv e nt i o ns ¢ Ca l l p r o c ed u r e: § j um p a nd l i nk ( jal ) ¢ Re t urn f ro m pro c e dure : § j um p r e g i s t e r ( jr ) ¢ A r gu m e n t v a l u e s : § $a0 - $a3 ¢ Re t urn v a l ue : § $v0 C a r ne gi e M e l l on 45 Pro c e d u re Cal l s int main() { simple(); a = b + c; } void simple() { return ; } 0x00400200 main: jal simple 0x00400204 add $s0,$s1,$s2 ... 0x00401020 simple: jr $ ra Hig h - lev el c od e MI P S A s s e m b l y c o d e ¢ vo i d me a ns t ha t s i mpl e do e s n’ t re t urn a v a l ue C a r ne gi e M e l l on 46 Pro c e d u re Cal l s int main() { simple(); a = b + c; } void simple() { return ; } 0x00400200 main: jal simple 0x00400204 add $s0,$s1,$s2 ... 0x00401020 simple: jr $ ra Hig h - lev el c od e MI P S A s s e m b l y c o d e ¢ jal : ju m p s t o simple an d s ave s P C + 4 i n t h e r e t u r n a d d r e s s r e gi s t e r ( $ ra ) § I n t hi s c a s e , $ ra = 0x00400204 af ter jal e x e c ut e s ¢ jr $ ra : ju m p s t o a d d r e s s i n $ ra § i n t hi s c a s e j um p t o a ddr e s s 0x00400204 C a r ne gi e M e l l on 47 In p u t A r g u m en ts a n d R etu r n V a lu es ¢ MI P S c o n ve n t i o n s : § A r g um e nt v a l ue s : $a0 - $a3 § R e t ur n v a l ue : $v0 C a r ne gi e M e l l on 48 In p u t A r g u m en ts a n d R etu r n V a lu es # MIPS assembly code # $s0 = y main : ... addi $a0, $0, 2 # argument 0 = 2 addi $a1, $0, 3 # argument 1 = 3 addi $a2, $0, 4 # argument 2 = 4 addi $a3, $0, 5 # argument 3 = 5 jal diffofsums # call procedure add $s0, $v0, $0 # y = returned value ... # $s0 = result diffofsums : add $t0, $a0, $a1 # $t0 = f + g add $t1, $a2, $a3 # $t1 = h + i sub $s0, $t0, $t1 # result = (f + g) - (h + i) add $v0, $s0, $0 # put return value in $v0 jr $ ra # return to caller // High - level code int main () { int y; ... // 4 arguments y = diffofsums (2, 3, 4, 5); ... } int diffofsums ( int f, int g, int h, int i) { int result ; result = (f + g) - (h + i); return result ; // return value } C a r ne gi e M e l l on 49 In p u t A r g u m en ts a n d R etu r n V a lu es # $s0 = result diffofsums : add $t0 , $a0, $a1 # $t0 = f + g add $t1 , $a2, $a3 # $t1 = h + i sub $s0 , $t0, $t1 # result = (f + g) - (h + i) add $v0, $s0, $0 # put return value in $v0 jr $ ra # return to caller ¢ diffofsums o v e r w r o t e 3 r e gi s t e r s : $t0 , $t1 , a n d $s0 ¢ diffofsums ca n u s e t h e sta c k t o t e m p o r a r i l y s t o r e r e gi s t e r s (c o m e s n e x t ) C a r ne gi e M e l l on 50 The S t a c k ¢ M e m o r y u s e d t o t e m p o r a r i l y s a v e var i ab l e s ¢ Like a s t a ck of d is h e s , la s t - in - fi r st - ou t ( LIF O ) q u e u e ¢ Ex p a n d s: u s e s m o r e m e m o r y w h e n mo re s pa c e i s ne e de d ¢ Co n tra c ts: u s e s l e s s m e m o r y w h e n t h e s p a c e i s n o l o n ge r n e e d e d C a r ne gi e M e l l on 51 The S t a c k ¢ G r o w s d o w n ( f r o m h i gh e r t o l o w e r m e m o r y a d d r e s s e s ) ¢ S t a c k p o i n t e r : $ sp , p o i n ts to to p o f th e sta c k Data 7FFFFFFC 12345678 7FFFFFF8 7FFFFFF4 7FFFFFF0 Address $sp 7FFFFFFC 7FFFFFF8 7FFFFFF4 7FFFFFF0 Address Data 12345678 $sp AABBCCDD 11223344 C a r ne gi e M e l l on 52 Ho w P r o c edur es us e t he S t a c k # MIPS assembly # $s0 = result diffofsums : add $t0 , $a0, $a1 # $t0 = f + g add $t1 , $a2, $a3 # $t1 = h + i sub $s0 , $t0, $t1 # result = (f + g) - (h + i ) add $v0, $s0, $0 # put return value in $v0 jr $ ra # return to caller ¢ Ca l l ed p r o c ed u r es m u st h a v e n o o th er u n i n ten d ed si d e ef f ec ts ¢ Bu t diffofsums o v e r w r i t e s 3 r e gi s t e r s : $t0 , $t1 , $s0 C a r ne gi e M e l l on 53 St o ri n g Re g i s t e r Val u e s o n t h e St ac k # $s0 = result diffofsums : addi $ sp , $ sp , - 12 # make space on stack # to store 3 registers sw $s0, 8($ sp ) # save $s0 on stack sw $t0, 4($ sp ) # save $t0 on stack sw $t1, 0($ sp ) # save $t1 on stack add $t0, $a0, $a1 # $t0 = f + g add $t1, $a2, $a3 # $t1 = h + i sub $s0, $t0, $t1 # result = (f + g) - (h + i ) add $v0, $s0, $0 # put return value in $v0 lw $t1, 0($ sp ) # restore $t1 from stack lw $t0, 4($ sp ) # restore $t0 from stack lw $s0, 8($ sp ) # restore $s0 from stack addi $ sp , $ sp , 12 # deallocate stack space jr $ ra # return to caller C a r ne gi e M e l l on 54 The S t a c k dur i ng diffofsums Cal l Data FC F8 F4 F0 Address $sp (a) Data FC F8 F4 F0 Address $sp (b) $s0 Data $sp (c) $t0 FC F8 F4 F0 Address ? ??stack frame $t1 C a r ne gi e M e l l on 55 Re g i s t e rs Pr e s e r v e d Ca l l ee - sa v ed = Ca l l ee mus t pr e s e r v e Non p r eser v ed Ca l l er - sa v ed = Ca l l ee ca n o v e r w r i t e $s 0 - $s 7 $t0 - $t9 $ ra $a 0 - $a 3 $ sp $v 0 - $v 1 st a c k a b o v e $ sp st a c k b e l o w $ sp C a r ne gi e M e l l on 56 St o ri n g Save d Re g i s t e rs o n t h e St ac k # $s0 = result diffofsums : addi $ sp , $ sp , - 4 # make space on stack to # store one register sw $s0, 0($ sp ) # save $s0 on stack # no need to save $t0 or $t1 add $t0, $a0, $a1 # $t0 = f + g add $t1, $a2, $a3 # $t1 = h + i sub $s0, $t0, $t1 # result = (f + g) - (h + i ) add $v0, $s0, $0 # put return value in $v0 lw $s0, 0($ sp ) # restore $s0 from stack addi $ sp , $ sp , 4 # deallocate stack space jr $ ra # return to caller wh ich o f t h e s e r e g is t e r s m a y n o t b e o v e r wr it t e n b y diffofsums ? C a r ne gi e M e l l on 57 St o ri n g Save d Re g i s t e rs o n t h e St ac k # $s0 = result diffofsums : addi $ sp , $ sp , - 4 # make space on stack to # store one register sw $s0, 0($ sp ) # save $s0 on stack # no need to save $t0 or $t1 add $t0, $a0, $a1 # $t0 = f + g add $t1, $a2, $a3 # $t1 = h + i sub $s0, $t0, $t1 # result = (f + g) - (h + i ) add $v0, $s0, $0 # put return value in $v0 lw $s0, 0($ sp ) # restore $s0 from stack addi $ sp , $ sp , 4 # deallocate stack space jr $ ra # return to caller wh ich o f t h e s e r e g is t e r s m a y n o t b e o v e r wr it t e n b y di f f o f s um s ? $s0 – he nc e i t ha s t o be s t o r e d o n t he s t a c k a nd r e s t o r e d C a r ne gi e M e l l on 58 Mul t i pl e P r o c e dur e C a l l s proc1: addi $ sp , $ sp , - 4 # make space on stack sw $ ra , 0($ sp ) # save $ ra on stack jal proc2 ... lw $ ra , 0($ sp ) # restore $s0 from stack addi $ sp , $ sp , 4 # deallocate stack space jr $ ra # return to caller C a r ne gi e M e l l on 59 Re c u rs i ve Pro c e d u re C al l // High - level code int factorial( int n) { if (n <= 1) return 1; else return (n * factorial(n - 1)); } C a r ne gi e M e l l on 60 Re c u rs i ve Pro c e d u re C al l # MIPS assembly code 0x90 factorial : addi $ sp , $ sp , - 8 # make room 0x94 sw $a0, 4($ sp ) # store $a0 0x98 sw $ ra , 0($ sp ) # store $ ra 0x9C addi $t0, $0, 2 0xA0 slt $t0, $a0, $t0 # a <= 1 ? 0xA4 beq $t0, $0, else # no : go to else 0xA8 addi $v0, $0, 1 # yes : return 1 0xAC addi $ sp , $ sp , 8 # restore $ sp 0xB0 jr $ ra # return 0xB4 else : addi $a0, $a0, - 1 # n = n - 1 0xB8 jal factorial # recursive call 0xBC lw $ ra , 0($ sp ) # restore $ ra 0xC0 lw $a0, 4($ sp ) # restore $a0 0xC4 addi $ sp , $ sp , 8 # restore $ sp 0xC8 mul $v0, $a0, $v0 # n * factorial (n - 1) 0xCC jr $ ra # return C a r ne gi e M e l l on 61 St ac k d u ri n g Re c u rs i ve Cal l $sp FC F8 F4 F0 $ra EC E8 E4 E0 DC FC F8 F4 F0 EC E8 E4 E0 DC FC F8 F4 F0 EC E8 E4 E0 DC $sp $sp $sp $sp $a0 = 1 $v0 = 1 x 1 $a0 = 2 $v0 = 2 x 1 $a0 = 3 $v0 = 3 x 2 $v0 = 6 $sp $sp $sp $sp DataAddress DataAddress DataAddress $a0 (0x3) $ra (0xBC) $a0 (0x2) $ra (0xBC) $a0 (0x1) $ra $a0 (0x3) $ra (0xBC) $a0 (0x2) $ra (0xBC) $a0 (0x1) C a r ne gi e M e l l on 62 Pro c e d u re Cal l Su mmary ¢ Ca l l er § P ut a r g um e nt s i n $a0 - $a3 § S a v e a ny r e g i s t e r s t ha t a r e ne e de d ( $ ra , m a y be $t0 - t9 ) § jal callee § Re s t o re re g i s t e rs § L o o k f o r r e s ul t i n $v0 ¢ Ca l l ee § S a v e r e g i s t e r s t ha t m i g ht be di s t ur be d ($s0 - $s7 ) § P e r f o r m pr o c e dur e § P ut r e s ul t i n $v0 § Re s t o re re g i s t e rs § jr $ ra C a r ne gi e M e l l on 63 Addr e s s i ng M o de s ¢ Ho w do w e a ddre s s t he o pe ra nds ? § R e g i s t e r O nl y § I m m e di a t e § B a s e A ddr e s s i ng § PC - Re l a t i v e § P s e udo D i r e c t C a r ne gi e M e l l on 64 Re g i s t e r O n l y A d d re s s i n g ¢ O p e r a n d s f o u n d i n r e gi s t e r s § Ex a m p l e : add $s0, $t2, $t3 § Ex a m p l e : sub $t8, $s1, $0 C a r ne gi e M e l l on 65 Im m ed ia te A d d r essin g ¢ 16 - bi t i mme di a t e us e d a s a n o pe ra nd § Ex a m p l e : addi $s4, $t5, - 73 § Ex a m p l e : ori $t3, $t7, 0xFF C a r ne gi e M e l l on 66 Ba s e A d d r e s s i n g ¢ Ad d r e s s of op e r a n d i s : base address + sign - extended immediate § Ex a m p l e : lw $s4, 72($0) A ddr e s s = $0 + 72 § Ex a m p l e : sw $t2, - 24($t1) A ddr e s s = $t1 - 24 C a r ne gi e M e l l on 67 PC - Re l at i ve A d d re s s i n g 0x10 beq $t0, $0, else 0x14 addi $v0, $0, 1 0x18 addi $ sp , $ sp , i 0x1C jr $ ra 0x20 else: addi $a0, $a0, - 1 0x24 jal factorial beq $t0, $0, else Assembly Code Field Values 4 8 0 3 op rs rt imm 6 bits 5 bits5 bits5 bits5 bits 6 bits (beq $t0, $0, 3) C a r ne gi e M e l l on 68 Ps e u d o - di r e c t Addr e s s i ng 0x0040005C jal sum ... 0x004000A0 sum: add $v0, $a0, $a1 0000 0000 0100 0000 0000 0000 1010 0000JTA 26-bit addr (0x0100028) (0x004000A0) 0000 0000 0100 0000 0000 0000 1010 0000 0 1 0 0 0 2 8 000011 00 0001 0000 0000 0000 0010 1000 op addr Machine CodeField Values 3 0x0100028 6 bits 26 bits (0x0C100028) op imm 6 bits 26 bits C a r ne gi e M e l l on 69 Ho w D o W e C o m pile & R un a n A pplic a t io n? Assembly Code High Level Code Compiler Object File Assembler Executable Linker Memory Loader Object Files Library Files C a r ne gi e M e l l on 70 Wh a t n eed s to b e stor ed in m em or y ? ¢ In s t r u ct ion s ( a ls o ca lle d t e x t ) ¢ Da t a § G l o ba l / s t a t i c : a l l o c a t e d be f o r e pr o g r a m be g i ns § D y na m i c : a l l o c a t e d w i t hi n pr o g r a m ¢ H o w b i g i s m e m o r y? § At m o s t 2 32 = 4 g i g a by t e s ( 4 G B ) § F r o m a ddr e s s 0x00000000 to 0xFFFFFFFF C a r ne gi e M e l l on 71 The M I P S M e m o r y M a p SegmentAddress 0xFFFFFFFC 0x80000000 0x7FFFFFFC 0x10010000 0x1000FFFC 0x10000000 0x0FFFFFFC 0x00400000 0x003FFFFC 0x00000000 Reserved Stack Heap Static Data Text Reserved Dynamic Data C a r ne gi e M e l l on 72 Ex a m p l e P r o g r a m : C C o d e int f, g, y; // global variables int main(void) { f = 2; g = 3; y = sum(f, g); return y; } int sum( int a, int b) { return (a + b); } C a r ne gi e M e l l on 73 Ex a m p l e P r o g r a m : A s s e m b l y C o d e int f, g, y; // global int main(void) { f = 2; g = 3; y = sum(f, g); return y; } int sum( int a, int b) { return (a + b); } .data f: g: y: .text main: addi $ sp , $ sp , - 4 # stack sw $ ra , 0($ sp ) # store $ ra addi $a0, $0, 2 # $a0 = 2 sw $a0, f # f = 2 addi $a1, $0, 3 # $a1 = 3 sw $a1, g # g = 3 jal sum # call sum sw $v0, y # y = sum() lw $ ra , 0($ sp ) # rest. $ ra addi $ sp , $ sp , 4 # rest. $ sp jr $ ra # return sum: add $v0, $a0, $a1 # $v0= a+b jr $ ra # return C a r ne gi e M e l l on 74 Ex a m p l e P r o g r a m : S ym b o l T a b l e S ym b o l Ad d r e s s f 0x10000000 g 0x10000004 y 0x10000008 ma i n 0x00400000 su m 0x0040002C C a r ne gi e M e l l on 75 Ex a m p l e P r o g r a m : Ex e c u t a b l e Executable file header Text Size Data Size Text segment Data segment Address Instruction Address Data 0x00400000 0x00400004 0x00400008 0x0040000C 0x00400010 0x00400014 0x00400018 0x0040001C 0x00400020 0x00400024 0x00400028 0x0040002C 0x00400030 addi $sp, $sp, -4 sw $ra, 0 ($sp) addi $a0, $0, 2 sw $a0, 0x8000 ($gp) addi $a1, $0, 3 sw $a1, 0x8004 ($gp) jal 0x0040002C sw $v0, 0x8008 ($gp) lw $ra, 0 ($sp) addi $sp, $sp, -4 jr $ra add $v0, $a0, $a1 jr $ra 0x10000000 0x10000004 0x10000008 f g y 0xC (12 bytes)0x34 (52 bytes) 0x23BDFFFC 0xAFBF0000 0x20040002 0xAF848000 0x20050003 0xAF858004 0x0C10000B 0xAF828008 0x8FBF0000 0x23BD0004 0x03E00008 0x00851020 0x03E0008 C a r ne gi e M e l l on 76 Ex a m p l e P r o g r a m : I n M e m o r y y g f 0x03E00008 0x00851020 0x03E00008 0x23BD0004 0x8FBF0000 0xAF828008 0x0C10000B 0xAF858004 0x20050003 0xAF848000 0x20040002 0xAFBF0000 0x23BDFFFC MemoryAddress $sp = 0x7FFFFFFC 0x7FFFFFFC 0x10010000 0x00400000 Stack Heap $gp = 0x10008000 PC = 0x00400000 0x10000000 Reserved Reserved C a r ne gi e M e l l on 77 Odds a nd E nds ¢ Ps e udo ins t ruc t io ns ¢ Ex c e p ti o n s ¢ S i gn e d a n d u n s i gn e d i n s t r u c t i o n s ¢ Fl o a t i ng - po i nt i ns t ruc t i o ns C a r ne gi e M e l l on 78 Ps e u d o i n s t ru c t i o n E xamp l e s Ps e u d o i n s t r u c t i o n MI P S I n s t r u c t i o n s li $s0, 0x1234AA77 lui $s0, 0x1234 ori $s0, 0xAA77 mul $s0, $s1, $s2 mult $s1, $s2 mflo $s0 clear $t0 add $t0, $0, $0 move $s1, $s2 add $s2, $s1, $0 nop sll $0, $0, 0 C a r ne gi e M e l l on 79 Ex c e p t i o n s ¢ Un s c h e d u l e d p r o c e d u r e c a l l t o t h e e x c e p t i o n h a n d l e r ¢ C a u s e d b y: § H a r dw a r e , a l s o c a l l e d a n i nt e r r upt , e . g . k e y bo a r d § S o f t w a r e , a l s o c a l l e d t r a ps , e . g . unde f i ne d i ns t r uc t i o n ¢ Wh e n e x c e p t i o n o c c u r s , t h e p r o c e s s o r : § R e c o r ds t he c a us e o f t he e x c e pt i o n § J um ps t o t he e x c e pt i o n ha ndl e r a t i ns t r uc t i o n a ddr e s s 0 x 8 0 0 0 0 1 8 0 § R e t ur ns t o pr o g r a m C a r ne gi e M e l l on 80 Ex c e p t i o n R e g i s t e r s ¢ N o t p a r t o f t h e r e gi s t e r f i l e . § C a us e § R e c o r ds t he c a us e o f t he e x c e pt i o n § E P C ( E x c e pt i o n P C ) § R e c o r ds t he P C w he r e t he e x c e pt i o n o c c ur r e d ¢ E P C a n d C a u s e : p a r t o f C o p r o c e s s o r 0 ¢ Mo ve f r o m C o p r o c e s s o r 0 § m f c 0 $ t 0 , E P C § M o v e s t he c o nt e nt s o f E P C i nt o $ t 0 C a r ne gi e M e l l on 81 Ex c e p t i o n C a u s e s Ex c e p ti o n Ca u se H a r d w a r e I n t e rru p t 0x00000000 Sy s t e m C a l l 0x00000020 Br e a kp o i n t / D i v i d e b y 0 0x00000024 U n d e f i n e d I n s t ru c t i o n 0x00000028 A ri t h m e t i c O v e rf l o w 0x00000030 C a r ne gi e M e l l on 82 Ex c e p t i o n s ¢ Pro c e s s o r sa v es ca u s e an d ex c ep ti o n PC in Ca u se an d EP C ¢ Pro c e s s o r ju m p s to ex c ep ti o n ha ndl e r (0 x 8 0 0 0 0 1 8 0 ) ¢ Ex c e p ti o n ha ndl e r : § Sa v e s re g i s t e rs o n sta c k § R e a ds t he C a us e re g i s t e r § mfc0 $t0, Cause § H a ndl e s t he e x c e pt i o n § Re s t o re s re g i s t e rs § R e t ur ns to pr o g r a m § mfc0 $k0, EPC § jr $k0 C a r ne gi e M e l l on 92 Wh a t D id We Lea r n ? ¢ H o w t o t r a n s l a t e c o m m o n p r o gr a m m i n g c o n s t r u c t s § C o ndi t o ns § L o o ps § P r o c e dur e c a l l s ¢ St ac k ¢ T h e c o m p i l e d p r o gr a m ¢ Od d s an d E n d s § F l o a t i ng po i nt ( F - t y pe ) i ns t r uc t i o ns ¢ Wh a t N e x t ? § A c t ua l l y bui l di ng t he M I P S M i c r o pr o c e s s o r ! !","libVersion":"0.3.1","langs":""}