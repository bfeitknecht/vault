{"path":"sem4/CN/UE/s/CN-u09-s.pdf","text":"Exercise 09: Spanning Tree Algorithm / Physical Layer Question 1: Control Plane (Spanning Tree Computation) Consider the local area network (LAN) shown in the figure below, where the circles B1 to B7 represent switches and the letters A to J represent the net- work (LAN) segments connecting these switches via a direct connection or a hub/repeater. Figure 1: Network topology Question 1.1 Which ports are not selected by the spanning tree algorithm? 1 Solution: The ports that are not selected (BP, “blocked ports”) are marked in red, so (A, B2), (B, B5), (I, B6). DP stands for designated port and RP for root port. The root is highlighted in blue. Question 1.2 Assume that switch B1 suffers catastrophic failure. Indicate which ports are not selected by the spanning tree algorithm after the recovery process when a new tree has been formed. Solution: We rerun the algorithm without B1 and get the following result. The ports that are not selected are: (F, B5), (I, B6) 2 Question 2: Data Plane (Forwarding) Consider hosts A, C, E and switches S1 to S6 with empty forwarding tables ini- tially, connected as the figure below shows. The address of Sx is 00:00:00:00:00:0x. Question 2.1 Which links are removed after the completion of the spanning tree? Use the lowest switch address to break ties. Solution: 3 Figure 2: Network topology 4 In the figure above the root and the spanning tree are marked in blue. ℓ24, ℓ35, ℓ56 Question 2.2 Backward Learning Fill in the forwarding table for each switch after each transmission. Assume that each transmission starts after the previous has finished and the forwarding tables have been updated. In the forwarding table, mark the port by the unique LAN segment (e.g., La, Lc) reachable using that port or the label of the link (e.g., ℓ12, ℓ23) that is connected to that port. In each cell, write only the forwarding information that gets updated and not the whole forwarding table. We already filled out two entries for you. TransmissionS1 S2 S3 S4 S5 S6 A → E A at La A at ℓ12 E → A C → A Solution: 5 TransmissionS1 S2 S3 S4 S5 S6 A → E A at La A at ℓ12 A at ℓ23 A at ℓ14 A at ℓ45 A at ℓ36 E → A E at ℓ14 - - E at ℓ45 E at Le - C → A C at ℓ12 C at ℓ23 C at Lc - - - Question 3: Encoding and Modulation Question 3.1 Multiple Choice: Which answers are correct? • In baseband modulation the bit stream is directly send onto the wire • In baseband modulation the bit stream is transmitted by sending a modu- lated carrier frequency signal • In passband modulation the bit stream is directly send onto the wire • In passband modulation the bit stream is transmitted by sending a modu- lated carrier frequency signal Solution: In baseband modulation the bit stream is directly send onto the wire. In passband modulation the bit stream is send by modulating a carrier frequency and sending this signal which now encodes the bitstream in its modulation (e.g. Amplitude Modulation or Frequency Modulation, you might know this from setting your old radio to “AM” or “FM” for receiving the signal) Question 3.2 Consider the binary message 1010 1110 0001 to be baseband encoded. Draw the message encoded using non-return-to-zero (NRZ) and non-return-to- zero-inverted (NRZI). You can assume that a high logic level maps to the bit 1 in non-return-to-zero, and that the signal starts at high logic level. Solution: In NRZ the signal directly reflects the input. In NRZI the signal is inverted for every occurring 1 in the signal. The message 1010 1110 0001 is encoded as follows: 6 Question 3.3 What is the message encoded using 4B5B? You might need the encoding table found here. Solution: Under 4B5B encoding, we map 1010 → 10110, 1110 → 11100, and 0001 → 01001, resulting in the message 1011 0111 0001 001. Question 3.4 Draw the result from Question 3.3, encoded using non-return-to-zero (NRZ) and non-return-to-zero-inverted (NRZI). You can make the same assumptions again. Solution: The message 1011 0111 0001 001 is encoded as follows: Question 3.5 Compare the resulting signals from Question 3.1 and Question 3.3. Why is it beneficial to use 4B5B encoding? Are there any disadvantages? Solution: There are more transitions in the 4B5B-encoded signal. This allows for clock recovery to prevent resynchronization after long runs of 0s or 1s. 7 Question 3.6 Match the following waveforms with their respective modulation forms. 1. Phase Key Shifting 2. Amplitude Key Shifting 3. NZR Signal of Bits 4. Frequency Key Shifting Solution 1. Phase Key Shifting → (d) 2. Amplitude Key Shifting → (b) 3. NZR Signal of Bits → (a) 4. Frequency Key Shifting → (c) Question 4: Framing & Error Correction Question 4.1 The message 0110 0111 1110 0000 0111 1110 1111 1001 is to be transmit- ted. Show the bit sequence for the message if it is encoded using the following framing methods: 1. Flag bytes with byte stuffing (FLAG = 0111 1110, ESC = 1110 0000) 2. Starting and ending flag bits with bit stuffing (FLAG = 0111 1110) Solution: 8 1. The message contains an occurrence of the ESC pattern at the second byte and an occurrence of the FLAG pattern at the third byte: 0110 0111 1110 0000 0111 1110 1111 1001 We escape each of these by inserting the ESC pattern directly before them, resulting in the stuffed byte string: 0110 0111 1110 0000 1110 0000 1110 0000 0111 1110 1111 1001 Finally, we surround the stuffed message with the flag bytes, to get the final framing: 0111 1110 0110 0111 1110 0000 1110 0000 1110 0000 0111 1110 1111 1001 0111 1110 2. Recall that in bit stuffing, we insert a zero-bit after every sequence of 5 one-bits. The above message would thus be stuffed as: 0110 0111 11010 0000 0111 11010 1111 1 0 001 The flag byte is then prepended and appended to the stuffed string. 0111 1110 0110 0111 11010 0000 0111 11010 1111 10001 0111 1110 Question 4.2 A 32-bit message is transmitted using a Hamming code. How many check bits are needed to properly detect and correct 1-bit errors in this 32-bit message? Solution: For data of length n, the length of the Hamming code is given by n + k = 2 k − 1, where k is the number of check bits to detect and correct an error in one bit (minimum Hamming distance of 3). Thus, 5 check bits can support correcting 2 5 − 5 − 1 = 26 message bits, and 6 check bits can support correcting one error in 2 6 − 6 − 1 = 57 bits. Finally, to correct an error in 32 bits, we would need 6 check bits. Question 4.3 You wish to transmit the frame containing 10010110010 with a CRC attached. Your generator polynomial is x3 + 1 and k = 3. What bit string would be transmitted? Solution: The generator polynomial converted to binary is 1 · x3 + 0 · x2 + 0 · x1 + 1 · x 0 = 1001 In the following we abuse notation such that e.g. 10 101 corresponds to x1 x2+x0 . 9 CRC encoding has 3 steps: 1. shift the message to the right by k (padded with zeros) 2. divide by the generator polynomial and compute the remainder 3. insert the remainder to the end of the original message (instead of the padded zeros) The result should be dividable by the generator with a remainder of zero. This code takes the value of the remainder of 10010110010 left-shifted by 3 bits, and divided by the generator polynomial. We compute the polynomial division: remainder( 10010110010000 1001 ) = 100 The final result is obtained by adding this code 100 to the left-shifted bit string: 10010110010100. 10","libVersion":"0.5.0","langs":""}