{"path":"sem3/TI/UE/s/TI-s-u07.pdf","text":"Departement Informatik Theoretische Informatik Prof. Dr. Dennis Komm Prof. Dr. Juraj Hromkoviˇc Dr. Hans-Joachim B¨ockenhauer Exemplary Solutions – Sheet 7 Z¨urich, November 15, 2024 Solution to Task 19 To show L′ diag ≤R LH, we assume that A is an algorithm that decides LH. Then we construct an algorithm B that uses A to decide L′ diag. The algorithm B is designed as shown in the following diagram: x ∈ Σ∗ bool B C x = w2i x = w2i+1 Kod(Mi) A L(A) = LH /∈ LH ∈ LH D w2i ∈ L(Mi) w2i /∈ L(Mi) x /∈ L′ diag x ∈ L′ diag For every input x ∈ Σ∗ bool, the subprogram C computes j ∈ N such that x = wj is the j-th word over Σbool in the canonical order. If j is odd, i.e., j = 2i + 1 for some i ∈ N, then B rejects the input x. On the other hand, if j = 2i for some i ∈ N, then C computes the code Kod(Mi) of the i-th Turing machine in the canonical order. The subprogram A for LH then gets Kod(Mi) and x = w2i as input of the form Kod(Mi)#x. If A rejects the input Kod(Mi)#x, then Mi does not halt on w2i, i.e., Mi does not accept the word w2i either. Hence, w2i ∈ L′ diag and B accepts its input x = w2i. If A accepts the input Kod(Mi)#x, then Mi halts on w2i. In this case, the subprogram D simulates Mi on w2i. This simulation is guaranteed to end in finite time. If the simulation shows that Mi accepts the word w2i, then w2i /∈ L′ diag and B rejects its input x = w2i. Otherwise, Mi rejects the word w2i, then w2i ∈ L ′ diag and B accepts its input x = w2i. Solution to Task 20 (a) To show Lunion ∈ LRE, we construct a 3-tape Turing machine A for Lunion. This suffices because multitape Turing machines and Turing machines are equivalent by Theorem 4.17. in the textbook. The 3-tape Turing machine A first checks if the input is valid, i.e., if it consists of the codes of two Turing machines M and M ′ and one word w. If this is not the case, then A rejects. Otherwise, A first copies the input on the second working tape, then brings the reading head and the head on the second working tape to the beginning of the respective tape, and finally simulates in parallel M on w using the first working tape and M ′ on w using the second and third working tape, where the second working tape is used as the input tape of M ′. If one of the two simulated machines accepts w, then A accepts its input as well. If both M and M ′ reject the word w, then A rejects as well. If one of the two machines M and M ′ does not halt and the other one rejects or does not halt, then A does not halt either. Hence, A is a Turing machine that accepts the language Lunion. Note that a sequential simulation of the two machines M and M ′ is not possible because M might not halt on w, but M ′ could accept w. (b) To show LU ≤m Lunion, we must provide an algorithm that transform inputs for LU into inputs for Lunion so that exactly the accepting inputs for LU are map- ped to accepting inputs for Lunion. Every word over {0, 1, #} that does not have the form Kod(M )#w, for any Turing machine M and any word w, gets mapped to λ because λ /∈ Lunion. Every word of the form Kod(M )#w gets mapped to Kod(M )#Kod(M )#w, which is a valid input for Lunion. Moreover, we have Kod(M )#Kod(M )#w ∈ Lunion ⇐⇒ Kod(M )#w ∈ LU . Hence, LU ≤m Lunion is proved. (c) To show Lunion ≤m LU, we provide a computable function that transforms valid inputs for Lunion into valid inputs for LU. Invalid inputs (i.e., inputs that do not have the form Kod(M )#Kod(M ′)#w) get again mapped to λ /∈ LU. Every input of the form Kod(M )#Kod(M ′)#w gets mapped to Kod(A)#w, where A is a Turing machine that simulates M and M ′ in parallel, as described in part (a). Then we have Kod(M )#Kod(M ′)#w ∈ Lunion ⇐⇒ w ∈ L(M ) ∪ L(M ′) ⇐⇒ w ∈ L(A) ⇐⇒ Kod(A)#w ∈ LU. Hence, Lunion ≤m LU is proved.","libVersion":"0.3.2","langs":""}