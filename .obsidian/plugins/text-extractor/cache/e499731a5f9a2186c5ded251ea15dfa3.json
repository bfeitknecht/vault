{"path":"sem2/PProg/VRL/extra/kuhn/PProg-w03-kuhn.pdf","text":"Parallel Programming Session 3 Spring 2024 Schedule assignment 2 post-discussion synchronized wait/no7fy Pre-Discussion assignment 3 Quiz Concurrency vs Parallelism 3 Thread A Thread B Thread C Thread A Thread B Thread C Thread A Concurrent, not parallel Concurrent, parallel Not concurrent, not parallel Concurrency vs Parallelism 4 Concurrency Dealing with mul)ple things at the same )me Reasoning about and managing shared resources. O8en used interchangeably with parallelism. Parallelism Doing mul)ple things at the same )me Performing computa)ons simultaneously; either actually, if suﬃcient computa)ons units (CPUs, cores, ...) are available, or virtually, via some form of alterna)on. O>en used interchangeably with concurrency. Parallelism can be speciﬁed explicitly by manually assigning tasks to threads or implicitly by using a framework that takes care of distribu7ng tasks to threads. Source: hFps://cgl.ethz.ch/teaching/parallelprog24/pages/terminology.html Past Exam Task 5 essentials Rep. Exam, FS 2023 Past Exam Task 6 essentials Rep. Exam, FS 2023 Past Exam Task 7 essentials Rep. Exam, FS 2023 Past Exam Task 8 essentials Rep. Exam, FS 2023 Post-Discussion Ex.2 Post-Discussion Ex.2a ! Post-Discussion Ex.2a What if we change t.start() to t.run()? Can we say something about the thread ? Post-Discussion Ex.2a t.start(); t.run(); Post-Discussion Ex.2b 1.) Run method computePrimeFactors in a single thread other than main thread. 2.)Measure the execuDon Dme of sequenDal execuDon (main thread) vs. single thread (new thread) -> diﬀerence ? Post-Discussion Ex.2b 1.) What method do I want to run? à o:en already given: here: ComputePrimeFactors if not given: just write „normal sequenHal code“ “Recipe“: Post-Discussion Ex.2b 1.) What method do I want to run? à o:en already given: here: ComputePrimeFactors if not given: just write „normal sequenHal code“ 2.) Look at the method you want to run: What is input and output -> important for thread class. „Recipe“: Post-Discussion Ex.2b Input = Int Array & Ouput = Int Array à Threads need to know about it -> work with it Post-Discussion Ex.2b 1.) What method do I want to run? à o:en already given: here: ComputePrimeFactors if not given: just write „normal sequenHal code“ 2.) Look at the method you want to run: What is input and output -> important for thread class. 3.) Create the thread class accorrding to your problem/method. „Recipe“ : Post-Discussion Ex.2b Because we know computePrimeFactors needs an arrray as input Post-Discussion Ex.2b Because we know computePrimeFactors needs an arrray as input Post-Discussion Ex.2b Because we know computePrimeFactors needs an arrray as input Something is s,ll missing/wrong ? Post-Discussion Ex.2b Because we know computePrimeFactors needs an arrray as input RETURN DATA Post-Discussion Ex.2b exactly what your method inputs and outputs Post-Discussion Ex.2b How can we then get the threads work from outside ? Run() doesn‘t return anything… Post-Discussion Ex.2b Access threads work via 2-steps: 1.) in run method thread writes to data Post-Discussion Ex.2b Access threads work via 2-steps: 1.) in run method thread writes to data 2.) write method to return thread local data Post-Discussion Ex.2b 1.) What method do I want to run? à o:en already given: here: ComputePrimeFactors if not given: just write „normal sequenHal code“ 2.) Look at the method you want to run: What is input and output -> important for thread class. 3.) Create the thread class accorrding to your problem/method. thread local data according to funcHon input and output data. + make sure we can access the thread data from extern.(e.g. getResult() method) „Recipe“: Post-Discussion Ex.2b 1.) What method do I want to run? à o:en already given: here: ComputePrimeFactors if not given: just write „normal sequenHal code“ 2.) Look at the method you want to run: What is input and output -> important for thread class. 3.) Create the thread class accorrding to your problem/method. thread local data according to funcHon input and output data. + make sure we can access the thread data from extern.(e.g. getResult() method) 4.) create the threads in the main-method/ main code ﬁle. Input the correct data ! Start them J „Recipe“: Post-Discussion Ex.2b In the main code ﬁle Post-Discussion Ex.2bPost-Discussion Ex.2bPost-Discussion Ex.2bPost-Discussion Ex.2b the work of the thread Post-Discussion Ex.2b 1.) What method do I want to run? à o:en already given: here: ComputePrimeFactors if not given: just write „normal sequenHal code“ 2.) Look at the method you want to run: What is input and output -> important for thread class. 3.) Create the thread class accorrding to your problem/method. thread local data according to funcHon input and output data. + make sure we can access the thread data from extern.(e.g. getResult() method) 4.) create the threads in the main-method/ main code ﬁle. Input the correct data ! Start them J „Recipe“: Post-Discussion Ex.2b 1.) Run method computePrimeFactors in a single thread other than main thread. 2.) Measure the execuDon Dme of sequenDal execuDon (main thread) vs. single thread (new thread) -> diﬀerence ? Post-Discussion Ex.2b general ,pp: write sub-methods to keep an overview ! Post-Discussion Ex.2b Call from main thread: messure time: take average time Post-Discussion Ex.2b Same new thread Post-Discussion Ex.2b What do we no,ce ? Post-Discussion Ex.2b What do we no,ce ? Post-Discussion Ex.2c Overhead L threads are not free…. Post-Discussion Ex.2c Let‘s messure it: empty run() method Post-Discussion Ex.2c Let‘s messure it: add timer aka wrap it in a timer Post-Discussion Ex.2c Overhead L threads are not free…. Post-Discussion Ex.2d Split array: prepare the data to give to the individual threads Given: Take the whole array and divide it into objects of ArraySplit Post-Discussion Ex.2d Real-world: use existing libraries etc. -> fast, tested e.g parallel streams in Java Post-Discussion Ex.2E Compute primeFactor Array via Threads -> if you are lost, maybe little recipe helps/ gives intuition :) Post-Discussion Ex.2E Each thread should call computePrimeFactors on a given Array Part -> we deﬁned the Array Split in Task D needs to know Array Part, hence: amount of numbers in its part start& end index size of the array part it should work on Post-Discussion Ex.2E Write method that return us the threads -> convenient Allows each thread to work on a part of the array we assign it to Post-Discussion Ex.2E Prepare the work-packets to give to the threads. Post-Discussion Ex.2E Create the threads and assign a work-packet to each Post-Discussion Ex.2E Create the threads and assign a work-packet to each Remember: returns a thread with the following run() method Post-Discussion Ex.2E Create the threads and assign a work-packet to each l sizefactors Post-Discussion Ex.2EPost-Discussion Ex.2E Why do we ﬁrst start all of them and then a>er join all of them, we not start -> join -> start -> join etc. ? Theory Recap bad interleavingNeed to synchronizeWhy synchronize Interleavings: possible execu,on order Bad interleaving: faulty execu,on order, yields wrong result Why synchronize Interleavings: possible execu,on order Bad interleaving: faulty execu,on order, yields wrong result Race condi,on: execu,on of program depends on real-,me execu,on order -> scheduler! When bad interleavings are possible Why synchronize Interleavings: possible execu,on order Bad interleaving: faulty execu,on order, yields wrong result Race condi,on: execu,on of program depends on real-,me execu,on order -> scheduler! When bad interleavings are possible Cri,cal sec,on: Code that only one thread at a ,me should execute to guarantee program correctness Why synchronize Interleavings: possible execu,on order Bad interleaving: faulty execu,on order, yields wrong result Race condi,on: execu,on of program depends on real-,me execu,on order -> scheduler! When bad interleavings are possible Cri,cal sec,on: Code that only one thread at a ,me should execute to guarantee program correctness Mutual Exclusion: property than only one thread can enter at the same ,me That’s why we need locks SynchronizaDon: monitors/synchronize wait() & noDfy() Others: atomic variables That’s why we need locks SynchronizaDon: monitors/synchronize wait() & noDfy() Others: atomic variables Synchronize “Lock()” “Unlock()” Synchronize Could be any object: counter, buﬀer etc. That’s why we need locksThat’s why we need lockssynchronize Every reference type contains a lock inherited from the Object class synchronize Every reference type contains a lock inherited from the Object class lock is automa&cally acquired when entering and released when exiDng a synchronized block synchronize Every reference type contains a lock inherited from the Object class lock is automa&cally acquired when entering and released when exiDng a synchronized block A thread can obtain mulDple locks (by nesDng the synchronized blocks) synchronize Every reference type contains a lock inherited from the Object class lock is automa&cally acquired when entering and released when exiDng a synchronized block A thread can obtain mulDple locks (by nesDng the synchronized blocks) Locks will be covered in more detail later in the course synchronize Synchronized method locks on the object owning the method synchronize Synchronized method locks on the object owning the method Object.xMethod() //lock on the Object synchronizesynchronize Synchronized keyword obtains a lock on the parameter object synchronized (bar) { … } //lock on bar Synchronize Sychnroinzed Monitor/intrinsic Lock What if we have a staDc method ? Methods we call without an object ( aka no „this“). Monitor/intrinsic Lock What if we have a staDc method ? Methods we call without an object ( aka no „this“). Call it on the whole class Monitor/intrinsic Lock What if we have a staDc method ? Methods we call without an object. Synchronize on the myClass.Object Monitor/intrinsic Lock What if we have a staDc method ? Methods we call without an object. Synchronize on the myClass.Object Let’s testLet’s testLet’s testReentrance REENTRANT aka this code works correctly. That’s why we need locks SynchronizaDon: monitors/synchronize wait() & no4fy() atomic variables locks (2nd part) We saw this…Correct? Synchronized both critical sections, is the code now correct ? Wait& Notify Each reference type has a lock we as programmers can use (any object can be a lock) Object locks provide wait and notify methods Wait() wait: Precondition: Thread must own object’s lock to call wait Wait() wait: Precondition: Thread must own object’s lock to call wait wait(): 1.) thread releases lock Wait() wait: Precondition: Thread must own object’s lock to call wait wait(): 1.) thread releases lock 2.) added to “waiting list for that object Wait() wait: Precondition: Thread must own object’s lock to call wait wait(): 1.) thread releases lock 2.) added to “waiting list for that object 3.) thread waits until notify (All) is called on the object Wait/Notify Wait: gives up lock for other threads such that they can obtain it and make progress. Wait/Notify Wait: gives up lock for other threads such that they can obtain it and make progress. Thread State Model 95 details Notify() Notify: Precondition: Thread must own object’s lock to call notify Notify() Notify: Precondition: Thread must own object’s lock to call notify Notify(): 1.) wakes up one arbitrary thread waiHng for that object lock. Notify() Notify: Precondition: Thread must own object’s lock to call notify Notify(): 1.) wakes up one arbitrary thread waiHng for that object lock. 2.) doesn’t release the lock !!!! Important (only when it leaves synchronized block) NotifyAll() Notify: Precondition: Thread must own object’s lock to call notifyAll NotifyAll() Notify: Precondition: Thread must own object’s lock to call notifyAll Notify(): 1.) wakes up all thread waiHng for that object lock. 2.). doesn’t release the lock !!!! Important (only when it leaves synchronized block) Waking up != getting lock Thread waiting for that object lock get woken up Waking up != getting lock Thread waiting for that object lock get woken up Then compete for the lock -> fastest thread gets the lock Waking up != getting lock Thread waiting for that object lock get woken up Then compete for the lock -> fastest thread gets the lock As notify() only wakes up one thread -> it will most likely get the lock (if its free) Waking up != getting lock Thread waiting for that object lock get woken up Then compete for the lock -> fastest thread gets the lock As notify() only wakes up one thread -> it will most likely get the lock (if its free) Still need to check our condition because “wrong” thread could get the lock (thread with different condition but waiting for the same lock) Waking up != getting lock Thread waiting for that object lock get woken up Then compete for the lock -> fastest thread gets the lock As notify() only wakes up one thread -> it will get the lock Still need to check our condition because “wrong” thread could get the lock (thread with different condition but waiting for the same lock) If noDﬁed-> from WAITING into RUNNABLE state. Wait and No7fy Recap 106 What is the diﬀerence? Issues? Wait and No7fy Recap 107 Spurious wake-ups and notifyAll() à wait has to be in a while loop Wait/Notify Critical Sections: Syntactic sugar: left out try-catch-block both in your code you have to do it ! Pre-Discussion Ex.3 Counter Let’s count the number of 7mes a given event occurs 110 public interface Counter { public void increment(); public int value(); } // background threads for (int i = 0; i < numIterations; i++) { // perform some work counter.increment(); } // progress thread while (isWorking) { System.out.println(counter.value()); } 111 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 10 itera2ons each number of 2mes increment() is called value of the shared Counter 112 1 Counter 1 Thread 1 0 Thread 2 0 Thread 3 increment() number of 2mes increment() is called value of the shared Counter 113 10 Counter 10 Thread 1 0 Thread 2 0 Thread 3 increment() number of 2mes increment() is called value of the shared Counter 114 15 Counter 10 Thread 1 0 Thread 2 5 Thread 3 increment() number of 2mes increment() is called value of the shared Counter 115 25 Counter 10 Thread 1 10 Thread 2 5 Thread 3 increment() number of 2mes increment() is called value of the shared Counter 116 30 Counter 10 Thread 1 10 Thread 2 10 Thread 3 increment() number of 2mes increment() is called value of the shared Counter 117 30 Counter 10 Thread 1 10 Thread 2 10 Thread 3 Print 30 Main value() number of 2mes increment() is called value of the shared Counter read the Counter value Counter Why will what we just saw probably not work? 118 essentials Counter Why will what we just saw probably not work? 119 essen%als BAD Interleavings :( Counter There are many threads accessing the counter at the same :me. How should we implement it such that there are no conﬂicts? You will try diﬀerent solu:ons including: ➔Task A: Sequen-alCounter ➔Task B: SynchronizedCounter ➔Task E (op-onal): AtomicCounter 120 Task A – Sequen7al counter ➔Implement a sequen7al version of the Counter in Sequen7alCounter class that does not use any synchroniza7on. ➔In taskASequen7al we provide a method that runs a single thread which increments the counter. Inspect the code and understand how it works. ➔Verify that the Sequen7alCounter works properly when used with a single thread (the test testSequen7alCounter should pass). 121 Task A – Parallel counter ➔Run the code in taskAParallel which creates several threads that all try to increment the counter at the same 7me. ➔Will this work? What will happen? 122 essentials Task B – Synchronized counter ➔Implement a diﬀerent thread safe version of the Counter in SynchronizedCounter. In this version use the standard primi:ve type int but synchronize the access to the variable by inser:ng synchronized blocks. ➔Run the code in taskB. 123124 10 Counter 10 Thread 1 0 Thread 2 0 Thread 3 125 11 Counter 11 Thread 1 0 Thread 2 0 Thread 3 lock increment() unlock essentials 126 11 Counter 11 Thread 1 0 Thread 2 0 Thread 3 lock Lock: Thread 1 essentials 127 11 Counter 11 Thread 1 0 Thread 2 0 Thread 3 lock failed Blocked: Thread 3 Lock: Thread 1 essentials 128 11 Counter 11 Thread 1 0 Thread 2 0 Thread 3 lock failed Blocked: Thread 3 Thread 2 Lock: Thread 1 essentials 129 11 Counter 11 Thread 1 0 Thread 2 0 Thread 3 lock Blocked: Thread 3 Thread 2 Lock: Thread 1 essentials 130 12 Counter 12 Thread 1 0 Thread 2 0 Thread 3 lock increment() unlock Blocked: Thread 3 Thread 2 essentials Task C Whenever the Counter is incremented, keep track which thread performed the increment (you can print out the thread-id to the console). Can you see a paLern in how the threads are scheduled? Discuss what might be the reason for this behavior. 131 essentials Task D ➔Implement a FairThreadCounter that ensures that diﬀerent threads increment the Counter in a round-robin fashion. In round-robin scheduling the threads perform the increments in circular order. That is, two threads with ids 1 and 2 would increment the value in the following order 1, 2, 1, 2, 1, 2, etc. ➔You should implement the scheduling using the wait and no'fy methods. ➔Can you think of implementa7on that does not use wait and no7fy methods? Hint: assign ID’s 132 essentials 133 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 Thread 1 must increment ﬁrst! essentials 134 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 lock Thread 1 must increment ﬁrst! essentials 135 Counter 0 Thread 1 Thread 2 0 Thread 3 lock failed Blocked: Thread 3 Thread 1 must increment ﬁrst! 0 lock 0 essentials 136 0 Counter 0 Thread 1 0 Thread 2 0 Thread 3 lock check Blocked: Thread 3 Thread 1 must increment ﬁrst! essentials 137 0 Counter 0 Thread 1 0 Thread 2 Thread 3 lock check wait Wai4ng: Thread 2 Thread 1 must increment ﬁrst! Blocked: Thread 3 0 essentials 138 0 Counter 0 Thread 1 0 Thread 2 Thread 3 Wai4ng: Thread 2 lockThread 1 must increment ﬁrst! Blocked: Thread 3 0 Both Thead 1 and Thread 3 could obtain lock. Let’s assume Thread 1 succeeds. essentials 139 0 Counter 0 Thread 1 0 Thread 2 Thread 3 Wai4ng: Thread 2 lock check Thread 1 must increment ﬁrst! Blocked: Thread 3 0 essentials 140 1 Counter 1 Thread 1 0 Thread 2 Thread 3 Wai4ng: Thread 2 lock check increment Thread 1 must increment ﬁrst! Blocked: Thread 3 0 essentials 141 1 Counter 1 Thread 1 0 Thread 2 Thread 3 lock check increment notify Thread 1 must increment ﬁrst! Blocked: Thread 3 0 essentials 142 1 Counter 1 Thread 1 0 Thread 2 Thread 3 lock check increment notifyAll unlock Thread 1 must increment ﬁrst! Blocked: Thread 3 0 essentials now the others can check if its their turn Task E – Atomic counter Implement a thread safe version of the Counter in AtomicCounter. In this version we will use an implementa7on of the int primi7ve value, called AtomicInteger, that can be safely used from mul7ple threads. 143 read in Java Doc Atomic Variables Set of classes providing implementaDon of atomic variables in Java, e.g., AtomicInteger, AtomicLong, ... an operaDon is atomic if no other thread can see it parDally executed. Atomic as in “appears indivisible”. Implemented using special hardware primiDves (instrucDons) for concurrency. Will be covered in detail later in the course. -> Scheduler cannot interrupt in between !!! All or nothing Atomic => not this Task F – Atomic vs Synchronized counter Experimentally compare the AtomicCounter and SynchronizedCounter implementa7ons by measuring which one is faster. Observe the diﬀerences in the CPU load between the two versions. Can you explain what is the cause of diﬀerent performance characteris7cs? - Vary the load per thread - Vary the number of threads 146 essentials Task G Implement a thread that measures execu7on progress. That is, create a thread that observes the values of the Counter during the execu7on and prints them to the console. Make sure that the thread is properly terminated once all the work is done [thread.interrupt()]. 147 DemoDid I really understand? Bad interleaving idea of atomic operaHons Race condiHon criHcal secHon synchronize block vs. synchronize method Mutual exclusion synchronizing staHc methods monitor/intrinsic lock Reentrance wait(), noHfy(), noHfyAll() state change when calling wait / noHfy(All)() while vs. if with wait() Task A) Task B) Task C) Task D) (harder) Task E) Task F) Task G) Tasks ⭐ ❗⭐ ❗⭐ ❗⭐ ⭐⭐ ⭐⭐ ⭐⭐ ⭐ ⭐ opHonal finally https://quizizz.com/admin/quiz/tp/6225327b387927001df6b1f5?source=quiz_share See you next week J","libVersion":"0.3.2","langs":""}