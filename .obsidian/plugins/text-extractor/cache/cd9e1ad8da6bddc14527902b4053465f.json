{"path":"sem4/CN/UE/s/CN-u12-s.pdf","text":"Exercise 12: BGP Security, Routing Attacks, DNS, and DNSSEC Note: This exercise sheet contains exercise about DNSSEC from the “Network Security” lecture exams HS19 - HS17. Note that only the content from the Computer Networks lecture is relevant for the exam. Question 1: TCP reset attacks [1] Note: In the book from the lecture (K.Ross, J. Kurose, CN - A top down approach) the TCP sequence number is a (randomly initialized) integer that is increased by one for subsequent packets, intuitively “having the meaning of a packet id”. In the TCP implementation the sequence number of a packet is again a (randomly initialized) integer that is increased by the length of the incoming packet, intuitively “having the meaning of the current byte traffic offset. In this exercise we talk about the”byte-offset” sequence number as in the implementation Suppose two Internet routers exchange BGP routing updates over a long-lived TCP connection between them. Suppose the window size of the TCP connection on the receiver side is 2 16 bytes [1] and the sequence number is 32 bit. Assume both TCP endpoints select their initial sequence numbers uniformly at random. Derive the expected number of packets required for an attacker to successfully reset the connection. State your assumptions. Hint: To reset a TCP connection, an attacker must send a TCP RST packet with a sequence number within the sliding window. Solution: We assume network latency is minimal. There are 2 32 (32 bit number) possible sequence numbers and a window size of 2 16. An attacker has p = 2 16/2 32 chance of correctly guessing a TCP sequence number within this window. We can model the attack as a geometric distribution where the attacker makes n − 1 failed guesses until a successful guess, i.e. (1 − p) n−1 · p. The expected number of attack packets in this attack is the mean 1 p = 1 216/232 = 2 16. The attack can also be represented as a negative hypergeometric distribution if we assume that the window doesn’t move and that the attacker increments its sequence number by the window size after every attempt. Then, the expected value is given by K N −K+1 , where N = 216 is the total number of elements and K = 216 − 1 is the number of failure elements. On average, this attack will require 215 + 1 2 packets. 1 Question 2: BGP Attacks In this problem, we would like you to explain and analyze two attacks against the BGP routing protocol. Assume each AS assigns the same local pref values to each of their neighbors. In both attacks, the attacker, who has control over AS999, targets AS1000. The following figure shows the routing paths in the normal state after AS1000 has announced 192.0.2.0/24: Each circle represents an Autonomous System (AS). A solid line indicates a link over which two neighboring ASes can exchange control messages such as BGP update messages. A dashed line indicates an established AS path to 192.0.2.0/24. Question 2.1 Under attack, the situation looks as follows: 2 Is this attack possible? If yes, describe the most likely scenario that could explain the result of this situation. Solve this by specifying what AS999 announced. Solution: Yes it is. AS999 could announce two longer prefixes: 192.0.2.128/25 and 192.0.2.0/25, because when more than one path is available to the destina- tion, BGP adopts the path with the longest matching. Question 2.2 3 In the second type of attack illustrated above, the attacker can silently redirect the hijacked traffic back to the victim along the path indicated by green lines. This attack relies on two mechanisms: - path prepending, where an AS inserts AS numbers at the beginning of an AS path to make the path less preferable for traffic engineering purpose, and - loop prevention, where an AS drops any BGP update with itself in the AS-path attribute to prevent routing loops. Instead of announcing the ownership of an address block, AS999 announces a spurious BGP update: {IP prefix, {AS x, AS y, ...}}. Specify a BGP update message that could cause the result of the attack scenario above. Solution: AS999 could announce the updates: {192.0.2.128/25, {AS999, AS2, AS1, AS1000}} and {192.0.2.0/25, {AS999, AS2, AS1, AS1000}}. Now the attacker not only uses a longer prefix (just as in the previous attack), but prepends the ASes which are on its intended reply path. Due to the longest-prefix-match rule, AS3, AS4, and AS5 would send packets to AS1000 through AS999. Moreover, AS1 and AS2 would not add themselves into the path due to loop prevention. Note that appending AS1000 at the end of the AS-PATH looks less suspicious (since the AS announcing the prefix seems to be the same as before) but the attack might work without this i.e. {AS999, AS2, AS1}. Question 2.3 Briefly explain how the attacker abuses path prepending and loop prevention for malicious purposes. Solution: Path prepending: the attacker uses AS path prepending function to add each of the ASes intended for reply path. Loop prevention: this BGP rule allows the attacker to create a fake route which will not be accepted by the ASes on the intended reply path. Question 2.4 List one advantage and one disadvantage of this attack from the attacker’s point of view. Solution: Advantage: Compared to the first type of attack, this attack is more difficult to detect because the traffic still reaches the destination. Disadvantage: the attacker can only eavesdrop part of the network traffic. 4 Question 3: Link weight attacks In the network below, node E is malicious. It announces wrong weights to launch attacks in the network. The weights are integers greater than 0 in this problem. Shortest paths are used to send data traffic in the network, and Dijkstra’s algorithm is used to construct the shortest paths between source and destination node. Question 3.1 Suppose node E wants to direct all of the network’s traffic destined to node D via node C. What are the weights node E should announce for links EF, ED and EC for this attack while minimizing the sum of the weights? Note: Our solution uses: • python • pulp package to solve the ILP (https://coin-or.github.io/pulp/) • networkx package to automatically generate the constraints from the graph (https://networkx.org/) (optional, constraints can also be defined manually) Solution: The link weights that minimize the sum of weights are EF = EC = 1 and ED = 6. In the following we try to find constraints of the weights. A possibility is to construct an ILP from this. The most difficult part is to formulate all the constraints. Paths from A to D In the following table, we see the paths from A to D and their weight: 5 Path Weight ABCED 4+EC+ED AECD 6+EC ABCD 8 AFECD 6+EF+EC ABCEFD 11+EC+EF AED 2+ED AFED 2+EF+ED AFD 9 AEFD 9+EF We must ensure that there exists a path from A to D containing C with a lower weight than all paths not containing C. AFECD and ABCEFD both have strictly higher weight than AECD and thus are not considered as shortest path. ABCED cannot be the shortest path, since its weight is always higher than the weight of AED, which does not traverse C. Like this we can also rule out AFED, AFD and AEFD (we crossed out those paths in the table below) Path Weight ABCED - AECD 6+EC ABCD 8 AFECD - ABCEFD - AED 2+ED AFED - AFD - AEFD - To route the traffic over C it must hold that (AECD < AED ≤ ABCD < AED). • If AECD = 6+EC < AED = 2+ED then ED > 6−2+EC > 6−2+1 = 5 • If ABCD = 8 < AED = 2 + ED then ED > 8 − 2 = 6 Therefore ED ≥ 6. Paths from F to D Path Weight FD 7 FED EF + ED >= EF + 6 FECD EF + EC + 4 6 Path Weight FEABCD EF+10 FAED 4+ ED >= 10 FAECD EC+8 FABCD 10 For the path from F to D , the shortest paths not containing C is FD (wFD = 7).All other paths that do not contain C, FED = EF + ED ≥ 7 and F AED (wFAED = 4 + ED ≥ 10), are at least as long than FD. We removed all paths <= 7. Path Weight FD 7 FED EF + ED >= EF + 6 FECD EF + EC + 4 FEABCD EF+10 FAED 4+ ED >= 10 FAECD EC+8 FABCD 10 In order for F ECD to be shorter than F D , both EF and EC must be equal to 1. (the minimum weight). Minimizing those constraints: ED = 5, EF = EC = 1 gives the solution since the shortest paths of B and C (BCD, CD) also use C. We run this LP to obtain the solution. To run it (python3 required): 1. download the file 2. open a terminal 3. use the “cd folder/to/exercise” command to navigate to the script 4. install pulp by running “python3 -m pip install pulp networkx” (maybe in an virtual environment or deinstall it later) 5. run the script by “./minweights.py” Question 3.2 What weights should node E announce if it does not want to receive any network traffic destined to ISP D or ISP C while minimizing the sum of the weights? A possibility is again to construct an ILP from this. Your solution can also be given in an ILP (Pseudo) Code that computes the weights. Solution: Constraints: 7 • AE + EC > 4 (AEC must be longer than one other route from A to C where the shortest one is ABC = 4) • AE + ED > 8 (AED must be longer than one other route from A to D where the shortest one is ABCD = 8) • AE + EF > 2 (F EABC must be longer than one other route from F to C where the shortest one is F ABC = 6) • CE + ED > 4 (CED must be longer than one other route from C to D where the shortest one is CD = 4) • EF + DE > 7 (F ED must be longer than one other route from F to D where the shortest one is F D = 7) • EF + CE > 6 (F EC must be longer than one other route from F to C where the shortest one is F ABC = 6) The minimum sum of weights (16) can be achieved through the following weights (maybe more): EA EC ED EF 5 1 4 6 2 4 7 3 5 1 4 6 6 2 3 5 You can again run this LP to obtain the solution. Or, there is a more simple ILP using the constraints listed above here. Question 3.3 Node E now wants to attract all of the network’s traffic destined to node D towards itself. How would node E achieve its goal with the least deviation from the current weights, i.e., by only reducing the value of one link? Solution: We try out reducing the 4 links and check the shortest paths. It is sufficient if E announces the weight of EC as 1. Question 4: DNS and DNSSEC Question 4.1: DNS root servers The following two questions relate to DNS root name servers, the basic footing of the global DNS infrastructure. 1. Name three reasons why root name servers are replicated across the globe. 2. A recent proposal suggests to eliminate DNS root servers altogether and distribute the data that would be on those root servers (i.e., the root zone 8 file) to recursive resolvers. This proposal has a security benefit for DNS (not DNSSEC). What is the security benefit of this proposal for DNS? Solution: 1. • Load balancing • latency minimization • failure tolerance • reduced attack surface by short paths to name servers • political reasons 2. DNS queries have to traverse less of the network, thus the attack surface for spoofing is reduced. Question 4.2: Caching resolvers Recursive resolvers have an important role in DNS: by caching the replies they obtain, they significantly lower the average lookup latency for end hosts using the resolvers. However, the use of caching is not without its drawbacks. 1. Name and describe one drawback in terms of privacy. 2. Why would an adversary prefer a world in which caching resolvers are used extensively (as they are in our world) over a world in which all end hosts’ clients perform the full recursive look-ups on their own? In other words: Which vulnerabilities does this expose? Solution: 1. • By measuring the latency of replies from a resolver, an a adversary can figure out whether certain names have been queried by other clients using that resolver. Just by querying the same resolver. • The resolver itself is an additional entity learning what queries the user is making, which is a problem in particular for resolvers that are not provided by an ISP. 2. It allows: • Cache Poisoning attacks that have potentially a large impact, as many clients would be affected • Because, if the resolvers are configured to be open, they can be leveraged for amplification attacks Question 4.3 Attacks on DNS(SEC) For the two attacks on DNS below, state whether the deployment of DNSSEC would make the attack less effective, equally effective or more effective. Moreover, justify your answer. 1. Reflection/Amplification Attack 2. DNS Spoofing (injecting fake DNS records) 9 Solution: 1. Reflection attacks become more effective, as responses get longer due to the additionally attached signatures. If the size of the response increases and the size of the request stays the same, a higher amplification factor is achieved, making the reflection attack more potent. 2. Less effective, as DNS responses are authenticated. Preventing DNS spoofing is main benefit of DNSSEC. Question 4.4 Attacks circumventing DNSSEC Recall that DNSSEC is typically used only between recursive resolvers and authoritative name servers. Assuming DNSSEC is fully deployed, consider an end host that fully trusts the recursive resolvers provided by its ISP (so it also trusts that the resolver will always use DNSSEC). 1. What attack undermining the authenticity of the query replies should the end host still worry about, and why? 2. What countermeasure (if any) could be adopted to prevent or significantly mitigate the attack you mentioned? Briefly explain your answer. Solution: 1. • The link between the end host and the resolver is in general not secure, so an eavesdropping attacker (e.g., in the same LAN network) may alter the replies. • an adversary could even replace the resolver entirely by hijacking the initial DHCP setup. 2. • The end host could set up an authenticated channel to the resolver, ensuring (via certificates or other) that it is getting the replies sent by the correct resolver • The end host could do the entire DNSSEC lookup on its own 10","libVersion":"0.5.0","langs":""}