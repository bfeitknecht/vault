{"path":"sem3/TI/VRL/extra/nwehrl/TI-nwehrl-w05.pdf","text":"Theoretische Informatik HS24 Nicolas Wehrli ¨Ubungsstunde 05 22. Oktober 2024 ETH Z ¨urich nwehrl@ethz.ch 1 Heute 1 Feedback zur Serie 2 Nichtdeterministische Endliche Automaten Mindestanzahl Zust¨ande 3 Turing Maschinen 4 Midterm Prep 2 Feedback zur Serie Feedback - Pumping Lemma war mid. Heute Repetition. - Common Mistakes: I. Ihr zeigt f ¨ur eine Teilmenge aller m ¨oglichen Aufteilungen, dass (i), (ii) und (iii) nicht alle gelten. Es muss f ¨ur alle gezeigt werden. II. Vorsicht bei Case Distinctions Aufgabe 12.b. - Widerspruch jeweils zu Ende f ¨uhren. 3 Beispielaufgabe Pumpinglemma Wir zeigen per Pumping Lemma, dass die Sprache L = {w ∈ {a, b, c}∗ | w enth¨alt das Teilwort ab gleich oft wie das Teilwort ba} nicht regul¨ar ist. Pumping Lemma Sei L regul¨ar. Dann existiert eine Konstante n0 ∈ N, so dass jedes Wort w ∈ Σ∗ mit |w| ≥ n0 in drei Teile x, y und z zerlegen l¨asst, das heisst w = yxz, wobei (i) |yx| ≤ n0 (ii) |x| ≥ 1 (iii) entweder {yxkz | k ∈ N} ⊆ L oder {yxkz | k ∈ N} ∩ L = ∅. 4 Beispielaufgabe Pumpinglemma L ¨osung Sei L regul¨ar. Nach dem Pumping Lemma existiert eine Konstante n0 ∈ N, so dass jedes Wort w mit |w| ≥ n0 die Bedingung des PL erf ¨ullt. Sei w = (abc)n0(bac)n0. Offensichtlich gilt |w| ≥ n0. Nach dem PL existiert eine Zerlegung w = yxz, die (i), (ii) und (iii) erf ¨ullt. Da yxz die Bedingung (i) erf ¨ullt, gilt |yx| ≤ n0. Insbesondere folgt daraus, dass x komplett in der ersten H¨alfte (i.e. (abc)n0) enthalten ist. Aus (ii) folgt weiter, dass x mindestens ein Buchstaben enth¨alt. 5 Beispielaufgabe Pumpinglemma Case Distinction I. Case x = c In diesem Fall enth¨alt yx0z = yz das Teilwort ba einmal mehr als ab. Somit gilt in diesem Fall yx0z /∈ L. II. Case x enth¨alt mindestens ein a oder b Wir betrachten yx0z = yz. In diesem Fall bleibt die Anzahl der Teilw ¨orter ba gleich oder erh ¨oht sich. Da aber die Anzahl der Teilw ¨orter ab um mindestens 1 kleiner wird, gilt yx0z /∈ L. Da die Case Distinction alle F¨alle abdeckt folgt f ¨ur die Zerlegung yx0z /∈ L. Aus yxz ∈ L ergibt sich somit ein Widerspruch. Demnach ist die Annahme falsch und L nicht regul¨ar. ■ 6 Nichtdeterministische Endliche Automaten Definition NEA Ein nichtdeterministischer endlicher Automat (NEA) ist ein Quintupel M = (Q, Σ, δ, q0, F). Dabei ist (i) Q eine endliche Menge, Zustandsmenge genannt, (ii) Σ ein Alphabet, Eingabealphabet genannt, (iii) q0 ∈ Q der Anfangszustand, (iv) F ⊆ Q die Menge der akzeptierenden Zust¨ande und (v) δ eine Funktion von Q × Σ nach P(Q), ¨Ubergangsfunktion genannt. Ein NEA kann zu einem Zustand q und einem gelesenen Zeichen a mehrere oder gar keinen Nachfolgezustand haben. 7 Konfigurationen f ¨ur NEAs Eine Konfiguration von M ist ein Tupel (q, w) ∈ Q × Σ∗. - ”M befindet sich in einer Konfiguration (q, w) ∈ Q × Σ∗, wenn M im Zustand q ist und noch das Suffix w eines Eingabewortes lesen soll.” Ein Schritt von M ist eine Relation (auf Konfigurationen) M ⊆ (Q × Σ∗) × (Q × Σ∗), definiert durch (q, w) M (p, x) ⇐⇒ w = ax, a ∈ Σ und p ∈ δ(q, a) 8 Berechnungen f ¨ur NEAs Eine Berechnung von M ist eine endliche Folge C1, ..., Ck von Konfigurationen, so dass Ci M Ci+1 f ¨ur alle 1 ≤ i ≤ k. Eine Berechnung von M auf x ist eine Berechnung C = C0, ..., Cm, wobei C0 = (q0, x) und entweder Cm ∈ Q × {λ} so dass δ(q, a) = ∅. Falls Cm ∈ F × {λ}, sagen wir, dass C eine akzeptierende Berechnung von M auf x ist, und dass M das Wort x akzeptiert. 9 Weitere Definitionen Die Relation M ∗ ist die reflexive und transitive H ¨ulle von M , genau wie bei einem EA. Wir definieren L(M) = {w ∈ Σ∗ | (q0, w) M ∗ (p, λ) f ¨ur ein p ∈ F} als die von M akzeptierte Sprache. Zu der ¨Ubergangsfunktion δ definieren wir die Funktion ˆδ : (Q × Σ∗) → P(Q) wie folgt: (i) ˆδ(q, λ) = {q} f ¨ur alle q ∈ Q (ii) ˆδ(q, wa) = ⋃ r∈ˆδ(q,w) δ(r, a) f ¨ur alle q ∈ Q, a ∈ Σ, w ∈ Σ∗. 10 Beispiel aus der Vorlesung Wir betrachten folgenden NEA M = ({q0, q1, q2}, Σbool, δ, q0, {q2}) Abbildung 1: Abb. 3.15 aus dem Buch 11 Berechnungsbaum F ¨ur ein Wort x ∈ (Σbool)∗ ist ein Berechnungsbaum BM(x) n ¨utzlich, um zu erkennen, ob x ∈ L(M). Abbildung 2: Abb. 3.16 aus dem Buch 12 Sprache des NEA - Lemma 3.5 Wir k ¨onnen die Sprache des NEA bestimmen. L(M) = {x11y | x, y ∈ (Σbool)∗} Beweisidee Beide Inklusionen zeigen und fertig. (Siehe Buch) Wir definieren die Klasse LNEA. LNEA = {L(M) | M ist ein NEA} 13 ¨Aquivalenz von NEA und EA Beweis von LNEA = LEA per Potenzmengenkonstruktion. Satz 3.2 Zu jedem NEA M existiert ein EA A, so dass L(M) = L(A) Beweisidee Potenzmengenkonstruktion und dann Induktion auf der L¨ange von einem Input i.e. |x|. (Siehe Buch) 14 Potenzmengenkonstruktion Sei M = (Q, Σ, δM, q0, F) ein NEA. Wir konstrurieren einen ¨aquivalenten End- lichen Automaten A = (QA, ΣA, δA, q0A, FA). (i) QA = {⟨P⟩ | P ⊆ Q} (ii) ΣA = Σ (iii) q0A = ⟨{q0}⟩ (iv) FA = {⟨P⟩ | P ⊆ Q und P ∩ F ̸= ∅} (v) δA : (QA × ΣA) → QA ist eine Funktion, definiert wie folgt. F ¨ur jedes ⟨P⟩ ∈ QA und jedes a ∈ ΣA ist δA(⟨P⟩, a) = 〈 ⋃ p∈P δM(p, a) 〉 = ⟨{q ∈ Q | ∃p ∈ P, so dass q ∈ δM(p, a)}⟩ 15 Potenzmengenkonstruktion mit Beispiel NEA Wenden wir Potenzmengenkonstruktion an: 16 Potenzmengenkonstruktion mit Beispiel NEA L ¨osung: 17 Exponentiell mehr Zust¨ande - manchmal Sei Lk = {x1y | x ∈ (Σbool) ∗, y ∈ (Σbool)k−1} Folgender NEA Ak mit k + 1 Zust¨anden akzeptiert Lk. Abbildung 3: Abb. 3.19 im Buch 18 Exponentiell mehr Zust¨ande - manchmal Lemma 3.6 F ¨ur alle k ∈ N \\ {0} muss jeder EA, der Lk akzeptiert, mindestens 2k Zust¨ande haben. Beweis Sei Bk = (Qk, Σbool, δk, q0k, Fk) ein EA mit L(Bk) = Lk. Nach Lemma 3.3 gilt f ¨ur x, y ∈ (Σbool)∗: Wenn ˆδk(q0k, x) = ˆδk(q0k, y), dann gilt f ¨ur alle z ∈ (Σbool)∗: xz ∈ L(Bk) ⇐⇒ yz ∈ L(Bk) 19 Exponentiell mehr Zust¨ande - manchmal Die Idee des Beweises ist es, eine Menge Sk von W ¨ortern zu finden, so dass f ¨ur keine zwei unterschiedlichen W ¨orter x, y ∈ Sk die Gleichung ˆδk(q0k, x) = ˆδk(q0k, y) gelten darf. Dann m ¨usste Bk mindestens |Sk| viele Zust¨ande haben. Wir w¨ahlen Sk = (Σbool)k und zeigen, dass ˆδk(q0k, u) paarweise unterschiedliche Zust¨ande f ¨ur alle u ∈ Sk sind. Wir beweisen dies per Widerspruch. 20 Exponentiell mehr Zust¨ande - manchmal Seien x = x1x2...xk und y = y1y2...yk f ¨ur xi, yi ∈ Σbool, i ∈ {1, ..., k} zwei unterschiedliche W ¨orter aus Sk. Nehmen wir zum Widerspruch an, dass ˆδk(q0k, x) = ˆδk(q0k, y). Weil x ̸= y, existiert ein j ∈ {1, ..., k}, so dass xj ̸= yj. O.B.d.A. setzen wir xj = 1 und yj = 0. Betrachten wir nun z = 0j−1. Dann ist xz = x1...xj−11xj+1...xk0j−1 und yz = y1...yj−10yj+1...yk0j−1 und daher xz ∈ Lk und yz /∈ Lk. Dies ist ein Widerspruch! Folglich gilt ˆδk(q0k, x) ̸= ˆδk(q0k, y) f ¨ur alle paarweise unterschiedliche x, y ∈ Sk = (Σbool)k. Daher hat Bk mindestens |Sk| = 2k viele Zust¨ande. ■ 21 Mindestanzahl Zust¨ande n - Beweisschema Die Grundidee ist es n W ¨orter anzugeben und zu beweisen, dass jedes von diesen n W ¨ortern in einem eigenen Zustand enden muss. Seien w1, ..., wn diese W ¨orter. Dann geben wir f ¨ur jedes Paar von W ¨ortern wi ̸= wj einen Suffix zi,j an, so dass folgendes gilt: wizi,j ∈ L ̸⇐⇒ wjzi,j ∈ L Dann folgt aus Lemma 3.3 ˆδ(q0, wi) ̸= ˆδ(q0, wj) Es eignet sich die Suffixe als Tabelle anzugeben. Um die W ¨orter und Suffixe zu finden, kann es sich als n ¨utzlich erweisen, den Endlichen Automaten zu konstruieren. 22 Mindestanzahl Zust¨ande n - Beweisschema Wir nehmen zum Widerspruch an, dass es einen EA f ¨ur L gibt mit weniger als n Zust¨anden. Betrachten wir w1, ..., wn. Per Pigeonhole-Principle existiert i < j, so dass ˆδ(q0, wi) = ˆδ(q0, wj) Per Lemma 3.3 folgt daraus, dass ∀z ∈ Σ ∗ : wiz ∈ L ⇐⇒ wjz ∈ L F ¨ur z = zi,j gilt aber per Tabelle wizi,j ∈ L ̸⇐⇒ wjzi,j ∈ L (1) f ¨ur alle i < j. Da keines der n W ¨orter im gleichen Zustand enden kann: Widerspruch. 23 Mindestanzahl Zust¨ande n - Beweisschema Dann noch Angabe der Tabelle f ¨ur (1) w2 ... wn w1 z1,2 ... z1,n ... ... ... wn−1 zn−1,n - Wenn es offensichtlich ist, muss (1) nicht bei jedem Suffix begr ¨undet werden. - Ein minimaler endlicher Automat ist nicht notwendig f ¨ur den Beweis. Hilft aber f ¨urs i. Finden der wi ii. Finden der zi,j iii. Beweis von wizi,j ∈ L ̸⇐⇒ wjzi,j ∈ L (Leicht ¨uberpr ¨ufbar) 24 Klassische Aufgabe - HS19 Aufgabe 3.a Wir betrachten die Sprache L = {x00y | x ∈ {0, 1}∗ und y ∈ {0, 1}} Konstruieren Sie einen nichtdeterminstischen endlichen Automaten mit h ¨ochstens 4 Zust¨anden, der L akzeptiert. q0start q1 q2 q3 0, 1 0 0 0, 1 25 Klassische Aufgabe - HS19 Aufgabe 3.b Zeigen Sie, dass jeder deterministische endliche Automat, der L akzeptiert, mindestens 5 Zust¨ande braucht. Wir zeichnen den zugeh ¨origen EA zuerst. q0start q1 q2 q3 q4 1 0 0 1 0 1 0 1 0 1 26 Klassische Aufgabe - HS19 Aufgabe 3.b Nehmen wir zum Widerspruch an, dass es einen endlichen Automaten gibt, der L akzeptiert und weniger als 5 Zust¨ande hat. Wir w¨ahlen die W ¨orter B = {λ, 0, 00, 000, 001}. Nach dem Pigeonhole-Principle existieren zwei W ¨orter wi, wj ∈ B, wi ̸= wj, so dass ˆδ(q0, wi) = ˆδ(q0, wj) Per Lemma 3.3 folgt daraus, dass ∀z ∈ Σ∗ : wiz ∈ L ⇐⇒ wjz ∈ L 27 Klassische Aufgabe - HS19 Aufgabe 3.b Wir betrachten folgende Tabelle mit Suffixen. 0 00 000 001 λ 01 1 λ λ 0 1 λ λ 00 λ λ 000 1 Der zeigt f ¨ur jedes Wortpaar x, y ∈ B, x ̸= y die Existenz eines Suffixes z, so dass (xz ∈ L ∧ yz /∈ L) ∨ (xz /∈ L ∧ yz ∈ L) Dies kann man mit den angegebenen Suffixen und dem angegebenen EA einfach ¨uberpr ¨ufen. 28 Klassische Aufgabe - HS19 Aufgabe 3.b Dies widerspricht der vorigen Aussage, dass ein Wortpaar wi, wj ∈ B, wi ̸= wj existiert, so dass ∀z ∈ Σ ∗ : wiz ∈ L ⇐⇒ wjz ∈ L Somit ist unsere Annahme falsch und es existiert kein EA mit < 5 Zust¨anden f ¨ur L. ■ 29 Mindestanzahl Zust¨ande n - Bemerkung Manchmal ist es zu schwierig einen minimalen EA zu finden und es funktioniert einfacher die W ¨orter durch Trial and Error zu finden. (Siehe Midterm HS22) 30 Turing Maschinen Motivation und ¨Uberblick Formalisierung notwendig, um mathematisch ¨uber die automatische Unl ¨osbarkeit zu argumentieren. Jede vern ¨unftige Programmiersprache ist eine zul¨assige Formalisierung. Aber nicht geeignet (meistens komplexe Operationen). Die Turingmaschine erlaubt ein paar elementare Operationen und besitzt trotzdem die volle Berechnungsst¨arke beliebiger Programmiersprachen. Ziel dieses Kapitels ist, dass ihr ein gewisse Gesp ¨ur daf ¨ur bekommt, was eine Turingmaschine kann und was nicht. 31 Turing Maschinen - Formalisierung von Algorithmen Informell Eine Turingmaschine besteht aus (i) einer endlichen Kontrolle, die das Programm enth¨alt, F ¨ur formale Beschreibung siehe Buch. 32 Turing Maschinen - Formalisierung von Algorithmen Abbildung 4: Abb. 4.1 vom Buch 33 Turing Maschinen - Formalisierung von Algorithmen Elementare Operation einer TM - Informell Input - Zustand der Maschine (der Kontrolle) - Symbol auf dem Feld unter dem Lese-/Schreibkopf Aktion (i) ¨andert Zustand (ii) schreibt auf das Feld unter dem Lese-/Schreibkopf (iii) bewegt den Lese-/Schreibkopf nach links, rechts oder gar nicht. Ausser wenn g , dann ist links nicht m ¨oglich. 34 Turing Maschinen - Formalisierung von Algorithmen Eine Konfiguration C von M ist ein Element aus Konf(M) = {g } · Γ∗ · Q · Γ + ∪ Q · {g } · Γ ∗ - Eine Konfiguration g w1qaw2 mit w1, w2 ∈ Γ∗, a ∈ Γ und q ∈ Q sagt uns: M im Zustand q, Inhalt des Bandes g w1aw2 ..., Kopf an Position |w1| + 1 und liest gerade a. 35 Turing Maschinen - Formalisierung von Algorithmen Es gibt wieder eine Schrittrelation M ⊆ Konf(M) × Konf(M). Abbildung 5: Diagramm von Adeline 36 Turing Maschinen - Formalisierung von Algorithmen Berechnung von M, Berechnung von M auf einer Eingabe x etc. durch M definiert. Die Berechnung von M auf x heisst - akzeptierend, falls sie in einer akzeptierenden Konfiguration w1qacceptw2 endet (wobei g in w1 enthalten ist). - verwerfend, wenn sie in in einer verwerfenden Konfiguration w1qrejectw2 endet. - nicht-akzeptierend, wenn sie entweder eine verwerfende oder unendli- che Berechnung ist. 37 Turing Maschinen - Formalisierung von Algorithmen Die von der Turingmaschine M akzeptierte Sprache ist L(M) = {w ∈ Σ ∗ | q0g w M ∗ yqacceptz, f ¨ur irgendwelche y, z ∈ Γ ∗} 38 Wichtige Klassen Regul¨are Sprachen LEA = {L(A) | A ist ein EA} = LNEA Rekursiv aufz¨ahlbare Sprachen Eien Sprache L ⊆ Σ∗ heisst rekursiv aufz¨ahlbar, falls eine TM M existiert, so dass L = L(M). LRE = {L(M) | M ist eine TM} ist die Klasse aller rekursiv aufz¨ahlbaren Sprachen. 39 Wichtige Klassen Halten Wir sagen das M immer h¨alt, wenn f ¨ur alle Eingaben x ∈ Σ∗ (i) q0g x M ∗ yqacceptz, y, z ∈ Γ∗, falls x ∈ L und (ii) q0g x M ∗ uqrejectv, u, v ∈ Γ∗, falls x /∈ L. Rekusive Sprachen Eine Sprache L ⊆ Σ∗ heisst rekursiv (entscheidbar), falls L = L(M) f ¨ur eine TM M, die immer h¨alt. LR = {L(M) | M ist eine TM, die immer h¨alt} ist die Klasse der rekursiven (algorithmisch erkennbaren) Sprachen. 40 Mehrband-Turingmaschine Mehrband-TM - Informelle Beschreibung F ¨ur k ∈ N \\ {0} hat eine k-Band Turingmaschine - eine endliche Kontrolle - ein endliches Band mit einem Lesekopf (Eingabeband) - k Arbeitsb¨ander, jedes mit eigenem Lese-/Schreibkopf (nach rechts un- endlich) Insbesondere gilt 1-Band TM ̸= ”normale” TM Am Anfang der Berechnung einer MTM M auf w - Arbeitsb¨ander ”leer” und die k Lese-/Schreibk ¨opfe auf Position 0. - Inhalt des Eingabebands g w$ und Lesekopf auf Position 0. - Endliche Kontrolle im Zustand q0. 41 ¨Aquivalenz von Maschinen (TM, MTM) Seien A und B zwei Maschinen mit gleichem Σ. Wir sagen, dass A ¨aquivalent zu B ist, wenn f ¨ur jede Eingabe x ∈ Σ∗ (i) A akzeptiert x ⇐⇒ B akzeptiert x (ii) A verwirft x ⇐⇒ B verwirft x (iii) A arbeitet unendlich lange auf x ⇐⇒ B arbeitet unendlich lange auf x Wir haben A und B ¨aquivalent =⇒ L(A) = L(B) aber L(A) = L(B) ̸=⇒ A und B ¨aquivalent da A auf x unendlich lange arbeiten k ¨onnte, w¨ahrend B x verwirft. 42 ¨Aquivalenz von 1-Band TM zu TM Lemma 4.1 Zu jeder TM A existiert eine zu A ¨aquivalente 1-Band-TM B Beweisidee B kopiert die Eingabe zuerst aufs Arbeitsband und simuliert dann A. 43 ¨Aquivalenz von TM zu k-Band-TM Lemma 4.2 Zu jeder Mehrband-TM A existiert eine zu A ¨aquivalente TM B Beweis postponed 44 ¨Aquivalenz Folgerung Aus Lemma 4.1 und 4.2 folgt direkt Satz 4.1 Die Maschinenmodelle von Turingmaschinen und Mehrband- Turingmaschinen sind ¨aquivalent. Note: ” ¨Aquivalenz” f ¨ur Maschinenmodelle wird in Definition 4.2 definiert. Maschinenmodelle sind Klassen von Maschinen (i.e. Mengen von Maschinen mit gewissen Eigenschaften). 45 Midterm Prep","libVersion":"0.5.0","langs":""}