{"path":"sem3/TI/VRL/extra/nwehrl/TI-nwehrl-w02.pdf","text":"Theoretische Informatik HS24 Nicolas Wehrli ¨Ubungsstunde 02 2. Oktober 2024 ETH Z ¨urich nwehrl@ethz.ch 1 Heute 1 Letzte Woche & Feedback zur Serie 2 Kolmogorov Komplexit¨at - Theorie 3 How To Kolmogorov 2 Letzte Woche & Feedback zur Serie Feedback I. Grunds¨atzlich gut. II. Bei manchen die L¨ange reduzieren und konkreter argumentieren. III. Bei anderen hat Argumentation gefehlt. Steht in der Korrektur. IV. Bei Aufgabe 3: k und l beliebig. Alle Antworten m ¨ussen begr ¨undet werden. 3 Kolmogorov Komplexit¨at - Theorie Vorl¨aufige Definition des Begriffs Algorithmus Mathematische Definition folgt in Kapitel 4 (Turingmaschinen). Vorerst betrachten wir Programme, die f ¨ur jede zul¨assige Eingabe halten und eine Ausgabe liefern, als Algorithmen. Wir betrachten ein Programm (Algorithmus) A als Abbildung A : Σ∗ 1 → Σ∗ 2 f ¨ur beliebige Alphabete Σ1 und Σ2. Dies bedeutet, dass (i) die Eingaben als W ¨orter ¨uber Σ1 kodiert sind, (ii) die Ausgaben als W ¨orter ¨uber Σ2 kodiert sind und (iii) A f ¨ur jede Eingabe eine eindeutige Ausgabe bestimmt. A und B ¨aquivalent ⇐⇒ Eingabealphabet Σ gleich, A(x) = B(x), ∀x ∈ Σ∗ Ie. diese Notion von ” ¨Aquivalenz” bezieht sich nur auf die Ein und Ausgabe. 4 Algorithmen generieren W ¨orter Sei Σ ein Alphabet und x ∈ Σ∗. Wir sagen, dass ein Algorithmus A das Wort x generiert, falls A f ¨ur die Eingabe λ die Ausgabe x liefert. Beispiel: An : begin f o r i = 1 t o n ; w r i t e ( 0 1 ) ; end An generiert (01)n. 5 Aufz¨ahlungsalgorithmus Sei Σ ein Alphabet und sei L ⊆ Σ∗. A ist ein Aufz¨ahlungsalgorithmus f ¨ur L, falls A f ¨ur jede Eingabe n ∈ N \\ {0} die Wortfolge x1, ..., xn ausgibt, wobei x1, ..., xn die kanonisch n ersten W ¨orter in L sind. 6 Entscheidungsproblem Das Entscheidungsproblem (Σ, L) f ¨ur ein gegebenes Alphabet Σ und eine ge- gebene Sprache L ⊆ Σ∗ ist, f ¨ur jedes x ∈ Σ∗ zu entscheiden, ob x ∈ L oder x /∈ L. Ein Algorithmus A l ¨ost das Entscheidungsproblem (Σ, L), falls f ¨ur alle x ∈ Σ∗ gilt: A(x) =    1, falls x ∈ L, 0, falls x /∈ L. Wir sagen auch, dass A die Sprache L erkennt. 7 Aufgabe 2.21 - machen wir am Ende Wenn f ¨ur eine Sprache L ein Algorithmus existiert, der L erkennt, sagen wir, dass L rekursiv ist. L ∈ LR Aufgabe 2.21 Beweisen Sie, dass eine Sprache L genau dann rekursiv ist, wenn ein Aufz¨ahlungsalgorithmus f ¨ur L existiert. 8 Information messen Wir beschr¨anken uns auf Σbool Kolmogorov-Komplexit¨at F ¨ur jedes Wort x ∈ (Σbool)∗ ist die Kolmogorov-Komplexit¨at K(x) des Wortes x das Minimum der bin¨aren L¨angen, der Pascal-Programme, die x generieren. K(x) ist die k ¨urzestm ¨ogliche L¨ange einer Beschreibung von x. Die einfachste (und triviale) Beschreibung von x, ist wenn man x direkt angibt. x kann aber eine Struktur oder Regelm¨assigkeit haben, die eine Komprimierung erlaubt. Welche Programmiersprache gew¨ahlt wird ver¨andert die Kolmogorov-Komplexit¨at nur um eine Konstante. (Satz 2.1) 9 Kolmogorov-Komplexit¨at - Beispiel Beispiel Sei w = 0101010101010101010101010101010101010101. Die L¨ange von w ist |w| = 40 und die triviale Beschreibungl¨ange w¨are wie gegeben 40. Aber durch die Regelm¨assigkeit von einer 20-fachen Wiederholung der Sequenz 01, k ¨onnen w auch durch (01)20 beschreiben. Hierbei ist die Beschreibungsl¨ange ein wenig mehr als 4 Zeichen. 10 Grundlegende Resultate Es existiert eine Konstante d, so dass f ¨ur jedes x ∈ (Σbool)∗ K(x) ≤ |x| + d Die Kolmogorov-Komplexit¨at einer nat ¨urlichen Zahl n ist K(n) = K(Bin(n)). 11 Lemma 2.5 - Nichtkomprimierbar F ¨ur jede Zahl n ∈ N \\ {0} existiert ein Wort wn ∈ (Σbool)n, so dass K(wn) ≥ |wn| = n 12 Lemma 2.5 - Beweis Es gibt 2n W ¨orter x1, ..., x2n ¨uber Σbool der L¨ange n. Wir bezeichnen C(xi) als den Bitstring des k ¨urzesten Programms, der xi generieren kann. Es ist klar, dass f ¨ur i ̸= j : C(xi) ̸= C(xj). Die Anzahl der nichtleeren Bitstrings, i.e. der W ¨orter der L¨ange < n ¨uber Σbool ist: n−1∑ i=1 2i = 2 n − 2 < 2n Also muss es unter den W ¨ortern x1, ..., x2n mindestens ein Wort xk mit K(xk) ≥ n geben. ■ 13 Satz 2.1 - Programmiersprachen F ¨ur jedes Wort x ∈ (Σbool)∗ und jede Programmiersprache A sei KA(x) die Kolmogorov-Komplexit¨at von x bez ¨uglich der Programmiersprache A. Seien A und B Programmiersprachen. Es existiert eine Konstante cA,B, die nur von A und B abh¨angt, so dass |KA(x) − KB(x)| ≤ cA,B f ¨ur alle x ∈ (Σbool)∗. 14 Ein zuf¨alliges Wort Ein Wort x ∈ (Σbool)∗ heisst zuf¨allig, falls K(x) ≥ |x|. Eine Zahl n heisst zuf¨allig, falls K(n) = K(Bin(n)) ≥ ⌈log2(n + 1)⌉ − 1. Jede Bin¨ar-Darstellung beginnt immer mit einer 1, deshalb k ¨onnen wir die L¨ange der Bin¨ar-Darstellung um 1 verk ¨urzen. Zuf¨alligkeit hier bedeutet, dass ein Wort v ¨ollig unstrukturiert ist und sich nicht komprimieren l¨asst. Es hat nichts mit Wahrscheinlichkeit zu tun. 15 Satz 2.2 Sei L eine Sprache ¨uber Σbool. Sei f ¨ur jedes n ∈ N \\ {0}, zn das n-te Wort in L bez ¨uglich der kanonischen Ordnung. Wenn ein Programm AL existiert, das das Entscheidungsproblem (Σbool, L) l ¨ost, dann gilt f ¨ur alle n ∈ N \\ {0}, dass K(zn) ≤ ⌈log2(n + 1)⌉ + c wobei c eine von n unabh¨angige Konstante ist. 16 Satz 2.2 - Beweisidee Wir k ¨onnen aus AL, ein Programm entwerfen, dass das kanonisch n-te Wort generiert, indem wir in der kanonischen Reihenfolge alle W ¨orter x ∈ (Σbool)∗ durchgehen und mit AL entscheiden, ob x ∈ L. Dann k ¨onnen wir einen Counter c haben und den Prozess abbrechen, wenn der Counter c = n wird und dann dieses Wort ausgeben. Wir sehen, dass dieses Programm ausser der Eingabe n immer gleich ist. Sei die L¨ange dieses Programms c, dann k ¨onnen wir f ¨ur das n-te Wort der Sprache L, zn, die Kolmogorov-Komplexit¨at auf n reduzieren, bzw: K(zn) ≤ ⌈log2(n + 1)⌉ + c ■ 17 Primzahlsatz F ¨ur jede positive ganz Zahl n sei Prim(n) die Anzahl der Primzahlen kleiner gleich n. lim n→∞ Prim(n) n/ ln n = 1 N ¨utzliche Ungleichung ln n − 3 2 < n Prim(n) < ln n − 1 2 f ¨ur alle n ≥ 67. 18 Lemma 2.6 - schwache Version des Primzahlsatzes Sei n1, n2, n3, ... eine steigende unendliche Folge nat ¨urlicher Zahlen mit K(ni) ≥ ⌈log2 ni⌉/2. F ¨ur jedes i ∈ N \\ {0} sei qi die gr ¨osste Primzahl, die die Zahl ni teilt. Dann ist die Menge Q = {qi | i ∈ N \\ {0}} unendlich. Beweis: Wir beweisen diese Aussage per Widerspruch: Nehmen wir zum Widerspruch an, dass die Menge Q = {qi | i ∈ N \\ {0}} sei endlich. Sei pm die gr ¨osste Primzahl in Q. Dann k ¨onnen wir jede Zahl ni eindeutig als ni = pri,1 1 · p ri,2 2 · · · · · pri,m m f ¨ur irgendwelche ri,1, ri,2, ..., ri,m ∈ N darstellen. Bemerke das die pi ausser pm nicht notwendigerweise in Q sein m ¨ussen, wir verwenden nur den Fakt, dass es endlich viele davon hat. 19 Lemma 2.6 - Beweis continued Sei c die bin¨are L¨ange eines Programms, dass diese ri,j als Eingaben nimmt und ni erzeugt (A ist f ¨ur alle i ∈ N bis auf die Eingaben ri,1, ..., ri,m gleich). Dann gilt: K(ni) ≤ c + 8 · (⌈log2(ri,1 + 1)⌉ + ⌈log2(ri,2 + 1)⌉ + ... + ⌈log2(ri,m + 1)⌉) Die multiplikative Konstante 8 kommt daher, dass wir f ¨ur die Zahlen ri,1, ri,2, ..., ri,m dieselbe Kodierung, wie f ¨ur den Rest des Programmes verwenden (z.B. ASCII-Kodierung), damit ihre Darstellungen eindeutig voneinander getrennt werden k ¨onnen. Weil ri,j ≤ log2 ni, ∀j ∈ {1, ..., m} erhalten wir K(ni) ≤ c + 8m · ⌈log2(log2 ni + 1)⌉, ∀i ∈ N \\ {0} 20 Lemma 2.6 - Beweis continued 2 Weil m und c Konstanten unabh¨angig von i sind, kann ⌈log2 ni⌉/2 ≤ K(ni) ≤ c + 8m · ⌈log2(log2 ni + 1)⌉ ⌈log2 ni⌉/2 ≤ c + 8m · ⌈log2(log2 ni + 1)⌉ nur f ¨ur endlich viele i ∈ N \\ {0} gelten. Dies ist ein Widerspruch! Folglich ist die Menge Q unendlich. ■ 21 How To Kolmogorov Aufgabentyp 1 Sei wn = (010)32n3 ∈ {0, 1}∗ f ¨ur alle n ∈ N \\ {0}. Gib eine m ¨oglichst gute obere Schranke f ¨ur die Kolmogorov-Komplexit¨at von wn an, gemessen in der L¨ange von wn. 22 Aufgabentyp 1 Wir zeigen ein Programm, dass n als Eingabe nimmt und wn druckt: Wn : begin M := n ; M := 2 × M × M × M ; J := 1 ; f o r I = 1 t o M J : = J × 3 ; f o r I = 1 t o J ; w r i t e ( 0 1 0 ) ; end 23 Aufgabentyp 1 Der einzige variable Teil dieses Algorithmus ist n. Der restliche Code ist von konstanter L¨ange. Die bin¨are L¨ange dieses Programms kann von oben durch ⌈log2(n + 1)⌉ + c beschr¨ankt werden, f ¨ur eine Konstante c. Somit folgt K(wn) ≤ log2(n) + c ′ Wir berechnen die L¨ange von wn als |wn| = |010| · 32n3 = 32n3+1. 24 Aufgabentyp 1 Mit ein wenig umrechnen erhalten wir n = 3 √ log3 |wn| − 1 2 und die obere Schranke K(wn) ≤ log2 ( 3 √ log3 |wn| − 1 2 ) + c ′ ≤ log2 log3 |wn| + c ′′ 25 Aufgabentyp 2 Geben Sie eine unendliche Folge von W ¨ortern y1 < y2 < ... an, so dass eine Konstante c ∈ N existiert, so dass f ¨ur alle i ≥ 1 K(yi) ≤ log2 log2 log3 log2(|yi|) + c Wir definieren die Folge y1, y2, ... mit yi = 0232i f ¨ur alle i ∈ N. Da |yi| < |yi+1| folgt die geforderte Ordnung. Es gilt i = log2 log3 log2 |yi| f ¨ur i ≥ 1 Wir zeigen ein Programm, dass i als Eingabe nimmt und yi druckt: 26 Aufgabentyp 2 begin M := i ; M := 2 ˆ ( 3 ˆ ( 2 ˆ M ) ) ; f o r I = 1 t o M ; w r i t e ( 0 ) ; end Das ˆ f ¨ur die Exponentiation ist nicht Teil der originalen Pascal Syntax, aber wir verwenden es um unser Programm lesbarer zu machen. 27 Aufgabentyp 2 Der einzige variable Teil dieses Programms ist das i. Der Rest hat konstante L¨ange. Demnach kann die L¨ange diese Programms f ¨ur eine Konstante c′ durch ⌈log2(i + 1)⌉ + c ′ von oben beschr¨ankt werden. Somit folgt K(yi) ≤ log2(i) + c ≤ log2 log2 log3 log2 |yi| + c f ¨ur eine Konstante c. 28 Aufgabentyp 3 Sei M = {7i | i ∈ N, i ≤ 2n − 1}. Beweisen Sie, dass mindestens sieben Achtel der Zahlen in M Kolmogorov-Komplexit¨at von mindestens n − 3 haben. Wir zeigen, dass h ¨ochstens 1 8 der Zahlen x ∈ M eine Kolmogorov-Komplexit¨at K(x) ≤ n − 4 haben. Nehmen wir zum Widerspruch an, dass M mehr als 1 8 |M| Zahlen x enth¨alt, mit K(x) ≤ n − 4. 29 Aufgabentyp 3 Die Programme, die diese W ¨orter generieren, m ¨ussen paarweise verschieden sein, da die W ¨orter paarweise verschieden sind. Es gibt aber h ¨ochstens n−4∑ k=0 2 k = 2n−3 − 1 < 1 8 |M| Bitstrings mit L¨ange ≤ n − 4. Widerspruch. 30 Entscheidungsproblem Das Entscheidungsproblem (Σ, L) f ¨ur ein gegebenes Alphabet Σ und eine ge- gebene Sprache L ⊆ Σ∗ ist, f ¨ur jedes x ∈ Σ∗ zu entscheiden, ob x ∈ L oder x /∈ L. Ein Algorithmus A l ¨ost das Entscheidungsproblem (Σ, L), falls f ¨ur alle x ∈ Σ∗ gilt: A(x) =    1, falls x ∈ L, 0, falls x /∈ L. Wir sagen auch, dass A die Sprache L erkennt. 31 Aufgabe 2.21 Wenn f ¨ur eine Sprache L ein Algorithmus existiert, der L erkennt, sagen wir, dass L rekursiv ist. L ∈ LR Aufgabe 2.21 Beweisen Sie, dass eine Sprache L genau dann rekursiv ist, wenn ein Aufz¨ahlungsalgorithmus f ¨ur L existiert. 32 Aufgabe 2.21 L rekursiv ( =⇒ ) existiert Aufz¨ahlungsalgorithmus: Sei A ein Algorithmus, der L erkennt. Wir beschreiben nun einen Aufz¨ahlungsalgorithmus B konstruktiv. Algorithm 1 B(Σ, n) i ← 0 while i ≤ n do w ← kanonisch n¨achstes Wort ¨uber Σ∗ if A(w) = 1 then print(w) i ← i + 1 end if end while 33 Aufgabe 2.21 Aufz¨ahlungsalgorithmus B =⇒ L rekursiv: Algorithm 2 A(Σ, w) n ← |Σ||w|+1 L ← B(Σ, n) if w ∈ L then print(1) else print(0) end if Es gibt ein kleines Problem. B k ¨onnte unendlich lange laufen, falls n > |L|. Es sollte nicht so schwierig sein, B zu modifizieren, dass es die Berechnung aufh ¨ort, falls es keine weiteren W ¨orter in L gibt. 34","libVersion":"0.3.2","langs":""}