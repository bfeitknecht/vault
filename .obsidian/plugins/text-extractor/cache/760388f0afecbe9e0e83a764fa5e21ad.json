{"path":"sem2a/PProg/UE/e/PProg-u13-e.pdf","text":"Parallel Programming Assignment 13: Linearizability and Sequential Consistency Spring Semester 2024 Assigned on: 20.05.2024 Due by: 27.05.2024 Sequential Consistency For each of the following histories, indicate if they are sequentially consistent or not. In the following the objects r and s are registers (initially zero), q is a FIFO (initially empty). A: --|r.write(1)|------------------------- B: ------|r.read():0|--------------------- C: ---------------------|r.read():1|------ A: q.enq(5) B: q.enq(3) A: void B: void A: q.deq() B: q.deq() A: 3 B: 3 A: --|s.write(1)|------------------------- B: ------|r.read():0|--------------------- C: ---------------------|r.read():1|------ A: --|s.write(1)|------------------------- B: ------|r.read():1|---|r.read():0|------ Linearizability Which of the following histories are linearizable? Infer the object type from the supported operations, registers are initially zero, stacks/queues initially empty. A: s.push(1) A: void B: s.push(2) B: void B: s.pop() A: s.pop() B: 1 A: 2 A: --|s.write(1)|------------------------- B: ------|r.read():1|---|r.read():0|------ Equivalence Give two different well-formed histories H1 and H2, which are equivalent to each other. Incomplete Histories When histories are obtained from a program trace, the history might be incomplete, i.e., if tracing stopped before the program completed. In the lecture you learned that this can be dealt with in two ways. Explain them. Why do we need both ways? Give an example where discarding all pending invocations will lead to a non-linearizable history, but adding a response will lead to a linearizable history. Deifference between Sequential Consistency and Linearizability Give a history which is sequentially consistent but not linearizable. 2","libVersion":"0.3.2","langs":""}