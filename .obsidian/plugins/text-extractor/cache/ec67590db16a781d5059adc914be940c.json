{"path":"sem2a/AuW/VRL/extra/AuW-dp.pdf","text":"Dynamic programming in probabilistic problems I. Recap on DP II. DP in probabilistic problems III. An example: frog feeding Recap on dynamic programming Decomposition in subproblems • The problem involves a ”decision” which leads to subproblems • The solution of the main problem can be obtained using the solutions of the subproblems Overlapping subproblems • While making choices, we end up with the same subproblem multiple times • Key part of DP: store and reuse previously computed solutions P P1 P2 P3 DP in probabilistic problems Decomposition in subproblems • The “decision” naturally arises in probabilistic problems • For example: • With probability 𝑝 the event 𝐸 happens • With probability (1 − 𝑝) the complement event '𝐸 happens Useful tools to come up with a recurrence relation • Law of total probability • Law of total expectation Next: we look at an example using it! An example: frog feeding Problem A frog randomly jumps from leaf to leaf and eat the flies available there pos pos+1pos-1 go left with proba prob[pos] go right with proba 1-prob[pos] flies available flies[i] Question Starting from position 𝑥, what is the expected number of flies the frog will eat in 𝑚 jumps? the frog falls into the water when jumping to position -1 or n 0 n-1 An example: frog feeding Starting from position 𝑥, what is the expected number of flies the frog eats in 𝑚 jumps? 1. Introduce two random variables: • 𝑋!: position of the frog with 𝑖 jumps left. • 𝐹!: number of flies that the frog eats in the last 𝑖 jumps. Goal: compute 𝔼[𝐹\"|𝑋\" = 𝑥] 2. Use law of total expectation (marginalize over the next position): 3. Base cases 𝔼 𝐹# 𝑋# = 𝑝 = ,lies p eat and stop there 𝔼 𝐹! 𝑋! = −1 or 𝑛 = 0 cannot eat flies after falling in the water 𝔼 𝐹! 𝑋! = 𝑝 = 8 $ 𝔼 𝐹! 𝑋!%& = 𝑞, 𝑋! = 𝑝 ℙ 𝑋!%& = 𝑞 𝑋! = 𝑝 = ,lies p + prob p 𝔼 𝐹!%& 𝑋!%& = 𝑝 − 1 + 1 − prob p 𝔼 𝐹!%& 𝑋!%& = 𝑝 + 1 eat the flies available here go to the left and continue eating flies go to the right and continue eating flies An example: frog feeding 𝔼 𝐹! 𝑋! = 𝑝 = ,lies p + prob p 𝔼 𝐹!%& 𝑋!%& = 𝑝 − 1 + 1 − prob p 𝔼 𝐹!%& 𝑋!%& = 𝑝 + 1 𝔼[𝐹\"|𝑋\" = 𝑥] 𝔼[𝐹\"%&|𝑋\"%& = 𝑥 − 1] 𝔼[𝐹\"%&|𝑋\"%& = 𝑥 + 1] 𝔼[𝐹\"%'|𝑋\"%' = 𝑥 − 2] 𝔼[𝐹\"%'|𝑋\"%' = 𝑥] 𝔼[𝐹\"%'|𝑋\"%' = 𝑥 + 2] Reuses the same computations! → use DP An example: frog feeding DP[pos][jump] = -1. for all pos, jump // default value for 𝔼[𝐹!\"#$|𝑋!\"#$ = pos] solve(pos, jump) { if (jump == 0) return flies[pos] // no jumps remaining if (pos < 0 || pos > n-1) return 0. // frog falls in the water if (DP[pos][jump] != -1.) return DP[pos][jump] // reuse previously done computation else { DP[pos][jump] = flies[pos] + prob[pos] * solve(pos-1, jump-1) + (1-prob[pos]) * solve(pos+1, jump-1) // use recurrence formula return DP[pos][jump] } } solve(x, m) Pseudo-code An example: frog feeding Pseudo-code Complexity: O(mn) DP[pos][jump] = -1. for all pos, jump // default value for 𝔼[𝐹!\"#$|𝑋!\"#$ = pos] solve(pos, jump) { if (jump == 0) return flies[pos] // no jumps remaining if (pos < 0 || pos > n-1) return 0. // frog falls in the water if (DP[pos][jump] != -1.) return DP[pos][jump] // reuse previously done computation else { DP[pos][jump] = flies[pos] + prob[pos] * solve(pos-1, jump-1) + (1-prob[pos]) * solve(pos+1, jump-1) // use recurrence formula return DP[pos][jump] } } solve(x, m) Init DP table Base cases Check for memory Otherwise compute value and store it General structure for DP algorithms Take-home messages • DP naturally arises in probablistic problems • Substructure naturally arises + overlapping subproblems • Law of total probability / expectation are powerful tools • Use double when implementing (to avoid overflows and underflows) • Be careful with initial values of the DP table • DP can be equally solved in bottom-up or top-down way","libVersion":"0.3.2","langs":""}