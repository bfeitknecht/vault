{"path":"sem2a/AuW/VRL/extra/AuW-dp.pdf","text":"Dynamic programming in probabilistic problems I. Recap on DP II. DP in probabilistic problems III. An example: frog feeding Recap on dynamic programming Decomposition in subproblems â€¢ The problem involves a â€decisionâ€ which leads to subproblems â€¢ The solution of the main problem can be obtained using the solutions of the subproblems Overlapping subproblems â€¢ While making choices, we end up with the same subproblem multiple times â€¢ Key part of DP: store and reuse previously computed solutions P P1 P2 P3 DP in probabilistic problems Decomposition in subproblems â€¢ The â€œdecisionâ€ naturally arises in probabilistic problems â€¢ For example: â€¢ With probability ğ‘ the event ğ¸ happens â€¢ With probability (1 âˆ’ ğ‘) the complement event 'ğ¸ happens Useful tools to come up with a recurrence relation â€¢ Law of total probability â€¢ Law of total expectation Next: we look at an example using it! An example: frog feeding Problem A frog randomly jumps from leaf to leaf and eat the flies available there pos pos+1pos-1 go left with proba prob[pos] go right with proba 1-prob[pos] flies available flies[i] Question Starting from position ğ‘¥, what is the expected number of flies the frog will eat in ğ‘š jumps? the frog falls into the water when jumping to position -1 or n 0 n-1 An example: frog feeding Starting from position ğ‘¥, what is the expected number of flies the frog eats in ğ‘š jumps? 1. Introduce two random variables: â€¢ ğ‘‹!: position of the frog with ğ‘– jumps left. â€¢ ğ¹!: number of flies that the frog eats in the last ğ‘– jumps. Goal: compute ğ”¼[ğ¹\"|ğ‘‹\" = ğ‘¥] 2. Use law of total expectation (marginalize over the next position): 3. Base cases ğ”¼ ğ¹# ğ‘‹# = ğ‘ = ,lies p eat and stop there ğ”¼ ğ¹! ğ‘‹! = âˆ’1 or ğ‘› = 0 cannot eat flies after falling in the water ğ”¼ ğ¹! ğ‘‹! = ğ‘ = 8 $ ğ”¼ ğ¹! ğ‘‹!%& = ğ‘, ğ‘‹! = ğ‘ â„™ ğ‘‹!%& = ğ‘ ğ‘‹! = ğ‘ = ,lies p + prob p ğ”¼ ğ¹!%& ğ‘‹!%& = ğ‘ âˆ’ 1 + 1 âˆ’ prob p ğ”¼ ğ¹!%& ğ‘‹!%& = ğ‘ + 1 eat the flies available here go to the left and continue eating flies go to the right and continue eating flies An example: frog feeding ğ”¼ ğ¹! ğ‘‹! = ğ‘ = ,lies p + prob p ğ”¼ ğ¹!%& ğ‘‹!%& = ğ‘ âˆ’ 1 + 1 âˆ’ prob p ğ”¼ ğ¹!%& ğ‘‹!%& = ğ‘ + 1 ğ”¼[ğ¹\"|ğ‘‹\" = ğ‘¥] ğ”¼[ğ¹\"%&|ğ‘‹\"%& = ğ‘¥ âˆ’ 1] ğ”¼[ğ¹\"%&|ğ‘‹\"%& = ğ‘¥ + 1] ğ”¼[ğ¹\"%'|ğ‘‹\"%' = ğ‘¥ âˆ’ 2] ğ”¼[ğ¹\"%'|ğ‘‹\"%' = ğ‘¥] ğ”¼[ğ¹\"%'|ğ‘‹\"%' = ğ‘¥ + 2] Reuses the same computations! â†’ use DP An example: frog feeding DP[pos][jump] = -1. for all pos, jump // default value for ğ”¼[ğ¹!\"#$|ğ‘‹!\"#$ = pos] solve(pos, jump) { if (jump == 0) return flies[pos] // no jumps remaining if (pos < 0 || pos > n-1) return 0. // frog falls in the water if (DP[pos][jump] != -1.) return DP[pos][jump] // reuse previously done computation else { DP[pos][jump] = flies[pos] + prob[pos] * solve(pos-1, jump-1) + (1-prob[pos]) * solve(pos+1, jump-1) // use recurrence formula return DP[pos][jump] } } solve(x, m) Pseudo-code An example: frog feeding Pseudo-code Complexity: O(mn) DP[pos][jump] = -1. for all pos, jump // default value for ğ”¼[ğ¹!\"#$|ğ‘‹!\"#$ = pos] solve(pos, jump) { if (jump == 0) return flies[pos] // no jumps remaining if (pos < 0 || pos > n-1) return 0. // frog falls in the water if (DP[pos][jump] != -1.) return DP[pos][jump] // reuse previously done computation else { DP[pos][jump] = flies[pos] + prob[pos] * solve(pos-1, jump-1) + (1-prob[pos]) * solve(pos+1, jump-1) // use recurrence formula return DP[pos][jump] } } solve(x, m) Init DP table Base cases Check for memory Otherwise compute value and store it General structure for DP algorithms Take-home messages â€¢ DP naturally arises in probablistic problems â€¢ Substructure naturally arises + overlapping subproblems â€¢ Law of total probability / expectation are powerful tools â€¢ Use double when implementing (to avoid overflows and underflows) â€¢ Be careful with initial values of the DP table â€¢ DP can be equally solved in bottom-up or top-down way","libVersion":"0.3.2","langs":""}