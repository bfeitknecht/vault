{"path":"sem3/A&D/VRL/extra/rzhang/A&D-rzhang-w13.pdf","text":"Algorithms and Datastructures (HS2024) Week 13 Rui Zhang December 22, 2024 Contents 1 Revision Theory 1 1.1 Floyd-Warshall . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.2 Johnson . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.3 All-to-All Summary . . . . . . . . . . . . . . . . . . . . . . . . . 4 2 Exercise Sheet 4 2.1 Exercise Sheet 13 - Priority List . . . . . . . . . . . . . . . . . . 4 2.2 Exercise Sheet 12 - Feedback . . . . . . . . . . . . . . . . . . . . 4 2.3 Exercise Sheet 11 - Feedback . . . . . . . . . . . . . . . . . . . . 4 3 Supplementary Exercises 5 3.1 Johnson Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1 Revision Theory A ’one-to-all’ shortest-path-finding algorithm finds the shortest path starting at some vertex s to all other vertices v ∈ V \\{s}. You have seen BFS for unweighted graphs and Dijkstra and Bellmann-Ford for weighted graphs (exercise: why do we have two algorithms for weighted graphs?). Now, we will develop efficient ’all-to-all’ shortest-path-algorithms, that work on any weighted graph, regardless of exact weights. 1.1 Floyd-Warshall Floyd-Warshall is DP again. Consider the following DP-Definition: DP [i][u][v] := ”length of shortest walk from u to v using only vertices from 1 to i in between (not counting u and v)” 1 With this definition, we have the following: Base Cases: DP [0][u][u] = 0 ∀u ∈ V DP [0][u][v] = c(u, v) ∀(u, v) ∈ E DP [0][u][v] = ∞ ∀(u, v) /∈ E Recursion: DP [i][u][v] = min{DP [i − 1][u][v], DP [i − 1][u][i] + DP [i − 1][i][v]} There are three cases for this recursion: 1. vertex i does not appear on walk from u to v 2. vertex i appears exactly once on walk from u to v 3. vertex i appears more than once on walk from u to v Note that case 3 is not represented in the recursive formula, the reason being that repetition of some vertex i on a shortest walk implies the existence of a negative cycle. As an exercise, try to assign each of the two other cases 1. and 2. the correct term in the recursive formula and explain why it is correct. Calculation Order: for i from 1 to n (ascendingly): for u in V (no specific order): for v in V (no specific order): calculate DP[i][u][v] like above Solution Extraction: If you want to find the length of the shortest path from u to v, then return DP [n][u][v]. Finding Negative Cycles: You can also find negative cycles via Floyd-Warshall: After computing the en- tire DP-table, check the entries DP [n][v][v] for all v ∈ V . If any of these entries is negative, then by definition, the shortest walk from v to itself if we allow for all vertices on that walk, is of negative length (so there exists a negative cycle somewhere). Runtime: Runtime is the number of entries we have to calculate, since each entry can be calculated in O(1). Thus O(n3). 2 1.2 Johnson Derivation: One idea for all-to-all path-finding would be applying Dijkstra n times - starting at each vertex once. However, this will only work for graphs without negative edge weights. You might have thought about increasing every edge weight by some number such that the resulting edge weights are all non-negative and then running Dijkstra on a graph. This does not work. Consider finding a shortest path from A to C in the following: A B C 4 6 -3 If we increase all edge weights on this graph by 3, then suddenly the direct edge from A to C becomes the new shortest path, which is different from the original shortest path via B. Notice: paths with more edges are ”penalized” more when we increase each edge by the same amount. (*) Given a graph G = (V, E, c) with edge weights specified by c, we want to create a new graph G = (V, E, c′) such that c ′(u, v) ≥ 0 ∀(u, v) ∈ E (1) and c′(u → v) = c(u → v) + g(u, v) (2) where c(u → v) denotes the lenght of some path from u to v. Notice that (2) prevents what we had in (*): We want every path length to be increased by some amount only dependent on their endpoints. To reach this goal, we realize that to fulfil (1), we still have to add some positive number to the edge weights dependent on the starting and end vertices of that edge: c ′(u, v) = c(u, v) + f (u, v). For those proficient with telescoping sums, you may realize that choosing f (u, v) = h(u)−h(v) will satisfy the second condition, with c′(u → v) = c(u → v) + h(u) − h(v). As a final step, we have to define h such that (1) holds. If we rewrite (1) we get: c ′(u, v) = c(u, v) + h(u) − h(v) ≥ 0 ⇔ c(u, v) + h(u) ≥ h(v). For those who have worked a lot with graph theory and shortest paths, it becomes clear that this inequality looks very familiar if we choose h(v) to be some shortest 3 path length ending in v. Thus we get the following idea: Algorithm: We add another vertex z /∈ V to the original graph, with a directed edge to every vertex in V with weight 0. We are able to define h(v) then as the shortest path length from z to v. Then we may modify the graph via the formula we had derived and apply Dijkstra n times. What is even more: finding the shortest path starting at z must be done with Bellman-Ford, since we may have negative edges still at this point. Then, in the same process, we may find out if there are any negative cycles in the original graph. If we do find one, we do not need to run the rest of the algorithm. 1.3 All-to-All Summary Algorithm Graph Runtime n × BFS unweighted graphs O(nm) n × Dijsktra weighted, non-negative graphs O(n(n + m) log(n)) Floyd-Warshall weighted graphs, ideally dense O(n3) Johnson weighted graphs, ideally sparse O(n(n + m) log(n)) 2 Exercise Sheet 2.1 Exercise Sheet 13 - Priority List • - 13.2, 13.3 - obviously, since they were exam exercises • - 13.1 - good revision for path-finding algorithms • - 13.4 - interesting exercise, but takes a lot of effort and is not as relevant. 2.2 Exercise Sheet 12 - Feedback • 12.1 was solved excellently by most of you. • Exercise 12.3 was especially hard. Do not worry too much if you struggled with that exercise. A look into the solutions is recommended. • 12.5 was a bit more challenging but most of you got the idea. Try to be more careful with the reasoning. When choosing a replacement-edge f for a ’heavy’ edge e, we have to choose it such that it is on the cycle that made e ’heavy’ in the first place (so a cycle where actually all of the edges have less weight). This is because e could be on multiple cycles. 2.3 Exercise Sheet 11 - Feedback This is a recap of what was said in class. 4 • important: This exercise sheet was mostly about the ”layering” approach for graphs. The idea was usually to copy the graph given some number of times and modify the edges, then run some known algorithm. In an exam, try to define the set of edges and vertices formally. This level of formalism is indeed expected of you. • In the exericse ”Rail Racer”, there were stations and checkpoints. Each was a vertex in the graph we were supposed to model. Every station / checkpoint had a speedlimit however. And since we want to find the fastest route from station Zurich to Zermatt, it may seem intuitive to just let the train travel at the fastest possible speed between two stations. (top speed, as fast as the speedlimit). However, since the train can only accelerate a total of 50km/h, we could have a problem. Thus, the correct solution would have been to triple the amount of vertices (create three copies for each vertex). Each representing a different speed at which the train travels through this vertex. • The task rotating weights was especially complicated. In the end, there was a typo in the task so everybody got the point. The original idea was to find a shortest walk. Since the edge-weights rotated, it may have been better to repeat a vertex. The original task specified to find a shortest path though. The intended solution was to apply Bellmann-Ford on a graph where we had n copies of each vertex, representing how much we have ”rotated”. Many of you opted for a DP solution on the original graph. However, notice that the DP solution was basically the actual implementation of Bellmann-Ford. 3 Supplementary Exercises 3.1 Johnson Conditions Prove that by choosing f in the format f (u, v) = h(u) − h(v), you will indeed get c ′(u → v) = c(u → v) + g(u, v), the second condition we needed for Johnson. Hint: think of how a path looks like from u to v and what the cost of that path is in terms of a sum. 5","libVersion":"0.3.2","langs":""}