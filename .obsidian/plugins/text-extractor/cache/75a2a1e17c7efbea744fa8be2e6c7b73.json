{"path":"sem4/FMFP/UE/s/FMFP-u09-s.pdf","text":"P. M¨uller, D. Basin and R. Jung Formal Methods and Functional Programming Exercise Sheet 9: States and Expressions Submission deadline: April 22nd/23rd, 2025 Assignment 1 (Simplifying State Updates) In this assignment, we will prove statements that allow us to “clean up” states as we apply additional state updates to them: If many state updates to the same variable have been applied, you can always leave out all but the last one (Tasks 1.1 and 1.3), and reordering state updates applied to different variables never change the state (Task 1.2). Task 1.1: Prove that, for all states σ, all variables x, and all values v1 and v2, we have σ[x ↦→ v1][x ↦→ v2] = σ[x ↦→ v2]. Solution. Let the state σ, the variable x, and the values v1 and v2 be arbitrary. We need to show ∀y · σ[x ↦→ v1][x ↦→ v2](y) = σ[x ↦→ v2](y). Using the definition of state update, for an arbitrary variable y, we have σ[x ↦→ v1][x ↦→ v2](y) = { v2 if y ≡ x σ[x ↦→ v1](y) if y ̸≡ x = { v2 if y ≡ x σ(y) if y ̸≡ x = σ[x ↦→ v2](y). Task 1.2: Prove that, for all states σ, all variables x and y with x ̸≡ y, and all values v and w, we have σ[x ↦→ v][y ↦→ w] = σ[y ↦→ w][x ↦→ v]. 1 Solution. Let the state σ, the variables x and y with x ̸≡ y, and the values v and w be arbitrary. We need to show that ∀z · σ[x ↦→ v][y ↦→ w] = σ[y ↦→ w][x ↦→ v]. Using the definition of state update, for an arbitrary z, we have σ[x ↦→ v][y ↦→ w](z) = { w if z ≡ y σ[x ↦→ v](z) if z ̸≡ y =    w if z ≡ y v if z ̸≡ y and z ≡ x σ(z) if z ̸≡ y and z ̸≡ x (∗) =    v if z ≡ x w if z ̸≡ x and z ≡ y σ(z) if z ̸≡ x and z ̸≡ y = { v if z ≡ x σ[y ↦→ w](z) if z ̸≡ x = σ[y ↦→ w][x ↦→ v](z) Note that the rewriting of the cases in the step marked with (∗) only works because we assumed that x ̸≡ y. And, indeed, the overall result is not true with this condition, as we see from the counter-example with v = 1, w = 2, and x ≡ y ≡ z: σ[x ↦→ v][y ↦→ w](z) = w = 2 ̸= 1 = v = σ[y ↦→ w][x ↦→ v](z) Task 1.3: Prove that, for all states σ, all variables x, all values v1 and v2, all natural numbers n, and all sequences ⃗y ≡ ⟨y1, . . . , yn⟩ and ⃗w ≡ ⟨w1, . . . , wn⟩ of variables and values, respectively, we have σ[x ↦→ v1][⃗y ↦→ ⃗w][x ↦→ v2] = σ[⃗y ↦→ ⃗w][x ↦→ v2], where σ[⃗y ↦→ ⃗w] denotes the sequence of updates σ[y1 ↦→ w1] . . . [yn ↦→ wn]. Note: This task is a bit more involved. Solution. Let the variable x, the values v1 and v2 be arbitrary. We define P (n) ≡ ∀σ, ⃗y, ⃗w · ( |⃗y| = | ⃗w| = n =⇒ σ[x ↦→ v1][⃗y ↦→ ⃗w][x ↦→ v2] = σ[⃗y ↦→ ⃗w][x ↦→ v2] ) and prove ∀n · P (n) by weak induction over n: • Base Case: We show P (0). We consider some arbitrary state σ and sequences ⃗y and ⃗w of variables and values, respectively. We assume |⃗y| = | ⃗w| = 0. In this case, the sequences ⃗y and ⃗w can only be empty. Thus, the claim to be proved is σ[x ↦→ v1][x ↦→ v2] = σ[x ↦→ v2], which immediately follows from Task 1.1. • Step Case: For some arbitrary n, we assume that P (n) holds and aim to prove that P (n + 1) also holds. Let the state σ and the sequences ⃗y and ⃗w of variables and values, 2 respectively, be arbitrary. We assume that |⃗y| = | ⃗w| = n + 1, i.e., that ⃗y ≡ ⟨y1, . . . , yn+1⟩ and ⃗w = ⟨w1, . . . , wn+1⟩ for some appropriate variables yi and values wi. We proceed with a case analysis on the variable y1: – Case y1 ≡ x: By Task 1.1, we have σ[x ↦→ v1][y1 ↦→ w1] = σ[y1 ↦→ w1] and therefore σ[x ↦→ v1][y1 ↦→ w1][y2 ↦→ w2] . . . [yn+1 ↦→ wn+1][x ↦→ v2] = σ[y1 ↦→ w1][y2 ↦→ w2] . . . [yn+1 ↦→ wn+1][x ↦→ v2], as required. – Case y1 ̸≡ x: We have σ[x ↦→ v1][y1 ↦→ w1][y2 ↦→ w2] . . . [yn+1 ↦→ wn+1][x ↦→ v2] = σ[y1 ↦→ w1][x ↦→ v1][y2 ↦→ w2] . . . [yn+1 ↦→ wn+1][x ↦→ v2] (Task 1.2) = σ[y1 ↦→ w1][y2 ↦→ w2] . . . [yn+1 ↦→ wn+1][x ↦→ v2] (IH) where the first equality follows from Task 1.2, and the second equality follows from the induction hypothesis P (n) (instantiating the quantifiers as follows: σ ⇝ σ[y1 ↦→ w1], ⃗y ⇝ ⟨y2, . . . , yn+1⟩, and ⃗w ⇝ ⟨w2, . . . , wn+1⟩; note that we are only able to conclude the desired claim since ⃗y and ⃗w are both instantiated with sequences of length n). 3 Assignment 2 (Substitution Properties) In the exercise session, we proved a substitution lemma for arithmetic expressions: ∀σ, e, e ′, x · (A[[e[x ↦→ e′]]]σ = A[[e]](σ[x ↦→ A[[e ′]]σ]) ) Task: Prove the corresponding statement for boolean expressions, i.e, prove that ∀σ, b, e, x · ( B[[b[x ↦→ e]]]σ = B[[b]](σ[x ↦→ A[[e]]σ]) ) . Solution. Recall the definition of substitution on boolean expressions b[x ↦→ e] ≡    e1[x ↦→ e] op e2[x ↦→ e] if b ≡ e1 op e2 not b′[x ↦→ e] if b ≡ not b′ b1[x ↦→ e] ◦ b2[x ↦→ e] if b ≡ b1 ◦ b2 for some ◦ ∈ {and, or} (*) and the lemma proved in the exercise session ∀σ, e, e ′, x · ( A[[e[x ↦→ e′]]]σ = A[[e]](σ[x ↦→ A[[e ′]]σ]) ). (**) Proof: Let the state σ, the variable x, and the expression e be arbitrary (note that we deal with the inner quantifiers first here; several consecutive for-all quantifiers can always be reordered). We define P (b) ≡ (B[[b[x ↦→ e]]]σ = B[[b]](σ[x ↦→ A[[e]]σ]) ) and prove ∀b · P (b) by structural induction on the boolean expression b: • Or Case: We need to prove P (b1 or b2), for some boolean expressions b1, b2, and may assume P (b1) and P (b2) as our induction hypothesis. We have B[[(b1 or b2)[x ↦→ e]]]σ = B[[b1[x ↦→ e] or b2[x ↦→ e]]]σ (*) = B[[b1[x ↦→ e]]]σ ∨ B[[b2[x ↦→ e]]]σ (B) = B[[b1]](σ[x ↦→ A[[e]]σ]) ∨ B[[b2]](σ[x ↦→ A[[e]]σ]) (IH) = B[[b1 or b2]](σ[x ↦→ A[[e]]σ]), (B) where ∨ denotes the function that maps to tt if at least one of its arguments is tt. • And Case: Analogous to the previous case. • Not Case: We need to prove P (not b′), for some boolean expression b′, and may assume P (b′) as our induction hypothesis. We have B[[(not b′)[x ↦→ e]]]σ = B[[not b′[x ↦→ e]]]σ (*) = ¬B[[b′[x ↦→ e]]]σ (B) = ¬B[[b′]](σ[x ↦→ A[[e]]σ]) (IH) = B[[(not b′)]](σ[x ↦→ A[[e]]σ]), (B) where ¬ denotes the function that maps tt to ff and ff to tt. 4 • Relation Case: We need to show P (e1 op e2), for some arithmetic expressions e1, e2 and and arithmetic relation op. We have B[[(e1 op e2)[x ↦→ e]]]σ = B[[e1[x ↦→ e] op e2[x ↦→ e]]]σ (*) = A[[e1[x ↦→ e]]]σ op A[[e2[x ↦→ e]]]σ (B) = A[[e1]](σ[x ↦→ A[[e]]σ]) op A[[e2]](σ[x ↦→ A[[e]]σ]) (**) = B[[e1 op e2]](σ[x ↦→ A[[e]]σ]), (B) where op denotes the operation corresponding to op. 5","libVersion":"0.5.0","langs":""}