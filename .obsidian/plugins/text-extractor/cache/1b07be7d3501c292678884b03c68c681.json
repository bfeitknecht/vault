{"path":"sem3/TI/VRL/extra/nwehrl/TI-nwehrl-w10.pdf","text":"Theoretische Informatik HS24 Nicolas Wehrli ¨Ubungsstunde 10 26. November 2024 ETH Z ¨urich nwehrl@ethz.ch 1 Heute 1 Feedback zur Serie 2 Komplexit¨atstheorie 3 Nichtdeterministische Komplexit¨atstheorie 2 Feedback zur Serie Feedback 1. Unterschied EE-Reduktion und R-Reduktion 2. Reduktion alleine reicht nicht. Ihr m ¨usst noch die Konsequenz davon aufzeigen, um die gew ¨unschte Aussage zu beweisen. 3. zus¨atzliche n 12 kommen vom zur ¨uckbewegen des Kopfes an den Start, nicht vom Schreiben! 3 Implikationsbeweis f ¨ur Reduktion Wenn eine Reduktion verlangt wird, dann d ¨urft ihr die Implikation nicht trivial per Implikationsaussage zeigen. Gemeint damit ist folgender Ansatz. L1 ≤R L2 soll gezeigt werden. Da per Definition L1 ≤R L2 ⇐⇒ (L2 ∈ LR =⇒ L1 ∈ LR) folgt die gew ¨unschte Aussage per L2 /∈ LR (oder L1 ∈ LR). Dieser Ansatz gibt an der Pr ¨ufung 0 Punkte. 4 Komplexit¨atstheorie Time Sei M eine MTM oder TM, die immer h¨alt. Sei Σ das Eingabealphabet von M. Sei x ∈ Σ∗ und D = C1, C2, ..., Ck die Berechnung von M auf x. Die Zeitkomplexit¨at TimeM(x) der Berechnung von M auf x ist definiert durch TimeM(x) = k − 1. Die Zeitkomplexit¨at von M ist die Funktion TimeM : N → N, definiert durch TimeM(n) = max {TimeM(x) | x ∈ Σn} . 5 Space Sei k ∈ N \\ {0}. Sei M eine k-Band-TM, die immer h¨alt. Sei C = (q, x, i, α1, i1, α2, i2, ..., αk, ik) mit 0 ≤ i ≤ |x| + 1 und 0 ≤ ij ≤ |αj| f ¨ur j = 1, ..., k eine Konfiguration von M. Die Speicherplatzkomplexit¨at von C ist SpaceM(C) = max{|αi| | i = 1, ..., k}. 6 Space Sei C1, C2, ..., Cl die Berechnung von M auf x. Die Speicherplatzkomplexit¨at von M auf x ist SpaceM(x) = max { SpaceM(Ci) | i = 1, ..., l} . Die Speicherplatzkomplexit¨at von M ist die Funktion SpaceM : N → N, defi- niert durch SpaceM(n) = max {SpaceM(x) | x ∈ Σn} . 7 Space Bemerkungen 1. L¨ange des Eingabewortes, hat keinen Einfluss auf die Speicherplatzkomplexit¨at. 2. M¨achtigkeit des Alphabets hat keinen Einfluss auf die Speicherplatzkomplexit¨at. 8 Space Lemma 6.1 Sei k ∈ N\\{0}. F ¨ur jede k-Band-TM A, die immer h¨alt, existiert eine ¨aquivalente 1-Band-TM B, so dass SpaceB(n) ≤ SpaceA(n) Beweisskizze: Gleiche Konstruktion wie in Lemma 4.2. Lemma 4.2 = ”F ¨ur jede MTM A existiert eine ¨aquivalente TM B”. Wir sehen, dass B genau so viele Felder braucht, wie A. 9 Space Lemma 6.2 Zu jeder MTM A existiert eine ¨aquivalente MTM B mit SpaceB(n) ≤ SpaceA(n) 2 + 2 Beweisskizze: Wir fassen jeweils 2 Felder von A zu einem Feld in B zusammen. ΓB = ΓA × ΓA. Wir addieren 1 f ¨ur das g am linken Rand und 1 f ¨ur das Aufrunden im Fall von ungerader L¨ange. 10 Konfiguration Wir erinneren uns: Konfiguration einer k-Band-TM Die Konfiguration einer k-Band-TM sieht wie folgt aus (q, w, i, u1, i1, u2, i2, ..., uk, ik) ∈ Q × Σ∗ × N × (Γ∗ × N)k wobei ▶ q der Zustand der TM ist ▶ g w$ der Inhalt des Eingabebandes, Lesekopf Eingabeband auf dem i-ten Feld ▶ f ¨ur j ∈ {1, ..., k} ist der Inhalt des j-ten Bandes g uj und ij ≤ |uj| die Position des Kopfs auf dem j-ten Band. 11 Asymptotik ▶ O(f(n)): Menge aller Funktionen, die asymptotisch nicht schneller wachsen als f (n). ▶ Ω(g(n)): Menge aller Funktionen, die asymptotisch mind. so schnell wachsen wie g(n). ▶ Θ(h(n)): Menge aller Funktionen, die asymptotisch gleich schnell wachsen wie h(n). Small o-notation Seien f und g zwei Funktionen von N nach R+. Falls limn→∞ f (n) g(n) = 0, dann sagen wir, dass g asymptotisch schneller w¨achst als f : f (n) ∈ o(g(n)) 12 Bloomsches Speedup Theorem Satz 6.1 Es existiert ein Entscheidungsproblem (Σbool, L), so dass f ¨ur jede MTM A, die (Σbool, L) entscheidet, eine MTM B existiert, die auch (Σbool, L) entscheidet, und f ¨ur die gilt TimeB(n) ≤ log2(TimeA(n)) f ¨ur unendlich viele n ∈ N. I.e. es existieren Entscheidungsprobleme, die keinen optimalen Algorithmus haben. Deswegen fokussieren wir uns auf untere und obere Schranken der Komplexit¨at eines Problemes und nicht auf die genaue Bestimmung davon. 13 Komplexit¨at eines Entscheidungsproblems (Σ, L) Sei L eine Sprache. Sei f , g : N → R+. ▶ O(g(n)) ist eine obere Schranke f ¨ur die Zeitkomplexit¨at von L, falls eine MTM A existiert, die L entscheidet und TimeA(n) ∈ O(g(n)). ▶ Ω(f (n)) ist eine untere Schranke f ¨ur die Zeitkomplexit¨at von L, falls f ¨ur jede MTM B die L entscheidet und TimeB(n) ∈ Ω(f (n)). ▶ Eine MTM C heisst optimal f ¨ur L, falls TimeC(n) ∈ O(f (n)) und Ω(f (n)) eine untere Schranke f ¨ur die Zeitkomplexit¨at ist. Untere Schranke finden und beweisen: schwierig. Obere Schranke kann durch einen konkreten Algorithmus gezeigt werden. 14 Komplexit¨atsklassen Klassen F ¨ur alle Funktionen f , g : N → R+ definieren wir TIME(f) = {L(B) | B ist eine MTM mit TimeB(n) ∈ O(f (n))} SPACE(g) = {L(A) | A ist eine MTM mit SpaceA(n) ∈ O(g(n))} DLOG = SPACE(log2 n) P = ⋃ c∈N TIME(nc) PSPACE = ⋃ c∈N SPACE(nc) EXPTIME = ⋃ d∈N TIME(2 nd) 15 Zeitkomplexit¨at zu Platzkomplexit¨at Lemma 6.3 F ¨ur jede Funktion t : N → R+ gilt TIME(t(n)) ⊆ SPACE(t(n)) Beweisskizze: In O(t(n)) Schritten sind h ¨ochstens O(t(n)) Felder beschreibbar. Korollar 6.1 P ⊆ PSPACE 16 Platzkonstruierbarkeit Eine Funktion: s : N → N heisst platzkonstruierbar, falls eine 1-Band-TM M existiert, so dass (i) SpaceM(n) ≤ s(n) f ¨ur alle n ∈ N und (ii) f ¨ur jede Eingabe 0n, generiert M das Wort 0s(n) auf ihrem Arbeitsband und h¨alt in qaccept. 17 Zeitkonstruierbarkeit Eine Funktion: t : N → N heisst zeitkonstruierbar, falls eine MTM A existiert, so dass (i) TimeA(n) ≤ O(t(n)) f ¨ur alle n ∈ N und (ii) f ¨ur jede Eingabe 0n, generiert A das Wort 0t(n) auf dem ersten Arbeitsband und h¨alt in qaccept. 18 Platzgarantien Lemma 6.4 (verst¨andlicher formuliert) Sei s : N → N platzkonstruierbar. F ¨ur jede MTM M, f ¨ur welche SpaceM(w) ≤ s(|w|) nur f ¨ur alle w ∈ L(M) erf ¨ullt, existiert eine ¨aquivalente MTM A, welche dies f ¨ur alle w ∈ Σ∗ erf ¨ullt. Beweisskizze: Erzeuge f ¨ur jede Eingabe x ∈ Σ∗ zuerst 0s(|x|) auf einem zus¨atzlichen Band und nutze das als Platz ¨uberwachung. Wenn A diesen Platz ¨uberschreiten will, wird die Simulation unterbrochen und die Eingabe verworfen. 19 Zeitgarantien Lemma 6.5 (verst¨andlicher formuliert) Sei t : N → N zeitkonstruierbar. Zu jeder MTM M, welche TimeM(w) ≤ t(|w|) nur f ¨ur alle w ∈ L(M) erf ¨ullt, existiert eine ¨aquivalente MTM A mit TimeA(n) ∈ O(t(n)) Beweisskizze 1. Schreibe f ¨ur jede Eingabe w ∈ Σ∗ 0t(|w|) auf ein zus¨atzliches Arbeitsband und nutze dies zur Zeitz¨ahlung. 2. Wenn A mehr Schritte machen will, wird die Simulation abgebrochen und die Eingabe verworfen. 3. Erster Schritt in O(t(n)) und die Simulation auf w dauert O(t(n)) 20 Satz 6.2 F ¨ur jede Funktion s mit s(n) ≥ log2(n) gilt: SPACE(s(n)) ⊆ ⋃ c∈N TIME(c s(n)) Beweis Sei L ∈ SPACE(s(n)). Nach Lemma 6.1 existiert eine 1-Band-TM M = (Q, Σ, Γ, δ, q0, qaccept, qreject), die immer h¨alt, so dass L = L(M) und SpaceM(n) ≤ d · s(n) f ¨ur d ∈ N gelten. 21 Speicherplatzkomplexit¨at zu Zeitkomplexit¨at F ¨ur jede Konfiguration C = (q, w, i, x, j) von M definieren wir die innere Konfiguration von C als In(C) = (q, i, x, j). Die innere Konfiguration enth¨alt das Eingabewort w nicht, da dies sich w¨ahrend einer Berechnung nicht ¨andert. 22 Speicherplatzkomplexit¨at zu Zeitkomplexit¨at Sei InKonfM(n) die Menge aller m ¨oglichen inneren Konfigurationen auf Eingabew ¨ortern der L¨ange n. Sei X = |InKonfM(n)| dessen Kardinalit¨at. Sei D = C1C2...Ck eine endliche Berechnung von M auf einem Wort w, |w| = n. Wir zeigen per Widerspruch, dass D maximal X verschiedene Konfigurationen haben kann, i.e. k ≤ X. 23 Speicherplatzkomplexit¨at zu Zeitkomplexit¨at Nehmen wir zum Widerspruch an k > X. Dann muss es in D = C1C2...Ci...Cj...Ck, zwei identische innere Konfigurationen In(Ci) und In(Cj) geben (f ¨ur i < j). Da M deterministisch ist, sollte aber von Ci = Cj aus immer die gleichen Berechnungsschritte ausgef ¨uhrt werden. Dann w¨are aber D eine unendliche Berechnung mit der Endlosschleife CiCi+1...Cj. Widerspruch, da M immer h¨alt. 24 Speicherplatzkomplexit¨at zu Zeitkomplexit¨at Eine beliebige endliche Berechnung D von M auf w, |w| = n, kann h ¨ochstens X viele Zeitschritte (i.e. Konfigurationen) haben. Jetzt m ¨ussen wir noch X = |InKonfM(n) absch¨atzen. Wir wissen folgendes ▶ Es gibt |Q| verschieden m ¨ogliche Zust¨ande. ▶ Index des Eingabekopfes ist 0 ≤ i ≤ n + 1 (Eingabeband g w$ mit |w| = n) ▶ Inhalt des Arbeitsbandes x hat L¨ange: |x| ≤ SpaceM(n) ≤ d · s(n) ▶ Index vom Kopf auf dem Arbeitsband: 0 ≤ j ≤ SpaceM(n) ≤ d · s(n) ▶ x ∈ Γ|x| ▶ n + 2 ≤ 4log2 n ≤ 4s(n) f ¨ur n ≥ 2 25 Speicherplatzkomplexit¨at zu Zeitkomplexit¨at Setzen wir alles zusammen: |InKonfM(n)| ≤ |Q| · (n + 2) · |Γ| SpaceM(n) · SpaceM(n) ≤ (max{4, |Q|, |Γ|}) 4d·s(n) ≤ c s(n) ■ 26 Nichtdeterministische Komplexit¨atstheorie Nichtdeterministische Komplexit¨atsmasse Sei M eine NTM oder nichtdet. MTM. Sei x ∈ L(M). - TimeM(x) ist die L¨ange der k ¨urzesten akzeptierenden Berechnung von M auf x. - TimeM(n) = max({TimeM(x) | x ∈ L(M) ∧ |x| = n} ∪ {0}) - SpaceM(C) = max{SpaceM(Ci) | i = 1, ..., m} f ¨ur eine Berechnung C = C1, ..., Cm von M. - SpaceM(x) = min{SpaceM(C) | C ist eine Berechnung von M auf x} - SpaceM(n) = max({SpaceM(x) | x ∈ L(M) ∧ |x| = n} ∪ {0}) 27 Lemma 6.6 Lemma 6.6 F ¨ur alle t, s mit s(n) ≥ log2(n) gilt: (i) NTIME(t) ⊆ NSPACE(t) (ii) NSPACE(s) ⊆ ⋃ c∈N NTIME(cs(n)) Beweisskizze (i) K ¨urzeste akzeptierende Berechnung betrachten. Kann in h ¨ochstens t Zeitschritten h ¨ochstens t Felder beschreiben. (ii) K ¨urzeste akzeptierende Berechnung betrachten. Innere Konfigurationen z¨ahlen. Eine Konfiguration kann nicht zweimal vorkommen sonst ist es nicht die k ¨urzeste Berechnung. 28 Satz 6.5 Satz 6.5 Sei s : N → N, t : N → R+ platzkonstruierbar. Dann gilt: (i) TIME(t) ⊆ NTIME(t) (ii) SPACE(t) ⊆ NSPACE(t) (iii) NTIME(s(n)) ⊆ SPACE(s(n)) ⊆ ⋃c∈N TIME(cs(n)) Beweisskizze Anzahl Transitionsm ¨oglichkeiten beschr¨ankt durch ein r. In t Schritten gibt es h ¨ochstens rt m ¨ogliche Berechnungen. Man kann auf einem zus¨atzlichen Band alle Entscheidungsketten durchiterieren. F ¨ur jede Entscheidungskette deterministisch simulieren. 29","libVersion":"0.5.0","langs":""}