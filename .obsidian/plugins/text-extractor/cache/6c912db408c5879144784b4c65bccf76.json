{"path":"sem4/DMDB/UE/slides/DMDB-s02-SQL-2.pdf","text":"Omar Hammoud & Marko Kabić Data Modelling & Databases Exercise 3: SQL II Spring 2025 ohammoud@student.ethz.ch marko.kabic@inf.ethz.ch Information There is a guide at the start to help you connect to the database. Question 1 Construct a query that finds all female employees who have ever worked in the Research department. Return their employee number, first name, and last name. We consider here the employee dataset: Question 1 1. SELECT e.emp_no, e.first_name, e.last_name 2. FROM employees e 3. JOIN dept_emp de ON e.emp_no = [[]] 4. JOIN departments d ON [[]] = d.dept_no 5. WHERE d.dept_name = [[]] 6. AND e.gender = [[]] ; Construct a query that finds all female employees who have ever worked in the Research department. Return their employee number, first name, and last name. Question 1 1. SELECT e.emp_no, e.first_name, e.last_name 2. FROM employees e 3. JOIN dept_emp de ON e.emp_no = de.emp_no 4. JOIN departments d ON [[]] = d.dept_no 5. WHERE d.dept_name = [[]] 6. AND e.gender = [[]] ; Construct a query that finds all female employees who have ever worked in the Research department. Return their employee number, first name, and last name. Question 1 1. SELECT e.emp_no, e.first_name, e.last_name 2. FROM employees e 3. JOIN dept_emp de ON e.emp_no = de.emp_no 4. JOIN departments d ON de.dept_no = d.dept_no 5. WHERE d.dept_name = [[]] 6. AND e.gender = [[]] ; Construct a query that finds all female employees who have ever worked in the Research department. Return their employee number, first name, and last name. Question 1 1. SELECT e.emp_no, e.first_name, e.last_name 2. FROM employees e 3. JOIN dept_emp de ON e.emp_no = de.emp_no 4. JOIN departments d ON de.dept_no = d.dept_no 5. WHERE d.dept_name = ‘Research’ 6. AND e.gender = [[]] ; Construct a query that finds all female employees who have ever worked in the Research department. Return their employee number, first name, and last name. Question 1 1. SELECT e.emp_no, e.first_name, e.last_name 2. FROM employees e 3. JOIN dept_emp de ON e.emp_no = de.emp_no 4. JOIN departments d ON de.dept_no = d.dept_no 5. WHERE d.dept_name = ‘Research’ 6. AND e.gender = ‘F’; Construct a query that finds all female employees who have ever worked in the Research department. Return their employee number, first name, and last name. Question 2 Construct a query that lists the total number of employees in each department, but only include departments with more than 100 employees. Return the department name and count. We consider here the employee dataset: Question 2 1. SELECT d.dept_name, COUNT( [[]] ) AS employee_count 2. FROM employees e 3. JOIN dept_emp de ON e.emp_no = de.emp_no 4. JOIN departments d ON [[]] = d.dept_no 5. GROUP BY [[]] 6. HAVING [[]] > 100; Construct a query that lists the total number of employees in each department, but only include departments with more than 100 employees. Return the department name and count. Question 2 1. SELECT d.dept_name, COUNT( e.emp_no) AS employee_count 2. FROM employees e 3. JOIN dept_emp de ON e.emp_no = de.emp_no 4. JOIN departments d ON [[]] = d.dept_no 5. GROUP BY [[]] 6. HAVING [[]] > 100; Construct a query that lists the total number of employees in each department, but only include departments with more than 100 employees. Return the department name and count. Question 2 1. SELECT d.dept_name, COUNT( e.emp_no) AS employee_count 2. FROM employees e 3. JOIN dept_emp de ON e.emp_no = de.emp_no 4. JOIN departments d ON de.dept_no = d.dept_no 5. GROUP BY [[]] 6. HAVING [[]] > 100; Construct a query that lists the total number of employees in each department, but only include departments with more than 100 employees. Return the department name and count. Question 2 1. SELECT d.dept_name, COUNT( e.emp_no) AS employee_count 2. FROM employees e 3. JOIN dept_emp de ON e.emp_no = de.emp_no 4. JOIN departments d ON de.dept_no = d.dept_no 5. GROUP BY de.emp_no 6. HAVING [[]] > 100; Construct a query that lists the total number of employees in each department, but only include departments with more than 100 employees. Return the department name and count. Question 2 1. SELECT d.dept_name, COUNT( e.emp_no) AS employee_count 2. FROM employees e 3. JOIN dept_emp de ON e.emp_no = de.emp_no 4. JOIN departments d ON de.dept_no = d.dept_no 5. GROUP BY de.emp_no 6. HAVING COUNT(e.emp_no) > 100; Construct a query that lists the total number of employees in each department, but only include departments with more than 100 employees. Return the department name and count. Question 3 Construct a query that finds all employees who have a salary greater than 80000 and hold the title 'Senior Engineer'. Return their employee number, salary, and title. We consider here the employee dataset: Question 3 1. SELECT e.emp_no, s.salary, t.title 2. FROM employees e 3. JOIN salaries s ON [[]] 4. JOIN titles t ON [[]] 5. WHERE s.salary [[]] 80000 6. AND t.title = [[]] ; Construct a query that finds all employees who have a salary greater than 80000 and hold the title 'Senior Engineer'. Return their employee number, salary, and title. Question 3 1. SELECT e.emp_no, s.salary, t.title 2. FROM employees e 3. JOIN salaries s ON e.emp_no = s.emp_no 4. JOIN titles t ON [[]] 5. WHERE s.salary [[]] 80000 6. AND t.title = [[]] ; Construct a query that finds all employees who have a salary greater than 80000 and hold the title 'Senior Engineer'. Return their employee number, salary, and title. Question 3 1. SELECT e.emp_no, s.salary, t.title 2. FROM employees e 3. JOIN salaries s ON e.emp_no = s.emp_no 4. JOIN titles t ON e.emp_no = t.emp_no 5. WHERE s.salary [[]] 80000 6. AND t.title = [[]] ; Construct a query that finds all employees who have a salary greater than 80000 and hold the title 'Senior Engineer'. Return their employee number, salary, and title. Question 3 1. SELECT e.emp_no, s.salary, t.title 2. FROM employees e 3. JOIN salaries s ON e.emp_no = s.emp_no 4. JOIN titles t ON e.emp_no = t.emp_no 5. WHERE s.salary > 80000 6. AND t.title = [[]] ; Construct a query that finds all employees who have a salary greater than 80000 and hold the title 'Senior Engineer'. Return their employee number, salary, and title. Question 3 1. SELECT e.emp_no, s.salary, t.title 2. FROM employees e 3. JOIN salaries s ON e.emp_no = s.emp_no 4. JOIN titles t ON e.emp_no = t.emp_no 5. WHERE s.salary > 80000 6. AND t.title = ‘Senior Engineer’ ; Construct a query that finds all employees who have a salary greater than 80000 and hold the title 'Senior Engineer'. Return their employee number, salary, and title. Question 4 Find all employees who are currently managers of their departments. Return their employee number, first name, last name, and department name. We consider here the employee dataset: Question 4.a 1. SELECT e.emp_no, e.first_name, e.last_name, d.dept_name 2. FROM employees e 3. JOIN dept_manager dm ON e.emp_no = dm.emp_no 4. JOIN departments d ON dm.dept_no = d.dept_no 5. WHERE dm.to_date = '9999-01-01'; Find all employees who are currently managers of their departments. Return their employee number, first name, last name, and department name. Question 4.a 1. SELECT e.emp_no, e.first_name, e.last_name, d.dept_name 2. FROM employees e 3. JOIN dept_manager dm ON e.emp_no = dm.emp_no 4. JOIN departments d ON dm.dept_no = d.dept_no 5. WHERE dm.to_date = '9999-01-01'; Find all employees who are currently managers of their departments. Return their employee number, first name, last name, and department name. ‘9999-01-01’ is used to denote an undetermined date. Question 4.b 1. SELECT e.emp_no, e.first_name, e.last_name, d.dept_name 2. FROM employees e 3. JOIN dept_manager dm ON e.emp_no = dm.emp_no 4. JOIN departments d ON dm.dept_no = d.dept_no 5. WHERE dm.to_date IS NULL; Find all employees who are currently managers of their departments. Return their employee number, first name, last name, and department name. Question 4.b 1. SELECT e.emp_no, e.first_name, e.last_name, d.dept_name 2. FROM employees e 3. JOIN dept_manager dm ON e.emp_no = dm.emp_no 4. JOIN departments d ON dm.dept_no = d.dept_no 5. WHERE dm.to_date IS NULL; Find all employees who are currently managers of their departments. Return their employee number, first name, last name, and department name. NULL could be used to determine an undetermined date, but not in our case! Question 4.c 1. SELECT e.emp_no, e.first_name, e.last_name, d.dept_name 2. FROM employees e 3. JOIN dept_manager dm ON e.emp_no = dm.emp_no 4. JOIN departments d ON dm.dept_no = d.dept_no 5. WHERE dm.from_date <= CURRENT_DATE 6. AND dm.to_date >= CURRENT_DATE; Find all employees who are currently managers of their departments. Return their employee number, first name, last name, and department name. Question 4.c 1. SELECT e.emp_no, e.first_name, e.last_name, d.dept_name 2. FROM employees e 3. JOIN dept_manager dm ON e.emp_no = dm.emp_no 4. JOIN departments d ON dm.dept_no = d.dept_no 5. WHERE dm.from_date <= CURRENT_DATE 6. AND dm.to_date >= CURRENT_DATE; Find all employees who are currently managers of their departments. Return their employee number, first name, last name, and department name. Question 4.d 1. SELECT e.emp_no, e.first_name, e.last_name, d.dept_name 2. FROM employees e 3. JOIN dept_manager dm ON e.emp_no = dm.emp_no 4. JOIN departments d ON dm.dept_no = d.dept_no 5. WHERE de.to_date > CURRENT_DATE; Find all employees who are currently managers of their departments. Return their employee number, first name, last name, and department name. Question 4.d 1. SELECT e.emp_no, e.first_name, e.last_name, d.dept_name 2. FROM employees e 3. JOIN dept_manager dm ON e.emp_no = dm.emp_no 4. JOIN departments d ON dm.dept_no = d.dept_no 5. WHERE de.to_date > CURRENT_DATE; Find all employees who are currently managers of their departments. Return their employee number, first name, last name, and department name. Doesn’t check the correct table (dept_manager) Question 5 1. WITH latest_titles AS ( 2. SELECT t.emp_no, t.title, t.from_date 3. FROM title t 4. WHERE t.from_data = ( 5. SELECT MAX(t2.from_date) 6. FROM title t2 7. WHERE t2.emp_no = t.emp_no 8. ) 9. ), 10. current_managers AS ( 11. SELECT dm.emp_no, d.dept_name 12. FROM dept_manager dm 13. JOIN departments d USING(dept_no) 14. WHERE dm.to_date = '9999-01-01' 15. ) 16. SELECT DISTINCT e.first_name, e.last_name, lt.title, cm.dept_name 17. FROM employees e 18. JOIN latest_titles lt USING(emp_no) 19. LEFT JOIN current_managers cm ON e.emp_no = cm.emp_no 20. WHERE lt.title = 'Senior Engineer'; The query lists the names of employees who currently hold the title of Senior Engineer. Employees who are Senior Engineers but not managers are still included in the result. The query only returns employees who are both Senior Engineers and currently managers. The query checks the most recent title for each employee. The query returns the department name only for employees who are current managers. If an employee has the title of Senior Engineer but is not a manager, their dept_name will be NULL in the result. The query would exclude any employee who was a Senior Engineer but currently has a different title. Question 5 1. WITH latest_titles AS ( 2. SELECT t.emp_no, t.title, t.from_date 3. FROM title t 4. WHERE t.from_data = ( 5. SELECT MAX(t2.from_date) 6. FROM title t2 7. WHERE t2.emp_no = t.emp_no 8. ) 9. ), 10. current_managers AS ( 11. SELECT dm.emp_no, d.dept_name 12. FROM dept_manager dm 13. JOIN departments d USING(dept_no) 14. WHERE dm.to_date = '9999-01-01' 15. ) 16. SELECT DISTINCT e.first_name, e.last_name, lt.title, cm.dept_name 17. FROM employees e 18. JOIN latest_titles lt USING(emp_no) 19. LEFT JOIN current_managers cm ON e.emp_no = cm.emp_no 20. WHERE lt.title = 'Senior Engineer'; The query lists the names of employees who currently hold the title of Senior Engineer. Employees who are Senior Engineers but not managers are still included in the result. The query only returns employees who are both Senior Engineers and currently managers. The query checks the most recent title for each employee. The query returns the department name only for employees who are current managers. If an employee has the title of Senior Engineer but is not a manager, their dept_name will be NULL in the result. The query would exclude any employee who was a Senior Engineer but currently has a different title. Question 5 1. WITH latest_titles AS ( 2. SELECT t.emp_no, t.title, t.from_date 3. FROM title t 4. WHERE t.from_data = ( 5. SELECT MAX(t2.from_date) 6. FROM title t2 7. WHERE t2.emp_no = t.emp_no 8. ) 9. ), 10. current_managers AS ( 11. SELECT dm.emp_no, d.dept_name 12. FROM dept_manager dm 13. JOIN departments d USING(dept_no) 14. WHERE dm.to_date = '9999-01-01' 15. ) 16. SELECT DISTINCT e.first_name, e.last_name, lt.title, cm.dept_name 17. FROM employees e 18. JOIN latest_titles lt USING(emp_no) 19. LEFT JOIN current_managers cm ON e.emp_no = cm.emp_no 20. WHERE lt.title = 'Senior Engineer'; The query lists the names of employees who currently hold the title of Senior Engineer. Employees who are Senior Engineers but not managers are still included in the result. The query only returns employees who are both Senior Engineers and currently managers. The query checks the most recent title for each employee. The query returns the department name only for employees who are current managers. If an employee has the title of Senior Engineer but is not a manager, their dept_name will be NULL in the result. The query would exclude any employee who was a Senior Engineer but currently has a different title. Question 5 1. WITH latest_titles AS ( 2. SELECT t.emp_no, t.title, t.from_date 3. FROM title t 4. WHERE t.from_data = ( 5. SELECT MAX(t2.from_date) 6. FROM title t2 7. WHERE t2.emp_no = t.emp_no 8. ) 9. ), 10. current_managers AS ( 11. SELECT dm.emp_no, d.dept_name 12. FROM dept_manager dm 13. JOIN departments d USING(dept_no) 14. WHERE dm.to_date = '9999-01-01' 15. ) 16. SELECT DISTINCT e.first_name, e.last_name, lt.title, cm.dept_name 17. FROM employees e 18. JOIN latest_titles lt USING(emp_no) 19. LEFT JOIN current_managers cm ON e.emp_no = cm.emp_no 20. WHERE lt.title = 'Senior Engineer'; The query lists the names of employees who currently hold the title of Senior Engineer. Employees who are Senior Engineers but not managers are still included in the result. The query only returns employees who are both Senior Engineers and currently managers. The query checks the most recent title for each employee. The query returns the department name only for employees who are current managers. If an employee has the title of Senior Engineer but is not a manager, their dept_name will be NULL in the result. The query would exclude any employee who was a Senior Engineer but currently has a different title. Question 5 1. WITH latest_titles AS ( 2. SELECT t.emp_no, t.title, t.from_date 3. FROM title t 4. WHERE t.from_data = ( 5. SELECT MAX(t2.from_date) 6. FROM title t2 7. WHERE t2.emp_no = t.emp_no 8. ) 9. ), 10. current_managers AS ( 11. SELECT dm.emp_no, d.dept_name 12. FROM dept_manager dm 13. JOIN departments d USING(dept_no) 14. WHERE dm.to_date = '9999-01-01' 15. ) 16. SELECT DISTINCT e.first_name, e.last_name, lt.title, cm.dept_name 17. FROM employees e 18. JOIN latest_titles lt USING(emp_no) 19. LEFT JOIN current_managers cm ON e.emp_no = cm.emp_no 20. WHERE lt.title = 'Senior Engineer'; The query lists the names of employees who currently hold the title of Senior Engineer. Employees who are Senior Engineers but not managers are still included in the result. The query only returns employees who are both Senior Engineers and currently managers. The query checks the most recent title for each employee. The query returns the department name only for employees who are current managers. If an employee has the title of Senior Engineer but is not a manager, their dept_name will be NULL in the result. The query would exclude any employee who was a Senior Engineer but currently has a different title. Question 5 1. WITH latest_titles AS ( 2. SELECT t.emp_no, t.title, t.from_date 3. FROM title t 4. WHERE t.from_data = ( 5. SELECT MAX(t2.from_date) 6. FROM title t2 7. WHERE t2.emp_no = t.emp_no 8. ) 9. ), 10. current_managers AS ( 11. SELECT dm.emp_no, d.dept_name 12. FROM dept_manager dm 13. JOIN departments d USING(dept_no) 14. WHERE dm.to_date = '9999-01-01' 15. ) 16. SELECT DISTINCT e.first_name, e.last_name, lt.title, cm.dept_name 17. FROM employees e 18. JOIN latest_titles lt USING(emp_no) 19. LEFT JOIN current_managers cm ON e.emp_no = cm.emp_no 20. WHERE lt.title = 'Senior Engineer'; The query lists the names of employees who currently hold the title of Senior Engineer. Employees who are Senior Engineers but not managers are still included in the result. The query only returns employees who are both Senior Engineers and currently managers. The query checks the most recent title for each employee. The query returns the department name only for employees who are current managers. If an employee has the title of Senior Engineer but is not a manager, their dept_name will be NULL in the result. The query would exclude any employee who was a Senior Engineer but currently has a different title. Question 5 1. WITH latest_titles AS ( 2. SELECT t.emp_no, t.title, t.from_date 3. FROM title t 4. WHERE t.from_data = ( 5. SELECT MAX(t2.from_date) 6. FROM title t2 7. WHERE t2.emp_no = t.emp_no 8. ) 9. ), 10. current_managers AS ( 11. SELECT dm.emp_no, d.dept_name 12. FROM dept_manager dm 13. JOIN departments d USING(dept_no) 14. WHERE dm.to_date = '9999-01-01' 15. ) 16. SELECT DISTINCT e.first_name, e.last_name, lt.title, cm.dept_name 17. FROM employees e 18. JOIN latest_titles lt USING(emp_no) 19. LEFT JOIN current_managers cm ON e.emp_no = cm.emp_no 20. WHERE lt.title = 'Senior Engineer'; The query lists the names of employees who currently hold the title of Senior Engineer. Employees who are Senior Engineers but not managers are still included in the result. The query only returns employees who are both Senior Engineers and currently managers. The query checks the most recent title for each employee. The query returns the department name only for employees who are current managers. If an employee has the title of Senior Engineer but is not a manager, their dept_name will be NULL in the result. The query would exclude any employee who was a Senior Engineer but currently has a different title. Question 5 1. WITH latest_titles AS ( 2. SELECT t.emp_no, t.title, t.from_date 3. FROM title t 4. WHERE t.from_data = ( 5. SELECT MAX(t2.from_date) 6. FROM title t2 7. WHERE t2.emp_no = t.emp_no 8. ) 9. ), 10. current_managers AS ( 11. SELECT dm.emp_no, d.dept_name 12. FROM dept_manager dm 13. JOIN departments d USING(dept_no) 14. WHERE dm.to_date = '9999-01-01' 15. ) 16. SELECT DISTINCT e.first_name, e.last_name, lt.title, cm.dept_name 17. FROM employees e 18. JOIN latest_titles lt USING(emp_no) 19. LEFT JOIN current_managers cm ON e.emp_no = cm.emp_no 20. WHERE lt.title = 'Senior Engineer'; The query lists the names of employees who currently hold the title of Senior Engineer. Employees who are Senior Engineers but not managers are still included in the result. The query only returns employees who are both Senior Engineers and currently managers. The query checks the most recent title for each employee. The query returns the department name only for employees who are current managers. If an employee has the title of Senior Engineer but is not a manager, their dept_name will be NULL in the result. The query would exclude any employee who was a Senior Engineer but currently has a different title. Information We consider for the following questions the zvv dataset: Question 6 Which queries are equivalent? 1. SELECT COUNT(*) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; 1. SELECT COUNT(*) 2. FROM stop_times 3. WHERE departure_time > '12:00:00' 4. AND arrival_time IS NOT NULL; 1. SELECT COUNT(departure_time) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; 1. SELECT COUNT(1) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; Question 6 Which queries are equivalent? 1. SELECT COUNT(*) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; → Considers all rows 1. SELECT COUNT(*) 2. FROM stop_times 3. WHERE departure_time > '12:00:00' 4. AND arrival_time IS NOT NULL; 1. SELECT COUNT(departure_time) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; 1. SELECT COUNT(1) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; Question 6 Which queries are equivalent? 1. SELECT COUNT(*) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; → Considers all rows 1. SELECT COUNT(*) 2. FROM stop_times 3. WHERE departure_time > '12:00:00' 4. AND arrival_time IS NOT NULL; 1. SELECT COUNT(departure_time) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; → Considers all rows 1. SELECT COUNT(1) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; Question 6 Which queries are equivalent? 1. SELECT COUNT(*) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; → Considers all rows 1. SELECT COUNT(*) 2. FROM stop_times 3. WHERE departure_time > '12:00:00' 4. AND arrival_time IS NOT NULL; → Only non-null arrival_time considered 1. SELECT COUNT(departure_time) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; → Considers all rows 1. SELECT COUNT(1) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; Question 6 Which queries are equivalent? 1. SELECT COUNT(*) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; → Considers all rows 1. SELECT COUNT(*) 2. FROM stop_times 3. WHERE departure_time > '12:00:00' 4. AND arrival_time IS NOT NULL; → Only non-null arrival_time considered 1. SELECT COUNT(departure_time) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; → Considers all rows 1. SELECT COUNT(1) 2. FROM stop_times 3. WHERE departure_time > '12:00:00'; → Considers all rows Question 7 Which queries are equivalent? 1. SELECT trip_id, COUNT(stop_id) 2. FROM stop_times 3. GROUP BY trip_id; 1. SELECT trip_id, COUNT(stop_sequence) 2. FROM stop_times 3. GROUP BY trip_id; 1. SELECT trip_id, COUNT(*) 2. FROM stop_times 3. GROUP BY trip_id; 1. SELECT trip_id, COUNT( DISTINCT stop_id) 2. FROM stop_times 3. GROUP BY trip_id; Question 7 Which queries are equivalent? 1. SELECT trip_id, COUNT(stop_id) 2. FROM stop_times 3. GROUP BY trip_id; → Doesn’t count stop_id when NULL 1. SELECT trip_id, COUNT(stop_sequence) 2. FROM stop_times 3. GROUP BY trip_id; 1. SELECT trip_id, COUNT(*) 2. FROM stop_times 3. GROUP BY trip_id; 1. SELECT trip_id, COUNT( DISTINCT stop_id) 2. FROM stop_times 3. GROUP BY trip_id; Question 7 Which queries are equivalent? 1. SELECT trip_id, COUNT(stop_id) 2. FROM stop_times 3. GROUP BY trip_id; → Doesn’t count stop_id when NULL 1. SELECT trip_id, COUNT(stop_sequence) 2. FROM stop_times 3. GROUP BY trip_id; 1. SELECT trip_id, COUNT(*) 2. FROM stop_times 3. GROUP BY trip_id; → Counts all rows 1. SELECT trip_id, COUNT( DISTINCT stop_id) 2. FROM stop_times 3. GROUP BY trip_id; Question 7 Which queries are equivalent? 1. SELECT trip_id, COUNT(stop_id) 2. FROM stop_times 3. GROUP BY trip_id; → Doesn’t count stop_id when NULL 1. SELECT trip_id, COUNT(stop_sequence) 2. FROM stop_times 3. GROUP BY trip_id; → Counts all rows 1. SELECT trip_id, COUNT(*) 2. FROM stop_times 3. GROUP BY trip_id; → Counts all rows 1. SELECT trip_id, COUNT( DISTINCT stop_id) 2. FROM stop_times 3. GROUP BY trip_id; Question 7 Which queries are equivalent? 1. SELECT trip_id, COUNT(stop_id) 2. FROM stop_times 3. GROUP BY trip_id; → Doesn’t count stop_id when NULL 1. SELECT trip_id, COUNT(stop_sequence) 2. FROM stop_times 3. GROUP BY trip_id; → Counts all rows 1. SELECT trip_id, COUNT(*) 2. FROM stop_times 3. GROUP BY trip_id; → Counts all rows 1. SELECT trip_id, COUNT( DISTINCT stop_id) 2. FROM stop_times 3. GROUP BY trip_id; → Doesn’t count stop_id duplicates Question 8 Which queries are equivalent? 1. SELECT stop_name 2. FROM stops 3. WHERE stop_id IN 4. (SELECT stop_id FROM stop_times WHERE departure_time < '06:00:00'); 1. SELECT DISTINCT stop_name 2. FROM stops 3. JOIN stop_times USING(stop_id) 4. WHERE departure_time < '06:00:00'; 1. SELECT stop_name 2. FROM stops 3. JOIN stop_times ON stops.stop_id = stop_times.stop_id 4. WHERE departure_time < '06:00:00' 5. GROUP BY stop_name; 1. SELECT DISTINCT stop_name 2. FROM stops s 3. WHERE EXISTS 4. (SELECT 1 FROM stop_times st WHERE st.stop_id = s.stop_id AND departure_time < '06:00:00'); 1. SELECT s.stop_name 2. FROM stops s 3. JOIN stop_times st USING(stop_id) 4. WHERE departure_time < '06:00:00' 5. GROUP BY s.stop_name; Question 8 Which queries are equivalent? 1. SELECT stop_name 2. FROM stops 3. WHERE stop_id IN 4. (SELECT stop_id FROM stop_times WHERE departure_time < '06:00:00'); → IN operator keeps duplicates 1. SELECT DISTINCT stop_name 2. FROM stops 3. JOIN stop_times USING(stop_id) 4. WHERE departure_time < '06:00:00'; 1. SELECT stop_name 2. FROM stops 3. JOIN stop_times ON stops.stop_id = stop_times.stop_id 4. WHERE departure_time < '06:00:00' 5. GROUP BY stop_name; 1. SELECT DISTINCT stop_name 2. FROM stops s 3. WHERE EXISTS 4. (SELECT 1 FROM stop_times st WHERE st.stop_id = s.stop_id AND departure_time < '06:00:00'); 1. SELECT s.stop_name 2. FROM stops s 3. JOIN stop_times st USING(stop_id) 4. WHERE departure_time < '06:00:00' 5. GROUP BY s.stop_name; Question 8 Which queries are equivalent? 1. SELECT stop_name 2. FROM stops 3. WHERE stop_id IN 4. (SELECT stop_id FROM stop_times WHERE departure_time < '06:00:00'); → IN operator keeps duplicates 1. SELECT DISTINCT stop_name 2. FROM stops 3. JOIN stop_times USING(stop_id) 4. WHERE departure_time < '06:00:00'; → DISTINCT operator eliminates duplicates 1. SELECT stop_name 2. FROM stops 3. JOIN stop_times ON stops.stop_id = stop_times.stop_id 4. WHERE departure_time < '06:00:00' 5. GROUP BY stop_name; 1. SELECT DISTINCT stop_name 2. FROM stops s 3. WHERE EXISTS 4. (SELECT 1 FROM stop_times st WHERE st.stop_id = s.stop_id AND departure_time < '06:00:00'); 1. SELECT s.stop_name 2. FROM stops s 3. JOIN stop_times st USING(stop_id) 4. WHERE departure_time < '06:00:00' 5. GROUP BY s.stop_name; Question 8 Which queries are equivalent? 1. SELECT stop_name 2. FROM stops 3. WHERE stop_id IN 4. (SELECT stop_id FROM stop_times WHERE departure_time < '06:00:00'); → IN operator keeps duplicates 1. SELECT DISTINCT stop_name 2. FROM stops 3. JOIN stop_times USING(stop_id) 4. WHERE departure_time < '06:00:00'; → DISTINCT operator eliminates duplicates 1. SELECT stop_name 2. FROM stops 3. JOIN stop_times ON stops.stop_id = stop_times.stop_id 4. WHERE departure_time < '06:00:00' 5. GROUP BY stop_name; → GROUP BY without aggregation eliminates duplicates 1. SELECT DISTINCT stop_name 2. FROM stops s 3. WHERE EXISTS 4. (SELECT 1 FROM stop_times st WHERE st.stop_id = s.stop_id AND departure_time < '06:00:00'); 1. SELECT s.stop_name 2. FROM stops s 3. JOIN stop_times st USING(stop_id) 4. WHERE departure_time < '06:00:00' 5. GROUP BY s.stop_name; Question 8 Which queries are equivalent? 1. SELECT stop_name 2. FROM stops 3. WHERE stop_id IN 4. (SELECT stop_id FROM stop_times WHERE departure_time < '06:00:00'); → IN operator keeps duplicates 1. SELECT DISTINCT stop_name 2. FROM stops 3. JOIN stop_times USING(stop_id) 4. WHERE departure_time < '06:00:00'; → DISTINCT operator eliminates duplicates 1. SELECT stop_name 2. FROM stops 3. JOIN stop_times ON stops.stop_id = stop_times.stop_id 4. WHERE departure_time < '06:00:00' 5. GROUP BY stop_name; → GROUP BY without aggregation eliminates duplicates 1. SELECT DISTINCT stop_name 2. FROM stops s 3. WHERE EXISTS 4. (SELECT 1 FROM stop_times st WHERE st.stop_id = s.stop_id AND departure_time < '06:00:00'); → EXISTS doesn’t eliminate duplicates, but DISTINCT does 1. SELECT s.stop_name 2. FROM stops s 3. JOIN stop_times st USING(stop_id) 4. WHERE departure_time < '06:00:00' 5. GROUP BY s.stop_name; Question 8 Which queries are equivalent? 1. SELECT stop_name 2. FROM stops 3. WHERE stop_id IN 4. (SELECT stop_id FROM stop_times WHERE departure_time < '06:00:00'); → IN operator keeps duplicates 1. SELECT DISTINCT stop_name 2. FROM stops 3. JOIN stop_times USING(stop_id) 4. WHERE departure_time < '06:00:00'; → DISTINCT operator eliminates duplicates 1. SELECT stop_name 2. FROM stops 3. JOIN stop_times ON stops.stop_id = stop_times.stop_id 4. WHERE departure_time < '06:00:00' 5. GROUP BY stop_name; → GROUP BY without aggregation eliminates duplicates 1. SELECT DISTINCT stop_name 2. FROM stops s 3. WHERE EXISTS 4. (SELECT 1 FROM stop_times st WHERE st.stop_id = s.stop_id AND departure_time < '06:00:00'); → EXISTS doesn’t eliminate duplicates, but DISTINCT does 1. SELECT s.stop_name 2. FROM stops s 3. JOIN stop_times st USING(stop_id) 4. WHERE departure_time < '06:00:00' 5. GROUP BY s.stop_name; → Same as #3 but with USING Question 9 Create a view (active_stops) that contains the stops currently in use. A stop is considered active if it appears in the stop_times table. We consider here the zvv dataset: Question 9 1. [[]] active_stops [[]] ( 2. SELECT DISTINCT stop_id, stop_name 3. FROM stops 4. WHERE stop_id IN (SELECT DISTINCT stop_id FROM stop_times) 5. ); 6. SELECT [[]](stop_id) 7. FROM [[]] ; Create a view (active_stops) that contains the stops currently in use. A stop is considered active if it appears in the stop_times table. Question 9 1. CREATE VIEW active_stops [[]] ( 2. SELECT DISTINCT stop_id, stop_name 3. FROM stops 4. WHERE stop_id IN (SELECT DISTINCT stop_id FROM stop_times) 5. ); 6. SELECT [[]](stop_id) 7. FROM [[]] ; Create a view (active_stops) that contains the stops currently in use. A stop is considered active if it appears in the stop_times table. Question 9 1. CREATE VIEW active_stops AS ( 2. SELECT DISTINCT stop_id, stop_name 3. FROM stops 4. WHERE stop_id IN (SELECT DISTINCT stop_id FROM stop_times) 5. ); 6. SELECT [[]](stop_id) 7. FROM [[]] ; Create a view (active_stops) that contains the stops currently in use. A stop is considered active if it appears in the stop_times table. Question 9 1. CREATE VIEW active_stops AS ( 2. SELECT DISTINCT stop_id, stop_name 3. FROM stops 4. WHERE stop_id IN (SELECT DISTINCT stop_id FROM stop_times) 5. ); 6. SELECT COUNT (stop_id) 7. FROM [[]] ; Create a view (active_stops) that contains the stops currently in use. A stop is considered active if it appears in the stop_times table. Question 9 1. CREATE VIEW active_stops AS ( 2. SELECT DISTINCT stop_id, stop_name 3. FROM stops 4. WHERE stop_id IN (SELECT DISTINCT stop_id FROM stop_times) 5. ); 6. SELECT COUNT (stop_id) 7. FROM active_stops; Create a view (active_stops) that contains the stops currently in use. A stop is considered active if it appears in the stop_times table. Question 10 Use the view from the previous task (most_frequent_stops) to determine the stops (by name) that are in the top 10% of most frequently visited stops. We consider here the zvv dataset: Question 10 1. [[]] ranked_frequent_stops AS ( 2. SELECT *, 3. [[]] OVER [[]] AS rank 4. FROM most_frequent_stops 5. ) 6. 7. SELECT stop_name, trip_count 8. FROM ranked_frequent_stops 9. WHERE rank [[]] 0.9 [[]] 1; Use the view from the previous task (most_frequent_stops) to determine the stops (by name) that are in the top 10% of most frequently visited stops. Question 10 1. WITH ranked_frequent_stops AS ( 2. SELECT *, 3. [[]] OVER [[]] AS rank 4. FROM most_frequent_stops 5. ) 6. 7. SELECT stop_name, trip_count 8. FROM ranked_frequent_stops 9. WHERE rank [[]] 0.9 [[]] 1; Use the view from the previous task (most_frequent_stops) to determine the stops (by name) that are in the top 10% of most frequently visited stops. Question 10 1. WITH ranked_frequent_stops AS ( 2. SELECT *, 3. PERCENT_RANK() OVER [[]] AS rank 4. FROM most_frequent_stops 5. ) 6. 7. SELECT stop_name, trip_count 8. FROM ranked_frequent_stops 9. WHERE rank [[]] 0.9 [[]] 1; Use the view from the previous task (most_frequent_stops) to determine the stops (by name) that are in the top 10% of most frequently visited stops. Question 10 1. WITH ranked_frequent_stops AS ( 2. SELECT *, 3. PERCENT_RANK() OVER (ORDER BY trip_count DESC) AS rank 4. FROM most_frequent_stops 5. ) 6. 7. SELECT stop_name, trip_count 8. FROM ranked_frequent_stops 9. WHERE rank [[]] 0.9 [[]] 1; Use the view from the previous task (most_frequent_stops) to determine the stops (by name) that are in the top 10% of most frequently visited stops. Question 10 1. WITH ranked_frequent_stops AS ( 2. SELECT *, 3. PERCENT_RANK() OVER (ORDER BY trip_count DESC) AS rank 4. FROM most_frequent_stops 5. ) 6. 7. SELECT stop_name, trip_count 8. FROM ranked_frequent_stops 9. WHERE rank BETWEEN 0.9 [[]] 1; Use the view from the previous task (most_frequent_stops) to determine the stops (by name) that are in the top 10% of most frequently visited stops. Question 10 1. WITH ranked_frequent_stops AS ( 2. SELECT *, 3. PERCENT_RANK() OVER (ORDER BY trip_count DESC) AS rank 4. FROM most_frequent_stops 5. ) 6. 7. SELECT stop_name, trip_count 8. FROM ranked_frequent_stops 9. WHERE rank BETWEEN 0.9 AND 1; Use the view from the previous task (most_frequent_stops) to determine the stops (by name) that are in the top 10% of most frequently visited stops. Question 11 Create a view (trip_delays) that calculates the delay for each stop. Then, use this view to find the 5 trips with the longest total delay. We consider here the zvv dataset: Question 11 1. -- Step 1: 2. [[]] trip_delays [[]] ( 3. SELECT trip_id, 4. SUM(TIMESTAMPDIFF( [[]], arrival_time, departure_time)) AS total_delay 5. FROM stop_times 6. GROUP BY [[]] 7. ); Create a view (trip_delays) that calculates the delay for each stop. Then, use this view to find the 5 trips with the longest total delay. Question 11 1. -- Step 1: 2. CREATE VIEW trip_delays [[]] ( 3. SELECT trip_id, 4. SUM(TIMESTAMPDIFF( [[]], arrival_time, departure_time)) AS total_delay 5. FROM stop_times 6. GROUP BY [[]] 7. ); Create a view (trip_delays) that calculates the delay for each stop. Then, use this view to find the 5 trips with the longest total delay. Question 11 1. -- Step 1: 2. CREATE VIEW trip_delays AS ( 3. SELECT trip_id, 4. SUM(TIMESTAMPDIFF( [[]], arrival_time, departure_time)) AS total_delay 5. FROM stop_times 6. GROUP BY [[]] 7. ); Create a view (trip_delays) that calculates the delay for each stop. Then, use this view to find the 5 trips with the longest total delay. Question 11 1. -- Step 1: 2. CREATE VIEW trip_delays AS ( 3. SELECT trip_id, 4. SUM(TIMESTAMPDIFF( MINUTE, arrival_time, departure_time)) AS total_delay 5. FROM stop_times 6. GROUP BY [[]] 7. ); Create a view (trip_delays) that calculates the delay for each stop. Then, use this view to find the 5 trips with the longest total delay. Question 11 1. -- Step 1: 2. CREATE VIEW trip_delays AS ( 3. SELECT trip_id, 4. SUM(TIMESTAMPDIFF( MINUTE, arrival_time, departure_time)) AS total_delay 5. FROM stop_times 6. GROUP BY trip_id 7. ); Create a view (trip_delays) that calculates the delay for each stop. Then, use this view to find the 5 trips with the longest total delay. Question 11 1. -- Step 2: 2. WITH ranked_delays AS ( 3. SELECT *, 4. [[]] OVER (ORDER BY total_delay DESC ) AS rank 5. FROM trip_delays 6. ) 7. SELECT trip_id, total_delay 8. FROM ranked_delays 9. WHERE rank [[]] 5; Create a view (trip_delays) that calculates the delay for each stop. Then, use this view to find the 5 trips with the longest total delay. Question 11 1. -- Step 2: 2. WITH ranked_delays AS ( 3. SELECT *, 4. RANK() OVER (ORDER BY total_delay DESC ) AS rank 5. FROM trip_delays 6. ) 7. SELECT trip_id, total_delay 8. FROM ranked_delays 9. WHERE rank [[]] 5; Create a view (trip_delays) that calculates the delay for each stop. Then, use this view to find the 5 trips with the longest total delay. Question 11 1. -- Step 2: 2. WITH ranked_delays AS ( 3. SELECT *, 4. RANK() OVER (ORDER BY total_delay DESC ) AS rank 5. FROM trip_delays 6. ) 7. SELECT trip_id, total_delay 8. FROM ranked_delays 9. WHERE rank <= 5; Create a view (trip_delays) that calculates the delay for each stop. Then, use this view to find the 5 trips with the longest total delay. Question 12 Select the views that are updatable. We consider here the zvv dataset: Question 12 Some rules for updatable views: - Must have exactly one entry: a table or another updatable view. - The view definition must not contain WITH, DISTINCT, GROUP BY, HAVING, LIMIT, or OFFSET clauses at the top level. - The view definition must not contain set operations (UNION, INTERSECT or EXCEPT) at the top level. - No column can be selected more than once. All columns must be a simple reference. Question 12.1 1. CREATE VIEW CurrentTramTrips AS 2. SELECT * FROM trips 3. WHERE trip_id IN (SELECT DSITINCT trip_id FROM stop_times); Question 12.1 1. CREATE VIEW CurrentTramTrips AS 2. SELECT * FROM trips 3. WHERE trip_id IN (SELECT DSITINCT trip_id FROM stop_times); Question 12.2 1. CREATE VIEW StopLocations AS 2. SELECT stop_id, stop_name, stop_lat, stop_lon 3. FROM stops; Question 12.2 1. CREATE VIEW StopLocations AS 2. SELECT stop_id, stop_name, stop_lat, stop_lon 3. FROM stops; Question 12.3 1. CREATE VIEW StopUsage AS 2. SELECT stop_id, COUNT(trip_id) AS trip_count 3. FROM stop_times 4. GROUP BY stop_id; Question 12.3 1. CREATE VIEW StopUsage AS 2. SELECT stop_id, COUNT(trip_id) AS trip_count 3. FROM stop_times 4. GROUP BY stop_id; Cannot use aggregation Question 12.4 1. CREATE VIEW TripsWithStopNames AS 2. SELECT st.trip_id, t.tram_number, s.stop_name, st.stop_sequence 3. FROM stop_times st 4. JOIN trips t ON st.trip_id=t.trip_id 5. JOIN stops s ON st.stop_id = s.stop_id Question 12.4 1. CREATE VIEW TripsWithStopNames AS 2. SELECT st.trip_id, t.tram_number, s.stop_name, st.stop_sequence 3. FROM stop_times st 4. JOIN trips t ON st.trip_id=t.trip_id 5. JOIN stops s ON st.stop_id = s.stop_id Cannot join multiple tables Question 12.5 1. CREATE VIEW StopsWithCoordinates AS 2. SELECT stop_id, stop_name, ROUND(stop_lat, 2) AS lat, 3. ROUND(stop_lon, 2) AS lon 4. FROM stops Question 12.5 1. CREATE VIEW StopsWithCoordinates AS 2. SELECT stop_id, stop_name, ROUND(stop_lat, 2) AS lat, 3. ROUND(stop_lon, 2) AS lon 4. FROM stops View is updatble even though ‘lat’ and ‘lon’ are not Question 12.6 1. CREATE VIEW StopSequence AS 2. SELECT stop_id, trip_id, stop_sequence, 3. ROW_NUMBER() OVER (PARTITION BY trip_id ORDER BY stop_sequence) AS row_num 4. FROM stop_times; Question 12.6 1. CREATE VIEW StopSequence AS 2. SELECT stop_id, trip_id, stop_sequence, 3. ROW_NUMBER() OVER (PARTITION BY trip_id ORDER BY stop_sequence) AS row_num 4. FROM stop_times; Cannot use ROW_NUMBER() or other window functions Question 13 Which of the following statements are true. We consider here the tpch dataset: Question 13 1. (SELECT o.orderid, o.customerid 2. FROM Orders o 3. JOIN Orderline ol ON o.orderid = ol.orderid 4. WHERE ol.supplierid = 10) 5. UNION 6. (SELECT o.orderid, o.customerid 7. FROM Orders o 8. JOIN Orderline ol ON o.orderid = ol.orderid 9. WHERE ol.supplierid = 20); 10. 11. (SELECT o.orderid, o.customerid 12. FROM Orders o 13. JOIN Orderline ol ON o.orderid = ol.orderid 14. WHERE ol.supplierid = 10) 15. INTERSECT 16. (SELECT o.orderid, o.customerid 17. FROM Orders o 18. JOIN Orderline ol ON o.orderid = ol.orderid 19. WHERE ol.supplierid = 20); Query 1 returns the list of orders that involve either supplier 10 or supplier 20, ensuring no duplicates. If an order contains items from both suppliers, Query 2 will return it once, while Query 1 may return it twice. Query 2 will return an order only if it has at least one item supplied by supplier 10 and another by supplier 20. Query 1 and Query 2 would return the exact same results if the database had only one supplier per order. If a customer places two orders: one from supplier 10 and one from supplier 20, Query 1 will return both orders, while Query 2 will return nothing. Query 2 could return fewer rows than Query 1 but never more. Question 13 1. (SELECT o.orderid, o.customerid 2. FROM Orders o 3. JOIN Orderline ol ON o.orderid = ol.orderid 4. WHERE ol.supplierid = 10) 5. UNION 6. (SELECT o.orderid, o.customerid 7. FROM Orders o 8. JOIN Orderline ol ON o.orderid = ol.orderid 9. WHERE ol.supplierid = 20); 10. 11. (SELECT o.orderid, o.customerid 12. FROM Orders o 13. JOIN Orderline ol ON o.orderid = ol.orderid 14. WHERE ol.supplierid = 10) 15. INTERSECT 16. (SELECT o.orderid, o.customerid 17. FROM Orders o 18. JOIN Orderline ol ON o.orderid = ol.orderid 19. WHERE ol.supplierid = 20); Query 1 returns the list of orders that involve either supplier 10 or supplier 20, ensuring no duplicates. If an order contains items from both suppliers, Query 2 will return it once, while Query 1 may return it twice. Query 2 will return an order only if it has at least one item supplied by supplier 10 and another by supplier 20. Query 1 and Query 2 would return the exact same results if the database had only one supplier per order. If a customer places two orders: one from supplier 10 and one from supplier 20, Query 1 will return both orders, while Query 2 will return nothing. Query 2 could return fewer rows than Query 1 but never more. Question 13 1. (SELECT o.orderid, o.customerid 2. FROM Orders o 3. JOIN Orderline ol ON o.orderid = ol.orderid 4. WHERE ol.supplierid = 10) 5. UNION 6. (SELECT o.orderid, o.customerid 7. FROM Orders o 8. JOIN Orderline ol ON o.orderid = ol.orderid 9. WHERE ol.supplierid = 20); 10. 11. (SELECT o.orderid, o.customerid 12. FROM Orders o 13. JOIN Orderline ol ON o.orderid = ol.orderid 14. WHERE ol.supplierid = 10) 15. INTERSECT 16. (SELECT o.orderid, o.customerid 17. FROM Orders o 18. JOIN Orderline ol ON o.orderid = ol.orderid 19. WHERE ol.supplierid = 20); Query 1 returns the list of orders that involve either supplier 10 or supplier 20, ensuring no duplicates. If an order contains items from both suppliers, Query 2 will return it once, while Query 1 may return it twice. Query 2 will return an order only if it has at least one item supplied by supplier 10 and another by supplier 20. Query 1 and Query 2 would return the exact same results if the database had only one supplier per order. If a customer places two orders: one from supplier 10 and one from supplier 20, Query 1 will return both orders, while Query 2 will return nothing. Query 2 could return fewer rows than Query 1 but never more. Question 13 1. (SELECT o.orderid, o.customerid 2. FROM Orders o 3. JOIN Orderline ol ON o.orderid = ol.orderid 4. WHERE ol.supplierid = 10) 5. UNION 6. (SELECT o.orderid, o.customerid 7. FROM Orders o 8. JOIN Orderline ol ON o.orderid = ol.orderid 9. WHERE ol.supplierid = 20); 10. 11. (SELECT o.orderid, o.customerid 12. FROM Orders o 13. JOIN Orderline ol ON o.orderid = ol.orderid 14. WHERE ol.supplierid = 10) 15. INTERSECT 16. (SELECT o.orderid, o.customerid 17. FROM Orders o 18. JOIN Orderline ol ON o.orderid = ol.orderid 19. WHERE ol.supplierid = 20); Query 1 returns the list of orders that involve either supplier 10 or supplier 20, ensuring no duplicates. If an order contains items from both suppliers, Query 2 will return it once, while Query 1 may return it twice. Query 2 will return an order only if it has at least one item supplied by supplier 10 and another by supplier 20. Query 1 and Query 2 would return the exact same results if the database had only one supplier per order. If a customer places two orders: one from supplier 10 and one from supplier 20, Query 1 will return both orders, while Query 2 will return nothing. Query 2 could return fewer rows than Query 1 but never more. Question 13 1. (SELECT o.orderid, o.customerid 2. FROM Orders o 3. JOIN Orderline ol ON o.orderid = ol.orderid 4. WHERE ol.supplierid = 10) 5. UNION 6. (SELECT o.orderid, o.customerid 7. FROM Orders o 8. JOIN Orderline ol ON o.orderid = ol.orderid 9. WHERE ol.supplierid = 20); 10. 11. (SELECT o.orderid, o.customerid 12. FROM Orders o 13. JOIN Orderline ol ON o.orderid = ol.orderid 14. WHERE ol.supplierid = 10) 15. INTERSECT 16. (SELECT o.orderid, o.customerid 17. FROM Orders o 18. JOIN Orderline ol ON o.orderid = ol.orderid 19. WHERE ol.supplierid = 20); Query 1 returns the list of orders that involve either supplier 10 or supplier 20, ensuring no duplicates. If an order contains items from both suppliers, Query 2 will return it once, while Query 1 may return it twice. Query 2 will return an order only if it has at least one item supplied by supplier 10 and another by supplier 20. Query 1 and Query 2 would return the exact same results if the database had only one supplier per order. If a customer places two orders: one from supplier 10 and one from supplier 20, Query 1 will return both orders, while Query 2 will return nothing. Query 2 could return fewer rows than Query 1 but never more. Question 13 1. (SELECT o.orderid, o.customerid 2. FROM Orders o 3. JOIN Orderline ol ON o.orderid = ol.orderid 4. WHERE ol.supplierid = 10) 5. UNION 6. (SELECT o.orderid, o.customerid 7. FROM Orders o 8. JOIN Orderline ol ON o.orderid = ol.orderid 9. WHERE ol.supplierid = 20); 10. 11. (SELECT o.orderid, o.customerid 12. FROM Orders o 13. JOIN Orderline ol ON o.orderid = ol.orderid 14. WHERE ol.supplierid = 10) 15. INTERSECT 16. (SELECT o.orderid, o.customerid 17. FROM Orders o 18. JOIN Orderline ol ON o.orderid = ol.orderid 19. WHERE ol.supplierid = 20); Query 1 returns the list of orders that involve either supplier 10 or supplier 20, ensuring no duplicates. If an order contains items from both suppliers, Query 2 will return it once, while Query 1 may return it twice. Query 2 will return an order only if it has at least one item supplied by supplier 10 and another by supplier 20. Query 1 and Query 2 would return the exact same results if the database had only one supplier per order. If a customer places two orders: one from supplier 10 and one from supplier 20, Query 1 will return both orders, while Query 2 will return nothing. Query 2 could return fewer rows than Query 1 but never more. Question 13 1. (SELECT o.orderid, o.customerid 2. FROM Orders o 3. JOIN Orderline ol ON o.orderid = ol.orderid 4. WHERE ol.supplierid = 10) 5. UNION 6. (SELECT o.orderid, o.customerid 7. FROM Orders o 8. JOIN Orderline ol ON o.orderid = ol.orderid 9. WHERE ol.supplierid = 20); 10. 11. (SELECT o.orderid, o.customerid 12. FROM Orders o 13. JOIN Orderline ol ON o.orderid = ol.orderid 14. WHERE ol.supplierid = 10) 15. INTERSECT 16. (SELECT o.orderid, o.customerid 17. FROM Orders o 18. JOIN Orderline ol ON o.orderid = ol.orderid 19. WHERE ol.supplierid = 20); Query 1 returns the list of orders that involve either supplier 10 or supplier 20, ensuring no duplicates. If an order contains items from both suppliers, Query 2 will return it once, while Query 1 may return it twice. Query 2 will return an order only if it has at least one item supplied by supplier 10 and another by supplier 20. Query 1 and Query 2 would return the exact same results if the database had only one supplier per order. If a customer places two orders: one from supplier 10 and one from supplier 20, Query 1 will return both orders, while Query 2 will return nothing. Query 2 could return fewer rows than Query 1 but never more. Question 14 Analyze the query and rewrite it. We consider here the tpch dataset: Question 14.1 1. SELECT c.customerid, c.customername 2. FROM Customer c 3. WHERE EXISTS ( 4. SELECT 1 FROM Orders o 5. WHERE o.customerid = c.customerid 6. ); The query returns at least one customer that have placed at least one order. The query returns all customers that have placed at least one order. The query returns the customer with the least orders. The query returns all customers that have placed more than one order. Question 14.1 1. SELECT c.customerid, c.customername 2. FROM Customer c 3. WHERE EXISTS ( 4. SELECT 1 FROM Orders o 5. WHERE o.customerid = c.customerid 6. ); The query returns at least one customer that have placed at least one order. The query returns all customers that have placed at least one order. The query returns the customer with the least orders. The query returns all customers that have placed more than one order. Question 14.1 1. SELECT DISTINCT c.customerid, c.customername 2. FROM Customer c 3. JOIN [[]] 4. ON [[]] The query returns all customers that have placed at least one order. Question 14.1 1. SELECT DISTINCT c.customerid, c.customername 2. FROM Customer c 3. JOIN Orders o 4. ON [[]] The query returns all customers that have placed at least one order. Question 14.1 1. SELECT DISTINCT c.customerid, c.customername 2. FROM Customer c 3. JOIN Orders o 4. ON o.customerid=c.customerid The query returns all customers that have placed at least one order. Question 14.2 1. SELECT s.supplierid, s.suppliername 2. FROM Supplier s 3. JOIN Supplypart sp ON s.supplierid = sp.supplierid 4. GROUP BY s.supplierid, s.suppliername 5. HAVING COUNT(sp.partid) > ( 6. SELECT AVG(supply_count) 7. FROM (SELECT COUNT(partid) AS supply_count FROM Supplypart GROUP BY supplierid) AS subquery 8. ); The query returns the suppliers that supply more parts than the average supplier. The query returns the suppliers with the most supplied parts. The query returns the average supplier in terms of supplied parts. Question 14.2 1. SELECT s.supplierid, s.suppliername 2. FROM Supplier s 3. JOIN Supplypart sp ON s.supplierid = sp.supplierid 4. GROUP BY s.supplierid, s.suppliername 5. HAVING COUNT(sp.partid) > ( 6. SELECT AVG(supply_count) 7. FROM (SELECT COUNT(partid) AS supply_count FROM Supplypart GROUP BY supplierid) AS subquery 8. ); The query returns the suppliers that supply more parts than the average supplier. The query returns the suppliers with the most supplied parts. The query returns the average supplier in terms of supplied parts. Question 14.2 1. WITH SupplierStats AS ( 2. SELECT s.supplierid, 3. s.suppliername, 4. COUNT(sp.partid) AS part_count, 5. [[]] sp.partid)) OVER() AS avg_parts 6. FROM Supplier s 7. JOIN Supplypart sp ON [[]] 8. [[]] s.supplierid, s.suppliername 9. ) 10. SELECT supplierid, suppliername, part_count 11. FROM SupplierStats 12. WHERE [[]] > avg_parts; The query returns the suppliers that supply more parts than the average supplier. Question 14.2 1. WITH SupplierStats AS ( 2. SELECT s.supplierid, 3. s.suppliername, 4. COUNT(sp.partid) AS part_count, 5. AVG(COUNT( sp.partid)) OVER() AS avg_parts 6. FROM Supplier s 7. JOIN Supplypart sp ON [[]] 8. [[]] s.supplierid, s.suppliername 9. ) 10. SELECT supplierid, suppliername, part_count 11. FROM SupplierStats 12. WHERE [[]] > avg_parts; The query returns the suppliers that supply more parts than the average supplier. Question 14.2 1. WITH SupplierStats AS ( 2. SELECT s.supplierid, 3. s.suppliername, 4. COUNT(sp.partid) AS part_count, 5. AVG(COUNT( sp.partid)) OVER() AS avg_parts 6. FROM Supplier s 7. JOIN Supplypart sp ON s.supplierid=sp.supplierid 8. [[]] s.supplierid, s.suppliername 9. ) 10. SELECT supplierid, suppliername, part_count 11. FROM SupplierStats 12. WHERE [[]] > avg_parts; The query returns the suppliers that supply more parts than the average supplier. Question 14.2 1. WITH SupplierStats AS ( 2. SELECT s.supplierid, 3. s.suppliername, 4. COUNT(sp.partid) AS part_count, 5. AVG(COUNT( sp.partid)) OVER() AS avg_parts 6. FROM Supplier s 7. JOIN Supplypart sp ON s.supplierid=sp.supplierid 8. GROUP BY s.supplierid, s.suppliername 9. ) 10. SELECT supplierid, suppliername, part_count 11. FROM SupplierStats 12. WHERE [[]] > avg_parts; The query returns the suppliers that supply more parts than the average supplier. Question 14.2 1. WITH SupplierStats AS ( 2. SELECT s.supplierid, 3. s.suppliername, 4. COUNT(sp.partid) AS part_count, 5. AVG(COUNT( sp.partid)) OVER() AS avg_parts 6. FROM Supplier s 7. JOIN Supplypart sp ON s.supplierid=sp.supplierid 8. GROUP BY s.supplierid, s.suppliername 9. ) 10. SELECT supplierid, suppliername, part_count 11. FROM SupplierStats 12. WHERE part_count > avg_parts; The query returns the suppliers that supply more parts than the average supplier. Question 14.3 1. SELECT o.orderid 2. FROM Orders o 3. WHERE o.orderid NOT IN ( 4. SELECT ol.orderid FROM Orderline ol 5. WHERE ol.supplierid = 5 6. ); The query returns orders that include Supplier 5. The query returns orders from the top 5 suppliers. The query returns orders that do not include Supplier 5. The query returns orders from the bottom 5 suppliers Question 14.3 1. SELECT o.orderid 2. FROM Orders o 3. WHERE o.orderid NOT IN ( 4. SELECT ol.orderid FROM Orderline ol 5. WHERE ol.supplierid = 5 6. ); The query returns orders that include Supplier 5. The query returns orders from the top 5 suppliers. The query returns orders that do not include Supplier 5. The query returns orders from the bottom 5 suppliers Question 14.3 1. SELECT o.orderid 2. FROM Orders o 3. LEFT JOIN [[]] ON o.orderid=ol.orderid AND [[]] 4. WHERE ol.orderid IS [[]] The query returns orders that do not include Supplier 5. Question 14.3 1. SELECT o.orderid 2. FROM Orders o 3. LEFT JOIN Orderline ol ON o.orderid=ol.orderid AND [[]] 4. WHERE ol.orderid IS [[]] The query returns orders that do not include Supplier 5. Question 14.3 1. SELECT o.orderid 2. FROM Orders o 3. LEFT JOIN Orderline ol ON o.orderid=ol.orderid AND ol.supplierid=5 4. WHERE ol.orderid IS [[]] The query returns orders that do not include Supplier 5. Question 14.3 1. SELECT o.orderid 2. FROM Orders o 3. LEFT JOIN Orderline ol ON o.orderid=ol.orderid AND ol.supplierid=5 4. WHERE ol.orderid IS NULL The query returns orders that do not include Supplier 5. Question 15 Write an SQL query to find the employee number of the person with the highest salary ever recorded in the salaries table. We consider here the employee dataset: Question 15 1. SELECT emp_no, salary 2. FROM salaries 3. ORDER BY salary DESC 4. LIMIT 1; Answer: 10897 Find the employee number of the person with the highest salary ever recorded in the salaries table. Question 16 Write an SQL query to find the employee number of the person with the highest average salary over all recorded salary entries. We consider here the employee dataset: Question 16 1. SELECT emp_no, AVG(salary) AS avg_salary 2. FROM salaries 3. GROUP BY emp_no 4. ORDER BY avg_salary DESC 5. LIMIT 1; Answer: 10304 Find the employee number of the person with the highest average salary over all recorded salary entries. Question 17 Write an SQL query to find the last name of the employee who had the highest recorded salary at any point and served as a department manager. We consider here the employee dataset: Question 17 1. SELECT e.last_name, s.salary 2. FROM salaries s 3. JOIN dept_manager dm ON s.emp_no = dm.emp_no 4. JOIN employees e ON s.emp_no = e.emp_no 5. ORDER BY s.salary DESC 6. LIMIT 1; Answer: Markovitch Find the last name of the employee who had the highest recorded salary at any point and served as a department manager. Question 18 Complete SQL query below that updates the salaries table, increasing each employee's salary by 1.5 times its current value. We consider here the employee dataset: Question 18 1. [[]] salaries 2. [[]] salary = salary [[]] 1.5; Find the last name of the employee who had the highest recorded salary at any point and served as a department manager. Question 18 1. UPDATE salaries 2. [[]] salary = salary [[]] 1.5; Find the last name of the employee who had the highest recorded salary at any point and served as a department manager. Question 18 1. UPDATE salaries 2. SET salary = salary [[]] 1.5; Find the last name of the employee who had the highest recorded salary at any point and served as a department manager. Question 18 1. UPDATE salaries 2. SET salary = salary * 1.5; Find the last name of the employee who had the highest recorded salary at any point and served as a department manager. Question 19 Retrieve the highest salary in the new currency. We consider here the employee dataset: Question 19 1. SELECT MAX(salary) 2. FROM salaries; Answer: 204006 Retrieve the highest salary in the new currency. Question 20 This question is a guided exercise to be completed on Moodle. Question 21.1 Create a table named performance_reviews with the following structure: - review_id: Auto-incrementing integer (Primary Key). - emp_no: Foreign key referencing employees(emp_no). - review_date: Date of the review. - score: Integer between 1 and 5. - comments: Optional text field. Question 21.1 1. [[]] performance_reviews ( 2. review_id [[]] PRIMARY KEY , 3. emp_no INT [[]] employees(emp_no), 4. review_date DATE NOT NULL , 5. score INT CHECK (score [[]] 1 AND score [[]] 5), 6. comments TEXT 7. ); Question 21.1 1. CREATE TABLE performance_reviews ( 2. review_id [[]] PRIMARY KEY , 3. emp_no INT [[]] employees(emp_no), 4. review_date DATE NOT NULL , 5. score INT CHECK (score [[]] 1 AND score [[]] 5), 6. comments TEXT 7. ); Question 21.1 1. CREATE TABLE performance_reviews ( 2. review_id SERIAL PRIMARY KEY , 3. emp_no INT [[]] employees(emp_no), 4. review_date DATE NOT NULL , 5. score INT CHECK (score [[]] 1 AND score [[]] 5), 6. comments TEXT 7. ); review_id: Auto-incrementing integer (Primary Key). Question 21.1 1. CREATE TABLE performance_reviews ( 2. review_id SERIAL PRIMARY KEY , 3. emp_no INT REFERENCES employees(emp_no), 4. review_date DATE NOT NULL , 5. score INT CHECK (score [[]] 1 AND score [[]] 5), 6. comments TEXT 7. ); emp_no: Foreign key referencing employees(emp_no). Question 21.1 1. CREATE TABLE performance_reviews ( 2. review_id SERIAL PRIMARY KEY , 3. emp_no INT REFERENCES employees(emp_no), 4. review_date DATE NOT NULL , 5. score INT CHECK (score >= 1 AND score <= 5), 6. comments TEXT 7. ); score: Integer between 1 and 5. Question 21.2 1. ALTER TABLE employees 2. [[]] COLUMN employment_status [[]] 3. [[]] 'Active'; Add a column employment_status with a default value of 'Active'. This field is a String of 10 characters Question 21.2 1. ALTER TABLE employees 2. ADD COLUMN employment_status [[]] 3. [[]] 'Active'; Add a column employment_status with a default value of 'Active'. This field is a String of 10 characters Question 21.2 1. ALTER TABLE employees 2. ADD COLUMN employment_status VARCHAR(10) 3. [[]] 'Active'; Add a column employment_status with a default value of 'Active'. This field is a String of 10 characters Question 21.2 1. ALTER TABLE employees 2. ADD COLUMN employment_status VARCHAR(10) 3. DEFAULT 'Active'; Add a column employment_status with a default value of 'Active'. This field is a String of 10 characters @DS3Lab www.DS3Lab.com Thank you.","libVersion":"0.5.0","langs":""}