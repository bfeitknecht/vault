{"path":"sem4/FMFP/pvw/FMFP-pvw-s04.pdf","text":"Formal Methods and Functional Programming PVW July 14-19, 2025 Wochenplan Donnerstag Heute auf dem Programm ▶ Axiomatic Analysis RulesAxiomatic Analysis ▶ { P } s { Q } ▶ P: Precondition ▶ Q: Postcondition ▶ In initial state σ P evaluates to true and s terminates with initial state σ in σ′ ⇒ Q holds in σ′ ▶ In Assertions (pre- and postconditions) we allow for logical variables. ▶ ⊢ { P } s { Q } ⇐⇒ ∃T .root(T ) ≡ { P } s { Q } Axiomatic Analysis ▶ { P } s { Q } ▶ P: Precondition ▶ Q: Postcondition ▶ In initial state σ P evaluates to true and s terminates with initial state σ in σ′ ⇒ Q holds in σ′ ▶ In Assertions (pre- and postconditions) we allow for logical variables. ▶ ⊢ { P } s { Q } ⇐⇒ ∃T .root(T ) ≡ { P } s { Q } Axiomatic Analysis ▶ { P } s { Q } ▶ P: Precondition ▶ Q: Postcondition ▶ In initial state σ P evaluates to true and s terminates with initial state σ in σ′ ⇒ Q holds in σ′ ▶ In Assertions (pre- and postconditions) we allow for logical variables. ▶ ⊢ { P } s { Q } ⇐⇒ ∃T .root(T ) ≡ { P } s { Q } Axiomatic Analysis ▶ { P } s { Q } ▶ P: Precondition ▶ Q: Postcondition ▶ In initial state σ P evaluates to true and s terminates with initial state σ in σ′ ⇒ Q holds in σ′ ▶ In Assertions (pre- and postconditions) we allow for logical variables. ▶ ⊢ { P } s { Q } ⇐⇒ ∃T .root(T ) ≡ { P } s { Q } Prove OutlineExample proof {x = X } y = 0 i f x = y then s k i p e l s e y = x end {y = X } Example proof solution {x = X } ⊨ {x = X ∧ 0 = 0} y = 0 {x = X ∧ y = 0} i f x = y then {x = y ∧ x = X ∧ y = 0} s k i p {x = y ∧ x = X ∧ y = 0} ⊨ {y = X } e l s e {¬(x = y ) ∧ x = X ∧ y = 0} ⊨ {x = X } y = x {y = X } end {y = X } Übung 1 i : = 0 ; s : = 0 ; w h i l e i <= x do s : = s + i ; i : = i + 1 end 1. Assume x ≥ 0 initially (i.e. as a pre-condition). What is the value of s at the end of the function? 2. Write a post-condition to ensure that s has the right value after completion 3. Find a suitable loop invariant that allowes to prove the post-condition given the pre-condition. 4. Prove that { x = X ∧ x ≥ 0 } s { s = (X +1)X 2 } Übung 1 i : = 0 ; s : = 0 ; w h i l e i <= x do s : = s + i ; i : = i + 1 end 1. Assume x ≥ 0 initially (i.e. as a pre-condition). What is the value of s at the end of the function? 2. Write a post-condition to ensure that s has the right value after completion 3. Find a suitable loop invariant that allowes to prove the post-condition given the pre-condition. 4. Prove that { x = X ∧ x ≥ 0 } s { s = (X +1)X 2 } Übung 1 i : = 0 ; s : = 0 ; w h i l e i <= x do s : = s + i ; i : = i + 1 end 1. Assume x ≥ 0 initially (i.e. as a pre-condition). What is the value of s at the end of the function? 2. Write a post-condition to ensure that s has the right value after completion 3. Find a suitable loop invariant that allowes to prove the post-condition given the pre-condition. 4. Prove that { x = X ∧ x ≥ 0 } s { s = (X +1)X 2 } Übung 1 i : = 0 ; s : = 0 ; w h i l e i <= x do s : = s + i ; i : = i + 1 end 1. Assume x ≥ 0 initially (i.e. as a pre-condition). What is the value of s at the end of the function? 2. Write a post-condition to ensure that s has the right value after completion 3. Find a suitable loop invariant that allowes to prove the post-condition given the pre-condition. 4. Prove that { x = X ∧ x ≥ 0 } s { s = (X +1)X 2 } Übung 1 i : = 0 ; s : = 0 ; w h i l e i <= x do s : = s + i ; i : = i + 1 end 1. Assume x ≥ 0 initially (i.e. as a pre-condition). What is the value of s at the end of the function? 2. Write a post-condition to ensure that s has the right value after completion 3. Find a suitable loop invariant that allowes to prove the post-condition given the pre-condition. 4. Prove that { x = X ∧ x ≥ 0 } s { s = (X +1)X 2 } Total Correctness ▶ Upper bound Z on the number of loop iterations ▶ Z is fresh logical variable. ▶ Erweitere den Beweis von zuvor für Total Correctness. Loop invariante ▶ Es gibt keine Strategie die immer funktioniert. Es brauch Bauchgefühl... ▶ Das kann helfen: ▶ Finde einen Ausdruck, welcher bei jeder loop iteration gleich bleibt. ▶ Dieser Ausdruck sollte nahe an dem sein was wir beweisen wollen. ▶ Aus diesem Ausdruck und ¬b muss man die finale Aussage herleiten können. ▶ Wähle konkrete Werte und schreibe einige loop iterationen auf. Das kann helfen um die Invariante zu finden. HS21 - Proof Outline Consider the following IMP statement s: p : = 0 ; q : = n ; w h i l e p < q do p : = p + 1 ; q : = q − 1 end Construct a proof outline that proves the following Hoare triple: { n ≥ 0 ∧ n = N } s { ⇓ p = ⌈ N 2 ⌉} Clearly state which loop invariant and variant you are using in your proof outline. Üben ▶ PVW p. 59 Exercise 3.1 ▶ Session Exercise Sheet 12, Ex. 2 ▶ Exercise Sheet 12, Ex. 1-2 ▶ Every past exam Freitag Heute auf dem Programm ▶ LTL (Linear Temporal Logic) ▶ Promela ▶ Verschiedenes Linear Temporal Logic Transition System (Programm) ▶ Finite set of states Γ ▶ Starting state s0 ∈ Γ ▶ Transition relation → Berechnung (eine Programm Execution) ▶ Können wir nun schreiben als: s0 → si1 → si2 → . . . ▶ Alle sind unendlich. Variable o sagt ob ein file handler offen ist o = 1 oder geschlossen ist o != 0 ∀isi[o] = 1 ⇒ ∃jsi+j[o] ̸= 0 Linear Temporal Logic Transition System (Programm) ▶ Finite set of states Γ ▶ Starting state s0 ∈ Γ ▶ Transition relation → Berechnung (eine Programm Execution) ▶ Können wir nun schreiben als: s0 → si1 → si2 → . . . ▶ Alle sind unendlich. Variable o sagt ob ein file handler offen ist o = 1 oder geschlossen ist o != 0 ∀isi[o] = 1 ⇒ ∃jsi+j[o] ̸= 0 Linear Temporal Logic Transition System (Programm) ▶ Finite set of states Γ ▶ Starting state s0 ∈ Γ ▶ Transition relation → Berechnung (eine Programm Execution) ▶ Können wir nun schreiben als: s0 → si1 → si2 → . . . ▶ Alle sind unendlich. Variable o sagt ob ein file handler offen ist o = 1 oder geschlossen ist o != 0 ∀isi[o] = 1 ⇒ ∃jsi+j[o] ̸= 0 Einige Mengen Für ein Transition System TS ▶ C(TS) alle mögliche Berechnungen. ▶ Eine property P ist auch eine Menge von Berechnungen. P ⊆ Γω ▶ Eine property hält (TS ⊨ P) gdw C(TS) ⊆ P Label System Vorallem wenn die property von mehreren variablen abhängt wird es sehr mühsam zu schreiben. Label System ▶ Atomic Propositions (Labels) P = {open, closed} ▶ Label function L : Γ → P(P) ▶ Program execution s0 → si1 → si2 → . . . wird zur trace: L(s0) → L(si1) → L(si2) → . . . Ampel Beispiel: P = {r , y , g} (red, yellow, green) Eine trace könnte so aussehen: {r } → {y } → {g} → · · · → {g} → {y , g} → {r } → . . . ∀ir ∈ L(si) ⇒ y ∈ L(si−1) Label System Vorallem wenn die property von mehreren variablen abhängt wird es sehr mühsam zu schreiben. Label System ▶ Atomic Propositions (Labels) P = {open, closed} ▶ Label function L : Γ → P(P) ▶ Program execution s0 → si1 → si2 → . . . wird zur trace: L(s0) → L(si1) → L(si2) → . . . Ampel Beispiel: P = {r , y , g} (red, yellow, green) Eine trace könnte so aussehen: {r } → {y } → {g} → · · · → {g} → {y , g} → {r } → . . . ∀ir ∈ L(si) ⇒ y ∈ L(si−1) LTL Syntax Syntax: φ = p | ¬φ | φ ∧ φ | φ U φ | ⃝φ LTL Semantics t ∈ P(P) w t |= p ⇐⇒ p ∈ t[0] t |= ¬φ ⇐⇒ not (t |= φ) t |= φ ∧ ψ ⇐⇒ (t |= φ and t |= ψ) t |= φ U ψ ⇐⇒ ∃k :k ≥0. (t(≥k ) |= ψ ∧ ∀j:0≤j<k . t(≥j) |= φ) t |= ⃝φ ⇐⇒ t(≥1) |= φ LTL Semantics t ∈ P(P) w t |= p ⇐⇒ p ∈ t[0] t |= ¬φ ⇐⇒ not (t |= φ) t |= φ ∧ ψ ⇐⇒ (t |= φ and t |= ψ) t |= φ U ψ ⇐⇒ ∃k :k ≥0. (t(≥k ) |= ψ ∧ ∀j:0≤j<k . t(≥j) |= φ) t |= ⃝φ ⇐⇒ t(≥1) |= φ LTL Semantics t ∈ P(P) w t |= p ⇐⇒ p ∈ t[0] t |= ¬φ ⇐⇒ not (t |= φ) t |= φ ∧ ψ ⇐⇒ (t |= φ and t |= ψ) t |= φ U ψ ⇐⇒ ∃k :k ≥0. (t(≥k ) |= ψ ∧ ∀j:0≤j<k . t(≥j) |= φ) t |= ⃝φ ⇐⇒ t(≥1) |= φ LTL Semantics t ∈ P(P) w t |= p ⇐⇒ p ∈ t[0] t |= ¬φ ⇐⇒ not (t |= φ) t |= φ ∧ ψ ⇐⇒ (t |= φ and t |= ψ) t |= φ U ψ ⇐⇒ ∃k :k ≥0. (t(≥k ) |= ψ ∧ ∀j:0≤j<k . t(≥j) |= φ) t |= ⃝φ ⇐⇒ t(≥1) |= φ LTL Semantics t ∈ P(P) w t |= p ⇐⇒ p ∈ t[0] t |= ¬φ ⇐⇒ not (t |= φ) t |= φ ∧ ψ ⇐⇒ (t |= φ and t |= ψ) t |= φ U ψ ⇐⇒ ∃k :k ≥0. (t(≥k ) |= ψ ∧ ∀j:0≤j<k . t(≥j) |= φ) t |= ⃝φ ⇐⇒ t(≥1) |= φ LTL - Semantics con’t ♢φ ≡ (true U φ) □φ ≡ ¬♢¬φ Precedence: unary operators have higher precendence. Hence. ♢ψ ⇒ ϕ ≡ (♢ψ) ⇒ ϕ LTL - Semantics con’t ♢φ ≡ (true U φ) □φ ≡ ¬♢¬φ Precedence: unary operators have higher precendence. Hence. ♢ψ ⇒ ϕ ≡ (♢ψ) ⇒ ϕ Üben Consider a transition system with two states s1, s2, where s1 is the initial state, and with transitions back and forth from s1 to s2 as well as a loop from s2 to itself. Let p be true in and only in state s2. Decide for these two LTL formulas if they hold or don’t hold for any trace in this transition system: ▶ □♢p ▶ ♢□p Aufgaben ▶ PVW p.73, Hands-On 1 (ex. 1.2-) Safety Property Something bad is never allowed to happen (and can’t be fixed) An LT-property P is a safety property if for all infinite sequences t ∈ P(AP)ω if t /∈ P then there is a finite prefix ˆt of t such that for every infinite sequence t ′ with prefix ˆt, t ′ /∈ P ▶ Safety properties are violated in finite time. ▶ If a safety property is broken, it cannot be fixed. ▶ \"Bad prefix\" Safety Property Something bad is never allowed to happen (and can’t be fixed) An LT-property P is a safety property if for all infinite sequences t ∈ P(AP)ω if t /∈ P then there is a finite prefix ˆt of t such that for every infinite sequence t ′ with prefix ˆt, t ′ /∈ P ▶ Safety properties are violated in finite time. ▶ If a safety property is broken, it cannot be fixed. ▶ \"Bad prefix\" Safety Property Something bad is never allowed to happen (and can’t be fixed) An LT-property P is a safety property if for all infinite sequences t ∈ P(AP)ω if t /∈ P then there is a finite prefix ˆt of t such that for every infinite sequence t ′ with prefix ˆt, t ′ /∈ P ▶ Safety properties are violated in finite time. ▶ If a safety property is broken, it cannot be fixed. ▶ \"Bad prefix\" Liveness Property If the good thing has not happened yet, it could happen in the future An LT-property P is a liveness property if every finite sequence ˆt ∈ P(AP) ∗ is a prefix of an infinite seqence t ∈ P ▶ Every finite prefix can be fixed. ▶ Liveness properties are violated in infinite time. Liveness Property If the good thing has not happened yet, it could happen in the future An LT-property P is a liveness property if every finite sequence ˆt ∈ P(AP) ∗ is a prefix of an infinite seqence t ∈ P ▶ Every finite prefix can be fixed. ▶ Liveness properties are violated in infinite time. Liveness Property If the good thing has not happened yet, it could happen in the future An LT-property P is a liveness property if every finite sequence ˆt ∈ P(AP) ∗ is a prefix of an infinite seqence t ∈ P ▶ Every finite prefix can be fixed. ▶ Liveness properties are violated in infinite time. Übung I Let p be an atomic proposition. ▶ Prove that both □♢p and ♢□p express liveness properties. ▶ Prove that □p expresses a safety property. Safety LivenessProveDisprove Übung I Let p be an atomic proposition. ▶ Prove that both □♢p and ♢□p express liveness properties. ▶ Prove that □p expresses a safety property. Safety LivenessProveDisprove Übung I con’t ▶ Prove that ♢□p is not a safety property. ▶ Prove that □p is not a lifeness property. Aufgaben ▶ PVW p 75, Hands-On 2 ▶ Exercise Sheet 14, Assignment 2 und 3","libVersion":"0.5.0","langs":""}