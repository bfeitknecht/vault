{"path":"sem2/PProg/VRL/slides/PProg-L26-transactional-memory.pdf","text":"spcl.inf.ethz.ch @spcl_eth TORSTEN HOEFLER Parallel Programming Consensus & Transactional Memory spcl.inf.ethz.ch @spcl_eth ‚ñ™ Theory ‚ñ™ Histories Definitions ‚ñ™ Linearizability Consider invocation + response of method calls to achieve modularity ‚ñ™ Sequential consistency is not modular/composable (just consistent at each thread but not across threads) 2 Last lecture spcl.inf.ethz.ch @spcl_eth ‚ñ™ Consensus (hierarchy) Atomic registers CAS Queues ‚ñ™ Transactional memory ‚ñ™ Motivation (summary of weaknesses in previous approaches) ‚ñ™ Semantics 3 Learning goals for today spcl.inf.ethz.ch @spcl_eth Consensus Literature: Herlihy: Chapter 5.1-5.4, 5.6-5.8 4 spcl.inf.ethz.ch @spcl_eth Consider an object c with the following interface public interface Consensus<T> { T decide (T value); } A number of threads call c.decide(v) with an input value v each. (Wait-free) Consensus P consensus object R Q 5 spcl.inf.ethz.ch @spcl_eth Requirements on consensus protocol ‚Ä¢ wait-free: consensus returns in finite time for each thread ‚Ä¢ consistent: all threads decide the same value ‚Ä¢ valid: the common decision value is some thread's input ‚ûî linearizability of consensus must be such that first thread's decision is adopted for all threads. Consensus protocol P consensus object R Q 6 spcl.inf.ethz.ch @spcl_eth Consensus A c.decide(x)‚Üíx B c.decide(y) ‚Üíx C c.decide(z)‚Üíx time 7 spcl.inf.ethz.ch @spcl_eth A class C solves n-thread consensus if there exists a consensus protocol (algorithm) using any number of objects of class C and any number of atomic registers. Consensus number of C: largest n such that C solves n-thread consensus. Consensus number 8 spcl.inf.ethz.ch @spcl_eth Theorem I: Atomic Registers have consensus number 1. [Proof: Herlihy, Ch. 5, presented during exercise or youtube (below) ‚Äì relevant for exam!] Corollary: There is no wait-free implementation of n-thread consensus, n>1, from read-write registers Atomic registers 9https://www.youtube.com/watch?v=3ZR-REOSG_w spcl.inf.ethz.ch @spcl_eth Theorem II: Compare-And-Swap has infinite consensus number. How to prove this? Compare and swap 10 spcl.inf.ethz.ch @spcl_eth class CASConsensus { private final int FIRST = -1; private AtomicInteger r = new AtomicInteger(FIRST); // supports CAS private AtomicIntegerArray proposed; // suffices to be atomic register ‚Ä¶ // constructor (allocate array proposed etc.) public Object decide (Object value) { int i = ThreadID.get(); proposed.set(i, value); if (r.compareAndSet(FIRST, i)) // I won return proposed.get(i); // = value else return proposed.get(r.get()); } } Proof by construction 11 spcl.inf.ethz.ch @spcl_eth Theorem III: There is no wait-free implementation of a FIFO queue with atomic registers How to prove this now? Proof by contradiction follows. How to use these theorems? Example: wait-free FIFO queue 12 Theorem I: They have consensus number 1! spcl.inf.ethz.ch @spcl_eth Can a FIFO queue implement two-thread consensus? proposed array FIFO queue with one red and one black ball8 red ball black ball 13 spcl.inf.ethz.ch @spcl_eth Protocol: Write value to array 0 1 0 14 spcl.inf.ethz.ch @spcl_eth Protocol: Take next item from queue 0 0 1 8 15 spcl.inf.ethz.ch @spcl_eth Protocol: Take next Item from queue 0 1 I got the red ball, so I will decide my value I got the black ball, so I will decide the other‚Äôs value from the array 8 16 spcl.inf.ethz.ch @spcl_eth If one thread gets the red ball Then the other gets the black ball Winner decides her own value Loser can find winner‚Äôs value in array Because threads write array Before dequeueing from queue Why does this work? 17 spcl.inf.ethz.ch @spcl_eth Given A consensus protocol from queue and registers Assume there exists A queue implementation from atomic registers Substitution yields: A wait-free consensus protocol from atomic registers However: atomic registers have consensus number 1 Wait-free queue implementation from atomic registers? 18 spcl.inf.ethz.ch @spcl_eth We know ‚Ä¢ Wait-free FIFO queues have consensus number 2 (we showed ¬´at least 2¬ª only) ‚Ä¢ Test-And-Set, getAndSet, getAndIncrement have consensus number 2 ‚Ä¢ CAS has consensus number ‚àû ‚Üí wait-free FIFO queues, wait-free RMW operations and CAS cannot be implemented with atomic registers! Why consensus is important 19 spcl.inf.ethz.ch @spcl_eth 1 Read/Write Registers 2 getAndSet, getAndIncrement, ‚Ä¶ FIFO Queue LIFO Stack . . ‚àû CompareAndSet, ‚Ä¶ Multiple Assignment The Consensus Hierarchy 20 spcl.inf.ethz.ch @spcl_eth Squaring the circle Geometric way to construct a square with the same area as a given circle with compass and straightedge using a finite number of steps. There is an algebraic proof that no such construction exists. People tried it for hundreds of years, some still try it today. Apparently they do not believe the mathematical proof. Let's not do the same mistake in our field...: provably there is no way to construct certain wait-free algorithms with atomic registers. Don't even try. Importance of Consensus by Analogy r=1 ùúã 21 spcl.inf.ethz.ch @spcl_eth Motivation for Transactional Memory 22 spcl.inf.ethz.ch @spcl_eth Motivation: programming with locks is too difficult Lock-free programming is even more difficult... Goal: remove the burden of synchronization from the programmer and place it in the system (hardware / software) Transactional Memory in a nutshell Literature: - Herlihy Chapter 18.1 ‚Äì 18.2. - Herlihy Chapter 18.3. interesting but too detailed for this course. 23 spcl.inf.ethz.ch @spcl_eth Deadlocks: threads attempt to take shared/dependent locks in different orders What is wrong with locking? 24 spcl.inf.ethz.ch @spcl_eth Convoying: thread holding a resource R is descheduled while other threads queue up waiting for R What is wrong with locking? 25 spcl.inf.ethz.ch @spcl_eth Priority Inversion: lower priority thread holds a resource R that a high priority thread is waiting on What is wrong with locking? 26 spcl.inf.ethz.ch @spcl_eth Association of locks and data established by convention (e.g., monitors). The best you can do is reasonably document your code! What is wrong with locking? 27 spcl.inf.ethz.ch @spcl_eth Example: Unbounded Queue (FIFO) What is wrong with CAS? sentinel node node node node node head tail value value value value value public class LockFreeQueue<T> { private AtomicReference<Node> head; private AtomicReference<Node> tail; public void enq(T item); public T deq(); } public class Node { public T value; public AtomicReference<Node> next; public Node(T v) { value = v; next = new AtomicReference<Node>(null); } } 28 spcl.inf.ethz.ch @spcl_eth Enqueue S node node node node node head tail new ‚ë† ‚ë° CAS next CAS tail value value value value value value Two CAS operations ‚Üí half finished enqueue visible to other processes 29 spcl.inf.ethz.ch @spcl_eth Dequeue S node node node node node head tail ‚ë† ‚ë° value value value value value read value CAS head 30 spcl.inf.ethz.ch @spcl_eth public class LockFreeQueue<T> { .. public void enq(T item) { Node node = new Node(item); while(true) { Node last = tail.get(); Node next = last.next.get(); if (last == tail.get()) { if (next == null) if (last.next.compareAndSet(next, node)) { tail.compareAndSet(last, node); return; } else tail.compareAndSet(last, next); } } } } Code for enqueue Half finished insert may happen! Help other processes with finishing operations (‚Üí lock-free) 31 spcl.inf.ethz.ch @spcl_eth public class LockFreeQueue<T> { .. public void enq(T item) { Node node = new Node(item); while(true) { Node last = tail.get(); Node next = last.next.get(); if (multiCompareAndSet({last.next, tail},{next, last},{node, node}) return; } } } Code with hypothetical DCAS This code ensures consistency of both next and last: operation either fails completely without effect or the effect happens atomically 32 spcl.inf.ethz.ch @spcl_eth class Account { private final Integer id; // account id private Integer balance; // account balance Account(int id, int balance) { this.id = new Integer(id); this.balance = new Integer(balance); } synchronized void withdraw(int amount) { // assume that there are always sufficient funds... this.balance = this.balance ‚Äì amount; } synchronized void deposit(int amount) { this.balance = this.balance + amount; } } More problems: Bank account 33 spcl.inf.ethz.ch @spcl_eth void transfer_unsafe(Account a, Account b, int amount) { a.withdraw(amount); b.deposit(amount); } Bank account transfer (unsafe) Transfer does not happen atomically A thread might observe the withdraw, but not the deposit 34 spcl.inf.ethz.ch @spcl_eth void transfer_deadlock(Account a, Account b, int amount) { synchronized (a) { synchronized (b) { a.withdraw(amount); b.deposit(amount); } } } Bank account transfer (can cause a deadlock) 35 Concurrently executing: ‚ñ™ transfer_deadlock(a, b) ‚ñ™ transfer_deadlock(b, a) Might lead to a deadlock spcl.inf.ethz.ch @spcl_eth void transfer(Account a, Account b, int amount) { if (a.id < b.id) { synchronized (a) { synchronized (b) { a.withdraw(amount); b.deposit(amount); } } } else { synchronized (b) { synchronized (a) { a.withdraw(amount); b.deposit(amount); } } } } Bank account transfer (lock ordering to avoid deadlock) 36 spcl.inf.ethz.ch @spcl_eth void transfer_elegant(Account a, Account b, int amount) { Account first, second; if (a.id < b.id) { first = a; second = b; } else { first = b; second = a; } synchronized (first) { synchronized (second) { a.withdraw(amount); b.deposit(amount); } } } Bank account transfer (slightly better ordering version) Code for the actual operationCode for synchronization 37 spcl.inf.ethz.ch @spcl_eth Ensuring ordering (and correctness) is really hard (even for advanced programmers at least annoying) ‚ñ™ rules are ad-hoc, and not part of the program ‚ñ™ (documented in comments at best-case scenario) Locks are not composable ‚ñ™ how can you combine n thread-safe operations? ‚ñ™ internal details about locking are required ‚ñ™ big problem, especially for programming ‚Äúin the large‚Äù Lack of composability 38 spcl.inf.ethz.ch @spcl_eth Locks are pessimistic ‚óè worst is assumed ‚óè performance overhead paid every time Locking mechanism is hard-wired to the program ‚óè synchronization / rest of the program cannot be separated ‚óè changing synchronization scheme ‚Üí changing all of the program Problems using locks (cont'd) 39 spcl.inf.ethz.ch @spcl_eth What the programmer actually meant to say is: atomic { a.withdraw(amount); b.deposit(amount); } ‚Üí This is the idea behind transactional memory also behind locks, isn‚Äôt it? The difference is the execution! Solution: atomic blocks (or transactions) I want these operations to be performed atomically! 40 atomic { a.withdraw(amount); b.deposit(amount); } spcl.inf.ethz.ch @spcl_eth Programmer explicitly defines atomic code sections Programmer is concerned with: what: what operations should be atomic but, not how: e.g., via locking the how is left to the system (software, hardware or both) (declarative approach) Transactional Memory (TM) 41 spcl.inf.ethz.ch @spcl_eth ‚ñ™ simpler and less error-prone code ‚ñ™ higher-level (declarative) semantics (what vs. how) ‚ñ™ composable ‚ñ™ analogy to garbage collection (Dan Grossman. 2007. \"The transactional memory / garbage collection analogy\". SIGPLAN Not. 42, 10 (October 2007), 695-706.) ‚ñ™ optimistic by design (does not require mutual exclusion) TM benefits 42 spcl.inf.ethz.ch @spcl_eth changes made by a transaction are made visible atomically other threads preserve either the initial or the final state, but not any intermediate states Note: locks enforce atomicity via mutual exclusion, while transactions do not require mutual exclusion TM semantics: Atomicity 43 spcl.inf.ethz.ch @spcl_eth Transactions run in isolation ‚ñ™ while a transaction is running, effects from other transactions are not observed ‚óè as if the transaction takes a snapshot of the global state when it begins and then operates on that snapshot TM semantics: Isolation 44 spcl.inf.ethz.ch @spcl_eth Serializability TXA Thread 0 Thread 1 TXB TXA TXB as if: Executed Sequentially (transactions appear serialized) 45 spcl.inf.ethz.ch @spcl_eth Transactional Memory is heavily inspired by database transactions ACID properties in database transactions: ‚óè Atomicity ‚óè Consistency (data remains in a consistent state) ‚óè Isolation (no mutual corruption of data) ‚óè Durability (e.g., transaction effects will survive power loss ‚Üí stored in disk) Transactions in databases 46 spcl.inf.ethz.ch @spcl_eth Big lock around all atomic sections ‚ñ™ gives (nearly all) desired properties, but not scalable ‚ñ™ not done in practice for obvious reasons Keep track of operations performed by each transaction ‚ñ™ concurrency control ‚ñ™ system ensures atomicity and isolation properties How to implement TM? Which are missing? 47 spcl.inf.ethz.ch @spcl_eth Conflict example: a transaction (not yet committed) has read a value that was changed by a transaction that has committed What happens when a conflict occurs? TXA atomic { ‚Ä¶ x = a // read a if (x == 0) { ‚Ä¶ } else { ‚Ä¶ } } TXB atomic { ‚Ä¶ a = 10 // write a ‚Ä¶ } 48 initially: a = 0 spcl.inf.ethz.ch @spcl_eth Conflict example: a transaction (not yet committed) has read a value that was changed by a transaction that has committed What happens when a conflict occurs? TXA atomic { ‚Ä¶ x = a // read a if (x == 0) { ‚Ä¶ } else { ‚Ä¶ } } TXB atomic { ‚Ä¶ a = 10 // write a ‚Ä¶ } started not started 49 initially: a = 0 spcl.inf.ethz.ch @spcl_eth Conflict example: a transaction (not yet committed) has read a value that was changed by a transaction that has committed What happens when a conflict occurs? TXA atomic { ‚Ä¶ x = a // read a if (x == 0) { ‚Ä¶ } else { ‚Ä¶ } } TXB atomic { ‚Ä¶ a = 10 // write a ‚Ä¶ } read value 0 not started 50 initially: a = 0 spcl.inf.ethz.ch @spcl_eth Conflict example: a transaction (not yet committed) has read a value that was changed by a transaction that has committed What happens when a conflict occurs? TXA atomic { ‚Ä¶ x = a // read a if (x == 0) { ‚Ä¶ } else { ‚Ä¶ } } TXB atomic { ‚Ä¶ a = 10 // write a ‚Ä¶ } read value 0 started 51 initially: a = 0 spcl.inf.ethz.ch @spcl_eth Conflict example: a transaction (not yet committed) has read a value that was changed by a transaction that has committed What happens when a conflict occurs? TXA atomic { ‚Ä¶ x = a // read a if (x == 0) { ‚Ä¶ } else { ‚Ä¶ } } TXB atomic { ‚Ä¶ a = 10 // write a ‚Ä¶ } read value 0 update a locally not visible to other transactions 52 initially: a = 0 spcl.inf.ethz.ch @spcl_eth Conflict example: a transaction (not yet committed) has read a value that was changed by a transaction that has committed What happens when a conflict occurs? TXA atomic { ‚Ä¶ x = a // read a if (x == 0) { ‚Ä¶ } else { ‚Ä¶ } } TXB atomic { ‚Ä¶ a = 10 // write a ‚Ä¶ } read value 0 commited changes visible to other transactions 53 initially: a = 0 spcl.inf.ethz.ch @spcl_eth Conflict example: a transaction (not yet committed) has read a value that was changed by a transaction that has committed What happens when a conflict occurs? TXA atomic { ‚Ä¶ x = a // read a if (x == 0) { ‚Ä¶ } else { ‚Ä¶ } } TXB atomic { ‚Ä¶ a = 10 // write a ‚Ä¶ } commited can this transaction now be placed after TXB in the serialization order? commited changes visible to other transactions 54 initially: a = 0 spcl.inf.ethz.ch @spcl_eth Serialized view TXA atomic { ‚Ä¶ x = a // read a if (x == 0) { ‚Ä¶ } else { ‚Ä¶ } } TXB atomic { ‚Ä¶ a = 10 // write a ‚Ä¶ } Serial order of transactions. Should have read a == 10 Executions that read a == 0 are invalid! 55 initially: a = 0 spcl.inf.ethz.ch @spcl_eth Issues like this are handled by a Concurrency Control (CC) mechanism When a transaction aborts, it can be retried automatically or the user is notified Transactions will be aborted if necessary 56 spcl.inf.ethz.ch @spcl_eth Bank account example TXA atomic { Withdraw(a, 10); Deposit(b, 10); } TXB atomic { Withdraw(b, 5); Deposit(a, 5); } Initially a = 100; b = 100 57 spcl.inf.ethz.ch @spcl_eth Bank account example TXA atomic { Withdraw(a, 10); Deposit(b, 10); } TXB atomic { Withdraw(b, 5); Deposit(a, 5); } Initially a = 100; b = 100 a reads 100, now local a = 90 58 spcl.inf.ethz.ch @spcl_eth Bank account example TXA atomic { Withdraw(a, 10); Deposit(b, 10); } TXB atomic { Withdraw(b, 5); Deposit(a, 5); } Initially a = 100; b = 100 a reads 100, now local a = 90 b reads 100 now local b = 95 a reads 100 now local a = 105 59 spcl.inf.ethz.ch @spcl_eth Bank account example TXA atomic { Withdraw(a, 10); Deposit(b, 10); } TXB atomic { Withdraw(b, 5); Deposit(a, 5); } Initially a = 100; b = 100 a reads 100, now local a = 90 commit a is now 105 b is now 95 60 spcl.inf.ethz.ch @spcl_eth Bank account example TXA atomic { Withdraw(a, 10); Deposit(b, 10); } TXB atomic { Withdraw(b, 5); Deposit(a, 5); } Initially a = 100; b = 100 commit a is now 105 b is now 95 What now? May b read 95? 61 spcl.inf.ethz.ch @spcl_eth Zombies and Consistency TXA atomic { a = a + 10; b = b + 10; c = 1 / (a-b); } TXB atomic { a = a - 10; b = b + 10; c = 1 / (a-b); } Initially a = 10; b = 0; c = 0 62 spcl.inf.ethz.ch @spcl_eth Zombies and Consistency TXA atomic { a = a + 10; b = b + 10; c = 1 / (a-b); } TXB atomic { a = a - 10; b = b + 10; c = 1 / (a-b); } Initially a = 10; b = 0; c = 0 local a = 20 commit a = 0 b = 10 63 spcl.inf.ethz.ch @spcl_eth Zombies and Consistency TXA atomic { a = a + 10; b = b + 10; c = 1 / (a-b); } TXB atomic { a = a - 10; b = b + 10; c = 1 / (a-b); } Initially a = 10; b = 0; c = 0 if b read 10, we would have a-b = 0 ‚Üí catastrophic inconsistency commit a = 0 b = 10 64 spcl.inf.ethz.ch @spcl_eth The transactional memory system guarantees that consistent data will always be seen by a running transaction Possibilities (conceptually): ‚ñ™ Snapshot at the beginning ‚ñ™ Early abort Consistency Guarantee 65 spcl.inf.ethz.ch @spcl_eth Hardware TM (HTM): ‚ñ™ can be fast ‚ñ™ but bounded resources ‚ñ™ can often not handle big transactions Examples: ‚ñ™ Intel Haswell ‚Üí first widely available implementation of TM on x86 (future unclear) ‚ñ™ Sun (now Oracle) Rock ‚Üí was not released ‚ñ™ Supercomputers (IBM's Blue Gene/Q) ‚Üí long retired Where to implement TM? Intel Haswell instructions xbegin: transaction begin xend: transaction end xabort: abort transaction Pattern: xbegin L0 <transaction code> xend <commit was successful> ... L0: <transaction aborted> 66 spcl.inf.ethz.ch @spcl_eth Software (STM) ‚ñ™ in the (parallel) programming language ‚ñ™ greater flexibility ‚ñ™ achieving good performance might be challenging ‚ñ™ Examples: Haskell, Clojure, ‚Ä¶ Hybrid TM (Hardware + Software) ‚ñ™ research topic Where to implement TM? 67 spcl.inf.ethz.ch @spcl_eth Implementations are still immature Many different approaches The first HTM (RTM) implementation became widely available in Intel‚Äôs Haswell architecture (and has largely been remove soon after)! STM implementations are still being actively developed TM is still work in progress! 68 spcl.inf.ethz.ch @spcl_eth Q: What happens when shared state accessed by a transaction is also accessed outside of a transaction? Are the transactional guarantees still maintained? Strong isolation: Yes ‚ñ™ easier for porting existing code ‚ñ™ difficult to implement, overhead Weak isolation: No Design choice: strong vs. weak isolation 69 spcl.inf.ethz.ch @spcl_eth Q: What are the semantics of nested transactions (Note: nested transactions are important for composability) ‚ñ™ Flat nesting ‚ñ™ Closed nesting ‚ñ™ Other approaches (e.g., open nesting) Design choice: Nesting 70 spcl.inf.ethz.ch @spcl_eth 71 Flattened nesting atomic { atomic { atomic { ... } } } atomic { ... } inner aborts ‚Üí outer aborts inner commits ‚Üí changes visible only if outer commits spcl.inf.ethz.ch @spcl_eth Similar to flattened, but: ‚ñ™ an abort of an inner transaction does not result in an abort for the outer transaction Inner transaction commits ‚ñ™ changes visible to outer transaction ‚ñ™ but not to other transactions Outer transaction commits ‚ñ™ changes of inner transactions become visible globally Closed nesting 72 spcl.inf.ethz.ch @spcl_eth If all program variables are protected: ‚ñ™ easier to port existing code but, difficult to implement ‚ñ™ need to check every memory operation 73 What is part of a transaction? stmt1; stmt2; stmt3; atomic { stmt1; stmt2; stmt3; } spcl.inf.ethz.ch @spcl_eth Mutable state is put into special variables These variables can only be modified inside a transaction Everything else is immutable (or not shared) This is the model that we will (briefly) discuss 74 Reference-based STMs spcl.inf.ethz.ch @spcl_eth Java does not include STM support ‚ñ™ Scala-stm is an STM library built for scala ‚ñ™ Has a Java interface ‚ñ™ Follows the reference-based (Ref) approach Other STMs for Java exist (e.g., Deuce), exhibiting a research character [like also the scala-stm in Java] We will use scala-stm 75 spcl.inf.ethz.ch @spcl_eth Java 7 does not have lambdas (Java 8 has!) ‚Üí each transaction is defined as a Runnable Object No compiler support for ensuring that Refs are only accessed inside a transaction Our goal is to get a first idea of how to use an STM ‚ñ™ a view of things to come (?) ‚ñ™ not an established programming technique yet scala-stm (on Java) limitations 76 spcl.inf.ethz.ch @spcl_eth class AccountSTM { private final Integer id; // account id private final Ref.View<Integer> balance; AccountSTM(int id, int balance) { this.id = new Integer(id); this.balance = STM.newRef(balance); } } Bank account (ScalaSTM) 77 spcl.inf.ethz.ch @spcl_eth void withdraw(final int amount) { // assume that there are always sufficient funds... atomic { int old_val = balance.get(); balance.set(old_val ‚Äì amount); } } void deposit(final int amount) { atomic { int old_val = balance.get(); balance.set(old_val + amount); } } Ideal world: bank account using atomic keyword 78 spcl.inf.ethz.ch @spcl_eth void withdraw(final int amount) { // assume that there are always sufficient funds... STM.atomic(new Runnable() { public void run() { int old_val = balance.get(); balance.set(old_val ‚Äì amount); }}); } void deposit(final int amount) { STM.atomic(new Runnable() { public void run() { int old_val = balance.get(); balance.set(old_val + amount); }}); } 79 Real world: bank account in ScalaSTM spcl.inf.ethz.ch @spcl_eth public int getBalance() { int result = STM.atomic( new Callable<Integer>() { public Integer call() { int result = balance.get(); return result; } }); return result; } GetBalance (return a value)\"atomic\" 80 spcl.inf.ethz.ch @spcl_eth What if account a does not have enough funds? How can we wait until it does in order to retry the transfer? locks ‚Üí conditional variables TM ‚Üí retry static void transfer(final AccountSTM a, final AccountSTM b, final int amount) { atomic { a.withdraw(amount); b.deposit(amount); } } Bank account transfer 81 spcl.inf.ethz.ch @spcl_eth static void transfer_retry(final AccountSTM a, final AccountSTM b, final int amount) { atomic { if (a.balance.get() < amount) STM.retry(); a.withdraw(amount); b.deposit(amount); } } retry: abort the transaction and retry when conditions change Bank account transfer with retry 82 static void transfer_retry(final AccountSTM a, final AccountSTM b, final int amount) { atomic { if (a.balance.get() < amount) STM.retry(); a.withdraw(amount); b.deposit(amount); } } spcl.inf.ethz.ch @spcl_eth Implementations need to track what reads/writes a transaction performed to detect conflicts ‚ñ™ Typically called read-/write-set of a transaction ‚ñ™ When retry is called, transaction aborts and will be retried when any of the variables that were read, change ‚ñ™ In our example, when a.balance is updated, the transaction will be retried How does retry work? 83 spcl.inf.ethz.ch @spcl_eth Ingredients Threads that run transactions with thread states ‚ñ™ active ‚ñ™ aborted ‚ñ™ committed Objects representing state stored in memory (the variables affected by a transaction) ‚ñ™ offering methods like a constructor, read (get), write (set) ‚ñ™ and copy! Simplest STM Implementation 87 spcl.inf.ethz.ch @spcl_eth Clock-based STM System global clock Transaction A birthdate Transaction B birthdate Transaction C commits increases read at start read at start 88 spcl.inf.ethz.ch @spcl_eth Each transaction uses a local read-set and a local write-set holding all locally read and written objects. Transaction calls read - check if the object is in the write set ‚Üí return this (new) version - otherwise check if object's time stamp ‚â§ transaction's birthdate, if not throw aborted exception, otherwise add new copy of the object to the read set Transaction calls write - if object is not in write set, create a copy of it in the write set Atomic Objects atomic memory object version reference time stamp 89 spcl.inf.ethz.ch @spcl_eth Transaction life time time birthdate of T X.date Y.date Z.date T reads Y T reads X T reads Z read set of T 90","libVersion":"0.3.2","langs":""}