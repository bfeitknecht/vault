{"path":"sem2/PProg/VRL/extra/kuhn/PProg-w14-kuhn.pdf","text":"Parallel Programming Last Session J Spring 2024 Schedule Post-Discussion Assignment 12 Theory Recap (Consensus, transactional memory incl. sheet 13 ) Exam tasks Exam Tips/ Recipes Kahoot ?Post-Discussion Ex.12 Pen& PaperPen& Paper Some common “tricks” if it seems like a long/”hard” history check typically ”bad” cases: does it even make sense f.eg. dequeue 3x even though only 2x enqueue read return value not even written per thread not sequential L if not seq. consistent also follows not linearizable Pen& Paper Any questions ? Pen& Paper Any questions ? Understand the concept of sequential consistency & linearizability Pen& Paper Any questions ? Understand the concept of sequential consistency & linearizability sequential consistent: allowed to reorder as long as the per-thread projections remain identical Pen& Paper Any questions ? Understand the concept of sequential consistency & linearizability sequential consistent: allowed to reorder as long as the per-thread projections remain identical Applied: seq. consistency -> allows shifting linearizability -> no shifting, stay in real-time execution interval Example Collection This is an example of a history that is _______________ but not ________________ Example Collection This is an example of a history that is quiescent con. but not seq. consistent Example Collection This ? Example Collection This ? none Collection This is an example of a history that is _______________ but not ________________ Collection This is an example of a history that is seq. consistent but not linearizable Pen& Paper Any questions ? Pen& Paper Any questions ? Understand the concept of sequential consistency & linearizability Conclusion when look at old exams: know how to define& apply it ! Pen& Paper Any questions ? Understand the concept of sequential consistency & linearizability Conclusion when look at old exams: know how to define& apply it ! Questions? Theory Recap ConsensusConsensus A protocol where n-threads should agree on one value. Consensus A protocol where n-threads should agree on one value. Many important real-life applications :: blockchain (oracle nodes), databases etc. Consensus A protocol where n-threads should agree on one value. Many important real-life applications :: blockchain (oracle nodes), databases etc. Consensus A protocol where n-threads should agree on one value. Many important real-life applications :: blockchain (oracle nodes), databases etc. you use this object of class C to make n- threads agree on a value Consensus Meassure on how strong a synchronization method is. Consensus also Messure on how strong a synchronization method is. Is there an ordering on synchronization primitives ? Consensus also Messure on how strong a synchronization method is. Is there an ordering on synchronization primitives ? Compare them based on for how many threads they can solve a synchronization problem consensus Consensus : Build How can we implement Consensus ? Consensus : Build Building blocks: any amount of atomic registers + objects of class C Consensus : Build Building blocks: any amount of atomic registers + objects of class C à Class C then solves n-thread consensus <-> make n threads agree Consensus : Build Building blocks: any amount of atomic registers + objects of class C à Class C then solves n-thread consensus Consensus number: largest n such that Class C solves the n-thread consensus But how does it look like ?But how does it look like ? Consensus object c has decide() function But how does it look like ? Consensus object c has decide() function Threads call it -> Decide() function will return the decided value c.decide(v) Consensus Protocol : What do we expect from a consensus implementation ? Finite time ? What when one thread fails ? Consensus Protocol : What do we expect from a consensus implementation ? Finite time ? What when one thread fails ? call it consensus protocol if fullfills certain conditions…. 39 Recap: Consensus Protocols I propose “23”. I propose “42”. A few moments later… (a finite number of steps) We agreed on“23”. We agreed on “23” Which other scenarios are allowed? 40 Wait-Free I propose “23”. I propose “42”. I cannot finish because I am waiting for the other thread. This is illegal! Consensus needs to be wait-free: All threads finish after a finite number of steps, independent of other threads. I will not schedule you now! Consensus Protocol : What do we expect from a consensus implementation ? 42 Consistent Result I propose “23”. I propose “42”. We agreed on“23”. We agreed on “42” This is illegal! Consensus result needs to be Consensus Protocol : What do we expect from a consensus implementation ? 44 Valid Result I propose “23”. I propose “42”. We agreed on“420”. We agreed on “420” This is illegal! Consensus result needs to be valid: proposed by some thread. Consensus Protocol : What do we expect from a consensus implementation ? Consensus Protocol : What do we expect from a consensus implementation ? Consensus object is linearizable to a sequential consistent object -> where thread who wins, completes decided first Question If we know we have a lock-free consensus implementation, is it then also wait-free ? What do we know about threads calling the decide function ? Question If we know we have a lock-free consensus implementation, is it then also wait-free ? Since each thread calls decide() at most once, by definition a lock-free implementation is also wait-free. (assuming n-thread consensus for any n) Binary Consensus Make threads decide on value 0 or 1 and not any integer value. Binary Consensus Make threads decide on value 0 or 1 and not any integer value. Binary consensus using normal consensus? Binary Consensus Make threads decide on value 0 or 1 and not any integer value. Binary consensus using normal consensus: just call the normal consensus using binary values 0 and 1. binary_decide(bit b) { return int_decide(b) } Binary Consensus Make threads decide on value 0 or 1 and not any integer value. Normal consensus using binary consensus? Binary Consensus Make threads decide on value 0 or 1 and not any integer value. Normal consensus using binary consensus: Binary Consensus Make threads decide on value 0 or 1 and not any integer value. Normal consensus using binary consensus: use binary consensus to decide winner index Binary Consensus Make threads decide on value 0 or 1 and not any integer value. Binary consensus equivalent to normal consensus Why consensus is important Now want to prove things about objects using consensus. Why consensus is important Now want to prove things about objects using consensus. If we know the consensus number of certain objects can prove that other objects with higher consensus number cannot be implemented with our initial objects Why consensus is important Now want to prove things about objects using consensus. If we know the consensus number of certain objects can prove that other objects with higher consensus number cannot be implemented with our initial objects Proof tools…. Protocol state Now want to prove things about objects using consensus. If we know the consensus number of certain objects can prove that other objects with higher consensus number cannot be implemented with our initial objects Modell it as a graph/state tree node = state of thread & objects edge = possible move (method call) by on thread Protocol Now want to prove things about objects using consensus. If we know the consensus number of certain objects can prove that other objects with higher consensus number cannot be implemented with our initial objects Modell it as a graph/state tree node = state of thread & objects edge = possible move (method call) by on thread Protocol (2-thread consensus) from official slides Protocol (2-thread consensus) state & each state has 2 possible successors -> A or B make a move from official slides Protocol (2-thread consensus) state & each state has 2 possible successors -> A or B make a move from official slides Graph should not look like this ? Which property not fulfilled ? Binary Consensus Give states names according to their property 67 Anatomy of a State (in two-thread consensus) Shared Variables Thread local variables of A Thread local variables of B Program counter of A Program counter of B Binary Consensus Give state names according to their property Binary Consensus Bivalent: states where still both values possible (always start state ) Give state names according to their property Binary Consensus Bivalent: states where still both values possible (always start state ) Univalent: states from where we only reach 1 value “outcome fixed” (output states) Give state names according to their property Binary Consensus Bivalent: states where still both values possible (always start state ) Univalent: states from where we only reach 1 value “outcome fixed” (output states) Critical: state is bivalent but all its successor univalent “decided here” Give states names according to their property Task(from official slides)Task(from official slides)Task(from official slides)Task(from official slides)Task(from official slides)Task(from official slides)Task(from official slides)Task(from official slides)Task(from official slides)Task(from official slides) 86 Critical State Existence Proof Lemma: Every consensus protocol has a critical state. Proof: From (bivalent) start state, let the threads only move to other bivalent states. • If it runs forever the protocol is not wait free. • If it reaches a position where no moves are possible this state is critical. Why useful ? If we know the consensus number of certain objects can prove that other objects with higher consensus number cannot be implemented with our initial objects f.eg with atomic registers Atomic registers Proof is perfectly explained in the book, we don’t have time for full proof, just outline. Atomic registers Suppose there exists a binary consensus protocol for two threads A and B. We will reason about the properties of such a protocol and derive a contradiction. Now there is a critical state in every consensus protocol (Lemma) A next move : 0-valent state B next move : 1-valent state Now we look at what A & B could call : read, write different registers & write same reigsters Proof outlineProof outline write to different registers Proof outline write to same register 104 That’s all First Action A: r1.read() A: r1.write() Second Action B: r1.read() No, Case I No, Case I’ B: r2.read() No, Case I No, Case I’ B: r1.write() No, Case I No, Case III B: r2.write() No, Case I No, Case II Is binary consensus possible for any of those? No 1985, 2.5k citations If you want to get more detail -> read in the book Why consensus is important If we know the consensus number of certain objects -> can prove that other objects with higher consensus number cannot be implemented with our initial objects Why consensus is important If we know the consensus number of certain objects -> can prove that other objects with higher consensus number cannot be implemented with our initial objects We know from the lecture: Why consensus is important If we know the consensus number of certain objects -> can prove that other objects with higher consensus number cannot be implemented with our initial objects We know from the lecture: & just proved that atomic register have consensus number 1 Conclusion ? Why consensus is importantTask(from official slides) Assume you have a machine with atomic registers and an atomic test-and-set operation. (set value from 0 to 1 aka like CAS but only from 0 to 1, not any value. -> returns 1 on success) Implement a two-process consensus protocol using TAS() and atomic registers. Task(from official slides) Assume you have a machine with atomic registers and an atomic test-and-set operation. (set value from 0 to 1 aka like CAS but only from 0 to 1, not any value. -> returns 1 on success) Implement a two-process consensus protocol using TAS() and atomic registers. How can you make threads agree on a value 0 or 1 using TAS? Task(from official slides)Task(from official slides) What is consensus number of TAS ? 2 CAS consensus What do you think ? Consensus number of CAS ? CAS consensus What do you think ? Consensus number of CAS ? Infinite/ unbounded How to prove this ? How do I in general proof a consensus number ? CAS consensus What do you think ? Consensus number of CAS ? Infinite/ unbounded How to prove this ? How do I in general proof a consensus number ? construct the consensus protocol CAS consensusCAS consensus If no one has written it, I’m the first& take my value CAS consensus If no one has written it, I’m the first& take my value Someone was first, agree on their value Implemented I choose to init it with -1 bc no thread can have -1 ID What about queues ?What about queues ? Depends on which methods we have in our class ! What about queues ? Depends on which methods we have in our class ! Dequeue, enqueue & do we also have peek or not ? consensus number depends on object implementation What about queues ? Depends on which methods we have in our class ! Dequeue, enqueue & do we also have peek or not ? consensus number depends on object implementation Consensus of wait-free queue with only en-& dequeue Wait-free queue ? Only en- & dequeue: Wait-free queue ? Only en- & dequeue: consensus number = 2 Wait-free queue ? Only en- & dequeue: consensus number = 2 I’m the first one to dequeue, I won Wait-free queue ? Only en- & dequeue: consensus number = 2 I’m the first one to dequeue, I won Another thread won, let’s decide his value Wait-free queue ? Only en- & dequeue & peek: Wait-free queue ? Only en- & dequeue & peek: consensus number = infinite will always return the value of the first enqueuer Question When we know a class doesn’t implement consensus for 2-threads, how can we proof that it doesn’t implement for n>2 threads ? Question When we know a class doesn’t implement consensus for 2-threads, how can we proof that it doesn’t implement for n>2 threads ? Assume it does: Wait-free property: Hence should work if all expect for two out of n threads die -> should still come to a correct Consensus bc as the protocol is wait-free it should work even when threads die. So let all expect for n-2 thread be descheduled/dead ->As wait-free still works for the two. Contradiction. Wrap up& exercise sheet This week’s exercise is about consensus & proofs I can really recommend the book for consensus -> detailed but not too much ! Exam TaskExam TaskExam TaskExam TaskTransactional memory We often talked about the issues of locks and also of optimistic synchronization lock-free -> often very complex (f.eg queue) , alternative solution ? Transactional memory We often talked about the issues of locks and also of optimistic synchronization Idea: just define WHAT we want to have atomic and we don’t care about HOW now CS is called a “transaction” Transactional memory We often talked about the issues of locks and also of optimistic synchronization Idea: just define WHAT we want to have atomic and we don’t care about HOW System should decide how to execute it: software, hardware, mix ? declarative approach Transactional memory We often talked about the issues of locks and also of optimistic synchronization Idea: just define WHAT we want to have atomic and we don’t care about HOW System should decided how to execute it: software, hardware, mix ? declarative approach we have software & hardware transaction memory Transactional memory Transaction is atomic: commits = all changes applied abort = no changes applied ->STM.retry like “wait” Transactional memory Transaction is atomic: commits = all changes applied abort = no changes applied ->STM.retry like “wait” Software TM & Hardware TM Transactional memory Transaction is atomic: commits = all changes applied abort = no changes applied ->STM.retry like “wait” Software TM & Hardware TM No special hardware needed Flexible Transactional memory Transaction is atomic: commits = all changes applied abort = no changes applied ->STM.retry like “wait” Software TM & Hardware TM No special hardware needed Flexible faster/performance but needs special hardware support Scala STM in Java One implementation of STM in Java Scala STM in Java One implementation of STM in Java all the variables you want to modify in the transaction -> declare them special Scala STM in Java One implementation of STM in Java Scala STM in Java Wrap what we want atomically in an atomic block Scala STM in JavaTaskTaskTaskExam TaskExam TaskExam TaskExam Task Personal exam tips These steem from my own experience and have nothing to do with official exam info etc. I also cannot promise anything as we are not involved in the exam process ! Walk through exam Just some personal tips and typically tricks for the exam added 1-3 scale on how “hard” it is the get these points & if you can easily practise and get these points 1:: “easy” points in terms of you should get them as they are easier than other tasks but good points 2:: for the effort they give accurate points, “ fair exam questions not to easy not to hard” 3:: put in more effort for in comparison little points Walk through exam Amdahl vs. Gustafons: fixed time vs fixed workload -> look for hints in the text to tell you which to apply Know the formulas (either learn off by heart or really know how to derive them(! I would do that) Know how to solve the formula for every variable -> f.eg given p and f solve for S etc. Know how the formulas behave in the limit Amdahl& Gustafson are not opposites -> different perspective on a topic Walk through exam Amdahl vs. Gustafons: fixed time vs fixed workload -> look for hints in the text to tell you which to apply Know the formulas (either learn off by heart or really know how to derive them(! I would do that) Know how to solve the formula for every variable -> f.eg given p and f solve for S etc. Know how the formulas behave in the limit Amdahl& Gustafson are not opposites -> different perspective on a topic Calculate clean at the exam& shorten your results ! Double check 1/3 Walk through exam balanced/ unbalanced Do I know how many elements to process or is it in the limit ? Unbalanced -> already know that latency is unbounded etc. Throughput& latency formulas one useful formula for latency: Walk through exam balanced/ unbalanced Do I know how many elements to process or is it in the limit ? Unbalanced -> already know that latency is unbounded etc. Throughput& latency formulas one useful formula for total time: latency + (iterations-1)*throughput (works if we have every stage once, with this you don’t have to draw the whole pipeline) 1/3 First check balanced or not and then answer the rest, practise 12 times& will be fine Walk through exam Implement some communication system using wait/notify Here again : while loops not if-loops and know why ! Walk through exam Practise this & get intuition Implement some communication system using wait/notify Here again : while loops not if-loops and know why ! 2/3Walk through exam start() vs. run() synchronized, notify, notifyAll() (when do we use notify/notifyAll ?), while-loop not if & why !!!! Is synchronized necessary ? -> check if method only gets called from synchronized method anyways be aware -> synchronized -> increases ”sequential part” of your code without synchronization threads interleave any many (unsafe) interleavings possible Walk through exam start() vs. run() synchronized, notify, notifyAll() (when do we use notify/notifyAll ?), while-loop not if & why !!!! Is synchronized necessary ? -> check if method only gets called from synchronized method anyways be aware -> synchronized -> increases ”sequential part” of your code without synchronization threads interleave any many (unsafe) interleavings possible often random task about threads in general -> various formats over the years (1-2)/3Walk through exam Usual divide and conquer structure (base case, compute mid, subtasks and then combine them) If you want all of your task to have data/part of data -> attributes or input to method call Only part you really have to think: when combing the sub-results -> min, max, add, subtract etc. fork() fork(), join(), join() or fork(), compute(), join() both are fine What is a good cutoff ? Why do we even have cutoff ? Pro/cons small vs big cutoff Walk through exam Trees -> span, longest path, execution time Parallel patterns (scan, gather, scatter etc…) Walk through exam Usual divide and conquer structure (base case, compute mid, subtasks and then combine them) If you want all of your task to have data/part of data -> attributes or input to method call Only part you really have to think: when combing the sub-results -> min, max, add, subtract etc. fork() fork(), join(), join() or fork(), compute(), join() both are fine What is a good cutoff ? Why do we even have cutoff ? Pro/cons small vs big cutoff 2/3 (practise then easy 1/3) Walk through exam Know the difference and what implies what, know counterexamples/ histories violating a certain property ->see beginning of this session Always check what kind of object ( stack, queue etc, -> tend to switch sometimes !) Be able to give the definition ( aka define linearizability etc….) Walk through exam Know the difference and what implies what, know counterexamples/ histories violating a certain property ->see beginning of this session Always check what kind of object ( stack, queue etc, -> tend to switch sometimes !) Be able to give the definition ( aka define linearizability etc….) 1/3Walk through exam here often random topics Over all just be comfortable with all the concepts from the second part -> exercise sheets from the semester -> ask yourself what would be a good exam question from that topic 2-3/3Walk through exam There is often an implementation task except for wait/notify & fork/join from 1st part Know how to implement : consensus protocols (TAS, CAS, Queue) Locks using TAS, CAS Spinlocks using TAS, CAS Barriers (with Semaphores and with monitors (wait/notify) Semaphores (via monitors) From wait/notify to lock conditions Apply transactional memory Walk through exam There is often a implementation task form the 2nd part except for wait/notify & fork/join from 1st part Know how to implement consensus protocols (TAS, CAS, Queue) Locks using TAS, CAS Spinlocks using TAS, CAS Barriers (with Semaphores and with monitors (wait/notify) Semaphores (via monitors) From wait/notify to lock conditions Apply transactional memory Go over all the implantations we had in class Walk through examWalk through exam Try to not loose overview First scan the code and think-> what is wrong here& then draw only that part of the diagram Know how to detect deadlock, livelock, starvation-free, mutual exclusion etc. Walk through exam You usually have 120 minutes and 120 points -> this is a big hint on how much time you should spend Overall If you practise enough PPROG will be good J Be sure that you get the “easier” points Even tough you only paper code at the exam, I would suggest at least understanding the code solutions from the semester -> if you can code it, you can do it Fork/join & wait/notify are usually “big point tasks”(at least in the last years) so practise these enough !! For the less predictable tasks -> really get the intuition for parallel execution and what can go wrong + learn of definitions from the course + be able to pseudocode barriers, semaphores etc. When you look at a synchronization method(lock,CAS, monitor etc) Ask yourself, why did we introduce this ? Why was the other one not enough ? What is good/bad ? Be sure you know why we are doing this. BUT we don’t know how the exam will be so these are just tips based on our experience, no guarantees Anyways If you have any questions or a topic is unclear f.eg MPI wasn’t covered in the exercise lessons , let me know. Will be doing the PPROG PVW so you can also come by in person and ask the question during the break If you still want to hand-in some coding tasks -> do it until end of June later I won’t accept. Rock the exam ! I had a really nice time with you guys every week, thank you J Quiz This is the one we did on Wednesday: https://create.kahoot.it/share/pprog14/f41c5b2f-c44d-4fea-901a-061e3c3a52b5 Friday aka big kahoot should be on moodle at some point….","libVersion":"0.3.2","langs":""}