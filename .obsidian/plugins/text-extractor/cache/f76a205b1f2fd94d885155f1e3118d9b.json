{"path":"sem2a/DDCA/VRL/slides/DDCA-L04b-verilog-combinational.pdf","text":"Carnegie Mellon 1 Digital Design and Computer Architecture Mohammad Sadrosadati Frank K. Gürkaynak Adapted from Digital Design and Computer Architecture, David Money Harris & Sarah L. Harris ©2007 Elsevier http://safari.ethz.ch/ddca Verilog for Combinational Circuits Carnegie Mellon 2 What will we learn? ¢ Introduction to Verilog ¢ Combinational Logic in Verilog ¢ Structural Modeling Carnegie Mellon 3 Hardware Description Languages ¢ In the beginning HDLs were developed as a ‘standard way’ of drawing circuit schematics. ¢ Modeled the interface of circuits, described how they were connected ¢ Allowed connections between these modules ¢ Supported some common logic functions § AND OR NOT XOR § Multiplexers Carnegie Mellon 4 Convenient Way of Drawing Schematics Carnegie Mellon 5 Convenient Way of Drawing Schematics ¢ It is standard § Everybody will interpret the schematic the same way ¢ It is not proprietary § HDLs are not tool specific ¢ It is machine readable § It is easier for computers to understand the circuit ¢ Only later on additional benefits were discovered § Simulation and Synthesis Carnegie Mellon 6 Two Hardware Description Languages ¢ Verilog § developed in 1984 by Gateway Design Automation § became an IEEE standard (1364) in 1995 § More popular in US ¢ VHDL (VHSIC Hardware Description Language) § Developed in 1981 by the Department of Defense § Became an IEEE standard (1076) in 1987 § More popular in Europe ¢ In this course we will use Verilog Carnegie Mellon 7 Defining a module ¢ A module is the main building block in Verilog ¢ We first need to declare: § Name of the module § Types of its connections (input, output) § Names of its connections a b y c Verilog Module Carnegie Mellon 8 Defining a module module example (a, b, c, y); input a; input b; input c; output y; // here comes the circuit description endmodule a b y c Verilog Module Carnegie Mellon 9 A question of style module test ( a, b, y ); input a; input b; output y; endmodule module test ( input a, input b, output y ); endmodule The following two codes are identical Carnegie Mellon 10 What if we have busses? input [31:0] a; // a[31], a[30] .. a[0] output [15:8] b1; // b1[15], b1[14] .. b1[8] output [7:0] b2; // b2[7], b2[6] .. b1[0] input clk; // single signal ¢ You can also define multi-bit busses. § [ range_start : range_end ] ¢ Example: Carnegie Mellon 11 Basic Syntax // Single line comments start with a // /* Multiline comments are defined like this */ ¢ Verilog is case sensitive: § SomeName and somename are not the same! ¢ Names cannot start with numbers: § 2good is not a valid name ¢ Whitespace is ignored Carnegie Mellon 12 Good Practices ¢ Develop/use a consistent naming style ¢ Use MSB to LSB ordering for busses (little-endian) § Try using “a[31:0]” and not “a[0:31]” ¢ Define one module per file § Makes managing your design hierarchy easier ¢ Use a file name that equals module name § i.e. module TryThis is defined in a file called TryThis.v Carnegie Mellon 13 There are Two Main Styles of HDL ¢ Structural § Describe how modules are interconnected § Each module contains other modules (instances) § … and interconnections between these modules § Describes a hierarchy ¢ Behavioral § The module body contains functional description of the circuit § Contains logical and mathematical operators ¢ Practical circuits would use a combination of both Carnegie Mellon 14 Structural HDL: Instantiating a Module Carnegie Mellon 15 Structural HDL Example module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Module Definitions Carnegie Mellon 16 Structural HDL Example module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Module Definitions Carnegie Mellon 17 Structural HDL Example module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Wire definitions Carnegie Mellon 18 Structural HDL Example module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; // instantiate small once small i_first ( .A(A), .B(SEL), .Y(n1) ); endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Instantiate first module Carnegie Mellon 19 Structural HDL Example module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; // instantiate small once small i_first ( .A(A), .B(SEL), .Y(n1) ); // instantiate small second time small i2 ( .A(n1), .B(C), .Y(Y) ); endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Instantiate second module Carnegie Mellon 20 Structural HDL Example module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; // alternative small i_first ( A, SEL, n1 ); /* Shorter instantiation, pin order very important */ // any pin order, safer choice small i2 ( .B(C), .Y(Y), .A(n1) ); endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Short Instantiation Carnegie Mellon 21 What Happens with HDL code? ¢ Automatic Synthesis § Modern tools are able to map a behavioral HDL code into gate- level schematics § They can perform many optimizations § … however they can not guarantee that a solution is optimal § Most common way of Digital Design these days ¢ Simulation § Allows the behavior of the circuit to be verified without actually manufacturing the circuit § Simulators can work on behavioral or gate-level schematics Carnegie Mellon 22 Behavioral HDL: Defining Functionality module example (a, b, c, y); input a; input b; input c; output y; // here comes the circuit description assign y = ~a & ~b & ~c | a & ~b & ~c | a & ~b & c; endmodule Carnegie Mellon 23 Behavioral HDL: Synthesis Results un5_y un8_y y yc b a Carnegie Mellon 24 Behavioral HDL: Simulating the Circuit Carnegie Mellon 25 Bitwise Operators module gates(input [3:0] a, b, output [3:0] y1, y2, y3, y4, y5); /* Five different two-input logic gates acting on 4 bit busses */ assign y1 = a & b; // AND assign y2 = a | b; // OR assign y3 = a ^ b; // XOR assign y4 = ~(a & b); // NAND assign y5 = ~(a | b); // NOR endmodule Carnegie Mellon 26 Bitwise Operators: Synthesis Results Carnegie Mellon 27 Reduction Operators module and8(input [7:0] a, output y); assign y = &a; // &a is much easier to write than // assign y = a[7] & a[6] & a[5] & a[4] & // a[3] & a[2] & a[1] & a[0]; endmodule Carnegie Mellon 28 Reduction Operators: assign y = &a; Carnegie Mellon 29 Conditional Assignment module mux2(input [3:0] d0, d1, input s, output [3:0] y); assign y = s ? d1 : d0; // if (s) then y=d1 else y=d0; endmodule ¢ ? : is also called a ternary operator as it operates on three inputs: § s § d1 § d0. Carnegie Mellon 30 Conditional Assignment: y = s ? d1: d0; Carnegie Mellon 31 More Conditional Assignments module mux4(input [3:0] d0, d1, d2, d3 input [1:0] s, output [3:0] y); assign y = s[1] ? ( s[0] ? d3 : d2) : ( s[0] ? d1 : d0); // if (s1) then // if (s0) then y=d3 else y=d2 // else // if (s0) then y=d1 else y=d0 endmodule Carnegie Mellon 32 Even More Conditional Assignments module mux4(input [3:0] d0, d1, d2, d3 input [1:0] s, output [3:0] y); assign y = (s == 2’b11) ? d3 : (s == 2’b10) ? d2 : (s == 2’b01) ? d1 : d0; // if (s = “11” ) then y= d3 // else if (s = “10” ) then y= d2 // else if (s = “01” ) then y= d1 // else y= d0 endmodule Carnegie Mellon 33 How to Express numbers ? N’Bxx 8’b0000_0001 ¢ (N) Number of bits § Expresses how many bits will be used to store the value ¢ (B) Base § Can be b (binary), h (hexadecimal), d (decimal), o (octal) ¢ (xx) Number § The value expressed in base, apart from numbers it can also have X and Z as values. § Underscore _ can be used to improve readability Carnegie Mellon 34 Number Representation in Verilog Verilog Stored Number Verilog Stored Number 4’b1001 1001 4’d5 0101 8’b1001 0000 1001 12’hFA3 1111 1010 0011 8’b0000_1001 0000 1001 8’o12 00 001 010 8’bxX0X1zZ1 XX0X 1ZZ1 4’h7 0111 ‘b01 0000 .. 0001 12’h0 0000 0000 0000 Carnegie Mellon 35 What have seen so far: ¢ Describing structural hierarchy with Verilog § Instantiate modules in an other module ¢ Writing simple logic equations § We can write AND, OR, XOR etc ¢ Multiplexer functionality § If … then … else ¢ We can describe constants ¢ But there is more: Carnegie Mellon 36 Precedence of operations in Verilog ~ NOT *, /, % mult, div, mod +, - add,sub <<, >> shift <<<, >>> arithmetic shift <, <=, >, >= comparison ==, != equal, not equal &, ~& AND, NAND ^, ~^ XOR, XNOR |, ~| OR, NOR ?: ternary operator Highest Lowest Carnegie Mellon 37 Example: Comparing two numbers module MyXnor (input a, b, output z); assign z = ~(a ^ b); //not XOR endmodule module MyAnd (input a, b, output z); assign z = a & b; // AND endmodule An XNOR gate An AND gate Carnegie Mellon 38 Example: Comparing Two Numbers module compare (input a0, a1, a2, a3, b0, b1, b2, b3, output eq); wire c0, c1, c2, c3, c01, c23; MyXnor i0 (.A(a0), .B(b0), .Z(c0) ); // XNOR MyXnor i1 (.A(a1), .B(b1), .Z(c1) ); // XNOR MyXnor i2 (.A(a2), .B(b2), .Z(c2) ); // XNOR MyXnor i3 (.A(a3), .B(b3), .Z(c3) ); // XNOR MyAnd haha (.A(c0), .B(c1), .Z(c01) ); // AND MyAnd hoho (.A(c2), .B(c3), .Z(c23) ); // AND MyAnd bubu (.A(c01), .B(c23), .Z(eq) ); // AND endmodule Carnegie Mellon 39 Example: Comparing Two Numbers module compare (input a0, a1, a2, a3, b0, b1, b2, b3, output eq); wire c0, c1, c2, c3, c01, c23; MyXnor i0 (.A(a0), .B(b0), .Z(c0) ); // XNOR MyXnor i1 (.A(a1), .B(b1), .Z(c1) ); // XNOR MyXnor i2 (.A(a2), .B(b2), .Z(c2) ); // XNOR MyXnor i3 (.A(a3), .B(b3), .Z(c3) ); // XNOR assign c01 = c0 & c1; assign c23 = c2 & c3; assign eq = c01 & c23; endmodule Carnegie Mellon 40 Example: Comparing Two Numbers module compare (input a0, a1, a2, a3, b0, b1, b2, b3, output eq); wire c0, c1, c2, c3; MyXnor i0 (.A(a0), .B(b0), .Z(c0) ); // XNOR MyXnor i1 (.A(a1), .B(b1), .Z(c1) ); // XNOR MyXnor i2 (.A(a2), .B(b2), .Z(c2) ); // XNOR MyXnor i3 (.A(a3), .B(b3), .Z(c3) ); // XNOR assign eq = c0 & c1 & c2 & c3; endmodule Carnegie Mellon 41 Example: Comparing Two Numbers module compare (input a0, a1, a2, a3, b0, b1, b2, b3, output eq); wire [3:0] c; // bus definition MyXnor i0 (.A(a0), .B(b0), .Z(c[0]) ); // XNOR MyXnor i1 (.A(a1), .B(b1), .Z(c[1]) ); // XNOR MyXnor i2 (.A(a2), .B(b2), .Z(c[2]) ); // XNOR MyXnor i3 (.A(a3), .B(b3), .Z(c[3]) ); // XNOR assign eq = &c; // short format endmodule Carnegie Mellon 42 Example: Comparing Two Numbers module compare (input [3:0] a, input [3:0] b, output eq); wire [3:0] c; // bus definition MyXnor i0 (.A(a[0]), .B(b[0]), .Z(c[0]) ); // XNOR MyXnor i1 (.A(a[1]), .B(b[1]), .Z(c[1]) ); // XNOR MyXnor i2 (.A(a[2]), .B(b[2]), .Z(c[2]) ); // XNOR MyXnor i3 (.A(a[3]), .B(b[3]), .Z(c[3]) ); // XNOR assign eq = &c; // short format endmodule Carnegie Mellon 43 Example: Comparing Two Numbers module compare (input [3:0] a, input [3:0] b, output eq); wire [3:0] c; // bus definition assign c = ~(a ^ b); // XNOR assign eq = &c; // short format endmodule Carnegie Mellon 44 Example: Comparing Two Numbers module compare (input [3:0] a, input [3:0] b, output eq); assign eq = (a == b) ? 1 : 0; // really short endmodule Carnegie Mellon 45 What is the BEST way of writing Verilog ¢ Quite simply IT DOES NOT EXIST! ¢ Code should be easy to understand § Sometimes longer code is easier to comprehend ¢ Hierarchy is very useful § In the previous example it did not look like that, but for larger designs it is indispensible ¢ Try to stay closer to hardware § After all the goal is to design hardware Carnegie Mellon 46 Parameterized Modules module mux2 #(parameter width = 8) // name and default value (input [width-1:0] d0, d1, input s, output [width-1:0] y); assign y = s ? d1 : d0; endmodule ¢ We can pass parameters to a module Carnegie Mellon 47 Parameterized Modules: Instantiating // If parameter is not given, default is assumed (here 8) mux2 i_mux (d0, d1, s, out); // The same module with 12-bit bus width: mux2 #(12) i_mux_b (d0, d1, s, out); // More verbose version: mux2 #(.width(12)) i_mux_b (.d0(d0), .d1(d1), .s(s), .out(out)); module mux2 #(parameter width = 8) // name and default value (input [width-1:0] d0, d1, input s, output [width-1:0] y); assign y = s ? d1 : d0; endmodule Carnegie Mellon 48 Manipulating Bits // You can assign partial busses wire [15:0] longbus; wire [7:0] shortbus; assign shortbus = longbus[12:5]; // Concatenating is by {} assign y = {a[2],a[1],a[0],a[0]}; // Possible to define multiple copies assign x = {a[0], a[0], a[0], a[0]} assign y = { 4{a[0]} } Carnegie Mellon 49 Z floating output module tristate(input [3:0] a, input en, output [3:0] y); assign y = en ? a : 4'bz; endmodule y_1[3:0] y[3:0] [3:0] en a[3:0] [3:0] [3:0][3:0] Carnegie Mellon 50 Truth Table for AND with Z and X & A 0 1 Z X B 0 0 0 0 0 1 0 1 X X Z 0 X X X X 0 X X X Carnegie Mellon 51 What About Timing ? ‘timescale 1ns/1ps module simple (input a, output z1, z2); assign #5 z1 = ~a; // inverted output after 5ns assign #9 z2 = a; // output after 9ns endmodule ¢ It is possible to define timing relations in Verilog § These are ONLY for Simulation § They CAN NOT be synthesized § They are used for modeling delays in simulation Carnegie Mellon 52 Next Steps ¢ We have seen an overview of Verilog ¢ Discussed behavioral and structural modeling ¢ Showed combinational logic constructs Still to come: (later) ¢ Sequential circuit description in Verilog ¢ Developing testbenches for simulation","libVersion":"0.3.2","langs":""}