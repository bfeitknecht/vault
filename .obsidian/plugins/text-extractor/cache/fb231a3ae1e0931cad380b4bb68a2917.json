{"path":"sem4/FMFP/PV/exams/FMFP-finals/FMFP-HS21.pdf","text":"Formal Methods and Functional Programming Repeat Exam, 2022 February 14, 2022, 9:00 – 12:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 33 pages; the back page of this booklet is page 33. After the exam begins, check that your exam papers are complete (4 assignments for the FP part, 4 assignments and 2 pages of background material for the FM part). 2. You may complete the assignments in any order. We recommend spending roughly half of your time on each of the two parts of the exam. 3. Only write on the exam paper and extra paper sheets which are given by the assistants. Do not take any of this paper out of the exam: submit it all. 4. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 5. For the FP part of the exam, you may use any functions from the Haskell Prelude in your solutions (without giving their deﬁnitions), unless speciﬁed otherwise. You also may use any function from one subproblem to solve the subsequent subproblems, even if you have not provided a deﬁnition for the function itself. 6. Write clearly in the sense of logic, language, and readability. Label all rule applications in your derivation trees. The clarity of your arguments and explanations aﬀects your grade. 7. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 8 ∑ Max 7 25 10 8 6 23 12 9 100 Points Part I Functional Programming Formal Methods and Functional Programming, Repeat Exam, 2022 3 Assignment 1: Types and Evaluation (7 Points) Task 1.A (3 Points) Recall the following functions from the Haskell Prelude library. elem :: Eq a => a -> [a] -> Bool map :: (a -> b) -> [a] -> [b] zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] Determine whether the following expressions are well-typed or not, and if they are, state the most general type. No other justiﬁcation is needed. i) zipWith elem ii) \\x -> map x [x] iii) \\x y z -> (x z) (y z) Task 1.B (4 Points) Evaluate the following expression using both the lazy and the eager evaluation strategy. Show every intermediate step. (λx. λy. x) y (λz. (λx. x) z) Formal Methods and Functional Programming, Repeat Exam, 2022 4 This page is intentionally left blank. Formal Methods and Functional Programming, Repeat Exam, 2022 5 Assignment 2: Implementing Resolution (25 Points) Hints: Recall that you may use the functions deﬁned in one task to solve other tasks even if you have not provided a deﬁnition. On page 11, you can ﬁnd type signatures of functions you may ﬁnd helpful. Satisﬁability of propositional logic formulas in conjunctive normal form (CNF) can be decided via an algorithm that uses resolution. In this task, you will implement this algorithm step-by-step. A CNF formula is a conjunction of clauses, which are disjunctions of literals. A literal is either a propositional variable or a negated propositional variable. In other words, a CNF formula is of the form (l1,1 ∨ · · · l1,n1) ∧ · · · ∧ (lm,1 ∨ · · · ∨ lm,nm) where the li,j are literals. The following is an example of a CNF formula with propositional variables a, b, c, d: (a ∨ b) ∧ (¬b ∨ c ∨ d). We represent CNF formulas using three types: data Literal a = Prop a | NotProp a deriving Eq type Clause a = [Literal a] type CNF a = [Clause a] The type a represents propositional variables. Note that you can use (==) and (/=) on Literal a if the type a is an instance of the Eq type class. The above example could be represented using Char as variables: [[Prop ’a’, Prop ’b’], [NotProp ’b’, Prop ’c’, Prop ’d’]] :: CNF Char Task 2.A (5 Points) Implement basic functions on literals and clauses. 1. Implement the function var that returns the variable in a literal. For example: > var (Prop ’a’) ’a’ var :: Literal a -> a Formal Methods and Functional Programming, Repeat Exam, 2022 6 2. Implement the function neg that negates a literal. For example: > neg (NotProp ’a’) Prop ’a’ neg :: Literal a -> Literal a 3. Implement the function taut that determines whether a clause is a tautology. A clause is a tautology if and only if it contains both a literal and its negation. For example: > taut [Prop ’x’, NotProp ’y’, Prop ’z’, NotProp ’x’] True > taut [Prop ’x’, NotProp ’y’, Prop ’z’, Prop ’x’] False taut :: Eq a => Clause a -> Bool Assignment 2 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 7 In the following, you will implement a satisﬁability checker for CNF formulas using resolution. The resolution algorithm is based on the following inference rule for propositional logic: l1 ∨ · · · ∨ c ∨ · · · ∨ lm k1 ∨ · · · ∨ ¬c ∨ · · · ∨ kn l1 ∨ · · · ∨ lm ∨ k1 ∨ · · · ∨ kn We call c and ¬c complementary literals and the variable c the resolution variable. Task 2.B (4 Points) Implement the function complVar returning a list of all resolution variables in two clauses. If no such pair of complementary literals exists, the function should return an empty list. The returned list may contain duplicates. For example: > complVar [Prop ’x’, NotProp ’y’] [Prop ’y’] [’y’] > complVar [Prop ’x’, NotProp ’y’] [NotProp ’y’] [] complVar :: Eq a => Clause a -> Clause a -> [a] Assignment 2 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 8 Task 2.C (4 Points) Implement the function resolve, which, given two clauses and a variable, applies the resolution rule to the two clauses. You may assume that the given variable is a resolution variable of these clauses. More precisely, this function should remove all literals in the clauses containing the given resolution variable and merge the resulting lists. For example: > resolve [Prop ’x’, Prop ’y’] [NotProp ’z’, NotProp ’x’] ’x’ [Prop ’y’, NotProp ’z’] resolve :: Eq a => Clause a -> Clause a -> a -> Clause a Assignment 2 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 9 Task 2.D (8 Points) Implement the function step which, given a CNF formula, tries to apply the resolution rule once. This function should behave as follows. If there is a pair of clauses containing complementary literals, it chooses exactly one resolution variable and applies the resolution rule using the function resolve. The two clauses are replaced by the new clause. All other clauses are returned unchanged. It does not matter which pair of clauses nor which variable is chosen. If there is no pair containing complementary literals, the function should return the formula unchanged. For example: > step [[Prop ’x’, Prop ’y’], [Prop ’y’], [Prop ’z’, NotProp ’x’]] [[Prop ’y’], [Prop ’y’, Prop ’z’]] Note that, when applying the resolution rule, the order of the elements in each list does not matter. step :: Eq a => CNF a -> CNF a Assignment 2 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 10 Task 2.E (4 Points) Implement the function sat performing these four steps: – Remove all tautological clauses from the CNF formula. – Try to apply the resolution rule once (using step). – If the new formula contains a contradictory clause, return False. To determine whether a clause is contradictory, check whether the clause is empty. – If the new formula is equal to the original formula, return True. Otherwise apply sat recursively on the new formula. sat :: Eq a => CNF a -> Bool Formal Methods and Functional Programming, Repeat Exam, 2022 11 Helpful Functions Here are some functions that you may ﬁnd useful. map :: (a -> b) -> [a] -> [b] filter :: (a -> Bool) -> [a] -> [a] elem :: Eq a => a -> [a] -> Bool null :: [a] -> Bool Formal Methods and Functional Programming, Repeat Exam, 2022 12 Assignment 3: Natural Deduction (10 Points) Recall the following rules for natural deduction in ﬁrst-order intuitionistic logic: Γ, A ⊢ A axiom Γ, A ⊢ B Γ ⊢ A → B →I Γ ⊢ A → B Γ ⊢ A Γ ⊢ B →E Γ ⊢ ﬀ Γ ⊢ A ﬀ E Γ, A ⊢ ﬀ Γ ⊢ ¬A ¬I Γ ⊢ ¬A Γ ⊢ A Γ ⊢ B ¬E Γ ⊢ A Γ ⊢ B Γ ⊢ A ∧ B ∧I Γ ⊢ A ∧ B Γ ⊢ A ∧EL Γ ⊢ A ∧ B Γ ⊢ B ∧ER Γ ⊢ A Γ ⊢ A ∨ B ∨IL Γ ⊢ B Γ ⊢ A ∨ B ∨IR Γ ⊢ A ∨ B Γ, A ⊢ C Γ, B ⊢ C Γ ⊢ C ∨E Γ ⊢ A Γ ⊢ ∀x. A ∀I ∗ Γ ⊢ ∀x. A Γ ⊢ A[x/t] ∀E Γ ⊢ A[x/t] Γ ⊢ ∃x. A ∃I Γ ⊢ ∃x. A Γ, A ⊢ B Γ ⊢ B ∃E ∗∗ Side conditions: (∗) x is not free in any formula in Γ, (∗∗) x is neither free in B nor in any formula in Γ. Prove using the above rules that (¬p(x) ∨ (∃z. q(z)) ) → ¬ ( ∀y. p(x) ∧ ¬q(y) ) is a tautology, where p and q are unary predicate symbols. Give a complete derivation tree and label each inference step with the name of the corresponding rule. Hint: Introduce abbreviations Γi for the left-hand sides of sequents. You may break the tree apart into multiple subtrees. Formal Methods and Functional Programming, Repeat Exam, 2022 13 This page is intentionally left blank. Formal Methods and Functional Programming, Repeat Exam, 2022 14 Assignment 4: Structural Induction on Lists (8 Points) Consider the two datatypes data Tree a = Leaf a | Node (Tree a) (Tree a) data Dir = L | R and the function: child :: Tree a -> Dir -> Tree a child (Leaf x) _ = Leaf x --c.1 child (Node tl tr) L = tl --c.L child (Node tl tr) R = tr --c.R We use a list of directions (of type [Dir]) to walk through a tree: walk :: Tree a -> [Dir] -> Tree a walk t [] = t --w.1 walk t (d:ds) = walk (child t d) ds --w.2 Finally, recall the following function on lists : (++) :: [a] -> [a] -> [a] [] ++ ys = ys --app.1 (x:xs) ++ ys = x : (xs ++ ys) --app.2 Using the function deﬁnitions above, show that for all ds, ds’::[Dir] and all t::Tree a the equality walk (walk t ds) ds’ = walk t (ds ++ ds’) holds. Formal Methods and Functional Programming, Repeat Exam, 2022 15 This page is intentionally left blank. Part II Formal Methods Formal Methods and Functional Programming, Repeat Exam, 2022 17 Assignment 5: Small-Step Semantics (6 Points) Consider an extension of the IMP programming language with the following statements: raise e try s1 catch x with s2 end The raise statement raises a numeric exception, which interrupts the normal execution of the program and passes the control to the nearest enclosing try-catch block. When an exception is caught, its numeric value is stored in the variable x and the program executes s2 to handle the exception. After that, or if no exception is raised during the execution of s1, the program continues executing the statements after the try-catch block. Formally, the structural operational semantics is partially described by the following derivation rules: (RaiseSOS) ⟨raise e;s, σ⟩ →1 ⟨raise e, σ⟩ ⟨s1, σ⟩ →1 σ′ (TryEndSOS) ⟨try s1 catch x with s2 end, σ⟩ →1 σ′ (TryRaiseSOS) ⟨try raise e catch x with s2 end, σ⟩ →1 ⟨s2, σ[x ↦→ A[[e]]σ]⟩ ⟨s1, σ⟩ →1 ⟨s3, σ′⟩ (TryExecSOS) ⟨try s1 catch x with s2 end, σ⟩ →1 ⟨try s3 catch x with s2 end, σ′⟩ Note from TryRaiseSOS that the x used to store the exceptions is not a fresh local variable. x aliases any other syntactically equivalent variable used in the program. Task 5.A (4 Points) Consider the following IMP statement s: try (while true do raise a + b end) catch a with b := a − b end Let σ be a state such that σ(a) = 3 and σ(b) = 2. Prove using the structural operational semantics that there is a state σ′ such that ⟨s, σ⟩ → ∗ 1 σ′. Provide the complete derivation sequence, as well as the derivation tree for the ﬁrst step. You may use the shorthand sw ≡ “while true do raise a + b end” in your solution. Assignment 5 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 18 This page is intentionally left blank. Assignment 5 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 19 Task 5.B (2 Points) Deﬁne s1, s2 and x without using while or conditional statements, such that for any initial state σ the execution of ⟨try s1 catch x with s2 end, σ⟩ reaches a stuck conﬁguration after exactly two small-step transitions. Formal Methods and Functional Programming, Repeat Exam, 2022 20 Assignment 6: Big-Step Semantics (23 Points) In this assignment, we consider an extension to IMP that adds a ﬂip-ﬂop statement. The ﬂip-ﬂop statement consists of two branches, which are executed in a round-robin fashion every time the statement is reached: • First time statement is reached: ﬁrst branch is executed. • Second time statement is reached: second branch is executed. • Third time statement is reached: ﬁrst branch is executed. • Fourth time statement is reached: second branch is executed. • . . . A program can contain multiple ﬂip-ﬂop statements, which may be nested. each ﬂip-ﬂop statement in the program is given a unique number. The concrete syntax of the ﬂip-ﬂop statement is then flip(i) s0 flop s1 end, where i is the unique number of that ﬂip-ﬂop statement. As an example, the following program calculates the ﬁrst 11 Fibonacci numbers: a := 0; b := 1; n := 0; while n < 10 do flip(0) a := a + b flop b := a + b end; n := n + 1 end The state σ at the beginning of each iteration of the loop is as follows: iteration σ(n) σ(a) σ(b) 1 0 0 1 2 1 1 1 3 2 1 2 4 3 3 2 5 4 3 5 6 5 8 5 7 6 8 13 8 7 21 13 9 8 21 34 10 9 55 34 Formal Methods and Functional Programming, Repeat Exam, 2022 21 The unique ﬂip-ﬂop numbers are used to construct variable identiﬁers storing the ﬂip-ﬂop state. As an example, flip(42) s0 flop s1 end corresponds to the variable f42. The ﬂip-ﬂop variables are distinct from any other variable found in the program. The operational semantics for the ﬂip-ﬂop statements is as follows: ⟨s1, σ⟩ → σ′ (FlipNS) ⟨flip(i) s1 flop s2 end, σ⟩ → σ′[fi ↦→ 1] if σ(fi) = 0 ⟨s2, σ⟩ → σ′ (FlopNS) ⟨flip(i) s1 flop s2 end, σ⟩ → σ′[fi ↦→ 0] if σ(fi) ̸= 0 The deﬁnition of IMP states is not modiﬁed. As usual, the initial state σzero assigns 0 to all variables, including our ﬂip-ﬂop variables fi. Task 6.A (8 Points) Recall the operational semantics for non-deterministic choice: ⟨s, σ⟩ → σ′ (ND1NS) ⟨s s′, σ⟩ → σ′ ⟨s′, σ⟩ → σ′ (ND2NS) ⟨s s′, σ⟩ → σ′ For statements P1 and P2 below, say whether the statement holds or not. If the statement holds, prove it. If it does not, provide a counterexample and a brief explanation of why it is a counterexample. You may assume fi ̸∈ F V (s1) and fi ̸∈ F V (s2). You may use any lemma that was proven in a lecture or in an exercise. P1 ≡ ∀σ, σ′, s1, s2, i. (⊢ ⟨flip(i) s1 flop s2 end, σ⟩ → σ′) ⇒ (⊢ ⟨s1 s2, σ⟩ → σ′[fi ↦→ σ(fi)]) P2 ≡ ∀σ, σ′, s1, s2, i. (⊢ ⟨s1 s2, σ⟩ → σ′) ⇒ (∃x. ⊢ ⟨flip(i) s1 flop s2 end, σ⟩ → σ′[fi ↦→ x]) Assignment 6 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 22 This page is intentionally left blank. Assignment 6 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 23 This page is intentionally left blank. Assignment 6 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 24 Task 6.B (15 Points) Consider the statements sw and sf below: sw ≡ while n < k do if f0 = 0 then s1 else s2 end; f0 := 1 − f0; n := n + 1 end sf ≡ while n < k do flip(0) s1 flop s2 end; n := n + 1 end In general, programs may not contain any fi variable. In particular, s1 and s2 do not read or write the variable f0. However, we assume that the program sw is allowed to read and write the variable f0. Show that sw and sf are semantically equivalent in one direction assuming σ(f0) ∈ {0, 1} in the initial state, that is: ∀σ, σ′. σ(f0) ∈ {0, 1} ∧ (⊢ ⟨sw, σ⟩ → σ′) ⇒ (⊢ ⟨sf , σ⟩ → σ′) In your solution, you may use the following syntax shorthands: I ≡ if f0 = 0 then s1 else s2 end X ≡ f0 := 1 − f0 F ≡ flip(0) s1 flop s2 end A ≡ n := n + 1 Assignment 6 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 25 This page is intentionally left blank. Assignment 6 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 26 This page is intentionally left blank. Assignment 6 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 27 Assignment 7: Axiomatic Semantics (12 Points) Consider the following IMP statement s: p := 0; q := n; while p < q do p := p + 1; q := q - 1 end Construct a proof outline that proves the following Hoare triple: { n ≥ 0 ∧ n = N } s { ⇓ p = ⌈ N 2 ⌉ } Clearly state which loop invariant and variant you are using in your proof outline. Invariant: Variant: Formal Methods and Functional Programming, Repeat Exam, 2022 28 This page is intentionally left blank. Formal Methods and Functional Programming, Repeat Exam, 2022 29 Assignment 8: Modelling (9 Points) For your birthday, your friends have prepared a delicious cake. On the cake are ﬁve lit candles in a circle, and your mission is to extinguish them all, by blowing on them. Blowing on a lit candle eﬀectively extinguishes this candle, but it also aﬀects the two neighbouring candles: Any neighbouring candle that was lit before becomes extinguished, and any neighbouring candle that was extinguished before relights. Put another way, the candles follow these special rules: 1. You can only blow on a lit candle. 2. Blowing on a lit candle extinguishes it. 3. The two neighbouring candles switch states: If a neighbouring candle was unlit, then it becomes lit, and vice-versa. The goal of this assignment is to model the aforementioned scenario in Promela and use a model checker to ﬁnd out whether it is possible to extinguish all candles. And if it is possible, to ﬁnd out the minimum number of times you have to blow to extinguish all candles. Consider the following partial Promela model: #define n 5 bool success = 0 inline blow() { /* implement me in Task 8.A */ } init { do :: success -> /* implement me in Task 8.B */ :: else -> blow() od } Task 8.A (6 Points) Provide an appropriate implementation for the blow() macro. The blow() macro should model a blow on one candle, and then set the success ﬂag to 1 if all candles are extinguished after the blow. You may introduce additional variables and macros to do so. Your model should reﬂect the states of the candles, i.e., whether they are lit or unlit. Brieﬂy explain your solution. Assignment 8 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 30 Assignment 8 continues on the next page. Formal Methods and Functional Programming, Repeat Exam, 2022 31 Task 8.B (1 Point) Can we use a model checker (such as Spin) to verify whether there is a way to extinguish all the candles? If your answer is “yes”, brieﬂy explain the necessary additions or changes to the code of the Promela model, and why your approach works. If your answer is “no”, brieﬂy explain why it is not possible. Note: You may solve this task without having solved Task 8.A by assuming appropriate implementations for the blow() macro. Task 8.C (2 Points) Assume that there is a way to extinguish all the candles. We would like to ﬁnd a strategy (potentially invoking the model checker multiple times) that minimizes the number of steps, that is the number of times we have to blow on a candle. Can we use a model checker (such as Spin) to ﬁnd if extinguishing all candles is possible in at most k steps? If your answer is “yes”, brieﬂy explain your approach and how you would modify the code of the Promela model. If your answer is “no”, write “no” and brieﬂy explain why. Note: You may solve this task without having solved Task 8.A and Task 8.B, by assuming appropriate implementations for the blow() macro. Formal Methods and Functional Programming, Repeat Exam, 2022 32 Syntax and Semantics of IMP Big-Step Semantics (SkipN S) ⟨skip, σ⟩ → σ (AssN S) ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ → σ′ ⟨s2, σ′⟩ → σ′′ (SeqN S) ⟨s1;s2, σ⟩ → σ′′ ⟨s1, σ⟩ → σ′ (IfTN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = tt ⟨s2, σ⟩ → σ′ (IfFN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = ﬀ ⟨s, σ⟩ → σ′ ⟨while b do s end, σ′⟩ → σ′′ (WhTN S) ⟨while b do s end, σ⟩ → σ′′ if B[[b]]σ = tt (WhFN S) ⟨while b do s end, σ⟩ → σ if B[[b]]σ = ﬀ Syntax The statements (Stm) of the programming language IMP are given by the grammar s ::= skip | x := e | s;s | if b then s else s end | while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). The free variables FV(s) of a statement s are deﬁned as FV(skip) = ∅ FV(x:=e) = {x} ∪ FV(e) FV(s1;s2) = FV(s1) ∪ FV(s2) FV(if b then s1 else s2 end) = FV(b) ∪ FV(s1) ∪ FV(s2) FV(while b do s end) = FV(b) ∪ FV(s) Formal Methods and Functional Programming, Repeat Exam, 2022 33 Small-Step Semantics (SkipSOS) ⟨skip, σ⟩ →1 σ (AssSOS) ⟨x := e, σ⟩ →1 σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ →1 σ′ (Seq1SOS) ⟨s1;s2, σ⟩ →1 ⟨s2, σ′⟩ ⟨s1, σ⟩ →1 ⟨s′ 1, σ′⟩ (Seq2SOS) ⟨s1;s2, σ⟩ →1 ⟨s′ 1;s2, σ′⟩ (IfTSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s1, σ⟩ if B[[b]]σ = tt (IfFSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s2, σ⟩ if B[[b]]σ = ﬀ (WhileSOS) ⟨while b do s end, σ⟩ →1 ⟨if b then s; while b do s end else skip end, σ⟩ Axiomatic Semantics (Partial Correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ↦→ e] } x := e { P } { P } s1 { R } { R } s2 { Q } (SeqAx) { P } s1;s2 { Q } { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P ′ } s { Q′ } (ConsAx) { P } s { Q } if P ⊨ P′ and Q′ ⊨ Q Axiomatic Semantics (Total Correctness) Rules are as for partial correctness above, except for the following rule, which replaces WhAx: { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ⊨ 0 ≤ e where Z is a fresh logical variable (not used in P).","libVersion":"0.5.0","langs":""}