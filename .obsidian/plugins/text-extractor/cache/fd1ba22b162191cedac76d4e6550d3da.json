{"path":"sem4/CN/UE/slides/CN-u11-LP.pdf","text":"Computer Networks - Exercise 11 Algorithms, Linear Programming and Probabilistic Techniques ETH Zürich Slides by Paul Ellsiepen & Janic Moser Based on the work of Linus Baumberger & Severin Obrist May 2024 - Algorithms - Shortest Path Problem - Trafﬁc Engineering - Linear Programming - Probabilistic Techniques - Load Balancing - Membership Testing - Trafﬁc Monitoring - Kahoot! - Exercise #11 2 Table of contents Shortest Path Problem 4 Motivation: We want to use the optimal (shortest) path for our trafﬁc Environment: Graph with weighted edges Shortest path Algorithms Runtime (O-notation) Comment Dijkstra (|V| + |E|) * log (|V|) Non-negative weights Bellman-Ford |V| * |E| Distributed BFS |V| + |E| Only for unweighted graph - Latency - Additive - Loss Rate - Not directly additive, but success rate is multiplicative and can be made additive using logarithms - Bandwidth - Not additive: BW of a path is the minimum of the bandwidths of the edges - But still fulﬁlls isotonicity property: - Paths P1 and P2 from A to B; Path P3 from B to C (or C to A) - If P1 is better than P2, then P1 + P3 is better than (or equal to) P2 + P3 5 Weight Criterias A B C P1 P2 P3 A BC P1 P2 P3 Can combine criterias: - Shortest Widest Path (SWP): Optimize for bandwidth ﬁrst, latency second - Widest Shortest Path (WSP): Optimize for latency ﬁrst, bandwidth second But SWP does not fulﬁll the Isotonicity Property! In our example, with SWP: - B-A-T better than B-T - But S-B-T is better than S-B-A-T 6 Weight Criterias SWP example Trafﬁc engineering Network engineers need to consider many things: - How much trafﬁc can the network carry? (Max-Flow) - How reliable is the network? (Min-Cut) Algorithms: Ford-Fulkerson; Edmonds-Karp Really common in practice: - Between customers of an ISP - Between data centers of a company 8 Networking is complex Multiple Sources/Destinations? - Add “fake” source (S)/destination (T) nodes - Now we can use one of the previous algorithms 9 Many possible modiﬁcations Multi-commodity ﬂow (MCF): - Each source wants to send to a speciﬁc destination - Can’t be solved with standard algorithms Linear Programming - Variables: Real values - Flows on edges, distance from the start, … - Constraints: Linear combination of variables (strict inequality not allowed) - Flow on edge ≤ capacity of edge - Objective: Maximize/minimize a linear combination of variables - Maximize total ﬂow, minimize distances, … - Canonical form: - x is a vector of variables (all elements greater or equal 0) - Maximize Θ = c T · x (c is vector of constants) - Constraints in the form A · x ≤ b 11 What is a Linear Program? - Minimization: min Θ ➡ max -Θ - Greater-than constraint: A · x ≥ b ➡ (-A) · x ≤ -b - Equality constraint: A · x = b ➡ A · x ≤ b and (-A) · x ≤ -b - Variables with undeﬁned sign: x i replaced by x i + and x i - so that x = x i + - x i - - A · x ≤ b ➡ [A -A][x + x -] T ≤ b 12 Transformation to canonical form Advantages: - Many problems can be expressed as LP problems - Writing a LP is easier than developing a specialized algorithm - Efﬁcient LP solvers are available - LPs are easily adaptable to variations of a problem whereas specialized algorithms are usually not Disadvantages: - LPs are typically much slower than specialized algorithms (O(n³) rule of thumb, n = #columns in the constraints matrix) 13 Advantages and Disadvantages Objective: Max ﬂow from S to T Variables: - Flow S → T: f - Flow on edge u → v: f uv Constraints: - Edge capacities: ∀u→v ∈ E: 0 ≤ f uv ≤ c uv - Flow conservation: ∀v ∈ V\\{S,T}: F(v) = 0 - Flow from S: f = F(S) - Flow into T: f = -F(T) 14 Example - Max-ﬂow With E +: outgoing edges of v And E -: incoming edges of v - Each commodity has its own source and destination: S 1 = A, T 1 = H, etc. - Multiple possible objectives: - Maximize the ﬂow of all commodities - Maximize the minimum of all commodities - Deﬁne demand for each commodity and maximize average “fulﬁllment ratio” - LP is the best known solution 15 Example - Multi-commodity ﬂow - Variables: - Flow for commodity 𝛼: S 𝛼 → T 𝛼: f 𝛼 - Flow for commodity 𝛼 on edge u → v: f 𝛼,uv - Goal: maximize ∑ 𝛼f 𝛼 16 Adapting max-ﬂow LP to MCF - Constraints: Edge capacities Flow from S 𝛼 Flow conservation - Goal: Maximize the minimum of all commodities - Add new variable f: Minimum of all f 𝛼 - Add new constraints: f ≤ f 𝛼 for all 𝛼 - Maximize f 17 Adapting max-ﬂow LP to MCF - Alternative Goal - Notation: - Variables: x uv = 1 iff the edge u → v is on the shortest path - Goal: Minimize the path length of S → T, that is minimize 18 Example - Shortest-path Path starts at S Path is connectedRange for x - Constraints: Even without integer constraints for x, we still get the correct SPs Integer Linear Programming → NP hard 19 Example - Shortest-path - Multiple shortest paths - Deﬁne d u as the distance S → u, d S = 0 - For each u → v: d v ≤ d u + wuv - Maximize d T - Intuition: Try pulling S and T as far apart as possible, the distance will be limited by the shortest path 20 Example - Shortest-path - Alternative formulation Load Balancing 22 Motivation: Distribute requests efﬁciently to servers running an application Multiple ideas: - Round-Robin - Query/Track server load; send request to least loaded server - Pick a server at random (Balls in bins problem) - Pick a couple of servers at random - Consistent Hashing Random load balancing The circle represents the range of hash values Arrange servers on the circle Assign sessions to the server with the next closest hash value On server failure, next server will take over Improvement: Give servers multiple IDs, so they cover multiple but smaller hash value ranges, instead of one single big one Consistent Hashing Membership Testing Motivation: Check if an object is contained in a set Examples: Object in the CDN cache; client in a database; cache ﬁltering Idea: A yes/no Hash Table - Collisions? Ignore them, OK for many applications - False positive = Object is not in the set, but we say it is 25 Membership Testing Idea: Use more hash functions instead of just one Properties: - No False Negatives (FN), low False Positives (FP) - Time Efﬁcient: O(1) insertion and membership checking - Space Efﬁcient: constant bits per element, given FP rate What to do if the ﬁlter “ﬁlls up”? - Reset Bloom Filter periodically ➡ Now we can get FN - Primary and Secondary Filter - Only insert into primary ﬁlter - Check both ﬁlters when testing - Periodically empty secondary ﬁlter and swap them 26 Bloom Filter Trafﬁc Monitoring Why do we care about what is happening in our network? - Anomaly detection - Network management Monitoring Granularity? ➡ Trafﬁc ﬂows Problem: There is A LOT of trafﬁc in a network Idea: Trade accuracy/precision for efﬁciency ➡ Probabilistic Trafﬁc Monitoring 28 Trafﬁc Monitoring We want to know how many packets and how much data is sent by each ﬂow - Standard NetFlow: Sample every packet - Sampled NetFlow: Sample every k-th packet; Multiply recorded values by k - Simple to implement - Reduced processing times (only a subset of packets) - Memory overhead: one entry per ﬂow in the worst case - Imprecise estimate, especially for short-lived ﬂows Problem: General-purpose measurement is either imprecise or infeasible ➡ Focus on other trafﬁc information (Large ﬂows, Number of ﬂows, etc.) 29 General-Purpose Measurements - Sample-and-Hold: - Use byte-sampling (take packet size into account when sampling) - Once a ﬂow entry is created, monitor all subsequent packets of that ﬂow - Multistage Filter - Use multiple hash functions, each with its own array, to count ﬂows with the same hash value - If a ﬂows’ hash values are above a threshold in all arrays, then we consider it a large ﬂow - Properties: ﬁxed memory resources, no FNs, low FPs - Finding frequent items (Majority/MG Algorithm) - Find ﬂows which represents the majority/a percentage of the trafﬁc - Requires 2 passes of all the items - EARDet algorithm does not require the 2nd pass 30 Large-ﬂow detectors - Bloom Filter - Increment counter whenever an incoming packet is not in the Bloom Filter (new ﬂow) - O(1) time, but O(N) memory overhead, N = number of ﬂows - Probabilistic counting - Hash the ﬂow values to values between [0, 1) - Get the estimated number of ﬂows from the smallest hash value - Improvement: Keep track of the k smallest hash values 31 Estimate the Number of Flows KahootExercise #11 Question 1: Max ﬂow in data centers 34 Every data center can send arbitrary trafﬁc to any other data center in the network. For communication, a pair of data centers use the shortest path only. If there are paths of the same length, a pair of data centers will pick only one of them. The links are assumed to be full duplex link ● DC1: 3Gbps ● DC2: 2Gbps ● DC3: 2Gbps ● DC4: 5Gbps Question 1: Max ﬂow in data centers 35 1) What should be the capacity of the red link in order to accommodate any possible trafﬁc matrix? The only relevant pairs of data centers are: 1-3 and 1-4 and 2-4 (only their shortest path includes the red link) The capacity that has to be supported is 5 Gbps. ● DC1: 3Gbps ● DC2: 2Gbps ● DC3: 2Gbps ● DC4: 5Gbps Question 1: Max ﬂow in data centers 36 2) How to solve the same problem for an arbitrary network? For an arbitrary network and the target link, we ﬁrst have to calculate all the shortest paths that traverse the link. (In this case 1-3, 1-4 and 2-4) If we then compute the max-ﬂow over the shortest paths that traverse the target link, we will get the worst-case capacity that supports an arbitrary trafﬁc matrix. 1. Construct a new graph where nodes are data centers that communicate over the target link. Question 1: Max ﬂow in data centers 37 2) How to solve the same problem for an arbitrary network? The max-ﬂow can be computed in the following way: 1 3 2 4 ∞ ∞ ∞ 2. Next, connect data centers that want to communicate to each other with links of inﬁnite capacity. 3. Note that the resulting graph is bipartite: If the target link is on the shortest path between both A-B and A-C, it cannot be on the shortest path of B-C. This categorizes nodes into two groups: Senders (left) and receivers (right). Question 1: Max ﬂow in data centers 38 2) How to solve the same problem for an arbitrary network? The max-ﬂow can be computed in the following way: 4. After making this separation, we add two fake nodes, one source, and one destination and connect them to existing nodes as follows: 38 1 3 2 4 S D ∞ ∞ ∞ C1 = 3 C2 = 2 C3 = 2 C4 = 5 We connect all the left data centers to the source with links which capacity is equivalent to data center capacity. The destination is connected to the right data centers following the same principle. What remains is to calculate max-ﬂow between the new source and destination Question 2: Shortest-path routing 39 You are an ISP that operates the Internet2 network in the US 1) Would you use shortest-path routing to route the trafﬁc? If the capacity of your network is signiﬁcantly higher than the demand, then the shortest- path routing would be a good solution. However, if the network is reasonably utilized, and only the shortest path is used, there is a high probability of some links being congested while other links remain idle. This can be solved partially using equal-cost multipath (ECMP) routing. An optimal system needs to ﬁnd a good point in this tradeoff (short paths vs. uniform load). Question 3: Graph Algorithms 40 Consider a transmission between A and B within the network 1) Compute the path with lowest latency from A to B neglecting all other delays. Which algorithm can you use for this problem? ⇒ The numbers are the propagation delay The best archivable latency is 8. A path achieving this is A-C-D-B. Dijkstra's algorithm can compute the shortest path for positive weights. Question 3: Graph Algorithms 41 Consider a transmission between A and B within the network 2.1) Compute the path with highest possible bandwidth from A to B. ⇒ Now the numbers correspond to the bandwidth in Mbps. The maximum bandwidth for any transmission from A to B in this network is 3 Mbps. This bandwidth is achieved by the path A-F-G-B. Question 3: Graph Algorithms 42 Consider a transmission between A and B within the network 2.2) Describe an algorithm that can solve this problem (in words or in pseudocode). 1) We deﬁne that the current best path from A to X can achieve the bandwidth bX and initialize the achievable bandwidth bX to zero everywhere except for node A where we set bA to inﬁnity. 2) Choose the node X with highest value bX and set this node to \"visited\". Afterwards we relax all of its neighbors N. We do that by choosing the maximum of the best currently achievable bandwidth bN and the bandwidth of the path that goes through X to N (which is the minimum of bX and f_XN (bandwidth of the link X-N)) 3) If we choose the path from X to N (if bN < min (bX, f_XN) then we store X as the predecessor of N. 4) If there are unvisited nodes left, repeat at 2) Question 3: Graph Algorithms 43 Consider a transmission between A and B within the network 3) How could you ﬁnd the most reliable path from A to B? ⇒ The numbers correspond to the probability that the link fails in percent We assume link failures to be independent from each other. Hint: Deﬁne appropriate weights based on the probabilities f_i and use Dijkstra's algorithm. Which link weights are additive and usable for Dijkstra? Question 3: Graph Algorithms 44 Consider a transmission between A and B within the network 3) How could you ﬁnd the most reliable path from A to B? We observe that the availability probabilities a_i = 1 − f_i are multiplicative. By taking the logarithm, we can change this multiplication into an addition: ln (a_1 ⋅ a_2) = ln (a_1) + ln( a_2) Since Dijkstra tries to minimize the sum of weights and we want to maximize availability, we need to multiply our metric with −1 and ﬁnally obtain the weights w_i = −ln (1 − f_i) Question 3: Graph Algorithms 45 Consider a transmission between A and B within the network 3) How could you ﬁnd the most reliable path from A to B? Running Dijkstra on this graph, we ﬁnd the shortest path (A-C-D-B) with a total weight of W ≈ 0.081, corresponding to an availability A = e^(−W) ≈ 0.922 = 92.2% and a failure probability F = 1 − A ≈ 0.078 = 7.8%. Question 4: True or False 46 For each of the following statements indicate for each if it is true or false. 1) For each of the following statements indicate for each if it is true or false. ○ BFS is never a viable algorithm choice to solve the shortest path problem. ○ The shortest widest path (SWP) weight criteria fulﬁlls the isotonicity property. ○ The widest shortest path (WSP) weight criteria fulﬁlls the isotonicity property. ○ The Ford-Fulkerson Algorithm can be used to ﬁnd out how reliable a network is Exercise #10 Question 1: Linear Programming 48 Reminder of the LP max ﬂow algorithm: Variables: - Flow S → T: f - Flow on edge u → v: f uv Constraints: - Edge capacities: ∀u→v ∈ E: 0 ≤ f uv ≤ c uv - Flow conservation: ∀v ∈ V\\{S,T}: F(v) = 0 - Flow from S: f = F(S) - Flow into T: f = -F(T) With E +: outgoing edges of v And E -: incoming edges of v Question 1: Linear Programming 49 1) Write the max-ﬂow linear program above in the canonical form of an LP Step 1: deﬁne an ordering on the edges → assign index to each edge Eg: index(u→v) = lexicographical order based on (u,v) Step 2: deﬁne a function conservation_vector(x), where x∈V which returns a vector of size |E|, where: conservation_vector(x)[e] = 1 if e is an outgoing edge from x -1 if e is an incoming edge to x 0 in any other case Question 1: Linear Programming 50 1) Write the max-ﬂow linear program above in the canonical form of an LP Now we can set: Variables (vector x): A vector of size |E| describing the ﬂow per (directed) edge, with f e = x index(e) Objective function (vector c): A vector of size |E| generated by the function conservation_vector(S) Question 1: Linear Programming 51 1) Write the max-ﬂow linear program above in the canonical form of an LP Constraints (matrix A and vector b): ∀ e ∈ E: 0 ≤ f_e: implicit of any LP in canonical form, since x is non-negative ∀ e ∈ E: f_e ≤ c_e: set A maxcap = identity matrix of size |E|, b maxcap(index(e))=c_e ∀ v ∈ V\\{S,T}: F(v) = 0 equality must be replaced by 2 inequality constraints: A_x minﬂow = conservation_vector(x) for x ∈ V\\{S,T} b minﬂow = 0 vector of size |V|-2 A_x maxﬂow = -A_x minﬂow and b maxﬂow = 0 vector of size |V|-2 So we ﬁnally get: A = A maxcap A minﬂow A maxﬂow b = b maxcap b minﬂow b maxﬂow Question 2: Bloom Filters 52 The memory footprint of Bloom ﬁlters is so small that they can ﬁt into devices with very limited memory, like network switches or network cards (NIC). 1) Give 2 potential applications for Bloom ﬁlters on these platforms. Pre-ﬁltering: In a cache server on a NIC, Bloom ﬁlters can be used to ﬁlter out requests for entries that are certainly not in cache and thus reduce latency and the overall load on the server’s CPU. (this could also be done on switches between cache servers) Tracking information: Bloom ﬁlters allow switches to track speciﬁc information about network ﬂows. Question 3: Bloom Filter duplicate detection 53 In network monitoring, Bloom ﬁlters can be used to quickly ﬁnd duplicates. Our duplicate detection system is comprised of two ﬁlter, B0 and B1. We divide the time in intervals Δ which must be greater than the maximum propagation time of packets δ. At the beginning of each interval, one of the two ﬁlters is reset and is ﬁlled with new packets, while the other one is frozen. For each new packet, both ﬁlters are checked for duplicates. We ignore time sync errors for simplicity. 1) What kind of answers does a Bloom ﬁlter give? A Bloom ﬁlter is built to answer with surely not present or possibly present, that is it will give the requester false positives but never false negatives. To be very concise, if it says no, it means no. Question 3: Bloom Filter duplicate detection 54 2) Why does Δ need to be bigger than δ? What happens if a packet that is older than the two periods is received? The choice of Δ should prevent very old packets from arriving at the destination router. In fact, if a packet older than 2Δ arrives, the Bloom ﬁlters will have been both reset, so detection will fail. If such a packet arrives, it is dropped. Question 3: Bloom Filter duplicate detection 55 3) Assume the k hash functions are not correlated and the probabilities of single bit values are not correlated either. What is the probability of a false positive after inserting n elements into a bloom ﬁlter of size m? After the n insertions, we get a new element that is not in the ﬁlter. For a false positive to happen, we would need to have all k bits already set to 1. By independence: Extra slides","libVersion":"0.5.0","langs":""}