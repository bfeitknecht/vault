{"path":"sem4/CN/UE/slides/CN-u11-LP.pdf","text":"Computer Networks - Exercise 11 Algorithms, Linear Programming and Probabilistic Techniques ETH Z√ºrich Slides by Paul Ellsiepen & Janic Moser Based on the work of Linus Baumberger & Severin Obrist May 2024 - Algorithms - Shortest Path Problem - TrafÔ¨Åc Engineering - Linear Programming - Probabilistic Techniques - Load Balancing - Membership Testing - TrafÔ¨Åc Monitoring - Kahoot! - Exercise #11 2 Table of contents Shortest Path Problem 4 Motivation: We want to use the optimal (shortest) path for our trafÔ¨Åc Environment: Graph with weighted edges Shortest path Algorithms Runtime (O-notation) Comment Dijkstra (|V| + |E|) * log (|V|) Non-negative weights Bellman-Ford |V| * |E| Distributed BFS |V| + |E| Only for unweighted graph - Latency - Additive - Loss Rate - Not directly additive, but success rate is multiplicative and can be made additive using logarithms - Bandwidth - Not additive: BW of a path is the minimum of the bandwidths of the edges - But still fulÔ¨Ålls isotonicity property: - Paths P1 and P2 from A to B; Path P3 from B to C (or C to A) - If P1 is better than P2, then P1 + P3 is better than (or equal to) P2 + P3 5 Weight Criterias A B C P1 P2 P3 A BC P1 P2 P3 Can combine criterias: - Shortest Widest Path (SWP): Optimize for bandwidth Ô¨Årst, latency second - Widest Shortest Path (WSP): Optimize for latency Ô¨Årst, bandwidth second But SWP does not fulÔ¨Åll the Isotonicity Property! In our example, with SWP: - B-A-T better than B-T - But S-B-T is better than S-B-A-T 6 Weight Criterias SWP example TrafÔ¨Åc engineering Network engineers need to consider many things: - How much trafÔ¨Åc can the network carry? (Max-Flow) - How reliable is the network? (Min-Cut) Algorithms: Ford-Fulkerson; Edmonds-Karp Really common in practice: - Between customers of an ISP - Between data centers of a company 8 Networking is complex Multiple Sources/Destinations? - Add ‚Äúfake‚Äù source (S)/destination (T) nodes - Now we can use one of the previous algorithms 9 Many possible modiÔ¨Åcations Multi-commodity Ô¨Çow (MCF): - Each source wants to send to a speciÔ¨Åc destination - Can‚Äôt be solved with standard algorithms Linear Programming - Variables: Real values - Flows on edges, distance from the start, ‚Ä¶ - Constraints: Linear combination of variables (strict inequality not allowed) - Flow on edge ‚â§ capacity of edge - Objective: Maximize/minimize a linear combination of variables - Maximize total Ô¨Çow, minimize distances, ‚Ä¶ - Canonical form: - x is a vector of variables (all elements greater or equal 0) - Maximize Œò = c T ¬∑ x (c is vector of constants) - Constraints in the form A ¬∑ x ‚â§ b 11 What is a Linear Program? - Minimization: min Œò ‚û° max -Œò - Greater-than constraint: A ¬∑ x ‚â• b ‚û° (-A) ¬∑ x ‚â§ -b - Equality constraint: A ¬∑ x = b ‚û° A ¬∑ x ‚â§ b and (-A) ¬∑ x ‚â§ -b - Variables with undeÔ¨Åned sign: x i replaced by x i + and x i - so that x = x i + - x i - - A ¬∑ x ‚â§ b ‚û° [A -A][x + x -] T ‚â§ b 12 Transformation to canonical form Advantages: - Many problems can be expressed as LP problems - Writing a LP is easier than developing a specialized algorithm - EfÔ¨Åcient LP solvers are available - LPs are easily adaptable to variations of a problem whereas specialized algorithms are usually not Disadvantages: - LPs are typically much slower than specialized algorithms (O(n¬≥) rule of thumb, n = #columns in the constraints matrix) 13 Advantages and Disadvantages Objective: Max Ô¨Çow from S to T Variables: - Flow S ‚Üí T: f - Flow on edge u ‚Üí v: f uv Constraints: - Edge capacities: ‚àÄu‚Üív ‚àà E: 0 ‚â§ f uv ‚â§ c uv - Flow conservation: ‚àÄv ‚àà V\\{S,T}: F(v) = 0 - Flow from S: f = F(S) - Flow into T: f = -F(T) 14 Example - Max-Ô¨Çow With E +: outgoing edges of v And E -: incoming edges of v - Each commodity has its own source and destination: S 1 = A, T 1 = H, etc. - Multiple possible objectives: - Maximize the Ô¨Çow of all commodities - Maximize the minimum of all commodities - DeÔ¨Åne demand for each commodity and maximize average ‚ÄúfulÔ¨Ållment ratio‚Äù - LP is the best known solution 15 Example - Multi-commodity Ô¨Çow - Variables: - Flow for commodity ùõº: S ùõº ‚Üí T ùõº: f ùõº - Flow for commodity ùõº on edge u ‚Üí v: f ùõº,uv - Goal: maximize ‚àë ùõºf ùõº 16 Adapting max-Ô¨Çow LP to MCF - Constraints: Edge capacities Flow from S ùõº Flow conservation - Goal: Maximize the minimum of all commodities - Add new variable f: Minimum of all f ùõº - Add new constraints: f ‚â§ f ùõº for all ùõº - Maximize f 17 Adapting max-Ô¨Çow LP to MCF - Alternative Goal - Notation: - Variables: x uv = 1 iff the edge u ‚Üí v is on the shortest path - Goal: Minimize the path length of S ‚Üí T, that is minimize 18 Example - Shortest-path Path starts at S Path is connectedRange for x - Constraints: Even without integer constraints for x, we still get the correct SPs Integer Linear Programming ‚Üí NP hard 19 Example - Shortest-path - Multiple shortest paths - DeÔ¨Åne d u as the distance S ‚Üí u, d S = 0 - For each u ‚Üí v: d v ‚â§ d u + wuv - Maximize d T - Intuition: Try pulling S and T as far apart as possible, the distance will be limited by the shortest path 20 Example - Shortest-path - Alternative formulation Load Balancing 22 Motivation: Distribute requests efÔ¨Åciently to servers running an application Multiple ideas: - Round-Robin - Query/Track server load; send request to least loaded server - Pick a server at random (Balls in bins problem) - Pick a couple of servers at random - Consistent Hashing Random load balancing The circle represents the range of hash values Arrange servers on the circle Assign sessions to the server with the next closest hash value On server failure, next server will take over Improvement: Give servers multiple IDs, so they cover multiple but smaller hash value ranges, instead of one single big one Consistent Hashing Membership Testing Motivation: Check if an object is contained in a set Examples: Object in the CDN cache; client in a database; cache Ô¨Åltering Idea: A yes/no Hash Table - Collisions? Ignore them, OK for many applications - False positive = Object is not in the set, but we say it is 25 Membership Testing Idea: Use more hash functions instead of just one Properties: - No False Negatives (FN), low False Positives (FP) - Time EfÔ¨Åcient: O(1) insertion and membership checking - Space EfÔ¨Åcient: constant bits per element, given FP rate What to do if the Ô¨Ålter ‚ÄúÔ¨Ålls up‚Äù? - Reset Bloom Filter periodically ‚û° Now we can get FN - Primary and Secondary Filter - Only insert into primary Ô¨Ålter - Check both Ô¨Ålters when testing - Periodically empty secondary Ô¨Ålter and swap them 26 Bloom Filter TrafÔ¨Åc Monitoring Why do we care about what is happening in our network? - Anomaly detection - Network management Monitoring Granularity? ‚û° TrafÔ¨Åc Ô¨Çows Problem: There is A LOT of trafÔ¨Åc in a network Idea: Trade accuracy/precision for efÔ¨Åciency ‚û° Probabilistic TrafÔ¨Åc Monitoring 28 TrafÔ¨Åc Monitoring We want to know how many packets and how much data is sent by each Ô¨Çow - Standard NetFlow: Sample every packet - Sampled NetFlow: Sample every k-th packet; Multiply recorded values by k - Simple to implement - Reduced processing times (only a subset of packets) - Memory overhead: one entry per Ô¨Çow in the worst case - Imprecise estimate, especially for short-lived Ô¨Çows Problem: General-purpose measurement is either imprecise or infeasible ‚û° Focus on other trafÔ¨Åc information (Large Ô¨Çows, Number of Ô¨Çows, etc.) 29 General-Purpose Measurements - Sample-and-Hold: - Use byte-sampling (take packet size into account when sampling) - Once a Ô¨Çow entry is created, monitor all subsequent packets of that Ô¨Çow - Multistage Filter - Use multiple hash functions, each with its own array, to count Ô¨Çows with the same hash value - If a Ô¨Çows‚Äô hash values are above a threshold in all arrays, then we consider it a large Ô¨Çow - Properties: Ô¨Åxed memory resources, no FNs, low FPs - Finding frequent items (Majority/MG Algorithm) - Find Ô¨Çows which represents the majority/a percentage of the trafÔ¨Åc - Requires 2 passes of all the items - EARDet algorithm does not require the 2nd pass 30 Large-Ô¨Çow detectors - Bloom Filter - Increment counter whenever an incoming packet is not in the Bloom Filter (new Ô¨Çow) - O(1) time, but O(N) memory overhead, N = number of Ô¨Çows - Probabilistic counting - Hash the Ô¨Çow values to values between [0, 1) - Get the estimated number of Ô¨Çows from the smallest hash value - Improvement: Keep track of the k smallest hash values 31 Estimate the Number of Flows KahootExercise #11 Question 1: Max Ô¨Çow in data centers 34 Every data center can send arbitrary trafÔ¨Åc to any other data center in the network. For communication, a pair of data centers use the shortest path only. If there are paths of the same length, a pair of data centers will pick only one of them. The links are assumed to be full duplex link ‚óè DC1: 3Gbps ‚óè DC2: 2Gbps ‚óè DC3: 2Gbps ‚óè DC4: 5Gbps Question 1: Max Ô¨Çow in data centers 35 1) What should be the capacity of the red link in order to accommodate any possible trafÔ¨Åc matrix? The only relevant pairs of data centers are: 1-3 and 1-4 and 2-4 (only their shortest path includes the red link) The capacity that has to be supported is 5 Gbps. ‚óè DC1: 3Gbps ‚óè DC2: 2Gbps ‚óè DC3: 2Gbps ‚óè DC4: 5Gbps Question 1: Max Ô¨Çow in data centers 36 2) How to solve the same problem for an arbitrary network? For an arbitrary network and the target link, we Ô¨Årst have to calculate all the shortest paths that traverse the link. (In this case 1-3, 1-4 and 2-4) If we then compute the max-Ô¨Çow over the shortest paths that traverse the target link, we will get the worst-case capacity that supports an arbitrary trafÔ¨Åc matrix. 1. Construct a new graph where nodes are data centers that communicate over the target link. Question 1: Max Ô¨Çow in data centers 37 2) How to solve the same problem for an arbitrary network? The max-Ô¨Çow can be computed in the following way: 1 3 2 4 ‚àû ‚àû ‚àû 2. Next, connect data centers that want to communicate to each other with links of inÔ¨Ånite capacity. 3. Note that the resulting graph is bipartite: If the target link is on the shortest path between both A-B and A-C, it cannot be on the shortest path of B-C. This categorizes nodes into two groups: Senders (left) and receivers (right). Question 1: Max Ô¨Çow in data centers 38 2) How to solve the same problem for an arbitrary network? The max-Ô¨Çow can be computed in the following way: 4. After making this separation, we add two fake nodes, one source, and one destination and connect them to existing nodes as follows: 38 1 3 2 4 S D ‚àû ‚àû ‚àû C1 = 3 C2 = 2 C3 = 2 C4 = 5 We connect all the left data centers to the source with links which capacity is equivalent to data center capacity. The destination is connected to the right data centers following the same principle. What remains is to calculate max-Ô¨Çow between the new source and destination Question 2: Shortest-path routing 39 You are an ISP that operates the Internet2 network in the US 1) Would you use shortest-path routing to route the trafÔ¨Åc? If the capacity of your network is signiÔ¨Åcantly higher than the demand, then the shortest- path routing would be a good solution. However, if the network is reasonably utilized, and only the shortest path is used, there is a high probability of some links being congested while other links remain idle. This can be solved partially using equal-cost multipath (ECMP) routing. An optimal system needs to Ô¨Ånd a good point in this tradeoff (short paths vs. uniform load). Question 3: Graph Algorithms 40 Consider a transmission between A and B within the network 1) Compute the path with lowest latency from A to B neglecting all other delays. Which algorithm can you use for this problem? ‚áí The numbers are the propagation delay The best archivable latency is 8. A path achieving this is A-C-D-B. Dijkstra's algorithm can compute the shortest path for positive weights. Question 3: Graph Algorithms 41 Consider a transmission between A and B within the network 2.1) Compute the path with highest possible bandwidth from A to B. ‚áí Now the numbers correspond to the bandwidth in Mbps. The maximum bandwidth for any transmission from A to B in this network is 3 Mbps. This bandwidth is achieved by the path A-F-G-B. Question 3: Graph Algorithms 42 Consider a transmission between A and B within the network 2.2) Describe an algorithm that can solve this problem (in words or in pseudocode). 1) We deÔ¨Åne that the current best path from A to X can achieve the bandwidth bX and initialize the achievable bandwidth bX to zero everywhere except for node A where we set bA to inÔ¨Ånity. 2) Choose the node X with highest value bX and set this node to \"visited\". Afterwards we relax all of its neighbors N. We do that by choosing the maximum of the best currently achievable bandwidth bN and the bandwidth of the path that goes through X to N (which is the minimum of bX and f_XN (bandwidth of the link X-N)) 3) If we choose the path from X to N (if bN < min (bX, f_XN) then we store X as the predecessor of N. 4) If there are unvisited nodes left, repeat at 2) Question 3: Graph Algorithms 43 Consider a transmission between A and B within the network 3) How could you Ô¨Ånd the most reliable path from A to B? ‚áí The numbers correspond to the probability that the link fails in percent We assume link failures to be independent from each other. Hint: DeÔ¨Åne appropriate weights based on the probabilities f_i and use Dijkstra's algorithm. Which link weights are additive and usable for Dijkstra? Question 3: Graph Algorithms 44 Consider a transmission between A and B within the network 3) How could you Ô¨Ånd the most reliable path from A to B? We observe that the availability probabilities a_i = 1 ‚àí f_i are multiplicative. By taking the logarithm, we can change this multiplication into an addition: ln (a_1 ‚ãÖ a_2) = ln (a_1) + ln( a_2) Since Dijkstra tries to minimize the sum of weights and we want to maximize availability, we need to multiply our metric with ‚àí1 and Ô¨Ånally obtain the weights w_i = ‚àíln (1 ‚àí f_i) Question 3: Graph Algorithms 45 Consider a transmission between A and B within the network 3) How could you Ô¨Ånd the most reliable path from A to B? Running Dijkstra on this graph, we Ô¨Ånd the shortest path (A-C-D-B) with a total weight of W ‚âà 0.081, corresponding to an availability A = e^(‚àíW) ‚âà 0.922 = 92.2% and a failure probability F = 1 ‚àí A ‚âà 0.078 = 7.8%. Question 4: True or False 46 For each of the following statements indicate for each if it is true or false. 1) For each of the following statements indicate for each if it is true or false. ‚óã BFS is never a viable algorithm choice to solve the shortest path problem. ‚óã The shortest widest path (SWP) weight criteria fulÔ¨Ålls the isotonicity property. ‚óã The widest shortest path (WSP) weight criteria fulÔ¨Ålls the isotonicity property. ‚óã The Ford-Fulkerson Algorithm can be used to Ô¨Ånd out how reliable a network is Exercise #10 Question 1: Linear Programming 48 Reminder of the LP max Ô¨Çow algorithm: Variables: - Flow S ‚Üí T: f - Flow on edge u ‚Üí v: f uv Constraints: - Edge capacities: ‚àÄu‚Üív ‚àà E: 0 ‚â§ f uv ‚â§ c uv - Flow conservation: ‚àÄv ‚àà V\\{S,T}: F(v) = 0 - Flow from S: f = F(S) - Flow into T: f = -F(T) With E +: outgoing edges of v And E -: incoming edges of v Question 1: Linear Programming 49 1) Write the max-Ô¨Çow linear program above in the canonical form of an LP Step 1: deÔ¨Åne an ordering on the edges ‚Üí assign index to each edge Eg: index(u‚Üív) = lexicographical order based on (u,v) Step 2: deÔ¨Åne a function conservation_vector(x), where x‚ààV which returns a vector of size |E|, where: conservation_vector(x)[e] = 1 if e is an outgoing edge from x -1 if e is an incoming edge to x 0 in any other case Question 1: Linear Programming 50 1) Write the max-Ô¨Çow linear program above in the canonical form of an LP Now we can set: Variables (vector x): A vector of size |E| describing the Ô¨Çow per (directed) edge, with f e = x index(e) Objective function (vector c): A vector of size |E| generated by the function conservation_vector(S) Question 1: Linear Programming 51 1) Write the max-Ô¨Çow linear program above in the canonical form of an LP Constraints (matrix A and vector b): ‚àÄ e ‚àà E: 0 ‚â§ f_e: implicit of any LP in canonical form, since x is non-negative ‚àÄ e ‚àà E: f_e ‚â§ c_e: set A maxcap = identity matrix of size |E|, b maxcap(index(e))=c_e ‚àÄ v ‚àà V\\{S,T}: F(v) = 0 equality must be replaced by 2 inequality constraints: A_x minÔ¨Çow = conservation_vector(x) for x ‚àà V\\{S,T} b minÔ¨Çow = 0 vector of size |V|-2 A_x maxÔ¨Çow = -A_x minÔ¨Çow and b maxÔ¨Çow = 0 vector of size |V|-2 So we Ô¨Ånally get: A = A maxcap A minÔ¨Çow A maxÔ¨Çow b = b maxcap b minÔ¨Çow b maxÔ¨Çow Question 2: Bloom Filters 52 The memory footprint of Bloom Ô¨Ålters is so small that they can Ô¨Åt into devices with very limited memory, like network switches or network cards (NIC). 1) Give 2 potential applications for Bloom Ô¨Ålters on these platforms. Pre-Ô¨Åltering: In a cache server on a NIC, Bloom Ô¨Ålters can be used to Ô¨Ålter out requests for entries that are certainly not in cache and thus reduce latency and the overall load on the server‚Äôs CPU. (this could also be done on switches between cache servers) Tracking information: Bloom Ô¨Ålters allow switches to track speciÔ¨Åc information about network Ô¨Çows. Question 3: Bloom Filter duplicate detection 53 In network monitoring, Bloom Ô¨Ålters can be used to quickly Ô¨Ånd duplicates. Our duplicate detection system is comprised of two Ô¨Ålter, B0 and B1. We divide the time in intervals Œî which must be greater than the maximum propagation time of packets Œ¥. At the beginning of each interval, one of the two Ô¨Ålters is reset and is Ô¨Ålled with new packets, while the other one is frozen. For each new packet, both Ô¨Ålters are checked for duplicates. We ignore time sync errors for simplicity. 1) What kind of answers does a Bloom Ô¨Ålter give? A Bloom Ô¨Ålter is built to answer with surely not present or possibly present, that is it will give the requester false positives but never false negatives. To be very concise, if it says no, it means no. Question 3: Bloom Filter duplicate detection 54 2) Why does Œî need to be bigger than Œ¥? What happens if a packet that is older than the two periods is received? The choice of Œî should prevent very old packets from arriving at the destination router. In fact, if a packet older than 2Œî arrives, the Bloom Ô¨Ålters will have been both reset, so detection will fail. If such a packet arrives, it is dropped. Question 3: Bloom Filter duplicate detection 55 3) Assume the k hash functions are not correlated and the probabilities of single bit values are not correlated either. What is the probability of a false positive after inserting n elements into a bloom Ô¨Ålter of size m? After the n insertions, we get a new element that is not in the Ô¨Ålter. For a false positive to happen, we would need to have all k bits already set to 1. By independence: Extra slides","libVersion":"0.5.0","langs":""}