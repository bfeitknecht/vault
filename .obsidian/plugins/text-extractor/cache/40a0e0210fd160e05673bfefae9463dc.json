{"path":"sem2a/DDCA/UE/e/slides/DDCA-LAB02-gates.pdf","text":"Design of Digital Circuits Lab 2 Supplement: Mapping Your Circuit to an FPGA Frank K. GÃ¼rkaynak Seyyedmohammad Sadrosadati (Presentation by Aaron Zeller) ETH Zurich Spring 2024 12 March 2024 What Will We Learn? n In Lab 2, you will: q Design a 4-bit adder. n Design a 1-bit full-adder. n Use full-adders to design a 4-bit adder. q Learn how to map your circuits to an FPGA. q Program your FPGA using the Vivado Design Suite for HDL design. q Work with your FPGA board and see the results of your designs on the FPGA output. 2 3 Binary Addition Binary Addition (1) 0 1 1 1 + 1 0 1 0 4 A B Binary Addition (2) 0 1 1 1 + 1 0 1 0 1 5 Binary Addition (3) 1 0 1 1 1 + 1 0 1 0 0 1 6 Carry Binary Addition (4) 1 1 1 0 1 1 1 + 1 0 1 0 1 0 0 0 1 7 A B Sum Overflow Carry The Full-Adder (1) 1 1 1 0 1 1 1 + 1 0 1 0 1 0 0 0 1 8 The Full-Adder (2) 1 1 1 0 1 1 1 + 1 0 1 0 1 0 0 0 1 9 Inputs â€¢ Carry-in (Cin) â€¢ Input 1 (A) â€¢ Input 2 (B) Outputs â€¢ Sum (S) â€¢ Carry-out (Cout) Design an Adder (1) n Design a full-adder: q Inputs: input 1 (A), input 2 (B), carry-in (Cin). q Outputs: sum (S), carry-out (Cout). q All inputs and outputs are 1-bit wide. n Example: q A = 1, B = 1, Cin = 1 q S = 1, Cout = 1 10 Full-adder A B S Cout 1-bit 1-bit Cin 1-bit 1-bit 1-bit Design an Adder (2) n Design a 4-bit adder: q Receives two 1-bit numbers A and B and a 1-bit input carry (Cin) q Returns outputs S and C as sum and carry of the operation, respectively. n Example: A = 1110, B =0001, Cin=1 q S = 0000 q C = 1 n Hint: Use four full-adders to design a 4-bit adder. 11 Full Adder a0b0 s0 0c1 Full Adder a1b1 s1 c2 Full Adder a2b2 s2 c3 Full Adder a3b3 s3 c4 Design an Adder (Overview) 1. You will use truth tables to derive the Boolean equation of the adder. 2. You will design the schematic of the circuit using logic gates. 3. You will use Vivado to write your design in Verilog. 4. You will use Vivado to program the FPGA. 12 Vivado Design Suite n We will use the Vivado Design Suite for FPGA programming. q Vivado is installed in the computers in the lab rooms. q If you wish to use your own computer, you can follow these instructions: https://reference.digilentinc.com/learn/programmable-logic/tutorials/basys-3-getting-started/start 1314 Verilog Defining a Module in Verilog n A module is the main building block in Verilog. n We first need to define: q Name of the module q Directions of its ports (e.g., input, output) q Names of its ports n Then: q Describe the functionality of the module. 15 a b y c Verilog Module example Implementing a Module in Verilog a b y c Verilog Module module example (a, b, c, y); input a; input b; input c; output y; // here comes the circuit description endmodule 16 Port list (inputs and outputs) ports have a declared type a module definition name of module example Structural HDL: Instantiating a Module 17 Schematic of module â€œtopâ€ that is built from two instances of module â€œsmallâ€ i_first i_second Structural HDL Example (1) n Module Definitions in Verilog module small (A, B, Y); input A; input B; output Y; // description of small endmodule 18 i_first i_second Structural HDL Example (2) n Module Definitions in Verilog module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule 19 i_first i_second module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Structural HDL Example (3) n Defining wires (module interconnections) 20 i_first i_second n The first instantiation of the â€œsmallâ€ module module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; // instantiate small once small i_first ( .A(A), .B(SEL), .Y(n1) ); endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Structural HDL Example (4) 21 i_first i_second n The second instantiation of the â€œsmallâ€ module module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; // instantiate small once small i_first ( .A(A), .B(SEL), .Y(n1) ); // instantiate small second time small i_second ( .A(n1), .B(C), .Y(Y) ); endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Structural HDL Example (5) 22 i_first i_second n Short form of module instantiation module top (A, SEL, C, Y); input A, SEL, C; output Y; wire n1; // alternative small i_first ( A, SEL, n1 ); /* Shorter instantiation, pin order very important */ // any pin order, safer choice small i_second ( .B(C), .Y(Y), .A(n1) ); endmodule module small (A, B, Y); input A; input B; output Y; // description of small endmodule Structural HDL Example (6) 23 i_first i_second 24 What about logic gates? Instantiating Logic Gates: The NOT Gate 25 not my_not(output, input); gate type gate name output signal input signal input output ğ‘¨ ğ‘¨ 0 1 1 0 Instantiating Logic Gates: AND Gate 26 and my_and(output, input1, input2); gate type gate name output signal input signals A B A â€¢ B ğ‘¨ ğ‘© ğ‘¨ â€¢ ğ‘© 0 0 0 0 1 0 1 0 0 1 1 1 Instantiating Logic Gates: AND Gate 27 and my_and(output, input1, input2); orâ€¦ and my_and(output, input1, input2, input3, ...); gate type gate name output signal input signals (as many as you want) gate type gate name output signal input signals A B A â€¢ B ğ‘¨ ğ‘© ğ‘¨ â€¢ ğ‘© 0 0 0 0 1 0 1 0 0 1 1 1 Instantiating Logic Gates: More Gates 28 not my_not(output, input); buf my_buf(output, input); and my_and(output, input1, input2, ...), or my_or(output, input1, input2, ...); xor my_xor(output, input1, input2, ...); nand my_nand(output, input1, input2, ...); nor my_nor(output, input1, input2, ...); xnor my_xnor(output, input1, input2, ...); Instantiating Logic Gates: Simple Example 29 ğ’ğ’–ğ’• = %ğ‘¨ ' %ğ‘© Instantiating Logic Gates: Simple Example n Bubbles are used to denote negation of signals. o This requires a NOT-Gate even if not explicitly drawn. 30 ğ’ğ’–ğ’• = %ğ‘¨ ' %ğ‘© Instantiating Logic Gates: Simple Example 31 ğ’ğ’–ğ’• = %ğ‘¨ ' %ğ‘© // Notice the alternative port declaration module check_zeros ( input A, input B, output out ); // wires for the intermediate signals wire not_a, not_b; // instantiate the NOT gates not(not_a, A); not(not_b, B); // instantiate the AND gate and(out, not_a, not_b); endmodule Basys 3 FPGA Board n In this course, we will be using the Basys 3 boards from Digilent, as shown below. n You can learn more about the Basys 3 Starter Board from: o Digilent: Shop o Digilent: Getting Started o Digilent: Reference Manual 32 Output LEDs Input Switches For this weekâ€™s lab: Basys 3 FPGA Board 33 Plug in your board here Switches are used for input LEDs are used for outputIf your board is not working check if it is switched on Basys 3 FPGA Board: Constraints n Constraint files are used to map the Verilog code to the actual board. n Map top module inputs / output signals to physical inputs / outputs pins on the board. 34 https://nerdytechy.com/basys-3-artix-7-fpga-trainer-board-review/ Basys 3 FPGA Board: Constraints n Every input / output in the code in the top- module must be mapped to the board. n set_property PACKAGE_PIN is used once for every input / output. n set_property IOSTANDARD LVCMOS33 is used once for all inputs / outputs together. 35 Basys 3 FPGA Board: Constraints n Every input / output in the code in the top- module must be mapped to the board. n set_property PACKAGE_PIN is used once for every input / output. n set_property IOSTANDARD LVCMOS33 is used once for all inputs / outputs together. 36 Verilog: Basics n Verilog is not just some new programming language. q Verilog code implements hardware n Variables do not really exist like in Java. q They are electronic components like a wire, register, etc. q You are describing electronic circuits using a hardware design language. n Verilog is untyped. q Be careful when assigning wires or registers. 37 Verilog: Basic Workflow n Add all source files and make sure that the correct top-module is selected. n Add the constraints file to define a mapping to the FPGA board. n Generate the bitstream and then open the hardware manager to program the device. 38 Verilog: Basic Workflow n Add all source files and make sure that the correct top-module is selected. n Add the constraints file to define a mapping to the FPGA board. n Generate the bitstream and then open the hardware manager to program the device. 39 Verilog: Hardware Detection Issues n Sometimes Vivado does not auto-detect your board. o Check if your board is turned on. o Check if the default part is correctly selected as xc7a35tcpg236-1. 40 Verilog: Messages n When generating the Bitstream you will be greeted with many error, warning, info and status messages. o Errors are problems that cannot be ignored. o Critical warnings mostly precede errors and should not be ignored. o Warnings can be useful. o Info and Status messages can be ignored. 41 Verilog: Messages n If you cannot generate the bitstream check if another bitstream is currently being generated. o To avoid confusion delete all messages before generating a bitstream to differentiate between old and new messages. o In the top right corner you can check if Vivado is currently working on a job or not. ( = not done, = done) 42 Verilog: Modules n When asked to define a module select \"Cancel\" and then \"Yes\" in the next menu. 43 Last Words n In this lab, you will map your circuit to an FPGA. n First you will design a full-adder. You will then use the full- adder as a building block to build a 4-bit adder. n Then, you will learn how to use Xilinx Vivado for writing Verilog and how to connect to the Basys 3 board. n Finally, you will program the FPGA and get the circuit running on the FPGA board. n You will find more exercises in the lab report. 44 Report Deadline 45 [12. April 2024 23:59] Design of Digital Circuits Lab 2 Supplement: Mapping Your Circuit to an FPGA Frank K. GÃ¼rkaynak Seyyedmohammad Sadrosadati ETH Zurich Spring 2024 12 March 2024","libVersion":"0.3.2","langs":""}