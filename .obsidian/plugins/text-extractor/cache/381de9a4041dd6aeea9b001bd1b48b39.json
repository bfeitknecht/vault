{"path":"sem2a/AuW/UE/u/s/AuW-u00-s.pdf","text":"ETH Z¨urich Institute of Theoretical Computer Science Prof. Rasmus Kyng Prof. Angelika Steger FS 2024 Algorithmen und Wahrscheinlichkeit Warmup-Exercises — L¨osung Aufgabe 1 – Pfade, Wege, Kreise 1. Der Pfad ⟨a, b, c, f, e⟩ ist der einzige Pfad der L¨ange 4 von a nach e. 2. Es gibt 12 solche Wege: ⟨a, b, c, f, e⟩, ⟨a, b, c, b, e⟩, ⟨a, b, e, d, e⟩, ⟨a, b, e, f, e⟩, ⟨a, b, e, b, e⟩, ⟨a, b, a, b, e⟩, ⟨a, b, a, d, e⟩, ⟨a, d, a, d, e⟩, ⟨a, d, a, b, e⟩, ⟨a, d, e, d, e⟩, ⟨a, d, e, b, e⟩, ⟨a, d, e, f, e⟩. 3. Es gibt drei wesentlich verschiedenen Kreise ⟨a, b, d, e, a⟩, ⟨b, c, f, e, b⟩ und ⟨a, b, c, f, e, d, a⟩. Ausserdem k¨onnen wir f¨ur jeden Kreis noch den Startpunkt ausw¨ahlen (vier M¨oglichkeiten in den ersten zwei F¨allen, 6 M¨oglichkeiten im dritten Fall), und die Durchlaufrichtung. Insgesamt gibt es also 8 + 8 + 12 = 28 verschiedene Kreise. In der Vorlesung werden wir oft Startpunkt und Durchlaufrichtung ignorieren – daher werden wir im Einzelfall spezifizieren, ob sie ber¨ucksichtigt werden sollen. 4. Es gibt unendlich viele Zykeln in G, z.B. ⟨a, b, a⟩, ⟨a, b, a, b, a⟩, ⟨a, b, a, b, a, b, a⟩, . . .. Aufgabe 2 – Asymptotisches Wachstum. Zur besseren Lesbarkeit k¨urzen wir f = o(g) durch f ≪ g und f = Θ(g) durch f ≡ g ab. 2 32 ≪ log(n2) ≡ ln n ≡ log n ≪ e√log n ≪ n1/4 ≪ n log n ≪ n ≡ n + √n ≪ 0.01n 2 ≪ 2 n ≪ en ≪ n! Anmerkungen • Die meisten Vergleiche k¨onnen durch Theorem 1.1 aus Algorithmen und Datenstrukturen ermittelt werden. Es besagt unter anderem, dass lim n→∞ g(n) f (n) = ∞ =⇒ f = o(g) und lim n→∞ f (n) g(n) = C f¨ur ein C ∈ R+ =⇒ f = Θ(g). Zur Auswertung des Limes ist oft der Satz von L’Hˆopital hilfreich. • 2 32 ist ein Konstante. • log(n2) = 2 · log n und log n = ln n ln 2 = 1.442 . . . · ln n. • e√log n log n = e√log n elog log n = e√log n−log log n → ∞, weil √x − log x → ∞ f¨ur x → ∞. (Hier mit x = log n.) • n1/4 e√log n = e1/4·log n e√ log n = e 1/4·log n− √log n → ∞, weil 1 4 x − √x → ∞ f¨ur x → ∞. (Wieder mit x = log n.) • In n! stecken n − 3 Faktoren, die alle mindestens Gr¨osse 4 haben. Daher ist n! ≥ 4 n−3 = 1 64 · 4n = ω(en). Aufgabe 3 – Induktion (a) Induktionsanfang: F¨ur n = 1 sind beide Seiten 1/2, daher stimmt die Behauptung. Induktionsvoraussetzung: 1 1·2 + 1 2·3 + 1 3·4 + . . . + 1 n(n+1) = n n+1 . Induktionsbehauptung: 1 1·2 + 1 2·3 + . . . + 1 n·(n+1) + 1 (n+1)(n+2) = n+1 n+2 . Induktionsschritt: Es gilt 1 1 · 2 + 1 2 · 3 + . . . + 1 n(n + 1) + 1 (n + 1) · (n + 2) I.V. = n n + 1 + 1 (n + 1)(n + 2) = n2 + 2n + 1 (n + 1)(n + 2) = (n + 1)2 (n + 1)(n + 2) = n + 1 n + 2 . (b) Sei h ≥ −1 fest vorgegeben. Wir verwenden Induktion ¨uber n. Induktionsanfang: F¨ur n = 1 sind beide Seiten gleich 1+h, daher stimmt die Behauptung. Induktionsvoraussetzung: 1 + nh ≤ (1 + h) n. Induktionsbehauptung: 1 + (n + 1)h ≤ (1 + h) n+1. Induktionsschritt: Es gilt (1 + h)n+1 = (1 + h) n · (1 + h) I.V., und (1 + h) ≥ 0 ≥ (1 + nh) · (1 + h) = 1 + (n + 1)h + nh 2 ≥ 1 + (n + 1)h. Aufgabe 4 – Eine generelle Eigenschaft von Graphen Wir zeigen die Aussage mit dem Schubfachprinzip. Nehmen Sie an, dass der Graph n Knoten hat. Jeder dieser Knoten ist mit entweder 0, 1, 2, . . . , n − 2 oder n − 1 anderen Knoten verbunden. Falls es einen Knoten mit Grad n − 1 gibt, so ist dieser mit allen anderen verbunden und es kann keinen Knoten mit Grad 0 geben. Es ist also unm¨oglich einen Graphen mit n Knoten zu haben indem es sowohl einen Knoten mit Grad 0 als auch einen Knoten mit Grad n − 1 gibt. Die Knoten k¨onnen also h¨ochstens n − 1 verschiedene Grade haben, da es n Knoten gibt haben nach dem Schubfachprinzip wenigstens zwei Knoten den gleichen Grad. Aufgabe 5 – Algorithmus Es gibt viele Arten dieses Problem zu l¨osen. Hier betrachten wir einen Algorithmus der auf dem Statement aus 6 (b) basiert. Algorithmus: Als erstes pr¨ufen wir ob |E| = |V | − 1. Dies tun wir in dem wir durch die Kanten gehen und abbrechen, sobald wir |V | Kanten gesehen haben. Falls |E| ̸= |V | − 1, geben wir sofort “Nein” aus. Sonst w¨ahlen wir einen Knoten v und f¨uhren eine Tiefensuche beginnend bei v durch. Dann pr¨ufen wir, ob alle Knoten als besucht markiert sind. Falls sie das sind, geben wir“Ja” aus, ansonsten geben wir “Nein” aus. Korrektheitsbeweis: Falls wir mehr als |V | Kanten haben gilt sicher |E| > |V | − 1 somit reicht es die ersten |V | Kanten zu betrachten, um zu entscheiden ob |E| ̸= |V | − 1. Wir wissen, dass die Tiefensuche, die in einem Knoten v beginnt genau die Knoten besucht, die in der Zusammenhangs- komponente von v sind. Daher gibt der Algorithmus “Ja” aus, genau dann wenn |E| = |V | − 1 und der Graph zusammenh¨angend ist. Nach 6(b), ist dies ¨aquivalent dazu, dass der Graph ein Baum ist. Laufzeitanalyse: Um zu entscheiden, ob |E| = |V |−1 oder nicht, gehen wir die Kanten eine nach der anderen durch (in beliebiger Reihenfolge). Da wir abbrechen, wenn wir |V | Kanten gesehen haben k¨onnen wir dies in O(|V |) tun. (Man beachte, das wir an dieser Stelle das wir O(|V | + |E|) Zeit br¨auchten um den ganzen Graphen einzulesen) Die Tiefensuche durchzuf¨uhren braucht normalerweise O(|V |+|E|) Zeit. Da wir diese nur ausf¨uhren falls |E| = |V | − 1, l¨auft diese in O(|V | + |V | − 1) = O(|V |). Zu pr¨ufen ob alle Knoten von der Tiefensuche besucht wurden k¨onnen wir in O(|V |) durchf¨uhren. Also ist die Gesamtlaufzeit unseres Algorithmus O(|V |). Aufgabe 6 – Charakterisierung von B¨aumen (Challenge-Aufgabe) Siehe Satz 1.6 im Skript.","libVersion":"0.3.2","langs":""}