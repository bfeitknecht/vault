{"path":"sem5/SPCA/VRL/extra/slides/SPCA-s00-introduction.pdf","text":"252-0061-00 V Systems Programming and Computer Architecture Chapter 1: Introduction Systems Programming 2025 Ch. 1: Introduction 1 This course covers in depth… • How to write fast and correct code • How to write good systems code • What makes programs go fast (and slow) • Programming in C • Still the systems programming language of choice • Programming in Assembly Language • What the machine understands • Programs as more than mathematical objects • E.g. how does Facebook work? • How programs interact with the hardware Systems Programming 2025 Ch. 1: Introduction 2 Course Goals • Think like systems programmers • Build a mental model of the entire machine • Be able to think about and write systems code • Become more effective application programmers • Find and eliminate bugs efficiently • Easily assimilate new programming models • Understand and tune for program performance • Write better application code • Prepare for later systems classes at ETHZ • Compilers, Operating Systems, Networks, Computer Architecture, Embedded Systems Systems Programming 2025 Ch. 1: Introduction 3 Who are we? Systems Programming 2025 Ch. 1: Introduction 4 Prof. Timothy Roscoe Prof. Ana Klimovic Full Disclosure Systems Programming 2025 Ch. 1: Introduction 5 Full Disclosure Systems Programming 2025 Ch. 1: Introduction 6 Acknowledgements • Half of the course material from the famous CS 15-213 at Carnegie Mellon University • Basis for the book • Thanks to Dave O’Halloran, Randall Briant, & Brian Railing at CMU • Some C programming slides adapted from CSE333 at University of Washington • Many thanks to (ex-)Prof. Steve Gribble at UW. • New material: • Considerable evolution… • Multicore, devices, etc. • Mostly our fault ☺ Systems Programming 2025 Ch. 1: Introduction 7 1.1: Logistics Systems Programming and Computer Architecture Systems Programming 2025 Ch. 1: Introduction 8 Lectures • Physical: • 10:00-12:00 Tuesdays and Wednesdays • HG E 7 (Tue) & ETA F 5 (Wed) • Recordings will appear after a few days • https://video.ethz.ch/lectures/d-infk/2025/autumn.html Systems Programming 2025 Ch. 1: Introduction 9 The slides are not intended to be understood without the lectures… Moodle • The first place to look! • Links posted here • All lecture materials will be posted on Moodle. • Ask questions in the forum • TAs and Profs will monitor the forum! • Ask TAs to post questions if you prefer • We will not answer questions on Discord. Systems Programming 2025 Ch. 1: Introduction 10 https://moodle-app2.let.ethz.ch/course/view.php?id=26295 Tutorial sessions • Very important! • Logistics: • Wednesday, 12:15-14:00 or 14:15-16:00 • See myStudies for rooms and streams • Content: • Tools and skills for lab exercises • Knowledge needed for exams, but not in the lectures! • There will be a session this Wednesday (tomorrow) Systems Programming 2025 Ch. 1: Introduction 11 Language • We’ll teach in English (and C…) • If we speak too fast, or say something unclear, raise your hand! • Please ask questions! • Assistants speak German, English, Italian, French, Mandarin, … Systems Programming 2025 Ch. 1: Introduction 12 Asking questions 1. Ask during the lectures 2. Ask on the Moodle forum outside the lectures 3. Ask your friends 4. Check the web 5. Ask your teaching assistant 6. Ask another teaching assistant 7. Email us (troscoe@inf.ethz.ch or aklimovic​@ethz.​ch) Systems Programming 2025 Ch. 1: Introduction 13 1.2: Course background and assumptions Systems Programming and Computer Architecture Systems Programming 2025 Ch. 1: Introduction 14 Textbooks • Randal E. Bryant and David R. O’Hallaron, • Computer Systems: A Programmer’s Perspective, Third Edition (CS:APP3e), Pearson, 2016 • http://csapp.cs.cmu.edu Systems Programming 2025 Ch. 1: Introduction 15 Courses we build on • Programming & software engineering • Parallel programming • Data structures and algorithms • Digital Circuits • Discrete Mathematics Systems Programming 2025 Ch. 1: Introduction 16 Though obviously not all of each of them What we’ll assume you know #1: • Memory, addresses, bytes, and words • Binary, and Hexadecimal notation • Byte-ordering (Big/Little Endian) • Boolean algebra • and, or, not, xor • Generalized Boolean algebra: bitwise operations on words as bit vectors • How to write programs • Languages • Java (but we won’t use it) • Some C or C++ (but not much) • Some assembly language Systems Programming 2025 Ch. 1: Introduction 17 What we’ll assume you know #2: • Processor architecture, pipelines • Registers • Addressing modes • Instruction formats • Basic memory systems • cache architectures • virtual memory • I/O devices • Software engineering • Object-orientation • Design-by-contract • Strong typing • Concurrency and parallelism • Threads • Locks, mutexes, condition variables • Parallel programming constructs Systems Programming 2025 Ch. 1: Introduction 18 Catching up with the background • Textbook: • Ch. 1: general background • Ch. 2: representing integers and floats • Ch. 4: processor architecture • Dedicated exercise group for RW/CSE students • Pierre Pang • Wednesdays 12:15-14:00, ETZ G.91 • We'll also recap a lot of topics in lectures. Systems Programming 2025 Ch. 1: Introduction 19 If you haven't taken Digital Circuits You are here: Systems Programming 2025 Ch. 1: Introduction 20 Systems Programming and Computer Architecture Parallel Programming Digital Circuits Networks Data modelling and Databases Compiler Design Information Systems Embedded Systems… Application areas: Visual Computing, Big Data, Numerical Analysis, Machine Learning, etc. Computer Systems 1.3: Programming in this course Systems Programming and Computer Architecture Systems Programming 2025 Ch. 1: Introduction 21 You’ll be writing a lot of C • You’ll be seeing a lot of code • We’ll make our source code available to play with • You should be writing quite a bit of code • Exam performance will depend on it. • You’ll need to be comfortable with the command line • We’ll spend a lot of time at the prompt. • Unix shell commands • ls, more, make, gcc, gdb, grep, rm, mv, … • Why? • Closer to reality: the topic of this course • Makes it clearer what is really going on Systems Programming 2025 Ch. 1: Introduction 22 Books on C (there are many) Systems Programming 2025 Ch. 1: Introduction 23 Samuel Harbison and Guy Steele C: A Reference Manual 5th edition 2002 Brian Kernighan and Dennis Ritchie, The C Programming Language 2nd Edition 1988(!) Other recommendations Systems Programming 2025 Ch. 1: Introduction 24 Brian Kernighan and Rob Pike, The Practice of Programming 1999 Peter van der Linden Expert C Programming: Deep C Secrets, 1994 Programming environment • This course targets: • Linux Ubuntu 24.04 LTS command line on 64-bit x86 PC hardware • CodeExpert (of course) • Various options for this exist: • Native install, or log into lab machines • Windows Subsystem for Linux (from the Store) • Docker image for Apple Silicon (and Windows) • Use another environment and wing it… • We’ll help, but there’s a limit to how weird we’re prepared to get. Systems Programming 2025 Ch. 1: Introduction 25 A word on testing • Essential systems programming skill: devising and writing good tests • In many exercises and exam questions, you won’t get a test suite. • This is what happens in reality • See exam environment later… • We will cover debugging, testing, and writing tests in the course. Systems Programming 2025 Ch. 1: Introduction 26 A word on submitting • Essential systems programming skill: reasoning about the correctness of your code • This is part of what makes good programmers good • In many exercises and exam questions, the last submitted version is what counts. • This is, again, what happens in reality • Trying something until it works is not good engineering practice. • We strongly advise getting good at writing C during the course, and not submitting untested answers at the last moment! Systems Programming 2025 Ch. 1: Introduction 27 A word on LLMs and coding agents • To paraphrase Prof. Buhmann: \"An LLM is a lossy index over human statements.\" • Corollary: Using a coding agent in a programming course is, essentially, copying your c.ode from other people. • We learn C programming in order to understand how: • To write very difficult code • How computer systems work • What constitutes good and bad code • How to express systems problems clearly Systems Programming 2025 Ch. 1: Introduction 28 Coding agents just don't help with this C in the exam • The exam will be online. • We use CodeExpert for the exam. (and many of the lab exercises) • The exam will cover: • C knowledge • Systems programming skills • Concepts in the course … sometimes in the same question. Systems Programming 2025 Ch. 1: Introduction 29 Use of C in the exam • What is the largest positive signed integer representable in a two’s complement format using n bits? ↓ • Fill in the body of the following C function, which calculates and returns the largest positive signed integer representable in two’s complement format using sz bits: Systems Programming 2025 Ch. 1: Introduction 30 /* * Return the largest signed integer representable * in two's-complement notation using sz bits. */ int64_t maxint(unsigned int sz) { return (1 << (sz-1)) - 1; } 1.4: What is Systems Programming? Systems Programming and Computer Architecture Systems Programming 2025 Ch. 1: Introduction 31 Systems vs. application programming • Systems programmers can, and do, write applications. • They are usually the most productive programmers • Their code is more efficient and robust • Performance is often dramatically better. • Pure applications programmers should not be trusted to write system software. • What is this system software? Systems Programming 2025 Ch. 1: Introduction 32 “Systems” as a field • Encompasses: • Operating systems • Database systems • Networking protocols and routing • Compiler design and implementation • Distributed systems • Cloud computing & online services • Big Data and machine learning frameworks • On and above the hardware/software boundary Systems Programming 2025 Ch. 1: Introduction 33 Why systems matters: • The nice abstractions that application programmers like: • Processes, threads, virtual memory, garbage collection, files, network sockets, cloud services, databases, parallel frameworks, containers, etc. etc. • The security properties we rely on: • Authentication, authorization, protection, access control, remote login, automated management, etc. • Everything that makes a computer more than a glorified abacus: • I/O devices, graphical output, multiprocessing, accelerators for ML and AI, etc. … is all provided by system software. And someone has to write it. Systems Programming 2025 Ch. 1: Introduction 34 “Systems” as a field „In designing an operating system one needs both theoretical insight and horse sense. Without the former, one designs an ad hoc mess; without the latter one designs an elephant in best Carrara marble (white, perfect, and immobile).“ Systems Programming 2025 Ch. 1: Introduction 35 Roger Needham and David Hartley, ACM Symposium on Operating Systems Principles, 1968 Why systems programming is different • Systems programming is a way of thinking about computing • Most CS courses emphasize abstraction • Abstract data types (objects, contracts, etc.) • Program as mathematical object with well-defined behavior • Asymptotic analysis (worst-case, complexity) • These abstractions have limitations • Often don’t survive contact with reality • Especially in the presence of bugs • Systems Programmers understand details of underlying implementations Systems Programming 2025 Ch. 1: Introduction 36 1.5: Motivation – Some inconvenient truths about computers Systems Programming and Computer Architecture Systems Programming 2025 Ch. 1: Introduction 37 Inconvenient truth: Computers don’t really deal with numbers. Computers don’t deal with integers • Maths: • Reality: Systems Programming 2025 Ch. 1: Introduction 39 𝑆 = 𝑖𝑜 … 𝑖𝑘−1, 𝑖 ∈ ℤ 𝑇 = ෍ 𝑗=0 𝑘−1 𝑖𝑗 #include <stdio.h> #include <stdlib.h> #define BUFFER_LENGTH 80 int main(int argc, char *argv[]) { char buffer[BUFFER_LENGTH]; int total = 0; while( fgets( buffer, BUFFER_LENGTH, stdin ) ) { total += atoi(buffer); } printf(\"Total is %d\\n\", total); return 0; } This is not a bug – it is correct behavior! Source code: chapter 1 → addint Computers don’t deal with reals either • Maths: • Reality: Systems Programming 2025 Ch. 1: Introduction 40 ∀ 𝑥, 𝑦, 𝑧 ∈ ℝ, 𝑥 + 𝑦 + 𝑧 = 𝑥 + (𝑦 + 𝑧) #include <stdio.h> int main(int argc, char *argv[]) { float x = 1e20; float y = -1e20; float z = 3.14; printf(\"( x + y ) + z = %f\\n\", (x + y) + z); printf(\"x + ( y + z ) = %f\\n\", x + (y + z)); return 0; } This is not a bug – it is correct behavior! Source code: chapter 1 → addfloat Computer arithmetic • Does not generate random values • Arithmetic operations have important mathematical properties • Cannot assume all “usual” mathematical properties • Due to finiteness of representations • Integer operations satisfy “ring” properties • Commutativity, associativity, distributivity • Floating point operations satisfy “ordering” properties • Monotonicity, values of signs • Observation • Need to understand which abstractions apply in which contexts • Important issues for compiler writers and serious application programmers Systems Programming 2025 Ch. 1: Introduction 41 Inconvenient truth: The best programmers know assembly. You’ve got to know assembly • Chances are, you’ll never write a program in assembly • Compilers are much better & more patient than you are • But: understanding assembly is key to machine-level execution model • Behavior of programs in presence of bugs • High-level language model breaks down • Tuning program performance • Understand optimizations done/not done by the compiler • Understanding sources of program inefficiency • Implementing system software • Compiler has machine code as target • Operating systems must manage process state • Creating / fighting malware • x86 assembly is the language of choice! Systems Programming 2025 Ch. 1: Introduction 43 Assembly example: measuring cycles • Time Stamp Counter • Special 64-bit register in Intel-compatible machines • Incremented every clock cycle • Read with rdtsc instruction • Cannot be read from a programming language • Requires assembly code to access • C compiler’s asm facility inserts assembly code into generated machine code Systems Programming 2025 Ch. 1: Introduction 44 uint64_t rdtsc() { uint32_t lo, hi; asm volatile(\"rdtsc; movl %%edx,%0; movl %%eax,%1\" : \"=r\" (hi), \"=r\" (lo) : : \"%edx\", \"%eax\"); return (lo | (((uint64_t)hi) << 32)); } Source code: chapter 1 → timing Assembly example: measuring cycles • Can be used to measure how many instruction cycles a computation really took. • Need to be careful about measurement methodology… Systems Programming 2025 Ch. 1: Introduction 45 int main(int argc, char *argv[]) { uint64_t start, overhead; unsigned long result; // Measure the overhead. // We should really repeat this many times. start = rdtsc(); overhead = rdtsc()-start; printf(\"Counter overhead is %lu cycles\\n\", overhead); // Time the function start = rdtsc(); result = calc(); printf(\"Time = %lu cycles\\n\", rdtsc()-start-overhead ); printf(\"Result = %lu\\n\", result ); return 0; } Source code: chapter 1 → timing Inconvenient truth: Performance is about much more than asymptotic complexity There’s much more to performance than asymptotic complexity • Constant factors matter too – often more. • Even exact op count does not predict performance • Easily see 10:1 performance range depending on how code written • Must optimize at multiple levels: algorithm, data representations, procedures, and loops • Must understand system to optimize performance • How programs compiled and executed • How to measure program performance and identify bottlenecks • How to improve performance without destroying code modularity and generality Systems Programming 2025 Ch. 1: Introduction 47 Example: matrix-matrix mutliplication • Fundamental operation in ML, graphics, etc., etc. … ↤ … × … • How complicated can this be? • Basically requires 𝑛3operations for 𝑛 × 𝑛 matrices • Though some subcubic algorithms exist – ignore for now. Systems Programming 2025 Ch. 1: Introduction 48 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0 1’000 2’000 3’000 4’000 5’000 6’000 7’000 8’000 9’000 matrix size triple loopMatrix-Matrix Multiplication (MMM) on 2 x Core 2 Duo 3 GHz (double precision) Gflop/s Example: matrix-matrix multiplication Systems Programming 2025 Ch. 1: Introduction 49 Triple loop 0 5 10 15 20 25 30 35 40 45 50 0 1,000 2,000 3,000 4,000 5,000 6,000 7,000 8,000 9,000 matrix size Matrix-Matrix Multiplication (MMM) on 2 x Core 2 Duo 3 GHz (double precision) Gflop/s Example: matrix-matrix multiplication • Standard desktop computer, vendor compiler, using optimization flags • Both implementations have exactly the same operation count (2n3) • What is going on? Systems Programming 2025 Ch. 1: Introduction 50 160x Triple loop Best known code (K. Goto) MMM plot: analysis 0 5 10 15 20 25 30 35 40 45 50 0 1,000 2,000 3,000 4,000 5,000 6,000 7,000 8,000 9,000 matrix size Matrix-Matrix Multiplication (MMM) on 2 x Core 2 Duo 3 GHz Gflop/s Systems Programming 2025 Ch. 1: Introduction 51 • Why? Blocking or tiling, loop unrolling, array scalarization, instruction scheduling, … • Effect: less register spills, less L1/L2 cache misses, less TLB misses Memory hierarchy and other optimizations: 20x Vector instructions: 4x Multiple threads: 4x Inconvenient truth: Memory is not a nice array that stores your data The details of memory • Memory is not unbounded • It must be allocated and managed • Many applications are memory-dominated • Memory performance is not uniform • Cache and virtual memory effects can greatly affect program performance • Adapting program to characteristics of memory system can lead to major speed improvements • Memory is typed • Different kinds of memory behave differently • Sometimes memory isn’t even memory. Systems Programming 2025 Ch. 1: Introduction 53 Memory-related bugs are still a nightmare. Systems Programming 2025 Ch. 1: Introduction 54 typedef struct { int a[2]; double d; } struct_t; double fun(int i) { volatile struct_t s; s.d = 3.14; s.a[i] = 1073741824; /* Possibly out of bounds */ return s.d; } fun(0) –> 3.14 fun(1) –> 3.14 fun(2) –> 3.1399998664856 fun(3) –> 2.00000061035156 fun(4) –> 3.14 fun(6) -> Segmentation fault Actual results are system-specific… Source code: chapter 1 → memory_bug Memory referencing bug Systems Programming 2025 Ch. 1: Introduction 55 typedef struct { int a[2]; double d; } struct_t; Location accessed by fun(i) Explanation: Critical State 6 ? 5 ? 4 d7 ... d4 3 d3 ... d0 2 a[1] 1 a[0] 0 struct_t fun(0) –> 3.14 fun(1) –> 3.14 fun(2) –> 3.1399998664856 fun(3) –> 2.00000061035156 fun(4) –> 3.14 fun(6) -> Segmentation fault Source code: chapter 1 → memory_bug Memory system performance • Hierarchical memory organization • Performance depends on access patterns • Including how step through multi-dimensional array Systems Programming 2025 Ch. 1: Introduction 56 void copyji(int src[2048][2048], int dst[2048][2048]) { int i,j; for (j = 0; j < 2048; j++) for (i = 0; i < 2048; i++) dst[i][j] = src[i][j]; } void copyij(int src[2048][2048], int dst[2048][2048]) { int i,j; for (i = 0; i < 2048; i++) for (j = 0; j < 2048; j++) dst[i][j] = src[i][j]; } 5.2 ms 162 ms ! Intel Core i7 2.7 GHz Source code: chapter 1 → copyij The Memory Mountain Systems Programming 2025 Ch. 1: Introduction 57 Intel Core i7 2.67 GHz 32 KB L1 d-cache 256 KB L2 cache 8 MB L3 cache 128m 32m 8m 2m 512k 128k 32k 0 2000 4000 6000 8000 10000 12000 14000 16000 s1 s3 s5 s7 s9 s11 Size (bytes)Read throughput (MB/s) Stride (x8 bytes) copyij copyji What does *p = v do? Let’s ask the compiler. • Intel/AMD 64-bit x86: movq %rsi, (%rdi) • ARMv8-A: str x1, [x0] • RISC-V RV64I: sd a1, 0(a0) To a naive application programmer, this just sets a memory location to a value. Systems Programming 2025 Ch. 1: Introduction 58 $ cat t.c #include <stdint.h> void store(uint64_t *p, uint64_t v) { *p = v; } $ gcc -O2 -S t.c $ more t.s … store: … movq %rsi, (%rdi) ret … $ To a systems programmer, there are many possibilities: • Cache hit and sets a dirty bit in the cache • Cache hit, global invalidate • Cache miss, write allocate, and evicts another line • Cache miss, write-through • Cache miss, fetch from another cache in exclusive mode • TLB hit, mark page dirty • TLB hit, mark page accessed • TLB miss and hardware fill • TLB miss, software exception • Page fault, page not present • Page fault, protection fault • Write page table entry, change virtual memory mappings Systems Programming 2025 Ch. 1: Introduction 59 usw., usw…. Or it might not even be memory! • Bus fault exception, precise or imprecise • Device register, initiate I/O operation • Send inter-processor interrupt • Change virtual memory page table base register • Send cache transaction to an I/O device Systems Programming 2025 Ch. 1: Introduction 60 Inconvenient truth: Computers don’t just execute programs Programs don’t just calculate values Computers don’t just run programs • They need to get data in and out • I/O critical to program reliability and performance • Sense the physical world • Act in the physical world • They communicate over networks • Many system-level issues arise with a network • Concurrent operations by autonomous processes • Coping with unreliable media • Cross-platform interoperability • Complex performance issues Systems Programming 2025 Ch. 1: Introduction 62 Lies our teachers tell us… Systems Programming 2025 Ch. 1: Introduction 63 Computer Systems, A Programmer's Perspective, Bryant & O'Hallaron, 2011 Interesting times… • Processors are not getting faster. • Performance-wise, progress in computer architecture has halted. • In fact, it’s going backwards due to security concerns. Systems Programming 2025 Ch. 1: Introduction 64 Interesting times… • Lots of companies, universities, etc. are building new kinds of computers. • How can these be programmed? • This is a systems software problem. Systems Programming 2025 Ch. 1: Introduction 65 A modern(ish) System-on-Chip Systems Programming 2025 Ch. 1: Introduction 66 Something else runs on all these Android runs here • Cavium / Marvell ThunderX-1 NP: • 48 x ARMv8 cores at 2GHz • 128 GB DDR4 • 2 x 40Gb/s network • Xilinx UltraScale+ VU9P • 512 GB DDR4 • 4 x 100 Gb/s network • NVMe, SATA, PCIe on both sides • Native coherence between FPGA and CPU Systems Programming 2025 Ch. 1: Introduction 67 Computers are looking different! Inconvenient truth: Programs are not semantic specifications The role of “standards” • Language standards aim to specify unambigously what any program in the language does when compiled and executed. • Java: “write once, run anywhere” • Formal semantics • The C standards should be viewed as rather different • Behavior frequently described as “implementation dependent” • What does this mean? 69Systems Programming 2025 Ch. 1: Introduction “Implementation defined” “unspecified behavior where each implementation documents how the choice is made” At least two interpretations: • Compiler is allowed to do anything, so optimizes out the code completely • Compiler implements the most natural mapping to the target hardware and documents this. Systems Programming 2025 Ch. 1: Introduction 70 Default behavior for newer C compilers  Default behavior for older C compilers, and What You Actually Want. The role of “standards” • Language standards aim to specify unambigously what any program in the language does when compiled and executed. • Java: “write once, run anywhere” • Formal semantics • The C standards should be viewed as rather different • Behavior frequently described as “implementation dependent” • What does this mean? A program is a set of instructions to a compiler that tell it what assembly language to generate. 71Systems Programming 2025 Ch. 1: Introduction","libVersion":"0.5.0","langs":""}