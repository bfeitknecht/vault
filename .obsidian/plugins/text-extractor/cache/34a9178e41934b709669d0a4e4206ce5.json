{"path":"sem4/CN/UE/s/CN-u11-s.pdf","text":"Exercise 11: Algorithms, Linear Programming, and Bloom Filters Question 1: Max flow in data centers Figure 1 shows a network of 4 data centers. The data centers can generate and receive the following amounts of traffic: • DC1: 3Gbps • DC2: 2Gbps • DC3: 2Gbps • DC4: 5Gbps Every data center can send arbitrary traffic to any other data center in the network. For communication, a pair of data centers use the shortest path only. If there are paths of the same length, a pair of data centers will pick only one of them. The links are assumed to be full duplex link; i.e., if their capacity is c, then a traffic rate of c can be sent simultaneously in both directions. What should be the capacity of the red link in order to accommodate any possible traffic matrix? How to solve the same problem for an arbitrary network? Solution: The capacity that has to be supported is 5 Gbps. For an arbitrary network and the target link, we first have to calculate all the shortest paths that traverse the link. If we then compute the max-flow over the shortest paths that traverse the target link, we will get the worst-case capacity that supports an arbitrary traffic matrix. The max-flow can be computed in the following way: 1 1. Construct a new graph where nodes are data centers that communicate over the target link. 2. Next, connect data centers that want to communicate to each other with links of infinite capacity. 3. Note that the resulting graph is bipartite: if the target link is on the shortest path between A and B ond on the shortest path between A and C, it cannot be on the shortest path between B and C. This allows us to define a subset of nodes that send traffic (left) and a set of receiving nodes (right). 4. After making this separation, we add two fake nodes, one source, and one destination and connect them to existing nodes as follows: We connect all the left data centers to the source with links which capacity is equivalent to data center capacity. The destination is connected to the right data centers following the same principle. What remains is to calculate max-flow between new source and destination. The new graph constructed for the example in Fig. 1 is shown in Fig. 2. Note that the same procedure can be applied on every link in the network, for any topology, number of data centers and their capacity. Question 2: Shortest-path routing You are an ISP that operates the Internet2 network in the US (shown in Fig. 3). Would you use shortest-path routing to route the traffic? Explain your answer. 2 Solution: If the capacity of your network is significantly higher than the demand, then the shortest-path routing would be a good solution. However, if the network is reasonably utilized, and only the shortest path is used, there is a high probability of some links being congested while other links remain idle. This can be solved partially using equal-cost multipath (ECMP) routing. At the other end of the spectrum lie MinMax routing schemes, which minimize the maximum link utilization, and thus prevent congestion at the cost of longer paths. An optimal system needs to find a good point in this tradeoff (short paths vs. uniform load). Question 3: Graph Algorithms Consider a transmission between A and B within the network depicted in the Figure below. Question 3.1 Latency The numbers on the links, fi, correspond to the propagation delay of that respective link in ms. Compute the path with lowest latency from A to B neglecting all other delays. Which algorithm can you use for this problem? 3 Network Topology with propagation delay of links, fi Solution: The best achievable latency is 8. A path achieving this is A,C,D,B. Dijkstra’s algorithm can compute the shortest path for positive weights. Question 3.2 Bandwidth Consider the same figure as in 4.1. Now the numbers on the links, fi, correspond to the available bandwidth of that respective link in Mbps. Compute the path with highest possible bandwidth from A to B. Describe an algorithm that can solve this problem (in words or in pseudocode). Solution: The maximum bandwidth for any transmission in this network is 3 Mbps since this is the maximum bandwidth of all links in the network. This bandwidth is archived by the path A,F,G,B. Note that since bandwidth of different links does not add up, the bandwidth of a path is given by the minimal bandwidth of all the edges on the path. We can construct a Dijkstra-like algorithm that solves this problem. We can use the same principle as in Dijkstra but instead of summing up weights we take the minimum of a node’s maximum achievable bandwidth and the weight of the link. The algorithm looks like this: 1. Initialize the achievable “bandwidth” bX for all X ∈ V to zero, except bA, which is set to infinity. The current best path from A to X can achieve the maximum bandwidth bX . 2. Choose the node with highest value bX and set this node to “visited” or “best path found”. Afterwards we relax all of its neighbors. Assume neigh- bor N has the value bN then the new value is bN = max(bN , min(bX , fXN )). That is we choose the maximum between the best currently achievable bandwidth bN and the bandwidth of the path from X to N which is min(bX , fXN )) 4 3. If we choose the path from X to N (if bN < min(bX , fXN )) then we store the predecessor of N as X. 4. If there are unvisited nodes left repeat at 2 Question 3.3 Reliability Consider the same figure as in 4.1. Now the numbers on the links, fi, correspond to the probability that the respective link may fail in percent; for example, the link AF has a failure probability of 3%. We assume link failures to be independent from each other. How could you find the most reliable path from A to B? Hint: Define appropriate weights based on the fi and use Dijkstra’s algorithm. Which link weights are additive and usable for Dijkstra? Solution: Recall that Dijkstra’s Algorithm computes the path where the sum of individual weights is minimal. To be applicable, the property that is encoded in the weights needs to be additive: the sum of weights of a path actually needs to correspond to the property of the whole path. For example, this works well for distances as the distance of a path is indeed given by the sum of the individual distances. Unfortunately, this is not the case for failure probabilities: The failure probability of a path consisting of two links is F[1,2] = 1 − (1 − f1) · (1 − f2) = f1 +f2 − f1f2 ̸= f1 + f2. We need to define weights in such a way that they are indeed additive. First, we observe that the availability probabilities ai = 1 − fi are multiplicative, i.e., A[1,2] = a1 · a2. By taking the logarithm, we can change this multiplication into an addition: ln(A[1,2]) = ln(a1 · a2) = ln a1 + ln a2. As we want to maximize availability when Dijkstra minimizes the sum of weights, we need to multiply with −1 and finally obtain weights wi = − ln(1 − fi), see the Figure below. 5 Network Topology with modified link weights, wi = − ln(1 − fi) Running Dijkstra on this graph, we find the shortest path (A, C, D, B) with a total weight of W ≈ 0.081, corresponding to an availability A = e −W ≈ 0.922 = 92.2% and a failure probability F = 1 − A ≈ 0.078 = 7.8% . Note that this path actually corresponds to what one could consider the shortest paths from A to B if the numbers in the exercise were distances. This is not simply a coincidence but comes from the fact that ln(1 + x) ≈ x for |x| ≪ 1 and thus wi ≈ fi for small values of fi. This is clearly visible when comparing both Figures. Still, this is not true in general: Consider a path 1 consisting of 20 links with f1 = 1% each and a second path 2 consisting of a single link with f2 = 19%. Looking at f as distances, we would consider path 2 to be the shorter path. Looking at availabilities, however, we get A2 = 1 − f2 = 81% while A1 = (1 − f1)20 ≈ 81.8%, i.e., path 1 is favorable. Question 4: True or False For each of the following statements indicate for each if it is true or false. 1. BFS is never a viable algorithm choice to solve the shortest path problem. 2. The shortest widest path (SWP) weight criteria fulfills the isotonicity property. 3. The widest shortest path (WSP) weight criteria fulfills the isotonicity property. 4. The Ford-Fulkerson Algorithm can be used to find out how reliable a network is. Solution: 1. False: BFS can be used in unweighted graphs, or in graphs where every edge has the same weight. 6 2. False: For example in the graph below we can see that B-A-D is better than B-D, but S-B-D is better than S-B-A-D. 3. True: the WSP weight criteria does fulfill the isotonicity property (see last paragraph of section 3.2 in [1]) 4. True: the Ford-Fulkerson algorithm can be used to find the min-cut of the network, and thus how many links can fail before connectivity breaks. [1] João Luís Sobrinho, & Ferreira, M. A. (2020). Routing on multiple optimality criteria. In Proceedings of the ACM SIGCOMM Conference. https://dx.doi.org/10.1145/3387514.3405864. Question 5: Linear Programming In this question, let’s look at the LP formulation of the max-flow linear program presented in the lecture. Variables: 7 • Flow S → T : f • Flow on edge u → v : fuv Objective: • maximize f Notation: • F (v) = ∑ w∈E+(v) fvw − ∑ u∈E−(v) fuv Constraints: 1. Edge capacities: ∀u → v ∈ E : • 0 ≤ fuv • fuv ≤ cuv 2. Flow from S: f = F (S) 3. Flow conservation: ∀v ∈ V \\ {S, T } : F (v) = 0 Question 5.1 Canonical form Write the max-flow linear program above in the canonical form of an LP. In particular, specify: • the vector of variables x = (x1, ..., xn) T , x ≥ 0 • the maximization coefficients for the objective function c = (c1, ..., cn)T , where Θ = cT · x is maximized • the unequality constraints in the form of m × n matrix A and the vector b = (b1, ..., bm) T , where A · x ≤ b Solution: In the following, we use n = |V | and m = |E|. In order to translate our problem into the canonical form, we have to define an ordering of the edges, such that each edge u → v ∈ E is assigned an index between 1 and m. Let the function index(e), where e ∈ E define such an ordering. In this solution, the (outgoing) edges are ordered lexicographically based on the source and destination node. However, any ordering works. Based on this ordering, let us define a function conservation_vector(x), where x ∈ V . This function returns a vector of size m where each entry corresponding to an edge leaving node x is equal to 1, each entry corresponding to an edge ending in x is equal to -1, and other entries are 0. Variables (vector x) 8 x is a vector of size m describing the flow per (directed) edge, with fe = xindex(e), i.e., x = fac, faf , fbd, fbg, ... Objective function (vector c) c is a vector of size m generated by the function conservation_vector(S). This means ci = 1 if xi corresponds to a flow with the source S, otherwise ci = −1. Constraints (matrix A and vector b) Note that we have removed the variable f and integrated the corresponding constraint into the objective function. Consequently, the second constraint is already included in the calculation of the vector c above. The first constraint (minimum and maximum flow capacities) and third constraint (flow conservation) are constructed as follows. 1. The constraint that all variables are non-negative is an implicit part of any LP in canonical form. (If that were not the case, we could ensure non-negative flows by Amincap = −Im (where Im is the identity matrix of size m × m) and bmincap = 0m (where 0m is the zero vector with m entries). 2. To ensure that no edge is overused, we use the identity matrix of size m as the matrix and use the respective edge capacities as the right-hand side vector. • Amaxcap = Im • b maxcap index(x,y) = cxy 3. For the third constraint, the incoming and outgoing flow must be identical for each node (except the source and destination nodes (S, T ). As this is an equality constraint, we need to replace it with two inequality constraints. • Aminflow x = conservation_vector(x), for x ∈ V \\ {S, T } • bminflow = 0n−2 • Amaxflow = −Aminflow • bmaxflow = 0n−2 Finally, we can construct the final matrix A and vector b by stacking these constraints on top of each other combine these constraint sets to achieve the final constraint (we ignore the first implicit constraint here): • A =   Amaxcap Aminflow Amaxflow   • b =   bmaxcap bminflow b maxflow   9 The matrix A has a size of [m + 2(n − 2)] × m, the vector b has m + 2(n − 2) entries. Question 5.2 Implementation (optional) Implement the max-flow linear program by yourself (e.g., using python’s scipy library) and verify that it indeed finds the correct solution for the maximum bandwidth of the network presented in question 3.2. You can use the maxflow-template.py to get started. The relevant scipy docu- mentation can be found here. Solution: See maxflow.py Question 6: Bloom Filters The memory footprint of Bloom filters is so small that they can fit into devices with very limited memory like network switches or network cards (NIC). Give 2 potential applications for Bloom filters on these platforms. Solution: • Bloom filters are used for pre-filtering. If there is a cache server, a bloom filter can be implemented on the NIC to filter out requests for entries that are certainly not in cache and thus, reduce latency and the overall load on the server’s CPU. • Bloom filters are used in network switches to track specific information about network flows. Also, instead of deploying a filter on a NIC, the filter can be installed on a switch that connects multiple cache servers. Thus, the same effect can be achieved as in the previous example, just at the switch, which further improves the latency. Question 7: Bloom Filter duplicate detection In the context of network monitoring, Bloom filters can be used to quickly find duplicates. Our duplicate detection system is comprised of two filter, B0 and B1. We divide the time in intervals ∆, which must be greater than the maximum propagation time of packets δ. We ignore time sync errors for simplicity. At the beginning of each interval, one of the two filters is reset and is filled with new packets, while the other one is frozen. For each new packet, both filters are checked for duplicates. Question 7.1 What kind of answers does a Bloom filter give? Solution: 10 A Bloom filter is built to answer with surely not present or possibly present, that is it will give the requester false positives but never false negatives. To be very concise, if it says no, it means no. Question 7.2 Why does ∆ need to be bigger than δ? What happens if a packet that is older than the two periods is received? Solution: The choice of ∆ should prevent very old packets from arriving at the destination router. In fact, if a packet older than 2∆ arrives, the Bloom filters will have been both reset, so detection will fail. If such a packet arrives, it is dropped. Question 7.3 Assume the k hash functions are not correlated and the probabilities of single bit values are not correlated either. What is the probability of a false positive after inserting n elements into a bloom filter of size m? Solution: After the n insertions, we get a new element that is not in the filter. For a false positive to happen, we would need to have all k bits already set to 1. By independence: P [F P ] = (1 − [ 1 − 1 m ]nk)k 11","libVersion":"0.5.0","langs":""}