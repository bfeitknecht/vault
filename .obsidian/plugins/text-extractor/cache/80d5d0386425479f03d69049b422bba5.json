{"path":"sem4/FMFP/PV/exams/-30finals/FMFP-FS20.pdf","text":"Formal Methods and Functional Programming Final Exam, 2020 August 10, 2020, 15:00 – 18:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 21 pages; the back page of this booklet is page 21. After the exam begins, check that your exam papers are complete (4 assignments for the FP part, 4 assignments and 2 pages of background material for the FM part). 2. You may complete the assignments in any order. We recommend spending roughly half of your time on each of the two parts of the exam. 3. Only write on the exam paper and extra paper sheets which are given by the assistants. Do not take any of this paper out of the exam: submit it all. Write your ﬁrst and last name and your student number on every sheet of paper that you write on. 4. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 5. For the FP part of the exam, you may use any functions from the Haskell Prelude in your solutions (without giving their deﬁnitions), unless speciﬁed otherwise. You also may use any function from one subproblem to solve the subsequent subproblems, even if you have not provided a deﬁnition for the function itself. 6. Write clearly in the sense of logic, language, and readability. Label all rule applications in your derivation trees. The clarity of your arguments and explanations aﬀects your grade. 7. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 8 ∑ Max 10 10 7 13 6 14 12 8 80 Points Part I Functional Programming Formal Methods and Functional Programming, Final Exam, 2020 3 Assignment 1: Typing (10 Points) Task 1.A (3 Points) Recall the following functions from the Haskell libraries. map :: (a -> b) -> [a] -> [b] ($) :: (a -> b) -> a -> b (==) :: Eq a => a -> a -> Bool Determine whether the following expressions are well-typed or not. If so, then state the most general type; otherwise justify informally why the expression is not typable. i) \\x y -> \\z -> y z x ii) map ($ []) iii) \\x y -> y x == y Assignment 1 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2020 4 Task 1.B (7 Points) Recall the proof rules for the Mini-Haskell type system: Var . . . , x : τ, . . . ⊢ x :: τ Γ, x : σ ⊢ t :: τ Abs Γ ⊢ λx. t :: σ → τ Γ ⊢ t1 :: σ → τ Γ ⊢ t2 :: σ App Γ ⊢ t1 t2 :: τ Int Γ ⊢ n :: Int True Γ ⊢ True :: Bool False Γ ⊢ False :: Bool Γ ⊢ t :: Int iszero Γ ⊢ iszero t :: Bool Γ ⊢ t1 :: Int Γ ⊢ t2 :: Int BinOp Γ ⊢ (t1 op t2) :: Int for op ∈ {+, ∗} Γ ⊢ t0 :: Bool Γ ⊢ t1 :: τ Γ ⊢ t2 :: τ if Γ ⊢ if t0 then t1 else t2 :: τ Γ ⊢ t1 :: τ1 Γ ⊢ t2 :: τ2 Tuple Γ ⊢ (t1, t2) :: (τ1, τ2) Γ ⊢ t :: (τ1, τ2) fst Γ ⊢ fst t :: τ1 Γ ⊢ t :: (τ1, τ2) snd Γ ⊢ snd t :: τ2 Formally infer the most general type of the following expression using the Mini-Haskell typing rules. Label every proof step with the name of the used rule and list the arising constraints explicitly. ⊢ (λx. λy. iszero ((snd y) (x y)) ) ( λx. fst x) :: . . . Formal Methods and Functional Programming, Final Exam, 2020 5 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2020 6 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2020 7 Assignment 2: Data Types and Proofs (10 Points) The datatype Direction represents a direction that can be either left or right: data Direction = L | R The datatype Path represents a sequence of nodes that ends with the constructor End. Each node is labeled with an integer and a direction. data Path = End | Node Int Direction Path Task 2.A (2 Points) i) Give the type of the canonical fold function foldPath on Path. ii) Deﬁne the canonical fold function foldPath on Path. Assignment 2 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2020 8 Task 2.B (8 Points) Consider the following Haskell declarations. opp :: Direction -> Direction opp L = R -- opp.1 opp R = L -- opp.2 mirror :: Path -> Path mirror End = End -- mirror.1 mirror (Node x d p) = Node x (opp d) (mirror p) -- mirror.2 invert :: Path -> Path -> Path invert p End = p -- invert.1 invert p (Node x d q) = invert (Node (-x) d p) q -- invert.2 Prove that for all ﬁnite paths p::Path the equality mirror (invert End p) = invert End (mirror p) holds. Structure your proof clearly and justify every proof step. Formal Methods and Functional Programming, Final Exam, 2020 9 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2020 10 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2020 11 Assignment 3: Programming with Lists (7 Points) A timed word of type [(Int,v)] is a (possibly inﬁnite) sequence that models a value changing over time. It consists of pairs (ts,val), called observations, where ts :: Int is an integer time-stamp and val :: v is a value. The time-stamps in a timed word appear in ascending order with possible repetitions. For example, the ﬁnite timed word [(1,3.4), (3,2.1), (3,1.9), (5,6.3)] has four numeric values 3.4, 2.1, 1.9, and 6.3 occurring at time-stamps 1, 3, 3, and 5, respectively. Task 3.A (2 Points) Write a function reps :: Int -> [(Int,v)] -> Int that takes a time-stamp and a ﬁnite timed word and returns the number of observations with that time-stamp, i.e., how often the time-stamp is repeated. For example: reps 3 [(1,3.4),(3,2.1),(3,1.9),(5,6.3)] = 2 reps 4 [(1,3.4),(3,2.1),(3,1.9),(5,6.3)] = 0 Assignment 3 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2020 12 Task 3.B (2 Points) Write a function maxReps :: [(Int,v)] -> Int that takes a ﬁnite, non-empty timed word and returns the largest number of observations with the same time-stamp. For example: maxReps [(1,3.4),(3,2.1),(3,1.9),(5,6.3)] = 2 Assignment 3 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2020 13 Task 3.C (3 Points) Now consider timed words with numeric values, i.e., timed words of type Num v => [(Int,v)]. Write a function psum :: Num v => [(Int,v)] -> [(Int,v)] that takes a timed word and produces another timed word with the values’ preﬁx sums. More precisely: The result must have the same number of observations with the same time-stamps as the input. The value of each observation in the result must be equal to the value at the corresponding position in the input, plus the sum of all previous values. Make sure that psum works correctly for inﬁnite timed words. For example: psum [(1,3.4),(3,2.1),(3,1.9),(5,6.3)] = [(1,3.4),(3,5.5),(3,7.4),(5,13.7)] Formal Methods and Functional Programming, Final Exam, 2020 14 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2020 15 Assignment 4: Arithmetic Expressions (13 Points) In this assignment you will write code for evaluating and simplifying arithmetic expressions. For the sake of this assignment, the syntax of arithmetic expressions is described by the grammar e ::= c | x | ∑[e, e, . . . , e] | let x = e in e, where c ∈ C is a constant from a set C of constants, x ∈ V is a variable from a set V of variable names, and [e, e, . . . , e] is a list of expressions. Given a valuation σ : V → C of variables, the value of an arithmetic expression v(σ, e) is deﬁned recursively as follows: v(σ, c) = c v(σ, x) = σ(x) v(σ, ∑ [e0, e1, . . . , en]) = n∑ i=0 v(σ, ei) v(σ, let x = e in e′) = v(σ[x := v(σ, e)], e ′) where σ[x := v(σ, e)] is the valuation obtained from σ by replacing the value of σ(x) by v(σ, e), i.e., σ[x := v(σ, e)](y) = { v(σ, e) if y = x, σ(y) otherwise. We say that two arithmetic expressions e, e ′ are equivalent if and only if v(σ, e) = v(σ, e′) holds for all valuations σ. We use the following types to model variable names, valuations, and arithmetic expressions, where the type variable a denotes the type of constants: type Name = String type Val a = Name -> a data Expr a = Con a | Var Name | Add [Expr a] | Let Name (Expr a) (Expr a) deriving Eq Assignment 4 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2020 16 Task 4.A (4 Points) Write a function eval :: Num a => Val a -> Expr a -> a that evaluates an arithmetic expression under a valuation according to the above deﬁnition of v(σ, e). For example: eval (\\_ -> 1) (Let \"x\" (Add [Var \"x\", Con 1]) (Var \"x\")) = 2 Assignment 4 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2020 17 Task 4.B (4 Points) Write a function flat :: Expr a -> Expr a that transforms an arithmetic expression into an equivalent one such that the list es in each subexpression of the form Add es does not directly contain any expression of the form Add fs. For example: flat (Add [Add [Con 1, Con 2], Var \"x\"]) = Add [Con 1, Con 2, Var \"x\"] Assignment 4 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2020 18 Task 4.C (5 Points) Write a function cp :: Num a => Expr a -> Expr a that performs constant propagation in an arithmetic expression. This means that the function transforms an arithmetic expression into an equivalent one such that • the list es in each subexpression of the form Add es contains at most one expression of the form Con c, and • each subexpression which is not of the form Con c contains a subexpression of the form Var x. For example: cp (Add [Add [Con 1, Con 2], Con 1, Var \"x\"]) = Add [Con 4, Var \"x\"] cp (Let \"x\" (Con 0) (Var \"x\")) = Let \"x\" (Con 0) (Var \"x\") cp (Let \"x\" (Con 0) (Add [Con 1, Con 1])) = Con 2 Formal Methods and Functional Programming, Final Exam, 2020 19 This page is intentionally left blank. Part II Formal Methods Formal Methods and Functional Programming, Final Exam, 2020 21 Assignment 5: Small-Step Semantics (6 Points) In this assignment, we consider extending IMP with the statement timeout s after e end, where s is a statement and e is an arithmetic expression. Intuitively, this timeout-statement executes e steps of the statement s and then times out: If the complete execution of s takes at most e steps then the statement s is executed entirely. Conversely, if the complete execution of s takes more than e steps then the resulting state should be the one obtained from executing the ﬁrst e steps of s. The expression e should be evaluated only once in the initial state. Give structural operational semantics (small-step) rules for such a timeout-statement. Formal Methods and Functional Programming, Final Exam, 2020 22 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2020 23 Assignment 6: Big-Step Semantics (14 Points) Let b1 and b2 be some Boolean expressions such that ∀σ · ( (B[[b1]]σ = tt) ⇔ (B[[b2]]σ = tt) ). (1) For the sake of shorter notation, we deﬁne w(b, s) ≡ while b do s end, for all boolean expressions b and all statements s. Using natural (big-step) semantics, prove that ∀s, σ, σ′ · (⊢ ⟨w(b2, s), σ⟩ → σ′ ⇒ ⊢ ⟨w(b1, s);w(b2, s), σ⟩ → σ′). Formal Methods and Functional Programming, Final Exam, 2020 24 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2020 25 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2020 26 Assignment 7: Axiomatic Semantics (12 Points) Consider the statement s ≡ while n > 0 do b := a + b;a := b - a;n := n - 1 end. Construct a proof outline that proves the Hoare triple { a = 0 ∧ b = 1 ∧ n ≥ 0 ∧ n = N } s { ⇓ a = f (N ) }, where f : N → N is a function deﬁned by f (i) = { i if i ≤ 1 f (i − 2) + f (i − 1) otherwise. Formal Methods and Functional Programming, Final Exam, 2020 27 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2020 28 Assignment 8: Modelling (8 Points) A farmer went to the market and is on the way back home, with him he has a fox, a chicken, and some grain. He has to cross a river using a small boat only big enough for him and one other item. If the fox is left alone with the chicken the fox will eat it. If the chicken is left alone with the grain the chicken will eat it. Neither the fox, the chicken, nor the grain can cross the river without the farmer. The goal of this assignment is to model the aforementioned scenario in Promela and use a model checker to ﬁnd out whether it is possible for the farmer to make it home with all three of his items. Consider the following partial Promela model: bool success = 0 /* success flag */ bool failure = 0 /* failure flag */ inline step() { /* implement me (1) */ } inline check() { /* implement me (2) */ } init { do :: failure -> /* (3) */ :: success -> /* (4) */ :: else -> step(); check() od } Task 8.A (6 Points) Provide appropriate implementations for the step() and check() macros. You may introduce additional variables and macros to do so. • The step() macro should model all possible steps the farmer can perform, i.e., cross the river with an item or cross the river on his own. Your model should reﬂect the positions of the farmer and the three items. Brieﬂy explain how you model these positions. • The check() macro should set the success ﬂag to 1 if the farmer made it to the other side of the river with all three items. Moreover, it should set the failure ﬂag to 1 if the fox is left unattended with the chicken or the chicken is left unattended with the grain. Assignment 8 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2020 29 Assignment 8 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2020 30 Task 8.B (2 Points) Can we use a model checker (such as Spin) to verify whether there is a strategy for the farmer to make it home with all three items? If your answer is “yes”, brieﬂy explain the necessary additions or changes to the code of the Promela model, and why your approach works. If your answer is “no”, brieﬂy explain why it is not possible. Note: You may solve this task without having solved Task 8.A by assuming appropriate implementations for the step() and check() macros. Formal Methods and Functional Programming, Final Exam, 2020 31 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ::= skip | x := e | s;s | if b then s else s end | while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). Big-Step Semantics (SkipN S) ⟨skip, σ⟩ → σ (AssN S) ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ → σ′ ⟨s2, σ′⟩ → σ′′ (SeqN S) ⟨s1;s2, σ⟩ → σ′′ ⟨s1, σ⟩ → σ′ (IfTN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = tt ⟨s2, σ⟩ → σ′ (IfFN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = ﬀ ⟨s, σ⟩ → σ′ ⟨while b do s end, σ′⟩ → σ′′ (WhTN S) ⟨while b do s end, σ⟩ → σ′′ if B[[b]]σ = tt (WhFN S) ⟨while b do s end, σ⟩ → σ if B[[b]]σ = ﬀ Formal Methods and Functional Programming, Final Exam, 2020 32 Small-Step Semantics (SkipSOS) ⟨skip, σ⟩ →1 σ (AssSOS) ⟨x := e, σ⟩ →1 σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ →1 σ′ (Seq1SOS) ⟨s1;s2, σ⟩ →1 ⟨s2, σ′⟩ ⟨s1, σ⟩ →1 ⟨s′ 1, σ′⟩ (Seq2SOS) ⟨s1;s2, σ⟩ →1 ⟨s′ 1;s2, σ′⟩ (IfTSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s1, σ⟩ if B[[b]]σ = tt (IfFSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s2, σ⟩ if B[[b]]σ = ﬀ (WhileSOS) ⟨while b do s end, σ⟩ →1 ⟨if b then s; while b do s end else skip end, σ⟩ Axiomatic Semantics (Partial Correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ↦→ e] } x := e { P } { P } s1 { R } { R } s2 { Q } (SeqAx) { P } s1;s2 { Q } { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P ′ } s { Q′ } (ConsAx) { P } s { Q } if P ⊨ P′ and Q′ ⊨ Q Axiomatic Semantics (Total Correctness) Rules are as for partial correctness above, except for the following rule, which replaces WhAx: { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ⊨ 0 ≤ e where Z is a fresh logical variable (not used in P).","libVersion":"0.5.0","langs":""}