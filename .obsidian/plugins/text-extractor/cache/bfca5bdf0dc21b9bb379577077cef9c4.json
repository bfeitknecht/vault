{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w02.pdf","text":"Schlegel Woche 2 – Übersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder Vollständigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne Gewähr.) Anmerkungen zu den Code-Expert Abgaben: Anmerkungen zu den Moodle Abgaben: • Insgesamt sehr schön gelöst. Mir sind keine besonderen Probleme aufgefallen. Alpha-Conversion: Kleiner First-Order-Logic (ich werde von nun an FOL schreiben) Recap: Wir arbeiten mit Termen und Formeln. Terme sind entweder Variablen 𝑥 ∈ 𝑉 oder (multivariate) Funktionen 𝑓𝑛(𝑡1, … , 𝑡𝑛) wobei 𝑡1, … , 𝑡𝑛 selbst Terme sind (Für 𝑛 = 0 handelt es sich um Konstanten, bspw. “4”). Formeln sind: ⊥ 𝑝𝑛(𝑡1, … , 𝑡𝑛), 𝑝 ∈ 𝑃 (Prädikate) 𝐴 ∘ 𝐵, 𝐴, 𝐵 ∈ 𝐹𝑜𝑟𝑚𝑒𝑙𝑛, ∘ ∈ {∧,∨, →} 𝑄𝑥. 𝐴, 𝐴 ∈ 𝐹𝑜𝑟𝑚𝑒𝑙𝑛, 𝑥 ∈ 𝑉, 𝑄 ∈ {∃, ∀} Wichtig: Quantifier reichen so weit wie möglich, also entweder bis zum Ende einer “Zeile” oder bis zu einer schliessenden Klammer “)”!!! Hier dazu ein hilfreiches Bild aus der VL: Gem. Vorlesung gilt für alle Variablen, dass sie entweder “bound” oder “free” sind: In diesem Beispiel aus der Vorlesung (Quelle: ND-Slides) sind die blauen Variablen “bound”, da sie in einer Subformel 𝐴 der Form ∃𝑥. 𝐵 bzw. ∀𝑥. 𝐵 vorkommen und die roten Variablen “free” (denen in einer Interpretation noch ein Wert zugewiesen werden muss, siehe Diskrete Mathematik). Solange wir nichts an der “binding structure” der Formel (also welche Variablen bound und welche free sind und durch welche Quantifier die bound variables gebunden werden) ändern, dürfen wir die Namen von bound Variables beliebig verändern. (→ Merke: “Binding Structure”: Welche Variablen bound, welche free sind und durch welche Quantifiers sie gebunden werden!!) Hier ein paar Aufgaben (von den Slides, die wir in der Übungsstunde gelöst haben): (Nächste Seite) __________________________________________________________________________________ (Wozu machen wir das eigentlich? Unter anderem für das bessere Verständnis von ND-Proofs und Lambda-Expressions in Haskell (später mehr dazu)). Substitution: Wir schreiben 𝐴[𝑥 → 𝑡] für das Substituieren eines Terms 𝑡 für eine “free” Variable 𝑥, also für das Ersetzen aller Vorkommnisse von 𝑥 in 𝐴 durch 𝑡. Einfaches Beispiel: Sei 𝐴 ≡ ∀𝑥. 𝑝(𝑥) ∨ 𝑧. Dann ist 𝐴[𝑧 → 𝑦] ≡ ∀𝑥. 𝑝(𝑥) ∨ 𝑦 oder 𝐴[𝑧 → 𝑓(𝑣)] ≡ ∀𝑥. 𝑝(𝑥) ∨ 𝑓(𝑣). Wichtig: Die “free” Variablen in dem Term 𝑡 müssen auch nach der Substitution “free” bleiben! Sehen können wir das Anhand unseres Beispiels von oben: Für 𝑡 ≔ 𝑥 gilt, dass 𝑥 “free” ist, also gibt es bei der Subsitution 𝐴[𝑧 → 𝑥] ≡ ∀𝑥. 𝑝(𝑥) ∨ 𝑥 offensichtlich ein Problem, da das “zweite” 𝑥 nun “bound” ist! ➔ Lösung: Erst 𝛼-conversion anwenden, dann Substituieren! Hier also: Erst 𝛼-conversion: 𝐴 ≡ ∀𝑣. 𝑝(𝑣) ∨ 𝑧 und dann substituieren: 𝐴[𝑧 → 𝑥] ≡ ∀𝑣. 𝑝(𝑣) ∨ 𝑥. Erweiterung unserer ND-Regeln für FOL: Zunächst müssen wir uns noch einmal daran erinnern, dass Quantifier so weit wie möglich (also bis zum Ende einer Zeile oder bis zu einer schliessenden Klammer) reichen, das heisst wir könnten die Regel →-I nicht für die Formel ∀𝑥. 𝑃 → 𝑄 anwenden, da hier eigentlich ∀𝑥. (𝑃 → 𝑄) steht. (Achtung: Das wurde in anderen Kursen (Diskrete Mathematik) eventuell anders gelehrt!). Das hier haben wir “anfangs” So schreiben wir die Formel um Wir führen vier neue Regeln (je eine Elimination und eine Introduction) für die beiden Quantifier, die im Gegensatz zu Prädikatenlogik bei der FOL neu sind, ein: __________________________________________________________________________________ Einzelne kurze Erklärungen (Ich erkläre die Regeln immer “von oben nach unten”, also in der Reihenfolge, wie man einen ND-Proof lesen – aber nicht schreiben – würde) zu den interessanten 3: Zunächst betrachten wir die Regeln ∀ − 𝐼∗ und ∃ − 𝐸∗∗: Wenn aus unseren Annahmen folgt, dass 𝐴 gilt, können wir herleiten, dass aus unseren Annahmen folgt, dass 𝐴 für alle 𝑥 gilt bzw. Wenn aus unseren Annahmen folgt, dass ein 𝑥 existiert, sodass 𝐴 gilt, und aus unseren Annahmen und 𝐴 folgt, dass 𝐵 gilt, dann können wir herleiten, dass aus unseren Annahmen 𝐵 folgt. Wichtig: Warum müssen die jeweiligen Nebenbedingungen gelten? Hier gibt es eine sehr schöne Erklärung: https://math.stackexchange.com/questions/1819976/natural-deduction- introduction-of-universal-quantifier-and-elimination-of-exist (zweite Antwort, @dankness) Kurz gesagt: Ohne die NB kann es passieren, dass wir aus einer “Aussage” über ein spezifisches Objekt (die freie Variable 𝑥) eine allgemeine Aussage schliessen. Nun betrachten wir die Regel ∀ − 𝐸: Wenn aus unseren Annahmen folgt, dass 𝐴 für alle 𝑥 gilt, dann können wir herleiten, dass aus unseren Annahmen folgt, dass 𝐴 auch gilt, wenn man 𝑥 durch einen beliebigen Term substituiert (da 𝐴 ja für alle 𝑥 gilt). Achtung: Eventuell muss man zunächst 𝛼- conversion anwenden, um eine Änderung der binding structure zu vermeiden. Beispiel von Sofia’s Slides: Hier ein Beispiel von Sofias Slides, wie wir die Regel ∀ − 𝐸 häufig verwenden: Und hier nun die Aufgaben von den Slides mit Lösungen (die wir in der Übungsstunde gelöst haben): Haskell Rekursion – Fortgeschritten(er): Die Funktionen, die wir in der Übungsstunde implementiert haben:","libVersion":"0.5.0","langs":""}