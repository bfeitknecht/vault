{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w02.pdf","text":"Schlegel Woche 2 â€“ Ãœbersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder VollstÃ¤ndigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne GewÃ¤hr.) Anmerkungen zu den Code-Expert Abgaben: Anmerkungen zu den Moodle Abgaben: â€¢ Insgesamt sehr schÃ¶n gelÃ¶st. Mir sind keine besonderen Probleme aufgefallen. Alpha-Conversion: Kleiner First-Order-Logic (ich werde von nun an FOL schreiben) Recap: Wir arbeiten mit Termen und Formeln. Terme sind entweder Variablen ğ‘¥ âˆˆ ğ‘‰ oder (multivariate) Funktionen ğ‘“ğ‘›(ğ‘¡1, â€¦ , ğ‘¡ğ‘›) wobei ğ‘¡1, â€¦ , ğ‘¡ğ‘› selbst Terme sind (FÃ¼r ğ‘› = 0 handelt es sich um Konstanten, bspw. â€œ4â€). Formeln sind: âŠ¥ ğ‘ğ‘›(ğ‘¡1, â€¦ , ğ‘¡ğ‘›), ğ‘ âˆˆ ğ‘ƒ (PrÃ¤dikate) ğ´ âˆ˜ ğµ, ğ´, ğµ âˆˆ ğ¹ğ‘œğ‘Ÿğ‘šğ‘’ğ‘™ğ‘›, âˆ˜ âˆˆ {âˆ§,âˆ¨, â†’} ğ‘„ğ‘¥. ğ´, ğ´ âˆˆ ğ¹ğ‘œğ‘Ÿğ‘šğ‘’ğ‘™ğ‘›, ğ‘¥ âˆˆ ğ‘‰, ğ‘„ âˆˆ {âˆƒ, âˆ€} Wichtig: Quantifier reichen so weit wie mÃ¶glich, also entweder bis zum Ende einer â€œZeileâ€ oder bis zu einer schliessenden Klammer â€œ)â€!!! Hier dazu ein hilfreiches Bild aus der VL: Gem. Vorlesung gilt fÃ¼r alle Variablen, dass sie entweder â€œboundâ€ oder â€œfreeâ€ sind: In diesem Beispiel aus der Vorlesung (Quelle: ND-Slides) sind die blauen Variablen â€œboundâ€, da sie in einer Subformel ğ´ der Form âˆƒğ‘¥. ğµ bzw. âˆ€ğ‘¥. ğµ vorkommen und die roten Variablen â€œfreeâ€ (denen in einer Interpretation noch ein Wert zugewiesen werden muss, siehe Diskrete Mathematik). Solange wir nichts an der â€œbinding structureâ€ der Formel (also welche Variablen bound und welche free sind und durch welche Quantifier die bound variables gebunden werden) Ã¤ndern, dÃ¼rfen wir die Namen von bound Variables beliebig verÃ¤ndern. (â†’ Merke: â€œBinding Structureâ€: Welche Variablen bound, welche free sind und durch welche Quantifiers sie gebunden werden!!) Hier ein paar Aufgaben (von den Slides, die wir in der Ãœbungsstunde gelÃ¶st haben): (NÃ¤chste Seite) __________________________________________________________________________________ (Wozu machen wir das eigentlich? Unter anderem fÃ¼r das bessere VerstÃ¤ndnis von ND-Proofs und Lambda-Expressions in Haskell (spÃ¤ter mehr dazu)). Substitution: Wir schreiben ğ´[ğ‘¥ â†’ ğ‘¡] fÃ¼r das Substituieren eines Terms ğ‘¡ fÃ¼r eine â€œfreeâ€ Variable ğ‘¥, also fÃ¼r das Ersetzen aller Vorkommnisse von ğ‘¥ in ğ´ durch ğ‘¡. Einfaches Beispiel: Sei ğ´ â‰¡ âˆ€ğ‘¥. ğ‘(ğ‘¥) âˆ¨ ğ‘§. Dann ist ğ´[ğ‘§ â†’ ğ‘¦] â‰¡ âˆ€ğ‘¥. ğ‘(ğ‘¥) âˆ¨ ğ‘¦ oder ğ´[ğ‘§ â†’ ğ‘“(ğ‘£)] â‰¡ âˆ€ğ‘¥. ğ‘(ğ‘¥) âˆ¨ ğ‘“(ğ‘£). Wichtig: Die â€œfreeâ€ Variablen in dem Term ğ‘¡ mÃ¼ssen auch nach der Substitution â€œfreeâ€ bleiben! Sehen kÃ¶nnen wir das Anhand unseres Beispiels von oben: FÃ¼r ğ‘¡ â‰” ğ‘¥ gilt, dass ğ‘¥ â€œfreeâ€ ist, also gibt es bei der Subsitution ğ´[ğ‘§ â†’ ğ‘¥] â‰¡ âˆ€ğ‘¥. ğ‘(ğ‘¥) âˆ¨ ğ‘¥ offensichtlich ein Problem, da das â€œzweiteâ€ ğ‘¥ nun â€œboundâ€ ist! â” LÃ¶sung: Erst ğ›¼-conversion anwenden, dann Substituieren! Hier also: Erst ğ›¼-conversion: ğ´ â‰¡ âˆ€ğ‘£. ğ‘(ğ‘£) âˆ¨ ğ‘§ und dann substituieren: ğ´[ğ‘§ â†’ ğ‘¥] â‰¡ âˆ€ğ‘£. ğ‘(ğ‘£) âˆ¨ ğ‘¥. Erweiterung unserer ND-Regeln fÃ¼r FOL: ZunÃ¤chst mÃ¼ssen wir uns noch einmal daran erinnern, dass Quantifier so weit wie mÃ¶glich (also bis zum Ende einer Zeile oder bis zu einer schliessenden Klammer) reichen, das heisst wir kÃ¶nnten die Regel â†’-I nicht fÃ¼r die Formel âˆ€ğ‘¥. ğ‘ƒ â†’ ğ‘„ anwenden, da hier eigentlich âˆ€ğ‘¥. (ğ‘ƒ â†’ ğ‘„) steht. (Achtung: Das wurde in anderen Kursen (Diskrete Mathematik) eventuell anders gelehrt!). Das hier haben wir â€œanfangsâ€ So schreiben wir die Formel um Wir fÃ¼hren vier neue Regeln (je eine Elimination und eine Introduction) fÃ¼r die beiden Quantifier, die im Gegensatz zu PrÃ¤dikatenlogik bei der FOL neu sind, ein: __________________________________________________________________________________ Einzelne kurze ErklÃ¤rungen (Ich erklÃ¤re die Regeln immer â€œvon oben nach untenâ€, also in der Reihenfolge, wie man einen ND-Proof lesen â€“ aber nicht schreiben â€“ wÃ¼rde) zu den interessanten 3: ZunÃ¤chst betrachten wir die Regeln âˆ€ âˆ’ ğ¼âˆ— und âˆƒ âˆ’ ğ¸âˆ—âˆ—: Wenn aus unseren Annahmen folgt, dass ğ´ gilt, kÃ¶nnen wir herleiten, dass aus unseren Annahmen folgt, dass ğ´ fÃ¼r alle ğ‘¥ gilt bzw. Wenn aus unseren Annahmen folgt, dass ein ğ‘¥ existiert, sodass ğ´ gilt, und aus unseren Annahmen und ğ´ folgt, dass ğµ gilt, dann kÃ¶nnen wir herleiten, dass aus unseren Annahmen ğµ folgt. Wichtig: Warum mÃ¼ssen die jeweiligen Nebenbedingungen gelten? Hier gibt es eine sehr schÃ¶ne ErklÃ¤rung: https://math.stackexchange.com/questions/1819976/natural-deduction- introduction-of-universal-quantifier-and-elimination-of-exist (zweite Antwort, @dankness) Kurz gesagt: Ohne die NB kann es passieren, dass wir aus einer â€œAussageâ€ Ã¼ber ein spezifisches Objekt (die freie Variable ğ‘¥) eine allgemeine Aussage schliessen. Nun betrachten wir die Regel âˆ€ âˆ’ ğ¸: Wenn aus unseren Annahmen folgt, dass ğ´ fÃ¼r alle ğ‘¥ gilt, dann kÃ¶nnen wir herleiten, dass aus unseren Annahmen folgt, dass ğ´ auch gilt, wenn man ğ‘¥ durch einen beliebigen Term substituiert (da ğ´ ja fÃ¼r alle ğ‘¥ gilt). Achtung: Eventuell muss man zunÃ¤chst ğ›¼- conversion anwenden, um eine Ã„nderung der binding structure zu vermeiden. Beispiel von Sofiaâ€™s Slides: Hier ein Beispiel von Sofias Slides, wie wir die Regel âˆ€ âˆ’ ğ¸ hÃ¤ufig verwenden: Und hier nun die Aufgaben von den Slides mit LÃ¶sungen (die wir in der Ãœbungsstunde gelÃ¶st haben): Haskell Rekursion â€“ Fortgeschritten(er): Die Funktionen, die wir in der Ãœbungsstunde implementiert haben:","libVersion":"0.5.0","langs":""}