{"path":"HS23/AuD/VRL/slides/AuD-s04-search-&sorting-algorithms.pdf","text":"SUCHENUNDSORTIEREN-su.de : Beispiel : Finde die Prüfung vo n Ma ria Müller in einem Stapel au s 600 Prüfungen . Problem ( Suche) : Input : Ein ArrayA mit n Einträgen ( bei uns : Zahlen) und ein Element b. Output : In der K mit ASK ] - _ er oder„ nicht gefunden \" Fa llt : A nicht sortiert → Algorithmus 1 ( Lineare Sache) : - = AH . . . n ] Array for i = 1 . . - n if Al i ] = b : retumirrtum „ nicht gefunden \" Laufzeit 0 (n ) Geht es besser ? NE IN , denn wir müssen jedes Element vo n A- anschauen , falls b nicht vorkommt . It al : A sortiert , A [ 1) ≤ Au s ≤ . _ . ≤ A [ n ] Atgorithmm2:Bin-uhe_ Binary Search (A , b) N für sortiertes A l : = 1, r : = n N A [ l . . - r ) gibt den Bereich an , in dem wir noch suchen müssen while l ≤ r do m : = CE I ✗auch floor ( ¥ ) : grösstegame Zahl ≤ e: if b = A [ mit : re tu m me if b < 1- [ mit : r : = m - 1 else : l : = mit retw m „ nicht gefunden \" Laufzeit : TCO) , T (1) = c konstant TC n ) ≤ T ( %) + d , d Konstant ↑ stillschweigend benutzt : Laufzeit wird höchstens grösser für längere Arrays. Behauptung : Tln ) ≤ ct d - login Beweis > Induktion ( Übung) Tcm ) -- Oclognl Geht es besser ? NEIN ! ( Wir nehmen hieran , dass die Suche durch Vergleiche ausgeführt wird) Beweis : Betrachte einen beliebigen Iuchalgorithmus als Entscheidungsbaum jeder Knoten 2-B.ie y<A[y# ist ein Vergleich Tiefe O : Kneten 1-[2×-113]>0 b= Tiefen : YES ↓ ◦ ≤ Zttnoten YES ↓ V0 ' : Tiefe 20 ≤ vermuten ↓ iüü \"iü|rüw① . gefunden \" ' i , Tiefen ↑ ≤ znitmctm Alle n -11 möglichen Outputs müssen vorkommen . Am ahl Vergleiche Gerrit une ) = Tiefe h Ein Baum der Tiefe h hat höchstens 1+2+4 + . . + 2h = 2h\" - 1 ≤ 2h \" Knoten ( genauere Rechnung : ≤ 2h irrtum \" - Knoten Daher gilt : mit = Ansahl Outputs ≤ Anzahl retum - Knoten ≤ 2 \" \" Wort - on e - Laufzeit ≥ h ≥ login + 1) - 1- = 0 ( lag n ) . ☒ Sortieren- Suche ist viel schneller auf sortierten Daten Wie sortieren wir Daten effizient ? Probbmckrtierenk.tn mit : ein Array A vo n n Zahlen Output : eine Permutation ( Unordnung) vo n A , die aufsteigend sortiert ist : Ali ] ≤ A [j ] für alle i , j c- { 1-in | mitiaj Elementare Operationen : - Vergleiche - Vertauschungen AGorithmus-Priifekrtiertha.tnSa tellit) forint .in - I if Ali ] > 1-[ itifretumfaheretwmt.me Laufzeit 0cm ) . AGorithmusi.Bubbles-Bubblesotltlforj-1.fr notwendig : üneinselnu Durchgang reicht nich t ( siehe Beispiel) fe ri-1.in - I if 1- [ i ] > 1- [ im ] tausche Ali ] und Ali -11] j :| f- 2 f- 3 f- 4 Beispiel : 53-714 3514 7 31457 13457 35-714 3-5147 -13457 1-3457 35 7-14 3-15-47 15457 13-457 35 171 3145 7 134-57 134-57 35 1 4 7 314-57 1345-7 13457 Laufzeit : Un ) Vergleiche 0cm ') Vertauschungen Wie können wir beweisen /einsehen , dass Bubblesat korrekt ist ? Idee : Finde geeignete Invariante und beweine sie mit- Induktion . Invariante Il j ) : Nach j Durchgängen befinden sich die j grössten Elemente am korrekten Ort Beweis : Induktion ( Übung) Aus Ilm ) folgt : Nach n Durchläufen sind allen Elemente korrekt . Vonderhvariamtezumvtlgorithmus-B.it reichte dieselbe Invariante Icj ) wie oben . Können wir IH N mit weniger Aufwand erreichen ? Mit : i \" %÷÷÷÷. Element Idee : Finde grösstes Element in AK . in -j ] und tausche es mit A [ n - j ] AGorithmus2.kleetions.at/braucht n - j -1 ≤ n Vergleichefor j = n . . . 1- K : = Index des Maximums in A [ 1 . . . n - j ] tausche 1- [ KE IN - j ] Beispiel : 53714N Il o ) 53 4 117 ICH7-3 1 3 415 7 - I (2 ) 1 314 5 7 153 45 z I (3) I (4) 3 457 I (5) sortiert Laufzeit : 0C n ' ) Vergleiche 0cm ) Vertauschungen ← besser als Bubblesort- Andere Invariante : I ( j ) = 1- [ 1 . . . j ] ist sortiert ( enthält aber nicht garantiert die richtigen Elemente) Array : sortiert | 1- [ja ] | unsortierter Teil | Wenn Icj ) gilt , wie erhalten wir Icj + 1) ? → Setze A [ j +1 ] an korrekten Stelle in All ] , → A) ein Beispiel . 112 7 9 141 8 351 → 11 2 üT9 18 35 1 AGorithmus3cznsertionsot-T-nsutions.at( A ) geht mit binärer Suche for j = 2 . - n y in Zeit Oclogj ) Finde grösstes K£11, - ,j - 11 sodass 1- [ j ] ≤ Alk ] „ A [ j ] gehört an diese Stelle K × : = Alj ] N merke 1- [ j ] , du es gleich überschrieben wird verschiebe Alk . . . j - 1 ] nach Alk +1 . . . j ][ Alk ] : = ✗ aufwendig, braucht j - K Operationen ( wirst une : j ) Beispiele 51 374 1 3<517 4 1 35 ¥14 1 3 ist7M ¥ - 7 1 Laufzeit . Vergleiche ≤ Iii lag4) ≤ §, c. leg n ≤ 0cm . leg n ) Vertauschungen ≤ ¥, j = OCNY Bis jetzt : Alle Algorithmen sin d 0in) Selection Sat : 0cm) Vertauschungen Insertion Sat : Ocnbgn ) Vergleiche Geht es besser ? Können wir das beste vo n beidem haben ? Algorithmentheorie Idee : Divide - and - Conquer ( Teile - und - Herrsche ) A Tj S Hort Hort 1*770--9*40=681 B hz%E9.tl#- nächstes Element in Bis t das erste (kleinste ) übrige Element in einer Hilfsarray der beiden Hälften von A MergeSort ( A , lir ) ✗ sortiert den Bereich All . . - r ] if he r m : =L LE ] MergeSort ( A , ein ) N sortiere linke Hälfte Merge Sort ( A.mil, r ) \" sortiere rechte Hälfte Merge ( A , limit II verschmelzen beide Hälften Merge ( A, l , m , r ) B : = no w Array with r - 1+ 1 alls ✗ some sine as Al l . . - r ] ii. =L ✗ erstes unbenutztes Element in linker Hälfte j : = mit Kents unbenutztes Element in rechter Hälfte k : = 1- N nächste Position in B while i ≤ m a nd j ≤ r ✗ beide Hälften noch nicht ausgeschöpft if Al i ] < Al j ] B.[ K ] : = A [ i ] ii. = it I K : = K -11 ehe B. [ K ] : = 1-[ j ] j : = j -11 K : = K -11 übernimm Rest links bow . rechts // wenn die andere Hälfte ausgeschöpft ist kopiere B nach Al l . . . r ] Beispiel : 9 7 3 2111 8 46 ← 97113 2 78446 6 97 2 1% ¥6 s : : : : : : : Beispiel : 9732111846 f 97 13 2 18446f 9117 3112 1¥ ¥16 Gesamtarbüt § ↓ ≥ 5 ! Ily ¥ , pro Level : }≤ n Vergleiche 4g ¥, tu t 18 ! 2h Kopier - Ops 146g } ≤ \" Vergleiche{ ↓ In Kopier -0ps 237 9 { ≤ n Vergleiche→ 2m Kopien -0ps12346¥89 = jede Zahlwird vo n Anachl} insgesamt Ocnlogn ) , und anschliessend duesolkyn)Levelsgibtwieder zurück kopiert Alternative Bestimmung der Laufzeit : wn =Ü ≤ 2. Tl) -1d m Induktion 1- (a) ≤ den . logan -1cm ( Übung!) ≤ Ocnlogn) Beste Laufzeit bisher : Ocnloyn) Nachteil : braucht Zmatzamay ( nicht „ in place \" )","libVersion":"0.3.2","langs":""}