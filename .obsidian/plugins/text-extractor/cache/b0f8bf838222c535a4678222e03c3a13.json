{"path":"sem4/DMDB/VRL/extra/slides/DMDB-s07-normal-forms.pdf","text":"Data Modeling and Databases Spring Semester 2025 Normal Forms Normal Forms Gustavo Alonso Institute of Computing Platforms Department of Computer Science ETH Zürich 1 Lessons learned so far • This lecture concludes the part of the course establishing the formal foundation of data management • The language (relational model, relational algebra, SQL) • Entity Relationship for modeling • Corner cases and quirks in the model and language • Nulls • Views • Recursion • Integrity constraints • Today we cover normal forms to provide a formal approach to organizing a schema Normal Forms 2 What is a Normal Form • Normal forms describe properties of concrete schemas based on functional dependencies in terms of data redundancy and data integrity • For each normal form, we consider the following problems: • Given a relational schema R, and a set of functional dependencies FD, how to decide whether {R, FD} satisfies a given normal form • Given {R, FD} that satisfies a given normal form, what are the set of properties that it will have (e.g., no update anomalies) • Given a relational schema R, and a set of functional dependencies FD, how to generate a new schema R’ such that {R’, FD) satisfies a given normal form Normal Forms 3 Database Design Theory • What we are going to see today often provide a reasonable guideline. • Normal Forms • Being “normal” is not always the best option. De-normalization is a common step in practice for performance reasons • DB design is often an application-dependent, complex process that evolves as the needs of applications evolve. Normal Forms 4 1st Normal Form Normal Forms 5 1NF: First Normal Form • Only Atomic Domains. • Intuition: this makes the concept of \"key\" well defined (or, easier to define). • SQL3 and XML allows Non-First Normal Form by introducing the Array type Father Mother Children A B C1 A B C2 Father Mother Children A B {C1, C2} Normal Forms 6 Examples of non 1NF Derived (with corrections) from https://learn.microsoft.com/en-us/office/troubleshoot/access/database-normalization-description Problems with this representation: • What if need to add more classes? • What is there are less than 3 classes? How did we get here? • Representing an 1-N relationship with an array for the N side • Instead, the N side should be represented as different tuples Class { { } } Normal Forms 7 Careful with 1NF Class This is in 1NF but it is not a good approach • Same problems as before • The attributes Class1, Clkass2, Class3, etc. represent the same thing, they should be a single attribute Normal Forms 8 Yet, it can be done • Use SQL Arrays: https://www.postgresql.org/docs/current/arrays.html • Not all systems support them and the semantics vary • A feature that must be handle with care (but often needed) • 1NF is tempting if one has a very long array to void repeating the other attributes in the table for every entry in the array. In relational databases, better represented through a relationship. • Special languages and data representation for nested data, e.g., JSON and JSONIQ Pay_by_quarter is the pay every 3 months Schedule is the weekly schedule with several entries per day Normal Forms 9 1NF not enough • Functional dependencies to the rescue: • Student -> Advisor • Advisor -> Adv-Room • Adv-room -> Advisor • What about the attribute Class? It does not depend on any other attribute! Normal Forms 10 2nd Normal Form Normal Forms 11 2NF: Second Normal Form • What types of data redundancy do we have in this example? • For each student, Name is stored multiple times. • Why? • {Legi, Nr} -> {Name, Semester} • {Legi} -> {Name, Semester} • 2NF tries to remove data redundancy caused by similar cases. Normal Forms 12 2NF and functional dependencies • Let’s look at these two dependencies: • {Legi, Nr} -> {Name, Semester} • {Legi} -> {Name, Semester} • They state the following: • Legi determines the Name and the Semester • By adding {Legi, Nr} -> {Name, Semester}, we need to map every pair {Legi, Nr} to a pair {Name, Semester} when it is sufficient to map them to {Legi} alone • This is an indication that these two dependencies in a single relation are going to lead to redundancy in {Name, Semester} since they will have to be repeated for every combination of {Legi, Nr} • However, we need {Legi, Nr} since that is exactly the relationship that the table is meant to capture • The conclusion is that {Name, Semester} have nothing to do in that table … Normal Forms 13 2NF: Second Normal Form • {R, FD} is in 2NF iff. every non-key attribute is minimally dependent on every key. • minimally dependent: No attribute dependents on part of a key. • The example on the right is not in 2NF because of the following FD: • {Legi} -> {Name, Semester} Normal Forms 14 2NF: Second Normal Form • Problem for relations that are not in 2NF: • Insert Anomaly: Student who attend no lectures. • Update Anomaly: Increase Carnap Semester by 1. • Delete Anomaly: Fichte drops his last course. • All these can lead to redundant / inconsistent updates of the relations. Normal Forms 15 2NF: Second Normal Form • Enforcing 2NF: • Take the “evil” FD, i.e., {Legi} -> {Name, Semester}, and decompose the relation into multiple relations: • Student(Legi, Name, Semeter) • Attends(Legi, Nr) • Lossless Decomposition • The join returns the original table • But we eliminate one FD: • {Legi, Nr} -> {Name, Semester} • It is OK, as it is implied by {Legi} -> {Name, Semester} (see Armstrong axioms …) Normal Forms 16 2NF, another example Functional dependencies: • Student -> Advisor • Advisor -> Adv-Room • Adv-Room -> Advisor The attribute Class does not depend on any key, meaning it should not be there Advisor Normal Forms 17 2NF summary • 2Nf is often summarized as follows: • Everything depends on the key • Note that it is a good way to remember it but it is not accurate as 2NF says everything depends on every key which is not exactly the same Normal Forms 18 2NF is not enough • Does 2NF get rid of Insert Anomaly, Update Anomaly, and Delete Anomaly? • The schema on the right is in 2NF. • However, consider this relation instance. • Update anomaly • Delete anomaly • Why? • C -> D (non-key FD) is a problem R(A, B, C, D) AB -> CD C -> D A B C D a b c d a b’ c d Normal Forms 19 3rd Normal Form & BCNF Normal Forms 20 3NF: Third Normal Form • R is in 3NF iff for all 𝛼 → 𝐵, at least one condition holds: • 𝐵 ∈ 𝛼 (𝛼 → 𝐵 is a trivial FD) • 𝐵 is an attribute of at least one key • 𝛼 is a superkey of R (superkey = superset of a candidate key) • Intuition: if 𝛼 → 𝐵 does not satisfy any of these conditions, 𝛼 is a concept in its own right. • 3NF tries to get rid of \"transitive dependency\" (e.g., A -> B, B -> C) • The schema on the right is not in 3NF (because of C -> D) R(A, B, C, D) AB -> CD C -> D A B C D a b c d a b’ c d Normal Forms 21 From 2NF to 3NF Functional dependencies: • Student -> Advisor • Advisor -> Adv-Room • Adv-Room -> Advisor • Key is Student but Advisor -> Adv-Room implies that there is another concept mixed into this relation. The fact that an advisor has an office (Advisor -> Adv-Room) has nothing to do with the student having an advisor (Student -> Advisor). • That separate concept needs to be taken away and captured in a different relation. Normal Forms 22 3NF: Understanding it • R is in 3NF iff for all 𝛼 → 𝐵, at least one condition holds: • 𝐵 ∈ 𝛼 (𝛼 → 𝐵 is a trivial FD) • 𝐵 is an attribute of at least one key • 𝛼 is a superkey of R (superkey = superset of a candidate key) • This rule allows: • Advisor -> Adv-Room • Adv-Room -> Advisor • Making the result 3NF • Which is the key? Interesting question (see later) Normal Forms 23 3NF is not enough • R is in 3NF iff for all 𝛼 → 𝐵, at least one condition holds: • 𝐵 ∈ 𝛼 (𝛼 → 𝐵 is a trivial FD) • 𝐵 is an attribute of at least one key • 𝛼 is a superkey of R (superkey = superset of some candidate keys) • Does 3NF get rid of data redundancy? • Still have Update anomaly • Still have Delete anomaly • (D -> C) is the problem. R(A, B, C, D) ABC -> D D -> C A B C D a b c d a’ b’ c d Normal Forms 24 BCNF: Boyce-Codd Normal Form • R is in BCNF iff for all 𝛼 → 𝐵, at least one condition holds: • 𝐵 ∈ 𝛼 (𝛼 → 𝐵 is a trivial FD) • 𝛼 is a superkey of R (superkey = superset of a candidate key) • Intuitively, in each relation, you only store the same information once. • The right schema is in 3NF, but not BCNF (because of D -> C) R(A, B, C, D) ABC -> D AD -> BC D -> C A B C D a b c d a b’ c d’ Normal Forms 25 BCNF & 3NF • Q1: How to turn a DB schema into BCNF? • Q2: How to turn a DB schema into 3NF? • Q3: Why do we need 3NF when we have BCNF? • Spoiler alert: Trade-off between correctness and efficiency R(A, B, C, D) ABC -> D AD -> BC D -> C A B C D a b c d a b’ c d’ Normal Forms 26 BCNF Decomposition Algorithm • Input: Schema ℛ • Output: ℛ1, … , ℛ𝑛 such that • ℛ1, … , ℛ𝑛 is a lossless decomposition of ℛ (joining ℛ1, … , ℛ𝑛 together will perfectly recover information in ℛ) • ℛ1, … , ℛ𝑛 are in BCNF • Algorithm • Result = {ℛ} • While (exists ℛ𝑖 in Result such that ℛ𝑖 is not BCNF) • Let 𝛼 → 𝛽 be the evil FD • ℛ𝑖 1 = 𝛼 ∪ 𝛽 • ℛ𝑖 2 = ℛ𝑖 − 𝛽 • 𝑅𝑒𝑠𝑢𝑙𝑡 = 𝑅𝑒𝑠𝑢𝑙𝑡 − 𝑅𝑖 ∪ {ℛ𝑖 1, ℛ𝑖 2} • Output Result R(A, B, C, D) ABC -> D AD -> BC D -> C A B C D a b c d a b’ c d’ C D c d c d’ A B D a b d a b’ d’ D -> C Normal Forms 27 BCNF Decomposition Algorithm PersNr Name Level Room City Street Zip AreaCode Canton Population Professor {PersNr} -> Name, Level, Room, City, Street, Canton {Room} -> PersNr {Street, Canton, City} -> Zip {City, Canton} -> {Population, AreaCode} {Zip} -> {Canton, City} Step 0: Generate Closure from all FDs Step 1: Find Candidate Keys {PersNr}, {Room} Step 2: Check each FD and see whether Professor is in BCNF No, one evil FD is {Zip} -> {Canton, City} Step 3: Decompose the relation Zip Canton City PersNr Name Level Room Street Zip AreaCode Population Professor_new ZipCodeStep 4: Repeat Step 1-3 for each new relation. Normal Forms 28 BCNF Decomposition Algorithm {PersNr} -> Name, Level, Room, Street, Population, AreaCode {Room} -> PersNr {Zip} -> {Population, AreaCode} Step 0: Generate Closure from all FDs Step 1: Find Candidate Keys {PersNr}, {Room} Step 2: Check each FD and see whether Professor_new is in BCNF No, one evil FD is {Zip} -> {Population, AreaCode} Step 3: Decompose the relation PersNr Name Level Room Street Zip AreaCode Population Professor_new Step 4: Repeat Step 1-3 for each new relation. PersNr Name Level Room Street Zip Professor_new2 Zip AreaCode Population ZipAreaPop Normal Forms 29 BCNF Decomposition Algorithm PersNr Name Level Room Street Zip Professor_new2 Zip AreaCode Population ZipAreaPop PersNr Name Level Room City Street Zip AreaCode Canton Population Professor {PersNr} -> Name, Level, Room, City, Street, Canton {Room} -> PersNr {Street, Canton, City} -> Zip {City, Canton} -> {Population, AreaCode} {Zip} -> {Canton, City} Zip Canton City ZipCode Normal Forms 30 BCNF Decomposition Algorithm PersNr Name Level Room Street Zip Professor_new2 Zip AreaCode Population ZipAreaPop PersNr Name Level Room City Street Zip AreaCode Canton Population Professor {PersNr} -> Name, Level, Room, City, Street, Canton {Room} -> PersNr {Street, Canton, City} -> Zip {City, Canton} -> {Population, AreaCode} {Zip} -> {Canton, City} Zip Canton City ZipCode This FD is lost during the decomposition • BCNF does not preserve all FDs (3NF does, we will see it soon). • BCNF does not get rid of ALL data redundancies – it gets rid of all data redundancies caused by functional dependencies.Normal Forms 31 BCNF Decomposition Algorithm PersNr Name Level Room Street Zip Professor_new2 Zip AreaCode Population ZipAreaPop PersNr Name Level Room City Street Zip AreaCode Canton Population Professor {PersNr} -> Name, Level, Room, City, Street, Canton {Room} -> PersNr {Street, Canton, City} -> Zip {City, Canton} -> {Population, AreaCode} {Zip} -> {Canton, City} Zip Canton City ZipCode • The order of picking the evil FD matters. • If we pick {Street, Canton, City} -> Zip first, we will end up having a relation with (Zip, Street, Canton, City) during the first step of the decomposition. • Heuristics – prioritize the one with the largest RHS. Normal Forms 32 3NF Synthesis Algorithm • R is in 3NF iff for all 𝛼 → 𝐵, at least one condition holds: • 𝐵 ∈ 𝛼 (𝛼 → 𝐵 is a trivial FD) • 𝐵 is an attribute of at least one key • 𝛼 is a superkey of R (superkey = superset of some candidate keys) • Input: ℛ • Output: ℛ1, … , ℛ𝑛 such that • ℛ1, … , ℛ𝑛 is lossless decomposition of ℛ • ℛ1, … , ℛ𝑛 are in 3NF • Synthesis Algorithm • Compute the minimal basis Fc of F • For all 𝛼 → 𝛽 ∈ 𝐹𝑐, create 𝑅𝑎∪𝛽(𝛼 ∪ 𝛽) • If none of the above relations contains a superkey, add a relation with a key • Eliminate 𝑅𝛼 if there exists 𝑅𝛼′ such that 𝛼 ⊆ 𝛼′. R(A, B, C, D) AB -> CD C -> D A B C D a b c d a b’ c d Fc: {AB->C, C->D} A B C a b c a b’ c C D c d Normal Forms 33 3NF Synthesis Algorithm PersNr Name Level Room City Street Zip AreaCode Canton Population Professor {PersNr} -> Name, Level, Room, City, Street, Canton {Room} -> PersNr {Street, Canton, City} -> Zip {City, Canton} -> {Population, AreaCode} {Zip} -> {Canton, City} Step 0: Generate Basis Step 1: Generate Relations for Each FD Step 2: Check whether one relation has a key -- Yes PersNr Name Level Room City Street Canton PersNr Room City Street Zip Canton City AreaCode Canton Population City Zip Canton Normal Forms 34 3NF Synthesis Algorithm PersNr Name Level Room City Street Zip AreaCode Canton Population Professor {PersNr} -> Name, Level, Room, City, Street, Canton {Room} -> PersNr {Street, Canton, City} -> Zip {City, Canton} -> {Population, AreaCode} {Zip} -> {Canton, City} Step 0: Generate Basis Step 1: Generate Relations for Each FD Step 1’: Merge relations Step 2: Check whether one relation has a key -- Yes PersNr Name Level Room City Street Canton PersNr Room City Street Zip Canton City AreaCode Canton Population City Zip Canton • Lossless decomposition? – yes (As for all 3NF synthesis algorithm output) • Preserving dependencies – Yes (As for all 3NF synthesis algorithm output) • Free of redundancy? – Not for (City, Street, Zip, Canton) since it is not BCNF Normal Forms 35 BCNF vs. 3NF PersNr Name Level Room City Street Zip AreaCode Canton Population Professor {PersNr} -> Name, Level, Room, City, Street, Canton {Room} -> PersNr {Street, Canton, City} -> Zip {City, Canton} -> {Population, AreaCode} {Zip} -> {Canton, City} PersNr Name Level Room City Street Canton City Street Zip Canton City AreaCode Canton Population 3NF PersNr Name Level Room Street Zip Zip AreaCode Population Zip Canton City BCNF Correctness (Model all FDs) Efficiency (No Redundancy by FD)vs. Normal Forms 36 BCNF: understanding it • Note the following two FDs: • {PersNr} -> Name, Level, Room, City, Street, Canton • {Room} -> PersNr • They are OK in both 3NF and BCNF because both left hand sides are candidate keys in the table professor • A relation Has_Office(PersNr, Room) with (PersNr, Room) as the key would be a problem and it would not be in BCNF (none of the left hand sides is a superkey). • Neither the decomposition not the synthesis algorithm produces such a table so we get to keep that FD • However, Has_Office(PersNr, Room) is in BCNF if we make one of either PersNr or Room the key. • One more example that cardinalities cannot be enforced completely through keys but through constraints (make one the key, the other UNIQUE) Normal Forms 37 The missing concept Functional dependencies: • Student -> Advisor • Advisor -> Adv-Room • Adv-Room -> Advisor • In this set of tables, make advisor the key and enforce Adv-Room -> Advisor by making it UNIQUE in that table. Normal Forms 38 BCNF: understanding it • What happens if we actually have one table for professor and another one for room? Assume we want to enforce a 1:1 cardinality between the two • Professor: {PersNr,Name, Level,City, Street, Canton} • Room: {RoomNr, size, telephone, department, …} • Does it make sense to add another relation Has_Office: {PersNr,RoomNr}? • If we do not add it, we do not map professors to offices • If we add it, we can proceed as explained to make it BCNF • However, there is certain degree of redundancy: one of the two attributes is repeated as it appears in its own relation and in the one making the connection. • The 1:1 cardinality allows us to merge the Has_Office relation with either the Professor relation or the Room relation, removing the need to have a separate table. Normal Forms 39 BCNF: Problem? • Given FDs:, what is the highest normal form? • => BCNF • Does this table has redundancy? • Clearly, yes. • Additional normal forms address this type of redundancy (but are seldom used). Normal Forms 40 Normal Form: Summary 41 & there are more… Normal Forms Normal Forms & ER-Modeling ▪ The ER=>Relational Model algorithm we discussed automatically generates at least 3NF. ▪ Refresh Memory: Rules of Thumb ➢ Entities become relations. ➢ Relationships become relations. ➢ Merge relations with the same key. ▪ FDs resulting from cardinality constraints from relationships. 42Normal Forms Normalization: the higher the better? ▪ Not always -- there is a trade-off, in practice ▪ Database De-normalization ➢ Benefit: Could be faster to read ➢ Downside: Could be less redundant, easier to maintain consistency 43 PersNr Name Level Room City Street Zip AreaCode Canton Population PersNr Name Level Room Street Zip Zip AreaCode Population Zip Canton City Normal Forms Practice • Many applications have data that does not easily fit into a normal form. In these cases, just chose the one that fits but be aware of the implications. • Examples: • Scientific data (arrays) • Machine learning vectors and embeddings 44Normal Forms Lessons learned • Normal Forms help understand the nature of a schema and how data relates to each other • In general, avoiding redundancy is the better option • Helps to maintain data consistency • Helps creating a clean schema • Use views to get speed (possibly materialized) • Next, we will start covering the system side of data processing Normal Forms 45","libVersion":"0.5.0","langs":""}