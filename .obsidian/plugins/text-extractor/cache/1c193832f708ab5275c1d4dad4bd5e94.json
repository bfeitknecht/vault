{"path":"sem3/A&D/VRL/script/A&D-script-w10-decision-problems.pdf","text":"Skript zur Vorlesung Algorithmen und Datenstrukturen Auswahlproblem und Median Herbstsemester 2024 Stand: 18. Dezember 2024 Johannes Lengler David Steurer Inhaltsverzeichnis 1 Das Auswahlproblem und der Median 1 1.1 Motivation: QuickSort . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.2 Das Auswahlproblem . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.3 Quickselect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.3.1 Analyse des Good Case . . . . . . . . . . . . . . . . . . . . . 3 1.4 Median der Mediane . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.4.1 Analyse des Pivot-Elements . . . . . . . . . . . . . . . . . . . 4 1.4.2 Laufzeitanalyse . . . . . . . . . . . . . . . . . . . . . . . . . . 5 i ii Kapitel 1 Das Auswahlproblem und der Median In diesem Kapitel besch¨aftigen wir uns mit dem Problem, das i-kleinste Element in einem unsortierten Array zu finden. Dieses Problem wird Auswahlproblem genannt. Ein wichtiger Spezialfall des Auswahlproblems ist die Bestimmung des Medians, also des Elements, das in der Mitte des sortierten Arrays steht. 1.1 Motivation: QuickSort Bevor wir uns dem Auswahlproblem zuwenden, erinnern wir uns an den Algorithmus QuickSort, den wir in einem fr¨uheren Kapitel kennengelernt haben. QuickSort ist ein Algorithmus zum Sortieren eines Arrays. Die Idee von QuickSort ist, ein Element des Arrays, das sogenannte Pivot-Element, zu w¨ahlen und das Array in zwei Teile aufzuteilen, so dass alle Elemente in der linken H¨alfte kleiner sind als das Pivot- Element und alle Elemente in der rechten H¨alfte gr¨osser sind als das Pivot-Element. Anschliessend werden die linke und die rechte H¨alfte rekursiv sortiert. Die Laufzeit von QuickSort h¨angt davon ab, wie gut das Pivot-Element gew¨ahlt wird. Im schlechtesten Fall ist das Pivot-Element das kleinste oder gr¨osste Element des Arrays. In diesem Fall erhalten wir eine Laufzeit von O(n2). Im besten Fall ist das Pivot-Element der Median des Arrays. In diesem Fall erhalten wir eine Laufzeit von O(n log n). Tats¨achlich reicht es aus, wenn das Pivot-Element das Array in zwei Teile aufteilt, deren Gr¨osse mindestens ϵ · n ist, wobei ϵ eine Konstante zwischen 0 und 1 ist.1 In diesem Fall erhalten wir ebenfalls eine Laufzeit von O(n log n). Diesen Fall nennen wir den Good Case. Der Good Case ergibt sich automatisch, indem wir das Pivot-Element zuf¨allig w¨ahlen.2 Die resultierende Variante von QuickSort heisst randomisiertes QuickSort und hat eine erwartete Laufzeit von O(n log n). Wenn wir den Median in Zeit O(n) berechnen k¨onnten, dann k¨onnten wir Quick- Sort auch deterministisch in Zeit O(n log n) laufen lassen, ohne das Pivot-Element zuf¨allig w¨ahlen zu m¨ussen. Die Bestimmung des Medians ist auch f¨ur andere Probleme n¨utzlich, in denen Daten gleichm¨assig aufgeteilt werden sollen. 1Wir werden das hier nicht analysieren. Informatik-Studierende der ETH werden diese Analyse im zweiten Semester in der Vorlesung Algorithmen und Wahrscheinlichkeit sehen. 2Der Good Case ergibt sich nicht immer, aber mit extrem hoher Wahrscheinlichkeit ergibt er sich oft genug. Auch hier verweisen wir auf die Vorlesung Algorithmen und Wahrscheinlichkeit. 1 2 Das Auswahlproblem und der Median 1.2 Das Auswahlproblem Formal betrachten wir das folgende Problem: Definition 1.1 (Auswahlproblem). Gegeben sei ein Array A[1..n] mit n verschiede- nen3 Zahlen und ein Index i ∈ {1, . . . , n}. Gesucht ist das i-kleinste Element in A, also das Element, f¨ur das es genau i − 1 kleinere Zahlen im Array gibt. Ein wichtiger Spezialfall des Auswahlproblems ist die Bestimmung des Medians, also des ⌈(n + 1)/2⌉-kleinsten Elements. Es gibt verschiedene M¨oglichkeiten, das Auswahlproblem zu l¨osen. Die einfachs- te L¨osung besteht darin, das Array zu sortieren. Dies ben¨otigt Zeit O(n log n). Ei- ne weitere M¨oglichkeit besteht darin, einen Suchbaum zu verwenden. Wir k¨onnen einen Suchbaum in Zeit O(n log n) erzeugen und dann das i-kleinste Element in Zeit O(log n) finden. Allerdings ist die Erzeugung des Suchbaums bereits zu langsam. Eine weitere M¨oglichkeit besteht darin, einen Min-Heap zu verwenden. Wir k¨onnen einen Min-Heap in Zeit O(n) erzeugen und dann i-mal die Operation extractMin ausf¨uhren. Die Operation extractMin ben¨otigt Zeit O(log n). Diese L¨osung ist je- doch nur effizient, wenn i klein ist. F¨ur i = ⌈(n + 1)/2⌉ erhalten wir wieder eine Laufzeit von O(n log n). Schliesslich k¨onnten wir versuchen, den Mittelwert des kleinsten und gr¨ossten Elements zu berechnen und das Element zu finden, das am n¨achsten an diesem Mittelwert liegt. Diese L¨osung funktioniert jedoch nicht, da der Mittelwert weit vom Median entfernt sein kann. Betrachten wir beispielsweise ein Array, das viele kleine Zahlen enth¨alt, etwa die Zahlen zwischen 1 und n − 1, und eine grosse Zahl als Ausreisser, etwa die Zahl n2. In diesem Fall ist der Mittelwert des kleinsten und gr¨ossten Elements n2+1 2 und damit viel gr¨osser als der Median. Der Mittelwert ist sogar viel gr¨osser als das zweitgr¨osste Element. Unser Ziel ist es, das Auswahlproblem in Zeit O(n) zu l¨osen. 1.3 Quickselect Eine weitere Idee zur L¨osung des Auswahlproblems ist die Verwendung eines Divide- and-Conquer-Ansatzes, der dem Algorithmus QuickSort ¨ahnelt. Der Algorithmus, den wir betrachten, heisst Quickselect. Er erh¨alt als Eingabe ein Array A und einen Index i und gibt das i-kleinste Element in A zur¨uck. Der Algorithmus Quickselect funktioniert wie folgt: 1. W¨ahle ein Element p in A als Pivot-Element. 2. Bestimme die korrekte Position k von p in A, so dass alle Elemente links von p kleiner sind als p und alle Elemente rechts von p gr¨osser sind als p. Dies erreichen wir mit der Prozedur Aufteilen, die wir bereits von QuickSort kennen. 3. Falls i = k ist, so ist p das i-kleinste Element, und wir geben p zur¨uck. 4. Falls i < k ist, so liegt das i-kleinste Element links von p, und wir rufen Quickselect rekursiv auf dem Teilarray A[1..k − 1] mit Index i auf. 3Man kann das Problem leicht so erweitern, dass es auch den Fall abdeckt, dass Zahlen mehrfach vorkommen. In diesem Fall wird aber die Definition des i-kleinsten Elementes umst¨andlicher, deshalb verzichten wir hier darauf. 1.4 Median der Mediane 3 5. Falls i > k ist, so liegt das i-kleinste Element rechts von p, und wir rufen Quickselect rekursiv auf dem Teilarray A[k + 1..n] mit Index i − k auf. Die Laufzeit von Quickselect h¨angt davon ab, wie gut das Pivot-Element gew¨ahlt wird. Im schlechtesten Fall ist das Pivot-Element das kleinste oder gr¨osste Element des Arrays. In diesem Fall erhalten wir eine Laufzeit von O(n2), denn die Rekursion reduziert die Gr¨osse des Arrays in jedem Schritt nur um 1. Im besten Fall teilt das Pivot-Element das Array in zwei Teile auf, so dass das i-kleinste Element in dem kleineren Teil liegt. ¨Ahnlich wie bei Quicksort sind wir in einem Good Case, wenn das Pivot-Element das Array so aufteilt, dass beide Teile mindestens Gr¨osse ϵ · n haben, wobei ϵ eine Konstante zwischen 0 und 1 ist. In diesem Fall reduzieren wir die Gr¨osse des Arrays in jedem Schritt um den konstanten Faktor q := 1 − ϵ. 1.3.1 Analyse des Good Case Bevor wir uns der Wahl des Pivot-Elements zuwenden, analysieren wir die Laufzeit von Quickselect im Good Case. Nehmen wir an, dass wir in jedem Schritt ein Pivot- Element w¨ahlen, das das Array in zwei Teile aufteilt, deren Gr¨osse h¨ochstens q · n ist, wobei q eine Konstante zwischen 0 und 1 ist. Dann k¨onnen wir die Laufzeit T (n) von Quickselect durch die folgende Rekurrenz absch¨atzen: T (n) ≤ T (qn) + cn, wobei cn die Zeit f¨ur das Aufteilen des Arrays in Schritt 2 ist. Wir teleskopieren diese Rekurrenz, indem wir sie wiederholt auf T (qn) anwenden: T (n) ≤ T (qn) + cn ≤ T (q2n) + cqn + cn ≤ T (q3n) + cq2n + cqn + cn ... ≤ T (1) + c ( ∞∑ i=0 qi) n = T (1) + c 1 − q n. Im letzten Schritt haben wir die Formel ∑∞ i=0 qi = 1 1−q benutzt, die im Bereich 0 < q < 1 gilt.4 Da q eine Konstante zwischen 0 und 1 ist, folgt T (n) ≤ O(n). Das Hauptproblem von Quickselect ist also die Wahl des Pivot-Elements. Im n¨achsten Abschnitt werden wir einen Algorithmus kennenlernen, der das Pivot- Element so w¨ahlt, dass wir immer den Good Case erreichen. 1.4 Median der Mediane Wir beschreiben nun den Algorithmus Median der Mediane. Der Algorithmus ist identisch zu Quickselect, ausser dass wir das Pivot-Element in Schritt 1 wie folgt w¨ahlen: 4Diese Formel wird im zweiten Semester in der Analysis gelehrt. 4 Das Auswahlproblem und der Median 1a) Teile das Array A gedanklich in Gruppen von jeweils f¨unf Elementen auf. 1b) Bestimme in jeder Gruppe den Median. 1c) Definiere ein neues Array A′, das die Mediane der F¨unfergruppen enth¨alt. 1d) W¨ahle das Pivot-Element p als den Median von A′. Dazu rufen wir Quickselect rekursiv auf A′ mit Index ⌈|A′|/2⌉ auf. Wir bemerken, dass der Algorithmus Median der Mediane eine doppelte Rekursion verwendet: Wir rufen Quickselect in Schritt 1d rekursiv auf, um das Pivot-Element zu w¨ahlen, und dann noch einmal in Schritt 4 bzw. 5, um das i-kleinste Element in A zu finden. 1.4.1 Analyse des Pivot-Elements Der Schl¨ussel zur Analyse des Algorithmus Median der Mediane ist die Beobachtung, dass das Pivot-Element p, das wir in Schritt 1d) w¨ahlen, ein “gutes” Pivot-Element ist. Um dies zu sehen, betrachten wir die folgende Visualisierung: Wir stellen das Array A′ als ein Array dar, in dem die Mediane der F¨unfergruppen aufsteigend sortiert sind. Das Pivot-Element p ist dann der Median von A′. Array A′ (Mediane der Gruppen) p Abb. 1.1 Visualisierung des Arrays A′ und des Pivot-Elements p. Die Mediane der F¨unfergruppen sind aufsteigend sortiert. Das Pivot-Element p ist der Median von A′. Die roten Pfeile markieren Elemente in den F¨unfergruppen, die kleiner sind als der jeweilige Median, und daher auch kleiner als p. Analog sind die blauen Pfeile Elemente, die gr¨osser als der jeweilige Median, und daher auch gr¨osser als p sind. Der Einfachheit halber werden wir in der folgenden Analyse annehmen, dass n durch 5 teilbar ist, sodass jede Gruppe genau 5 Elemente enth¨alt. Dies ¨andert nichts an der asymptotischen Laufzeit. Da p der Median von A′ ist, sind mindestens die H¨alfte der Elemente in A′ klei- nergleich p, das Element p selbst mitgez¨ahlt. Da A′ genau ⌈n/5⌉ Elemente enth¨alt, sind also mindestens ⌈n/10⌉ Elemente in A′ kleinergleich p. Jedes Element in A′, das kleinergleich p ist, ist der Median einer F¨unfergruppe. In jeder dieser F¨unfergruppen gibt es mindestens zwei weitere Elemente, die kleiner sind als der Median. Also sind mindestens 3 · ⌈n/10⌉ Elemente in A kleinergleich p. Analog k¨onnen wir argumentieren, dass mindestens 3 · ⌈n/10⌉ Elemente in A gr¨ossergleich p sind. Also teilt p das Array A in zwei Teile auf, deren Gr¨osse h¨ochstens 7·⌈n/10⌉−1 ≤ 7n/10 ist, wobei die −1 daher kommt, dass wir p bei diesen Intervallen nicht mitz¨ahlen. Das heisst, wir erreichen immer den Good Case! 1.4 Median der Mediane 5 1.4.2 Laufzeitanalyse Wir k¨onnen die Laufzeit T (n) des Algorithmus Median der Mediane durch die fol- gende Rekurrenz absch¨atzen: T (n) ≤ T (n/5) + T (7n/10) + cn. Dabei ist T (n/5) die Zeit, die wir f¨ur den rekursiven Aufruf von Quickselect in Schritt 1d) ben¨otigen, T (7n/10) die Zeit, die wir f¨ur den rekursiven Aufruf von Quickselect in Schritt 4 bzw. 5 ben¨otigen, und cn die Zeit, die wir f¨ur das Aufteilen in Schritt 2 ben¨otigen. Wir ignorieren hier die Auf- und Abrundungen. Dies ¨andert nichts am Ergebnis. Sei nun c eine Konstante, f¨ur die T (1) ≤ c gilt. Dann beweisen wir mit vollst¨andi- ger Induktion, dass dann auch T (n) ≤ 10cn f¨ur alle n ≥ 1 gilt. Induktionsanfang (n = 1): F¨ur n = 1 ist die Aussage trivial, da wir ja T (1) ≤ c angenommen haben. Induktionsschritt (n > 1): Wir nehmen an, dass die Aussage f¨ur alle k < n gilt. Dann ist T (n) ≤ T (n/5) + T (7n/10) + cn ≤ 10c(n/5) + 10c(7n/10) + cn (Induktionshypothese) = 2cn + 7cn + cn = 10cn. Also gilt die Aussage auch f¨ur n. Damit haben wir bewiesen, dass T (n) = O(n) gilt. Also k¨onnen wir das Aus- wahlproblem in linearer Zeit l¨osen. Insbesondere k¨onnen wir auch den Median in linearer Zeit berechnen. Benutzen wir diesen Algorithmus, um den Median als Pivot-Element von QuickSort zu w¨ahlen, so l¨auft QuickSort in Zeit O(n log n). Wir bemerken, dass wir selbst dann, wenn wir nur den Median berechnen wollen, den allgemeinen Algorithmus Quickselect ben¨otigen, da wir in Schritt 3 den richtigen Index in der linken oder rechten H¨alfte suchen m¨ussen. In diesem Fall ist der Index nicht mehr der Median des Teilarrays.","libVersion":"0.3.2","langs":""}