{"path":"sem2/PProg/VRL/slides/PProg-L13-virtual-threads.pdf","text":"Parallel Programming Virtual Threads – Project Loom Big Picture (Part I) 2 CPU OS JVM (Process A) Core Core Core Core OS thread OS thread OS thread OS thread OS scheduler JVM scheduler JVM thread Process B Memory Space A Memory Space B Physical Memory JVM thread JVM thread JVM threadL03-05 L06 L07 L08-09 L10-L11 L13 … … Stack Registers PC Stack Registers PC Stack Registers PC Stack Registers PC Parallel performance & algorithms L12Virtual threads Plan for today Java Threads Recap Virtual Threads Project Loom Code Examples Helpful links and suggested reading • Project Loom: https://wiki.openjdk.org/display/loom/Main • A nice and concise summary: https://www.baeldung.com/openjdk-project-loom • Motivation with code examples: https://cr.openjdk.org/~rpressler/loom/Loom-Proposal.html 3 Java Threads Recap 4 Threads Overview Definition • A set of instructions to be executed one at a time, in a specified order • Smallest unit of processing that can be performed concurrently • Every Java application has at least one thread (main) Importance • Multitasking • Efficient Utilization of CPU Java Concurrency Model (traditional) • Threads/locks • Synchronized/wait&notify 5 Creating Threads (Thread class) 6 Instantiates a subclass of java.lang.Thread class • Single method: public void run() • Class extends Thread class ConcurrWriter extends Thread { … public void run() { // code here executes concurrently with caller } } ConcurrWriter writerThread = new ConcurrWriter(); writerThread.start(); // calls ConcurrWriter.run() Creating Threads (Runnable interface) 7 Implements java.lang.Runnable • Single method: public void run() • Class implements Runnable public class ConcurrWriter implements Runnable { … public void run() { … // code here executes concurrently with caller } } ConcurrWriter writerThread = new ConcurrWriter(); Thread t = new Thread(writerThread); t.start(); // calls ConcurrWriter.run() Thread State Model in Java 8 http://pervasive2.morselli.unimo.it/~nicola/courses/IngegneriaDelSoftware/java/J5e_multithreading.html Synchronization and Thread Safety Synchronization • Control access to shared resources • Prevent data inconsistency and corruption Thread Safety • Avoid race conditions and deadlocks 9 Java Concurrency Model Mechanism to allow multiple threads to operate concurrently. obj - Every obj has an intrinsic lock (monitor lock) - Locks are reentrant - automatically released synchronized Java keyword that requires a specific object’s lock within the block of code T1 T2 Wait/Notify Mechanism Wait! Release Notify! synchronized(obj){ // do work } lock java.util.concurrent Java provides thread-safe collections that are designed for concurrent access and provide better scalability 10 Challenges with Traditional Threads Resource consumption • High Memory usage • CPU overhead Scalability Issues • Limit on Thread Counts • Thread Starvation Complexity • Concurrency Bugs • Managing Thread Lifecycle Blocking IO 11 Challenges with Traditional Threads The native threads are just a thin wrapper around OS threads! 12 PT OT PT OT PT OT PT OT PT OT PT OT PT OT PT OT Platform Thread OS Thread Native Memory Challenges with Traditional Threads The native threads are just a thin wrapper around OS threads! 13 Consequences: • Calling start() creates a new OS thread (via a system call) • There is only a limited number of OS threads available • Throughput is limited, cannot efficiently run millions of threads • Wasted system resources* *we’ll see examples in a bit Challenges with Traditional Threads The OS does the scheduling but is agnostic to the thread requesting the CPU ! 14 Consequences: • Cannot control which thread runs next • Priority not always fulfilled • Cannot wake specific threads without overhead • Only have notify() and notifyAll() • Threads working on the same data could be scheduled on different CPUs (inefficient) Virtual Threads – Project Loom Project Loom – Motivation “Project Loom aims to drastically reduce the effort of writing, maintaining, and observing high-throughput concurrent applications that make the best use of available hardware.” - Ron Pressler (Tech Lead, Project Loom) 16 https://wiki.openjdk.org/display/loom/Main https://cr.openjdk.org/~rpressler/loom/loom/sol1_part1.html Project Loom – Two Parts • JEP 425: Virtual Threads • JEP 428: Structured Concurrency (JEP = JDK Enhancement Proposal) à Project Loom is experimental (!) à Terminology changes (e.g., virtual threads used to be called fibers) 17 main focus today Big Picture (Part I) 18 CPU OS JVM (Process A) Core Core Core Core OS thread OS thread OS thread OS thread OS scheduler JVM scheduler JVM thread Process B Memory Space A Memory Space B Physical Memory JVM thread JVM thread JVM threadL03-05 L06 L07 L08-09 L10-L11 L13 … … Stack Registers PC Stack Registers PC Stack Registers PC Stack Registers PC Parallel performance & algorithms L12Virtual threads 19 In a nutshell • Decouples OS threads from threads visible to programmer • Native threads still used (as carrier threads) • JVM decides which instructions from virtual threads are assigned to carrier threads • Much more efficient arrangements possible • Reduced number of expensive context switches VIRTUAL THREAD VIRTUAL THREAD VIRTUAL THREAD VIRTUAL THREAD VIRTUAL THREAD JVM SCHEDULER OS THREAD OS THREAD OS THREAD OS SCHEDULER CARRIER THREAD CARRIER THREADOPERATING SYSTEMJAVA VIRTUAL MACHINETwo groups of threads 1. Platform threads – the real native threads we used until now 2. Virtual threads – aka user threads Project Loom allows us to create millions of virtual threads • Current Java threading is counted in the thousands of threads (at most) 20 Project Loom – Details (I) 21 Project Loom – Details (II) A virtual thread is … • a Thread — in code, at runtime, in the debugger and in the profiler. • not a wrapper around an OS thread, but a Java entity. • cheap to create — have millions, and don’t pool them! • cheap to block — be synchronous! • requiring (almost) no language changes. Pluggable schedulers offer the flexibility of asynchronous programming. Pluggable scheduler: Different schedulers can be used for different scenarios -> Increased flexibility Virtual threads are most useful in … • high-throughput concurrent applications, especially those that consist of concurrent tasks that spend most of their time waiting • I/O blocks • Network calls • not so much for long-running CPU-intensive operations • Why not? • à Remember where Project Loom saves time. It reduces context switches and idle time … 22 Project Loom – Details (III) Any implementation of a thread depends on two constructs: 1. Continuation – A sequence of instructions that can suspend itself for some blocking operation. All necessary information is stored so that the execution can be resumed later. 2. Scheduler – For assigning the continuation to the CPU and reassigning the CPU from a paused continuation. Java relied on the OS for both. Project Loom wanted to change that. 23 Continuations and Schedulers • The flow of execution: • (0) A continuation is created, beginning at the foo function • (1) It passes control to the entry point of the continuation • (2) It executes until the next suspension point, which is at (3) • (3) It releases control back to the origination, at (1) • (4) It now executes, which calls continue on the continuation, and flow returns to where it was suspended at (5) 24 Continuations – Conceptual Example (Pseudocode) foo() { // (2) ... bar() ... } bar() { ... yield() // (3) ... // (5) } main() { Continuation c = new Continuation(foo) // (0) c.continue() // (1) ... c.continue() // (4) } Adapted from OpenJDK • Platform threads – OS implementation • Virtual threads – runtime implementation Consider an application thread which performs some action on the requests and then passes on the data to another thread for further processing. Here, it would be better to schedule both these threads on the same CPU. Since an OS scheduler is agnostic to the thread requesting the CPU, this is impossible to guarantee. 25 OS vs Runtime Schedulers We already used schedulers during this course! • ForkJoinPool (implementation of ExecutorService) • Executors in general Same in Project Loom, but more efficient thanks to Virtual Threads! à Most code remains the same! The optimization is (partly) under the hood. à So, what does change? 26 Schedulers in Project Loom Virtual Threads – Code Examples Virtual Thread Creation (I) As usual, with the Thread class Virtual Thread Creation (II) Or use a factory to build new virtual threads Virtual Thread Creation (III) Use an Executor ! For every submitted Runnable a new virtual thread will be created Comparison: Number of threadsRuntime: Virtual vs. Platform Threads Every virtual and platform thread executes an empty runnable 0 10000 20000 30000 40000 50000 60000 70000 80000 90000 10 100 1000 10000 100000 1000000Runtime in ms Number of threads launched Number of threads vs. runtime Virtual Threads Platform Threads AMD Ryzen 5 2600 6-Core 3.4Ghz, 16GB, Windows 10 To increase throughput of servers written in a thread-per-request style How you might use Virtual ThreadsComparison Side-by-Side Platform threads • Platform threads are scarce and a precious resource. We use thread pools to manage them. • Managed and scheduled by the OS • Use for heavier CPU-intensive workloads Virtual threads • Virtual threads are plentiful. Each should represent a task, not some shared, pooled, resource. Never pool virtual threads (no need). • Managed and scheduled by the JVM • Use for small tasks or I/O- and network-intensive tasks Additional Links • Project loom source code • Virtual threads documentation","libVersion":"0.3.2","langs":""}