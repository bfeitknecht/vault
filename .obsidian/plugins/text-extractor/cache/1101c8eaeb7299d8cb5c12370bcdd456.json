{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w01.pdf","text":"Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Woche 1 â€“ Ãœbersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder VollstÃ¤ndigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne GewÃ¤hr.) Allgemeines zur Ãœbungsstunde: Anmerkungen zu den Abgaben: â€¢ WÃ¶chentlich erscheinen (Montags) Aufgaben auf Code-Expert und auf der Kurs-Website. Auf Code-Expert erscheinen Programmieraufgaben (Haskell) und auf der Kurs-Website Pen-and-paper-Aufgaben. â€¢ Es ist optional, die Aufgaben zu lÃ¶sen. Es gibt keine Bonuspunkte oder NotenabzÃ¼ge, wenn ihr Aufgaben nicht lÃ¶st. Allerdings empfehle ich euch dringend, die Aufgaben wÃ¶chentlich zu lÃ¶sen, da ihr sonst den Anschluss verliert â€“ und nur sehr schwer wieder einsteigen kÃ¶nnt. Die Klausur beinhaltet ausserdem Ã¤hnliche Aufgaben. â€¢ Es ist vollkommen okay und normal, wenn ihr nicht alles auf Anhieb alleine lÃ¶sen kÃ¶nnt. Versucht trotzdem, die Aufgaben ohne die MusterlÃ¶sung zu lÃ¶sen. â€¢ Die Aufgaben sind anfangs noch Ã¼berwiegend einfach und in vergleichsweise kurzer Zeit lÃ¶sbar, werden aber - meiner Meinung nach - mit zunehmender KomplexitÃ¤t des Unterrichtsmaterials auch schwieriger und zeitintensiver. Plant also eure Bearbeitungszeit nicht anhand des Eindrucks der ersten 1-3 Wochen. â€¢ Abgaben der Theorieaufgaben in diesem Jahr auf Papier in der Ãœbungsstunde, Submission der Programmieraufgaben via Expert. â€¢ Es nicht alle Aufgaben korrigiert, sondern nur die Theorieaufgaben mit einem (*). Ich werde mir eure Code-Expert Submissions angucken und allgemeine Fehler in den Ãœbungsstunden ansprechen, allerdings nur falls absolut nÃ¶tig individuelles Feedback geben. â€¢ Mittwochs, 10 Uhr bis 12 Uhr im LEE C114 â€¢ Unterrichtssprache ist deutsch. Allerdings spreche ich natÃ¼rlich auch Englisch und ihr kÃ¶nnt mir sowohl auf Deutsch als auch auf Englisch fragen stellen, sei es per Mail oder in Person â€¢ Wie bereits im letzten Jahr mÃ¶chte ich begleitend zur Ãœbungsstunde eine WhatsApp- Gruppe erÃ¶ffnen, Ã¼ber die ihr u.a. Fragen (inhaltlich/organisatorisch) stellen kÃ¶nnt. Die Teilnahme an der Gruppe ist selbstverstÃ¤ndlich vollkommen optional und alle relevanten Informationen von meiner Seite werden per Mail oder in den Ãœbungsstunden kommuniziert, damit niemand etwas verpasst. Den Link zur Gruppe: https://chat.whatsapp.com/GyJU0la5Ao4FuodifPfvU0 â€¢ Da wir alle ungefÃ¤hr gleich alt und gleich weit im Studium sind, wÃ¤re es eigenartig, von euch gesiezt zu werden. Duzt mich bitte und nennt mich gerne einfach Max, egal ob per Mail oder in Person. :) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Recap: Mathematische Induktionsbeweise Ihr werdet in diesem Kurs hÃ¤ufig Induktionsbeweise fÃ¼hren (vermutlich spÃ¤testens ab Woche 4). Dabei werdet ihr mit verschiedenen speziellen Induktionsarten vertraut gemacht werden, damit ihr diese aber gut versteht, mÃ¶chte ich an dieser Stelle noch einmal das Grundprinzip von (starker) Induktion formal vorstellen: Und hier noch der VollstÃ¤ndigkeit halber ein simpler klassischer Induktionsbeweis: Sei: ğ´(ğ‘›) â‰¡ (ğ‘›2 + ğ‘›) ğ‘’ğ‘Ÿğ‘”ğ‘–ğ‘ğ‘¡ ğ‘ ğ‘¡ğ‘’ğ‘¡ğ‘  ğ‘’ğ‘–ğ‘›ğ‘’ ğ‘‘ğ‘¢ğ‘Ÿğ‘â„ 2 ğ‘¡ğ‘’ğ‘–ğ‘™ğ‘ğ‘ğ‘Ÿğ‘’ ğ‘ğ‘â„ğ‘™ Beweise, dass gilt: âˆ€ğ‘› âˆˆ â„• âˆ¶ ğ´(ğ‘›) Behauptung: âˆ€ğ‘› âˆˆ â„• âˆ¶ ğ´(ğ‘›) Induktionsanfang: (ğ‘› = 0): (02 + 0) = 0 und 0 ist durch 2 teilbar. Induktionsvorraussetzung: Sei ğ‘š âˆˆ â„• beliebig, wir nehmen an, dass ğ´(ğ‘š) gilt. Prinzip der vollst. Induktion: (ğ´(ğ‘›0) âˆ§ [âˆ€ğ‘› âˆˆ â„•, ğ‘› â‰¥ ğ‘›0 âˆ¶ ğ´(ğ‘›) â‡’ ğ´(ğ‘› + 1)]) â‡’ âˆ€ğ‘› âˆˆ â„•, ğ‘› â‰¥ ğ‘›0 âˆ¶ ğ´(ğ‘›) â€¢ Behauptung: âˆ€ğ‘› âˆˆ â„•, ğ‘› â‰¥ ğ‘›0 : ğ´(ğ‘›) â€¢ Induktionsanfang / Base Case (IA/BC): Zeige, dass A fÃ¼r kleinstes ğ‘›0 gilt â€¢ â€œA(n) gilt fÃ¼r EIN konkretes nâ€ â€¢ Induktionshypothese / Induktionsvorraussetzung (IH / IV) ğ´(ğ‘š) gilt fÃ¼r bel. fixes ğ‘›. â€œA(m) gilt fÃ¼r EIN allgemeines mâ€ â€¢ Induktionsschritt (IS): Beweis von ğ´(ğ‘š) â‡’ ğ´(ğ‘š + 1) â€¢ â€œWenn A(m) fÃ¼r ein m gilt, dann gilt immer auch A(m+1), â€¢ da wir m allgemein gehalten habenâ€ â‡’ Induktionsbehauptung (IB): âˆ€ğ‘› âˆˆ â„•, ğ‘› â‰¥ ğ‘›0 : ğ´(ğ‘›) Prinzip der Starken Induktion: (ğ´(ğ‘›0) âˆ§ [âˆ€ğ‘› âˆˆ â„•, ğ‘› > ğ‘›0 âˆ¶ (âˆ€ğ‘˜ âˆˆ â„•, ğ‘›0 â‰¤ ğ‘˜ < ğ‘› âˆ¶ ğ´(ğ‘˜)) â‡’ ğ´(ğ‘›)]) â‡’ âˆ€ğ‘› âˆˆ â„•, ğ‘› > ğ‘›0 âˆ¶ ğ´(ğ‘›) â€¢ Behauptung: âˆ€ğ‘› âˆˆ â„•, ğ‘› â‰¥ ğ‘›0 : ğ´(ğ‘›) â€¢ Induktionsanfang / Base Case (IA/BC): Zeige, dass A fÃ¼r kleinstes ğ‘›0 âˆˆ â„• (oder eine Menge an kleinsten ğ‘›0, â€¦ , ğ‘›ğ‘¥ âˆˆ â„•) gilt â€œA(n) gilt fÃ¼r EIN konkretes ğ‘›0 (bzw. EINE konkrete Menge ğ‘€ â‰” {ğ‘›0, â€¦ , ğ‘›ğ‘¥})â€ â€¢ Induktionshypths. / Induktionsvorstz. (IH / IV): FÃ¼r bel. fix ğ‘š â‰¥ ğ‘›0 : âˆ€ğ‘›0 â‰¤ ğ‘˜ < ğ‘š âˆ¶ ğ´(ğ‘˜) â€œ â€œA(k) gilt fÃ¼r alle k < m fÃ¼r EIN allgemeines mâ€ â€¢ Induktionsschritt (IS): Beweis von ğ´(ğ‘š) â‡’ ğ´(ğ‘š + 1) â€¢ â€œWenn A fÃ¼r alle ğ‘˜ âˆˆ {ğ‘›0, â€¦ , ğ‘š} gilt, dann gilt immer auch A(m+1), da wir n allgemein gehalten habenâ€ â‡’ Induktionsbehauptung (IB): âˆ€ğ‘› âˆˆ â„• : ğ´(ğ‘›) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Induktionsschritt: (ğ‘š â†’ ğ‘š + 1): ğ´(ğ‘š + 1) â‰¡ ((ğ‘š + 1)2 + (ğ‘š + 1)) ğ‘–ğ‘ ğ‘¡ ğ‘‘ğ‘¢ğ‘Ÿğ‘â„ 2 ğ‘¡ğ‘’ğ‘–ğ‘™ğ‘ğ‘ğ‘Ÿ. Es gilt: ((ğ‘š + 1)2 + (ğ‘š + 1)) = ğ‘š2 + 2ğ‘š + 1 + ğ‘š + 1 = (ğ‘š2 + ğ‘š) + 2(ğ‘š + 1) Nun sehen wir, dass 2(ğ‘š + 1) trivialerweise durch 2 teilbar ist. Ausserdem, haben wir per I.V. angenommen, dass ğ›¢(ğ‘š) gilt, also (ğ‘š2 + ğ‘š) durch 2 teilbar ist. Da die Summe von zwei, durch 2 teilbaren Zahlen auch durch 2 teilbar ist, haben wir damit gezeigt, dass ğ´(ğ‘š + 1) gilt. Nach dem Prinzip der vollstÃ¤ndigen mathematischen Induktion folgt: âˆ€ğ‘› âˆˆ â„• âˆ¶ ğ´(ğ‘›) âˆ Functional Programming â€“ Grundlagen: Haskell â€“ EinfÃ¼hrung: Ich werde in meinen Unterrichtsstunden unter anderem Material aus dem sehr empfehlenswerten Buch â€œLearn You a Haskell for Great Good!â€(Lipovaca, 2011) verwenden. Haskell ist: â€¢ Lazy (SpÃ¤ter mehr dazu): Argumente werden erst dann evaluiert, wenn es nicht anders geht. Das erlaubt bspw. das Verwenden von unendlich langen Listen. â€¢ Statically Typed: Variable-Typen stehen bei Compile-Time fest. Bei Haskell muss allerdings nicht der Programmierer explizit den Typ aller Variablen/Funktionen angeben, da Haskell Type-Inference anbietet, also in der Lage ist, selbst die Typen zu erkennen. Damit werden viele typische Bugs schon bei Compile-Time abgefangen (SpÃ¤ter mehr dazu) â€¢ Konzept, dass seine Wurzeln in der Mathematik hat: â€œProgramm aus Funktionenâ€ â€¢ â€œPure Functionsâ€: Funktionen die fÃ¼r dieselben Eingaben immer dieselben Ausgaben zurÃ¼ckgibt und keine Side-Effects hat. o â€œSide-Effectsâ€: Wenn eine Funktionen etwas an bzw. von dem State des Programms verÃ¤ndert oder verwendet, also beispielsweise globale Variablen Ã¼berschreibt oder liest. â€¢ Das Verwenden von Pure Functions garantiert uns sogenannte â€œreferential transparacyâ€: Wir kÃ¶nnen eine Funktion in einer Expression mit ihrem Ergebnis vertauschen und erhalten das gleiche Ergebnis, da es keine Nebeneffekte gibt, bspw: (sum 2 2) + 3 == 4 + 3 â€¢ Referential Transparacy erlaubt es uns, mathematisch Ã¼ber Programmbausteine zu argumentieren (SpÃ¤ter! Aber: Indem wir Funkt. & Ergeb. in Beweisen vertauschen kÃ¶nn.) â€¢ Functional Programming verwendet Pure Functions als Grundbausteine, die zu komplexeren Funktionen zusammenkonstruiert, nicht nur selbst Werte berechnen, sondern auch wie Werte in anderen Programmiersprachen behandelt, sprich als Parameter Ã¼bergeben, als RÃ¼ckgabewert von anderen Funktionen zurÃ¼ckgegeben oder in komplexen Datenstrukturen verwendet werden kÃ¶nnen. â€¢ Wozu das alles? Functional Programming erlaubt es zuverlÃ¤ssig sehr komplexe Programme zu schreiben, da wir die Korrektheit aller verwendeten Funktionen mathematisch beweisen kÃ¶nnen. Ausserdem sind Programme ohne mutable state und Funtionen mit Side-Effects deutlich leichter zu parallelisieren â†’ attraktiv auch fÃ¼r ML! Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch GHC und GHCi: GHC ist der Haskell-Compiler, den wir in FMFP verwenden werden. Theoretisch kÃ¶nnt ihr eine .hs file schreiben, sie mit GHC (â€œghc file.hsâ€) kompilieren und die erhaltene executable file anschliessend ausfÃ¼hren (Dabei wird dann immer zuerst die main Function ausgefÃ¼hrt). Da dies allerdings sehr aufwÃ¤ndig ist, verwenden wir meistens GHCi, den â€œinteractive modeâ€ von GHC. DafÃ¼r gehen wir folgendermassen vor: â€œghciâ€ eingeben und anschliessend file â€œladenâ€ mit â€œ:l file.hsâ€. Nun kÃ¶nnen einzelne Funktionen oder Haskell Expressions direkt in GHCi ausgefÃ¼hrt werden, bspw. â€œghci> mySum 2 3â€ oder â€œghci> 2*4â€ oder â€œghci> let a = 4â€ oder â€œghci> [x|x<-[1..20], (odd x)]â€. (Nicht erschrecken, die einzelnen Expressions werden im Laufe des Kurses alle verstÃ¤ndlich). Haskell Functions (Grundlagen): In Haskell schreiben wir Funktionen, indem wir ihre Definition angeben. Die Declaration, die aus Funktionenname und den Typen des Parameters und des RÃ¼ckgabewertes besteht, kann aufgrund von Haskells Type Inference allerdings weggelassen werden: Haskell kann die Typen selbst erkennen. Wir kÃ¶nnen Funktionen sehr einfach zusammenfÃ¼gen, um komplexere Funktionen zu erstellen: If-Then-Else-Statements in Haskell: Wir kÃ¶nnen auch If-Then-Else-Statements, wie wir sie aus anderen Programmiersprachen kennen, in Haskell verwenden. In Haskell sind If-Then-Else-Statements Expressions und mÃ¼ssen dementsprechend wie alle Haskell Funktionen/Expressions einen eindeutigen RÃ¼ckgabewert haben (Gleicher Input â€“ Gleicher Output). Deshalb mÃ¼ssen alle FÃ¤lle definiert sein, es geht also nicht, bspw. einfach den Else-Part wegzulassen, da es sonst nicht fÃ¼r jeden Fall einen RÃ¼ckgabewert fÃ¼r die Expression gÃ¤be, was verboten ist. Aber dies erlaubt es uns auch, If-Then-Else-Statements bspw. direkt in Berechnungen (wie du es vielleicht von anderen Expressions in anderen Programmiersprachen kennst) zu verwenden, bspw.: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Wir kÃ¶nnen in If-Then-Else Statement auch eine andere Formatierung (direkt untereinander) und selbstverstÃ¤ndlich auch â€œelse ifâ€ FÃ¤lle verwenden. Haskell Functions (Pattern Matching): Wir setzen in Haskell unter anderem auf ein sehr interessantes Prinzip namens Pattern Matching: Wir kÃ¶nnen fÃ¼r eine Funktion fÃ¼r verschiedene Inputs verschiedene Funktionen-Definitionen schreiben und je nachdem, welchen Wert der Input hat, wird die entsprechende Definition ausgefÃ¼hrt. Das entspricht ungefÃ¤hr dieser Funktionen-Definition, die man aus der Mathematik kennt: (Beispiel): ğ‘“(ğ‘¥) = {2, if x = 0 âˆ’1, if x = 1 ğ‘¥2, else In Haskell sieht das dann beispielsweise so aus: Achtung: wenn ihr einer Funktion einen negativen Wert mit einem Minus Ã¼bergebt (was hier nicht passiert, das ist eher eine allgemeine Anmerkung) muss dieser Negative Wert mit Klammern umrandet werden. Denn â€œf -4â€ ist kein Funktionenaufruf von f mit Eingabewert -1 sondern wird von Haskell als eine Expression verstanden, also eine Subtraktion mit 1 von f. Richtig wÃ¤re also: â€œf (-4)â€: Mit Pattern Matching kÃ¶nnen wir also auch sehr gut rekursive Funktionen schreiben: Dabei definieren wir immer einen oder mehrere Base Cases und den Rekursions-Fall nach dem Prinzip des Pattern Matching: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Allerdings kann es beim Pattern Matching auch zu Problemen kommen: Falls unsere Funktionen- Definitionen nicht alle Definitionen abdecken, kann es passieren, dass wir eine Exception zu â€œfalschenâ€ Inputs bekommen. Sei dies ein Beispiel: Unsere Funktion ist fÃ¼r die Patterns Input = 1 und Input = 2 definiert, allerdings nicht fÃ¼r andere Inputs. Wenn wir nun aber failfunc mit bspw. dem Wert 3 aufrufen, bekommen wir ein Problem: â€œNon-exhaustive patternsâ€ -Exceptions bedeuten fÃ¼r uns, dass zur Laufzeit kein Pattern gefunden werden konnte, zu dem der Input, mit dem wir die Funktion aufgerufen haben, gematched werden konnte. Haskell Functions (Guards): In Haskell gibt es neben Pattern Matching noch eine andere MÃ¶glichkeit, um in Funktionen FÃ¤lle zu unterscheiden: Von oben nach unten werden die Guards â€œabgearbeitetâ€, indem geprÃ¼ft wird, ob der guard zu â€œTrueâ€ evaluiert â†’ falls ja, wird die zugehÃ¶rige Funktionendefinition zurÃ¼ckgegeben, falls nein wird mit nem nÃ¤chsten Guard weitergemacht (Achtung: Auch hier sind Non-exhaustive Patterns mÃ¶glich!) Um Non-Exhaustive Patterns zu vermeiden oder/bzw. alle allgemeinen FÃ¤lle abzudecken, gibt es dass Keyword â€œotherwiseâ€, das immer zu â€œTrueâ€ evaluiert und damit jeden Fall erwischt. Hier ein weiteres Beispiel: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Unterschied zwischen Guards und Pattern Matching: Im Gegensatz zu Guards, bei denen wir komplexe boolsche Expressions evaluieren kÃ¶nnen, kÃ¶nnen wir beim Pattern Matching nur â€“ nunja â€“ Patterns abfangen. Also klar, wir kÃ¶nnen zwar unterscheiden, ob ein Funktionenargument eine 3 oder eine 11 oder eine beliebige andere Zahl ist, aber wir kÃ¶nnen bspw. nicht direkt prÃ¼fen, ob das Argument eine gerade oder ungerade Zahl ist. DafÃ¼r kÃ¶nnen wir mit Pattern Matching Variablen binden, bspw. fÃ¼r Listen (siehe unten) mit x:xs. Insofern haben beide FunktionalitÃ¤ten ihre Relevanz und finden Verwendung (oft auch gemeinsam!). Haskell Functions (Where): Wenn wir eine bestimmte Variable oder Funktion mehrfach verwenden, kÃ¶nnen wir sie auch einfach einmal definieren und dann mit dem where-keyword einbinden. Wichtig: â€œWhere-Bindingsâ€ sind nur in der jeweiligen â€œPattern Definitionâ€ sichtbar. Haskell Functions (Let-Bindings): Let <definition> in <expression> ist in etwa so, als wÃ¼rde man <expression> where <definition> schreiben. Aber es gibt einen wichtigen Unterschied, der auch die Existenzberechtigung von Let- Bindings begrÃ¼ndet: Sie sind selbst Expressions und kÃ¶nnen somit Ã¼berall verwendet werden, wo man Expressions verwenden kann. Unterschied WHERE und LET-IN: â€Whereâ€œ kÃ¶nnen wir nur im Kontext von Funktionen verwenden, wÃ¤hrend Let-In eigenstÃ¤ndige Expressions sind. Das bedeutet weiter aber auch, dass Let-In-Expressions immer einen eindeutigen Wert haben, so wie alle Expressions in Haskell. Andererseits erlauben where-bindings einen scope Ã¼ber mehrere guarded Expressions. Daher verwendet man sie oft, wenn man mit Guards eine bestimmte Condition prÃ¼ft, die (oder von der man Teile) allerdings einmal kompakt beschreibt. Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Haskell Functions (Case-Expressions): Es gibt sogar noch mehr MÃ¶glichkeiten in Haskell, um verschiedene FÃ¤lle zu behandeln: Die expression wird mit den patterns gematched, genau so wie wir es vom pattern matching bei funktionen bereits kennen. Das Gesamtkonstrukt (also die Case Expression selbst) ist wieder eine Expression und kann somit an allen â€œOrtenâ€ verwendet werden, wo wir Case-Expressions erwarten wÃ¼rden. Zum Beispiel so: Haskell Tuples: Tuples in Haskell sehen genau so aus, wie man es sich vorstellen wÃ¼rde. Sie werden mit runden Klammern notiert und kÃ¶nnen aus beliebigen Typen bestehen (auch Funktionen!). NatÃ¼rlich kÃ¶nnen wir auch verschachtelte Tupel haben. Wichtig zu kennen sind die fst und die snd Funktionen aus der Haskell Prelude, deren Beschreibung trivial ist. Haskell Lists: Listen sind eines der Kernelemente von Haskell und sehr interessant da sie sehr vielfÃ¤ltig eingesetzt werden kÃ¶nnen: Sie werden mit eckigen Klammern notiert und die einzelnen (vom Typ homogenen!) Element emit Kommata getrennt. Beispielsweise [1,2,3,4,5] ist eine Liste aus 5 Integern. Ein String, z.B. â€œHelloâ€, ist in Haskell nur syntactic sugar fÃ¼r eine List [â€˜Hâ€™, â€˜eâ€™, â€˜lâ€™, â€˜lâ€™, â€˜oâ€™], das heiss, wir behandeln String immer so wie Listen â€“ denn das sind sie. Wir kÃ¶nnen Elemente an Listen mit diesem Operator: â€˜:â€™ anhÃ¤ngen, bspw. 1:[2,3] = [1,2,3]. Jede Listendarstellung der Form [a,b,c,d,e] ist in Haskell also nur eine vereinfachte Form davon, wie die Listen wirklich gespeichert sind, undzwar als a:b:c:d:e:[] Das kÃ¶nnen wir fÃ¼r recursive Funktionen, die Listen durchgehen sollen gut verwenden: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Hier habe ich einen typischen Ansatz fÃ¼r das Patternmatching mit Listen verwendet: Es gibt den Base Case der leeren Liste â€˜[]â€™ oder den rekursiven Fall indem die Liste die Form x:xs hat, wobei x also das vorderste Listenelement und xs die restliche Liste ist. Achtung: xs kann auch eine leere Liste reprÃ¤sentieren, es steht einfach fÃ¼r irgendeine beliebige Liste. Theoretisch kÃ¶nnte man also auch ein Patternmatching der Form (x:y:xs) machen. Hier ist aber wichtig, dass die Liste (noch) mind. 2 Elemente hat, ansonsten kann dieses Pattern nicht gematched werden. Man mÃ¼sste den Fall mit einem einzigen Element also extra abfangen: Das ist allerdings ein Beispiel, das ich hier nur angebe, um zu erklÃ¤ren was ich meine. Dieses kompliziertere Patternmatching braucht es hier eigentlich nicht. Manchmal aber schon. Wir kÃ¶nnen Listen mit diesem Operator: â€˜++â€™ konkatinieren, z.B.: [1,2]++[3,4] = [1,2,3,4] (auch das ist bei rekursiven Funktionen mit Listen oft sehr nÃ¼tzlich). Hier einige wichtige Prelude-Funktionen (die also schon von Haskell gegeben sind): Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Es ist eine sehr gute und einfache Ãœbung, alle diese Funktionen einmal selbst zu implementieren. Auch wichtig ist zu wissen, dass wir Listen als â€œRangesâ€ angeben kÃ¶nnen: â€¢ [1..10] gibt die Liste [1,2,3,4,5,6,7,8,9,10] (alle Zahlen von 0 bis 10) â€¢ [0,2..10] gibt die Liste [0,2,4,6,8,10] (gerade Zahlen von 0 bis 10) â€¢ [â€˜aâ€™..â€™zâ€™] gibt die Liste aller Buchstaben von a bis z (bzw. den String â€œabcdefghijk...rstuvwxyzâ€) â€¢ [1,2...] gibt die unendliche Liste aller natÃ¼rlichen Zahlen (wie man damit arbeiten kann erfahrt ihr im Kapitel lazy evaluation, bzw. spÃ¤ter im Kurs) Haskell List Comprehension: Falls ihr dem Thema bereits begegnet seid, verweise ich an dieser Stelle auf das Buch Learnyouahaskell, da dieses Thema vorraussichtlich erst in 2-3 Wochen Gegenstand der Ãœbungsstunde sein wird und bis dahin den Rahmen sprengt. Haskell IO: Wir kÃ¶nnen auch I/O in Haskell verwenden. Das Prinzip dahinter ist ein wenig kompliziert, da I/O grundsÃ¤tzlich dem Prinzip von Functional Programming widerspricht (Der State eines I/O devices wird verÃ¤ndert), allerdings gibt es in Haskell Funktionen, die uns I/O erlauben. Wieso genau das funktioniert, ist allerdings noch nicht Stoff dieser EinfÃ¼hrungsÃ¼bung: Die Funktion putStrLn x gibt den String x in einer neuen Zeile aus. Die Funktion getLine, genutzt als x <- getLine, liest einen Eingabe-String in x. Die Funktion show, genutzt als show x, wandelt x in einen String um (bspw. show 11 â†’ â€œ11â€) Die Funktion read, genutzt als read x :: Type, wandelt x (type String) in typ Type um, (bspw. read â€œ23â€ :: Double â†’ 23.0) Haskell Lazy Evaluation (Basics): Wie eingangs erwÃ¤hnt, verwendet Haskell sogenannte Lazy Evaluation. Das heisst vereinfacht gesagt, dass Haskell eine Expression nicht evaluiert, bis das Resultat der Expression gebraucht wird, beziehungsweise konkret fÃ¼r Funktionen, dass Argumente erst in die Funktionendefinition substituiert und erst evaluiert werden, wenn sie gebraucht werden. Hier ein paar Beispiele: [NÃ„CHSTE SEITE] Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch [NATURAL DEDUCTION AUF DER NÃ„CHSTEN SEITE] Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Natural Deduction: Ãœbersicht der Regeln: Wichtig: â€œRecall that â†’ is right-associative, while âˆ§ and âˆ¨ are left-associative. Moreover, Â¬ binds stronger than âˆ§, which binds stronger than âˆ¨, which in turn binds stronger than â†’.â€ (Quelle: Ãœbung 1) Hier einige Beispiele zur AssoziativitÃ¤t: Nun zur grundlegenden Idee von Natural Deduction Proofs und der Notation: ğ´1, â€¦ ğ´ğ‘› âŠ¢ ğ´ bedeutet, dass ğ´ aus ğ´1, â€¦ ğ´ğ‘› folgt, also mit Regeln der Natural Deduction hergeleitet werden kann (in einer sogenannten Derivation). Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Derivations in Natural Deduction Proofs verlaufen immer nach einer Baum-Struktur. Das heisst, die Regeln geben an, was aus was hergeleitet werden kann. Trivial gelten also Axiome wie ğ´ âŠ¢ ğ´, das heisst, sie kÃ¶nnen aus â€œnichtsâ€ hergeleitet werden, denn sie gelten immer. Das Î“ (â€œgrosses Gammaâ€) steht dabei in den Regeln einfach fÃ¼r eine beliebige, von uns gewÃ¤hlte, Variablenmenge, fÃ¼r die wir annehmen, dass sie wahr ist. Da das Derivation System der Natural Deduction sound ist, gilt: wenn ğ´1, â€¦ , ğ´ğ‘› âŠ¢ ğ´, dann auch ğ´1, â€¦ , ğ´ğ‘› âŠ¨ ğ´. Ein Natural-Deduction Proof ist ein Beweis, dessen Root keine Annahmen/LHS hat, also die Form âŠ¢ ğ¹ğ‘œğ‘Ÿğ‘šğ‘’ğ‘™ hat. Die Derivation-Rules ergeben beim genauen Betrachten sofort Sinn: (Beispiel âˆ§ âˆ’ğ¼) Wenn gilt, dass aus der Annahme A folgt und aus der Annahme B folgt, dann folgt aus der Annahme (siehe Holy Chapter 6, Diskrete Mathematik) auch, dass ğ´ âˆ§ ğµ gilt, also ist diese Regel einfach eine âˆ§- Introduction, kurz âˆ§ âˆ’ğ¼. Genauso haben wir aber auch Regeln, die Eliminationen vornehmen, bspw. âˆ§ âˆ’ğ¸ğ¿, die mit unsrem jetzigen Wissen sofort Sinn ergibt: Wenn aus unserer Annahme ğ´ âˆ§ ğµ folgt, kÃ¶nnen wir daraus herleiten, dass aus unserer Annahme auch ğ´ folgt. Wollen wir nun also ğ´ beweisen, mÃ¼ssen wir zeigen, dass ğ´ eine Tautologie ist, also einen Derivation Tree konstruieren, der die Root âŠ¢ ğ´ hat. Hier sind nun einige Beispiele: (Auf der nÃ¤chsten Seite ist noch ein kompliziertes Beispiel) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch","libVersion":"0.5.0","langs":""}