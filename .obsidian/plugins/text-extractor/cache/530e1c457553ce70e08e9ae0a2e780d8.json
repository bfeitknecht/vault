{"path":"sem4/FMFP/UE/e/FMFP-u04-e.pdf","text":"Formal Methods and Functional Programming Exercise Sheet 4 252-0058-00L March 10, 2025 1. Structural Induction (a) Solution. Proof. Let P’≡ rev (xs ++ ys’) = rev ys’ ++ rev xs. We show that: ∀ys’. ∀xs. P’ Fix an arbitrary ys and let P≡ P’[ys’↦→ys]. We show that ∀xs.P by induction on xs. Since ys is fixed and arbitrary this will imply that ∀ys.∀xs.P’. Base case: we show P[xs↦→ []]. rev ([] ++ ys) = (app.1) rev ys = (app_Nil) rev ys ++ [] = (rev.1) rev ys ++ rev [] Step case: We need to show that ∀z zs. P[xs ↦→ zs] → P[xs ↦→ (z:zs)] Fix arbitrary z, zs. We assume IH: rev (zs ++ ys) = rev ys ++ rev zs, and show that rev ((z:zs) ++ ys) = rev ys ++ rev (z:zs). rev ((z:zs) ++ ys) = (app.2) rev (z : (zs ++ ys) = (rev.2) rev (zs ++ ys) ++ [z] = (IH) (rev ys ++ rev zs) ++ [z] = (app_assoc) rev ys ++ (rev zs ++ [z]) = (rev.2) rev ys ++ (rev (z:zs)) (b) Solution. We have shown in (a) that ∀ys’. ∀xs. P’. where P’≡rev (xs ++ ys’) = rev ys’ ++ rev xs. In particular P’[ys’↦→rev ys] also holds, hence for all xs, ys the following holds: rev (xs ++ rev ys) = rev (rev ys) ++ rev xs The statement is then shown applying rev rev. 1 Formal Methods and Functional Programming Exercise Sheet 4 252-0058-00L March 10, 2025 2. Types Solution (a) (\\x y z -> (x y) z) :: (t1 -> t2 -> t3) -> t1 -> t2 -> t3 (b) (\\f -> fst (f,f)) :: b -> b (c) (\\p f -> filter p . map f) :: (a1 -> Bool) -> (a2 -> a1) -> [a2] -> [a1] 2","libVersion":"0.5.0","langs":""}