{"path":"sem3/A&D/VRL/extra/script/Algo Datastructures Week 1.pdf","text":"Algorithmen und Datenstrukturen Johannes Lengler David Steurer October 7, 2024 1 Algorithmen Algorithmen spielen eine wichtige Rolle, sobald wir Computer verwenden wollen, um grosse Datenmengen zu verarbeiten. Unsere FÃ¤higkeit grosse Datenmengen zu verarbeiten erschliesst uns erstaunliche MÃ¶glichkeiten. So kÃ¶nnen bestimmte Algorithmen moderne Sprachmodelle wie Chat- GPT erstellen, indem sie unglaublich grosse Datenmengen verarbeiten. NÃ¤herungsweise kÃ¶nnen wir uns vorstellen, dass diese Algorithmen die gesammelten Texte der Menschheit verarbeiten, insbesondere alle BÃ¼cher und Zeitungsartikel, die jemals verfasst wurden. Algorithmen erstellen interessante Verbindungen zu vielen anderen Themen des Informatik- studiums. Zum Beispiel, befasst sich die Programmierung mit der Frage, wie wir Aufgaben so beschreiben, dass Computer sie korrekt erledigen kÃ¶nnen. Im Bereich der Algorithmen geht es auch darum, Aufgaben mithilfe von Computern zu erledigen, allerdings haben wir neben der Korrektheit zusÃ¤tzlich zum Ziel, dass der Aufwand mÃ¶glichst gering ist. Wenn wir Wege finden, dieselbe Aufgabe mit weniger Aufwand zu erledigen, bedeutet dies, dass Computer dieselbe Datenmenge in kÃ¼rzerer Zeit verarbeiten kÃ¶nnen. Ebenso bedeutet dies, dass Computer in derselben Zeit grÃ¶ssere Datenmengen verarbeiten kÃ¶nnen. Es liegt nahe zu vermuten, dass wir zum Verarbeiten grosser Datenmengen lediglich besonders schnelle Computer benÃ¶tigen. Allerdings ist dies ein Trugschluss. Es ist sicherlich zutrÃ¤glich, besonders schnelle Computer zu verwenden, allerdings haben Algorithmen einen mindestens genauso grossen Einfluss auf die Menge der Daten, die wir zeitnah verarbeiten kÃ¶nnen. Zum Beispiel ist es mÃ¶glich, dass geeignete Algorithmen eine grosse Datenmenge in wenigen Minuten auf einem handelsÃ¼blichen Laptop verarbeiten kÃ¶nnen, wohingegen weniger geeignete Algorithmen fÃ¼r dieselbe Datenmenge selbst auf dem weltweit schnellsten Supercomputer mindestens solange brÃ¤uchte, bis unsere Sonne erlischt. Was sind Algorithmen? Wir kÃ¶nnen Algorithmen zweckmÃ¤ssig und informell definieren als systematische Zerlegungen eines vermeintlich schwierigen Problems in einfache Schritte. Diese Definition scheint zunÃ¤chst banal, da jede LÃ¶sung eines Problems wohl beinhaltet, es in machbare Schritte zu zerlegen. TatsÃ¤chlich weist diese scheinbare BanalitÃ¤t bereits auf die grundlegende Bedeutung des Algorithmenbegriffs hin. Unsere informelle Definition beinhaltet, dass die Zerlegung systematisch sein soll. Wir meinen damit, dass die Zerlegung verallgemeinerbar ist und nicht spezialisiert ist auf eine bestimmte Instanz des Problems. Um diese Verallgemeinerbarkeit zu gewÃ¤hrleisten, verlangen wir fÃ¼r einen 1 Algorithmus ein eindeutige, vollstÃ¤ndige und allgemeingÃ¼ltige Beschreibung der Abfolge von Schritten zur LÃ¶sung des Problems. Ein gutes Beispiel ist die aus der Schule bekannte schriftliche Multiplikation. Dieser Algorithmus erlaubt uns, zwei beliebige Zahlen miteinander zu multiplizieren, indem wir eine Reihe von Additionen und einstelligen Multiplikationen durchfÃ¼hren. In diesem Sinn zerlegen wir das Problem der mehrstelligen Multiplikation in einfache Schritte. Die Zerlegung ist verallgemeinerbar in dem Sinn, dass sie nicht fÃ¼r jedes Paar von Zahlen neu ermittelt werden muss, sondern dass wir die Zerlegung fÃ¼r ein beliebiges Paar von Zahlen beschreiben kÃ¶nnen. In der Informatik spielen Algorithmen eine zentrale Rolle: Computer kÃ¶nnen beliebige Algo- rithmen auf Daten unvorstellbar schnell ausfÃ¼hren mit Milliarden von Schritten pro Sekunde. (Wir bezeichnen die mÃ¶glichen Schritte eines Computers als elementare Operationen.) In diesem Sinn werden alle FÃ¤higkeiten von Computern erst durch Algorithmen ermÃ¶glicht. Aus diesem Grund wird die Informatik oft als Wissenschaft der Algorithmen definiert. In der Vorlesung werden wir verschiedene Algorithmen entwerfen und ihre Eigenschaften analysieren. Allerdings ist das eigentliche Ziel der Vorlesung nicht die Funktionsweise oder die Eigenschaften dieser konkreten Algorithmen zu erlernen. Vielmehr ist das Ziel Ihnen eine algorithmische Denkweise zu vermitteln. Ein wichtiger Teil dieser Denkweise ist die Art von Fragen, die wir zu Algorithmen untersuchen: â€¢ Welche verschiedenen Algorithmen gibt es fÃ¼r dasselbe Problem? â€¢ Wie kÃ¶nnen wir diese Algorithmen miteinander vergleichen? KÃ¶nnen wir Algorithmen ein QualitÃ¤tsmass zuordnen und quantitativ bemessen, wie viel besser ein Algorithmus ist als ein anderer? â€¢ KÃ¶nnen wir den bestmÃ¶glichen Algorithmus fÃ¼r ein Problem bestimmen bezÃ¼glich dieses QualitÃ¤tsmasses? 2 Schriftliche Multiplikation Die schriftliche Multiplikation erlaubt uns, zwei beliebige Zahlen zu multiplizieren. Da dieser Algorithmus schon aus der Schule bekannt ist, nennen wir ihn oft Schulalgorithmus. Schriftliche Multiplikation 2-stelliger Zahlen. Am Beispiel der Zahlen ğ‘ = 87 und ğ‘ = 43 lÃ¤sst sich der Algorithmus wie folgt darstellen: ğ‘1 ğ‘0 Â· ğ‘1 ğ‘0 8 7 Â· 4 3 2 1 ğ‘0 Â· ğ‘0 2 4 ğ‘1 Â· ğ‘0 2 8 ğ‘0 Â· ğ‘1 3 2 ğ‘1 Â· ğ‘1 3 7 4 1 2 ZunÃ¤chst wird die Einerziffer der ersten Zahl ğ‘0 = 7 mit der Einerziffer der zweiten Zahl ğ‘0 = 3 multipliziert. Wir notieren das Ergebnis ğ‘0 Â· ğ‘0 = 21. Anschliessend wird die Zehnerziffer der ersten Zahl ğ‘1 = 8) mit der Einerziffer der zweiten Zahl ğ‘0 = 3 multipliziert. Wir schreiben das Ergebnis ğ‘1 Â· ğ‘0 = 24 um eine Stelle nach links versetzt unter das vorherige Ergebnis. Im nÃ¤chsten Schritt wird die Einerziffer der ersten Zahl ğ‘0 = 7 mit der Zehnerziffer der zweiten Zahl ğ‘1 = 4 multipliziert. Wir schreiben das Ergebnis ğ‘0 Â· ğ‘1 = 28 um eine Stelle nach links versetzt unter das vorherige Ergebnis. Schliesslich wird die Zehnerziffer der ersten Zahl ğ‘1 = 8 mit der Zehnerziffer der zweiten Zahl ğ‘1 = 4 multipliziert. Wir schreiben das Ergebnis ğ‘1 Â· ğ‘1 = 32 um zwei Stellen nach links versetzt unter das vorherige Ergebnis. Zum Schluss addieren wir die vier berechneten Zahlen und erhalten das Ergebnis 3741. FÃ¼r den konkreten Fall ğ‘ = 87 und ğ‘ = 43 kÃ¶nnten wir uns mithilfe eines Taschenrechners versichern, dass dieses Ergebnis korrekt ist. FÃ¼r den allgemeinen Fall kÃ¶nnen wir uns von der Korrektheit wie folgt Ã¼berzeugen: FÃ¼r die Stellen der Zahlen ğ‘ und ğ‘ im Dezimalsystem gilt ğ‘ = 10ğ‘1 + ğ‘0 und ğ‘ = 10ğ‘1 +ğ‘0, wobei ğ‘0, ğ‘0 die Einerziffern und ğ‘1, ğ‘1 die Zehnerziffern von ğ‘ und ğ‘ sind. Laut seiner Beschreibung berechnet der Algorithmus die Zahl ğ‘0 Â·ğ‘0 +10Â· ğ‘1 Â·ğ‘0 +10Â· ğ‘0 Â·ğ‘1 +100Â· ğ‘1 Â·ğ‘1. Unter Verwendung des Distributivgesetzes der Addition und Multiplikation zeigt die folgende Rechnung, dass dieses Ergebnis immer mit dem LÃ¶sungswert ğ‘ Â· ğ‘ Ã¼bereinstimmt, ğ‘ Â· ğ‘ = (10 Â· ğ‘1 + ğ‘0) Â· (10 Â· ğ‘1 + ğ‘0) = ğ‘0 Â· ğ‘0 + 10 Â· ğ‘1 Â· ğ‘0 + 10 Â· ğ‘0 Â· ğ‘1 + 100 Â· ğ‘1 Â· ğ‘1 . Schriftliche Multiplikation ğ‘›-stelliger Zahlen. Seien ğ‘ und ğ‘ zwei beliebige ğ‘›-stellige Zahlen mit ğ‘ = 10ğ‘›âˆ’1 Â· ğ‘ğ‘›âˆ’1 + 10ğ‘›âˆ’2 Â· ğ‘ğ‘›âˆ’2 + Â· Â· Â· + 10 Â· ğ‘1 + ğ‘0, ğ‘ = 10ğ‘›âˆ’1 Â· ğ‘ğ‘›âˆ’1 + 10ğ‘›âˆ’2 Â· ğ‘ğ‘›âˆ’2 + Â· Â· Â· + 10 Â· ğ‘1 + ğ‘0, wobei ğ‘ğ‘›âˆ’1, . . . , ğ‘0 âˆˆ {0, . . . , 9} und ğ‘ğ‘›âˆ’1, . . . , ğ‘0 âˆˆ {0, . . . , 9} die Stellen von ğ‘ und ğ‘ im Dezimalsys- tem sind. Der Algorithmus berechnet alle Teilprodukte ğ‘ğ‘– Â· ğ‘ ğ‘— fÃ¼r ğ‘–, ğ‘— âˆˆ {0, 1, . . . , ğ‘› âˆ’1}. Es gibt insgesamt ğ‘›2 solcher Teilprodukte. Anschliessend werden die Teilprodukte addiert, wobei sie ihrem Stellenwert entsprechend verschoben werden. Geht es besser? Es stellt sich die Frage, ob ein besserer Algorithmus fÃ¼r die Multiplikation existiert, der mit wesentlich weniger einstelligen Multiplikationen auskommt. Der berÃ¼hmte russische Mathematiker Kolmogorov hatte vermutet, dass die Anzahl der einstelligen Multiplikationen im Schulalgorithmus, bis auf konstante Faktoren, bestmÃ¶glich ist. Diese Vermutung wurde jedoch im Jahr 1960 von Anatoli Karatsuba, einem seiner Studenten, widerlegt. 3 Karatsubas Algorithmus Im vorherigen Abschnitt haben wir gesehen, dass der Schulalgorithmus ğ‘›2 einstellige Multiplika- tionen benÃ¶tigt, um zwei ğ‘›-stellige Zahlen zu multiplizieren. In diesem Abschnitt untersuchen wir, ob wir solche Zahlen mit wesentlich weniger einstelligen Multiplikationen berechnen kÃ¶nnen. 3 Karatsubas Algorithmus fÃ¼r 2-stellige Zahlen. Wir betrachten zunÃ¤chst wieder das Beispiel der Zahlen ğ‘ = 87 und ğ‘ = 43. Der Schulalgorithmus benÃ¶tigt fÃ¼r diesen Fall 4 einstellige Multiplikationen. Karatsuba entdeckte einen Algorithmus, der dieses Problem mit nur 3 einstelligen Multiplikationen lÃ¶st. ğ‘1 ğ‘0 Â· ğ‘1 ğ‘0 8 7 Â· 4 3 2 1 ğ‘0 Â· ğ‘0 3 2 ğ‘1 Â· ğ‘1 âˆ’1 âˆ’(ğ‘1 âˆ’ ğ‘0) Â· (ğ‘1 âˆ’ ğ‘0) 5 3 ğ‘0 Â· ğ‘0 + ğ‘1 Â· ğ‘1 3 7 4 1 ZunÃ¤chst berechnen wir die Produkte ğ‘0 Â· ğ‘0 und ğ‘1 Â· ğ‘1, wie im Schulalgorithmus. Danach berechnen wir noch ein zusÃ¤tzliches Produkt (ğ‘1 âˆ’ ğ‘0) Â· (ğ‘1 âˆ’ ğ‘0). Im Beispiel ist ğ‘1 âˆ’ ğ‘0 = 1 und ğ‘1 âˆ’ ğ‘0 = 1, also ist das Produkt (ğ‘1 âˆ’ ğ‘0) Â· (ğ‘1 âˆ’ ğ‘0) = 1. Wir notieren dieses Ergebnis mit negativem Vorzeichen versehen und um eine Stelle nach links versetzt. Anschliessen verwenden wir die zuvor berechneten Produkte ğ‘0 Â· ğ‘0 und ğ‘1 Â· ğ‘1 wieder und notieren ihre Summe um eine Stelle nach links versetzt. Anschliessend addieren wir die alle Zahlen und erhalten das gewÃ¼nschte Ergebnis 3741. Korrektheit fÃ¼r 2-stellige Zahlen. FÃ¼r die Zahlen ğ‘ = 10ğ‘1 + ğ‘0 und ğ‘ = 10ğ‘1 + ğ‘0 berechnet Karatsubas Algorithmus als Ergebnis ğ‘0 Â· ğ‘0 + 10 Â· (ğ‘0 Â· ğ‘0 + ğ‘1 Â· ğ‘1 âˆ’ (ğ‘1 âˆ’ ğ‘0) Â· (ğ‘1 âˆ’ ğ‘0)) + 100 Â· ğ‘1 Â· ğ‘1. FÃ¼r den mittleren Term mit Koeffizienten 10 gilt ğ‘0 Â· ğ‘0 + ğ‘1 Â· ğ‘1 âˆ’ (ğ‘1 âˆ’ ğ‘0) Â· (ğ‘1 âˆ’ ğ‘0) = ğ‘1 Â· ğ‘0 + ğ‘0 Â· ğ‘1 . Also berechnet Karatsubas Algorithmus dasselbe Ergebnis wie der Schulalgorithmus. Somit ist Karatsubas Algorithmus fÃ¼r zweistellige Zahlen korrekt. Wir sehen, dass Karatsubas Algorithmus fÃ¼r zweistellige Zahlen nur 3 Teilprodukte (anstatt 4 Teilprodukte wie beim Schulalgorithmus). Allerdings ist zunÃ¤chst unklar, inwiefern Karatsubas Algorithmus wirklich besser ist als die Schulmethode. (Unter anderem fÃ¼hrt Karatsubas einige zusÃ¤tzliche Subtraktionen aus, die so im Schulalgorithmus nicht vorkommen.) Karatsubas Algorithmus fÃ¼r 4-stellige Zahlen. Wir wollen nun Karatsubas Idee verallgemeinern auf die Multiplikation von zwei 4-stelligen Zahlen. Als Beispiel wÃ¤hlen wir die Zahlen ğ‘ = 8765 und ğ‘ = 4321. Wir spalten die vierstellige Zahlen ğ‘ und ğ‘ auf in jeweils zwei zweistellige Zahlen, so dass ğ‘ = 102ğ‘1 + ğ‘0 und ğ‘ = 102ğ‘1 + ğ‘0, wobei ğ‘1 = 87, ğ‘0 = 65, ğ‘1 = 43, und ğ‘0 = 21. Wir verwenden nun dieselbe Idee wie zuvor um eine 4-stellige Multiplikation auf drei 2-stellige Multiplikationen zurÃ¼ckzufÃ¼hren. 4 ğ‘1 ğ‘0 Â· ğ‘1 ğ‘0 87 65 Â· 43 21 13 65 ğ‘0 Â· ğ‘0 37 41 ğ‘1 Â· ğ‘1 46 22 ğ‘0 Â· ğ‘0 + ğ‘1 Â· ğ‘1 âˆ’ (ğ‘1 âˆ’ ğ‘0) Â· (ğ‘1 âˆ’ ğ‘0) 37 87 35 65 Wir kÃ¶nnen die drei 2-stelligen Multiplikationen berechnen mit jeweils drei 1-stelligen Multip- likationen, indem wir Karatsubas Algorithmus fÃ¼r 2-stellige Zahlen verwenden. Insgesamt fÃ¼hrt Karatsubas Algorithmus fÃ¼r 4-stellige Zahlen also 3 Â· 3 = 9 einstellige Multiplikationen aus. Der Schulalgorithmus braucht fÃ¼r diesen Fall 42 = 16 einstellige Multiplikationen. Veranschaulichung. Mithilfe eines Baumdiagramms kÃ¶nnen wir den Ablauf von Karatsubas Algorithmus veranschaulichen. Der Knoten ganz oben im Diagramm entspricht der ursprÃ¼nglichen Multiplikation. Die Kinder eines Knotens entsprechen den Multiplikationen, in die die Multiplika- tion des Elternknotens zerlegt wird. ğ‘ Â· ğ‘ ğ‘0 Â· ğ‘0 ğ‘1 Â· ğ‘1 (ğ‘1 âˆ’ ğ‘0) Â· (ğ‘1 âˆ’ ğ‘0) Die Knoten in der zweiten Ebene des Diagramms entsprechen 2-stelligen Multiplikationen. Die Knoten in der dritten Ebene entsprechen 1-stelligen Multiplikationen. Karatsubas Algorithmus fÃ¼r ğ‘›-stellige Zahlen. Sei ğ‘˜ eine natÃ¼rliche Zahl und ğ‘› = 2ğ‘˜. Seien ğ‘ und ğ‘ zwei beliebige ğ‘›-stellige Zahlen. Wir schreiben die Zahlen ğ‘ und ğ‘ in der Form ğ‘ = 10ğ‘›/2ğ‘1 + ğ‘0 und ğ‘ = 10ğ‘›/2ğ‘1 + ğ‘0, wobei ğ‘1 und ğ‘1 die ğ‘›/2 hÃ¶chstwertigsten Stellen von ğ‘ und ğ‘ sind und ğ‘0 und ğ‘0 die ğ‘›/2 niedrigstwertigsten Stellen von ğ‘ und ğ‘ sind. Mit derselben Idee wie zuvor kÃ¶nnen wir eine 2ğ‘˜-stellige Multiplikationen zurÃ¼ckfÃ¼hren auf drei 2ğ‘˜âˆ’1-stellige Multiplikationen. Diese 2ğ‘˜âˆ’1-stellige Multiplikationen fÃ¼hren wir zurÃ¼ck auf jeweils drei 2ğ‘˜âˆ’2-stellige Multiplikationen. Wir fahren fort bis wir alles auf 1-stellige Multiplikationen zurÃ¼ckgefÃ¼hrt haben. Wie zuvor kÃ¶nnen wir den Ablauf des Algorithmus mithilfe eines Baumdiagramms veran- schaulichen. 5 ğ‘ Â· ğ‘ ğ‘0 Â· ğ‘0 . . . . . . . . . ğ‘1 Â· ğ‘1 . . . . . . . . . (ğ‘1 âˆ’ ğ‘0) Â· (ğ‘1 âˆ’ ğ‘0) . . . . . . . . . Der Baum hat ğ‘˜ + 1 Ebenen. In der ğ‘–-ten Ebene befinden sich 3ğ‘–âˆ’1 Knoten, die jeweils der Multiplikation zweier 2ğ‘˜âˆ’ğ‘–+1-stelliger Zahlen entsprechen. In der vorletzten Ebene (ğ‘– = ğ‘˜) befinden sich 3ğ‘˜âˆ’1 Knoten, die jeweils einer 2-stelligen Multiplikation entsprechen. Jeder dieser Knoten fÃ¼hrt zu drei einstelligen Multiplikationen. Insgesamt fÃ¼hrt der Algorithmus also 3ğ‘˜ einstellige Multiplikationen aus. Dabei ist zu beachten, dass die Subtraktionen, die der Algorithmus ausfÃ¼hrt, nicht zu zusÃ¤tzlichen einstelligen Multiplikation fÃ¼hren. Analyse. FÃ¼r zwei ğ‘› = 2ğ‘˜-stellige Zahlen benÃ¶tigt Karatsubas Algorithmus 3ğ‘˜ einstellige Multip- likationen. Die Schulmethode hingegen verwendet ğ‘›2 = (2ğ‘˜)2 = 4ğ‘˜ einstellige Multiplikationen. FÃ¼r grosse Werte ğ‘˜ ist 3ğ‘˜ wesentlich kleiner als 4ğ‘˜. FÃ¼r ğ‘˜ = 9 gilt (4/3)ğ‘˜ â‰ˆ 13.32 und damit ist Karatsubas Algorithmus mehr als zehnmal gÃ¼nstiger als der Schulalgorithmus im Bezug auf die Anzahl einstelliger Multiplikationen. FÃ¼r ğ‘˜ = 18 gilt (4/3)ğ‘˜ â‰ˆ (13.32)2 > 177 und damit ist Karatsubas Algorithmus mehr als 177-mal gÃ¼nstiger. Geht es noch besser? TatsÃ¤chlich ist es mÃ¶glich, zwei ğ‘›-stellige Zahlen mit noch weniger als 3ğ‘˜ einstelligen Multiplikationen zu multiplizieren, falls ğ‘› = 2ğ‘˜. Es gibt einen Algorithmus, der hÃ¶chstens ğ¶ Â· 2ğ‘˜ Â· ğ‘˜ einstellige Multiplikationen benÃ¶tigt, fÃ¼r eine sehr grosse Konstante ğ¶. Dieser Algorithmus wurde erst im Jahr 2019 entdeckt. Leider ist der Algorithmus sehr kompliziert. Deshalb werden wir diesen Algorithmus in der Vorlesung nicht weiter besprechen. Zudem stellt sich der Vorteil gegenÃ¼ber Karatsubas Algorithmus erst fÃ¼r astronomisch grosse Zahlen ein. Im Gegensatz zu Karatsubas Algorithmus hat dieser Algorithmus (noch) keine praktische Relevanz. Fazit. In dieser Vorlesung geht es nicht darum, besser multiplizieren zu lernen, sondern darum, eine algorithmische Denkweise zu entwickeln. Ein wichtiger Teil dieser Denkweise ist die Bereitschaft, naheliegende LÃ¶sungsverfahren zu hinterfragen und zu untersuchen, ob es bessere LÃ¶sungsver- fahren gibt. Oftmals lassen sich dramatische Verbesserungen erzielen. Karatsubas Algorithmus ist ein gutes Beispiel dafÃ¼r. Die Grundidee von Karatsubas Algorithmus ist ein Problem (wie ğ‘›-stellige Multiplikation) auf ein leichteres Teilproblem derselben Art zurÃ¼ckzufÃ¼hren. Diese Strategie ist erstaunlich vielseitig anwendbar und heisst Rekursion. Falls die Teilprobleme entstehen, indem wir die ursprÃ¼ngliche Eingabe in mehrere ungefÃ¤hr gleichgrosse Teile aufspalten, sprechen wir oft von â€œdivide-and- conquerâ€. 6 4 Pasture-break Problem In diesem Abschnitt diskutieren wir das Pasture-break Problem. Dieses Problem ist etwas ungewÃ¶hn- lich, da es nicht direkt darum geht, Eingabedaten zu verarbeiten. Dennoch ist es ein interessantes Problem und illustriert einige wichtige Konzepte der Entwicklung und Analyse von Algorithmen. Problemstellung. Wir stellen uns vor, dass eine kurzsichtige Kuh auf einer unendlich grossen Weide steht. Die Weide ist begrenzt durch einen Zaun. Es gibt genau eine LÃ¼cke im Zaun. Die Kuh mÃ¶chte die Weide verlassen (wohl weil das Gras auf der anderen Seite des Zauns grÃ¼ner ist). Allerdings weiss sie nicht, wo sich die LÃ¼cke befindet. Zaun Kuh k Schritte Wir nehmen an, dass die Kuh sich nur in Schritten parallel zum Zaun bewegen kann. In einem Schritt kann sie nur feststellen, ob sich an ihrer Position die LÃ¼cke befindet. Unser Ziel ist es, die Kuh so zu steuern, dass sie mit mÃ¶glichst wenigen Schritten die LÃ¼cke findet und die Weide verlassen kann. Distanz bekannt. Nehmen wir zunÃ¤chst an, dass die Kuh die Distanz ğ‘˜ zur LÃ¼cke kennt. In diesem Fall kann sie die LÃ¼cke finden, indem sie ğ‘˜ Schritte nach links lÃ¤uft und anschliessend 2ğ‘˜ Schritte nach rechts. Dieser Algorithmus findet die LÃ¼cke in jedem Fall. Falls sich die LÃ¼cke links vom Startpunkt befindet, dann findet sie die Kuh schon nach ğ‘˜ Schritten. Falls sich die LÃ¼cke rechts vom Startpunkt befindet, dann findet sie die Kuh nach 3ğ‘˜ Schritten. Der worst case des Algorithmus betrÃ¤gt also 3ğ‘˜ Schritte. Start LÃ¼cke LÃ¼cke! k k k Distanz unbekannt. In der Praxis ist es natÃ¼rlich unrealistisch anzunehmen, dass die Kuh die Distanz zur LÃ¼cke kennt. Wir wollen deshalb einen Algorithmus finden, der auch ohne dieses Wissen auskommt. Eine naheliegende Idee ist es, die Distanz vom Startpunkt in jeder Iteration allmÃ¤hlich zu erhÃ¶hen, solange bis wir die LÃ¼cke finden. 7 Algorithmus 1. ZunÃ¤chst betrachten wir den Algorithmus, der die Distanz zum Startpunkt bei jedem Richtungswechsel um jeweils 1 erhÃ¶ht. Die Kuh lÃ¤uft zuerst einen Schritt nach links, dann zurÃ¼ck zum Startpunkt. Anschliessend lÃ¤uft die Kuh zwei Schritte nach rechts, dann zurÃ¼ck zum Startpunkt. Danach drei Schritte nach links, und so weiter. Wir analysieren nun den worst case dieses Algorithmus. In diesem Fall lÃ¤uft die Kuh zunÃ¤chst ğ‘˜ âˆ’ 1 Schritte in die richtige Richtung (also in Richtung der LÃ¼cke). Einen Schritt vor der LÃ¼cke kehrt sie um und lÃ¤uft ğ‘˜ âˆ’ 1 Schritte zurÃ¼ck zum Startpunkt. Dann lÃ¤uft die Kuh ğ‘˜ Schritte in die falsche Richtung (also entgegen der Richtung der LÃ¼cke). Die Kuh kehrt um und lÃ¤uft ğ‘˜ Schritt zurÃ¼ck zum Startpunkt. Schliesslich macht sich die Kuh wieder in die richtige Richtung auf und findet die LÃ¼cke nach ğ‘˜ weiteren Schritten. Start LÃ¼cke 1 1 2 23 3 k-1 k-1k k k . . . LÃ¼cke! Insgesamt betrÃ¤gt die Anzahl der Schritte in diesem Fall, 2 Â· 1 + 2 Â· 2 + 2 Â· 3 + Â· Â· Â· + 2 Â· (ğ‘˜ âˆ’ 1) + 2 Â· ğ‘˜ + ğ‘˜ Nach der Gaussschen Formel (mÃ¶glicherweise aus der Schule bekannt) betrÃ¤gt die Summe der ersten ğ‘˜ natÃ¼rlichen Zahlen ğ‘˜ Â· (ğ‘˜ + 1)/2. Also lÃ¤sst sich die worst-case Schrittzahl wie folgt vereinfachen, 2 Â· ğ‘˜ Â· (ğ‘˜ + 1) 2 + ğ‘˜ = ğ‘˜ Â· (ğ‘˜ + 2) . Algorithmus 2. Im vorherigen Algorithmus haben wir die Distanz vom Startpunkt in jeder Iteration nur um 1 erhÃ¶ht. Das heisst in jeder Iteration untersucht die Kuh nur 1-2 neue Positionen, wohingegen der Aufwand in jeder Iteration um einen Schritt wÃ¤chst. In diesem Sinn ist der Aufwand pro Iteration nicht verhÃ¤ltnismÃ¤ssig zum Informationsgewinn pro Iteration. Es liegt damit nahe, den Algorithmus so abzuÃ¤ndern, dass pro Iteration die Anzahl der schon bekannten Positionen ungefÃ¤hr gleich gross ist wie die Anzahl der neuen Positionen. Dieser Algorithmus verdoppelt also die Distanz in jeder Iteration. 8 Konkret lÃ¤uft die Kuh zuerst einen Schritt nach links, dann zurÃ¼ck zum Startpunkt. Anschliessend lÃ¤uft sie zwei Schritte nach rechts, dann zurÃ¼ck zum Startpunkt. Danach vier Schritte nach links, dann zurÃ¼ck zum Startpunkt. Und so weiter. Wir bestimmen wieder die Anzahl Schritte im worst case. WÃ¤hle eine natÃ¼rliche Zahl ğ‘– so, dass 2ğ‘–âˆ’1 < ğ‘˜ â©½ 2ğ‘–. (Diese Wahl von ğ‘– ist fÃ¼r jedes ğ‘˜ eindeutig!) Im worst case lÃ¤uft die Kuh zunÃ¤chst 2ğ‘–âˆ’1 Schritte in die richtige Richtung, dann kehrt sie um und lÃ¤uft 2ğ‘–âˆ’1 Schritte zurÃ¼ck zum Startpunkt. Danach lÃ¤uft sie 2ğ‘– Schritte in die falsche Richtung und 2ğ‘– Schritte zurÃ¼ck zum Startpunkt. Anschliessend macht sich die Kuh auf, um 2ğ‘–+1 Schritte in die richtige Richtung zu laufen, aber sie findet schon nach ğ‘˜ Schritte die LÃ¼cke. Start LÃ¼cke 1 1 2 24 4 2ğ‘–âˆ’1 2ğ‘–âˆ’12ğ‘– 2ğ‘– k . . . LÃ¼cke! Insgesamt benÃ¶tigt die Kuh im worst case also 2 Â· (2 0 + 2 1 + Â· Â· Â· + 2ğ‘–âˆ’1 + 2ğ‘–) + ğ‘˜ Schritte. Die Summe der ersten ğ‘– + 1 Zweierpotenzen ist gleich 2ğ‘–+1 âˆ’ 1. (Siehe Abschnitt Ã¼ber vollstÃ¤ndige Induktion.) Also lÃ¤sst sich die worst-case Anzahl der Schritte folgendermassen beschrÃ¤nken, 2 Â· (2ğ‘–+1 âˆ’ 1) + ğ‘˜ < 2 Â· 2ğ‘–+1 + ğ‘˜ â©½ 8ğ‘˜ + ğ‘˜ = 9ğ‘˜ , wobei wir 2ğ‘–+1 = 4 Â· 2ğ‘–âˆ’1 < 4ğ‘˜ verwenden. Vergleich. FÃ¼r grosse Werte von ğ‘˜ ist die worst-case Schranke 9ğ‘˜ von Algorithmus 2 wesentlich kleiner als der worst case ğ‘˜ Â· (ğ‘˜ + 2) von Algorithmus 1. Zum Beispiel, fÃ¼r ğ‘˜ = 100 benÃ¶tigt Algorithmus 1 mehr als 10000 Schritte im worst case, wohingegen Algorithmus 2 stets weniger als 900 Schritte benÃ¶tigt. 9 Geht es besser? Es liegt nahe zu vermuten, dass wir den worst case verbessern kÃ¶nnten, indem wir die Distanzen vom Startpunkt noch schneller mit jeder Iteration wachsen lassen. Es stellt sich aber heraus, dass sich dadurch der worst case verschlechtert! TatsÃ¤chlich ist die worst-case Schranke 9ğ‘˜ bestmÃ¶glich. FÃ¼r jeden Algorithmus und fÃ¼r jedes ğœ€ > 0 gibt es ein ğ‘˜, so dass der Algorithmus im worst case mindestens (9 âˆ’ ğœ€) Â· ğ‘˜ Schritte benÃ¶tigt. (An dieser Stelle lassen wir diese Behauptung unbewiesen.) 5 VollstÃ¤ndige Induktion Um die Effizienz und Korrektheit eines Algorithmus zu ermitteln, kÃ¶nnten wir eine pragmatische Sichtweise einnehmen und den Algorithmus auf mÃ¶glichst vielen interessanten Eingaben testen. Solche Tests sind wertvoll, erlauben uns aber keine RÃ¼ckschlÃ¼sse darauf, wie sich der Algorithmus auf anderen Eingaben verhÃ¤lt. In vielen Bereichen des tÃ¤glichen Lebens stehen Ursache und Wirkung miteinander im VerhÃ¤ltnis. Aber bei Algorithmen kÃ¶nnen schon kleine VerÃ¤nderungen der Eingabe verheerende Folgen fÃ¼r die Ausgabe haben. Deshalb haben wir in dieser Vorlesung den Anspruch, unsere Algorithmen fÃ¼r alle Eingaben zu analysieren. Solche universellen Aussagen kÃ¶nnen wir nur mittels mathematischen Beweisen treffen. Obwohl es kein einfaches Rezept dafÃ¼r gibt, mathematische Beweise zu finden, kÃ¶nnen Beweis- prinzipien die Suche nach Beweisen erheblich erleichtern. Ein besonders wichtiges und vielseitiges Beweisprinzip ist die vollstÃ¤ndige Induktion. Beispiel eines Induktionsbeweises. Sei ğ‘†ğ‘˜ = 1 + 2 + 4 + Â· Â· Â· + 2ğ‘˜âˆ’1 die Summe der ersten ğ‘˜ Zweierpotenzen. FÃ¼r kleine Werte von ğ‘˜ kÃ¶nnen wir diese Summe leicht berechnen: ğ‘†1 = 1 , ğ‘†2 = 1 + 2 = 3 , ğ‘†3 = 1 + 2 + 4 = 7 , ğ‘†4 = 1 + 2 + 4 + 8 = 15 . Anhand dieser Werte sehen wir, dass fÃ¼r alle ğ‘˜ â©½ 4 die Summe ğ‘†ğ‘˜ genau eins weniger ist als die nÃ¤chste Zweierpotenz 2ğ‘˜. Es liegt nahe zu vermuten, dass diese Eigenschaft verallgemeinert werden kann und dass ğ‘†ğ‘˜ = 2ğ‘˜ âˆ’ 1 fÃ¼r alle natÃ¼rlichen Zahlen ğ‘˜ gilt. Um diese Aussage fÃ¼r alle natÃ¼rlichen Zahlen ğ‘˜ zu beweisen, verwenden wir das Beweisprinzip der vollstÃ¤ndigen Induktion. Dazu mÃ¼ssen wir zunÃ¤chst den Induktionsanfang ausfÃ¼hren und zeigen, dass die Aussage fÃ¼r ğ‘˜ = 1 gilt. TatsÃ¤chlich sind die beiden Werte ğ‘†1 = 1 und 21 âˆ’ 1 = 1 gleich. Im Anschluss mÃ¼ssen wir den Induktionsschritt ausfÃ¼hren und fÃ¼r alle natÃ¼rlichen Zahlen ğ‘˜ zeigen, dass ğ‘†ğ‘˜+1 = 2ğ‘˜+1 âˆ’ 1 gilt unter der Annahme, dass ğ‘†ğ‘˜ = 2ğ‘˜ âˆ’ 1 gilt. TatsÃ¤chlich kÃ¶nnen wir diesen Induktionsschritt hier ausfÃ¼hren, indem wir ğ‘†ğ‘˜+1 und ğ‘†ğ‘˜ wie folgt zueinander in Bezug setzen: ğ‘†ğ‘˜+1 = ğ‘†ğ‘˜ + 2ğ‘˜ (per Definition) = 2ğ‘˜ âˆ’ 1 + 2ğ‘˜ (Induktionshypothese) = 2ğ‘˜+1 âˆ’ 1 . (Rechenregel) 10 Wir konnten hier also sowohl den Induktionsanfang als auch den Induktionsschritt erfolgreich ausfÃ¼hren. Das Beweisprinzip der vollstÃ¤ndigen Induktion besagt, dass wir dadurch die IdentitÃ¤t ğ‘†ğ‘˜ = 2ğ‘˜ âˆ’ 1 fÃ¼r alle natÃ¼rlichen Zahlen ğ‘˜ bewiesen haben. Allgemeine Form. Sei ğ´(ğ‘˜) eine Aussage Ã¼ber eine natÃ¼rliche Zahl ğ‘˜, z.B. die Aussage, dass die Summe der ersten ğ‘˜ Zweierpotenzen 2ğ‘˜ âˆ’ 1 betrÃ¤gt. Unser Ziel ist es, zu beweisen, dass diese Aussage fÃ¼r alle natÃ¼rlichen Zahlen ğ‘˜ âˆˆ â„• gilt. Ein Induktionsbeweis besteht aus zwei Teilen, dem Induktionsanfang und dem Induktionsschritt. â€¢ FÃ¼r den Induktionsanfang mÃ¼ssen wir zeigen, dass die Aussage ğ´(1) gilt. Dieser Teil eines Induktionsbeweises ist oft leichter als der Induktionsschritt. â€¢ Beim Induktionsschritt mÃ¼ssen wir fÃ¼r alle natÃ¼rlichen Zahlen ğ‘˜ âˆˆ â„• zeigen, dass aus der Aussage ğ´(ğ‘˜) die Aussage ğ´(ğ‘˜ + 1) folgt. Wir mÃ¼ssen also die Aussage ğ´(ğ‘˜ + 1) beweisen, dÃ¼rfen dabei aber verwenden, dass die Aussage ğ´(ğ‘˜) gilt. Beim Induktionsschritt ist es wichtig, wirklich alle natÃ¼rlichen Zahlen ğ‘˜ âˆˆ â„• abzudecken. 11","libVersion":"0.3.2","langs":""}