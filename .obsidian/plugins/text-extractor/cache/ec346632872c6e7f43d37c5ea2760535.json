{"path":"sem3/A&D/VRL/extra/script/Algo Datastructures Week 1.pdf","text":"Algorithmen und Datenstrukturen Johannes Lengler David Steurer October 7, 2024 1 Algorithmen Algorithmen spielen eine wichtige Rolle, sobald wir Computer verwenden wollen, um grosse Datenmengen zu verarbeiten. Unsere Fähigkeit grosse Datenmengen zu verarbeiten erschliesst uns erstaunliche Möglichkeiten. So können bestimmte Algorithmen moderne Sprachmodelle wie Chat- GPT erstellen, indem sie unglaublich grosse Datenmengen verarbeiten. Näherungsweise können wir uns vorstellen, dass diese Algorithmen die gesammelten Texte der Menschheit verarbeiten, insbesondere alle Bücher und Zeitungsartikel, die jemals verfasst wurden. Algorithmen erstellen interessante Verbindungen zu vielen anderen Themen des Informatik- studiums. Zum Beispiel, befasst sich die Programmierung mit der Frage, wie wir Aufgaben so beschreiben, dass Computer sie korrekt erledigen können. Im Bereich der Algorithmen geht es auch darum, Aufgaben mithilfe von Computern zu erledigen, allerdings haben wir neben der Korrektheit zusätzlich zum Ziel, dass der Aufwand möglichst gering ist. Wenn wir Wege finden, dieselbe Aufgabe mit weniger Aufwand zu erledigen, bedeutet dies, dass Computer dieselbe Datenmenge in kürzerer Zeit verarbeiten können. Ebenso bedeutet dies, dass Computer in derselben Zeit grössere Datenmengen verarbeiten können. Es liegt nahe zu vermuten, dass wir zum Verarbeiten grosser Datenmengen lediglich besonders schnelle Computer benötigen. Allerdings ist dies ein Trugschluss. Es ist sicherlich zuträglich, besonders schnelle Computer zu verwenden, allerdings haben Algorithmen einen mindestens genauso grossen Einfluss auf die Menge der Daten, die wir zeitnah verarbeiten können. Zum Beispiel ist es möglich, dass geeignete Algorithmen eine grosse Datenmenge in wenigen Minuten auf einem handelsüblichen Laptop verarbeiten können, wohingegen weniger geeignete Algorithmen für dieselbe Datenmenge selbst auf dem weltweit schnellsten Supercomputer mindestens solange bräuchte, bis unsere Sonne erlischt. Was sind Algorithmen? Wir können Algorithmen zweckmässig und informell definieren als systematische Zerlegungen eines vermeintlich schwierigen Problems in einfache Schritte. Diese Definition scheint zunächst banal, da jede Lösung eines Problems wohl beinhaltet, es in machbare Schritte zu zerlegen. Tatsächlich weist diese scheinbare Banalität bereits auf die grundlegende Bedeutung des Algorithmenbegriffs hin. Unsere informelle Definition beinhaltet, dass die Zerlegung systematisch sein soll. Wir meinen damit, dass die Zerlegung verallgemeinerbar ist und nicht spezialisiert ist auf eine bestimmte Instanz des Problems. Um diese Verallgemeinerbarkeit zu gewährleisten, verlangen wir für einen 1 Algorithmus ein eindeutige, vollständige und allgemeingültige Beschreibung der Abfolge von Schritten zur Lösung des Problems. Ein gutes Beispiel ist die aus der Schule bekannte schriftliche Multiplikation. Dieser Algorithmus erlaubt uns, zwei beliebige Zahlen miteinander zu multiplizieren, indem wir eine Reihe von Additionen und einstelligen Multiplikationen durchführen. In diesem Sinn zerlegen wir das Problem der mehrstelligen Multiplikation in einfache Schritte. Die Zerlegung ist verallgemeinerbar in dem Sinn, dass sie nicht für jedes Paar von Zahlen neu ermittelt werden muss, sondern dass wir die Zerlegung für ein beliebiges Paar von Zahlen beschreiben können. In der Informatik spielen Algorithmen eine zentrale Rolle: Computer können beliebige Algo- rithmen auf Daten unvorstellbar schnell ausführen mit Milliarden von Schritten pro Sekunde. (Wir bezeichnen die möglichen Schritte eines Computers als elementare Operationen.) In diesem Sinn werden alle Fähigkeiten von Computern erst durch Algorithmen ermöglicht. Aus diesem Grund wird die Informatik oft als Wissenschaft der Algorithmen definiert. In der Vorlesung werden wir verschiedene Algorithmen entwerfen und ihre Eigenschaften analysieren. Allerdings ist das eigentliche Ziel der Vorlesung nicht die Funktionsweise oder die Eigenschaften dieser konkreten Algorithmen zu erlernen. Vielmehr ist das Ziel Ihnen eine algorithmische Denkweise zu vermitteln. Ein wichtiger Teil dieser Denkweise ist die Art von Fragen, die wir zu Algorithmen untersuchen: • Welche verschiedenen Algorithmen gibt es für dasselbe Problem? • Wie können wir diese Algorithmen miteinander vergleichen? Können wir Algorithmen ein Qualitätsmass zuordnen und quantitativ bemessen, wie viel besser ein Algorithmus ist als ein anderer? • Können wir den bestmöglichen Algorithmus für ein Problem bestimmen bezüglich dieses Qualitätsmasses? 2 Schriftliche Multiplikation Die schriftliche Multiplikation erlaubt uns, zwei beliebige Zahlen zu multiplizieren. Da dieser Algorithmus schon aus der Schule bekannt ist, nennen wir ihn oft Schulalgorithmus. Schriftliche Multiplikation 2-stelliger Zahlen. Am Beispiel der Zahlen 𝑎 = 87 und 𝑏 = 43 lässt sich der Algorithmus wie folgt darstellen: 𝑎1 𝑎0 · 𝑏1 𝑏0 8 7 · 4 3 2 1 𝑎0 · 𝑏0 2 4 𝑎1 · 𝑏0 2 8 𝑎0 · 𝑏1 3 2 𝑎1 · 𝑏1 3 7 4 1 2 Zunächst wird die Einerziffer der ersten Zahl 𝑎0 = 7 mit der Einerziffer der zweiten Zahl 𝑏0 = 3 multipliziert. Wir notieren das Ergebnis 𝑎0 · 𝑏0 = 21. Anschliessend wird die Zehnerziffer der ersten Zahl 𝑎1 = 8) mit der Einerziffer der zweiten Zahl 𝑏0 = 3 multipliziert. Wir schreiben das Ergebnis 𝑎1 · 𝑏0 = 24 um eine Stelle nach links versetzt unter das vorherige Ergebnis. Im nächsten Schritt wird die Einerziffer der ersten Zahl 𝑎0 = 7 mit der Zehnerziffer der zweiten Zahl 𝑏1 = 4 multipliziert. Wir schreiben das Ergebnis 𝑎0 · 𝑏1 = 28 um eine Stelle nach links versetzt unter das vorherige Ergebnis. Schliesslich wird die Zehnerziffer der ersten Zahl 𝑎1 = 8 mit der Zehnerziffer der zweiten Zahl 𝑏1 = 4 multipliziert. Wir schreiben das Ergebnis 𝑎1 · 𝑏1 = 32 um zwei Stellen nach links versetzt unter das vorherige Ergebnis. Zum Schluss addieren wir die vier berechneten Zahlen und erhalten das Ergebnis 3741. Für den konkreten Fall 𝑎 = 87 und 𝑏 = 43 könnten wir uns mithilfe eines Taschenrechners versichern, dass dieses Ergebnis korrekt ist. Für den allgemeinen Fall können wir uns von der Korrektheit wie folgt überzeugen: Für die Stellen der Zahlen 𝑎 und 𝑏 im Dezimalsystem gilt 𝑎 = 10𝑎1 + 𝑎0 und 𝑏 = 10𝑏1 +𝑏0, wobei 𝑎0, 𝑏0 die Einerziffern und 𝑎1, 𝑏1 die Zehnerziffern von 𝑎 und 𝑏 sind. Laut seiner Beschreibung berechnet der Algorithmus die Zahl 𝑎0 ·𝑏0 +10· 𝑎1 ·𝑏0 +10· 𝑎0 ·𝑏1 +100· 𝑎1 ·𝑏1. Unter Verwendung des Distributivgesetzes der Addition und Multiplikation zeigt die folgende Rechnung, dass dieses Ergebnis immer mit dem Lösungswert 𝑎 · 𝑏 übereinstimmt, 𝑎 · 𝑏 = (10 · 𝑎1 + 𝑎0) · (10 · 𝑏1 + 𝑏0) = 𝑎0 · 𝑏0 + 10 · 𝑎1 · 𝑏0 + 10 · 𝑎0 · 𝑏1 + 100 · 𝑎1 · 𝑏1 . Schriftliche Multiplikation 𝑛-stelliger Zahlen. Seien 𝑎 und 𝑏 zwei beliebige 𝑛-stellige Zahlen mit 𝑎 = 10𝑛−1 · 𝑎𝑛−1 + 10𝑛−2 · 𝑎𝑛−2 + · · · + 10 · 𝑎1 + 𝑎0, 𝑏 = 10𝑛−1 · 𝑏𝑛−1 + 10𝑛−2 · 𝑏𝑛−2 + · · · + 10 · 𝑏1 + 𝑏0, wobei 𝑎𝑛−1, . . . , 𝑎0 ∈ {0, . . . , 9} und 𝑏𝑛−1, . . . , 𝑏0 ∈ {0, . . . , 9} die Stellen von 𝑎 und 𝑏 im Dezimalsys- tem sind. Der Algorithmus berechnet alle Teilprodukte 𝑎𝑖 · 𝑏 𝑗 für 𝑖, 𝑗 ∈ {0, 1, . . . , 𝑛 −1}. Es gibt insgesamt 𝑛2 solcher Teilprodukte. Anschliessend werden die Teilprodukte addiert, wobei sie ihrem Stellenwert entsprechend verschoben werden. Geht es besser? Es stellt sich die Frage, ob ein besserer Algorithmus für die Multiplikation existiert, der mit wesentlich weniger einstelligen Multiplikationen auskommt. Der berühmte russische Mathematiker Kolmogorov hatte vermutet, dass die Anzahl der einstelligen Multiplikationen im Schulalgorithmus, bis auf konstante Faktoren, bestmöglich ist. Diese Vermutung wurde jedoch im Jahr 1960 von Anatoli Karatsuba, einem seiner Studenten, widerlegt. 3 Karatsubas Algorithmus Im vorherigen Abschnitt haben wir gesehen, dass der Schulalgorithmus 𝑛2 einstellige Multiplika- tionen benötigt, um zwei 𝑛-stellige Zahlen zu multiplizieren. In diesem Abschnitt untersuchen wir, ob wir solche Zahlen mit wesentlich weniger einstelligen Multiplikationen berechnen können. 3 Karatsubas Algorithmus für 2-stellige Zahlen. Wir betrachten zunächst wieder das Beispiel der Zahlen 𝑎 = 87 und 𝑏 = 43. Der Schulalgorithmus benötigt für diesen Fall 4 einstellige Multiplikationen. Karatsuba entdeckte einen Algorithmus, der dieses Problem mit nur 3 einstelligen Multiplikationen löst. 𝑎1 𝑎0 · 𝑏1 𝑏0 8 7 · 4 3 2 1 𝑎0 · 𝑏0 3 2 𝑎1 · 𝑏1 −1 −(𝑎1 − 𝑎0) · (𝑏1 − 𝑏0) 5 3 𝑎0 · 𝑏0 + 𝑎1 · 𝑏1 3 7 4 1 Zunächst berechnen wir die Produkte 𝑎0 · 𝑏0 und 𝑎1 · 𝑏1, wie im Schulalgorithmus. Danach berechnen wir noch ein zusätzliches Produkt (𝑎1 − 𝑎0) · (𝑏1 − 𝑏0). Im Beispiel ist 𝑎1 − 𝑎0 = 1 und 𝑏1 − 𝑏0 = 1, also ist das Produkt (𝑎1 − 𝑎0) · (𝑏1 − 𝑏0) = 1. Wir notieren dieses Ergebnis mit negativem Vorzeichen versehen und um eine Stelle nach links versetzt. Anschliessen verwenden wir die zuvor berechneten Produkte 𝑎0 · 𝑏0 und 𝑎1 · 𝑏1 wieder und notieren ihre Summe um eine Stelle nach links versetzt. Anschliessend addieren wir die alle Zahlen und erhalten das gewünschte Ergebnis 3741. Korrektheit für 2-stellige Zahlen. Für die Zahlen 𝑎 = 10𝑎1 + 𝑎0 und 𝑏 = 10𝑏1 + 𝑏0 berechnet Karatsubas Algorithmus als Ergebnis 𝑎0 · 𝑏0 + 10 · (𝑎0 · 𝑏0 + 𝑎1 · 𝑏1 − (𝑎1 − 𝑎0) · (𝑏1 − 𝑏0)) + 100 · 𝑎1 · 𝑏1. Für den mittleren Term mit Koeffizienten 10 gilt 𝑎0 · 𝑏0 + 𝑎1 · 𝑏1 − (𝑎1 − 𝑎0) · (𝑏1 − 𝑏0) = 𝑎1 · 𝑏0 + 𝑎0 · 𝑏1 . Also berechnet Karatsubas Algorithmus dasselbe Ergebnis wie der Schulalgorithmus. Somit ist Karatsubas Algorithmus für zweistellige Zahlen korrekt. Wir sehen, dass Karatsubas Algorithmus für zweistellige Zahlen nur 3 Teilprodukte (anstatt 4 Teilprodukte wie beim Schulalgorithmus). Allerdings ist zunächst unklar, inwiefern Karatsubas Algorithmus wirklich besser ist als die Schulmethode. (Unter anderem führt Karatsubas einige zusätzliche Subtraktionen aus, die so im Schulalgorithmus nicht vorkommen.) Karatsubas Algorithmus für 4-stellige Zahlen. Wir wollen nun Karatsubas Idee verallgemeinern auf die Multiplikation von zwei 4-stelligen Zahlen. Als Beispiel wählen wir die Zahlen 𝑎 = 8765 und 𝑏 = 4321. Wir spalten die vierstellige Zahlen 𝑎 und 𝑏 auf in jeweils zwei zweistellige Zahlen, so dass 𝑎 = 102𝑎1 + 𝑎0 und 𝑏 = 102𝑏1 + 𝑏0, wobei 𝑎1 = 87, 𝑎0 = 65, 𝑏1 = 43, und 𝑏0 = 21. Wir verwenden nun dieselbe Idee wie zuvor um eine 4-stellige Multiplikation auf drei 2-stellige Multiplikationen zurückzuführen. 4 𝑎1 𝑎0 · 𝑏1 𝑏0 87 65 · 43 21 13 65 𝑎0 · 𝑏0 37 41 𝑎1 · 𝑏1 46 22 𝑎0 · 𝑏0 + 𝑎1 · 𝑏1 − (𝑎1 − 𝑎0) · (𝑏1 − 𝑏0) 37 87 35 65 Wir können die drei 2-stelligen Multiplikationen berechnen mit jeweils drei 1-stelligen Multip- likationen, indem wir Karatsubas Algorithmus für 2-stellige Zahlen verwenden. Insgesamt führt Karatsubas Algorithmus für 4-stellige Zahlen also 3 · 3 = 9 einstellige Multiplikationen aus. Der Schulalgorithmus braucht für diesen Fall 42 = 16 einstellige Multiplikationen. Veranschaulichung. Mithilfe eines Baumdiagramms können wir den Ablauf von Karatsubas Algorithmus veranschaulichen. Der Knoten ganz oben im Diagramm entspricht der ursprünglichen Multiplikation. Die Kinder eines Knotens entsprechen den Multiplikationen, in die die Multiplika- tion des Elternknotens zerlegt wird. 𝑎 · 𝑏 𝑎0 · 𝑏0 𝑎1 · 𝑏1 (𝑎1 − 𝑎0) · (𝑏1 − 𝑏0) Die Knoten in der zweiten Ebene des Diagramms entsprechen 2-stelligen Multiplikationen. Die Knoten in der dritten Ebene entsprechen 1-stelligen Multiplikationen. Karatsubas Algorithmus für 𝑛-stellige Zahlen. Sei 𝑘 eine natürliche Zahl und 𝑛 = 2𝑘. Seien 𝑎 und 𝑏 zwei beliebige 𝑛-stellige Zahlen. Wir schreiben die Zahlen 𝑎 und 𝑏 in der Form 𝑎 = 10𝑛/2𝑎1 + 𝑎0 und 𝑏 = 10𝑛/2𝑏1 + 𝑏0, wobei 𝑎1 und 𝑏1 die 𝑛/2 höchstwertigsten Stellen von 𝑎 und 𝑏 sind und 𝑎0 und 𝑏0 die 𝑛/2 niedrigstwertigsten Stellen von 𝑎 und 𝑏 sind. Mit derselben Idee wie zuvor können wir eine 2𝑘-stellige Multiplikationen zurückführen auf drei 2𝑘−1-stellige Multiplikationen. Diese 2𝑘−1-stellige Multiplikationen führen wir zurück auf jeweils drei 2𝑘−2-stellige Multiplikationen. Wir fahren fort bis wir alles auf 1-stellige Multiplikationen zurückgeführt haben. Wie zuvor können wir den Ablauf des Algorithmus mithilfe eines Baumdiagramms veran- schaulichen. 5 𝑎 · 𝑏 𝑎0 · 𝑏0 . . . . . . . . . 𝑎1 · 𝑏1 . . . . . . . . . (𝑎1 − 𝑎0) · (𝑏1 − 𝑏0) . . . . . . . . . Der Baum hat 𝑘 + 1 Ebenen. In der 𝑖-ten Ebene befinden sich 3𝑖−1 Knoten, die jeweils der Multiplikation zweier 2𝑘−𝑖+1-stelliger Zahlen entsprechen. In der vorletzten Ebene (𝑖 = 𝑘) befinden sich 3𝑘−1 Knoten, die jeweils einer 2-stelligen Multiplikation entsprechen. Jeder dieser Knoten führt zu drei einstelligen Multiplikationen. Insgesamt führt der Algorithmus also 3𝑘 einstellige Multiplikationen aus. Dabei ist zu beachten, dass die Subtraktionen, die der Algorithmus ausführt, nicht zu zusätzlichen einstelligen Multiplikation führen. Analyse. Für zwei 𝑛 = 2𝑘-stellige Zahlen benötigt Karatsubas Algorithmus 3𝑘 einstellige Multip- likationen. Die Schulmethode hingegen verwendet 𝑛2 = (2𝑘)2 = 4𝑘 einstellige Multiplikationen. Für grosse Werte 𝑘 ist 3𝑘 wesentlich kleiner als 4𝑘. Für 𝑘 = 9 gilt (4/3)𝑘 ≈ 13.32 und damit ist Karatsubas Algorithmus mehr als zehnmal günstiger als der Schulalgorithmus im Bezug auf die Anzahl einstelliger Multiplikationen. Für 𝑘 = 18 gilt (4/3)𝑘 ≈ (13.32)2 > 177 und damit ist Karatsubas Algorithmus mehr als 177-mal günstiger. Geht es noch besser? Tatsächlich ist es möglich, zwei 𝑛-stellige Zahlen mit noch weniger als 3𝑘 einstelligen Multiplikationen zu multiplizieren, falls 𝑛 = 2𝑘. Es gibt einen Algorithmus, der höchstens 𝐶 · 2𝑘 · 𝑘 einstellige Multiplikationen benötigt, für eine sehr grosse Konstante 𝐶. Dieser Algorithmus wurde erst im Jahr 2019 entdeckt. Leider ist der Algorithmus sehr kompliziert. Deshalb werden wir diesen Algorithmus in der Vorlesung nicht weiter besprechen. Zudem stellt sich der Vorteil gegenüber Karatsubas Algorithmus erst für astronomisch grosse Zahlen ein. Im Gegensatz zu Karatsubas Algorithmus hat dieser Algorithmus (noch) keine praktische Relevanz. Fazit. In dieser Vorlesung geht es nicht darum, besser multiplizieren zu lernen, sondern darum, eine algorithmische Denkweise zu entwickeln. Ein wichtiger Teil dieser Denkweise ist die Bereitschaft, naheliegende Lösungsverfahren zu hinterfragen und zu untersuchen, ob es bessere Lösungsver- fahren gibt. Oftmals lassen sich dramatische Verbesserungen erzielen. Karatsubas Algorithmus ist ein gutes Beispiel dafür. Die Grundidee von Karatsubas Algorithmus ist ein Problem (wie 𝑛-stellige Multiplikation) auf ein leichteres Teilproblem derselben Art zurückzuführen. Diese Strategie ist erstaunlich vielseitig anwendbar und heisst Rekursion. Falls die Teilprobleme entstehen, indem wir die ursprüngliche Eingabe in mehrere ungefähr gleichgrosse Teile aufspalten, sprechen wir oft von “divide-and- conquer”. 6 4 Pasture-break Problem In diesem Abschnitt diskutieren wir das Pasture-break Problem. Dieses Problem ist etwas ungewöhn- lich, da es nicht direkt darum geht, Eingabedaten zu verarbeiten. Dennoch ist es ein interessantes Problem und illustriert einige wichtige Konzepte der Entwicklung und Analyse von Algorithmen. Problemstellung. Wir stellen uns vor, dass eine kurzsichtige Kuh auf einer unendlich grossen Weide steht. Die Weide ist begrenzt durch einen Zaun. Es gibt genau eine Lücke im Zaun. Die Kuh möchte die Weide verlassen (wohl weil das Gras auf der anderen Seite des Zauns grüner ist). Allerdings weiss sie nicht, wo sich die Lücke befindet. Zaun Kuh k Schritte Wir nehmen an, dass die Kuh sich nur in Schritten parallel zum Zaun bewegen kann. In einem Schritt kann sie nur feststellen, ob sich an ihrer Position die Lücke befindet. Unser Ziel ist es, die Kuh so zu steuern, dass sie mit möglichst wenigen Schritten die Lücke findet und die Weide verlassen kann. Distanz bekannt. Nehmen wir zunächst an, dass die Kuh die Distanz 𝑘 zur Lücke kennt. In diesem Fall kann sie die Lücke finden, indem sie 𝑘 Schritte nach links läuft und anschliessend 2𝑘 Schritte nach rechts. Dieser Algorithmus findet die Lücke in jedem Fall. Falls sich die Lücke links vom Startpunkt befindet, dann findet sie die Kuh schon nach 𝑘 Schritten. Falls sich die Lücke rechts vom Startpunkt befindet, dann findet sie die Kuh nach 3𝑘 Schritten. Der worst case des Algorithmus beträgt also 3𝑘 Schritte. Start Lücke Lücke! k k k Distanz unbekannt. In der Praxis ist es natürlich unrealistisch anzunehmen, dass die Kuh die Distanz zur Lücke kennt. Wir wollen deshalb einen Algorithmus finden, der auch ohne dieses Wissen auskommt. Eine naheliegende Idee ist es, die Distanz vom Startpunkt in jeder Iteration allmählich zu erhöhen, solange bis wir die Lücke finden. 7 Algorithmus 1. Zunächst betrachten wir den Algorithmus, der die Distanz zum Startpunkt bei jedem Richtungswechsel um jeweils 1 erhöht. Die Kuh läuft zuerst einen Schritt nach links, dann zurück zum Startpunkt. Anschliessend läuft die Kuh zwei Schritte nach rechts, dann zurück zum Startpunkt. Danach drei Schritte nach links, und so weiter. Wir analysieren nun den worst case dieses Algorithmus. In diesem Fall läuft die Kuh zunächst 𝑘 − 1 Schritte in die richtige Richtung (also in Richtung der Lücke). Einen Schritt vor der Lücke kehrt sie um und läuft 𝑘 − 1 Schritte zurück zum Startpunkt. Dann läuft die Kuh 𝑘 Schritte in die falsche Richtung (also entgegen der Richtung der Lücke). Die Kuh kehrt um und läuft 𝑘 Schritt zurück zum Startpunkt. Schliesslich macht sich die Kuh wieder in die richtige Richtung auf und findet die Lücke nach 𝑘 weiteren Schritten. Start Lücke 1 1 2 23 3 k-1 k-1k k k . . . Lücke! Insgesamt beträgt die Anzahl der Schritte in diesem Fall, 2 · 1 + 2 · 2 + 2 · 3 + · · · + 2 · (𝑘 − 1) + 2 · 𝑘 + 𝑘 Nach der Gaussschen Formel (möglicherweise aus der Schule bekannt) beträgt die Summe der ersten 𝑘 natürlichen Zahlen 𝑘 · (𝑘 + 1)/2. Also lässt sich die worst-case Schrittzahl wie folgt vereinfachen, 2 · 𝑘 · (𝑘 + 1) 2 + 𝑘 = 𝑘 · (𝑘 + 2) . Algorithmus 2. Im vorherigen Algorithmus haben wir die Distanz vom Startpunkt in jeder Iteration nur um 1 erhöht. Das heisst in jeder Iteration untersucht die Kuh nur 1-2 neue Positionen, wohingegen der Aufwand in jeder Iteration um einen Schritt wächst. In diesem Sinn ist der Aufwand pro Iteration nicht verhältnismässig zum Informationsgewinn pro Iteration. Es liegt damit nahe, den Algorithmus so abzuändern, dass pro Iteration die Anzahl der schon bekannten Positionen ungefähr gleich gross ist wie die Anzahl der neuen Positionen. Dieser Algorithmus verdoppelt also die Distanz in jeder Iteration. 8 Konkret läuft die Kuh zuerst einen Schritt nach links, dann zurück zum Startpunkt. Anschliessend läuft sie zwei Schritte nach rechts, dann zurück zum Startpunkt. Danach vier Schritte nach links, dann zurück zum Startpunkt. Und so weiter. Wir bestimmen wieder die Anzahl Schritte im worst case. Wähle eine natürliche Zahl 𝑖 so, dass 2𝑖−1 < 𝑘 ⩽ 2𝑖. (Diese Wahl von 𝑖 ist für jedes 𝑘 eindeutig!) Im worst case läuft die Kuh zunächst 2𝑖−1 Schritte in die richtige Richtung, dann kehrt sie um und läuft 2𝑖−1 Schritte zurück zum Startpunkt. Danach läuft sie 2𝑖 Schritte in die falsche Richtung und 2𝑖 Schritte zurück zum Startpunkt. Anschliessend macht sich die Kuh auf, um 2𝑖+1 Schritte in die richtige Richtung zu laufen, aber sie findet schon nach 𝑘 Schritte die Lücke. Start Lücke 1 1 2 24 4 2𝑖−1 2𝑖−12𝑖 2𝑖 k . . . Lücke! Insgesamt benötigt die Kuh im worst case also 2 · (2 0 + 2 1 + · · · + 2𝑖−1 + 2𝑖) + 𝑘 Schritte. Die Summe der ersten 𝑖 + 1 Zweierpotenzen ist gleich 2𝑖+1 − 1. (Siehe Abschnitt über vollständige Induktion.) Also lässt sich die worst-case Anzahl der Schritte folgendermassen beschränken, 2 · (2𝑖+1 − 1) + 𝑘 < 2 · 2𝑖+1 + 𝑘 ⩽ 8𝑘 + 𝑘 = 9𝑘 , wobei wir 2𝑖+1 = 4 · 2𝑖−1 < 4𝑘 verwenden. Vergleich. Für grosse Werte von 𝑘 ist die worst-case Schranke 9𝑘 von Algorithmus 2 wesentlich kleiner als der worst case 𝑘 · (𝑘 + 2) von Algorithmus 1. Zum Beispiel, für 𝑘 = 100 benötigt Algorithmus 1 mehr als 10000 Schritte im worst case, wohingegen Algorithmus 2 stets weniger als 900 Schritte benötigt. 9 Geht es besser? Es liegt nahe zu vermuten, dass wir den worst case verbessern könnten, indem wir die Distanzen vom Startpunkt noch schneller mit jeder Iteration wachsen lassen. Es stellt sich aber heraus, dass sich dadurch der worst case verschlechtert! Tatsächlich ist die worst-case Schranke 9𝑘 bestmöglich. Für jeden Algorithmus und für jedes 𝜀 > 0 gibt es ein 𝑘, so dass der Algorithmus im worst case mindestens (9 − 𝜀) · 𝑘 Schritte benötigt. (An dieser Stelle lassen wir diese Behauptung unbewiesen.) 5 Vollständige Induktion Um die Effizienz und Korrektheit eines Algorithmus zu ermitteln, könnten wir eine pragmatische Sichtweise einnehmen und den Algorithmus auf möglichst vielen interessanten Eingaben testen. Solche Tests sind wertvoll, erlauben uns aber keine Rückschlüsse darauf, wie sich der Algorithmus auf anderen Eingaben verhält. In vielen Bereichen des täglichen Lebens stehen Ursache und Wirkung miteinander im Verhältnis. Aber bei Algorithmen können schon kleine Veränderungen der Eingabe verheerende Folgen für die Ausgabe haben. Deshalb haben wir in dieser Vorlesung den Anspruch, unsere Algorithmen für alle Eingaben zu analysieren. Solche universellen Aussagen können wir nur mittels mathematischen Beweisen treffen. Obwohl es kein einfaches Rezept dafür gibt, mathematische Beweise zu finden, können Beweis- prinzipien die Suche nach Beweisen erheblich erleichtern. Ein besonders wichtiges und vielseitiges Beweisprinzip ist die vollständige Induktion. Beispiel eines Induktionsbeweises. Sei 𝑆𝑘 = 1 + 2 + 4 + · · · + 2𝑘−1 die Summe der ersten 𝑘 Zweierpotenzen. Für kleine Werte von 𝑘 können wir diese Summe leicht berechnen: 𝑆1 = 1 , 𝑆2 = 1 + 2 = 3 , 𝑆3 = 1 + 2 + 4 = 7 , 𝑆4 = 1 + 2 + 4 + 8 = 15 . Anhand dieser Werte sehen wir, dass für alle 𝑘 ⩽ 4 die Summe 𝑆𝑘 genau eins weniger ist als die nächste Zweierpotenz 2𝑘. Es liegt nahe zu vermuten, dass diese Eigenschaft verallgemeinert werden kann und dass 𝑆𝑘 = 2𝑘 − 1 für alle natürlichen Zahlen 𝑘 gilt. Um diese Aussage für alle natürlichen Zahlen 𝑘 zu beweisen, verwenden wir das Beweisprinzip der vollständigen Induktion. Dazu müssen wir zunächst den Induktionsanfang ausführen und zeigen, dass die Aussage für 𝑘 = 1 gilt. Tatsächlich sind die beiden Werte 𝑆1 = 1 und 21 − 1 = 1 gleich. Im Anschluss müssen wir den Induktionsschritt ausführen und für alle natürlichen Zahlen 𝑘 zeigen, dass 𝑆𝑘+1 = 2𝑘+1 − 1 gilt unter der Annahme, dass 𝑆𝑘 = 2𝑘 − 1 gilt. Tatsächlich können wir diesen Induktionsschritt hier ausführen, indem wir 𝑆𝑘+1 und 𝑆𝑘 wie folgt zueinander in Bezug setzen: 𝑆𝑘+1 = 𝑆𝑘 + 2𝑘 (per Definition) = 2𝑘 − 1 + 2𝑘 (Induktionshypothese) = 2𝑘+1 − 1 . (Rechenregel) 10 Wir konnten hier also sowohl den Induktionsanfang als auch den Induktionsschritt erfolgreich ausführen. Das Beweisprinzip der vollständigen Induktion besagt, dass wir dadurch die Identität 𝑆𝑘 = 2𝑘 − 1 für alle natürlichen Zahlen 𝑘 bewiesen haben. Allgemeine Form. Sei 𝐴(𝑘) eine Aussage über eine natürliche Zahl 𝑘, z.B. die Aussage, dass die Summe der ersten 𝑘 Zweierpotenzen 2𝑘 − 1 beträgt. Unser Ziel ist es, zu beweisen, dass diese Aussage für alle natürlichen Zahlen 𝑘 ∈ ℕ gilt. Ein Induktionsbeweis besteht aus zwei Teilen, dem Induktionsanfang und dem Induktionsschritt. • Für den Induktionsanfang müssen wir zeigen, dass die Aussage 𝐴(1) gilt. Dieser Teil eines Induktionsbeweises ist oft leichter als der Induktionsschritt. • Beim Induktionsschritt müssen wir für alle natürlichen Zahlen 𝑘 ∈ ℕ zeigen, dass aus der Aussage 𝐴(𝑘) die Aussage 𝐴(𝑘 + 1) folgt. Wir müssen also die Aussage 𝐴(𝑘 + 1) beweisen, dürfen dabei aber verwenden, dass die Aussage 𝐴(𝑘) gilt. Beim Induktionsschritt ist es wichtig, wirklich alle natürlichen Zahlen 𝑘 ∈ ℕ abzudecken. 11","libVersion":"0.3.2","langs":""}