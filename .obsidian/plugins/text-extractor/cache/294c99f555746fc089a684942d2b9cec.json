{"path":"sem4/FMFP/PV/exams/endterms/FMFP-FS21.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Part II Midterm Exam, SS21 May 19, 2021, 10:15 – 10:45 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Assignment 1 2 3 ∑ Max 5 5 5 15 Points Formal Methods and Functional Programming, Part II Midterm Exam, SS21 2 Semantics of Expressions (5 Points) Variant 1 Consider the following concrete syntax of expressions. Exp = Numeral | ’⊙[’ ExpList ’]’ ExpList = Exp | Exp ’,’ ExpList In this task we use the meta variables n, m for instances of Numeral; e, e1, e2, e3 for instances of Exp and el for instances of ExpList. N is the usual semantics of numerals. Consider the following deﬁnition of the functions C and D, which deﬁne two possible semantics of expressions. C[[n]] = N [[n]] C[[ ⊙ [e1] ]] = C[[e1]] C[[ ⊙ [e1, e2] ]] = C[[e1]] − C[[e2]] C[[ ⊙ [e1, el] ]] = C[[e1]] − C[[e2]] + C[[e3]] if el ≡ “e2, e3” D[[n]] = N [[n]] D[[ ⊙ [e] ]] = D[[e]] D[[ ⊙ [n, el] ]] = N [[n]] − D[[ ⊙ [el] ]] D[[ ⊙ [e, el] ]] = D[[ ⊙ [m, el] ]] if e is not a Numeral, where N [[m]] = D[[e]] For each of the following statements, choose whether they are true or false. 1. ⊙ [1, ⊙ [⊙ [2, 3] , 4]] is a valid instance of Exp. 2. The deﬁnition of C is total. 3. The deﬁnition of D is inductive. 4. The deﬁnition of D is total. 5. C[[ ⊙ [4, 3] ]] = D[[ ⊙ [2, 1] ]] Solution. The correct answers are 1. True, by deﬁnition of Exp. 2. False. C[[ ⊙ [e1, el] ]] is not deﬁned if el ≡ e2, el′ and el′ ≡ e3, e4 Formal Methods and Functional Programming, Part II Midterm Exam, SS21 3 3. False. D[[⊙[e, el] ]] is deﬁned as D[[⊙[m, el] ]] if e is not a Numeral, where N [[m]] = D[[e]]. However, ⊙ [m, el] ̸⊏ ⊙ [e, el]. Recall that e′′ ⊏ e denotes that e′′ is a proper sub- expression of e. 4. True. D is deﬁned for all Exp expressions. 5. True. C[[ ⊙ [4, 3] ]] = C[[4]] − C[[3]] = N [[4]] − N [[3]] = 4 − 3 = 1 D[[ ⊙ [2, 1] ]] = N [[2]] − D[[ ⊙ [1] ]] = 2 − D[[1]] = 2 − N [[1]] = 1 Formal Methods and Functional Programming, Part II Midterm Exam, SS21 4 Variant 2 Consider the following concrete syntax of expressions. Exp = Numeral | ’⊙[’ ExpList ’]’ ExpList = Exp | Exp ’,’ ExpList In this task we use the meta variables n, m for instances of Numeral; e, e1, e2, e3 for instances of Exp and el for instances of ExpList. N is the usual semantics of numerals. Consider the following deﬁnition of the semantics of expressions C and D. C[[n]] = N [[n]] C[[ ⊙ [e] ]] = 1 + C[[e]] C[[ ⊙ [n, el] ]] = N [[n]] ∗ C[[ ⊙ [el] ]] C[[ ⊙ [e, el] ]] = C[[ ⊙ [m, el] ]] if e is not a Numeral, where N [[m]] = C[[e]] D[[n]] = N [[n]] D[[ ⊙ [e1] ]] = D[[e1]] D[[ ⊙ [e1, e2] ]] = D[[e1]] ∗ D[[e2]] D[[ ⊙ [e1, el] ]] = D[[e1]] ∗ D[[e2]] ∗ D[[e3]] if el ≡ “e2, e3” For each of the following statements, choose whether they are true or false. 1. The deﬁnition of C is inductive. 2. The deﬁnition of C is total. 3. The deﬁnition of D is total. 4. C[[ ⊙ [4, 3] ]] = D[[ ⊙ [3, 4] ]] 5. ⊙ [⊙ [1, ⊙ [2, 3]] , 4] is a valid instance of Exp. Solution. The correct answers are 1. False. C[[ ⊙ [n, el] ]] is deﬁned as N [[n]] ∗ C[[ ⊙ [el] ]] but ⊙ [el] ̸⊏ ⊙ [n, el]. Recall that e ′′ ⊏ e denotes that e ′′ is a proper sub-expression of e. 2. True. C is deﬁned for all Exp expressions. 3. False. D[[ ⊙ [e1, el] ]] is not deﬁned if el ≡ e2, el′ and el′ ≡ e3, e4 4. False. C[[ ⊙ [4, 3] ]] = N [[4]] ∗ C[[ ⊙ [3] ]] = 4 ∗ (1 + C[[3]]) = 4 ∗ (1 + N [[3]]) = 4 ∗ (1 + 3) = 16 D[[ ⊙ [3, 4] ]] = D[[3]] ∗ D[[4]] = N [[3]] ∗ N [[4]] = 3 ∗ 4 = 12 5. True, by deﬁnition of Exp. Formal Methods and Functional Programming, Part II Midterm Exam, SS21 5 Natural Semantics of IMP (5 Points) Variant 1 Consider the following IMP statement s which implements the Euclidean algorithm for computing the greatest common divisor of a and b. while a # b do if a > b then a := a - b else b := b - a end end Construct the correct derivation tree T such that root(T ) ≡ ⟨s, σzero[a, b ↦→ 9, 6]⟩ → σend for some ﬁnal state σend. Then, for each of the following statements, choose whether they are true or false. Note: Recall from the lectures that σzero(x) = 0 for all x 1. T contains exactly 7 rule applications 2. There exists a subtree T ′ of T such that root(T ′) = ⟨b := b − a, σ′⟩ → σ′′, for some σ′ and σ′′ where σ′′(a) = 6 and σ′′(b) = 3 3. There exists a subtree T ′ of T such that root(T ′) ≡ ⟨s′′, σzero[a, b ↦→ 3, 6]⟩ → σzero[a, b ↦→ 3, 3], where s′′ corresponds to the statement if a > b then a := a - b else b := b - a Solution. The correct answers are 1. True, according to the tree T shown below. 2. False. No subtree T ′ of T satisﬁes root(T ′) = ⟨b := b − a, σ′⟩ → σ′′, for some σ′ and σ′′ where σ′′(a) = 6 and σ′′(b) = 3. 3. True. The tree T 1 (shown below) satisﬁes this property. Formal Methods and Functional Programming, Part II Midterm Exam, SS21 6 We use the following abbreviations: • s′′ is the statement if a > b then a := a - b else b := b - a end • we abbreviate a state σzero[a ↦→ va][b ↦→ vb] as [va, vb]. We also use the simplifying properties of state updates from Exercise Sheet 9 and the fact that a ̸≡ b. The derivation tree T is then given by: (AssNS) ⟨a := a−b, [9, 6]⟩ → [3, 6] (IfTNS) ⟨s′′, [9, 6]⟩ → [3, 6] A AA \u0001 \u0001\u0001 T1 ⟨s′′, [3, 6]⟩ → [3, 3] (WhFNS) ⟨s, [3, 3]⟩ → [3, 3] (WhTNS) ⟨s, [3, 6]⟩ → [3, 3] (WhTNS) ⟨s, [9, 6]⟩ → [3, 3] where T1 is the derivation tree: (AssNS) ⟨b := b−a, [3, 6]⟩ → [3, 3] (IfFNS) ⟨s′′, [3, 6]⟩ → [3, 3] Formal Methods and Functional Programming, Part II Midterm Exam, SS21 7 Variant 2 Consider the following IMP statement s which implements the Euclidean algorithm for computing the greatest common divisor of a and b. while a # b do if a > b then a := a - b else b := b - a end end Construct the correct derivation tree T such that root(T ) ≡ ⟨s, σzero[a, b ↦→ 6, 9]⟩ → σend for some ﬁnal state σend. Then, for each of the following statements, choose whether they are true or false. Note: Recall from the lectures that σzero(x) = 0 for all x 1. T contains exactly 8 rule applications 2. There exists a subtree T ′ of T such that root(T ′) = ⟨b := b − a, σ′⟩ → σ′′, for some σ′ and σ′′ where σ′′(a) = 6 and σ′′(b) = 3 3. There exists a subtree T ′ of T such that root(T ′) ≡ ⟨s′′, σzero[a, b ↦→ 3, 6]⟩ → σzero[a, b ↦→ 3, 3], where s′′ corresponds to the statement if a > b then a := a - b else b := b - a Solution. The correct answers are 1. False. The tree T (shown below) contains 7 rule applications. 2. True. The tree T1 (shown below) satisﬁes this property. 3. False. No subtree T ′ of T satisﬁes root(T ′) ≡ ⟨s′′, σzero[a, b ↦→ 3, 6]⟩ → σzero[a, b ↦→ 3, 3]. Formal Methods and Functional Programming, Part II Midterm Exam, SS21 8 We use the following abbreviations: • s′′ is the statement if a > b then a := a - b else b := b - a end • we abbreviate a state σzero[a ↦→ va][b ↦→ vb] as [va, vb]. We also use the simplifying properties of state updates from Exercise Sheet 9 and the fact that a ̸≡ b. The derivation tree T is then given by: A AA \u0001 \u0001\u0001 T1 ⟨b := b−a, [6, 9]⟩ → [6, 3] (IfFNS) ⟨s′′, [6, 9]⟩ → [6, 3] (AssNS) ⟨a := a−b, [6, 3]⟩ → [3, 3] (IfTNS) ⟨s′′, [6, 3]⟩ → [3, 3] (WhFNS) ⟨s, [3, 3]⟩ → [3, 3] (WhTNS) ⟨s, [6, 3]⟩ → [3, 3] (WhTNS) ⟨s, [6, 9]⟩ → [3, 3] where T1 is the derivation tree: (AssNS) ⟨b := b−a, [6, 9]⟩ → [6, 3] Formal Methods and Functional Programming, Part II Midterm Exam, SS21 9 Extension of the IMP language (5 Points) Variant 1 Consider the extension of the programming language IMP with the statement havoc x, where x is a variable. In the natural semantics, the semantics of this new statement is captured by the following rule: (HavNS) ⟨havoc x, σ⟩ → σ[x ↦→ v] Based on this rule, state whether the following statements are true or false: 1. For an arbitrary state σ, the execution of x := 0; while (x != 5) do havoc x end in σ terminates successfully. 2. havoc x; havoc x and havoc x are semantically equivalent. 3. ∀σ, σ′.⟨havoc x; havoc y, σ⟩ → σ′ =⇒ σ′(x) = σ′(y) 4. havoc x; x:= 6 and x := 6; havoc x are semantically equivalent. Solution. havoc x non-deterministically assigns a value to x. Hence, the correct answers are 1. True. According to p. 82 of the slides, the execution of a statement s in state σ terminates successfully iﬀ ∃σ′.⟨s, σ⟩ → σ′ . In this case, it is suﬃcient to instantiate the rule HavNS with the value 5 to make the loop terminate. 2. True. According to p. 84 of the slides, the statements havoc x; havoc x and havoc x are semantically equivalent iﬀ ∀σ, σ′.(⊢ ⟨havoc x; havoc x, σ⟩ → σ′ ⇐⇒ ⊢ ⟨havoc x, σ⟩ → σ′). 3. False. Diﬀerent applications of the rule HavNS may instantiate v with diﬀerent values. Thus, the values of x and y may diﬀer at the end of the execution of havoc x; havoc y. 4. False. For all states σ, ⊢ ⟨havoc x; x:= 6, σ⟩ → σ[x ↦→ 6]. However, given that HavNS may be instantiated with any value, there is a derivation tree T such that root(T ) ≡ ⟨x := 6; havoc x⟩ → σ[x ↦→ 7]. Thus, the two statements cannot be semantically equivalent. Formal Methods and Functional Programming, Part II Midterm Exam, SS21 10 Variant 2 Consider the extension of the programming language IMP with the statement havoc x, where x is a variable. In the natural semantics, the semantics of this new statement is captured by the following rule: (HavNS) ⟨havoc x, σ⟩ → σ[x ↦→ v] Based on this rule, state whether the following statements are true or false: 1. ∀σ.∃σ′.⟨havoc x; havoc y, σ⟩ → σ′ ∧ σ′(x) = σ′(y) 2. havoc x; x := x + 1 and x := x - 1; havoc x are semantically equivalent. 3. havoc x and skip are semantically equivalent. 4. For an arbitrary state σ, the execution of havoc x; while (x > 0) do x := x + 1 end in σ terminates successfully. Solution. havoc x non-deterministically assigns a value to x. Hence, the correct answers are 1. True. For an arbitrary state σ and arbitrary values v1 and v2, it is possible to build the following tree: (HavNS) ⟨havoc x, σ⟩ → σ[x ↦→ v1] (HavNS) ⟨havoc y, σ[x ↦→ v1]⟩ → σ[x ↦→ v1][y ↦→ v2] (SeqNS) ⟨havoc x; havoc y, σ⟩ → σ[x ↦→ v1][y ↦→ v2] By making v1 = 1 = v2, we prove that ∀σ.∃σ′.⟨havoc x; havoc y, σ⟩ → σ′ ∧ σ′(x) = 1 = σ′(y) 2. True. According to p. 84 of the slides, the statements havoc x; havoc x and havoc x are semantically equivalent iﬀ ∀σ, σ′.(⊢ ⟨havoc x; havoc x, σ⟩ → σ′ ⇐⇒ ⊢ ⟨havoc x, σ⟩ → σ′). 3. False. For all states σ, ⊢ ⟨skip, σ⟩ → σ. However, given that HavNS may be instantiated with an arbitrary value, there is a derivation tree T such that root(T ) ≡ ⟨havoc x⟩ → σ[x ↦→ σ(x) + 1]. Thus, the two statements cannot be semantically equivalent. 4. True. According to p. 82 of the slides, the execution of a statement s in state σ terminates successfully iﬀ ∃σ′.⟨s, σ⟩ → σ′. In this case, it is suﬃcient to instantiate the HavNS rule with a non-positive value to show the existence of such a σ′. Formal Methods and Functional Programming, Part II Midterm Exam, SS21 11 Syntax and Semantics of IMP Syntax The statements s (Stm) and arithmetic expressions e (Aexp) of the programming language IMP are given by the grammar s ::= skip ∣ ∣ x := e ∣ ∣ s;s ∣ ∣ if b then s else s end ∣ ∣ while b do s end e ::= n ∣ ∣ x ∣ ∣ e op e where n ranges over numerals (Numeral), x ranges over variables (Var), b ranges over boolean expressions (Bexp), and op ranges over arithmetic operators (Op). Free Variables and Substitution FV(e) =    ∅ if e ≡ n for some numeral n {x} if e ≡ x for some variable x FV(e1) ∪ FV(e2) if e ≡ e1 op e2 for some e1, e2, and op e[x ↦→ e′] ≡    n if e ≡ n for some numeral n e ′ if e ≡ y for some variable y with y ≡ x y if e ≡ y for some variable y with y ̸≡ x e1[x ↦→ e ′] op e2[x ↦→ e′] if e ≡ e1 op e2 for some e1, e2, and op Natural Semantics (Big-Step Semantics) (SkipNS) ⟨skip, σ⟩ → σ (AssNS) ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ → σ′ ⟨s2, σ′⟩ → σ′′ (SeqNS) ⟨s1;s2, σ⟩ → σ′′ ⟨s1, σ⟩ → σ′ (IfTNS) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = tt ⟨s2, σ⟩ → σ′ (IfFNS) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = ﬀ ⟨s, σ⟩ → σ′ ⟨while b do s end, σ′⟩ → σ′′ (WhTNS) ⟨while b do s end, σ⟩ → σ′′ if B[[b]]σ = tt (WhFNS) ⟨while b do s end, σ⟩ → σ if B[[b]]σ = ﬀ","libVersion":"0.5.0","langs":""}