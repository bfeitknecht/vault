{"path":"var/export/A&D-bf-u05.pdf","text":"Antonia Tomova, 23-957-590, Basil Feitknecht, 23-922-099 5.1 (a) The max-heap obtained after inserting the elements 70 and 51 in that order is given below. 82 63 61 43 54 19 48 24 27 10 70 51 (b) The max-heap obtained after two e\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000x() operations is given below. 27 23 25 11 12 14 17 9 5 8 19 6 3 1 5.3 (a) We show that the number of comparisons T (n) satisﬁes the given recurrence relation. To do this, we apply a case distinction on n. Case n = 1 The condition i\u0000 l < r evaluates to false so the algorithm makes no comparisons, thus T (1) = 0. □ Case n ≥ 2 We use the assumption that p\u0000\u0000tit\u0000\u0000n(A, l, r) always performs exactly r − l comparisons. Since, the if condition evaluates to true, we call the p\u0000\u0000tit\u0000\u0000n method with the arguments l = 1, r = n. Thus, we perform n − 1 comparisons. Then we note that the two recursive function calls on line 4, q\u0000i\u0000ks\u0000\u0000t(A, l, k-1) and line 5, q\u0000i\u0000ks\u0000\u0000t(A, k+1, r) together cover the range [1, n − 1], thus they must perform exactly T (n − 1) comparisons, by deﬁnition of T . So the ﬁnal formula for the number of comparisons is exactly the recurrence relation, T (n) = T (n − 1) + (n − 1), ∀n ≥ 2. □ T (1) = 0, T (n) = T (n − 1) + (n − 1), ∀n ≥ 2 (b) We note, that for n ≥ 3, we can rewrite the recurrence relation as T (n) = (T (n − 2) + (n − 2)) + (n − 1). Similarly, for n ≥ 4, the formula becomes T (n) = ((T (n − 3) + (n − 3)) + (n − 2)) + (n − 1). We make the observation, that this pattern will continue, i.e. the number of comparisons taken follows the sum from 0 to n − 1. This yields the closed form for T (n) stated below. We will now evaluate the limit between T (n) and the function f(n) = n2. Since the limit of the ratio between T (n) and f(n) is a constant, T (n) = Θ(n2). □ T (n) = n−1 ∑ i=0 i = n(n − 1) 2 = n2 − n 2 lim n→∞ T (n) f(n) = lim n→∞ n2−n 2 n2 = lim n→∞ n2 − n 2n2 = lim n→∞ (1 − 1 n ) 2 = lim n→∞ 1 2 = 1 2 ∈ R n2 n2 − 1 n 5.4 (a) Prove that executing Heapify(T ) returns a valid heap. induction on invariant, base case n = 2 nodes and level l = 2,","libVersion":"0.3.2","langs":""}