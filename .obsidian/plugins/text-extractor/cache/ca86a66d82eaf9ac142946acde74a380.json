{"path":"var/export/A&D-bf-u05.pdf","text":"Antonia Tomova, 23-957-590, Basil Feitknecht, 23-922-099 5.1 (a) The max-heap obtained after inserting the elements 70 and 51 in that order is given below. 82 63 61 43 54 19 48 24 27 10 70 51 (b) The max-heap obtained after two e\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000x() operations is given below. 27 23 25 11 12 14 17 9 5 8 19 6 3 1 5.3 (a) We show that the number of comparisons T (n) satisﬁes the given recurrence relation. To do this, we apply a case distinction on n. C ase n = 1 The condition i\u0000 l < r evaluates to false so the algorithm makes no comparisons, thus T (1) = 0. □ C ase n ≥ 2 We use the assumption that p\u0000\u0000tit\u0000\u0000n(A, l, r) always performs exactly r − l comparisons. Since, the if condition evaluates to true, we call the p\u0000\u0000tit\u0000\u0000n method with the arguments l = 1, r = n. Thus, we perform n − 1 comparisons. Then we note that the two recursive function calls on line 4, q\u0000i\u0000ks\u0000\u0000t(A, l, k-1) and line 5, q\u0000i\u0000ks\u0000\u0000t(A, k+1, r) together cover the range [1, n − 1], thus they must perform exactly T (n − 1) comparisons, by deﬁnition of T . So the ﬁnal formula for the number of comparisons is exactly the recurrence relation, T (n) = T (n − 1) + (n − 1), ∀n ≥ 2. □ T (1) = 0, T (n) = T (n − 1) + (n − 1), ∀n ≥ 2 (b) We note, that for n ≥ 3, we can rewrite the recurrence relation as T (n) = (T (n − 2) + (n − 2)) + (n − 1). Similarly, for n ≥ 4, the formula becomes T (n) = ((T (n − 3) + (n − 3)) + (n − 2)) + (n − 1). We make the observation, that this pattern will continue, i.e. the number of comparisons taken follows the sum from 0 to n − 1. This yields the closed form for T (n) stated below. We will now evaluate the limit between T (n) and the function f(n) = n2. Since the limit of the ratio between T (n) and f(n) is a constant, T (n) = Θ(n2). □ T (n) = n−1 ∑ i= 0 i = n(n − 1) 2 = n2 − n 2 lim n→∞ T (n) f(n) = lim n→∞ n2−n 2 n2 = lim n→∞ n2 − n 2n2 = lim n→∞ (1 − 1 n ) 2 = lim n→∞ 1 2 = 1 2 ∈ R n2 n2 − 1 n 5.4 (a) Prove that executing heapify(T ) returns a valid heap. We prove the correctness of heapify(T ) for some binary tree T with n ≥ 2 nodes by process of mathematical induction. To do this, we use the given invariant I(t) on the levels of T , i.e. we show that I(0) holds after executing the algorithm. Base C ase h = height(T ) This trivially holds, as the nodes at level height(T ) are all leaves and thus fulﬁll the heap condition, since they have no children. Thus the invariant I(height(T )) is proven. Induction H ypothesis h = t + 1 We assume that the invariant I(t + 1) holds for some t ≤ height(T ) − 1, i.e. all nodes in levels from t + 1 down to height(T ) fulﬁll the heap condition. Induction Step h = t Now we consider an iteration of the algorithm at an arbitrary level t ≤ height(T ) − 1. For each node N at this level t, we check its two children C1, C2 in level t + 1, if they exist. From our induction hypothesis we know that all subtrees rooted at this level fulﬁll the heap condition. Then we make the following case distinction. Case key(N) ≥ key(C1), key(C2) In this case the children of N fulﬁll the heap condition and we can move on. Case key(N) < key(C) Without loss of generality, let C denote a child node of N such that the above holds. In this case, the algorithm swaps the nodes N and C during the execution of the appropriate if statement. After this, we restore the heap condition in the subtrees rooted at C1, C2, repeating the procedure described above, pushing the node N down to a level such that its parent's node P key is greater than its own key(P ) ≥ key(N). Then it follows that I(0) and thus we've shown the correctness of the algorithm heapify(T ), returning a valid heap H. □","libVersion":"0.5.0","langs":""}