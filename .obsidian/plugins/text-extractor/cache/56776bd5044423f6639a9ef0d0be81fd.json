{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s01b-natural deduction.pdf","text":"Natural Deduction David Basin Department of Computer Science ETH Z¨urich Functional Programming David Basin 1 Formal reasoning about systems • Requirements 1. Language 2. Semantics 3. Deductive system for carrying out proofs • Metatheorems relate these, e.g., soundness and completeness \u0011 We focus on (1) and (3) and only comment briefly on (2) \u0011 Most of this should be a review (logic/discrete math) • Proofs are essential for both parts of the course Some formality now allows (slightly) less formality later Functional Programming Spring Semester, 2025 David Basin 2 Road map ☞ Natural deduction • Propositional logic • First-order logic • Equality Functional Programming Spring Semester, 2025 David Basin 3 An abstract example of a formal proof • Language L = {⊕, ⊗, ×, +}. • Deductive proof system: • Rules: α: If +, then ⊗. β: If +, then ×. γ: If ⊗ and ×, then ⊕. δ: + holds. + α ⊗ + β × ⊗ × γ ⊕ δ + • Prove ⊕ 1. + holds by δ. 2. ⊗ holds by α with 1. 3. × holds by β with 1. 4. ⊕ holds by γ with 2 and 3. • Derivation tree (Prawitz style): δ + α ⊗ δ + β × γ ⊕ Functional Programming Spring Semester, 2025 David Basin 4 Another abstract example of a formal proof • Language L = {⊕, ⊗, ×, +}. • Deductive proof system: • Rules: α: If +, then ⊗. β: If +, then ×. γ: If ⊗ and ×, then ⊕. δ: We may assume + when proving ⊕. axiom . . . , A, . . . ⊢ A Γ ⊢ + α Γ ⊢ ⊗ Γ ⊢ + β Γ ⊢ × Γ ⊢ ⊗ Γ ⊢ × γ Γ ⊢ ⊕ Γ, + ⊢ ⊕ δ Γ ⊢ ⊕ • Prove ⊕ 1. Assume + holds by δ. 2. ⊗ holds by α with 1. 3. × holds by β with 1. 4. ⊕ holds by γ with 2 and 3. • Derivation tree (Gentzen-style): axiom + ⊢ + α + ⊢ ⊗ axiom + ⊢ + β + ⊢ × γ + ⊢ ⊕ δ ⊢ ⊕Functional Programming Spring Semester, 2025 David Basin 5 Natural deduction • Developed by Gentzen (1930s) and Prawitz (1960s) • Rules are used to construct derivations under assumptions. A1, ..., An ⊢ A reads as “A follows from A1, ..., An” • Derivations are trees axiom A, B ⊢ A axiom A, B ⊢ B ∧-I A, B ⊢ A ∧ B →-I A ⊢ B → A ∧ B →-I ⊢ A → B → A ∧ B • A proof is a derivation whose root has no assumptions Functional Programming Spring Semester, 2025 David Basin 6 Road map • Natural deduction ☞ Propositional logic • First-order logic • Equality Functional Programming Spring Semester, 2025 David Basin 7 Propositional logic: syntax • Propositions are built from a collection of variables and closed under disjunction, conjunction, implication, . . . • More formally: Let a set V of variables be given. LP , the language of propositional logic, is the smallest set where: \u0011 X ∈ LP if X ∈ V. \u0011 ⊥ ∈ LP . \u0011 A ∧ B ∈ LP if A ∈ LP and B ∈ LP . \u0011 A ∨ B ∈ LP if A ∈ LP and B ∈ LP . \u0011 A → B ∈ LP if A ∈ LP and B ∈ LP . • In the following: X ranges over variables, A and B over formulae Functional Programming Spring Semester, 2025 David Basin 8 Propositional logic: semantics • A valuation σ : V → {True, False} is a function mapping variables to truth values (truth assignment). \u0011 Valuations are simple kinds of models (interpretations). \u0011 Let Valuations be the set of valuations. • Satisfiability: smallest relation |= ⊆ Valuations × LP such that \u0011 σ |= X if σ(X) = True \u0011 σ |= A ∧ B if σ |= A and σ |= B \u0011 σ |= A ∨ B if σ |= A or σ |= B \u0011 σ |= A → B if whenever σ |= A then σ |= B • Note that σ ̸|= ⊥, for every σ ∈ Valuations Functional Programming Spring Semester, 2025 David Basin 9 Propositional logic: semantics (cont.) • A formula A ∈ LP is satisfiable if σ |= A, for some valuation σ • A formula A ∈ LP is valid (a tautology) if σ |= A, for all valuations σ • Semantic entailment: A1, . . . , An |= A if for all σ, if σ |= A1, . . . , σ |= An then σ |= A • Examples: \u0011 X ∧ Y satisfiable as σ |= X ∧ Y for σ(X) = σ(Y ) = True \u0011 X → X valid \u0011 ¬X, X ∨ Y |= Y holds as σ |= ¬X and σ |= X ∨ Y constrain σ to σ(X) = False and σ(Y ) = True, so σ |= Y . Functional Programming Spring Semester, 2025 David Basin 10 Requirements for a deductive system • Syntactic entailment ⊢ (derivation rules) and semantic entailment |= (truth tables) should agree • This requirement has two parts: Soundness: If Γ ⊢ A can be derived, then Γ |= A Completeness: If Γ |= A, then Γ ⊢ A can be derived For Γ ≡ A1, . . . , An some collection of formulae. • These are key requirements for any logic • Decidability is also desirable. What is complexity of determining: \u0011 If a proposition A is satisfied by a valuation σ? \u0011 If A is satisfiable? \u0011 If A is a tautology? Functional Programming Spring Semester, 2025 David Basin 11 Natural deduction for propositional formulae • A sequent is an assertion (judgement) of the form A1, . . . , An ⊢ A where all A, A1, . . . An are propositional formulae • Intuitively: A follows from the Ais If deductive system is sound, this means Ais semantically entail A • Axiom: starting point for building derivation trees axiom . . . , A, . . . ⊢ A • A proof of A is a derivation tree with root ⊢ A. If deductive system is sound, then A is a tautology Functional Programming Spring Semester, 2025 David Basin 12 Conjunction • Rules of two kinds: introduce and eliminate connectives Γ ⊢ A Γ ⊢ B ∧-I Γ ⊢ A ∧ B Γ ⊢ A ∧ B ∧-EL Γ ⊢ A Γ ⊢ A ∧ B ∧-ER Γ ⊢ B • Example derivation axiom Γ ⊢ X ∧ (Y ∧ Z) ∧-EL Γ ⊢ X axiom Γ ⊢ X ∧ (Y ∧ Z) ∧-ER Γ ⊢ Y ∧ Z ∧-ER Γ ⊢ Z ∧-I X ∧ (Y ∧ Z)︸ ︷︷ ︸ ≡Γ ⊢ X ∧ Z Functional Programming Spring Semester, 2025 David Basin 13 Conjunction (cont.) • Rules of two kinds: introduce and eliminate connectives Γ ⊢ A Γ ⊢ B ∧-I Γ ⊢ A ∧ B Γ ⊢ A ∧ B ∧-EL Γ ⊢ A Γ ⊢ A ∧ B ∧-ER Γ ⊢ B • Each rule is sound in that it preserves semantic entailment. E.g., for ∧-I if Γ |= A and Γ |= B then Γ |= A ∧ B • If all rules preserve semantic entailment, logic is sound. (proof?) • Can we prove anything with just these three rules + axiom? Equivalently: which (purely conjunctive) formulae are tautologies? Functional Programming Spring Semester, 2025 David Basin 14 Implication • Rules Γ, A ⊢ B →-I Γ ⊢ A → B Γ ⊢ A → B Γ ⊢ A →-E Γ ⊢ B • Application of →-I turns last derivation into a proof ... X ∧ (Y ∧ Z) ⊢ X ∧ Z →-I ⊢ X ∧ (Y ∧ Z) → X ∧ Z • Examples: (→ right associative and ∧ binds stronger than →) ⊢ X → Y → X ⊢ (X → Y → Z) → (X → Y ) → X → Z ⊢ (X ∧ Y ) → (Y ∧ X) Functional Programming Spring Semester, 2025 David Basin 15 Disjunction • Rules Γ ⊢ A ∨-IL Γ ⊢ A ∨ B Γ ⊢ B ∨-IR Γ ⊢ A ∨ B Γ ⊢ A ∨ B Γ, A ⊢ C Γ, B ⊢ C ∨-E Γ ⊢ C • Elimination rule formalizes proof by cases • Example: formalize and derive When it rains then I wear my jacket. When it snows then I wear my jacket. It is raining or snowing. Therefore I wear my jacket. Functional Programming Spring Semester, 2025 David Basin 16 Falsity and negation • Falsity Γ ⊢ ⊥ ⊥-E Γ ⊢ A • Negation: define ¬A as A → ⊥. Γ ⊢ ¬A Γ ⊢ A ¬-E Γ ⊢ B derived by Γ ⊢ A→⊥︷︸︸︷ ¬A Γ ⊢ A →-E Γ ⊢ ⊥ ⊥-E Γ ⊢ B Functional Programming Spring Semester, 2025 David Basin 17 Intuitionistic versus classical logic • Peirce’s Law: ((A → B) → A) → A. Is this valid? Provable? • We have only intuitionistic logic. Classical logic requires either \u0011 axiom of excluded middle TND Γ ⊢ A ∨ ¬A (“tertium non datur”) \u0011 or rule Γ, ¬A ⊢ ⊥ RAA Γ ⊢ A (“reductio ad absurdum”) • Example: There exist irrationals a and b such that a b is rational Proof: Let b = √ 2 and consider whether or not b b is rational Case 1: If b b rational, let a = b = √2 Case 2: If b b irrational, let a = b b = √2 √ 2 then ab = (√2 √ 2)√ 2 = √2(√ 2· √ 2) = √22 = 2 Functional Programming Spring Semester, 2025 David Basin 18 Finding ND proofs • Prove statement on paper first, then translate to formal proof. • Heuristic for backwards proofs: Apply safe rules first. \u0011 Rule is safe if we only enlarge Γ or can get the conclusion back. \u0011 ∧-I is safe: Γ ⊢ A ∧ B ∧-EL Γ ⊢ A Γ ⊢ A ∧ B ∧-ER Γ ⊢ B ∧-I Γ ⊢ A ∧ B \u0011 ∨-E + axiom is safe: axiom Γ ⊢ A ∨ B Γ, A ⊢ C Γ, B ⊢ C ∨-E Γ ⊢ C \u0011 ∧-EL is unsafe: Γ ⊢ A Γ ⊢ B ∧-I Γ ⊢ A ∧ B ∧-EL Γ ⊢ A\u0011 How about the other rules? Functional Programming Spring Semester, 2025 David Basin 19 Summary of derivation rules for propositional logic Γ ⊢ A Γ ⊢ B ∧-I Γ ⊢ A ∧ B Γ ⊢ A ∧ B ∧-EL Γ ⊢ A Γ ⊢ A ∧ B ∧-ER Γ ⊢ B Γ, A ⊢ B →-I Γ ⊢ A → B Γ ⊢ A → B Γ ⊢ A →-E Γ ⊢ B Γ ⊢ A ∨-IL Γ ⊢ A ∨ B Γ ⊢ B ∨-IR Γ ⊢ A ∨ B Γ ⊢ A ∨ B Γ, A ⊢ C Γ, B ⊢ C ∨-E Γ ⊢ C Γ ⊢ ⊥ ⊥-E Γ ⊢ A Γ ⊢ ¬A Γ ⊢ A ¬-E Γ ⊢ B Γ, ¬A ⊢ ⊥ RAA Γ ⊢ A Functional Programming Spring Semester, 2025 David Basin 20 Road map • Natural deduction • Propositional logic ☞ First-order logic \u0011 Syntax: variables over domain + functions, relations, quantifiers \u0011 Semantics: interpreting domain, functions, and relations \u0011 Deduction: ND proof rules for quantifiers • Equality Functional Programming Spring Semester, 2025 David Basin 21 First-Order Logic: Syntax • Two syntactic categories: terms and formulae • A signature consists of a set of function symbols F and a set of predicate symbols P (and their arities) Write f k (or pk) to indicate function symbol f (or predicate symbol p) has arity k ∈ N N.B. constants are 0-ary function symbols • Let V be a set of variables • Term, the terms of first-order logic, is the smallest set where 1. x ∈ Term if x ∈ V, and 2. f n(t1, . . . , tn) ∈ Term if f n ∈ F and ti ∈ Term, for all 1 ≤ i ≤ n Functional Programming Spring Semester, 2025 David Basin 22 Syntax (cont.) • Form, the formulae of first-order logic, is the smallest set where 1. ⊥ ∈ Form, 2. pn(t1, . . . , tn) ∈ Form if pn ∈ P and tj ∈ Term, for all 1 ≤ j ≤ n, 3. A ◦ B ∈ Form if A ∈ Form, B ∈ Form, and ◦ ∈ {∧, ∨, →}, and 4. Qx. A ∈ Form if A ∈ Form, x ∈ V, and Q ∈ {∀, ∃} • Each occurrence of each variable in a formula is bound or free. (q(x) ∨ ∃x. ∀y. p(f (x), z) ∧ q(a)) ∨ ∀x. r(x, z, g(x)) A variable occurrence x in a formula A is bound if x occurs within a subformula B of A of the form ∃x.B or ∀x. B • Analog from mathematics: x2 + ∫ d c x · y dy or ∑5 i=0 x · i Functional Programming Spring Semester, 2025 David Basin 23 Binding and α-conversion • Names of bound variables are irrelevant, they just encode the binding structure. ∃x. ∀y. p(f (x), y) ∧ q(x, z) stands for ∃ ∀ p(f (•), •) ∧ q(•, z) • We can rename bound variables at any time (α-conversion). \u0011 Must preserve binding structure. • Examples: α-convertible? ∀x. ∃y. p(x, y) ∀y. ∃x. p(y, x) yes ∃z. ∀y. p(z, f (y)) ∃y. ∀y. p(y, f (y)) no (∀x. p(x)) ∨ (∃x. q(x)) (∀z. p(z)) ∨ (∃y. q(y)) yes p(x) → ∀x. p(x) p(y) → ∀y. p(y) no Functional Programming Spring Semester, 2025 David Basin 24 Omitting parentheses • Binary operators: \u0011 ∧ binds stronger than ∨ stronger than →. \u0011 → associates to the right; ∧ and ∨ to the left. • Negation binds stronger than binary operators. • Quantifiers extend to the right as far as possible: end of line or ). p ∨ q ∧ ¬r → p ∨ q (p ∨ (q ∧ (¬ r))) → (p ∨ q) p → q ∨ p → r p → ((q ∨ p) → r) p ∧ ∀x. q(x) ∨ r p ∧ (∀x. (q(x) ∨ r)) ¬ ∀x. p(x) ∧ ∀x. q(x) ∧ r(x) ∧ s ¬   ∀x.  p(x) ∧ ( ∀x. (( q(x) ∧ r(x) ) ∧ s))     Functional Programming David Basin 25 Semantics • A structure is a pair S = ⟨US, IS⟩ where US is an nonempty set, the universe, and IS is a mapping where 1. IS(pn) is an n-ary relation on US, for pn ∈ P, and 2. IS(f n) is an n-ary (total) function on US, for f n ∈ F As shorthand, write pS for IS(p) and f S for IS(f ) • An interpretation is a pair I = ⟨S, v⟩, where S = ⟨US, IS⟩ is a structure and v : V → US a valuation. • The value of a term t under the interpretation I = ⟨S, v⟩ is written as I(t) and defined by 1. I(x) = v(x), for x ∈ V, and 2. I(f (t1, . . . , tn)) = f S(I(t1), . . . , I(tn)) Functional Programming Spring Semester, 2025 David Basin 26 Semantics (cont.) Satisfiability: |= ⊆ Interpretations × Form is the smallest relation satisfying ⟨S, v⟩ |= p(t1, . . . , tn) if (I(t1), . . . , I(tn) ) ∈ pS, where I = ⟨S, v⟩ ... ⟨S, v⟩ |= ∀x. A if ⟨S, v[x ↦→ a]⟩ |= A, for all a ∈ US ⟨S, v⟩ |= ∃x. A if ⟨S, v[x ↦→ a]⟩ |= A, for some a ∈ US Here v[x ↦→ a] is the valuation v′ identical to v, except that v′(x) = a Functional Programming Spring Semester, 2025 David Basin 27 Semantics (cont.) • When ⟨S, v⟩ |= A we say A is satisfied with respect to ⟨S, v⟩ or ⟨S, v⟩ is a model of A. • Note that if A does not have free variables, satisfaction does not depend on the valuation v. We write S |= A. • When every interpretation is a model, we write |= A and say that A is valid. • A is satisfiable if there is at least one model for A (and contradictory otherwise) • Complexity of these problems? Functional Programming Spring Semester, 2025 David Basin 28 An example ∀x. p(x, s(x)) • A model: US = N pS = {(m, n) | m, n ∈ US and m < n} sS = the successor function on US = i.e., sS(x) = x + 1 • Not a model: US = {a, b, c} pS = {(a, a), (a, b), (a, c)} sS = the identity function Functional Programming Spring Semester, 2025 David Basin 29 More examples Which of following are satisfiable? Valid? • ∀x. ∃y. y ∗ 2 = x satisfied WRT rationals • ∀x. ∀y. x < y → ∃z. x < z ∧ z < y satisfied WRT any dense order • ∃x. x ̸= 0 satisfied WRT structures S with ≥ 2 elements in US • (∀x. p(x, x)) → p(a, a) valid Functional Programming Spring Semester, 2025 David Basin 30 Substitution • Replace in A all occurrences of a free variable x with some term t. • We write A[x ↦→ t] to indicate that we substitute x by t in A. • Example: A ≡ ∃y. y ∗ x = x ∗ z A[x ↦→ 2 − 1] ≡ ∃y. y ∗ (2 − 1) = (2 − 1) ∗ z A[x ↦→ z] ≡ ∃y. y ∗ z = z ∗ z • All free variables of t must still be free in A[x ↦→ t]. Avoid capture! If necessary, α-convert A before substitution. A[x ↦→ 3 + y] ̸≡ ∃y. y ∗ (3 + y) = (3 + y) ∗ z A[x ↦→ 3 + y] ≡ ∃w. w ∗ (3 + y) = (3 + y) ∗ z Functional Programming Spring Semester, 2025 David Basin 31 Universal quantification • Rules Γ ⊢ A ∀-I ∗ Γ ⊢ ∀x. A Γ ⊢ ∀x. A ∀-E Γ ⊢ A[x ↦→ t] Side condition *: x not free in any assumption in Γ. • Example derivation: axiom implicit α-conversion ∀x. p(x) ⊢ ∀z. p(z) ∀-E with x ≡ z and t ≡ f (y) ∀x. p(x) ⊢ p(f (y)) ∀-I y not free in ∀x. p(x) ∀x. p(x) ⊢ ∀y. p(f (y)) →-I ⊢ (∀x. p(x)) → (∀y. p(f (y))) • N.B. we continue to use rules from propositional logic, but now for first-order formulae. Functional Programming Spring Semester, 2025 David Basin 32 Universal quantification (cont.) • Rules Γ ⊢ A ∀-I ∗ Γ ⊢ ∀x. A Γ ⊢ ∀x. A ∀-E Γ ⊢ A[x ↦→ t] Side condition *: x not free in any assumption in Γ. • Why this side condition? Consider the following “derivation”: axiom x = 0 ⊢ x = 0 ∀-I x = 0 ⊢ ∀x. x = 0 →-I ⊢ x = 0 → ∀x. x = 0 ∀-I ⊢ ∀x. (x = 0 → ∀x. x = 0) ∀-E ⊢ 0 = 0 → (∀x. x = 0) ref (see later) ⊢ 0 = 0 →-E ⊢ ∀x. x = 0 Functional Programming Spring Semester, 2025 David Basin 33 Universal quantification (cont.) • Rules Γ ⊢ A ∀-I ∗ Γ ⊢ ∀x. A Γ ⊢ ∀x. A ∀-E Γ ⊢ A[x ↦→ t] Side condition *: x not free in any assumption in Γ. • Is the following a proof? axiom ∀x. ∃y. x ̸= y ⊢ ∀x. ∃y. x ̸= y ∀-E wrong ∀x. ∃y. x ̸= y ⊢ ∃y. y ̸= y →-I correct ⊢ (∀x. ∃y. x ̸= y) → (∃y. y ̸= y) • Conclusion is not valid. Reason: false if US has ≥ 2 elements. • Proof incorrect. Reason: Substitution must avoid capture. Here: A ≡ ∃y. x ̸= y When substituting t ≡ y for x, we must rename bound y in A! Functional Programming Spring Semester, 2025 David Basin 34 Universal quantification (cont.) • Prove (∀x. p(x) ∧ q(x)) → (∀x. p(x)) ∧ (∀x. q(x)) axiom Γ ⊢ ∀y. p(y) ∧ q(y) ∀-E Γ ⊢ p(x) ∧ q(x) ∧-EL Γ ⊢ p(x) ∀-I Γ ⊢ ∀x. p(x) axiom Γ ⊢ ∀z. p(z) ∧ q(z) ∀-E Γ ⊢ p(x) ∧ q(x) ∧-ER Γ ⊢ q(x) ∀-I Γ ⊢ ∀x. q(x) ∧-I ≡Γ︷ ︸︸ ︷ ∀x. p(x) ∧ q(x) ⊢ (∀x. p(x)) ∧ (∀x. q(x)) →-I ⊢ (∀x. p(x) ∧ q(x)) → (∀x. p(x)) ∧ (∀x. q(x)) • Generalize proof: \u0011 Can use any formulae A and B instead of relations p and q. \u0011 Side conditions of ∀-I are trivial: x not free in Γ. Functional Programming Spring Semester, 2025 David Basin 35 Existential quantification • Rules Γ ⊢ A[x ↦→ t] ∃-I Γ ⊢ ∃x. A Γ ⊢ ∃x. A Γ, A ⊢ B ∃-E ∗ Γ ⊢ B Side condition *: x is neither free in B nor free in Γ. • Sample derivation, * z is neither free in Γ nor in q: axiom Γ ⊢ ∃z. p(z) axiom Γ ′ ⊢ ∀w. p(w) → q ∀-E Γ ′ ⊢ p(z) → q axiom Γ ′ ⊢ p(z) →-E Γ, p(z) ⊢ q ∃-E ∗ ∀x. p(x) → q, ∃y. p(y) ⊢ q →-I ∀x. p(x) → q ⊢ (∃y. p(y)) → q →-I ⊢ (∀x. p(x) → q) → ((∃y. p(y)) → q) where Γ ≡ ∀x.p(x) → q, ∃y. p(y) and Γ ′ ≡ Γ, p(z) Functional Programming Spring Semester, 2025 David Basin 36 Road map • Natural deduction • Propositional logic • First-order logic ☞ Equality Functional Programming Spring Semester, 2025 David Basin 37 FOL with equality • Equality is a logical symbol with associated proof rules One speaks of first-order logic with equality rather than equality being “just another predicate” • Extended language: t1 = t2 ∈ Form if t1, t2 ∈ Term • Extend definition of semantic entailment |=: I |= t1 = t2 if I(t1) = I(t2) \u0011 Recall I(t) is the value of t under the interpretation I = ⟨S, v⟩ \u0011 Note the two completely different uses of “=” here! Functional Programming Spring Semester, 2025 David Basin 38 Equality • Equality is an equivalence relation ref Γ ⊢ t = t Γ ⊢ t = s sym Γ ⊢ s = t Γ ⊢ t = s Γ ⊢ s = r trans Γ ⊢ t = r • Equality is also a congruence on terms and all (definable) relations Γ ⊢ t1 = s1 · · · Γ ⊢ tn = sn cong1Γ ⊢ f (t1, . . . , tn) = f (s1, . . . , sn) Γ ⊢ t1 = s1 · · · Γ ⊢ tn = sn Γ ⊢ p(t1, . . . , tn) cong2Γ ⊢ p(s1, . . . , sn) • Soundness: equality on US is a congruence Functional Programming Spring Semester, 2025 David Basin 39 On the shape of proofs • Let Γ ≡ a(b) = d(e), f (d(e)) = g(h). Prove Γ ⊢ f (a(b)) = g(h) axiom Γ ⊢ a(b) = d(e) cong1Γ ⊢ f (a(b)) = f (d(e)) axiom Γ ⊢ f (d(e)) = g(h) trans Γ ⊢ f (a(b)) = g(h) • Compare with following linear equational derivation f (a(b)) = f (d(e)) = g(h) • In general, any equality proof can be converted into such a linear style. We will usually carry out equality reasoning this linear way. • We will see many examples shortly, e.g., in proofs by induction. Functional Programming Spring Semester, 2025 David Basin 40 What next? • We consider the correctness question for functional programs. • I will usually not write formal proofs using these rules. • However, all proofs given can be translated to formal ones. • You should check this, also for your own proofs. • Topic is also of central importance in course’s second half. Functional Programming Spring Semester, 2025","libVersion":"0.5.0","langs":""}