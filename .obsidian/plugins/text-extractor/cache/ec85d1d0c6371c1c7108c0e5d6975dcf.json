{"path":"sem2/PProg/PV/exams/PProg-exam-.pdf","text":"Vor und Nachname (Druckbuchstaben): Legi Nummer: 252-0029-00L Parallele Programmierung ETH/CS: FS 2021 Semesterpr¨ufung Mittwoch, 25.08.2021 120 Minuten Diese Pr¨ufung enth¨alt 30 Seiten (inklusive Deckblatt) und 10 Aufgaben. ¨Uberpr¨ufen Sie nach Beginn der Pr¨ufung, dass keine Seiten fehlen. Schreiben Sie die Legi-Nummer oben auf jede einzelne Seite. Sie haben 120 Minuten Zeit f¨ur die L¨osung der Pr¨ufung. Falls Sie sich durch irgendjemanden oder irgendetwas gest¨ort f¨uhlen, melden Sie dies einer Auf- sichtsperson. Wir sammeln die Pr¨ufung zum Schluss ein, stellen Sie sicher, dass Ihre Pr¨ufung von einem Assistenten eingezogen wird. Wenn Sie fr¨uher abgeben wollen melden Sie sich und wir holen die Pr¨ufung ab. Vorzeitige Abgaben sind nur bis 15 Minuten vor Pr¨ufungsende m¨oglich. Wenn Sie zur Toilette m¨ussen, melden Sie dies einer Aufsichtsperson durch Handzeichen. Es darf zur gleichen Zeit immer nur eine Person zur Toilette. • L¨osungen m¨ussen lesbar sein. L¨osungen mit unklarer Reihenfolge oder anderweitig un- verst¨andlicher Pr¨asentation k¨onnen zu Punktabz¨ugen f¨uhren. Verwenden Sie keinen Blei- stift und keine rot oder orange-farbenen Stifte. • Falls mehr Platz ben¨otigt wird, schreiben Sie auf die leeren Seiten am Ende der Pr¨ufungsunterlagen. Versehen Sie die Aufgabe mit einem klaren Hinweis, falls das der Fall ist. • Multiple-choice Fragen werden minimal mit 0 Punkten bewertet, es werden keine negativen Punkte erteilt. • Die Aufgabenstellungen sind in Deutsch und Englisch gegeben. Die Aufgaben k¨onnen auf Deutsch oder Englisch beantwortet werden. • Legen Sie ihre ETH Karte zur Identit¨ats¨uberpr¨ufung gut sichtbar vor sich auf den Tisch. • In dieser Pr¨ufung sind keine Hilfsmittel oder mitgebrachte Unterlagen erlaubt, ausser ein W¨orterbuch f¨ur fremdsprachige Studierende. Insbesondere alle kommunikationsf¨ahigen, pro- grammierbaren und/oder speicherf¨ahigen Ger¨ate wie bspw. Smartphones, Smartwatches, etc. sind nicht erlaubt. Bei unehrlichem Handeln gelten die Strafnormen der Disziplinarordnung der ETH. • Eine pl¨otzlich auftretende Erkrankung muss bei der Pr¨ufungsaufsicht explizit angezeigt wer- den — ebenso zwingend erforderlich ist eine Mitteilung, die Pr¨ufung aus medizinischen Gr¨unden nicht beenden zu k¨onnen. Studierende mit Fieber, Husten, Atemnot, Verlust des Geschmacksinns, Muskelschmerzen d¨urfen nicht an der Pr¨ufung teilnehmen. Die Pr¨ufungsaufsicht ist befugt, Studierende, die oﬀensichtliche Krankheitssym- ptome zeigen, aus der Pr¨ufung zu weisen. Question: 1 2 3 4 5 6 7 8 9 10 Total Points: 11 15 9 13 12 10 14 10 12 14 120 Score: Parallele Programmierung - Semesterpr¨ufung - Seite 2 von 30 Mittwoch, 25.08.2021 Speedup, Amdahl, Gustafson (11 points) 1. Beantworten Sie die untenstehenden Fragen. Begr¨unden Sie ihre Antworten und geben Sie alle Rechenschritte an. Sie m¨ussen nicht die ge- nauen Dezimalzahlen berechnen. Answer the questions below. Justify your answers and give all the calculation steps. You don’t need to calculate the exact dec- imal numbers. (a) (1)Nehmen Sie an ein Programm besteht zu 70% aus parallelisierbarer Arbeit. Wir wol- len einen Speedup von 8 gem¨ass Gustafson’s Gesetz erlangen. Wie viele Prozessoren sind notwendig? Assume a program consists of 70% par- allelizable work. We want to achieve a speed up of 8 according to Gustafson’s law. How many processors are neces- sary? (b) (3)Angenommen Sie haben 4 Prozessoren in Nutzung bei einer Parallelit¨at von 70%. Ihre Firma hat ein Budget f¨ur: • A: 2 weitere Prozessoren. • B: Ein Programmierer, der die Paralle- lit¨at von 70% auf 80% erh¨oht. Welche der L¨osungen w¨urden sie empfehlen um die Laufzeit zu minimieren? Assume you are using four processors for a use case with 70% parallelizable work. Your company has a limited budget for either • A: 2 additional processors. • B: A software engineer to increase the parallel part from 70% to 80%. Which solution would you suggest to minimize runtime? Parallele Programmierung - Semesterpr¨ufung - Seite 3 von 30 Mittwoch, 25.08.2021 (c) (3)Sie haben f¨ur das oben genannte Programm Maschinen in der Firma f¨ur 24h (einen Tag) per Woche reserviert. Angenommen Sie m¨ochten nicht den Speedup optimieren, son- dern die Arbeit welche in dieser Zeit voll- bracht wird. Das dauerhafte laufen lassen des Programmes f¨ugt jedoch einen nicht paralleli- sierbaren Aufwand von 20% hinzu. Der paral- lelisierbare Anteil entspricht daher nun 50%. Sie haben erneut das Budget f¨ur die folgen- den zwei Optionen: • A: 2 weitere Prozessoren. • B: Ein Programmierer, der die Paralle- lit¨at um 40% erh¨oht (50% → 90%). Welche der L¨osungen w¨urden Sie empfehlen um die Laufzeit von 24h optimal auszunut- zen? Ignorieren Sie, ob der letzte Durchgang des Programmes komplett abgeschlossen wer- den kann. For the previously mentioned program you reserved computers in your company for 24 hours (one day) each week. As- sume you do not want to optimize the speedup but instead the amount of work that can be done in the given time. Let- ting the program run permanently adds, however, a non-parallelizable overhead of 20%. Thus, the parallelizable part is now 50%. You have again the budget for the following two options: • A: 2 additional processors. • B: A software engineer to increase the parallel part by 40% (50% → 90%). Which of the solutions would you rec- ommend to make the best use of the 24h runtime? Ignore whether the last run of the program can be fully completed. Parallele Programmierung - Semesterpr¨ufung - Seite 4 von 30 Mittwoch, 25.08.2021 (d) (4)Nehmen Sie an, dass Ihr Budget Ihnen erm¨oglich 5 Prozessoren mit einer Taktung von 2.5 GHz oder 8 Prozessoren mit einer Taktung von 1.5 GHz zu kaufen. Angenom- men die Arbeit ist konstant und der paralle- lisierbare Anteil entspricht 50%, welche der beiden Optionen ist die bessere? • A: 8 Prozessoren mit einer Taktung von 1.5 GHz. • B: 5 Prozessoren mit einer Taktung von 2.5 GHz. Assume that your budget allows to buy 5 processors with a clock speed of 2.5 GHz or 8 processors with a clock speed of 1.5 GHz. Assuming that the work (problem size) is constant and the parallelizable part is equal to 50%, which of the two options is better? • A: 8 processors with a clock speed of 1.5 GHz. • B: 5 processors with a clock speed of 2.5 GHz. Parallele Programmierung - Semesterpr¨ufung - Seite 5 von 30 Mittwoch, 25.08.2021 Pipelining (15 points) 2. Drei Studenten leben in einer Wohngemein- schaft. Seit dem neuen Semester hat sich der Stundenplan ge¨andert und nun m¨ussen alle gleichzeitig an der Uni sein. Leider funktioniert die bisherige Regelung nicht mehr, dass jeder die gemeinsamen R¨aume nutzen kann wie er m¨ochte. Alle sind sich einig, dass der Tag mit einem Kaﬀee (“coﬀee”) starten muss, direkt ge- folgt von der Dusche (“bath”). Danach setzt der Hunger (“toaster”) ein und zu guter letzt soll- te nat¨urlich alles ordentlich hinterlassen werden und das Geschirr gesp¨ult sein (“sink”). Betrach- ten Sie die drei unten dargestellten separaten Pipelines. Nehmen Sie f¨ur alle nachfolgen- den Fragen an, dass die drei Studenten kein Objekt gleichzeitig benutzen wollen. Die folgenden drei Zeilen zeigen drei m¨ogliche separate Pipelines: Three students live in a shared apartment. With the start of the new semester the class schedule changed, so they now all have to be at the university at the same time. Unfortunately, the existing rule al- lowing everyone to use the shared rooms as they want does not work anymore. They all agree that the day starts with a coﬀee (“coﬀee”), followed by a shower (“bath”). Then hunger (“toaster”) kicks in and at the end everything should be clean again and the dishes be done (“sink”). Consider the three separate pipelines shown below. For all of the following question, as- sume that the three students do not want to use an object at the same time. The following three lines show three possible separate pipelines: i) coﬀee 10 min bath 10 min toaster 15 min sink 10 min ii) coﬀee 5 min bath 20 min toaster 5 min sink 20 min iii) coﬀee 15 min bath 5 min toaster 15 min sink 10 min Sie k¨onnen den folgenden Platz f¨ur Notizen ver- wenden. You can use the following space for notes. Parallele Programmierung - Semesterpr¨ufung - Seite 6 von 30 Mittwoch, 25.08.2021 (a) (3)Was ist der Durchsatz (“throughput”) der einzelnen Pipelines pro Stunde in dieser WG? What is the throughput of each pipeline per hour in this living community? i) ii) iii) (b) (5)Das Ziel ist, dass alle drei Studenten so schnell wie m¨oglich fertig sind. Rechnen sie die Zeit aus, die es ben¨otigt bis alle drei Stu- denten die Pipelines durchlaufen haben. Be- gr¨unden Sie Ihre Antwort und geben Sie al- le Rechenschritte an. Welche Pipeline(s) ist (sind) die schnellste(n)? The goal is for all students to ﬁnish the morning schedule as quickly as possible. Calculate the time it takes to ﬁnish each Pipeline for all the three students. Jus- tify your answer and state all the calcu- lation steps. Which pipeline(s) is (are) the fastest? (c) (3)F¨ur Pipeline ii): Was ist der Speedup vergli- chen mit der streng sequentiellen Reihenfolge (d.h. wenn jeder Student erst anf¨angt, wenn der Vorherige mit dem Geschirrsp¨ulen fertig ist, statt schon anzufangen wenn die Kaﬀee- maschine frei ist)? Begr¨unden Sie Ihre Ant- wort und geben Sie alle Rechenschritte an. Sie k¨onnen das Ergebnis als Bruch angeben. For pipeline ii): What is the speedup compared to the strictly sequential or- der (i.e., every student only starts af- ter the previous student ﬁnished doing the dishes, instead of starting as soon as the coﬀee maker is available)? Justify your answer and state all the calculation steps. You can provide the result as a fraction. Parallele Programmierung - Semesterpr¨ufung - Seite 7 von 30 Mittwoch, 25.08.2021 (d) (4)Aufgrund von einer Pandemie ist es den Stu- denten leider nicht erlaubt eines der 4 ge- meinsamen Objekte zu benutzen bevor der vorhergehende Student komplett fertig ist (d.h. mit dem ”sink” Schritt abgeschlos- sen hat). Die Studenten haben jedoch die M¨oglichkeit, jeden Schritt um 10 Minuten zu verl¨angern um die Objekte zu desinﬁzie- ren, damit die n¨achste Person das Objekt un- mittelbar nach der Desinfektion verwenden kann. Welche Pipeline ist am schnellsten mit dieser neuen Regelung und lohnt es sich f¨ur die Studenten diese zu implementieren? Aus Solidarit¨at muss der letzte Student ebenso al- les desinﬁzieren. Begr¨unden Sie Ihre Antwort und geben Sie alle Rechenschritte an. Due to a pandemic the students are not allowed to use one of the 4 shared ob- jects before the previous student is ﬁn- ished with all of them (i.e. ﬁnished the ”sink” step). However, students have the option to extend each step by 10 minutes for disinfection of the objects to allow the next person to use the object immediately after disinfection. Which pipeline is fastest with this new rule? Is it worth it for the students to implement the rule? In solidarity, the last student must also disinfect everything. Justify your answer and state all the calculation steps. Parallele Programmierung - Semesterpr¨ufung - Seite 8 von 30 Mittwoch, 25.08.2021 Task Graphs (9 points) 3. Abbildung 1 zeigt den Task-Graphen eines Al- gorithmus. Die Zahl in einem Knoten bezeich- net die ben¨otigte Ausf¨uhrungszeit f¨ur den je- weiligen Berechnungsschritt. Figure 1 shows the task graph of an algo- rithm. The number in each node denotes the execution time for the particular task. 8030 70 80 3020 100 60 7090 10 Abbildung 1: Task-Graph. Figure 1: Task graph. (a) (2)Markieren Sie den kritischen Pfad des Task- Graphen in Abbildung 1. Was ist die Ausf¨uhrungszeit des kritischen Pfads? Mark the critical path of the task graph in Figure 1. What is the execution time of the critical path? (b) (4)Was ist die minimale Anzahl Prozessoren, die n¨otig sind um den Task-Graphen in Abbil- dung 1 so schnell wie m¨oglich auszuf¨uhren? Wie hoch ist die Ausf¨uhrungszeit? What is the minimum number of proces- sors necessary to execute the task graph in Figure 1 as quickly as possible? What is the execution time? Parallele Programmierung - Semesterpr¨ufung - Seite 9 von 30 Mittwoch, 25.08.2021 (c) (3)Angenommen Sie haben einen Weg gefun- den einen bisher sequentiellen Arbeitsschritt zu parallelisieren. D.h. Sie d¨urfen aus einem Knoten zwei Knoten machen, welche diesel- ben eingehenden und ausgehenden Kanten haben wie der originale Knoten, aber nur die H¨alfte der Zeit ben¨otigen. Welchen Kno- ten w¨urden Sie aufteilen, um die h¨ochste Be- schleunigung zu erzielen? W¨urde dies die mi- nimale Anzahl Prozessoren von Aufgabe b) f¨ur die schnellstm¨ogliche Ausf¨uhrung dieses neuen Graphen ¨andern? Wie hoch ist nun die Ausf¨uhrungszeit? Assume you discovered a way to par- allelize a sequential task. That means you are allowed to split one node into two nodes having the same incoming and outgoing edges as the original node, but require only half the time. Which node would you split to yield the high- est speedup? How would your choice af- fect the minimal number of processors in task b) required for the fastest execu- tion of the graph? What is the execution time now? Parallele Programmierung - Semesterpr¨ufung - Seite 10 von 30 Mittwoch, 25.08.2021 Wait/Notify (13 points) 4. Eine Gruppe von Doktoranden korrigiert Pr¨ufungen. Jedem Doktoranden wird eine be- stimmte Aufgabe zur Korrektur zugewiesen. Die Pr¨ufungen liegen alle auf einem Stapel. Es wird immer die oberste Pr¨ufung genommen (poll). Jede Pr¨ufung kann immer nur von ei- nem Doktoranden korrigiert werden. Des Wei- teren kann ein Doktorand zu einem bestimmten Zeitpunkt nur eine Pr¨ufung korrigieren. Ist die Aufgabe korrigiert, wird die Pr¨ufung unter den Stapel gelegt (add). Sind alle Aufgaben korri- giert, wird die Pr¨ufung auf den correctedPile gelegt (push). A group of doctoral students is correcting exams. Each doctoral student is assigned a speciﬁc exercise to correct. The exams are all in one pile. The topmost exam is always taken (poll). Each exam can only be cor- rected by one doctoral student at a time. Further, a doctoral student can only cor- rect one exam at a time. Once the exercise is corrected, the exam is placed under the stack (add). If all exercises are corrected, the exam is placed on the correctedPile (push). (a) (13)Vervollst¨andigen Sie das Code-Skelett der Klassen PhD, Supervisor und ExamPile gem¨ass der Beschreibung in den Kommenta- ren. Die Konstruktoren der Klassen m¨ussen nicht vervollst¨andigt werden. Ihre L¨osung sollte notify(), notifyAll(), wait() und das synchronized-Schl¨usselwort verwenden um das Programm korrekt zu synchronisie- ren, aber Sie sollen keine unn¨otige Synchro- nisation einf¨uhren. In dieser Aufgabe m¨ussen Sie Exceptions nicht behandeln. Complete the code skeleton of the classes PhD, Supervisor, and ExamPile ac- cording to the description in the com- ments. The constructors of the classes do not need to be completed. Make sure that your solution is properly synchro- nized by using notify(), notifyAll(), wait() and the synchronized keyword where required, but do not introduce unnecessary synchronization. For this task, you do not need to handle excep- tions. Parallele Programmierung - Semesterpr¨ufung - Seite 11 von 30 Mittwoch, 25.08.2021 public class Queue<E> { // Ruft den Kopf dieser Queue ab und entfernt ihn oder // gibt null zur¨uck, wenn die Queue leer ist. /* Retrieves and removes the head of this queue, or returns null if the queue is empty. */ public E poll() { ... } // F¨ugt das angegebene Element in die Queue ein. /* Inserts the specified element into the queue. */ public void add(E e){ ... } // Gibt die Anzahl der Elemente in der Queue zur¨uck. /* Returns the number of elements in the queue. */ public int size(){ ... } } public class Stack<E> extends Vector<E> { // F¨ugt ein Element zuoberst auf dem Stack ein. /* Pushes an item onto the top of the stack. */ public synchronized void add(E e){ ... } // Gibt die Anzahl der Elemente im Stack zur¨uck. /* Returns the number of items in the stack. */ public synchronized int size(){ ... } } public class Exam { private ArrayList<Exercise> exercises; public Exam(){ ... } // Ein Doktorand (PhD) korrigiert die zugewiesene Aufgabe. /* A doctoral student (PhD) corrects the assigned exercise. */ public void correct(PhD phd) throws InterruptedException { ... } // Gibt True zur¨uck, wenn jede Aufgabe der Pr¨ufung korrigiert wurde // ansonsten wird False zur¨uckgegeben. /* Returns True, if each exercise of the exam is corrected, otherwise False is returned. */ public boolean isFullyCorrected(){ ... } // Gibt True zur¨uck, wenn die i-te Aufgabe korrigiert wurde, // andernfalls wird False zur¨uckgegeben. /* Returns True, if the i-th exercise is corrected, otherwise False is returned. */ public boolean isExerciseCorrected(int i) throws InterruptedException { ... } } Parallele Programmierung - Semesterpr¨ufung - Seite 12 von 30 Mittwoch, 25.08.2021 public class PhD extends Thread { private final int exerciseToCorrect; private ExamPile examPile; private final Stack<Exam> correctedPile; public PhD(int exerciseToCorrect, ExamPile examPile, Stack<Exam> correctedPile){ ... } @Override public void run() { while(true) { try { // Die n¨achste Pr¨ufung holen. /* Get the next exam. */ Exam exam = .................................... // Falls noch nicht korrigiert, wird die Aufgabe korrigiert. /* If not corrected yet, correct the exercise. */ if(...............................................) { ............................................... ............................................... ............................................... } // Wenn die Pr¨ufung vollst¨andig korrigiert ist, f¨ugen Sie sie // dem korrigierten Stapel hinzu, andernfalls legen Sie sie // zur¨uck zu den anderen Pr¨ufungen. /* If the exam is fully corrected, add it to the corrected pile, otherwise put it back to the other exams. */ if(...............................................){ ................................................ ................................................ ................................................ } else{ ................................................ ................................................ ................................................ } } catch (InterruptedException e) { System.out.println(\"I'm done and going home.\"); return; } } } } Parallele Programmierung - Semesterpr¨ufung - Seite 13 von 30 Mittwoch, 25.08.2021 public class Supervisor implements Runnable{ private final Stack<Exam> correctedPile; private final int numberOfStudents; private final ArrayList<PhD> phds; public Supervisor(int numberOfStudents, Stack<Exam> correctedPile, ArrayList<PhD> phds){ ... } @Override public void run() { while(true) { try { // Sobald jede Pr¨ufung korrigiert ist... /* As soon as every exam is corrected... */ if(correctedPile.size() == this.numberOfStudents){ // ...unterbricht der Supervisor alle Doktoranden (PhDs)... /* ...the supervisor interrupts all doctoral students (PhDs)... */ for(PhD phd : this.phds){ ....................................... ....................................... ....................................... } // Nachdem alle PhDs nach Hause gegangen sind... /* After all PhDs went home... */ for(PhD phd : this.phds){ ....................................... ....................................... ....................................... } // ...geht der Supervisor ebenfalls nach Hause. /* ...the supervisor also goes home. */ System.out.println(\"Going home, too!\"); return; } Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } } Parallele Programmierung - Semesterpr¨ufung - Seite 14 von 30 Mittwoch, 25.08.2021 public class ExamPile { private Queue<Exam> exams; public ExamPile(Queue<Exam> exams) { ... } // Wenn sich eine Pr¨ufung in der Queue befindet, nehmen Sie sie, // ansonsten warten Sie, bis jemand eine Pr¨ufung wieder auf den Stapel legt. /* If there is an exam in the queue, poll it, otherwise wait until someone put an exam back on the pile. */ public Exam pollExam() throws InterruptedException { .......................................... .......................................... .......................................... .......................................... .......................................... .......................................... .......................................... .......................................... } // F¨ugen Sie die Pr¨ufung wieder der Queue hinzu. /* Add the exam back to the queue. */ public void addExam(Exam exam){ ........................................... ........................................... ........................................... ........................................... ........................................... ........................................... ........................................... } } Parallele Programmierung - Semesterpr¨ufung - Seite 15 von 30 Mittwoch, 25.08.2021 Fork/Join Framework (12 points) 5. Wir wollen einen Vektor v unter Benutzung der 2-Norm normieren, d.h. wir ersetzen je- des Element vi an Position i des Vektors mit vi/√∑ j v2 j . Der Spezialfall des Nullvektors (al- le Elemente von v sind 0) muss nicht behandelt werden. Unten ﬁnden Sie eine sequentielle Im- plementierung: We want to normalize a vector v using the 2-norm. For this we need to replace every value vi at position i by vi/√∑ j v2 j . You do not have to handle the case where the vector v is a zero vector (i.e., all elements of v are 0). A sequential implementation is provided below: public void vecNorm(double[] data) { double norm = 0; for (int i = 0; i < data.length; ++i) { norm += data[i]*data[i]; } norm = Math.sqrt(norm); for (int i = 0; i < data.length; ++i) { data[i] = data[i]/norm; } } (a) (10)Vervollst¨andigen Sie das Code-Skelett auf der n¨achsten Seite mit Hilfe des ForkJoin Fra- meworks. Ihre L¨osung muss die Berech- nung direkt auf dem Array data (in- place) vornehmen. Verwenden Sie kei- ne zus¨atzlichen Datenstrukturen (z.B. Arrays, Listen, Hashmaps, etc.). Stel- len Sie sicher, dass die Daten so auf die Sub-Tasks verteilt werden, dass alle ungef¨ahr gleich viel Arbeit haben und dass die Sub- Tasks parallel ausgef¨uhrt werden. Sie erhal- ten keine Punkte f¨ur sequentielle L¨osungen. In dieser Aufgabe m¨ussen Sie Exceptions nicht behandeln. Complete the code skeleton on the next page using the ForkJoin framework. The solution has to perform the computation in-place (i.e., directly update the data array) without us- ing any auxiliary data structures (e.g., arrays, lists, hashmaps, etc.). Make sure to split the data such that subtasks have roughly the same amount of work and to execute subtasks in paral- lel. Sequential solutions will not receive any points. For this task, you do not need to handle exceptions. Parallele Programmierung - Semesterpr¨ufung - Seite 16 von 30 Mittwoch, 25.08.2021 public static void normFJ(double[] data) { ForkJoinPool fjp = new ForkJoinPool(); NormSquaredFJ normSquaredTask = new NormSquaredFJ(data, 0, data.length); double normSquared = fjp.invoke(normSquaredTask); NormVectorFJ normVecTask = new NormVectorFJ(data, normSquared, 0, data.length); fjp.invoke(normVecTask); } public class NormSquaredFJ extends .............................. { public static final int CUTOFF = 100; int start; int length; double[] input; public NormSquaredFJ(double[] input, int start, int length) { this.start = start; this.length = length; this.input = input; } protected Double compute() { if (this.length <= ...............) { // Berechnen Sie das Quadrat der Norm der Eingabe sequentiell. /* Compute the square of the norm of the input sequentially. */ ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. } else { // Verwenden Sie das Fork/Join Framework, um die Eingabe aufzuteilen und // das Quadrat der Norm parallel auf den verschiedenen Teilen zu berechnen. /* Use the Fork/Join Framework to split the input and compute the square of the norm in parallel on the different parts. */ ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. } } } Parallele Programmierung - Semesterpr¨ufung - Seite 17 von 30 Mittwoch, 25.08.2021 public class NormVectorFJ extends .............................. { public static final int CUTOFF = 100; int start; int length; double[] input; double norm; public NormVectorFJ(double[] input, int start, int length, double norm) { this.start = start; this.length = length; this.input = input; this.norm = norm; } protected void compute () { if (this.length <= ...............) { // Normalisieren Sie die Eingabe sequentiell. /* Normalize the input sequentially. */ ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. } else { // Teilen Sie die Eingabe auf und normalisieren Sie die // verschiedenen Teile parallel mit dem Fork/Join Framework. /* Split the input and normalize the different parts in parallel using the Fork/Join Framework. */ ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. } } } Parallele Programmierung - Semesterpr¨ufung - Seite 18 von 30 Mittwoch, 25.08.2021 (b) (2)Kreuzen Sie alle korrekten Aussagen an. Eine korrekte Antwort gibt einen Punkt. F¨ur eine falsche Antwort wird ein Punkt abgezogen. Check all correct statements. A correct answer gives one point. One point will be deducted for an incorrect answer. ⃝ Die Funktionen normFJ und NormSquaredFJ.compute() in der vor- hergehenden Aufgabe beschreiben eine “map”-Operation. The functions normFJ and NormSquaredFJ.compute() in the previous task describe a map opera- tion. ⃝ In der vorhergehenden Aufgabe beschreibt die Klasse NormVectorFJ eine “map”- Operation und NormSquaredFJ beschreibt eine “reduce”-Operation (Reduktion). In the previous task, the class NormVectorFJ describes a map opera- tion and the class NormSquaredFJ de- scribes a reduce (reduction) operation. ⃝ Die Funktionen normFJ und NormSquaredFJ.compute() in der vor- hergehenden Aufgabe beschreiben eine “reduce”-Operation (Reduktion). The functions normFJ and NormSquaredFJ.compute() in the previous task describe a reduce (reduction) operation. ⃝ Beide Frameworks, ForkJoin und Executor- Service, unterhalten eine Liste von laufen- den Threads, die f¨ur mehrere Tasks wieder- verwendet werden. Both, ForkJoin and ExecutorService, maintain a pool of threads that is reused for multiple tasks. Parallele Programmierung - Semesterpr¨ufung - Seite 19 von 30 Mittwoch, 25.08.2021 Locks (10 points) 6. (a) (6)Geben Sie eine Deﬁnition zu jeder der folgen- den Eigenschaften von Locks an: Give a deﬁnition for each of the following lock properties: Fair Deadlock Free Starvation Free (b) (2)Ist jedes Lock, welches starvation free und deadlock free ist auch fair? Geben Sie einen Beweis oder ein Gegenbeispiel an. Is every lock that is starvation free and deadlock free also fair? Give a proof or counter example. (c) (2)Ist jedes faire Lock auch starvation-free und deadlock-free? Geben Sie einen Beweis oder ein Gegenbeispiel an. Is every fair lock also starvation-free and deadlock free? Give a proof or counter example. Parallele Programmierung - Semesterpr¨ufung - Seite 20 von 30 Mittwoch, 25.08.2021 Linearizability (14 points) 7. (a) (3)Basierend auf der untenstehenden History H, schreiben Sie eine History H ∗ auf, welche die gleichen Events enth¨alt, complete und well- formed ist, aber nicht equivalent zu H. Based on the history H below, write down a history H ∗ which consists of the same events, is complete, well-formed, but not equivalent to H. 1 H := A q.enq(3) 2 B p.enq(4) 3 B p:void 4 B q.deq() 5 A q:void 6 B q:3 (b) (5)Markieren Sie alle wahren Aussagen Mark all true statements. ⃝ Alle linearisierbaren Historien sind sequen- tiell konsistent. All linearizable Histories are sequen- tially consistent. ⃝ Alle sequentiell konsistenten Historien sind linearisierbar. All sequentially consistent histories are linearizable. ⃝ Ein Code der data-races enth¨alt kann keine linearisierbare Historie erzeugen. A code which contains data-races can- not produce a linearizable history. ⃝ Jede mit synchronized annotierte Metho- de hat einen Linearisierungspunkt. Any method marked with synchronized has a linearization point. ⃝ Jede als Transaktion (in STM) ausgef¨uhrte Methode hat einen Linearisierungspunkt. Each method executed as a transaction (in STM) has a linearization point. ⃝ Eine linearisierbare Methode kann mehrere Linearisierungpunkte im Code aufweisen. A linearizable method might have mul- tiple linearization points in its code ⃝ Ein sequentiell konsistentes Speichermo- dell schreibt vor, dass alle Aktionen eines Threads in Program Order sichtbar werden. A sequentially consistent memory model enforces that all actions of a thread become visible in program or- der. Parallele Programmierung - Semesterpr¨ufung - Seite 21 von 30 Mittwoch, 25.08.2021 (c) (6)Markieren Sie alle wahren Aussagen fuer jede der folgenden Historien. Mark all true statements for each of the following histories. 1 A p.enq(3) 2 B p.enq(4) 3 B p:void 4 B p.deq() 5 A p:void 6 B p:3 ⃝ Wenn das Objekt p ein zu Beginn leerer Stack ist, ist die Historie linearisierbar. If the object p is an initially empty stack, the history is linearizable. ⃝ Wenn das Objekt p eine zu Beginn leere (FIFO) Queue ist, ist die Historie lineari- sierbar. If the object p is an initially empty (FIFO) queue, the history is lineariz- able. ⃝ Wenn das Objekt r ein mit null initialisier- tes Register ist, ist die Historie linearisier- bar. If the object r is a register initialized to zero, the history is linearizable. ⃝ Wenn das Objekt r ein mit null initialisier- tes Register ist, ist die Historie sequentiell konsistent. If the object r is a register initialized to zero, the history is sequentially consis- tent. ⃝ Wenn das Objekt r ein mit null initialisier- tes Register ist, ist die Historie linearisier- bar. If the object r is a register initialized to zero, the history is linearizable. ⃝ Wenn das Objekt r ein mit null initialisier- tes Register ist, ist die Historie sequentiell konsistent. If the object r is a register initialized to zero, the history is sequentially consis- tent. Parallele Programmierung - Semesterpr¨ufung - Seite 22 von 30 Mittwoch, 25.08.2021 Barriers and Semaphores (10 points) 8. (a) (5)Implementieren Sie eine Semaphore in Ja- va, nutzen Sie wait/notify um sicherzustel- len, dass Threads welche keinen Fortschritt machen k¨onnen, nicht unn¨otig CPU Zyklen verschwenden. Implement a Semaphore in Java. Use wait/notify to ensure threads which can- not make progress do not spin. 1 public class CountingSemaphore { 2 private int counter = 0; 3 4 public synchronized void acquire() throws InterruptedException { 5 ...................................................... 6 ...................................................... 7 ...................................................... 8 ...................................................... 9 ...................................................... 10 ...................................................... 11 ...................................................... 12 ...................................................... 13 ...................................................... 14 ...................................................... 15 } 16 17 public synchronized void release() throws InterruptedException { 18 ...................................................... 19 ...................................................... 20 ...................................................... 21 ...................................................... 22 ...................................................... 23 ...................................................... 24 ...................................................... 25 ...................................................... 26 ...................................................... 27 ...................................................... 28 } 29 } Parallele Programmierung - Semesterpr¨ufung - Seite 23 von 30 Mittwoch, 25.08.2021 (b) (5)Implementieren Sie einen wiederverwendba- ren Barrier mit Hilfe von Instanzen der oben (Teil a) implementierten Semaphore. Implement a reusable barrier using in- stances of the Semaphore implemented above (part a). 1 public class SemaphoreBarrier { 2 private int numThreads = 8; //your barrier expects this many threads 3 4 public synchronized void barrier() { 5 ...................................................... 6 ...................................................... 7 ...................................................... 8 ...................................................... 9 ...................................................... 10 ...................................................... 11 ...................................................... 12 ...................................................... 13 ...................................................... 14 ...................................................... 15 ...................................................... 16 ...................................................... 17 ...................................................... 18 ...................................................... 19 ...................................................... 20 } 21 22 } Parallele Programmierung - Semesterpr¨ufung - Seite 24 von 30 Mittwoch, 25.08.2021 Message passing (12 points) 9. (a) (6)Nutzen Sie die unten angegebenen MPI Funktionen um die Allreduce kollektive Ope- ration zu implementieren. Ihr Algorithmus darf nur k Schritte aufweisen um die Opera- tion f¨ur 2k Prozesse zu durchzuf¨uhren. Neh- men Sie an die Kommunikatorgr¨osse ist im- mer eine Zweierpotenz, veriﬁzieren Sie diese Annahme in ihrem Code. Use the MPI functions given below to implement the Allreduce collective op- eration. Your algorithm may only use k steps to perform the collective with 2k processes. Assume the communica- tor size is always a power of 2, but check this assumption in your code. // Signatures of MPI funtions to use: // MPI.COMM_WORLD.Rank(); // MPI.COMM_WORLD.Size(); // MPI.COMM_WORLD.Send(buf, offset, size, dtype, dest, tag); // MPI.COMM_WORLD.Recv(buf, offset, size, dtype, dest, tag); int MyAllreduce(int localInput) { ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... ....................................................................... return s; //sum of all localInput values } Parallele Programmierung - Semesterpr¨ufung - Seite 25 von 30 Mittwoch, 25.08.2021 (b) (3)Einer der Vorteile der Programmierung im distributed-memory Modell ist, dass data- races und Deadlocks leichter zu vermei- den sind als im shared-memory Paral- lelismus. Eliminiert Message Passing alle M¨oglichkeiten f¨ur Deadlocks? Erkl¨aren Sie warum oder geben Sie ein Gegenbeispiel an. One of the beneﬁts of distributed- memory programming is that data-races and deadlocks are easier to avoid than in shared-memory parallelism. Does message passing eliminate all deadlocks? Explain why or give a counter example. (c) (3)Sie haben die Gesetze von Amdahl und Gu- stafson kennen gelernt um die Laufzeit paral- leler Programme zu modellieren. Sp¨ater ha- ben Sie MPI kollektive Operationen gese- hen, deren Laufzeit von der Anzahl invol- vierter Prozesse abh¨angt. Sind die erw¨ahnten Modelle auf MPI Programme anwendbar? Warum (nicht)? You have seen the laws of Amdahl and Gustafson to model the runtime of par- allel programs. Later you saw collec- tive MPI operations whose runtime de- pends on the number of processes in- volved. Are the mentioned models ap- plicable to MPI programs? Why (not)? Parallele Programmierung - Semesterpr¨ufung - Seite 26 von 30 Mittwoch, 25.08.2021 Mixer (14 points) 10. (a) (4)Ist es m¨oglich ein korrektes Sortiernetzwerk f¨ur 2k Eingaben zu konstruieren, in welchem es zwischen Input k und Input k+1 nur einen Komperator gibt, und beliebig viele Kompe- ratoren zwischen anderen Paaren von Inputs? Geben Sie einen Beweis oder ein Gegenbei- spiel an. Is it possible to construct a sorting net- work for 2k inputs, in which there is only one comparator between input k and in- put k + 1, and any number of compara- tors between any other pair of inputs? Give a proof or counterexample. (b) (2)Was ist das ABA Problem? Erkl¨aren Sie mit Hilfe eines Beispiels. What is the ABA Problem? Explain us- ing an example. (c) (4)Beschreiben Sie zwei Techniken um das ABA Problem zu vermeiden. Zeigen Sie deren je- weilige Nachteile auf. Describe two techniques to avoid the ABA problem and point out their re- spective drawbacks. Parallele Programmierung - Semesterpr¨ufung - Seite 27 von 30 Mittwoch, 25.08.2021 (d) (4)Implementieren sie ein TATAS lock. Be- schreiben Sie den Vorteil eines TATAS lock, verglichen mit einem TAS lock. Implement a TATAS lock. Describe the advantage of a TATAS lock over a TAS lock. Parallele Programmierung - Semesterpr¨ufung - Seite 28 von 30 Mittwoch, 25.08.2021 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu ﬁnden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found. Parallele Programmierung - Semesterpr¨ufung - Seite 29 von 30 Mittwoch, 25.08.2021 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu ﬁnden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found. Parallele Programmierung - Semesterpr¨ufung - Seite 30 von 30 Mittwoch, 25.08.2021 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu ﬁnden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found.","libVersion":"0.3.2","langs":""}