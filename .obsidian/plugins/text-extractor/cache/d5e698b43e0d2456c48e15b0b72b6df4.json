{"path":"sem2/PProg/VRL/slides/PProg-L19-monitors.pdf","text":"spcl.inf.ethz.ch @spcl_eth TORSTEN HOEFLER Parallel Programming Producer-/Consumer, Monitors xkcd.org May 4, 2021 spcl.inf.ethz.ch @spcl_eth ▪ Locks & locks with atomics ▪ Atomics enable constant memory requirement (as opposed to O(N)) ▪ Requires atomic read-modify-write operations ▪ Simplest: TASlock Simple optimizations TATAS + exponential backoff ▪ Intro to (dead)locks ▪ What is a deadlock formally ▪ How to avoid it (global locking, non-overlapping locking, ordered locking) ▪ Rendezvous & barrier ▪ Semantics for large-scale synchronization ▪ Implementation pitfalls Last week 2 spcl.inf.ethz.ch @spcl_eth ▪ Producer/consumer queues ▪ Single ▪ Many ▪ Monitors ▪ Making object locks more powerful ▪ Wait/signal ▪ Reader/Writer locks ▪ And some more tricks and optimizations Learning goals today 3 spcl.inf.ethz.ch @spcl_eth Producer Consumer Pattern 4 spcl.inf.ethz.ch @spcl_eth T0 computes X and passes it to T1 T1 uses X Is synchronization for X needed? No because, at any point in time only one thread accesses X we, however, need a synchronized mechanism to pass X from T0 to T1 5 Producer / Consumer Pattern T1T0 Producer thread Consumer thread X spcl.inf.ethz.ch @spcl_eth Fundamental parallel programming pattern Can be used to build data-flow parallel programs E.g., pipelines: 6 Producer / Consumer Pattern T1T0 T2 both producer and consumer 30 billion (30 * 109) transistors, programmable at fine-grain! spcl.inf.ethz.ch @spcl_eth while (true) { input = q_in.dequeue(); output = do_something(input); q_out.enqueue(output) } 7 Pipeline Node T spcl.inf.ethz.ch @spcl_eth 8 Producer / Consumer queues – as a buffer q.enqueue(x1) q.enqueue(x2) ... q.dequeue() → x1 q.dequeue() → x2 ... Producer Consumer spcl.inf.ethz.ch @spcl_eth Queue 9 Multiple Producers and Consumers enqueue dequeue Producers Consumers P Q R C D spcl.inf.ethz.ch @spcl_eth 10 Bounded FIFO as Circular Buffer b[0] b[1] b[2] b[10] b[11] + wrap around semantics inout = spcl.inf.ethz.ch @spcl_eth 11 Producer / Consumer queue implementation a b c out = 4 in = 7 count = 3 a b c d out = 4in = 0 count = 4 e a b c d out = 4in = 1 count = 5 Enqueue d Enqueue e e a b c d out = 4in = 1 count = 5 Dequeue → a e a b c d out = 5in = 1 count = 4 spcl.inf.ethz.ch @spcl_eth class Queue { private int in; // next new element private int out; // next element private int size; // queue capacity private long[] buffer; Queue(int size) { this.size = size; in = out = 0; buffer = new long[size]; } private int next(int i) { return (i + 1) % size; } 12 Producer / Consumer queue implementation public synchronized void enqueue(long item) { buffer[in] = item; in = next(in); } public synchronized long dequeue() { item = buffer[out]; out = next(out); return item; } What if we try to 1. dequeue from an empty queue? 2. enqueue to a full queue? spcl.inf.ethz.ch @spcl_eth public void doEnqueue(long item) { buffer[in] = item; in = next(in); } public boolean isFull() { return (in+1) % size == out; } public long doDequeue() { long item = buffer[out]; out = next(out); return item; } public boolean isEmpty() { return in == out; } 13 Producer / Consumer queues: helper functions outin outin full: one element not usable. Still it has a benefit to not use a counter variable. Any idea what this benefit could be? spcl.inf.ethz.ch @spcl_eth public synchronized void enqueue(long item) { while (isFull()) ; // wait doEnqueue(item); } 14 Producer / Consumer queues → Blocks forever infinite loops with a lock held … public synchronized long dequeue() { while (isEmpty()) ; // wait return doDequeue(); } Do you see the problem? public void doEnqueue(long item) { buffer[in] = item; in = next(in); } public boolean isFull() { return (in+1) % size == out; } public long doDequeue() { long item = buffer[out]; out = next(out); return item; } public boolean isEmpty() { return in == out; } spcl.inf.ethz.ch @spcl_eth public void enqueue(long item) throws InterruptedException { while (true) { synchronized(this) { if (!isFull()) { doEnqueue(item); return; } } Thread.sleep(timeout); // sleep without lock! } } 15 Producer / Consumer queues using sleep() What is the proper value for the timeout? Ideally, we would like to be notified when the change happens! When is that? spcl.inf.ethz.ch @spcl_eth import java.util.concurrent.Semaphore; class Queue { int in, out, size; long buf[]; Semaphore nonEmpty, nonFull, manipulation; Queue(int s) { size = s; buf = new long[size]; in = out = 0; nonEmpty = new Semaphore(0); // use the counting feature of semaphores! nonFull = new Semaphore(size); // use the counting feature of semaphores! manipulation = new Semaphore(1); // binary semaphore } } 16 Producer / Consumer queues with semaphores spcl.inf.ethz.ch @spcl_eth void enqueue(long x) { try { manipulation.acquire(); nonFull.acquire(); buf[in] = x; in = (in+1) % size; } catch (InterruptedException ex) {} finally { manipulation.release(); nonEmpty.release(); } } long dequeue() { long x=0; try { manipulation.acquire(); nonEmpty.acquire(); x = buf[out]; out = (out+1) % size; } catch (InterruptedException ex) {} finally { manipulation.release(); nonFull.release(); } return x; } 17 Producer / Consumer queues with semaphores, correct? Do you see the problem? spcl.inf.ethz.ch @spcl_eth 18 Deadlock (nearly the same as before, actually)! Consumer Producer manipulationnonEmpty owned byrequires owned by requires spcl.inf.ethz.ch @spcl_eth void enqueue(long x) { try { nonFull.acquire(); manipulation.acquire(); buf[in] = x; in = next(in); } catch (InterruptedException ex) {} finally { manipulation.release(); nonEmpty.release(); } } long dequeue() { long x=0; try { nonEmpty.acquire(); manipulation.acquire(); x = buf[out]; out = next(out); } catch (InterruptedException ex) {} finally { manipulation.release(); nonFull.release(); } return x; } 19 Producer / Consumer queues with semaphores In practice, some issue with interrupts remains spcl.inf.ethz.ch @spcl_eth Semaphores are unstructured. Correct use requires high level of discipline. Easy to introduce deadlocks with semaphores. We need: a lock that we can temporarily escape from when waiting on a condition. 20 Why are semaphores (and locks) problematic? spcl.inf.ethz.ch @spcl_eth Monitors 21 spcl.inf.ethz.ch @spcl_eth Monitor: abstract data structure equipped with a set of operations that run in mutual exclusion. Invented by Tony Hoare and Per Brinch Hansen (cf. Monitors: An Operating System Structuring Concept, Tony Hoare, 1974) 22 Monitors Tony Hoare (1934-today) Per Brinch Hansen (1938-2007) spcl.inf.ethz.ch @spcl_eth 23 Monitors vs. Semaphores/Unbound Locks shared shared Code monitor monitor spcl.inf.ethz.ch @spcl_eth public void synchronized enqueue(long item) { \"while (isFull()) wait\" doEnqueue(item); } 24 Producer / Consumer queues The mutual exclusion part is nicely available already. But: while the buffer is full we need to give up the lock, how? public long synchronized dequeue() { \"while (isEmpty()) wait\" return doDequeue(); } spcl.inf.ethz.ch @spcl_eth Monitors provide, in addition to mutual exclusion, a mechanism to check conditions with the following semantics: If a condition does not hold ▪ Release the monitor lock ▪ Wait for the condition to become true ▪ Signaling mechanism to avoid busy-loops (spinning) 25 Monitors spcl.inf.ethz.ch @spcl_eth Uses the intrinsic lock (synchronized) of an object + wait / notify / notifyAll: wait() – the current thread waits until it is signaled (via notify) notify() – wakes up one waiting thread (an arbitrary one) notifyAll() – wakes up all waiting threads 26 Monitors in Java spcl.inf.ethz.ch @spcl_eth class Queue { int in, out, size; long buf[]; Queue(int s) { size = s; buf = new long[size]; in = out = 0; } ... } 27 Producer / Consumer with monitor in Java spcl.inf.ethz.ch @spcl_eth synchronized void enqueue(long x) { while (isFull()) try { wait(); } catch (InterruptedException e) { } doEnqueue(x); notifyAll(); } 28 Producer / Consumer with monitor in Java synchronized long dequeue() { long x; while (isEmpty()) try { wait(); } catch (InterruptedException e) { } x = doDequeue(); notifyAll(); return x; } (Why) can't we use notify()? Wouldn't an if be sufficient? spcl.inf.ethz.ch @spcl_eth IMPORTANT TO KNOW JAVA MONITOR IMPLEMENTATION DETAILS 29 spcl.inf.ethz.ch @spcl_eth 30 Thread States in Java thread has not yet started thread is runnable, may or may not be currently scheduled by the OS thread is waiting for entry to monitor lock thread is waiting for a condition or a join waiting state with specified waiting time, e.g,. sleep notify notifyAll join/ wait monitor obtained monitor not yet free TERMINATED NEW TIMED_WAIT WAITING BLOCKED thread has finished execution RUNNABLE spcl.inf.ethz.ch @spcl_eth waiting entry waiting condition 31 Monitor Queues monitor method call notification wait spcl.inf.ethz.ch @spcl_eth Important to know for the programmer (you): what happens upon notification? Priorities? 1) signal and wait signaling process exits the monitor (goes to waiting entry queue) signaling process passes monitor lock to signaled process 2) signal and continue signaling process continues running signaling process moves signaled process to waiting entry queue other semantics: signal and exit, signal and urgent wait … 32 Various (exact) semantics possible spcl.inf.ethz.ch @spcl_eth class Semaphore { int number = 1; // number of threads allowed in critical section synchronized void acquire() { if (number <= 0) try { wait(); } catch (InterruptedException e) { }; number--; } synchronized void release() { number++; if (number > 0) notify(); } } 33 Why is this important? Let's try implementing a semaphore: Looks good, doesn't it? But there is a problem. Do you know which? spcl.inf.ethz.ch @spcl_eth synchronized void acquire() { if (number <= 0) try { wait(); } catch (InterruptedException e) { }; number--; } synchronized void release() { number++; if (number > 0) notify(); } Scenario: 1. Process P has previously acquired the semaphore and decreased number to 0. 2. Process Q sees number = 0 and goes to waiting list. 3. P is executing release. In this moment process R wants to enter the monitor via method acquire. 4. P signals Q and thus moves it into wait entry list (signal and continue!). P exits the function/lock. 5. R gets entry to monitor before Q and sees the number = 1 6. Q continues execution with number = 0! Inconsistency! 34 Java Monitors = signal + continue P Q R spcl.inf.ethz.ch @spcl_eth synchronized void acquire() { while (number <= 0) try { wait(); } catch (InterruptedException e) { }; number--; } 35 The cure – a while loop. synchronized void release() { number++; if (number > 0) notify(); } If, additionally, different threads evaluate different conditions, the notification has to be a notifyAll. In this example it is not required. spcl.inf.ethz.ch @spcl_eth Intrinsic locks (\"synchronized\") with objects provide a good abstraction and should be first choice Limitations ▪ one implicit lock per object ▪ are forced to be used in blocks ▪ limited flexibility Java offers the Lock interface for more flexibility (e.g., lock can be polled). 37 Something different: Java Interface Lock final Lock lock = new ReentrantLock(); spcl.inf.ethz.ch @spcl_eth Java Locks provide conditions that can be instantiated Java conditions offer .await() – the current thread waits until condition is signaled .signal() – wakes up one thread waiting on this condition .signalAll() – wakes up all threads waiting on this condition 38 Condition interface Condition notFull = lock.newCondition(); spcl.inf.ethz.ch @spcl_eth → Conditions are always associated with a lock lock.newCondition() .await() – called with the lock held – atomically releases the lock and waits until thread is signaled – When it returns, it is guaranteed to hold the lock – thread always needs to check condition .signal{,All}() – wakes up one (all) waiting thread(s) – called with the lock held 39 Condition interface","libVersion":"0.3.2","langs":""}