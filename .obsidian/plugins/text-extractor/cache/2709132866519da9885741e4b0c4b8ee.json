{"path":"HS23/DMath/UE/s/DMath-u11-s.pdf","text":"ETH Z ¨urich, D-INFK HS 2023, 8. December 2023 Prof. Ueli Maurer Giovanni Deligios Diskrete Mathematik Solution 11 11.1 Error-Correcting Codes a) Let c1, c2 ∈ C with c1 ̸= c2 be arbitrary. Since C forms a group, we know that c = c1 + (−c2) ∈ C. We have d(c1, c2) = hw(c1 + (−c2)) = hw(c) ≥ 2t + 1. In the ﬁrst step, we have used that two codewords differ at a position if and only if the difference of their values at this position is non-zero. In the last step, we have used the assumption from above, together with the fact that c1 ̸= c2 implies c ̸= 0n. Thus, we have dmin(C) ≥ 2t + 1, which implies by Theorem 5.41 that C is t-error correcting. b) Let c ∈ C be arbitrary. Moreover, let cmin ∈ C \\ {0n} be such that hw(cmin) = 2t + 1. Since C forms a group, we have c + cmin ∈ C. Observe that d(c, c + cmin) = hw(cmin) = 2t + 1. Thus, c and c + cmin differ on exactly 2t + 1 = (t + 1) + t positions. We can therefore change the ﬁrst t + 1 of these positions of c to the ones of c + cmin to obtain a word w with d(c, w) = t + 1 and d(c + cmin, w) = t. This word w cannot be error-corrected. Since c ∈ C was arbitrary, there exists no codeword such that up to t + 1 arbitrary errors can be corrected. 11.2 Proof Systems (⋆ ⋆) a) We prove the claim constructively. Let S and P be non-empty sets and let φ : S ×P → {0, 1} be an arbitrary function. Consider the function τ : S → {0, 1} deﬁned by τ (s) = 1 def ⇐⇒ there exists p ∈ P such that φ(s, p) = 1. The proof system Π = (S, P, τ, φ) is sound: For any s ∈ S and any p ∈ P with φ(s, p) = 1, the deﬁnition of τ implies that τ (s) = 1. Moreover, Π is complete: For any s ∈ S with τ (s) = 1, the deﬁnition of τ implies that there exists p ∈ P such that φ(s, p) = 1. It is left to show that τ is unique. Consider any function τ ′ : S → {0, 1} such that τ ̸= τ ′. This is implies that τ (s) ̸= τ ′(s) for some s ∈ S. Case distinction: • τ (s) = 0 and τ ′(s) = 1. By deﬁnition of τ , τ (s) = 0 implies there exists no p ∈ P such that φ(s, p) = 1. But since τ ′(s) = 1, the proof system (S, P, τ ′, φ) cannot be complete. • τ (s) = 1 and τ ′(s) = 0. By deﬁnition of τ , τ (s) = 1 implies there exists p ∈ P such that φ(s, p) = 1. But since τ ′(s) = 0, the proof system (S, P, τ ′, φ) cannot be sound. b) (i) We prove the claim indirectly. Assume that neither Π1 nor Π2 is sound. Then there exist s1 ∈ S1 and p1 ∈ P1 such that τ1(s1) = 0 and φ1(s1, p1) = 1, and there exist s2 ∈ S2 and p2 ∈ P2 such that τ2(s2) = 0 and φ2(s2, p2) = 1. Thus, we have τ3(s1, s2) = 0 but φ3((s1, s2), (p1, p2)) = 1. Hence, Π3 is not sound. (ii) We disprove the claim by giving a counterexample. Let S1 = S2 = {0} and P1 = P2 = {0}. We deﬁne τ1(0) = 0, φ1(0, 0) = 0, τ2(0) = 1, and φ2(0, 0) = 0. Clearly Π1 = (S1, P1, τ1, φ1) is complete. However, τ3(0, 0) = 1 since τ2(0) = 1, but φ3((0, 0), (p1, p2)) = 0 for all (p1, p2) ∈ P1 × P2 = {(0, 0)}. Thus, Π3 is not complete. 11.3 Difﬁe-Hellman Proof System A proof of a statement (yA, yB, kAB) will be the discrete logarithm xA of yA. Formally, P = Zn and φ((yA, yB, kAB), xA) = 1 if and only if gxA = yA and yxA B = kAB. Completeness: Assume τ ((yA, yB, kAB)) = 1. There exist unique xA, xB ∈ Zn (the secret keys chosen by Alice and Bob) such that gxA = yA and gxB = yB. Since the statement is true, we also have kAB = gxAxB = yxA B . Hence, for this xA we have φ((yA, yB, kAB), xA) = 1. Soundness: Assume φ((yA, yB, kAB), x′ A) = 1. Let xB ∈ Zn be (unique) such that gxB = yB. The veriﬁcation φ guarantees that kAB = yx′ A B = gx′ AxB and gx′ A = yA and x′ A ∈ Zn. Hence, kAB is the secret key resulting from the Difﬁe-Hellman protocol where Alice chooses x′ A and Bob chooses xB. 11.4 One More Proof System a) The statement is false: we provide a counterexample. Let S = {s} and P = ∅. Deﬁne τ (s) = 0. The system Σ is sound, because there is no p ∈ P such that φ(s, p) = 1. However, the proof system Σ is not complete: the statement s is true in Σ because τ (s) = 1 but there is not proof p ∈ P such that φ(s, p) = 1. Remark: the statement is true if one assumes P ̸= ∅. A possible proof is as follows. Assume that Σ is sound. This is equivalent to: for all s ∈ S, τ (s) = 0 =⇒ φ(s, p) = 0 for all p ∈ P. (1) To prove that Σ is complete, suppose that τ (s) = 1 for some s ∈ S. We have τ (s) = 1 ⇐⇒ τ (s) = 0 =⇒ φ(s, p) = 0 for all p ∈ P (Equation (1)) =⇒ φ(s, p) = 0 for some p ∈ P (P ̸= ∅ ⇒ ∀xP (x) |= ∃xP (x)) ⇐⇒ φ(s, p) = 1 for some p ∈ P. (2) This proves the completness of Σ′. b) The statement is false: we provide a counterexample. Let S = {s} and P = {p, q}. Deﬁne τ (s) = 1, φ(s, p) = 1, and φ(s, q) = 0. It is clear that Σ is complete, because p is a valid proof for the only true statement s ∈ Σ. However, the proof system Σ is not sound: we have τ (s) = 0 but φ(s, q) = 1, or in other words q is a valid proof for the false statement s ∈ Σ. y c) Let A be the proposition “Abe comes to the party”, etc. The conditions given in the exercise correspond to the following implications: A → B (3) B → C (4) C → D (5) (B ∧ D) → ¬C (6) D → (A ∨ B) (7) We show that no one would arrive at the party and, hence, Homer eventually ends up at Moe’s whether he organizes it or not. For each person, consider what happens when he comes to the party: i. A is true. In this case, B is true by formula (3), C is true by formula (4), D is true by formula (5) and ¬C is true by formula (6), which is a contradiction with C. Hence, A is false. ii. B is true. In this case, again, C is true by formula (4), D is true by formula (5) and ¬C is true by formula (6), which is a contradiction with C. Hence, B is false. iii. C is true. In this case, D is true by formula (5) and A ∨ B is true by formula (7). But both the assumption that A is true and the assumption that B is true lead to a contradiction, as shown in cases i. and ii. Hence, A ∨ B also leads to a contradiction and C is false. iv. D is true. In this case, A ∨ B is true by formula (7). By the same argument as above, D is false. Overall, we can conclude that no one can come to the party. That is, all the formulas are true only if A, B, C and D are all false. d) We now formally derive ¬A, ¬B, ¬C and ¬D, using given derivation rules: {(5) , (1)} ⊢R3 D → B (6) {(6) , (2)} ⊢R1 D → C (7) {(6)} ⊢R4 D → (B ∧ D) (8) {(8) , (4)} ⊢R1 D → ¬C (9) {(7) , (9)} ⊢R2 ¬D (10) {(3) , (10)} ⊢R5 ¬C (11) {(2) , (11)} ⊢R5 ¬B (12) {(1) , (12)} ⊢R5 ¬A (13) 11.5 Models and Satisﬁability a) Consider the function table of F : A B C ¬A ∨ B ¬C ∧ ¬A B → (¬C ∧ ¬A) A ∨ C F 0 0 0 1 1 1 0 0 0 0 1 1 0 1 1 1 0 1 0 1 1 1 0 0 0 1 1 1 0 0 1 0 1 0 0 0 0 1 1 0 1 0 1 0 0 1 1 0 1 1 0 1 0 0 1 0 1 1 1 1 0 0 1 0 The set of models for F contains all truth assignments A, such that A(A) = A(B) = 0 and A(C) = 1. Consider now the function table of G: A B C ¬(A → B) C → A G 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 1 1 0 1 1 0 0 0 1 0 0 1 1 1 1 0 1 1 1 1 1 1 0 0 1 1 1 1 1 0 1 1 The set of models for G contains all truth assignments A, such that A(A) = 1 and all truth assignments A, such that A(C) = 0. The formulas are not equivalent, since the sets are not the same. G is not the conse- quence of F , because the set of models for F is not a subset of the set of models for G. Similarly F is not a consequence of G. b) The statement is false. A counterexample is F = A ∨ ¬A and G = B ∨ ¬B. Of course, F and G have no common atomic formulas. However, by Lemma 6.1 11), A ∨ ¬A ≡ ⊤ ≡ B ∨ ¬B. c) The statement is false. A counterexample in propositional logic is F1 = A and F2 = A ∧ ¬A. F1 and F1 → F2 are both satisﬁable (F1 → F2 is true for all interpretations A that assign A(F1) = 0). However, F2 is clearly not satisﬁable. 11.6 Satisﬁability a) The set M is not satisﬁable. To show this, assume that A is a model for M . Since ¬A ∈ M , we have A(¬A) = 1 and thus A(A) = 0. Moreover, we have B ∧ C ∈ M , and therefore A(B ∧ C) = 1, which implies that A(C) = 1. Since ¬A → ¬C ∈ M , we also have A(¬A → ¬C) = 1, so A(¬¬A ∨ ¬C) = A(A ∨ ¬C) = 1, which implies A(A) = 1 or A(C) = 0. This is a contradiction to A(A) = 0 and A(C) = 1. b) A model for N is, for example, the truth assignment A : {A1, A2, . . .} → {0, 1} that assigns A(A1) = 1 and A(Ai) = 0 for i > 1. (One could interpret the statement Ai as “i is less or equal to 1”, for i ∈ N.)","libVersion":"0.3.2","langs":""}