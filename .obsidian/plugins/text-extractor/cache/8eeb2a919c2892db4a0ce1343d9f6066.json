{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s09-formal-methods.pdf","text":"Formal Methods and Functional Programming Introduction to Part II Peter M¨uller Programming Methodology Group ETH Zurich Organization Most aspects do not change (lecture times, web page, homework) Some exercise session have different TAs. Please attend the same exercise session. Tuesday 14–16, Johannes Hostert (German, CAB G52) Tuesday 16–18, Jo˜ao Carlos Mendes Pereira (English, ETZ F91) Tuesday 16–18, Ramon Wick (German, ETZ G91) Wednesday 8–10, Paul Ellsiepen (German, CAB G52) Wednesday 8–10, Johannes Hostert (English, ETZ F91) Wednesday 8–10, Sarp S¨umer (English, HG E33.5) Wednesday 8–10, Robin Ebersberger (German, LEE C114) Wednesday 16–18, Jon´aˇs Fiala (English, CHN D42) Wednesday 16–18, Nicolas Klose (German, CHN F46) Wednesday 16–18, Thibault Dardinier (English, HG G26.5) Exercise sessions start next week! For all organizational issues, please email anqi.li@inf.ethz.ch David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 2 Homework and Exam Homework Two types: (Highly) recommended and optional Recommended homework can be submitted in the exercise sessions, submission by email possible in exceptional circumstances only Your submission is corrected and returned in the following exercise session The exam will take place in the exam session See web page for details (coming soon) Please check the course website regularly for announcements https://www.infsec.ethz.ch/education/ss2025/fmfp David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 3 Second Quiz Similar arrangements to the first quiz: The quiz will be conducted in person. The quiz will take place on Tuesday, May 13th from 10:15 to 10:45. There will be a normal lecture from 11:10 onwards. The quiz will be on material from the second half of the course. Again, check the course website for any updates: https://www.infsec.ethz.ch/education/ss2025/fmfp David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 4 Recommended Books Hanne Riis Nielson and Flemming Nielson: Semantics with Applications: A Formal Introduction Available from www.cs.ru.nl/~herman/onderwijs/semantics2019/wiley.pdf Christel Baier and Joost-Pieter Katoen: Principles of Model Checking David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 5 Traditional Software Engineering Describes expected behavior and design using natural language or semi-formal notations Requirements and design documents typically are incomplete and contain ambiguities and contradictions Informal and semi-formal documents are not amenable to automatic analysis Relies on reviews and testing to ensure quality Reviews are helpful, but many flaws in complex artifacts remain undetected Exhaustive testing possible only for trivial programs Some errors are hard to find and reproduce (e.g., concurrency errors, security vulnerabilities, environment conditions) Testing can show the presence of errors, but not their absence. [E. Dijkstra] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 6 Alternative: Formal Methods Formal methods are mathematical approaches to software and system development which support the rigorous specification, design, and verification of computer systems. [FME] Programs, programming languages, designs, etc. are mathematical objects and can be treated by mathematical methods Examples from Part I of the course: Proving program properties ∀xs, ys, zs.(xs ++ ys) ++ zs = xs ++ (ys ++ zs) Formalizing language semantics (λx.t)t ′ ↪ t[x ← t ′] Proving language properties If t ↪ t ′ and A ⊢ t ∶∶ τ then A ⊢ t ′ ∶∶ τ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 7 Example 1: Sorting Function void sort(int[] input) Informal specification: Method sort sorts the elements of input in ascending order Testing sort({}) → {} ! sort({2}) → {2} ! sort({2,3,1}) → {1,2,3} ! sort({2,2,1}) → {1,2,1} % sort(null) → % David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 8 Example 1: Sorting Function void sort(int[] input) Informal specification: Method sort sorts the elements of input in ascending order Testing sort({}) → {} ! sort({2}) → {2} ! sort({2,3,1}) → {1,2,3} ! sort({2,2,1}) → {1,2,1} % sort(null) → % David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 8 Example 1: Sorting Function void sort(int[] input) Informal specification: Method sort sorts the elements of input in ascending order Testing sort({}) → {} ! sort({2}) → {2} ! sort({2,3,1}) → {1,2,3} ! sort({2,2,1}) → {1,2,1} % sort(null) → % David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 8 Example 1: Sorting Function void sort(int[] input) Informal specification: Method sort sorts the elements of input in ascending order Testing sort({}) → {} ! sort({2}) → {2} ! sort({2,3,1}) → {1,2,3} ! sort({2,2,1}) → {1,2,1} % sort(null) → % David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 8 Example 1: Sorting Function void sort(int[] input) Informal specification: Method sort sorts the elements of input in ascending order Testing sort({}) → {} ! sort({2}) → {2} ! sort({2,3,1}) → {1,2,3} ! sort({2,2,1}) → {1,2,1} % sort(null) → % David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 8 Example 1: Sorting Function void sort(int[] input) Informal specification: Method sort sorts the elements of input in ascending order Testing sort({}) → {} ! sort({2}) → {2} ! sort({2,3,1}) → {1,2,3} ! sort({2,2,1}) → {1,2,1} % sort(null) → % David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 8 Example 1: Sorting Function—Formal Treatment Specification Pre and postcondition in predicate logic (contract) If a is a non-null array of integers and in the state before a call sort(a), the elements of a are e0 . . . en, then the call terminates and immediately after the call, the elements of a, e′ 0 . . . e′ n, are a permutation of e0 . . . en and ∀i, j ∈ [0, n].i < j ⇒ e′ i ≤ e′ j . Verification Prove that sort satisfies its specification using a formal semantics of the programming language Observations Specification permits duplicate elements in array: Test sort({2,2,1}) reveals error in implementation Specification excludes null from the valid arguments to sort: Test sort(null) is an invalid test case Correctness proof covers all valid inputs, not just selected test cases David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 9 Example 1: Sorting Function—Formal Treatment Specification Pre and postcondition in predicate logic (contract) If a is a non-null array of integers and in the state before a call sort(a), the elements of a are e0 . . . en, then the call terminates and immediately after the call, the elements of a, e′ 0 . . . e′ n, are a permutation of e0 . . . en and ∀i, j ∈ [0, n].i < j ⇒ e′ i ≤ e′ j . Verification Prove that sort satisfies its specification using a formal semantics of the programming language Observations Specification permits duplicate elements in array: Test sort({2,2,1}) reveals error in implementation Specification excludes null from the valid arguments to sort: Test sort(null) is an invalid test case Correctness proof covers all valid inputs, not just selected test cases David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 9 Example 1: Sorting Function—Formal Treatment Specification Pre and postcondition in predicate logic (contract) If a is a non-null array of integers and in the state before a call sort(a), the elements of a are e0 . . . en, then the call terminates and immediately after the call, the elements of a, e′ 0 . . . e′ n, are a permutation of e0 . . . en and ∀i, j ∈ [0, n].i < j ⇒ e′ i ≤ e′ j . Verification Prove that sort satisfies its specification using a formal semantics of the programming language Observations Specification permits duplicate elements in array: Test sort({2,2,1}) reveals error in implementation Specification excludes null from the valid arguments to sort: Test sort(null) is an invalid test case Correctness proof covers all valid inputs, not just selected test cases David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 9 Example 1: Sorting Function—TimSort TimSort is the default sorting algorithm for Collections in Sun’s JDK, OpenJDK, and Android SDK Certain large arrays (≥ 67M) lead to index-out-of-bounds errors Bug was detected during a verification attempt Previous attempts to fix related errors were ineffective David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 10 Example 2: Zune Bug Zune 30 did not work on Dec. 31, 2008 Official fix: drain battery and recharge after midday on Jan. 01, 2009 //-------------------------- // Split total days since // Jan. 01, ORIGINYEAR // into year, month and day //-------------------------- BOOL ConvertDays(UINT32 days, ...) { int year = ORIGINYEAR; /* =1980 */ while (days > 365) { if (IsLeapYear(year)) { if (days > 366) { days -= 366; year += 1; } } else { days -= 365; year += 1; } } ... } David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 11 Example 2: Zune Bug—Formal Treatment Prove termination formally Repetition: Sufficient condition for termination of recursive functions: Arguments are smaller along a well-founded order Similar technique for loops Zune example: Termination measure: variable days Well-founded order: < with lower bound 365 (loop condition) Error: measure not decreased if IsLeapYear(year) and days==366 while (days > 365) { if (IsLeapYear(year)) { if (days > 366) { days -= 366; year += 1; } } else { days -= 365; year += 1; } } David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 12 Example 3: Deadlock Threads are synchronized via locks Interleaved execution of a.transfer(b,n) and b.transfer(a,m) might deadlock Multi-threaded programs are extremely hard to test class Account { int balance; void transfer(Account to, int amount) { acquire this; acquire to; this.balance -= amount; to.balance += amount; release this; release to; } } David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 13 Example 3: Deadlock—Formal Treatment (1) Prevent deadlocks by acquiring locks in ascending order Prove absence of deadlocks by: Defining an order on locks Proving for each acquire o that o is above all other locks held by the current thread class Account { int balance; int number; // unique account number void transfer(Account to, int amount) { if (this.number < to.number) { acquire this; acquire to; } else { acquire to; acquire this; } this.balance -= amount; to.balance += amount; release this; release to; } } David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 14 Example 3: Deadlock—Formal Treatment (2) Alternative approach: state space exploration Enumerate all possible states of a system Check properties on the states and their transitions Absence of deadlock: check for each state that there is a way to reach the terminal state Main problem: size of state space Explore abstractions of real program (here, balance does not matter) Explore state space for limited executions Small number of threads (here, two are sufficient) Small number of objects (here, two are sufficient) Small number of context switches (here, one is sufficient) State space exploration typically gives weaker correctness guarantee Similar to testing Very effective in practice David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 15 Example 3: Deadlock—Formal Treatment (2) Alternative approach: state space exploration Enumerate all possible states of a system Check properties on the states and their transitions Absence of deadlock: check for each state that there is a way to reach the terminal state Main problem: size of state space Explore abstractions of real program (here, balance does not matter) Explore state space for limited executions Small number of threads (here, two are sufficient) Small number of objects (here, two are sufficient) Small number of context switches (here, one is sufficient) State space exploration typically gives weaker correctness guarantee Similar to testing Very effective in practice David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 15 Example 3: Deadlock—Formal Treatment (2) Alternative approach: state space exploration Enumerate all possible states of a system Check properties on the states and their transitions Absence of deadlock: check for each state that there is a way to reach the terminal state Main problem: size of state space Explore abstractions of real program (here, balance does not matter) Explore state space for limited executions Small number of threads (here, two are sufficient) Small number of objects (here, two are sufficient) Small number of context switches (here, one is sufficient) State space exploration typically gives weaker correctness guarantee Similar to testing Very effective in practice David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 15 Example 4: Needham-Schroeder Protocol Establish a common secret over an insecure channel 1. Alice sends random number NA to Bob, encrypted with Bob’s public key: ⟨A, NA⟩B 2. Bob sends random number NB to Alice, encrypted with Alice’s public key: ⟨NA, NB ⟩A 3. Alice responds with ⟨NB ⟩B Intruders may: Intercept, store, and replay messages Initiate or participate in runs of the protocol Decrypt messages only if encrypted with intruder’s public key Error: intruder can pretend to be another party David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 16 Example 4: Needham-Schroeder Protocol— Formal Treatment State space exploration: enumerate protocol runs Develop formal model of intruder as non-deterministic program Simplifications: two agents, one intruder with limited memory Check whether there is a protocol run such that agent believes to talk to other agent, but in fact talks to intruder Error was found this way 17 years after protocol was published David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 17 Observations Specification—use mathematical notations to describe: System design to accomplish these requirements (e.g., program code) Requirements for the system (desired properties, e.g., deadlock freedom) Assumptions about the environment (e.g., intruder model) Verification—use formal logic to: Validate specifications by checking consistency Example: termination measure uses well-founded order Prove that design satisfies requirements under given assumptions Example: code does not deadlock Deductive (proof system) or algorithmic (state space exploration, model checking) Tool support Proofs are often simple, but long and tedious (unlike in mathematics) Tools needed to check details, e.g., theorem provers and model checkers David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 18 Observations Specification—use mathematical notations to describe: System design to accomplish these requirements (e.g., program code) Requirements for the system (desired properties, e.g., deadlock freedom) Assumptions about the environment (e.g., intruder model) Verification—use formal logic to: Validate specifications by checking consistency Example: termination measure uses well-founded order Prove that design satisfies requirements under given assumptions Example: code does not deadlock Deductive (proof system) or algorithmic (state space exploration, model checking) Tool support Proofs are often simple, but long and tedious (unlike in mathematics) Tools needed to check details, e.g., theorem provers and model checkers David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 18 Observations Specification—use mathematical notations to describe: System design to accomplish these requirements (e.g., program code) Requirements for the system (desired properties, e.g., deadlock freedom) Assumptions about the environment (e.g., intruder model) Verification—use formal logic to: Validate specifications by checking consistency Example: termination measure uses well-founded order Prove that design satisfies requirements under given assumptions Example: code does not deadlock Deductive (proof system) or algorithmic (state space exploration, model checking) Tool support Proofs are often simple, but long and tedious (unlike in mathematics) Tools needed to check details, e.g., theorem provers and model checkers David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 18 Benefits of Formal Methods Strong guarantees Detect faults with greater certainty than testing Provide guarantees for all inputs, thread schedules, environments, etc. Unambiguous communication and documentation Many practical applications Verification of CPU designs Analysis of safety-critical software such as flight controllers Detection of security vulnerabilities such as buffer overruns Enforcement of API usage protocols, e.g., for device drivers Analysis of security protocols such as TLS Verification of system implementations such as operating systems David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 19 Benefits of Formal Methods Strong guarantees Detect faults with greater certainty than testing Provide guarantees for all inputs, thread schedules, environments, etc. Unambiguous communication and documentation Many practical applications Verification of CPU designs Analysis of safety-critical software such as flight controllers Detection of security vulnerabilities such as buffer overruns Enforcement of API usage protocols, e.g., for device drivers Analysis of security protocols such as TLS Verification of system implementations such as operating systems David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 19 Limitations Incorrect specifications Formal methods per se do not guarantee correctness Verifying the wrong specification is useless It is difficult to get specifications right Technical limitations Almost all interesting properties are undecidable, in general Many tools quickly reach limits (scope, computing resources) Many applications of formal methods require specialist users Strong background in mathematics / training in formal modeling Some tools try to hide this complexity from users (research topic) Application of formal methods is expensive But testing is expensive, too David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 20 Formal Methods and Testing Formal methods and testing complement each other Testing still necessary Validate specifications Test properties not formally proven (e.g., performance) Detect errors in environment (e.g., compiler) Formal methods aid testing Derive test cases, test data, and test oracles from specifications Increase test coverage Replace (infinitely) many tests David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 21 Formal Methods and Testing Formal methods and testing complement each other Testing still necessary Validate specifications Test properties not formally proven (e.g., performance) Detect errors in environment (e.g., compiler) Formal methods aid testing Derive test cases, test data, and test oracles from specifications Increase test coverage Replace (infinitely) many tests David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 21 Formal Methods and Testing Formal methods and testing complement each other Testing still necessary Validate specifications Test properties not formally proven (e.g., performance) Detect errors in environment (e.g., compiler) Formal methods aid testing Derive test cases, test data, and test oracles from specifications Increase test coverage Replace (infinitely) many tests David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 21 Course Outline—Part II Focus: formal methods for (stateful) software Imperative programs and languages Software designs 1. Formal semantics of imperative programming languages Operational semantics Axiomatic semantics (Hoare logic) 2. Modeling and state space exploration techniques Constructing models of software designs Temporal logic and model checking David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 22 C: Expression Evaluation int print(char* text) { printf(\"%s\\n\", text); return 5; } print(\"One\")+print(\"Two\"); David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 23 C: Expression Evaluation int print(char* text) { printf(\"%s\\n\", text); return 5; } print(\"One\")+print(\"Two\"); One Two Two One In C and C++, evaluation order of expressions is unspecified Precedence and associativity define rules for structuring expressions But do not define operand evaluation order David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 23 Haskell and SML: Evaluation Haskell const :: Int -> Int const x = 1 const ( 2 ’div’ 0 ) SML fun const (x: int):int = 1; const ( 2 div 0 ); uncaught exception divide by zero Haskell uses lazy evaluation: Arguments are evaluated when they are needed SML uses eager evaluation: Arguments are evaluated when function is applied David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 24 Haskell and SML: Evaluation Haskell const :: Int -> Int const x = 1 const ( 2 ’div’ 0 ) 1 SML fun const (x: int):int = 1; const ( 2 div 0 ); uncaught exception divide by zero Haskell uses lazy evaluation: Arguments are evaluated when they are needed SML uses eager evaluation: Arguments are evaluated when function is applied David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 24 Java: Dynamic Method Binding class C1 { int x = 5; public void inc1( ) { inc2( ); } private void inc2( ) { x++; } } class CS1 extends C1 { public void inc2( ) { inc1( ); } } CS1 cs = new CS1(); cs.inc2( ); System.out.println(cs.x); class C2 { int x = 5; public void inc1( ) { inc2( ); } protected void inc2( ) { x++; } } class CS2 extends C2 { public void inc2( ) { inc1( ); } } CS2 cs = new CS2(); cs.inc2( ); System.out.println(cs.x); David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 25 Java: Dynamic Method Binding class C1 { int x = 5; public void inc1( ) { inc2( ); } private void inc2( ) { x++; } } class CS1 extends C1 { public void inc2( ) { inc1( ); } } CS1 cs = new CS1(); cs.inc2( ); System.out.println(cs.x); class C2 { int x = 5; public void inc1( ) { inc2( ); } protected void inc2( ) { x++; } } class CS2 extends C2 { public void inc2( ) { inc1( ); } } CS2 cs = new CS2(); cs.inc2( ); System.out.println(cs.x); David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 25 C: Undefined Behavior int always_true(signed char x, int test) { return x < 0 || (x == 0 && test) || x > 0; } __attribute__((noinline)) void print(signed char *p) { printf(\"Input: %d\\n\", (int)*p); } int main() { signed char y; print(&y); int res = always_true(y, 1); printf(\"Result: %d\\n\", res); return 0; } Input: 0 Result: 1 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 26 C: Undefined Behavior int always_true(signed char x, int test) { return x < 0 || (x == 0 && test) || x > 0; } __attribute__((noinline)) void print(signed char *p) { printf(\"Input: %d\\n\", (int)*p); } int main() { signed char y; print(&y); int res = always_true(y, 1); printf(\"Result: %d\\n\", res); return 0; } Input: 0 Result: 1 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 26 C: Undefined Behavior int always_true(signed char x, int test) { return x < 0 || (x == 0 && test) || x > 0; } __attribute__((noinline)) void print(signed char *p) { printf(\"Input: %d\\n\", (int)*p); } int main() { signed char y; // print(&y); int res = always_true(y, 1); printf(\"Result: %d\\n\", res); return 0; } Result: 0 Since y is not initialized, this program contains undefined behavior Compilers are free to optimize code under the assumption that UB does not happen, e.g., omit the call to always_true Try it out: https://godbolt.org/z/87K7Yroza David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 27 C: Undefined Behavior int always_true(signed char x, int test) { return x < 0 || (x == 0 && test) || x > 0; } __attribute__((noinline)) void print(signed char *p) { printf(\"Input: %d\\n\", (int)*p); } int main() { signed char y; // print(&y); int res = always_true(y, 1); printf(\"Result: %d\\n\", res); return 0; } Result: 0 Since y is not initialized, this program contains undefined behavior Compilers are free to optimize code under the assumption that UB does not happen, e.g., omit the call to always_true Try it out: https://godbolt.org/z/87K7Yroza David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 27 C: Undefined Behavior int always_true(signed char x, int test) { return x < 0 || (x == 0 && test) || x > 0; } __attribute__((noinline)) void print(signed char *p) { printf(\"Input: %d\\n\", (int)*p); } int main() { signed char y; // print(&y); int res = always_true(y, 1); printf(\"Result: %d\\n\", res); return 0; } Result: 0 Since y is not initialized, this program contains undefined behavior Compilers are free to optimize code under the assumption that UB does not happen, e.g., omit the call to always_true Try it out: https://godbolt.org/z/87K7Yroza David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 27 Why Formal Semantics? Design of programming languages Formal verification of language properties Reveal ambiguities Support for standardization Implementation of programming languages Specification for developing compilers Generation of interpreters Portability (abstract description of language semantics) Reasoning about programs Formal verification of program properties David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 28 Programming Language Properties Type safety: In each execution state, a variable of type T holds a value of type T (or a subtype of T) Very important question for language designers Example: If String is a subtype of Object, should String[] be a subtype of Object[]? void m(Object[] oa) { oa[0]=new Integer(5); } String[] sa=new String[10]; m(sa); String s = sa[0]; David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 29 Programming Language Properties Type safety: In each execution state, a variable of type T holds a value of type T (or a subtype of T) Very important question for language designers Example: If String is a subtype of Object, should String[] be a subtype of Object[]? void m(Object[] oa) { oa[0]=new Integer(5); } String[] sa=new String[10]; m(sa); String s = sa[0]; David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 29 Compiler Optimization Common subexpression elimination d = a * Math.sqrt(c); e = b * Math.sqrt(c); double tmp=Math.sqrt(c); d = a * tmp; e = b * tmp; Optimization works only for side-effect free expressions d = a * c++; e = b * c++; double tmp = c++; d = a * tmp; e = b * tmp; David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 30 Compiler Optimization Common subexpression elimination d = a * Math.sqrt(c); e = b * Math.sqrt(c); double tmp=Math.sqrt(c); d = a * tmp; e = b * tmp; Optimization works only for side-effect free expressions d = a * c++; e = b * c++; double tmp = c++; d = a * tmp; e = b * tmp; David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 30 Formal Verification /* returns the factorial of n */ int fac(int n) { if (n>1) return n*fac(n-1); else return 1; } fac(17); -288522240 Verification could run by induction Induction hypothesis: n ≥ 0 ⇒ fac(n) = n! Induction base is trivial Induction step requires to prove n × (n − 1)! = n! which is not the case in computer arithmetic (for ints) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 31 Formal Verification /* returns the factorial of n */ int fac(int n) { if (n>1) return n*fac(n-1); else return 1; } fac(17); -288522240 Verification could run by induction Induction hypothesis: n ≥ 0 ⇒ fac(n) = n! Induction base is trivial Induction step requires to prove n × (n − 1)! = n! which is not the case in computer arithmetic (for ints) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 31 Formal Verification /* returns the factorial of n */ int fac(int n) { if (n>1) return n*fac(n-1); else return 1; } fac(17); -288522240 Verification could run by induction Induction hypothesis: n ≥ 0 ⇒ fac(n) = n! Induction base is trivial Induction step requires to prove n × (n − 1)! = n! which is not the case in computer arithmetic (for ints) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 31 Operational Semantics Describes execution on an abstract machine Describes how the effect is achieved; abstractly, how the program runs y := 1; while not(x=1) do ( y := x*y; x := x-1 ) “First we assign 1 to y, then we test whether x is 1 or not. If it is then we stop and otherwise we update y to be the product of x and the previous value of y and then we decrement x by 1. Now we test whether the new value of x is 1 or not. . . ” Especially useful for proofs about language designs and implementations David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 32 Axiomatic Semantics Specific properties of the effect of executing a program are expressed Some aspects of the computation may be ignored y := 1; while not(x=1) do ( y := x*y; x := x-1 ) “If x= n holds before the program is executed then y= n! will hold when the execution terminates (if it terminates)” Especially useful for program verification David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 33","libVersion":"0.5.0","langs":""}