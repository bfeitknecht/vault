{"path":"sem3/TIN/VRL/extra/Hauser, D. How an electric circuit becomes Turing complete.pdf","text":"MNG Rämibühl Maturaproject 03/01/2022 How an electric circuit becomes Turing complete The construction of an 8-bit Computer Dimitrij Hauser Supervisor: Arno Liegmann MNG Rämibühl 3.1.2022 MNG Rämibühl Maturaproject 03/01/2022 ii Abstract It is the age of computers, undeniably. They are everywhere in our everyday live, but how do they work? This is the question I try to answer in this paper. To do this I first take a closer look at the theory of modern computers. This theory was first theorized by Alan Turing, who is often called the father of modern computer theory and artificial intelligence. He invented the Turing machine, which is the basis to modern computers. I then constructed the electronic circuit of a computer myself. I look at all parts of a computer from the smallest transistor up to better known parts like the RAM and CPU and explain the logic involved in all of the circuit. The computer was constructed inside an electronic circuit simulation program called Logisim. Finally, the functionality of the simulated 8-bit computer was tested with an implementation to calculate the Fibonacci sequence. MNG Rämibühl Maturaproject 03/01/2022 iii Prologue I most likely do not have to explain the relevance of computers in our modern age. They are everywhere, in every sector of life and work and they are spreading rapidly. Most people know them as machines with a screen and a keyboard, where one can press buttons to achieve the (most of the times) desired outcome. Many know that one level deeper computers are based on programs, which are based on lines of code/instructions, which instruct the computer on what to do. But there is a deeper level, when looking at a computer in the aspect of hardware, it is just an electronic circuit. But when interacting with a full computer, it seems to have an infinite number of possibilities one can achieve with it. Because it is programmable. I wanted to explore how computers work on the deepest level and how such an electric circuit becomes programmable, by building one myself and looking at Alan Turings theory of modern computers. The idea for this paper was sparked by a video of Sebastian Lague[3], where he explains on what basis computers work, and hearing about “Turing completeness”. I was immediately curious what that means and how Turing completeness exactly works. Upon a bit of research, I was fascinated by the simplicity and versatility behind the concept of Turing completeness. MNG Rämibühl Maturaproject 03/01/2022 iv Contents 1. Introduction 1 2. Turings Theory 2 2.1 Turing machines 2 2.2 Definitions of machines 4 2.3 Abbreviated tables 4 2.4 Universal Machine 4 3. The Turing complete circuit – A 8-bit computer 5 3.1 Foundation – The binary system 5 3.2 Elements of the electronic circuit 5 3.2.1 Logic gates 5 3.2.2 Building Blocks 8 3.2.3 Units 11 3.3 The construction Result – A Turing complete computer 13 3.3.1 Peripherals 13 3.3.2 Programming language 15 3.3.3 Test code 16 4. Conclusion 17 4.1 Comparison Turings theory and the electronic circuit 17 4.2 Computer’s incompleteness 17 5. Remarks 18 6. Literature 19 7. Appendix 20 MNG Rämibühl Maturaproject 03/01/2022 v List of Figures Fig. 1: Turing machine 3 Fig. 2: Transistor 6 Fig. 3: NAND symbol 6 Fig. 4: NAND construction [6] 6 Fig. 5: Memory bit symbol 8 Fig. 6: Memory bit construction 8 Fig. 7: Half adder construction 9 Fig. 8: Full adder construction 10 Fig. 9: Clock cycle illustration 12 Fig. 10: Computer Circuit 14 Fig. 11: Pseudocode - Fibonacci sequence 16 Fig. 12: Instruction code - Fibonacci sequence 16 List of Tables Tab. 1: Truth table – Transistor 6 Tab. 2: Truth table - NAND 6 Tab. 3: Common logic gates 7 Tab. 4: Truth table – Memory bit 8 Tab. 5: Truth table – Addition of 2 bits 9 Tab. 6: Truth table – Half adder 9 Tab. 7: Truth table – Full adder 10 Tab. 8: Instruction code of this circuit 15 MNG Rämibühl Maturaproject 01/01/2022 1 1. Introduction The goal of this project is to understand the concept of computers on their most basic level and to create the electronic circuit of a simple computer. The necessary elements of this circuit will be described, its functions explained and finally pieced together to a full computer. This work leads to the understanding of the functions of the electronic circuit of a general computer and its possibilities. This paper starts in chapter 2. with an introduction to the theory behind modern computers. The theory of modern computers first appeared in Alan Turings1 paper “On computable numbers with an application to the Entscheidungsproblem'' published 1936.[2] The machine conceptualized in Turings paper, the so-called ‘Turing Machine’ is the invention of the principle of modern computers and the logic involved.[4] In chapter 3. and 4. the electronic circuit is developed after Turings theory, i.e., it will be a Turing complete electronic circuit. A step-by-step assembly of a simple computer capable of (nearly) everything our computers can do today, will be built and shown in a simulation in a pre-existing program, Logisim, capable of simulating electronic circuits. The circuit presented in this paper will be a simple representation of a computer, made to explain its core concepts to the reader. It will not be optimised for efficiency. This circuit will be built as designed in “But how do it know\"[1] and has all the abilities of a modern computer. An even simpler Turing complete version of the circuit would be possible, but we would lose out on information and capabilities in comparison with modern computers. 1 Alan Turing was a mathematician and lived from 1912 until 1954. He is known as the father of theoretical computer science and artificial intelligence. During his lifetime, he helped the allied forces to crack German ciphers during World War II and in 1952 he fell victim to the prosecution of homosexuals, which lead to a chemical castration and two years later to his suicide.[11] MNG Rämibühl Maturaproject 03/01/2022 2 2. Turings Theory Turings seasonal paper of 1936[2] is an attempt to define computable numbers. He starts with trying to identify the simplest processes a ‘computer’ (person who computes) must be able to perform. Combining these processes, he generalises them to a set of rules. These rules combined with instructions are able to replicate the processes of a ‘computer’ (person who computes) and compute any computable number. Thus, he defines all computable numbers to be the numbers computable by this process with a finite amount of instructions. To visualise the process of these rules and instructions, he invents the Turing machine (Fig. 1). This is the first known concept of a modern computer. There have been analogue computers before, like an abacus and even mechanical ones [4], but none of them followed Turings principles. Machines or processes, which are capable of executing all processes a Turing machine can, are Turing complete. True Turing completeness needs an infinite amount of storage. This is not physically possible, so true Turing completeness does not exist. The amount of storage we can use with the speed of our Turing machines (computers) is not infinite. The need for infinite storage is mostly neglected when calling something Turing complete, as enough storage is sufficient next to the other traits that must be fulfilled. 2.1 Turing machines Turing machines consists of a few parts with defined attributes and abilities (Fig. 1). These parts are a mechanical or symbolic representation for certain actions a computer (person who computes) takes when computing. These parts are a tape, a machine and configuration cards. In the following list these parts will be shortly elaborate on their purpose and functions: ● A Tape is an infinitely long paper strip separated into squares. Each square bears a symbol. The tape functions as the memory, just like a computer (person who computes) taking notes on a paper. The paper became a tape for simplicity, as the machine only needs to move it in one dimension. One can just imagine all the lines of a paper written in a row instead. ● A Machine can scan and edit the symbol of one square on the tape at a time and move the tape one square to the left or right, to change the observed square. This works like the hand of a computer (person who computes) taking notes. ● Configuration Cards determine the next actions of the machine based on the previously scanned symbol. There is always one card selected and each card specifies for which card it should be swapped, also depending on the previously scanned symbol. These configuration cards contain the simple logic the brain of a computer (person who computes) needs to do. For example, seeing a plus, then adding the previous and next term together and then writing the result to the right of it after an equal sign. The plus sign and terms would be written on the tape, the machine would read those, the configuration cards contain the logic to add the terms together and instruct the machine to write the result on the tape. MNG Rämibühl Maturaproject 03/01/2022 3 At a particular time, a computing machine has a defined state. The current state of a machine can be described with the current configuration x [qx] and the currently scanned Symbol r [S(r)]. The combination [qx, S(r)] describes said state completely. Turing then suggests the convention that written symbols can be either part of the result (a computable number) or notes to “assist the memory”. These will be written on alternate squares on the tape. There are F-squares for the computed Number and E-squares for the notes, which are liable to erasure. Printing a symbol a on an E-square is called marking the F-square after it with a. It could mean for example that the symbol a marks the first digit of a number. In that case the machine in Fig. 1 would read that 1 1 and 0 on the tape are two numbers. What happens with those numbers is written elsewhere on the tape. Fig. 1: Turing machine MNG Rämibühl Maturaproject 03/01/2022 4 2.2 Definitions of machines Turing differentiates between certain types of machines. These machines are automatic or choice machines, computing machines, and circular or circle-free machines. What makes a machine fall into one of those categories will be explained here shortly: ● Automatic machines (a-machines): A machine is called automatic if the current state of the machine [qx, S(r)] completely determines the next action of it. ● Choice machines (c-machines): A machine is called a choice machine if there is at least one ambiguous combination [qx, S(r)], where the next action also depends on an arbitrary choice being made by an external operator. ● Computing machines: A computing machine is an a-machine which is limited to the symbols ‘0’ and ‘1’ on its F-squares i. e the machine only prints the symbols: '0' and '1' (figures) on F-squares. What can be written on E-squares remains uninhibited. This machine will produce the binary numeral of the computed numbers on the F- squares. ● Circular and circle-free machines: A machine is called circular if a computing machine never writes down more than a finite number of symbols on F-squares. All other machines are circle-free machines. 2.3 Abbreviated tables Certain sequences of configurations will be used a lot and it is easier to take them together and abbreviate the table of configurations. Instead of each time constructing the sequence of configurations to do a repetitive task, we can use a ‘function’ which contains the sequence of configuration cards needed to do said task. This function can then be used inside other configuration cards. 2.4 Universal Machine The last bit of theory regarding computers in Turings paper concerns the idea of a universal machine. A universal machine can be any other machine, only by being provided with a code for said machine. With an arbitrary set of rules, we can convert every possible set of configurations of a machine into the form of a number. If we then link all those numbers together, we are able to display the complete configuration set of any machine as a large number (code). With this we can then create another machine, a universal machine. This machine is able to read such a tape containing the configuration set of a computing machine and interpret it correctly to reproduce the machines effects. MNG Rämibühl Maturaproject 03/01/2022 5 3. The Turing complete circuit – A 8-bit computer I will now explain how the electronic circuit of a computer works. This electronic circuit (Fig. 22) was built in Logisim and based on the information provided by ‘But How Do It Know’ by J. Clark Scott [1]. As the program slightly differs from actual electronic logic, some circuits were altered. The circuits presented in this paper will be the ones, which work in reality and all alterations will be mentioned. The information in such a circuit uses the voltage in a wire. We differentiate between low and high voltage and have therefore only two states. The binary numeral system, as explained in section 3.1 is thus the optimal numeral system to use. In the whole of section 3.2 the structure of the computer circuit is explained, starting from the smallest element (3.2.1 Logic gates) and then step by step combining them to more complex elements (Units). 3.1 Foundation – The binary system To represent a number, we will use the binary numeral system, which only needs two symbols and therefore has a very straightforward implementation. In our electronic circuit we will use its voltage to represent symbols. We will only differentiate between high voltage and low voltage, which correspond to 1 & 0 or On & Off. It therefore makes sense to represent this information with binary digits. A binary digit can only have the two states 0 or 1. One binary digit is called a bit and 8 digits are called a byte. A byte is a collection of 8 wires, which each store one bit, a 0 or a 1. Taken together they form an 8-digit binary number in the binary system. The binary system is a base-2 numeral system and therefore has a positional notation with a radix of 2 instead of 10 like the commonly used decimal numeral system.[8] The nth digit will be represented by an. The Number N in binary will have the following structure: N = an2n + ... + a323 + a222 + a121 + a020 and each coefficient an will be either 1 or 0. A byte has 8 digits and therefore 28, 256 possible states. It can represent all numbers from 0 to 255. Here is an example for the number 150 in the binary system. 150 = (1×27) + (0×26) + (0×2 5) + (1×24) + (0×23) + (1×22) + (1×21) + (0×20) = 10010110 3.2 Elements of the electronic circuit 3.2.1 Logic gates The simplest connection between wires in a circuit is a logic gate. A logic gate has in- and outputs for wires and the outputs depend on the state of all the inputs. For each logic gate the rules to determine the output are consistent, and we can make a table showing all the possible input combinations and the resulting output(s). This is called a truth table. The most common logic gates are listed in Tab. 3. Modern computers use transistors to create those gates. We will not go into depth on the physics behind a transistor. But for a rough understanding of how it works, I will quickly describe its functions. It has three bits as in-/outputs. The input bit C increases the MNG Rämibühl Maturaproject 03/01/2022 6 resistance of the current flowing between the other two in-/outputs (bit A and bit B). Therefore, if C is on, A and B are not connected and if C is off A and B are connected. [5] Fig. 2 shows the symbol for such a transistor. Transistors are used to create logic gates. A logic gate is the physical representation of a logical operation using binary in-/outputs.[7] We will focus on the NAND gate, as it is a universal logic gate.[7] This means that all other logic gates can be built solely from combinations of NAND gates. The name NAND is an abbreviation of not-and. It will not output 1 only if all its inputs are 1 (input A and input B). A NAND gate can be built with just two transistors. Fig. 3 shows the commonly used symbol for NAND gates, Fig. 4 its construction, and Tab. 2 the truth table or its logic operation. Tab. 2: Truth table - NAND A B C 0 0 1 1 0 1 0 1 1 1 1 0 Fig. 3: NAND symbol Fig. 4: NAND construction [6] All the other gates will be built from a collection of NAND gates. The following list contains the most common gates [7], which are summarized in Tab. 3. The AND, OR, XOR and NOT gates will also be used in our circuit, the other two, the NOR and XNOR gate have only been added for completeness. MNG Rämibühl Maturaproject 03/01/2022 7 Tab. 3: Common logic gates Name Symbol NAND Construction Truth table AND A B C 0 0 0 1 0 0 0 1 0 1 1 1 OR A B C 0 0 0 1 0 1 0 1 1 1 1 1 XOR A B C 0 0 0 1 0 1 0 1 1 1 1 0 NOT A B 0 1 1 0 0 1 1 0 NOR A B C 0 0 1 1 0 0 0 1 0 1 1 0 XNOR A B C 0 0 0 1 0 1 0 1 1 1 1 0 MNG Rämibühl Maturaproject 03/01/2022 8 The rules of the common logic gates are as follows: • The AND gate outputs 1 if all its inputs are 1. • The OR gate outputs 1 if any of its inputs are 1. • The XOR gate outputs 1 if only one of its inputs is 1. • The NOT gate outputs 1 if its input is 0. • The NOR gate outputs 1 if none of its input are 1. • The XNOR gate outputs 1 if all its inputs are equal. 3.2.2 Building Blocks For the next step we will use these gates to construct small building blocks with useful capabilities, which will be used throughout the circuit. These building blocks have very simple but important functions. The memory bit is able to save the state of one bit. The adder is able to add binary numbers. We differentiate between a half and a full adder. Half adders are only able to add two bits, full adders can be wired together to add binary numbers with any number of digits. These two building blocks have central capabilities and will therefore be explained in detail. There is also a decoder, which can take a binary number of a specific length as an input and has an output for each possible input number. Its construction is visible in the appendix. A memory bit is a small circuit, only using NAND gates, which is able to ‘memorize’ one bit of information. It has an input wire (I), which will supply a bit to be saved, an output wire (O) which will display the saved bit and a ‘set’ wire (S), which, when activated will set the saved bit to the state of the currently supplied bit (I). Fig. 5: Memory bit symbol Fig. 6: Memory bit construction For this circuit a truth table is not completely defined (Tab. 4). When the set input (S) is turned off, the output (O) will be completely determined by the previous and not the current state of the input wire (I) and therefore memorizes the previous state. Tab. 4: Truth table – Memory bit I S O 0 0 0 or 1 1 0 0 or 1 0 1 0 1 1 1 MNG Rämibühl Maturaproject 03/01/2022 9 The second important building block is a small circuit, which is able to add two bits. This is the core element needed for calculating. Addition is the most essential piece to enable arithmetics. All other calculations can be simplified to addition. This will be shown for subtraction at the end of this section. In Tab. 5 the possible results of adding two bits, A and B, are shown. The sum resulting from this addition needs two digits to be able to represent all possible results. With only a bit as an output the number 10 is not representable. The 1 ‘overflows’ into the next digit. Tab. 5: Truth table – Addition of 2 bits This means this circuit must have two outputs to represent the first and second digit of the 2-bit result. This is called a half adder and in Fig. 7 its construction is shown. Tab. 6: Truth table – Half adder A B sum carry 0 0 0 0 1 0 1 0 0 1 1 0 1 1 0 1 Fig. 7: Half adder construction This becomes a problem when we try to add numbers with more than one digit. In the last case in Tab. 5 there is a carry bit active. This bit is named carry bit, because it has to be carried over and added to the next digit. This has the result that the next adder will have to be able to add 3 bits together. This is called a full adder (Fig. 8). Full adders can be stacked together to allow addition of numbers with any number of digits. The carry output (Cout) of each bit has to be connected to the carry input (Cin) of the next full adder. MNG Rämibühl Maturaproject 03/01/2022 10 Tab. 7: Truth table – Full adder A B Cin sum Cout 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 Fig. 8: Full adder construction With full adders we can add numbers of any amount of digits. But to subtract we will use a little trick. Instead of inventing an additional circuit, we will make use of the ‘two’s complement’ [12]. We will change the number to be subtracted in a way that the result will overflow by exactly the amount, a subtraction would give as a result. This is done by inverting all the bits of the subtrahend and then adding 1 to it. This might seem arbitrary, but it can be easily shown with a little example. Given a random subtrahend N, for example 10010110, we want to find a byte, which when added onto N will give the result 00000000, as this is the expected result when subtracting N of itself. Therefore, this new byte has to be -N. We get -N by XOR-ing N and adding 1 onto it. This will be proven in the next step. If we invert all the bits of N, we get 01101001 and added onto N it will result in a byte only consisting of ones. N 1 0 0 1 0 1 1 0 + XOR(N) 0 1 1 0 1 0 0 1 1 1 1 1 1 1 1 1 If we then add 1 onto it, it will overflow to (1) 00000000. (0 ) 1 1 1 1 1 1 1 1 + (01) 01 01 01 01 01 01 01 1 (1 ) 0 0 0 0 0 0 0 0 MNG Rämibühl Maturaproject 03/01/2022 11 As the 9th digit will not fit in a byte, the additional 1 can be ignored. We now have found the representation of -N, which will work mathematically in a digital adder. This is the same but instead of calculating A – N, we calculate A + (-N). 3.2.3 Units A computer is split into sections, which are sometimes even built separately. Each unit functions as a part of the complete computer, with a specific function. These sections are commonly called units and they are all built up from the above-described gates, building blocks and circuits. These units are the Bus, the registers, the RAM, the ALU, the clock and the CPU. With the above presented information one can understand how all described functions of these sections are possible. Their exact design will not be elaborated, but one can have a closer look at the simulation itself or the schematics in the appendix. Bus The bus is the simplest unit. It doesn’t use any gates and consists only of a set of 8 wires, which can hold one byte of information. It is less a unit and more the connection between all units, but it is vital and deserves its own entry here. The bus is connected to all other units and by controlling, which unit outputs something on the bus and which unit takes an input from it, the bus can transport information to and from all units. Registers Registers can save one byte of information. They consist of 8 memory bits connected and their output is controlled to not always be put onto the bus. If the register is used in a computer, with more bits (e.g. 32-bit computer) the registers will be bigger accordingly. Apart from their one byte in-/output, they have two additional inputs, called set and enable, which either set the register to hold the currently supplied byte or enable the Register to output said byte. There are a few special registers in a computer. The registers (Rn) used as short-term storage for bytes currently being manipulated. In our circuit (Fig. 10) there are four of those and they are numbered from 0 to 3. All the other special registers belong to a unit and will be described in that units’ section. RAM The Random Access Memory (RAM) is a collection of registers, which serves to store both instructions and data. Each register has a location, represented by an address in the form of a binary number. It is called Random Access Memory, because given a random address, it can access the byte stored at that memory location. The RAM unit has two main parts, the Memory Address Register (MAR), which temporarily stores the address and activates the memory byte in that location and the Memory Unit (MU), which consists of as many memory bytes as possible with the address length. In our example the RAM unit accepts an address of 8-bit length. An 8-bit number can be one of 256 unique numbers and therefore our RAM unit has 256 memory registers and can hold as many bytes of information. MNG Rämibühl Maturaproject 03/01/2022 12 ALU The Arithmetic Logic Unit (ALU) performs arithmetical and logical operations. It takes two bytes (input A and input B) as an input. The temporary register (TMP) is a register connected to the second input (input B) of the ALU. As some operations of the ALU require two different inputs, the first one will be temporarily saved in the TMP register to leave space for the next byte on the bus, so that another byte can be inputted into the first input. The ALU can apply the logic operations AND, OR, NOT and XOR on those two bytes. It can also shift a byte one digit to the right or left, this is called Rshift or Lshift. For the logic operations, which only need one input, like NOT, Rshift and Lshift, the first input (A) is used. It can also compare the two inputs and tell if they are equal or the first input (A) is larger. The result of this comparison is given by two additional bit outputs. There is another output bit denoting if the result is 0 and a bit, which shows if an operation did overflow i.e. a result exceeded the value of an 8-bit number. These bits are called flags. The flag register will save all the flags outputted by the ALU. The only arithmetical operation the ALU is capable of is to add the two inputted bytes. But as mentioned in the end of section 3.2.2 all other arithmetical operations are reproducible with additional steps. A proof for subtraction was also shown. A 3-digit number, called an opcode, short for operation-code, tells the ALU which of these eight operations it is supposed to take. The accumulator register (ACC) is a register connected to the output of the ALU. The output of the ALU needs to be saved temporarily as at the same time one of the two inputs is still on the bus. The output, which is the result, can then be stored in the next step. Clock The Clock is a central piece of the whole electronic circuit. It is connected to all other units and ensures that they all work synchronously. It has a normal clock cycle, an enable clock cycle and a set clock cycle. The enable clock cycle starts a little earlier and ends a little later than the set cycle, to ensure the correct data is transferred. The enable clock cycle (clk e) and the set clock cycle (clk s) are made from the initial clock cycle (clk) which gets OR-ed or AND-ed with a second clock cycle (clk d) with a quarter of a period of delay (Fig. 9). Fig. 9: Clock cycle illustration (after [1] p. 98, modified) MNG Rämibühl Maturaproject 03/01/2022 13 As the simulation program did not have an option to create a time delay, an accurate construction of a clock circuit in Logisim would not have worked. Luckily the simulation program has an inbuilt clock unit. The clock unit was integrated into the CPU, as the CPU controls the connection of the clock cycles. CPU The Central Processing Unit (CPU) has the core function of coordinating all other units. It reads the instruction, stored in the Instruction Register (IR) and then activates the needed circuits in the appropriate order. It has a special building block called a stepper (see Appendix). The stepper steps through six bits during the execution of an instruction, activating one after the other in rhythm with the clock cycle (clk). Each activation of a bit of the stepper can move one byte between units. The CPU processes the instruction byte to execute it by coordinating the movement of bytes to and from units and instructing those units what to do with the bytes. This means one instruction can include six movements of bytes. Only one byte movement at a time is possible, because of the limitations of the bus, but it can be transported to multiple locations at the same time. During the first three steps of every cycle of the stepper the CPU fetches the instruction from RAM and simultaneously increases the Instruction Address by 1. The Instruction Address is a byte which contains the memory location in the RAM of the current instruction. It then gets stored in the Instruction Address Register (IAR). The stepper in the simulation program was modified. As Logisim is unable to accept two different inputs onto a single wire at the same time, the stepper would always start in an irreparable broken state. Using a pre-existing module an alternative but working stepper has been constructed (cf. Appendix). Additionally, for ease of interaction with the CPU I have added an additional unlabelled input in the top right, which starts and stops the clock. 3.3 The construction Result – A Turing complete computer Fig. 10 shows the fully functioning computer which has been built from the units described above. It is Turing complete and has the same functionality as any modern computer. 3.3.1 Peripherals For the interaction with computers peripherals are needed. Common peripherals are a screen, speakers, a mouse, a keyboard, and a hard drive. They are not a core part of a computer, but necessary in some form for a user to interact with and read the processed data. Peripherals are a more special form of input and output to the whole computer. To work, peripherals only need to receive and send data in the form of bytes. In our circuit the peripherals get connected to the bus as well, as an in/output and get controlled by 4 bits of the CPU telling them if the current byte on the bus data or an address is, if it’s in- or output and two additional bits synchronise the peripherals enable (clk e) and set (clk s) cycles to the main circuits. Those currently unconnected wires are also visible at the bottom right of the complete circuit (Fig. 10). A keyboard inputs the data of which key was pressed and the screen receives data for what colour each pixel on the screen has. The hard drive is needed to store data from the RAM long-term, it is bigger but slower and will keep the data once the computer loses its energy supply. All these peripherals will not be explored further as this would break the scope of this paper. MNG Rämibühl Maturaproject 03/01/2022 14 Fig. 10: Computer Circuit (legend, see next page) MNG Rämibühl Maturaproject 03/01/2022 15 3.3.2 Programming language All the instructions of this circuit are hard to read, since their binary representations are not intuitive to understand. Therefore, they have been replaced with words, better explaining their effects. This is a very simple form of code, called a programming language. Tab. 8 contains all the functions this circuit can execute. This set of instructions is similar to the assembly language, also called machine language, which is the base language all modern computers run with (cf. [13]). All other programming languages need an interpreter which translates it to assembly. Tab. 8: Instruction code of this circuit Instruction byte Programming language Meaning 1000 rarb ADD RA, RB Add RA to RB and store it in RB. 1001 rarb SHR RA, RB Shift RA one digit to the right and store it in RB. 1010 rarb SHL RA, RB Shift RA one digit to the right and store it in RB. 1011 rarb NOT RA, RB NOT RA and store it in RB. 1100 rarb AND RA, RB AND RA and RB and store the result in RB. 1101 rarb OR RA, RB OR RA and RB and store the result in RB. 1110 rarb XOR RA, RB XOR RA and RB and store the result in RB. 1111 rarb CMP RA, RB Compare RA and RB. This will set the flags, which show if the RA is larger than RB or they are equal. 0000 rarb LD RA, RB Load the byte from the RAM address in RA into RB. 0001 rarb ST RA, RB Store RB to the RAM with the address in RA. 0010 00rb DATA RB, Addr Load the 8 bits from the next byte into RB. 0011 00rb JMPR RB Set the IR to the address in RB. Therefore ‘jumping’ to this address to read instructions there. 0100 0000 JMP Addr Jump to the address in the next byte. 0101 caez JCAEZ Addr Jump to the address in the next byte, if any of the tested flags are on. 0110 0000 CLF Clear all flags, to avoid unwanted carries from older executions. s: A set in-/output e: An enable in-/output R0-R3: Registers which temporarily store a byte BUS 1: Replaces the second input byte of the ALU with 1, used to increase the instruction address by 1 Flags: C: Carry out, is connected to the carry in A: The first input of the ALU, commonly called A, is larger than the second one E: The two inputs to the ALU are equal Z: The result of the operation of the ALU was 0 I/O bus: Connection to peripherals MNG Rämibühl Maturaproject 03/01/2022 16 Note that “ra” and “rb” in the instruction code are two 2- digit binary numbers n corresponding to the register R n. RA and RB refer to the byte saved in those registers, or the register themselves. The letters “caez” refer to the flags which show if there is a carry out (c), byte a in the ALU is larger (a), the two bytes are equal (e) or the result is zero. If the corresponding bit in the instruction code is one, it will test if that bit is on or not. 3.3.3 Test code To test the electronic circuit, I have taken a simple mathematical sequence which is well known: the Fibonacci sequence. Its definition is as follows: \u0000\u0000\u0000\u0000 = \u0000\u0000 + \u0000\u0000\u0000\u0000[9] In pseudo code2 the calculation of the Fibonacci sequence looks as follows: Fig. 11: Pseudocode - Fibonacci sequence In our instruction code this looks as follows: Fig. 12: Instruction code - Fibonacci sequence This code calculates the Fibonacci sequence and stops as soon as the byte overflows, which is as soon as Fn is bigger than 255, the maximum number an 8-bit integer can represent. Note: XOR-ing a register with itself is guaranteed to set the byte saved in said register to 0. And adding a Number to this 0 will move said number into this register. 2 Pseudocode is a plain language description of steps in an algorithm. It uses structural conventions of programming languages but is intended for human reading rather than machine reading.[10] R1 = 0 R2 = 1 While R1 ≤ 255: R3 = R1 + R2 R1, R2 = R2, R3 1 XOR R0,R0 1110 0000 Put 0 into R0 2 DATA R1, 1 0010 0001 0000 0001 Put 1 into R1 3 XOR R2,R2 1110 1010 Put 0 into R2 4 ADD R1,R2 1000 0110 Move R1 into R2 5 ADD R0,R2 1000 0010 Add R0 to R2 and store it in R2 6 XOR R0,R0 1110 0000 Put 0 into R0 7 ADD R1,R0 1000 0100 Move R1 into R0 8 XOR R1,R1 1110 0101 Put 0 into R1 9 ADD R2,R1 1000 1001 Move R2 into R1 10 JC 12 0101 1000 0000 1100 Exit the loop, if the if we have overflown 11 JMP 3 0100 0000 0000 0011 Repeat the loop 12 Space for further programming MNG Rämibühl Maturaproject 03/01/2022 17 4. Conclusion 4.1 Comparison Turings theory and the electronic circuit If we now look at the functionality of this circuit, we can make many connections to turings theory. The RAM is equivalent to the ‘tape’ mentioned in Turings theory. The RAM is the memory of the electronic circuit. The RAM’s memory is accessible at random spots with the use of an address. This is different to the’ tape’, where the cell accessed can only be a neighbouring cell to the currently selected cell. Our RAM also saves the information in groups of 8, a byte instead of a bit. Modern computers usually work with 32-bit to 64-bit numbers. The CPU can be either interpreted as the ‘machine’ in Turings theory (Fig. 1), which translates the configurations to movement and writing and reads the tape. In this case instruction code would be the same as the configuration cards. A more accurate view is to see the CPU as the machine plus configuration cards of a universal machine and the instruction code is the code for another Turing machine. The ALU is a form of functions, as mentioned in section 2.3. The operations it can perform are so common that in our computers the original movement and changing one symbol at a time doesn’t even exist in this form anymore. The core functionality of a computer in comparison with Turing machines is the same. The conditional jump instruction (JCAEZ) (cf. Tab. 8) allows for changes based on the data received and this data can still be stored and manipulated according to the principles in Turings theory. Changing computers to only execute functions is an optimization done for speed and to make more readable code. As modern computers follow Turing’s theory, they can calculate all computable numbers. This allows computer to be programmed to theoretically execute any task regarding the manipulation of information one can imagine a human perform, as long as the tasks are all computable. But a computer will be unimaginably faster and not prone to potential errors unlike a ‘computer’ (person who computes). All errors one encounters in a computer are usually due to wrong usage or faulty programming. In a computer there are some limitations and strict rules one has to follow, so the instructions tend to get very complex and take some detours in comparison to a verbal explanation to a human. 4.2 Computer’s incompleteness As mentioned in the start of chapter 2, a computer can never be truly Turing complete, as it lacks infinite storage. This is a somewhat unnecessary requirement, as the storage can never be fully used. Even though you might have run out of storage space at some point with your computer most computers have roughly enough storage to perform all their dedicated tasks. In the case that a computer does not have enough storage it can be upgraded to suit your needs. But computers are not fast enough to use substantially more storage efficiently. The circuit presented in this paper is limited to a mere 256 bytes of storage (RAM) This allows it to run the mathematical algorithm used to test the circuit but not much more. Modern computers usually have multiple gigabytes of RAM at their service, more registers and are able to execute instructions in parallel. MNG Rämibühl Maturaproject 03/01/2022 18 5. Remarks Creating this circuit and delving into the construction plans was an overall enjoyable task. Even though I had to go over certain parts multiple times to completely grasp their workings it was a pleasant exploration of the core of how computers work. Building this circuit inside a simulation was harder than expected. There are a few discrepancies between a real electronic circuit and this simulation program. Some features are meant for bug fixes, for example giving an error if a wire receives two conflicting inputs. However, in real life they would not conflict, as both currents would pass onto the wire and the stronger would be the one measured. A real-life wire therefore functions like an omnidirectional OR-gate, always prioritizing the on-bit over the off-bit. The whole simulation program has limited progressing speed and was not optimized to handle large amounts of objects. The RAM for example, which has more than a thousand objects, led to quite a long delay when trying to open or manipulate the circuit. Those waiting times were annoying to work with and sometimes lasted for minutes. Overall, I’m still very content with the performance and utility of the program. If I had further time, I would possibly have added various improvements to the presented circuit. I might still do them at a later date, as this project was quite interesting and entertaining for me. Besides a few infuriating troubles of course. I thought of including peripherals next. Logisim has for example an option to display a number on a seven- segment display. So, it would have been possible to add the option to display some numbers, which would make bug fixing way easier and more intuitive. I could also have improved the way of inputting code into the RAM. Currently it has to be done manually, which will already become tedious and prone to errors with the few lines of the example code. MNG Rämibühl Maturaproject 03/01/2022 19 6. Literature [1] Scott, J. Clark (2009): But How Do It Know? – The Basic Principles Of Computers For Everyone. Published by John C. Scott, Oldsmar, FL 34677 [2] Turing, Alan M. (1936): ON COMPUTABLE NUMBERS WITH AN APPLICATION TO THE ‘ENTSCHEIDUNGSPROBLEM’. [3] Lague, Sebastian: Youtube, ‘Exploring How Computers Work’ www.youtube.com/watch?v=QZwneRb-zqA [31/12/2021] [4] Wikipedia. Computer, en.wikipedia.org/wiki/Computer [31/12/2021] [5] Wikipedia. Transistor, en.wikipedia.org/wiki/Transistor [31/12/2021] [6] Wikipedia. NAND gate en.wikipedia.org/wiki/NAND_gate [31/12/2021] [7] Wikipedia. Logic gate en.wikipedia.org/wiki/Logic_gate [31/12/2021] [8] Wikipedia. Binary number en.wikipedia.org/wiki/Binary_number [31/12/2021] [9] Wikipedia. Fibonacci number en.wikipedia.org/wiki/Fibonacci_number [31/12/2021] [10] Wikipedia. Pseudocode en.wikipedia.org/wiki/Pseudocode [31/12/2021] [11] Wikipedia, Alan Turing en.wikipedia.org/wiki/Alan_Turing [1/1/2022] [12] Wikipedia, Two’s complement en.wikipedia.org/wiki/Two%27s_complement [1/1/2022] [13] Wikipedia, Assembly en.wikipedia.org/wiki/Assembly_language [1/1/2022] MNG Rämibühl Maturaproject 03/01/2022 20 7. Appendix Register MNG Rämibühl Maturaproject 03/01/2022 21 RAM MNG Rämibühl Maturaproject 03/01/2022 22 ALU MNG Rämibühl Maturaproject 03/01/2022 23 Clock MNG Rämibühl Maturaproject 03/01/2022 24 CPU Stepper MNG Rämibühl Maturaproject 03/01/2022 25 Decoder MNG Rämibühl Maturaproject 03/01/2022 26 Der/die Unterzeichnete bestätigt mit Unterschrift, dass die Arbeit selbständig verfasst und in schriftliche Form gebracht worden ist, dass sich die Mitwirkung anderer Personen auf Beratung und Korrekturlesen beschränkt hat und dass alle verwendeten Unterlagen und Gewährspersonen aufgeführt sind. Dimitrij Hauser Ort, Datum","libVersion":"0.3.2","langs":""}