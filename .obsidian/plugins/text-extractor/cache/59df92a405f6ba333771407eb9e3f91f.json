{"path":"sem2/PProg/PV/exams/PProg-FS23.pdf","text":"Vor und Nachname (Druckbuchstaben): Legi Nummer: 252-0029-00L Parallele Programmierung ETH/CS: FS 2023 Semesterpr¨ufung Thursday, 17.8.2023 120 Minuten Diese Pr¨ufung enth¨alt 24 Seiten (inklusive Deckblatt) und 9 Aufgaben. ¨Uberpr¨ufen Sie nach Be- ginn der Pr¨ufung, dass keine Seiten fehlen. Die Aufgaben 1-4 behandeln den von Dr. Solenthaler unterrichteten Teil der Vorlesung, Aufgaben 5-9 den Teil von Prof. Hoefler. Sie haben 120 Minuten Zeit f¨ur die L¨osung der Pr¨ufung und erhalten 120 Punkte. Wir empfehlen eine Uhr mitzubringen. Sie ben¨otigen nicht alle Punkte um die Bestnote zu erreichen. Um eine gen¨ugende Note zu erreichen reichen ca. die H¨alfte der Punkte (kann je nach Schwierigkeitsgrad der Pr¨ufung angepasst werden). Falls Sie sich durch irgendjemanden oder irgendetwas gest¨ort f¨uhlen, melden Sie dies einer Auf- sichtsperson. Wir sammeln die Pr¨ufung zum Schluss ein, stellen Sie sicher, dass Ihre Pr¨ufung von einem Assistenten eingezogen wird. Wenn Sie fr¨uher abgeben wollen melden Sie sich und wir holen die Pr¨ufung ab. Vorzeitige Abgaben sind nur bis 15 Minuten vor Pr¨ufungsende m¨oglich. Wenn Sie zur Toilette m¨ussen, melden Sie dies einer Aufsichtsperson durch Handzeichen. Es darf zur gleichen Zeit immer nur eine Person zur Toilette. • L¨osungen m¨ussen lesbar sein. L¨osungen mit unklarer Reihenfolge oder anderweitig un- verst¨andlicher Pr¨asentation k¨onnen zu Punktabz¨ugen f¨uhren. Verwenden Sie keinen Blei- stift und keine rot oder orange-farbenen Stifte. • Falls mehr Platz ben¨otigt wird, schreiben Sie auf die leeren Seiten am Ende der Pr¨ufungsunterlagen. Versehen Sie die Aufgabe mit einem klaren Hinweis, falls das der Fall ist. • Multiple-choice Fragen werden minimal mit 0 Punkten bewertet, es werden keine negativen Punkte erteilt. • Die Aufgabenstellungen sind in Deutsch und Englisch gegeben. Die Aufgaben k¨onnen auf Deutsch oder Englisch beantwortet werden. • Legen Sie ihre ETH Karte zur Identit¨ats¨uberpr¨ufung gut sichtbar vor sich auf den Tisch. • In dieser Pr¨ufung sind keine Hilfsmittel oder mitgebrachte Unterlagen erlaubt, ausser ein W¨orterbuch f¨ur fremdsprachige Studierende. Insbesondere alle kommunikationsf¨ahigen, pro- grammierbaren und/oder speicherf¨ahigen Ger¨ate wie bspw. Smartphones, Smartwatches, etc. sind nicht erlaubt. Bei unehrlichem Handeln gelten die Strafnormen der Disziplinarordnung der ETH. • Eine pl¨otzlich auftretende Erkrankung muss bei der Pr¨ufungsaufsicht explizit angezeigt wer- den. Ebenso zwingend erforderlich ist eine Mitteilung, die Pr¨ufung aus medizinischen Gr¨unden nicht beenden zu k¨onnen. Question: 1 2 3 4 5 6 7 8 9 Total Points: 10 16 16 18 14 12 14 8 12 120 Score: Parallele Programmierung - Semesterpr¨ufung - Seite 2 von 24 Thursday, 17.8.2023 Multiple Choice (10 points) 1. Umkreisen Sie die korrekten Antworten in den folgenden Multiple Choice Fragen. Eine korrek- te Antwort gibt einen Punkt. F¨ur eine falsche Antwort wird ein Punkt abgezogen. F¨ur keine Antwort wird weder ein Punkt gegeben noch ei- ner abgezogen. Die minimale Gesamtanzahl an Punkten pro Aufgabe ist 0. Circle the correct answers for the multiple choice questions below. A correct answer gives one point. One point is deducted for an incorrect answer. No point is given or deducted for no answer. The minimum to- tal number of points for each task is 0. (a) Umkreisen Sie in den folgenden Aussagen Amdal’s Law, Gustafson’s Law, oder beide, falls das jeweilige Gesetz auf die Aussage zu- trifft. Eine Antwort oder beide Antworten k¨onnen korrekt sein. For the following statements, circle Am- dahl’s law, Gustafson’s law, or both, if the statement applies to that law. One answer or both answers can be correct. i. (1)Wenn die Latency einer Pipeline konstant bleibt, sich jedoch die Datenmenge erh¨oht, die pro Sekunde verarbeitet wird, haben wir einen Speedup erreicht gem¨ass: If a pipeline’s latency stays constant, but the data processed per second is increased, we have achieved a speedup according to: Amdahl’s law Gustafson’s law ii. (1)Wenn der sequentielle Anteil 0% betr¨agt, ist der theoretische Speedup unlimitiert gem¨ass: Given a sequential fraction of 0%, the theoretical speedup is unlimited ac- cording to: Amdahl’s law Gustafson’s law (b) Umkreisen Sie f¨ur jede der folgenden Aussa- gen, ob sie war oder falsch ist. For each statement below, circle whether it is True or False. i. (1)Eine map Operation transformiert ein Ar- ray in einen Skalar. A map operation transforms an array into a scalar. True False ii. (1)In einem Task Graphen kann der kritische Pfad verk¨urzt werden, indem man mehr Prozessoren hinzuf¨ugt. In a task graph, the critical path can be shortened by adding more proces- sors. True False iii. (1)Ein Task Graph ist immer azyklisch. A task graph is always acyclic. True False iv. (1)In Java kann ein Thread sich ein Monitor Lock eines Objekts nur einmal erwerben. In Java, a thread can acquire the mon- itor lock of an object only once. True False Parallele Programmierung - Semesterpr¨ufung - Seite 3 von 24 Thursday, 17.8.2023 v. (1)Wenn eine Java Klasse eine static synchronized Methode enth¨alt, haben al- le Instanzen dieser Klasse garantiert gegen- seitig ausschliessenden Zugriff auf die Me- thode. When a Java class contains a static synchronized method, all instances of that class are guaranteed mutually ex- clusive access to the method. True False vi. (1)Wenn ein Java Thread versucht in einen synchronized Block einzutreten, welcher bereits von einem anderen Thread aus- gef¨uhrt wird, geht der Thread in den BLOCKED Zustand. When a Java thread tries to enter a synchronized block which is already being executed by another thread, the thread enters the BLOCKED state. True False vii. (1)Ein Thread, der auf Object obj war- tet, kann nur aufgeweckt werden, wenn ein anderer Therad obj.notify() oder obj.notifyAll() aufruft. A thread waiting on Object obj can only be woken up when another thread calls the obj.notify() or obj.notifyAll() methods. True False viii. (1)Die notify() Methode gibt dem Aufwe- cken von Threads, die am l¨angsten warten, keine Priorit¨at. The notify() method does not pri- oritise waking up threads which have waited the longest. True False Parallele Programmierung - Semesterpr¨ufung - Seite 4 von 24 Thursday, 17.8.2023 Pipelining and Speedup (16 points) 2. Eine Machine Learning Pipeline beinhaltet vier Stufen: A machine learning pipeline consists of four stages: A: Load 40 ms B: Pre-Process 20 ms C: Train 60 ms D: Update 20 ms Die volle Pipeline (d.h. alle vier Stufen) muss f¨ur ein vollst¨andiges Modelltraining vier Mal durchlaufen werden. Bei jedem Durchlauf der Pipeline m¨ussen die Stufen in der obig definier- ten Reihenfolge ausgef¨uhrt werden. Wir k¨onnen jedoch annehmen, dass jede Stufe auf einer se- paraten Recheneinheit ausgef¨uhrt wird. Dies bedeutet, dass die verschiedenen Stufen w¨ahrend verschiedener Durchl¨aufe paral- lel ausgef¨uhrt werden k¨onnen. Z.B. kann Stufe A aus dem zweiten Pipelinedurchlauf par- allel zu Stufe B aus dem ersten Pipelinedurch- lauf ausgef¨uhrt werden. Sie d¨urfen den folgenden Platz f¨ur Notizen und Diagramme benutzen. The full pipeline (i.e., all four stages) needs to run four times to complete the model training. In each pipeline run, the stages have to follow each other in the order de- fined above. However, we can assume that each stage is executed on a sepa- rate computational unit. This means that, across different pipeline runs, differ- ent stages can run in parallel. For ex- ample, Stage A from the second pipeline run can run in parallel to Stage B from the first pipeline run. You may use the following space for notes and diagrams. (a) (1)Was ist der Throughput der Pipeline? What is the throughput of the pipeline? (b) (2)Was ist der Speedup der Pipeline verglichen mit der strikt sequentiellen Reihenfolge? What is the speedup of the pipeline com- pared to strictly sequential order? Parallele Programmierung - Semesterpr¨ufung - Seite 5 von 24 Thursday, 17.8.2023 (c) Angenommen wir k¨onnen Stufe C beschleu- nigen indem wir zus¨atzliche Prozessoren hin- zuf¨ugen. Assume we can speed up stage C by adding additional processors. i. (1)Wie lange sollte Stufe C ben¨otigen damit die Pipeline balanciert ist? How long should stage C take, in order for the pipeline to be balanced? ii. (4)Stufe C beinhaltet 20% nicht paralleli- sierbare Arbeit. Berechnen Sie, wie vie- le Prozessoren notwendig sind, um die Ausf¨uhrungszeit zu erriechen, die Sie in Aufgabe c)i) angegeben haben, mit der Annahme, dass die Arbeitsmenge konstant bleibt. Wenden Sie das korrekte Speedup- Gesetz an und rechtfertigen Sie Ihre Wahl in einem oder zwei S¨atzen. Stage C consists of 20% non- parallelizable work. Calculate how many processors are needed to achieve the execution time of stage C that you stated in task c)i), assuming the amount of work stays constant. Use the correct speedup law, and justify your choice in one or two sentences. iii. (4)Eine Alternative zur Parallelisierung von Stufe C besteht darin, die urspr¨ungliche Pipeline auf einem einzigen, N -mal schnel- leren sequentiellen Prozessor auszuf¨uhren. Die Verarbeitungszeit jeder Stufe wird pro- portional reduziert. Z.B. ist die Verarbei- tungszeit pro Stufe mit einem 2x schnelle- ren Prozessor 0.5x des originalen Werts. Ab welchem Wert f¨ur N w¨are die totale Ausf¨uhrungszeit der modifizierten sequen- tiellen Pipeline niedriger als jener der ba- lancierten Pipeline von c)ii)? An alternative to parallelizing stage C is to deploy the original pipeline on a single, N times faster sequen- tial processor. The processing times of each stage are proportionately low- ered, e.g., for a 2x faster processor, the processing time per stage is 0.5x of the original value. At what value of N would the total execution time of the modified, sequential pipeline be lower than that of the balanced pipeline from c)ii)? Parallele Programmierung - Semesterpr¨ufung - Seite 6 von 24 Thursday, 17.8.2023 (d) Betrachten Sie die folgende Pipeline: Consider the following pipeline: A 60 ms B 40 ms C 20 ms i. (1)Was ist die Latency dieser Pipeline? What is the latency of this pipeline? ii. (1)Angenommen Stufe B kann auf einer GPU vollst¨andig parallelisiert werden, so dass sie mehrmals auf den gleichen Daten aus- gef¨uhrt werden kann, wodurch die Qualit¨at der Ausgabe verbessert wird. Die ¨ubrigen Stufen m¨ussen sequentiell ausgef¨uhrt wer- den. Berechnen Sie den parallelen Anteil dieser Pipeline. Suppose that stage B can be fully par- allelized on a GPU to run multiple times on the same data, thus increas- ing the quality of the output. The re- maining stages need to be executed se- quentially. Calculate the parallel frac- tion of this pipeline. iii. (2)Berechnen Sie den Speedup der Pipeline, den man erh¨alt, indem man Stufe B auf einer Maschine mit p = 100 Prozessorein- heiten ausf¨uhrt. Wenden Sie das korrekte Gesetz an (d.h. Amdal’s Law oder Gustaf- son’s Law). Gehen Sie davon aus, dass die Ausf¨uhrungszeit konstant ist und der Ar- beitsaufwand skalierbar ist. Calculate the speedup of the pipeline, obtained by running it with Stage B deployed on a machine with p = 100 processing units. Apply the correct law (i.e., Amdahl’s law or Gustafson’s law). Assume that the execution time is constant, and the amount of work can scale. Parallele Programmierung - Semesterpr¨ufung - Seite 7 von 24 Thursday, 17.8.2023 Fork/Join Framework (16 points) 3. Wir wollen zwei quadratische Matrizen multi- plizieren. Gegeben zwei 2D Arrays von Fliess- kommawerten, multiplizieren wir jede Reihe mit jeder Spalte. Unten finden Sie die forma- le Definition und zwei Beispiele. We want to multiply two square matrices. Given two 2D arrays of floating point val- ues, we multiply each row with each col- umn. Below, you can find the formal defi- nition and two examples: C =      c11 c12 . . . c1n c21 c22 . . . c2n ... ... . . . ... cn1 cn2 . . . cnn      =      a11 a12 . . . a1n a21 a22 . . . a2n ... ... . . . ... an1 an2 . . . ann           b11 b12 . . . b1n b21 b22 . . . b2n ... ... . . . ... bn1 bn2 . . . bnn      = AB, cij = ai1b1j + ai2b2j + . . . + ainbnj = n∑ k=1 aikbkj. (1 2 3 4 ) ( 5 6 7 8 ) = ( 1 ∗ 5 + 2 ∗ 7 1 ∗ 6 + 2 ∗ 8 3 ∗ 5 + 4 ∗ 7 3 ∗ 6 + 4 ∗ 8 ) = (19 22 43 50 )  1 2 3 4 5 6 7 8 9     1 2 3 4 5 6 7 8 9   =   30 36 42 66 81 96 102 126 150   (a) (14)Vervollst¨andigen Sie das Code-Skelett auf den n¨achsten zwei Seiten mithilfe des Fork/- Join Frameworks, um die Eintr¨age cij von C parallel zu berechnen. Ihre L¨osung darf nur primitive Datentypen verwenden. Stellen Sie sicher, dass der Arbeitsaufwand gleichm¨assig auf die Subtasks verteilt wird. Der Einfacheit halber d¨urfen Sie annehmen, dass die zu multiplizierenden Matrizen beide die gleiche quadratische Gr¨osse n × n haben, wobei n eine Potenz von 2 ist. Sequentielle L¨osungen geben keine Punkte. In dieser Auf- gabe m¨ussen Sie Exceptions nicht behan- deln. Complete the code skeleton on the next two pages using the Fork/Join frame- work to calculate the entries cij of C in parallel. Your solution must only use primitive data types. Make sure to split the workload evenly among the subtasks. For simplicity, you may as- sume that the matrices to be multiplied both have the same square size n × n, with n being a power of 2. Sequential solutions will not receive any points. For this task, you do not need to handle exceptions. Parallele Programmierung - Semesterpr¨ufung - Seite 8 von 24 Thursday, 17.8.2023 public class MatMulFJ extends ........................ { // 1 pt final static int CUTOFF = 32; // mat1 und mat2 sind die Eingangsmatrizen, die zu multiplizieren sind // (analog zu A und B in dem obigen Besipiel). matMul ist die Matrix, // die mit dem Resultat der Multiplikation zu f¨ullen ist (analog zu C). /* mat1 and mat2 are the input matrices to be multiplied (analogous * to A and B in the example above). matMul is the matrix to be * filled with the results of the multiplication (analogous to C).*/ double[][] mat1, mat2; double[][] matMul; // starti/j definieren die Anfangskoordinaten des geteilten Fensters. // len definiert die L¨ange des quadratischen Fensters in beide Dimensionen. /* starti/j define the starting coordinates of the split window. * len defines the extent of the square window in both dimensions.*/ int starti, startj; int len; // Instanziiert die gegebenen Argumente als Klassenvariablen. /* Instantiates the provided arguments as class variables. */ public MatMulFJ(double[][] mat1, double[][] mat2, double[][] matMul, int len, int starti, int startj) { ... } @Override protected void compute() { if (......................) { // 1 pt // Berechnen Sie das Resultat der Multiplikation f¨ur das Fenster ¨uber // matMul, indem Sie ¨uber dessen individuelle Eintr¨age iterieren und die // entsprecheneden Zeilen und Spalten von mat1 und mat2 multiplizieren. /* Compute the multiplication result for the window over matMul * by looping over its individual entries and multiplying the * corresponding row and column of mat1 and mat2.*/ ................................................................. // 5 pt ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. Parallele Programmierung - Semesterpr¨ufung - Seite 9 von 24 Thursday, 17.8.2023 } else { // Verwenden Sie das Fork/Join Framework, um matMul in vier gleich // grosse Fenster zu unterteilen. Berechnen Sie die Matrixmultiplikation // f¨ur diese Fenster parallel. Gehen Sie davon aus, dass die Matrixh¨ohe // und -breite eine gleiche Potenz von 2 sind, damit Sie sich nicht mit // ungleich grossen Partitionen befassen m¨ussen. /* Use the Fork/Join framework to split matMul into four windows * of equal size. Compute the matrix multiplication in parallel * for these windows. Assume that the matrix height and width * are an equal power of 2, so you do not have to worry about * uneven partitions. */ ................................................................. // 7 pt ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. } } } Parallele Programmierung - Semesterpr¨ufung - Seite 10 von 24 Thursday, 17.8.2023 (b) (2)Umkreisen Sie bei jeder Antwort, ob sie wahr oder falsch ist. Eine korrekte Antwort gibt einen Punkt. F¨ur eine falsche Antwort wird ein Punkt abgezogen. F¨ur keine Antwort wird weder ein Punkt gegeben noch einer abgezo- gen. Die minimale Gesamtanzahl an Punkten ist 0. For each question, circle whether it is true or false. A correct answer gives one point. One point is deducted for an in- correct answer. No point is given or de- ducted for no answer. The minimum to- tal score is 0 points. Parallelismus im Stil von Divide and Conquer w¨are eine Alternative zu dem Fork/Join Fra- mework, so wie es in a) benutzt wird. Divide and Conquer style parallelism would be an alternative to the Fork/Join framework as used in a). True False Theoretisch k¨onnen wir, verglichen mit se- quentieller Verarbeitung, einen bis zu expo- nentiellen Speedup erzielen mit der Paralleli- sierung aus a). Theoretically, compared to sequential processing, we can achieve up to expo- nential speedup with the parallelization used in a). True False Parallele Programmierung - Semesterpr¨ufung - Seite 11 von 24 Thursday, 17.8.2023 Wait/Notify (18 points) 4. In dieser Aufgabe implementieren Sie ein einfa- ches Logiksystem zum Navigieren in Kreisver- kehren. In this task, you will implement a simple logic system for navigating roundabouts. a) b) c) Abb. 1: a) Zonenlayout des Kreisels. b) Z0 muss frei sein, damit ein Auto ¨uber Einfahrt E0 einfahren kann. c) Z1 muss frei sein, damit das Auto weiterfahren kann. Figure 1: a) Roundabout zone layout. b) Z0 must be free for a car to enter via entrance E0. c) Z1 must be free for the car to continue. Wir betrachten 3-Wege-Kreisel (siehe Abbil- dung 1a). Der Kreisverkehr kann in 3 Zonen un- terteilt werden: Z0, Z1 und Z2. Die Einfahrten in den Kreisverkehr sind mit E0, E1 und E2 ge- kennzeichnet. Die Ausfahrten sind mit X0, X1 und X2 gekennzeichnet. We consider 3-way roundabouts (see Fig- ure 1a). The roundabout can be segmented into 3 zones: Z0, Z1, and Z2. The entries into the roundabout are labeled E0, E1, and E2. The exits are labeled X0, X1, and X2. Beispiel: Ein an E0 ankommendes Auto, wel- ches den Kreisel bei Ausfahrt X2 verlassen will, muss zun¨achst anstehen, bis die zuvor an E0 an- gekommenen Autos abgefahren sind. Das Auto muss dann warten, bis die Zone Z0 frei ist, um in den Kreisverkehr einfahren zu k¨onnen (siehe Abbildung 1b). Vor dem ¨Uberqueren der Zone Z1 muss das Auto warten, bis Z1 frei ist (sie- he Abbildung 1c). Das Auto kann dann bei X2 den Kreisel verlassen. Um Deadlocks zu ver- meiden, d¨urfen sich im Kreisverkehr nie mehr als 2 Autos gleichzeitig befinden! Example: A car arriving at E0, intending to leave the roundabout at exit X2, must first wait in line until the cars that have arrived earlier at E0 have left. The car then has to wait for zone Z0 to be free to enter the roundabout (see Figure 1b). Be- fore crossing zone Z1, the car has to wait for Z1 to be free (see Figure 1c). The car can then leave at X2. To avoid dead- locks, no more than 2 cars can be in the roundabout at any time! Parallele Programmierung - Semesterpr¨ufung - Seite 12 von 24 Thursday, 17.8.2023 (a) (18)Vervollst¨andigen Sie das Code-Skelett der Klasse Car gem¨ass der Beschreibung in den Kommentaren. Ihre L¨osung sollte notify(), notifyAll(), wait(), das synchronized- Schl¨usselwort und die vorhandenen Locks und Atomic Integers verwenden, um das Programm korrekt zu synchronisieren, aber Sie sollen keine unn¨otige Synchronisation einf¨uhren. In dieser Aufgabe m¨ussen Sie Ex- ceptions nicht behandeln. Complete the code skeleton of the class Car according to the description in the comments. Make sure that your so- lution is properly synchronized by us- ing notify(), notifyAll(), wait(), the synchronized keyword, and the pro- vided locks and atomic integers, where required, but do not introduce unneces- sary synchronization. For this task, you do not need to handle exceptions. public class Entry { private int index; // Die Ticketnummer, die dem Auto gegeben wird, welches sich als // n¨achstes hinten an der Warteschlange anstellt. /* The ticket number that will be given to the next car to arrive * at the back of the queue. */ private AtomicInteger next_ticket = new AtomicInteger(0); // Die Ticketnummer des Autos am Anfang der Warteschlange. /* The ticket number of the car in the front of the queue. */ private AtomicInteger next_car_in_line = new AtomicInteger(0); Entry(int index) { this.index = index; } public int get_index() { return index; } public int get_ticket() { return next_ticket.getAndIncrement(); } public int get_next_car_in_line() { return next_car_in_line.get(); } public void car_clears_entry(int car_ticket) { int expected_ticket = get_next_car_in_line(); assert car_ticket == expected_ticket : \"Cars must wait their turn.\"; next_car_in_line.incrementAndGet(); } } public class Zone { private int index; public final Lock mutex = new ReentrantLock(); Zone(int index) { this.index = index; } public int get_index() { return index; } } public class Car implements Runnable { private final List<Zone> zones = new ArrayList<>(); private final Entry entry, exit; private final int ticket_number; private final AtomicInteger cars_on_roundabout; Car(Zone[] zones, Entry entry, Entry exit, AtomicInteger n_cars_on_roundabout) { this.entry = entry; Parallele Programmierung - Semesterpr¨ufung - Seite 13 von 24 Thursday, 17.8.2023 this.exit = exit; this.ticket_number = entry.get_ticket(); int zone_index = this.entry.get_index(); this.n_cars_on_roundabout = n_cars_on_roundabout; // this.zones enth¨alt alle Zonen, welche das Auto // passieren will, geordnet. /* this.zones contains all the zones the car wants * to cross, in order. */ while (zone_index != this.exit.get_index()) { this.zones.add(zones[zone_index]); zone_index = (zone_index + 1) % zones.length; } } @Override public void run() { while (true) { synchronized (...................) { // 1 pt if (this.ticket_number > this.entry.get_next_car_in_line()) { // Vorrang f¨ur Autos, die fr¨uher bei derselben Einfahrt ankamen. /* Give priority to cars that arrived at the * same entry earlier. */ ............................................... // 1 pt ............................................... } else { break; } } // Bevor das Auto in den Kreisverkehr einf¨ahrt, // darf h¨ochstens ein Auto im Kreisverkehr sein. /* Before entering the roundabout, * ensure that at most one is already in the roundabout. */ while (true) { .................................................. // 4 pt .................................................. .................................................. .................................................. .................................................. .................................................. .................................................. } Zone current_zone = this.zones.get(0); // Stellen Sie sicher, dass die entsprechende Zone frei ist... /* Ensure that the relevant zone is free... */ .................................................. // 1 pt .................................................. Parallele Programmierung - Semesterpr¨ufung - Seite 14 von 24 Thursday, 17.8.2023 // ... und dass das n¨achste wartende Auto an dieser Einfahrt // passieren kann. /* ... and that the next car waiting at the same entry can proceed. */ .................................................. // 2 pt .................................................. .................................................. .................................................. .................................................. // Auto ¨uberquert current_zone. /* Car crosses current_zone. */ for (int i = 1; i < this.zones.size(); ++i) { Zone zone = this.zones.get(i); // Stellen Sie sicher, dass die n¨achste Zone frei ist, und // machen Sie die vorherige Zone frei. /* Ensure the next zone is free and free the previous zone. */ .................................................. // 4 pt .................................................. .................................................. .................................................. .................................................. .................................................. .................................................. .................................................. .................................................. // Auto ¨uberquert zone. /* Car crosses zone. */ current_zone = zone; } // Das Auto verl¨asst den Kreisverkehr. /* The car leaves the roundabout. */ .................................................. // 5 pt .................................................. .................................................. .................................................. .................................................. .................................................. .................................................. .................................................. .................................................. } } Parallele Programmierung - Semesterpr¨ufung - Seite 15 von 24 Thursday, 17.8.2023 Locks (14 points) 5. (a) (2)Erkl¨aren Sie den Begriff “Deadlock” im Kon- text von gegenseitigem Ausschluss mehrerer Threads. Explain the term ”deadlock” in the con- text of mutual exclusion in a multi- threaded environment. (b) (2)Was ist der Unterschied zwischen einem “Deadlock” und einem “Livelock”? What is the difference between a dead- lock and a livelock? Parallele Programmierung - Semesterpr¨ufung - Seite 16 von 24 Thursday, 17.8.2023 Der folgende Code implementiert eine Producer-Consumer Queue. Der Code enth¨alt einen Fehler welcher zu einem Deadlock f¨uhren kann. The following code implements a producer-consumer queue. The code contains a concurrency issue which can cause a deadlock to occur. 1 public class MyProdConsQ{ 2 private int MAX_SIZE=1; 3 private Vector<int> buf=new Vector<int>(MAX_SIZE); 4 public synchronized void put(int o) throws InterruptedException { 5 while (buf.size()==MAX_SIZE) { 6 wait(); 7 } 8 buf.add(o); 9 notify(); 10 } 11 public synchronized int get() throws InterruptedException { 12 while (buf.size()==0) { 13 wait(); 14 } 15 int obj = buf.remove(0); 16 notify(); 17 return obj; 18 } 19 } (c) (6)Nehmen Sie an, dass je zwei Threads die oben definierte put bzw. get Funktion aufrufen d.h., insgesamt gibt es vier Threads. Geben Sie eine Abfolge von ausgef¨urten Statements an, bei der es zu einem Deadlock kommt. Assume there are two threads calling the put function and two threads calling the get function from the code above. Write down an interleaving of statements that can lead to a deadlock. (d) (4)¨Andern Sie die obige Implementierung so ab, dass kein Deadlock mehr auftreten kann. Re- ferenzieren Sie die zu ¨andernden Codezeilen und geben Sie ¨Anderungen unten an. Change the implementation above to eliminate the possibility of a deadlock. Reference the lines in the source code above and provide your changes below. Parallele Programmierung - Semesterpr¨ufung - Seite 17 von 24 Thursday, 17.8.2023 Linearizability (12 points) 6. (a) (6)Geben Sie f¨ur jede der folgenden drei Histo- rien an, ob diese linearisierbar und/oder se- quentiell konsistent ist. Nehmen Sie an, r ist ein atomares Register, welches zu Beginn den Wert 0 enth¨alt. For each of the following three histories, indicate if it is linearizable and/or se- quentially consistent. Assume r is an atomic register which is initialized with 0. 1 H1: A r.write(1) 2 B r.write(0) 3 B r:void 4 A r:void 5 A r.read() 6 B r.read() 7 B r:1 8 A r:0 1 H2: B r.write(1) 2 A r.read() 3 C r.write(1) 4 C r:void 5 A r:0 6 C r.read() 7 C r:1 8 B r:void 9 B r:read() 10 B r:0 1 H3: A r.write(1) 2 B r:read() 3 A void 4 B r:0 Parallele Programmierung - Semesterpr¨ufung - Seite 18 von 24 Thursday, 17.8.2023 (b) (3)Impliziert Linearisierbarkeit sequentielle Konsistenz? Geben Sie entweder einen Beweis oder ein Gegenbeispiel an. Does linearizability imply sequential consistency? Provide either a proof or a counterexample. (c) (3)Impliziert sequentielle Konsistenz Lineari- sierbarkeit? Geben Sie entweder einen Beweis oder ein Gegenbeispiel an. Does sequential consistency imply lin- earizability? Provide either a proof or a counterexample. Parallele Programmierung - Semesterpr¨ufung - Seite 19 von 24 Thursday, 17.8.2023 Advanced Synchronization Primitives (14 points) 7. (a) (3)Nennen und erkl¨aren Sie die drei definieren- den Eigenschaften eines wait-free Konsensus Protokolls. Name and explain the three defining properties of wait-free consensus. (b) (2)Kann wait-free binary consensus f¨ur zwei Threads mithilfe von Locks implementiert werden? Begr¨unden Sie Ihre Antwort. Can binary wait-free consensus for two threads be implemented with locks? Ex- plain your answer. (c) (3)Was sind die Konsensuszahlen der folgenden drei Objekte: a) atomare Register welche ausschliesslich die Operationen Read() und Write() un- terst¨utzen b) atomare Register welche zus¨atzlich die TestAndSet() Operation unterst¨utzen, und c) atomare Register welche zus¨atzlich die Operation CompareAndSet() unterst¨utzen. What are the consensus numbers of the following three objects: a) atomic registers that support only the operations Read() and Write(), b) atomic registers that also support the TestAndSet() operation, and c) atomic registers that also support the CompareAndSet() operation? Parallele Programmierung - Semesterpr¨ufung - Seite 20 von 24 Thursday, 17.8.2023 (d) (6)Der folgende Code soll eine Semaphore im- plementieren, enth¨alt jedoch an (mindestens) zwei Stellen einen Fehler. Finden und er- kl¨aren Sie die Fehler, geben Sie ausserdem an, welche Codezeilen wie abge¨andert werden m¨ussen, um die Fehler zu beseitigen. The following semaphore implementa- tion contains (at least) two concurrency issues. Identify and explain the is- sues, and provide a solution to eliminate them. 1 public class MySemaphore { 2 private int count; 3 public MySemaphore(int maxCount) { 4 this.count = account; 5 } 6 public void acquire() throws InterruptedException { 7 synchronized (this) { 8 while (count == 0) { 9 this.wait(); 10 } 11 } 12 count--; 13 } 14 public void release() { 15 synchronized (this) { 16 count++; 17 } 18 this.notify(); 19 } 20 } Parallele Programmierung - Semesterpr¨ufung - Seite 21 von 24 Thursday, 17.8.2023 MPI (8 points) 8. (a) (2)Worin besteht der Unterschied zwischen Punkt-zu-Punkt und Kollektiven Operatio- nen in MPI? Warum werden Kollektive Ope- rationen verwendet? What is the difference between MPI point-to-point and collective operations? Why are collective operations used? (b) (6)Ein MPI Programm wird von 8 Prozessen ausgef¨uhrt. Jeder Prozess kann zu jeder Zeit maximal an einem Nachrichtenaustausch teilnehmen. Eine Nachricht welche einen double Wert enth¨alt kann innerhalb 1 ms zwischen zwei beliebigen Prozessen ausge- tauscht werden. In den unten gezeichneten Schemata (A, B und C) wird jeder Nachrich- tenaustausch als gerichtete Kante zwischen Sender und Empf¨anger dargestellt. Das Ziel des MPI Programms ist es, einen double Wert von Prozess 0 zu jedem anderen Prozess zu senden. Beantworten Sie f¨ur jedes der Schemata unten folgende Fragen: Wird das Ziel erreicht? Was ist die minimale Zeitdauer, bis der letzte Prozess seine Aufgabe erf¨ullt hat. An MPI program is executed by 8 processes. Each process can only par- ticipate in one communication at a time (either as a sender or a receiver). A message containing a double can be sent between any two processes in 1 ms. In the communication schemes below (A, B, and C) each directed edge represents a message sent from a sender to a receiver process. The goal is to send a double from process 0 to all other processes. For each of the schemes below, answer the following: Do they achieve the goal? What is the minimum time for the last process to finish its task? 0 4 2 6 1 53 7 0 4 2 6 1 5 3 7 0 42 6 1 5 3 7 A: B: C: Parallele Programmierung - Semesterpr¨ufung - Seite 22 von 24 Thursday, 17.8.2023 Mixer (12 points) 9. (a) (4)Geben Sie alle m¨oglichen Ausgaben des fol- genden Programms an. Erkl¨aren Sie ihre Antwort. What are all possible outputs the follow- ing program can print? Explain your an- swer. 1 public class MyClass { 2 static int value = 42; 3 static volatile boolean finished = false; 4 public static void main(String args[]){ 5 Thread t1 = new Thread(new Runnable() { 6 @Override 7 public void run() { 8 value++; 9 finished = true; 10 value++; 11 } 12 }); 13 Thread t2 = new Thread(new Runnable() { 14 @Override 15 public void run() { 16 while(!finished) {}; 17 System.out.println(\"Res: \" + value); 18 } 19 }); 20 t1.start(); 21 t2.start(); 22 } 23 } (b) (4)Nennen Sie je einen Vor- und Nachteil von course-grained und fine-grained Locking. List one advantage and disadvantage each of course- and fine-grained locking. Parallele Programmierung - Semesterpr¨ufung - Seite 23 von 24 Thursday, 17.8.2023 (c) (4)Nennen und erkl¨aren Sie zwei Eigenschaften von Transaktionen in Transaktionellem Spei- cher. Name and explain two properties of transactions in transactional memory. Parallele Programmierung - Semesterpr¨ufung - Seite 24 von 24 Thursday, 17.8.2023","libVersion":"0.3.2","langs":""}