{"path":"sem4/FMFP/PV/exams/FMFP-finals/FMFP-FS12.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Exam August 10th, 2012, 09:00 – 12:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Exam.-Nr.: 0 General Comments: 1. Check that your exam papers are complete (5 assignments). 2. Do not write on the exam sheets. Use a separate sheet of paper for every assignment and write your name on each of them. Additional sheets are available from the assistants. 3. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no prepared notes, etc. Do not use a pencil (Bleistift) and do not use the color red. 4. You may write your answers in English or German. Important: Write clearly in the sense of logic, language, and readability. 5. If you have a question regarding the meaning of a problem statement, you may ask one of the assistants in charge of the exam. Assignment 1 2 3 4 5 ∑ Max. points 8 8 10 10 14 50 Your points Formal Methods and Functional Programming, Exam, SS12, Exam-Nr. 0 1 Assignment 1: Typing (8 points) Recall the following functions from the Haskell libraries. 0 :: Num a => a map :: (a -> b) -> [a] -> [b] (>>=) :: Monad m => m a -> (a -> m b) -> m b State the most general type of each of the following expressions. 1. (\\x -> [x 0]) 2. (\\x z -> z (\\y -> x)) 3. map map 4. (\\x -> x >>= (\\y -> y)) Formal Methods and Functional Programming, Exam, SS12, Exam-Nr. 0 2 Assignment 2: Natural Deduction (8 points) Recall the following rules from natural deduction for intuitionistic predicate logic. Γ, A ⊢ A Ax Γ, A ⊢ B Γ ⊢ A → B → I Γ ⊢ A → B Γ ⊢ A Γ ⊢ B → E Γ ⊢ ⊥ Γ ⊢ A ⊥E Γ, A ⊢ ⊥ Γ ⊢ ¬A ¬I Γ ⊢ ¬A Γ ⊢ A Γ ⊢ B ¬E Γ ⊢ A Γ ⊢ B Γ ⊢ A ∧ B ∧I Γ ⊢ A ∧ B Γ ⊢ A ∧EL Γ ⊢ A ∧ B Γ ⊢ B ∧ER Γ ⊢ A Γ ⊢ A ∨ B ∨IL Γ ⊢ B Γ ⊢ A ∨ B ∨IR Γ ⊢ A ∨ B Γ, A ⊢ C Γ, B ⊢ C Γ ⊢ C ∨E Γ ⊢ P (x) Γ ⊢ ∀x. P (x) ∀I ∗ Γ ⊢ ∀x. P (x) Γ ⊢ P (t) ∀E Γ ⊢ A(t) Γ ⊢ ∃x. A(x) ∃I Γ ⊢ ∃x. A(x) Γ, A(x) ⊢ B Γ ⊢ B ∃E∗∗ Side conditions: (*) x not free in Γ and (**) x not free in Γ or B. Also recall that the scope of the quantiﬁers extends as far to the right as possible. Prove ⊢ (∀y. P (y) ∧ R(y)) → ((∃x. Q(x)) → ∃x. Q(x) ∧ R(x)) using natural deduction and label each inference step with the name of the corresponding rule. Formal Methods and Functional Programming, Exam, SS12, Exam-Nr. 0 3 Assignment 3: Lists (10 points) (a) Write a Haskell function last :: [a] -> a that returns the last element of a non- empty list and throws an error given the empty list. For example: last [235, 35, 2, 7, 100] = 100 (b) Let n be a positive integer. If n is even, divide it by two, otherwise multiply it by three and add one. The Collatz conjecture is that, for each n, if we repeat this step indeﬁnitely, then we will eventually reach the number 1. Write a Haskell function collatz :: Int -> [Int] such that collatz n returns a list of numbers obtained by starting with n and applying the step of the Collatz conjecture until 1 is reached. For example: collatz 11 = [11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] (c) The function avg :: [Int] -> Int is deﬁned as follows. avg xs = sum xs ‘div‘ length xs Using foldr :: (a -> b -> b) -> b -> [a] -> b, another possible deﬁnition is avg’ :: [Int] -> Int avg’ xs = g (foldr f (0,0) xs) where g = ... f = ... provided that g and f are deﬁned appropriately. Give deﬁnitions for g and f such that avg = avg’ and neither g nor f are or use any recursive functions. You do not have to formally prove that your deﬁnitions ensure that avg = avg’. Formal Methods and Functional Programming, Exam, SS12, Exam-Nr. 0 4 Assignment 4: Proof by Induction (10 points) Consider the following functions. imerge :: [a] -> [a] -> [a] imerge [] ys = ys -- imerge.1 imerge (x:xs) ys = x:(imerge ys xs) -- imerge.2 length :: [a] -> Int length [] = 0 -- length.1 length (x:xs) = 1 + length xs -- length.2 Prove that ∀xs :: [a]. ∀ys :: [a]. length (imerge xs ys) = length xs + length ys. Note: You might have to perform a case distinction in the step case. Take care that you structure your proof clearly and that you justify every proof step. Formal Methods and Functional Programming, Exam, SS12, Exam-Nr. 0 5 Assignment 5: Dictionaries, (14 points) A dictionary is a data structure storing a mapping from keys to values. We implement a dictionary that maps keys of type k to values of type v as a binary tree represented by the following algebraic data type. data Dict k v = Empty | Join (Dict k v) k v (Dict k v) For example, dict1 :: Dict Int String dict1 = Join (Join Empty 1 \"Hello\" Empty) 2 \"world\" Empty represents the mapping {1 ↦→ \"Hello\", 2 ↦→ \"world\"}. (a) Write the Haskell function foldDict :: (c -> k -> v -> c -> c) -> c -> Dict k v -> c for folding values of type Dict k v. (b) We deﬁne that a dictionary is ordered if, for each non-Empty-node with key k, i. all the keys in the left subtree are smaller than k, ii. all the keys in the right subtree are greater than k, and iii. both the left and the right subtree are ordered. For example, dict1 is ordered, whereas dict2 is not. dict2 = Join Empty 2 \"world\" (Join Empty 1 \"Hello\" Empty) Write a Haskell function lookupDict :: Ord k => k -> Dict k v -> Maybe v that looks up the value associated to a key in an ordered dictionary. For example: lookupDict 2 dict1 = Just \"world\" lookupDict 3 dict1 = Nothing Hint: Recall that data Maybe a = Nothing | Just a. (c) Deﬁne a Haskell function insertDict :: Ord a => a -> b -> Dict a b -> Dict a b such that, for all k::a, v::b, and d::Dict a b, i. lookupDict k (insertDict k v d) = Just v and ii. ordered d implies that ordered (insertDict k v d). You do not have to prove that the properties are satisﬁed. (d) Write a Haskell function ordered :: Ord k => Dict k v -> Bool that determines whether a dictionary is ordered. Computer Science Department, D. Basin, P. M¨uller Formal Methods and Functional Programming Date, Time Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud. No.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. Check that your exam papers are complete (this page, two pages on background material, and XXXXX assignments). 2. Write your last and ﬁrst name on every page that contains parts of your solutions. 3. It is not allowed to use your own papers, documents, scripts, etc., or any electronic equipment (notebook computers, calculators, cell phones, etc.) 4. Use a ballpoint pen or fountain pen (no pencil). Return the instructions, the tasks, and your solutions before leaving the room. 5. Write your answers in English. Write clearly in the sense of logic, language, and readability. The clarity of your arguments and explanations aﬀects your grade. Label all rule applications in your derivation trees and inference trees. 6. You have 180 minutes to complete the exam. 7. Place your student ID on the desk. Assignment 1 2 3 4 5 ∑ Max. points 11 10 12 11 6 50 Your points Grade Part II: Formal Methods Formal Methods and Functional Programming, Exam SS12 14 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ∶∶= skip ∣ x:=e ∣ s; s ∣ if b then s else s end ∣ while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). Structural Operational Semantics SkipSOS ⟨skip, σ⟩ →1 σ AssSOS ⟨x:=e, σ⟩ →1 σ[x ↦ A[[e]]σ] Seq1SOS ⟨s1, σ⟩ →1 σ′ ⟨s1;s2, σ⟩ →1 ⟨s2, σ′⟩ Seq2SOS ⟨s1, σ⟩ →1 ⟨s ′ 1, σ′⟩ ⟨s1;s2, σ⟩ →1 ⟨s ′ 1;s2, σ′⟩ IfTSOS ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s1, σ⟩ if B[[b]]σ = tt IfFSOS ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s2, σ⟩ if B[[b]]σ = ﬀ WhileSOS ⟨while b do s end, σ⟩ →1 ⟨if b then s;while b do s end else skip end, σ⟩ Formal Methods and Functional Programming, Exam SS12 15 Axiomatic Semantics (partial correctness) SkipAx { P } skip { P } AssAx { P[x ↦ e] } x:=e { P } SeqAx { P } s1 { Q } { Q } s2 { R } { P } s1;s2 { R } IfAx { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } { P } if b then s1 else s2 end { Q } WhAx { b ∧ P } s { P } { P } while b do s end { ¬b ∧ P } ConsAx { P′ } s { Q′ } { P } s { Q } if P ⇒ P′ and Q′ ⇒ Q Axiomatic Semantics (total correctness) As for partial correctness above, except for the following rule, which replaces WhAx : WhTotAx { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ⇒ 0 ≤ e Formal Methods and Functional Programming, Exam SS12 16 Assignment 1 (11 points) Consider the following IMP program s: while x < y do y := y - 1; if x < y then x := x + 1 else skip end end Provide an axiomatic semantics total correctness proof outline to show that the program s satisﬁes the following property: ⊢ {x = X ∧ y = Y ∧ X ≤ Y } s �⇓ x = y ∧ y = X + Y 2 � where a b represents integer division of a by b where the non-integer part of the result gets truncated, e.g., 3 2 = 1. Hints: (a) You may use the following property of integer division: for any integer n, 2n + 1 2 = 2n 2 = n (b) It is recommended that you explicitly state your loop invariant and loop variant. Formal Methods and Functional Programming, Exam SS12 19 Assignment 2 (10 points) Show that (for all statements s, for all boolean expressions b and for all predicates P and Q): ⊢ { P } while b do s end { Q } ⇒ ⊢ { P } if b then s; while b do s end else skip end { Q } Formal Methods and Functional Programming, Exam SS12 22 Assignment 3 (12 points) Additional rules This assignment is about diﬀerences in semantics between the two default SOS rules for conditional statements (page 14) and the four alternative SOS rules that have been men- tioned in the lecture and that are repeated here: IfT1SOS ⟨s1, σ⟩ →1 σ′ ⟨if b then s1 else s2 end, σ⟩ →1 σ′ if B[[b]]σ = tt IfT2SOS ⟨s1, σ⟩ →1 ⟨s ′ 1, σ′⟩ ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s ′ 1, σ′⟩ if B[[b]]σ = tt IfF1SOS ⟨s2, σ⟩ →1 σ′ ⟨if b then s1 else s2 end, σ⟩ →1 σ′ if B[[b]]σ = ﬀ IfF2SOS ⟨s2, σ⟩ →1 ⟨s ′ 2, σ′⟩ ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s ′ 2, σ′⟩ if B[[b]]σ = ﬀ Note that all four rules are needed as a replacement for the two default rules. The two sets of rules are equivalent for the basic IMP language, but result in diﬀerent behaviour when the language is extended by features that exhibit nondeterminism: Nondeterministic choice in SOS: ND1SOS ⟨s1 s2, σ⟩ →1 ⟨s1, σ⟩ ND2SOS ⟨s1 s2, σ⟩ →1 ⟨s2, σ⟩ Parallel statement in SOS: Par1SOS ⟨s1, σ⟩ →1 σ′ ⟨s1 par s2, σ⟩ →1 ⟨s2, σ′⟩ Par2SOS ⟨s1, σ⟩ →1 ⟨s ′ 1, σ′⟩ ⟨s1 par s2, σ⟩ →1 ⟨s ′ 1 par s2, σ′⟩ Par3SOS ⟨s2, σ⟩ →1 σ′ ⟨s1 par s2, σ⟩ →1 ⟨s1, σ′⟩ Par4SOS ⟨s2, σ⟩ →1 ⟨s ′ 2, σ′⟩ ⟨s1 par s2, σ⟩ →1 ⟨s1 par s′ 2, σ′⟩ Formal Methods and Functional Programming, Exam SS12 23 Assignment Consider statements of the following form: if x = 0 then (if x # 0 then y := 1 else skip end) else skip end op s2 where op is either par or as deﬁned above, and where s2 can be any statement. When executing statements of this form, the choice of rules for conditional statements can result in diﬀerent ﬁnal states. Show this, as follows: Choose op to be either par or , and choose s2 to be any statement you like. Let s be the entire resulting statement. Then, choose states σ and σ′, and show that ⟨s, σ⟩ → ∗ 1 σ′ is derivable using the default rules for conditional statements (page 14), but that it is not derivable using instead the alternative rules for conditional statements (page 22). Your answer should include suitable explanations. In any derivation sequences you write, you don’t need to justify the individual steps with derivation trees. Hint: Choose s2 to be as simple/small as possible. Formal Methods and Functional Programming, Exam SS12 26 Assignment 4 (11 points) Assignment: Consider the following game: there are two piles of n matches each, for n > 0, and two players P1 and P2. The two play in turn, each taking a (strictly) positive number of matches from one of the two piles. P1 is the starting player. The player taking the last match(es), i.e., the player after whose turn both piles are empty, wins. A strategy that guarantees that P2 wins is to take as many matches as P1 did, but from the other pile. Task: Model the game in Promela for n = 100, such that P2 plays according to the strategy described above. Include an assertion that shows that P2 is guaranteed to win. Formal Methods and Functional Programming, Exam SS12 29 Assignment 5 (6 points) Consider the transition system T = (Γ, s1, →, L) over the set of atomic propositions P = {p, q, r}: Γ = {s1, s2, s3, s4, s5} → = �(s1, s2), (s1, s3), (s2, s1), (s2, s3), (s3, s1), (s3, s2), (s3, s3), → = �(s3, s4), (s4, s5), (s5, s3)� L(s1) = {p}, L(s2) = {q}, L(s3) = {p, q, r}, L(s4) = {r} and L(s5) = {p, r}. You might ﬁnd the following picture helpful: s1 s2 s3 s5 s4 {p} {q} {p,q,r} {r} {p,r} Which of the following LTL formulas are satisﬁed in T , i.e., T ⊧ ϕi? Brieﬂy justify your answers. If T /⊧ ϕi, provide a computation γ of T (an inﬁnite sequence of states), such that for the corresponding trace t, t /⊧ ϕi. ϕ1 = (◯¬(q ∨ r)) ⇒ r U (q ∨ p) ϕ2 = (◻ ◇ ¬p) U (p ∧ r) ϕ3 = ◻(◯(p ∧ ¬q) ⇒ ◯ ◯ p) ϕ4 = (q U ◇r) ⇒ ◇r","libVersion":"0.5.0","langs":""}