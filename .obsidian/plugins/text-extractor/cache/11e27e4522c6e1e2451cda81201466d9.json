{"path":"sem4/DMDB/UE/slides/DMDB-s08-query-processing.pdf","text":"@DS3Lab www.DS3Lab.com Geun Woo Park Data Modelling & Databases gepark@ethz.ch Exercise 8: Query Processing Goal for this Session ▪ Understand these important concepts • Pages (Blocks) / Tuples (Rows) • Usage of indexes in databases • Cost of random and sequential access • Different join algorithms ▪ Calculate the cost for sequential and random accesses ▪ Choose the right algorithms to execute a DB query, given information about the tables and/or memory resources ▪ Get a feeling for the many decisions a DB system has to make RecapRecapRecapQuestion 1 1: A clustered index shows tuples consecutively, but the tuples are not necessarily stored consecutively in physical storage 2: Blocks can have headers in which they store metadata about a block’s content. 3: When adding tuples to a block, both the row directory and the tuples in the block grows from top to bottom. 4: Blocks can have variable sizes to store strings and other variable- length data (e.g. arrays). Question 1 1: A clustered index shows tuples consecutively, but the tuples are not necessarily stored consecutively in physical storage 2: Blocks can have headers in which they store metadata about a block’s content. 3: When adding tuples to a block, both the row directory and the tuples in the block grows from top to bottom. 4: Blocks can have variable sizes to store strings and other variable- length data (e.g. arrays). Question 1 False, clustered indexes forces the tuples to be stored consecutively in storage. 1: A clustered index shows tuples consecutively, but the tuples are not necessarily stored consecutively in physical storage 2: Blocks can have headers in which they store metadata about a block’s content. 3: When adding tuples to a block, both the row directory and the tuples in the block grows from top to bottom. 4: Blocks can have variable sizes to store strings and other variable- length data (e.g. arrays). Question 1 False, clustered indexes forces the tuples to be stored consecutively in storage. True 1: A clustered index shows tuples consecutively, but the tuples are not necessarily stored consecutively in physical storage 2: Blocks can have headers in which they store metadata about a block’s content. 3: When adding tuples to a block, both the row directory and the tuples in the block grows from top to bottom. 4: Blocks can have variable sizes to store strings and other variable- length data (e.g. arrays). Question 1 False, clustered indexes forces the tuples to be stored consecutively in storage. True False, the row directory grows down and the row data grows upwards. 1: A clustered index shows tuples consecutively, but the tuples are not necessarily stored consecutively in physical storage 2: Blocks can have headers in which they store metadata about a block’s content. 3: When adding tuples to a block, both the row directory and the tuples in the block grows from top to bottom. 4: Blocks can have variable sizes to store strings and other variable- length data (e.g. arrays). Question 1 False, clustered indexes forces the tuples to be stored consecutively in storage. True False, the row directory grows down and the row data grows upwards. False, blocks always have a fixed size but they can be set to different sizes at time of DB creation. Also varies for different OSs (e.g. Windows and macOS 4KB, UNIX 8KB) Question 2Question 2 ▪ Option 1 (Sequential Scan): Go through all tuples and check if it fulfills requirement. => Sequentially scan each page and check all the tuples in the page. ID name salary 1 Alice 30000 2 Bob 21000 3 Tom 13900 4 Jack 12300 5 Martin 20000 6 Linda 12300 Employees P1 P2 P3 Question 2 ▪ Option 1 (Sequential Scan): Go through all tuples and check if it fulfills requirement. => Sequentially scan each page and check all the tuples in the page. ID name salary 1 Alice 30000 2 Bob 21000 3 Tom 13900 4 Jack 12300 5 Martin 20000 6 Linda 12300 Employees P1 P2 P3 Case 1 Low Selectivity : Most or all tuples fulfill requirement => Sequential scan is efficient Case 2 High Selectivity: Not many tuples fulfill requirement => Sequential scan is inefficient Question 2: Cost estimation How long does this take? For the sequential table scan, ID name salary 1 Alice 30000 2 Bob 21000 3 Tom 13900 4 Jack 12300 5 Martin 20000 6 Linda 12300 Employees P1 P2 P3 Question 2: Cost estimation How long does this take? For the sequential table scan, TScan = (Access time for first page) + (Time to transmit all the pages) TScan = (Random access time) + ((Total size of all pages) / (Bandwidth)) m = total number of pages ▪ Option 1 (Sequential Scan): Go through all tuples and check if it fulfills requirement. => Sequentially scan each page and check all the tuples in the page. ID name salary 1 Alice 30000 2 Bob 21000 3 Tom 13900 4 Jack 12300 5 Martin 20000 6 Linda 12300 Employees P1 P2 P3 Question 2 ▪ Option 2 (Index Lookup): leverage the index to find tuples that fulfill requirement => Look for the desired tuples according to the index, and randomly access them ID name salary 1 Alice 30000 2 Bob 21000 3 Tom 13900 4 Jack 12300 5 Martin 20000 6 Linda 12300 Employees P1 P2 P3RID = (PageID, Slot ID) Tuples that have salary equals 12,300 Question 2 ▪ Option 2 (Index Lookup): leverage the index to find tuples that fulfill requirement => Look for the desired tuples according to the index, and randomly access them ID name salary 1 Alice 30000 2 Bob 21000 3 Tom 13900 4 Jack 12300 5 Martin 20000 6 Linda 12300 Employees P1 P2 P3RID = (PageID, Slot ID) Tuples that have salary equals 12,300 Case 1: Most or all tuples fulfill requirement => Index-based access is slow (too many random accesses) Case 2: Few tuples (e.g., only one) fulfill requirement => Index-based access is fast Question 2: Cost estimation ID name salary 1 Alice 30000 2 Bob 21000 3 Tom 13900 4 Jack 12300 5 Martin 20000 6 Linda 12300 Employees P1 P2 P3 How long does this take? For the index-based access, Question 2: Cost estimation ▪ Option 2 (Index Lookup): Output every tuple that fulfills requirement => Look for the desired tuples according to the index, and randomly access them ID name salary 1 Alice 30000 2 Bob 21000 3 Tom 13900 4 Jack 12300 5 Martin 20000 6 Linda 12300 Employees P1 P2 P3 RID = (PageID, Slot ID) How long does this take? For the index-based access, TIndex = (page random access time + transmit time per page) * (Number of accessed pages) m = total number of pages k = selectivity * #tuples Question 2 Plug in values: Selectivity = 0.1 % HDD index HDD scan Question 3 where k=selectivity⋅#tuples Question 3 where k=selectivity⋅#tuples Question 4 Oid Customer Volume 100 2 10 101 3 15 102 2 50 Order Cid Name 1 Bob 2 Alice 3 Carol Customer Question 4 Oid Customer Volume 100 2 10 101 3 15 102 2 50 Order Cid Name 1 Bob 2 Alice 3 Carol Customer Question 4 Oid Customer Volume 100 2 10 101 3 15 102 2 50 Order Cid Name 1 Bob 2 Alice 3 Carol Customer Question 4 Oid Customer Volume 100 2 10 101 3 15 102 2 50 Order Cid Name 1 Bob 2 Alice 3 Carol Customer Question 4 Oid Customer Volume 100 2 10 101 3 15 102 2 50 Order Cid Name 1 Bob 2 Alice 3 Carol Customer Question 4 Oid Customer Volume 100 2 10 101 3 15 102 2 50 Order Cid Name 1 Bob 2 Alice 3 Carol Customer Question 5Question 5 Can store all tuples in memory, normal sorting possible e.g. Quicksort Question 5 Lecture Operators, Slide 17 (2025) Question 5 We can simply use the sorted index to provide tuples in order Question 6Join ▪ ▪ Nested Loop Join 𝑅 ⋈𝜃 𝑆 for each tuple r in R: for each tuple s in S: check , if true, output𝜃(𝑟, 𝑠) 1 2 3 4 5 6 7 8 1 3 5 6 R S Join ▪ ▪ Nested Loop Join ▪ Complexity: 𝑅 ⋈𝜃 𝑆 for each tuple r in R: for each tuple s in S: check , if true, output𝜃(𝑟, 𝑠) 1 2 3 4 5 6 7 8 1 3 5 6 R S Join ▪ ▪ Nested Loop Join ▪ Complexity: O(|R| * |S|) or O( ) 𝑅 ⋈𝜃 𝑆 n2 for each tuple r in R: for each tuple s in S: check , if true, output𝜃(𝑟, 𝑠) 1 2 3 4 5 6 7 8 1 3 5 6 R S Join ▪ ▪ Nested Loop Join ▪ Complexity: O(|R| * |S|) or O( ) ▪ Join order matters 𝑅 ⋈𝜃 𝑆 n2 for each tuple r in R: for each tuple s in S: check , if true, output𝜃(𝑟, 𝑠) 1 2 3 4 5 6 7 8 1 3 5 6 R S Join ▪ ▪ Nested Loop Join ▪ Complexity: O(|R| * |S|) or O( ) ▪ Join order matters ▪ To maximize sequential reads, we want the larger relation in the inner loop 𝑅 ⋈𝜃 𝑆 n2 for each tuple r in R: for each tuple s in S: check , if true, output𝜃(𝑟, 𝑠) 1 2 3 4 5 6 7 8 1 3 5 6 R S Join ▪ ▪ Hash Join (equi-join) 𝑅 ⋈𝜃 𝑆 build Hash Table HT for R foreach tuple s in S: if h(s) in HT: check for all r h(r)=h(s) whether r = s, if so output Join ▪ ▪ Hash Join (equi-join) ▪ Complexity: 𝑅 ⋈𝜃 𝑆 build Hash Table HT for R foreach tuple s in S: if h(s) in HT: check for all r h(r)=h(s) whether r = s, if so output Join ▪ ▪ Hash Join (equi-join) ▪ Complexity: O(|R| + |S|) or O(n) 𝑅 ⋈𝜃 𝑆 build Hash Table HT for R foreach tuple s in S: if h(s) in HT: check for all r h(r)=h(s) whether r = s, if so output Questions 7 & 8Questions 7 & 8 h(𝑥1) ↦ 𝑎 h(𝑥2) ↦ 𝑏 x_1 != x_2 => h(x_1) != h(x_2)Questions 7 & 8 h(𝑥1) ↦ 𝑎 h(𝑥2) ↦ 𝑏 Questions 7 & 8Questions 7 & 8Questions 7 & 8Questions 7 & 8 1. All the data ends up in the same partition 2. All data ends up in the same hash bucket e.g., all the join attributes have the same value. Question 9Question 9Question 9 QP1 Question 9 QP1 QP1 Question 9 QP1 QP1 QP1 Question 9 QP1 QP1 QP1 Question 9 QP1 QP1 QP1 QP2 Question 9 QP1 QP1 QP1 QP2 QP2 Question 9 QP1 QP1 QP1 QP2 QP2 QP2 Question 9 QP1 QP1 QP1 QP2 QP2 QP2 Question 9 QP1 QP1 QP1 QP2 QP2 QP2 QP3 Question 9 QP1 QP1 QP1 QP2 QP2 QP2 QP3 QP3 Question 9 QP1 QP1 QP1 QP2 QP2 QP2 QP3 QP3 QP3 Question 9 Rules of thumb Nested Loop Join Efficient: Inner relation larger than outer relation, low selectivity Inefficient: Inner relation smaller than outer, high selectivity Indexed Nested Loop Join Efficient: High selectivity Inefficient: Low selectivity Solution: For low selectivity, normal nested loop join often better Hash Join Efficient: Result of join fits into memory Inefficient: Result doesn’t fit into memory Solution: Grace Hash Join (but more IO!) Sort Merge Join Efficient: Sorted attribute (e.g., clustered index) Inefficient: Unsorted attribute Question 10Question 10Question 10 Regarding the performance of join order A⋈B ≠ B⋈A (A⋈B)⋈C ≠ A⋈(B⋈C) Question 11Learning A database system has to make a lot of decisions ▪ How to order operators? ▪ How to order relations in a join? ▪ Which algorithm to use for an operator? ▪ Which access method to choose? ▪ How to organize the pages? ▪ ...and many, many more @DS3Lab www.DS3Lab.com Questions & Feedback? Geun Park - gepark@ethz.ch @DS3Lab www.DS3Lab.com Thank you :D","libVersion":"0.5.0","langs":""}