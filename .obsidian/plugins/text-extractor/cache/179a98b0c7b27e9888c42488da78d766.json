{"path":"var/export/A&D-bf-u04.pdf","text":"Antonia Tomova, 23-957-590, Basil Feitknecht, 23-922-099 4.3 Prove the correctness of insertion sort by mathematical induction. We will show that the invariant below holds for any j ∈ N+. I(j) = \"after j iterations the first j elements are sorted“ Base C ase j = 1 The algorithm doesn‘t iterate, since j ≯ 1. However, any one element array is sorted. Thus, the invariant holds. Induction H ypothesis j = k We assume the invariant to hold, i.e. I(k) is true for an arbitrary k ∈ N+. This means that after k iterations of the algorithm, the ﬁrst k elements of the array are now sorted, A[1]≤ A[2]≤ ⋯ ≤ A[k], while the next n − k elements are still unsorted. Inductive Step j = k + 1 We need to prove that the invariant I(k + 1) holds. To do this, let‘s assume we are at the k-th iteration of the algorithm. According to the IH, this implies that the ﬁrst k elements of the array are sorted, i.e. I(k) holds. For the next iteration of the algorithm, we use a case distinction. Case A[k + 1]< A[k] This is the case where the element at index k + 1 is smaller than the k-th element, which means it needs to be inserted at the correct index l ∈ [k] in the ﬁrst k elements such that A[l − 1]≤ A[l]≤ A[l + 1]. First, it gets swapped with the element at index k. This restores the invariant for the last two of the ﬁrst k elements. In the next k − 1 iterations of the inner loop, it gets pushed back to its correct position through a series of swaps based on the condition, that A[i + 1]< A[i]. That is, the invariant gets restored from the end of the ﬁrst k elements. At i = 1, all the ﬁrst k + 1 elements are sorted again and the invariant I(k + 1) holds. Case A[k + 1]≮ A[k] ⟹ A[k + 1]≥ A[k] This is the case that the element at index k + 1 is greater than or equal the k-th element, which means the ﬁrst k + 1 elements are sorted and the invariant I(k + 1) trivially holds. Thus, we have proven the correctness of insertion sort through induction. □ 4.4 (a) We ﬁnd the pivot k in a given weird array A using a modiﬁcation of the binary search algorithm. As a nice side eﬀect, we sort the array in constant time after having found the pivot. The correctness of the algorithm is given by the fact that the weird array contains only unique elements and the subarrays induced by the pivot are sorted in ascending order. This implies that the pivot is exactly the index of the element that is greater than the element directly proceeding it. Since we half the search range in every iteration, the algorithm’s runtime is in O(log n). □ \u0000\u0000 \u0000l\u0000\u0000\u0000i\u0000\u0000m t\u0000 d\u0000te\u0000m\u0000\u0000e \u0000i\u0000\u0000t \u0000l\u0000m\u0000\u0000t i\u0000 w\u0000\u0000\u0000\u0000 \u0000\u0000\u0000\u0000y \u0000\u0000 based on m\u0000\u0000\u0000f\u0000\u0000d \u0000i\u0000\u0000r\u0000 se\u0000r\u0000h \u0000\u0000 r\u0000\u0000\u0000\u0000\u0000\u0000: O(l\u0000g n) \u0000\u0000 i\u0000p\u0000t: int\u0000g\u0000r \u0000\u0000\u0000\u0000y A \u0000f l\u0000n\u0000t\u0000 n \u0000\u0000 o\u0000t\u0000\u0000t: int\u0000g\u0000r \u0000i\u0000\u0000t f\u0000n\u0000\u0000\u0000\u0000n w\u0000\u0000\u0000\u0000-s\u0000\u0000t(A) be\u0000in let l = 1 \u0000\u0000 le\u0000t let r = n \u0000\u0000 \u0000\u0000\u0000\u0000t let m = (l+r)/2 \u0000\u0000 \u0000\u0000\u0000\u0000l\u0000 s\u0000\u0000it w\u0000\u0000\u0000\u0000 l <= r do m = (l+r)/2 \u0000\u0000 \u0000\u0000\u0000\u0000l\u0000 s\u0000\u0000it i\u0000 A[m] > A[m+1] t\u0000en \u0000r\u0000ak end \u0000\u0000 f\u0000und \u0000i\u0000\u0000t i\u0000 A[m] < A\u00001\u0000 t\u0000en \u0000\u0000 se\u0000r\u0000h le\u0000t r = m - 1 el\u0000\u0000\u0000\u0000 A[m] > A[n] \u0000\u0000 se\u0000r\u0000h \u0000\u0000\u0000\u0000t l = m + 1 end end let M = [] M\u00001\u0000\u0000m-n] = A[m+1\u0000\u0000n] M[m-n+1\u0000\u0000n] = A\u00001\u0000\u0000m] A \u0000 M retur\u0000 m end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 (b) To determine if a given weird array A contains an element l, we ﬁrst sort the array with the algorithm from subtask (a). Then we apply binary search on the now sorted array with the element l. The correctness of the algorithm is given by the fact that the array is now sorted and the correctness of binary search. Its runtime is that of the algorithm from subtask (a) plus that of binary search, O(log n) + O(log n) = O(2 log n) ≤ O(log n). □ \u0000\u0000 \u0000l\u0000\u0000\u0000i\u0000\u0000m t\u0000 d\u0000te\u0000m\u0000\u0000e \u0000\u0000 w\u0000\u0000\u0000\u0000 \u0000\u0000\u0000\u0000y co\u0000tai\u0000s \u0000i\u0000en \u0000l\u0000m\u0000\u0000t \u0000\u0000 r\u0000\u0000\u0000\u0000\u0000\u0000: O(l\u0000g n) \u0000\u0000 i\u0000p\u0000t: int\u0000g\u0000r l, int\u0000g\u0000r \u0000\u0000\u0000\u0000y A \u0000f l\u0000n\u0000t\u0000 n \u0000\u0000 o\u0000t\u0000\u0000t: bo\u0000l\u0000an co\u0000tai\u0000s f\u0000n\u0000\u0000\u0000\u0000n w\u0000\u0000\u0000\u0000-co\u0000tai\u0000s(l, A\u0000 be\u0000in \u0000\u0000 s\u0000\u0000\u0000 \u0000\u0000\u0000\u0000y \u0000\u0000\u0000\u0000 \u0000l\u0000\u0000\u0000i\u0000\u0000m \u0000\u0000\u0000m (a) w\u0000\u0000\u0000\u0000-s\u0000\u0000t(A) \u0000\u0000 \u0000\u0000\u0000d \u0000l\u0000m\u0000\u0000t l \u0000\u0000 \u0000\u0000 e\u0000ist\u0000 u\u0000i\u0000g \u0000i\u0000\u0000r\u0000 se\u0000r\u0000h retur\u0000 \u0000i\u0000\u0000r\u0000-se\u0000r\u0000h(l, A\u0000 == l end 1 2 3 4 5 6 7 8 9 10 11 12 4.5 (a) The number of function calls to f is given below. We will now show that T (n) = Θ(nn), by deﬁnition of Θ. Let g(n) = nn. T (n) = n ∑ i= 1 ni ∑ j= 1 1 (constant sum) = n ∑ i= 1 ni (adjust range) = ( n ∑ i= 0 ni) − 1 (finite geometric series, n ≠ 1) = nn+1 − 1 n − 1 − 1 = nn+1 − n n − 1 1 lim n→∞ T (n) g(n) = lim n→∞ nn+1−n n−1 nn = lim n→∞ nn+1 − n nn(n − 1) = lim n→∞ (1 − 1 nn ) (1 − 1 n ) = lim n→∞ 1 1 = 1 ∈ R ⟹ T (n) = Θ(nn) □ nn+1 nn+1 − 1 nn+1 − 1 n (b) The number of calls to f is given by the following. Since we assume the function T to be increasing, we can drop the restriction on n being even. The master theorem on (1) implies that T (n) ≤ O(n2). We will now show that T (n) ≥ Ω(n2). Let g(n) = T ( n 2 ) + n2. The master theorem on (2) implies that g(n) ≤ O(T (n)), which in turn implies T (n) ≥ Ω(n2). Since T (n) ≤ O(n2) and T (n) ≥ Ω(n2), we can conclude that T (n) = Θ(n2). □ T (n) = 3T (⌊ n 2 ⌋) + n ∑ i= 1 n ∑ j= i 2 = 3T (⌊ n 2 ⌋) + n ∑ i= 1 n ∑ j= i 2 = 3T (⌊ n 2 ⌋) + 2 n ∑ i= 1 (n + 1 − i) = 3T (⌊ n 2 ⌋) + n(n + 1) = 3T (⌊ n 2 ⌋) + n2 + n ≤ 3T ( n 2 ) + 2n2 (1) g(n) ≤ T (n) ≤ 3T ( n 2 ) + 2n2 (2)","libVersion":"0.5.0","langs":""}