{"path":"sem2/PProg/VRL/slides/PProg-L23-ABA.pdf","text":"spcl.inf.ethz.ch @spcl_eth TORSTEN HOEFLER Parallel Programming Lock free and ABA How it started: How it’s going: spcl.inf.ethz.ch @spcl_eth ▪ Optimistic list-based sets ▪ Lazy synchronization Single wait-free traversal, wait-free contains ▪ Lazy skip lists ▪ Real data structure ▪ Lock-free ▪ CAS (repeat) Summary/recap last lecture 2 spcl.inf.ethz.ch @spcl_eth ▪ Lock-free unbounded queue ▪ Sentinels in front and back ▪ Reuse and ABA problem ▪ Pointer tagging ▪ Hazard pointers Learning goals today 3 spcl.inf.ethz.ch @spcl_eth LOCK FREE UNBOUNDED QUEUE 4 spcl.inf.ethz.ch @spcl_eth At the heart of an Operating System is a scheduler. A scheduler basically moves tasks between queues (or similar data structures) and selects threads to run on a processor core. Scheduling decisions usually happen when threads are created, threads end, threads block / wait, and threads unblock 5 Motivation: a Lock-Free Operating System Kernel Processor Core Processor Core Processor Core wait for x wait for y run run run ready Queue spcl.inf.ethz.ch @spcl_eth Data structures of a runtime or kernel need to be protected against concurrent access by ▪ threads and ▪ interrupt service routines on different cores. Conventionally, (spin-)locks are employed for protection. The granularity varies. 6 Motivation: a Lock-Free Operating System Kernel Processor Core Processor Core Processor Core run run run wait for x wait for y ready spcl.inf.ethz.ch @spcl_eth If we want to protect scheduling queues in a lock-free way, we obviously need - an implementation of a lock-free unbounded queue We will again meet the problem of transient inconsistencies - if we want to use the queues in an OS scheduler, usually we cannot rely on Garbage Collection, we need to reuse elements of the queue This will lead to a difficult problem, the ABA problem 7 Motivation: a Lock-Free Operating System Kernel spcl.inf.ethz.ch @spcl_eth public class Node<T> { public T item; public Node<T> next; public Node(T item) { this.item = item; this.next = null } } 8 Unbounded Queue Node item next item next item next NULL spcl.inf.ethz.ch @spcl_eth public class BlockingQueue<T> { Node<T> head, tail; public synchronized void Enqueue(T item) { } public synchronized T Dequeue() { } } 9 Blocking Unbounded Queue item next item next item next NULL head tail spcl.inf.ethz.ch @spcl_eth public synchronized void Enqueue(T item) { Node<T> node = new Node<T>(item); if (tail != null) tail.next = node; else head = node; tail = node; } case tail = null case tail != null 10 Enqueue node node node node node node head tail new ① ② head tail new ① ② spcl.inf.ethz.ch @spcl_eth 11 Dequeue case head == tail case head != tail node node node node node node head tail① ② node head tail ① public synchronized T Dequeue() { T item = null; Node<T> node = head; if (node != null) { item = node.item; head = node.next; if (head == null) tail = null; } return item; } spcl.inf.ethz.ch @spcl_eth It turns out that when we want to implement a lock-free queue like this, we run into problems because of potentially simultaneous updates of ▪ head ▪ tail ▪ tail.next How to solve this? 12 Observation spcl.inf.ethz.ch @spcl_eth 13 Idea: Sentinel at the front S node node node node node head tail spcl.inf.ethz.ch @spcl_eth 14 Sentinel at the front: Enqueue S node node node node node head tail node ① ② S head tail node ① ② operations • read/write tail.next • read/write tail empty Q nonempty Q spcl.inf.ethz.ch @spcl_eth 15 Sentinel at the front: Dequeue S node node node node node head tail S head tail node ① Read value ① Read value ② ② 1 element n elements operations • reading head.next • read/write head spcl.inf.ethz.ch @spcl_eth Still have to update two pointers at a time! ▪ But enqueuers work on tail and dequeuers on head Possible inconsistency? ▪ tail might (transiently) not point to the last element What's the problem with this? ▪ Unacceptable that any thread has to wait for the consistency to be established -- this would be locking camouflaged Solution ▪ Threads help making progress 16 Does this help? spcl.inf.ethz.ch @spcl_eth public class Node<T> { public T item; public AtomicReference<Node> next; public Node(T item) { next = new AtomicReference<Node>(null); this.item = item; } public void SetItem(T item) { this.item = item; } } 17 Lock-free Queue Node needs Atomic next pointer item next item next item next NULL spcl.inf.ethz.ch @spcl_eth public class NonBlockingQueue extends Queue { AtomicReference<Node> head = new AtomicReference<Node>(); AtomicReference<Node> tail = new AtomicReference<Node>(); public NonBlockingQueue() { Node node = new Node(null); head.set(node); tail.set(node); } public void Enqueue(T item); public T Dequeue(); } 18 Unbounded Lock-free (NonBlocking) Queue item next item next item next NULL spcl.inf.ethz.ch @spcl_eth Enqueuer ▪ read tail into last ▪ then tries to set last.next: CAS(last.next, null, new) ▪ If unsuccessful retry! ▪ If successful, try to set tail without retry CAS(tail, last, new) Dequeuer ▪ read head into first ▪ read first.next into next ▪ if next is available, read the item value of next ▪ try to set head from first to next CAS(head, first, next) ▪ If unsuccessful, retry! 19 Protocol: Initial Version node tail node ① ② S node head ① Read value ② spcl.inf.ethz.ch @spcl_eth 20 Protocol node tail node ① ② How can this be unsuccessful? 1. Some other thread has written last.next just before me 2. I have read a stale version of tail either a) because I just missed the update of other thread b) because the other thread failed in updating tail, for example because it has died If the thread dies before calling this, tail is never updated. Enqueuer ▪ read tail into last ▪ then tries to set last.next: CAS(last.next, null, new) ▪ If unsuccessful retry! ▪ If successful, try to set tail without retry CAS(tail, last, new) spcl.inf.ethz.ch @spcl_eth 21 Protocol How can this be unsuccessful? 1. another thread has already removed next S node head ① Read value ② Dequeuer ▪ read head into first ▪ read first.next into next ▪ if next is available, read the item value of next ▪ try to set head from first to next CAS(head, first, next) ▪ If unsuccessful, retry! spcl.inf.ethz.ch @spcl_eth ▪ Thread A enqueues an element to an empty list, but has not yet adapted tail ▪ Thread B dequeues (the sentinel) ▪ Now tail points to a dequeued element. 22 One more possible inconsistency S tail node head S tail node head spcl.inf.ethz.ch @spcl_eth public void enqueue(T item) { Node node = new Node(item); while(true) { Node last = tail.get(); Node next = last.next.get(); if (next == null) { if (last.next.compareAndSet(null, node)) { tail.compareAndSet(last, node); return; } } else tail.compareAndSet(last, next); } } 23 Final solution: enqueue Create the new node Read current tail as last and last.next as next Try to set last.next from null to node, if success then try to set tail Ensure progress by advancing tail pointer if required and retry Help other threads to make progress ! spcl.inf.ethz.ch @spcl_eth public T dequeue() { while (true) { Node first = head.get(); Node last = tail.get(); Node next = first.next.get(); if (first == last) { if (next == null) return null; else tail.compareAndSet(last, next); } else { T value = next.item; if (head.compareAndSet(first, next)) return value; } } } 24 Final solution: dequeue Read head as first, tail as last and first.next as next Check if queue looks empty (1) really empty: return (2) next available: advance last pointer (helping) If queue is not empty, memorize value on next element and try to remove current sentinel Retry if removal was unsuccessful Help other threads to make progress ! spcl.inf.ethz.ch @spcl_eth REUSE AND THE ABA PROBLEM 25 spcl.inf.ethz.ch @spcl_eth public class ConcurrentStack { AtomicReference<Node> top = new AtomicReference<Node>(); public void push(Long item) { … } public Long pop() { … } } 26 For the sake of simplicity: back to the stack ☺ item next item next item next NULL top spcl.inf.ethz.ch @spcl_eth public Long pop() { Node head, next; do { head = top.get(); if (head == null) return null; next = head.next; } while (!top.compareAndSet(head, next)); return head.item; } 27 Lock-free pop A B C NULL top head next Memorize \"current stack state\" in local variable head Action is taken only if \"the stack state\" did not change spcl.inf.ethz.ch @spcl_eth public void push(Long item) { Node newi = new Node(item); Node head; do { head = top.get(); newi.next = head; } while (!top.compareAndSet(head, newi)); } 28 push A B C NULL top head newi Memorize \"current stack state\" in local variable head Action is taken only if \"the stack state\" did not change","libVersion":"0.3.2","langs":""}