{"path":"sem1/EProg/extra/EProg_pvw_HS22.pdf","text":"Skript für den Prüfungsvoerbereitungs Workshop Einführung in die Programmierung Stand: Herbstsemester 2017 David Blaser, Julian Croci 3. Januar 2019 1 Inhaltsverzeichnis 0 Vorwort und Disclaimer 5 1 EBNF 6 1.1 Deﬁnitionen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 1.2 Rekursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 1.3 Tabelle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 1.4 Graﬁsche Darstellung einer EBNF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 1.5 Übungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 1.6 Lösungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 2 Einfache Java Programme 11 2.1 Einfache Programme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2.2 Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2.3 Typen und Variablen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2.4 Arithmetische Ausdrücke . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2.5 Variablen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.6 Methoden . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.7 Boolean Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.8 if-else . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.9 Schleifen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 2.10 Übungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.11 Lösungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 3 Arrays 17 3.1 Eindimensionale Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 3.2 Mehrdimensionale Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 3.3 Übungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 4 Klassen 19 4.1 Einführung und Erstellung von Objekten . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 4.2 Reference Semantic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 5 Input/Output 21 5.1 Auf der Konsole . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 5.2 Von einem File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 2 5.3 Übungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 6 Objekte 23 6.1 Abstraktion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 6.2 Attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 6.3 Methoden . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 6.4 Konstruktoren . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 6.5 Namensräume . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 6.6 static . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 6.7 Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 6.8 Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 6.9 Übungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 6.10 Lösungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 7 Arbeiten mit Objekten und Klassen 30 7.1 Einführung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 7.2 Beispiel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 7.3 Übungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 7.4 Lösungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 8 Vererbung 33 8.1 Einführung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 8.2 Beispiel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 8.3 Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 8.4 Übungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 8.5 Lösungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 9 Exceptions 36 9.1 Einführung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 9.2 checked und unchecked Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 9.3 Beispiele . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 9.4 Übungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 9.5 Lösungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 10 Generische Programmierung 40 10.1 Einführung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 10.2 Beispiel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 3 10.3 Collections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 10.4 Übungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 10.5 Lösungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 11 Systematisches Programmieren 43 11.1 Pre- und Postconditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 11.2 Hoare Tripels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 11.3 Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 11.4 Ein paar Worte zu JUnit-Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 11.5 Übungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 11.6 Lösungen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 4 Vorwort und Disclaimer Liebe Studierenden, wir freuen uns, dass du das Skript der Lernunterstützungskommission des VIS benützt und wir wünschen dir schon mal jetzt viel Erfolg bei den Prüfungen. Wir wollen ausdrücklich darauf Hinweisen, dass dieses Skript keinen Anspruch auf Korrektheit auf und insbesondere auf Vollständigkeit erhebt. Der Relevante Prüfungsstoﬀ wird von Professor Gross und den Hauptassistenten kommuniziert und festgelegt. Dennoch hoﬀen wir, dich mit diesem Skript Unterstützen zu können. Aus Erfahrung gilt, dass die Übungsserien eine sehr gute Vorbereitung auf die Prüfung sind. In diesem Skript ﬁndet ihr noch weitere Übungen und jeweils eine kurze Zusammenfassung des Stoﬀes. Die Hauptkapitel sind so durch nummeriert, dass die Nummerierung der Vorlesung von Professor Gross aus dem Herbstsemester 2017 übereinstimmen. Leider ist dies bei den Unterkapiteln nicht mehr der Fall. Sollten während dem Lernen fragen auftauchen, empfehlen wir euch wärmstens, diese in den entsprechenden Channeln unter chat.vis.ethz.ch zu stellen. Feedback zum Script gerne an blaserd@vis.ethz.ch oder crocij@vis.ethz.ch 5 EBNF EBNFs können benützt werden, um die Syntax einer Programmiersprachen zu beschreiben. EBNFs besitzen vier Elemente (\"control forms\") die man auch in Java wiederﬁndet: • Aufreihung (”sequence”) • Entscheidung oder Auswahl (”decision”) • Wiederholung (”repetition”) • rekursion (”recursion”) Deﬁnitionen Eine EBNF Beschreibung besteht aus einer Menge EBNF Regeln. Eine EBNF Regel besteht aus einer Linken Seite (LHS) und einer Rechten Seite (RHS). LHS and RHS werden durch ⇐ verbunden. Der ⇐ bedeutet “ist deﬁniert als“. Die LHS ist der Name der EBNF Regel und wird kursiv oder in <> geschrieben. Die RHS ist die Beschreibung für die LHS. Beispiele • <Digit> ⇐ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 • Zug ⇐ Lok Wagen Wagen Control Forms Folgende control forms können auf der Rechten Seite der EBNF Regel eingesetzt werden. • Aufreihung: Elemente in Ordnung von links nach rechts gelesen • Auswahl: Menge von Alternativen, getrennt durch | • Option: Element in [ und ], kann gewählt werden, muss aber nicht • Wiederholung: Element in { und }, das Element kann 0, 1 oder mehrmals genommen werden Beispiele • Auswahl: <Digit> ⇐ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 • Aufreihung: <Zug> ⇐ Lok Wagen Wagen • Option: <127> ⇐ [-] 127 • Wiederholung: <Positive Zahl> ⇐ <Digit> { <Digit> } 6 Rekursion Rekursion ist manchmal nötig um komplizierte Symbole zu beschreiben. Es können alle Wiederholungen durch Rekursion ausgedrückt werden, hingegen nicht jede Rekursion durch Wiederholungen. Es gibt direkte Rekursion und indirekte Rekursion: Bei der direkte Rekursion erscheint die LHS direkt wieder auf der RHS. Bei der indirekten Rekursion wird der Kreis über mehrere Regeln geschlossen. Beachte: Es sollte immer einen Ausweg aus der Rekursion geben. Beispiele • Direkte Rekursion: <Viele Einsen> ⇐ 1 [ <Viele Einsen> ] • Indirekte Rekursion: – <Regel1> ⇐ Bla [ <Regel2> ] – <Regel2> ⇐ Blup [ <Regel1> ] • Endlose Rekursion: <Viele Einsen> ⇐ 1 <Viele Einsen> Tabelle Mithilfe der Tabelle kann man zeigen, dass ein gegebenes Wort von der EBNF Beschreibung akzeptiert wird. Auf der ersten Zeile der Tabelle steht der Name, mit der das Symbol übereinstimmen soll. Die weiteren Zeile der Tabelle werden jeweils aus der Vorgängerzeile durch eine der folgenden Regeln abgeleitet: 1. Ersetze einen Namen (LHS) durch die entsprechende Deﬁnition (RHS) 2. Wahl einer Alternative 3. Entscheidung ob ein optionales Element dabei ist oder nicht 4. Bestimmung der Zahl der Wiederholungen Schritt eins und zwei werden manchmal in einem Schritt gemacht. Beispiel Wir beachten die EBNF deﬁniert durch die folgenden Regeln und möchten zeigen, dass -127.9 akzeptiert wird. Zur Gruppierung werden ( und ) verwendet. • <Zahl> ⇐ [ <Vorzeichen> ] <Ziﬀer> { <Ziﬀer> } [ . < Ziﬀer> { <Ziﬀer> } ] • <Ziﬀer> ⇐ 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 • <Vorzeichen> ⇐ + | - 7 <Zahl> Anfang [ <Vorzeichen> ] <Ziﬀer> { <Ziﬀer> } [ . < Ziﬀer> { <Ziﬀer> } ] Regel Zahl <Vorzeichen> <Ziﬀer> { <Ziﬀer> } [ . < Ziﬀer> { <Ziﬀer> } ] Option gewählt (+ | - ) <Ziﬀer> { <Ziﬀer> } [ . < Ziﬀer> { <Ziﬀer> } ] Regel Vorzeichen - <Ziﬀer> { <Ziﬀer> } [ . < Ziﬀer> { <Ziﬀer> } ] Auswahl - - 1 { <Ziﬀer> } [ . < Ziﬀer> { <Ziﬀer> } ] Regel Ziﬀer und Auswahl 1 - 1 <Ziﬀer> <Ziﬀer> [ . < Ziﬀer> { <Ziﬀer> } ] Wiederholung 2 mal - 1 2 <Ziﬀer> [ . < Ziﬀer> { <Ziﬀer> } ] Regel Ziﬀer und Auswahl 2 - 1 2 7 [ . < Ziﬀer> { <Ziﬀer> } ] Regel Ziﬀer und Auswahl 7 - 1 2 7 . < Ziﬀer> { <Ziﬀer> } Option gewählt - 1 2 7 . 9 { <Ziﬀer> } Regel Ziﬀer und Auswahl 9 - 1 2 7 . 9 Wiederholung 0 mal Graﬁsche Darstellung einer EBNF Mit einem Syntax Graph lässt sich eine EBNF darstellen und es ist einfach zu erkennen, welche Zeichen und Symbole in einer Reihenfolge auftreten müssen. Von links nach rechts werden für die Aufreihung Elemente verbunden, eine Auswahl wird durch eine Leiter dargestellt. Eine Option wird durch eine Leiter dargestellt, die eine ”leere” Zeile hat. Eine Wiederholung realisiert man gleich wie eine Option, signalisiert mit einem Pfeil zurück aber noch, dass eine Wiederholung möglich ist. Beispiel Folgende Graﬁk ist aus den Slides zur Vorlesung: Übungen Prinzipiell sind die Übungen aus den Serien eine sehr gut Vorbereitung. Hier darum nur eine kleine Übung: 8 1. Die folgenden EBNFs sollten genau jene Wörter zulassen, in denen für jedes X entweder ein Y oder drei Z als Gruppe auftreten. Beispiel für legale Symbole: ”XY”, ”XXYZZZ”, ” ”, ”XYYXZZZX” Leider sind beide falsch, ﬁnde jeweils den Fehler und ein Beispielwort, welches akzeptiert wird, obwohl es nicht sollte oder umgekehrt. 1. • <xyz> ⇐ [ X <xyz> <folge> ] • <folge> ⇐ Y | ZZZ 2. • <xyz> ⇐ [ { <xy> | <xzz> } ] • <xy> ⇐ XY | YX • <xzz> ⇐ XZZ | ZZX | ZXZ 2. Die folgenden EBNFs sollten genau jene Wörter akzeptieren, die folgende Anforderungen erfüllen: • Ein Wort besteht ausschliesslich aus den Symbolen A, B, C, X, Y, Z. • Ein Wort beginnt mit A und endet mit B. • Nach jedem X kommt entweder ein Y oder ein Z. Y und Z können nur direkt nach einem X auftreten. • C kann nur in Paaren auftreten (CC) und kann nicht direkt nach einem Z folgen. Beispiele legaler Symbole: ”AB”, ”ACCB”, ”AXZB”, ”ABAB”, ”AXYXZXZXYCCB” Leider sind alle falsch, ﬁnde jeweils den Fehler und ein Beispielwort, welches akzeptiert wird, obwohl es nicht sollte oder umgekehrt. 1. • <abc> ⇐ A {CC} <comb> B • <comb>⇐ [ (<comb> X ((Y [CC]) | Z) <comb> ) | (<comb> A [ CC ] <comb>) | (<comb> B [CC] <comb>) ] 2. • <abc> ⇐ A [ { <c> | <xyz> | A | B } ] B • <xyz> ⇐ XY | XZ • <c> ⇐ ACC | CCA | BCC | CCB | CCXY | CCXZ | YCC 3. • <abc> ⇐ A<inner>B • <s1> ⇐ A | B • <s2> ⇐ CC • <s3> ⇐ X (Y | Z) • <inner> ⇐ { [<s2>] [ {<s3>} <s1>] } 4. • <abc> ⇐ A { { <buchstaben> } | {<b2>} } B • <buchstaben> ⇐ A | B | <spezial> • <spezial> ⇐ XY | XZ • <b2> ⇐ A | B | XY | CC 5. • <abc> ⇐ A <c> { XY <c> | XZ } B • <c> ⇐ { | CC} 9 Lösungen 1 1. Es werden nur Wörter zugelassen, die alle x-en am Anfang haben. Ein Beispiel für ein Wort, welches akzeptiert werden sollte aber nicht wird ist: XYXZZZ 2. Es werden pro X nur zwei Z produziert, nicht drei. Es könnten auch nicht drei oder mehr Y oder ZZZ ”Gruppen” hintereinander gemacht werden. Ein Beispiel für ein Wort, welches akzeptiert werden sollte aber nicht wird ist: XYYYXX 2 1. Es werden nicht beliebig viele CCs akzeptiert, obwohl es so sein sollte. Ein Beispiel für ein Wort, welches akzeptiert werden sollte aber nicht wird ist: ACCACCCCB. 2. Nach einem Z sollten keine CCs möglich sein, sind aber. Folgendes Wort sollte illegal sein, wird aber akzeptiert: ACCXZCCAB 3. Ein Beispiel für ein Wort, welches akzeptiert werden sollte aber nicht wird ist: AXYCCB 4. Folgendes Wort sollte illegal sein, wird aber akzeptiert: AXZCCB 5. Die Möglichkeit A oder B mitten im Wort zu haben fehlt. Ein Beispiel für ein Wort, welches akzeptiert werden sollte aber nicht wird ist: ABAB 10 Einfache Java Programme Einfache Programme Java Programme bestehen immer aus mindestens einer Klasse mit einer main Methode: p u b l i c c l a s s HelloWorld { p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) { System . out . p r i n t l n ( \" H e l l o World\" ) ; } } Der Klassen Name sollte immer mit dem Namen des entsprechenden Files übereinstimmen. Oberes Programm wäre also in dem File HelloWorld.java gespeichert. Strings Ein String ist eine Folge von Charakteren, eingeschlossen in Klammern. ”Hallo I bims, ein String” ist zum Beispiel ein String. Strings können sogenannte Ersatz Darstellungen enthalten, wie zum Beispiel: • \\n Neue Zeile • \\t Tab character • \\” Quotation mark • \\\\Backslash Strings können in Java mit dem + Charakter zusammengehängt werden. Zum Beispiel ”Hello” + ”World”. Typen und Variablen Typen beschrieben Eigenschaften von Daten. Der Typ schränkt die Operationen, die mit Daten gemacht werden können. Viele Programmiersprachen erfordern, dass man den Typ explizit angibt, so auch in Java. Es gibt 8 simple in Java eingebaute Typen, die wichtigsten 4 sind die folgenden: • int Ganze Zahlen (1, 20, -5, etc.) • double Reelle Zahlen (1.2, -6.5, 0.0, etc.) • char einzelne Buchstaben (’A’, ’x’, ’*’ , etc.) • boolean Logische Werte (true, false) Arithmetische Ausdrücke Ausdrücke (”Expressions”) sind Werte oder Operationen die einen Wert berechnen. 1 + (5 * 0.5) ist zum Beispiel ein Ausdruck. Ausdrücke haben auch einen Typen. Es gibt die bekannten vier Grundrechenarten plus zusätzlich den Modulus (%) Operator, der den Rest der Division ganzer Zahlen zurück gibt. Generell gilt, dass Expressions von links nach rechts ausgewertet werden, allerdngs gilt Punkt vor Strich (Modulo gilt als Punkt). Mit Klammern kann man die Reihenfolge wie aus der Schule gewohnt anpassen. Normalerweise haben Expressions den Typ der Typen die kombiniert werden. Werden int und double gemischt hat die Epxression den Typ double. 11 Spezialfälle • Wenn wir ganze Zahlen dividieren ist das Ergebnis auch wieder eine ganze Zahl. 14 /4 gibt also 3 und nicht 3.5. • Division durch 0 gibt einen Laufzeitfehler. Variablen Variablen speichern Werte. Um Variablen zu gebrauchen muss man sie zuerst deklarieren, dann initialisieren und dann gebrauchen. Variablen werden wie folgt: • deklariert: type name;, konkret zum Beispiel int zahl; • initialisiert: name = expression;, konkret zum Beispiel zahl = 5 - 2; Dies kann öfters geschehen • gebraucht: 10 + 1 - zahl Methoden Methoden sind eine Sequenz von Anweisungen, die sich über einen Namen aufrufen lassen. Sie können einen Rückga- bewert haben und Parameter entgegen nehmen. Im Moment betrachten wir nur statische Methoden. Alle statischen Methoden fangen so an: static type name(args). Dies nennt man die Signatur einer Methode. Methoden werden so aufgerufen: methodenName(args); Hier ein Beispiel um es zu verdeutlichen. p u b l i c c l a s s MyProgram { p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) { System . out . p r i n t l n ( mul ( 5 , 5 ∗ 3 ) ) ; // Argumente werden auch h i e r // durch Komma g e t r e n n t } s t a t i c i n t s q r t ( i n t arg1 , i n t a r g 2 ) { // das i n t g i b t den r e t u r n Type an , // i n t a r g ∗ i s t d e r t y p e und d e r Name // d e s Arguments . // Argumente werden durch , g e t r e n n t i n t r e s u l t = a r g 1 ∗ a r g 2 ; r e t u r n r e s u l t ; } } Boolean Expressions Boolean Expressions sind Expressions, die vom type boolean sind. Es gibt zwei Arten von Operatoren, Operatoren, die zwei numerische Werte vergleichen und Operatoren, die booleans kombinieren. Zuerst zu den Vergleichsopera- toren. • zahl1 <= zahl2 kleiner gleich • zahl1 < zahl2 kleiner • zahl1 >= zahl2 grösser gleich 12 • zahl1 > zahl2 grösser • zahl1 == zahl2 gleich Die Ausdrücke evaluieren zu true, wenn die Gleichung wahr ist. Arithmetische Ausdrücke haben höhere Präzedenz als Vergleichsoperatoren. Ebenfalls gilt es zu beachten, dass Vergleichsoperatoren keine Kette bilden können wie in der Mathematik. 2 < x < 3 gehen also nicht, dies ist, weil zuerst 2 < 3 ausgewertet wird und den type boolean hat und man diesen nachher nicht mit 3 vergleichen kann. Nun zu den Booleschen Operatoren: • bool1 && bool2 logisches und • bool1 || bool2 logisches oder • ! bool nicht Booleasche Operatoren haben eine niedere Präzedenz als Vergleichsoperatoren. Short Circuit Evaluation Um Rechenzeit zu sparen, wird der zweite boolsche Ausdruck für && nur ausgewertet, wenn der erste wahr ist. Gleiches gilt für ||, der zweite boolsche Ausdruck wird nur ausgewertet, wenn der erste falsch ist. Beispiele ﬁnden sich in den kommenden Beispielen zu if-else und Schleifen. if-else if und else können benutzt werden, um Entscheidungen zu machen. Sie folgen intuitiv Ihrer jeweiligen Bedeutung, auf Deutsch also falls und sonst. Folgendes Beispiel illustriert dies. p u b l i c c l a s s MyProgram { p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) { i n t number1 = 1 ; i n t number2 = 1 0 ; i n t number3 = 1 0 0 ; testNumbers ( number1 ) ; testNumbers ( number2 ) ; testNumbers ( number3 ) ; } s t a t i c v o i d testNumbers ( i n t a r g ) { i f ( a r g <= 0 ) { // a r g <= 0 i s t d e r Test System . out . p r i n t l n ( a r g + \" i s t k l e i n e r g l e i c h 0\" ) ; } e l s e i f ( a r g < 1 0 ) { // e l s e und i f l a s s e n s i c h k o m b i n i e r e n System . out . p r i n t l n ( a r g + \" i s t e i n s t e l l i g \" ) ; } e l s e i f ( a r g < 1 0 0 ) { System . out . p r i n t l n ( a r g + \" i s t z w e i s t e l l i g \" ) ; } e l s e { // l e t z t e s e l s e ohne i f und daher auch ohne t e s t System . out . p r i n t l n ( a r g + \" i s t d r e i − o d e r m e h r s t e l l i g e r \" ) ; } } } // Output d e s Programmes : 13 // 1 i s t e i n s t e l l i g // 10 i s t z w e i s t e l l i g // 100 i s t d r e i − oder m e h r s t e l l i g Wie wir sehen muss der test für eine if Anweisung immer ein Ausdruck vom type boolean sein. Ebenfalls sehen wir, dass sich if und else Anweisungen zu einer else if Anweisung kombinieren lassen. Schleifen Schleifen ermöglichen es, einen bestimme Sequenz von Instruktionen mehrmals auszuführen. Ähnlich wie bei der if Anweisung gibt es immer einen Test (der vor jeder Ausführung der Schleife geprüft wird). In Java gibt es drei Arten von Loops. for-Loop Bei einem for Loop hat man die Möglichkeit, die sich ändernde Variable direkt in der for Anweisung zu deﬁnieren/i- nitalisieren. Ebenfalls kann man das Update dieser Laufvariable direkt dort ausführen. Das ganze sieht schematisch so aus: for (Laufvariable; Test: Update) { ... } . f o r ( i n t i = 0 ; i < 1 0 ; i = i + 1 ) { System . out . p r i n t ( i + \" ; \" ) ; } // Output 0 ; 1 ; 2 ; 3 ; 4 ; 5 ; 6 ; 7 ; 8 ; 9 ; // 10 wird n i c h t mehr a u s g e g e b e n , da 10 < 10 f a l s c h i s t . // 0 wird a u s g e g e b e n , w e i l das u p d a t e j e w e i l s nach d e r // Ausfuehrung d e s L o o p b o d i e s g e s c h i e h t . while-Loop Der while-Loop ist dem for-Loop relativ ähnlich, allerdings muss das Updaten der Laufvariable innerhalb des Loop-Bodies geschehen und man muss die Laufvariable ausserhalb des Loops deﬁnieren und initialisieren. Dies hat natürlich auch den Vorteil, dass man den Wert der Laufvariable auch noch nach dem Loop hat. Das ganze sieht dann schematisch wie folgt aus: while (test) {...}. Dieses Beispiel macht das slebe wie das Beispiel oben. i n t i = 0 ; w h i l e ( i < 1 0 ) { System . out . p r i n t l n ( i + \" ; \" ) ; i = i + 1 ; } do-while-Loop Der do-while-Loop ist dem while-Loop ähnlich, unterscheidet sich aber insofern, dass der Loop-Body mindestens einmal ausgeführt wird. Schematisch sieht dies so aus: do { ... } while (test); i n t i = 1 1 ; do { System . out . p r i n t l n ( i + \" ; \" ) ; i = i + 1 ; } w h i l e ( i < 1 0 ) ; // Output : 1 1 ; 14 Klassiﬁzierung von Schleifen Man unterscheidet zwischen unbestimmten (indeﬁnite loop) und bestimmten Schleifen (deﬁnite Loop). Bei be- stimmten Schleifen ist von Anfang an bekannt, wie oft die Schleife ausgeführt wird, zum Beispiel wenn es darum geht, die Zahlen zwischen 0 und 10 auszugeben. Bei unbestimmten Schleifen ist die Anzahl der Anführungen im voraus nicht bekannt, zum Beispiel wenn man auf eine speziﬁsche Nutzereingabe wartet. Eine Schleife, die auf ein spezielles Hinweiszeichen, einen Sentinel, wartet heisst sentinel loop. Solch ein Hinweiszei- chen kann man zum Beispiel benutzen, wenn man dem User die Möglichkeit geben möchte, das Programm durch einen Befehl zu beenden. Übungen 1 Sind die folgenden Ausdrücke gültig und wenn ja, was ergeben sie? 1. (5 / 2) * 2.0 2. (1 < 5 < 10) 3. 3.0 + 5 / 4 4. 3 + 5 % 4 5. (x < 5) || (x >= 5) 6. (5.0 / 2) - (10 / 2) 2 1. Schreibe eine statische Methode, die überprüft ob eine übergebene Zahl eine Primzahl ist. 2. Schreibe ein Programm, dass die Zahlen von 1 bis n durch ein Komma getrennt ausgibt, also zum Beispiel 1, 2, 3, 4 15 Lösungen 1 1. 4.0 2. Error 3. 4.0 4. 4 5. true (wenn x deﬁniert ist) 6. -2.5 16 Arrays Eindimensionale Arrays In einem Array können wir mehrere Werte des selben Typs speichern. Die Elemente eines Arrays werden von 0 bis zur Länge - 1 nummeriert. Bei der Initialisierung des Arrays werden alle Werte auf einen Wert gesetzt, der 0 entspricht. Im folgenden Beispiel wird aufgezeigt, wie mit Arrays gearbeitet werden kann. p u b l i c s t a t i c v o i d s p a s s M i t A r r a y s ( ) { i n t [ ] z a h l e n = new i n t [ 1 0 ] ; // I n i t i a l i s i e r u n g d e s Arrays f o r ( i n t i = 0 ; i < z a h l e n . l e n g t h ; i ++) { System . out . p r i n t ( z a h l e n [ i ] + \" ; \" ) ; } // Output : 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; System . out . p r i n t l n ( ) ; f o r ( i n t i = 0 ; i < z a h l e n . l e n g t h ; i ++) { z a h l e n [ i ] = i ; } f o r ( i n t i = 0 ; i < z a h l e n . l e n g t h ; i ++) { System . out . p r i n t ( z a h l e n [ i ] + \" ; \" ) ; } // Output : 0 ; 1 ; 2 ; 3 ; 4 ; 5 ; 6 ; 7 ; 8 ; 9 ; System . out . p r i n t l n ( ) ; d o u b l e [ ] kommaZahlen = { 1 . 0 , 2 . 0 , 3 . 0 , 4 . 0 , 5 . 0 } ; f o r ( i n t i = 0 ; i < kommaZahlen . l e n g t h ; i ++) { System . out . p r i n t ( kommaZahlen [ i ] + \" ; \" ) ; } // Output : 1 . 0 ; 2 . 0 ; 3 . 0 ; 4 . 0 ; 5 . 0 ; } Mehrdimensionale Arrays In Java kann man ebenfalls Arrays von Arrays anlegen, dadurch kann man Matrizen ”simulieren”. ”Simulieren”, da Arrays nicht unbedingt einer klassischen Matrix aus LinAlg entsprechen müssen. Zum Beispiel können unter Arrays verschieden lang sein, wie im folgenden Beispiel illustriert wird. p u b l i c s t a t i c v o i d s p a s s M i t M u l t i A r r a y s ( ) { i n t [ ] [ ] z a h l e n = new i n t [ 3 ] [ ] ; // I n i t i a l i s i e r u n g d e s Arrays f o r ( i n t i = 0 ; i < z a h l e n . l e n g t h ; i ++) { System . out . p r i n t ( z a h l e n [ i ] + \" ; \" ) ; } // Output : n u l l ; n u l l ; n u l l ; System . out . p r i n t l n ( ) ; f o r ( i n t i = 0 ; i < z a h l e n . l e n g t h ; i ++) { z a h l e n [ i ] = new i n t [ i + 1 ] ; } f o r ( i n t i = 0 ; i < z a h l e n . l e n g t h ; i ++) { System . out . p r i n t ( z a h l e n [ i ] . l e n g t h + \" ; \" ) ; 17 } // Output : 1 ; 2 ; 3 ; System . out . p r i n t l n ( ) ; f o r ( i n t i = 0 ; i < z a h l e n . l e n g t h ; i ++) { System . out . p r i n t ( \"{ \" ) ; f o r ( i n t j = 0 ; j < z a h l e n [ i ] . l e n g t h ; j ++) { System . out . p r i n t ( z a h l e n [ i ] [ j ] + \" \" ) ; } System . out . p r i n t ( \"}\" ) ; } // Output : { 0 }{ 0 0 }{ 0 0 0 } System . out . p r i n t l n ( ) ; d o u b l e [ ] [ ] kommaZahlen = { { 1 . 0 } , { 2 . 0 , 2 . 0 } , { 3 . 0 , 3 . 0 , 3 . 0 } } ; f o r ( i n t i = 0 ; i < kommaZahlen . l e n g t h ; i ++) { System . out . p r i n t ( \"{ \" ) ; f o r ( i n t j = 0 ; j < kommaZahlen [ i ] . l e n g t h ; j ++) { System . out . p r i n t ( kommaZahlen [ i ] [ j ] + \" \" ) ; } System . out . p r i n t ( \"}\" ) ; } // Output : { 1 . 0 }{ 2 . 0 2 . 0 }{ 3 . 0 3 . 0 3 . 0 } } Übungen 1. Implementiere eine Matrixmultiplikation, überlege dir, wie der User den Input eingeben kann und vergiss nicht, zu überprüfen ob sein Input Sinn macht. 2. Schreibe eine Funktion, die als Argument ein int-Array bekommt und ein neues int Array zurückgibt, in welchem die Werte der Eingabe in umgekehrter Reihenfolge sind. Benutze keine temporären Variablen um Werte aus dem Array zu speichern. 18 Klassen Dies hier ist nur ein kurzer Überblick, mehr ﬁndet ihr im Kapitel 6. Einführung und Erstellung von Objekten Klassen beschreiben einen Typ. Typen beschreiben Eigenschaften von Daten. Objekte sind Repräsentation von Typen zur Laufzeit des Programmes. Man könnte sagen, Klassen sind die Anleitungen um Objekte zu erschaﬀen und beschreiben, welche Fähigkeiten und Eigenschaften Objekte haben. Um mit einem Objekt zu arbeiten, muss es zuerst erschaﬀen werden. Entweder mit dem new Keyword oder durch eine Initialisierung. Random rand ; rand = new Random ( ) ; // E r s c h a f f u n g mit new Keyword Scanner c o n s o l e = new Scanner ( System . i n ) ; // kann auch a u f d e r g l e i c h e n L i n i e // e r l e d i g t werden S t r i n g s ; s = \" H e l l o \" + \"World ! \" ; // E r s c h a f f u n g durch I n i t i a l i s i e r u n g S t r i n g s 2 = \" H e l l o \" + \" World kompakt\" ; Objekte können von anderen Klassen benutzt werden, diese heissen Klienten oder auf Englisch client programs. Reference Semantic Anders als bei int, boolean, double und noch ein paar Anderen werden Referenzen zu den Objekten in Variablen gespeichert, nicht die Objekte selbst. Übertragen kann man es sich so vorstellen, dass nur die Adresse für den Ort gespeichert wird, an dem sich das Objekt beﬁndet, nicht aber das Objekt selbst. Dies bedeutet, dass wenn ich etwas an dem Objekt ändere, diese Änderungen auch an anderen Stelen zum Vorschein treten können. Das gleiche gilt insbesondere wenn Funktionen Dinge an Objekten ändern, die sie als Argument bekommen haben. Da Arrays auch Objekte sind, möchte ich es in diesem Beispiel kurz illustrieren. p u b l i c c l a s s Main { 19 p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) { i n t [ ] a1 = { 1 , 2 } ; i n t [ ] a2 = a1 ; s w a p F i r s t 2 ( a1 ) ; f o r ( i n t i = 0 ; i < a1 . l e n g t h ; i ++) { System . out . p r i n t ( a1 [ i ] + \" \" ) ; } System . out . p r i n t l n ( ) ; f o r ( i n t i = 0 ; i < a2 . l e n g t h ; i ++) { System . out . p r i n t ( a2 [ i ] + \" \" ) ; } } p u b l i c s t a t i c v o i d s w a p F i r s t 2 ( i n t [ ] a r r ) { i f ( a r r . l e n g t h < 2 ) { // Nothing t o swap r e t u r n ; } e l s e { i n t temp = a r r [ 0 ] ; a r r [ 0 ] = a r r [ 1 ] ; a r r [ 1 ] = temp ; } } } // Output o f t h e whole program : // 2 1 // 2 1 Generell spricht man von reference Semantics (Objekte) und value semantics (primitive types wie int etc.). 20 Input/Output Auf der Konsole Der Output auf die Konsole wurde bereits in einigen Beispielen benutzt. Mit System.out.println(”MyString”); Wird MyString auf der Konsole ausgegeben. Zusätzlich wird dem String noch ein \\n (new-line character) angehängt. Mit System.out.print(”MyString”); wird MyString ausgegeben ohne new-line character. Um Text von der Konsole einzulesen, muss man zuerst ein Scanner Objekt erstellen , diesem geben wir System.in als Parameter im Konstruktor, also haben wir insgesamt: Scanner scanner = new Scanner(System.in);. Um jetzt etwas einzulesen kann man die folgenden Funktionen der Scanner Klasse benutzen: nextLine(), nextDouble(), nextInt() etc. Werden die Werte von der Konsole eingelesen wartet das Programm auf die Eingabe. Was zu be- denken ist, ist dass eine Exception geworfen wird, sollte das gelesene nicht dem gewünschten Datentyp entspricht, doch dazu später mehr. Folgendes Beispiel liest eine Zeile von der Konsole ein und gibt sie wieder aus. Scanner s c a n n e r = new Scanner ( System . i n ) ; System . out . p r i n t l n ( \"Geben S i e etwas e i n \" ) ; S t r i n g i n p u t = s c a n n e r . n e x t L i n e ( ) ; System . out . p r i n t l n ( i n p u t ) ; Von einem File Die Klasse File erlaubt Operationen mit Files. Wir können wie folgend ein neues File Objekt erstellen: File f = new File(”example.txt”);. Nun können wir wieder einen Scanner benutzen, um auf die Inhalte des Fi- les zuzugreifen: Scanner scanner = new Scanner(f); oder kombiniert: Scanner scanner = new Scanner(new File(”example.txt”));. Eclipse wird uns nun sagen, das wir uns um eine Exception kümmern müssen. Zu den Exceptions später mehr. Folgendes Beispielprogramm gibt ungefähr den Inhalt des Files auf der Konsole aus. p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) throws FileNotFoundException { // F a l l s das F i l e n i c h t e x i s t i e r t Scanner s c a n n e r = new Scanner ( new F i l e ( ’ ’ example . t x t ’ ’ ) ; w h i l e ( s c a n n e r . hasNextLine ( ) ) { S t r i n g i n p u t = s c a n n e r . n e x t L i n e ( ) ; System . out . p r i n t l n ( i n p u t ) ; } } Wir sehen im Beispiel oben, dass wir eine Funktion hasNextLine() benützen, um zu überprüfen, ob es ein nächstes Token gibt, das den korrekten Typ hat. Sollte keines existieren, wird beim Aufruf von next*(); eine Exception geworfen. Daher gibt es für alle next*() Methoden der Scanner Klasse auch eine entsprechende has*(); Funktion. Für den Output gibt es die Klasse PrintStream. Ein Objekt dieser Klasse können wir nachher wie das bereits bekannten System.out verwenden. PrintStream output = new PrintsStream(new File(”out.txt”)); kreiert ein PrintStream Objekt, mit welchem man in das File out.txt zu schreiben. Um eine Zeile hinzuzufügen kann man folgendes machen: output.println(”Hello File”);. Doch es ist Vorsicht geboten, existiert das speziﬁzierte File bereits, wird es überschrieben. Folgendes Beispiel gibt die Zahlen von 0 bis 9 Zeilenweise im File zahlen.txt aus. PrintStream output = new PrintStream ( new F i l e ( ’ ’ z a h l e n . t x t ’ ’ ) ) ; f o r ( i n t i = 0 ; i < 1 0 ; i = i + 1 ) { output . p r i n t l n ( i ) ; } 21 Übungen 1. Schreibe ein Programm, welches ein File liest und ausgibt, wie oft ein speziﬁsches Wort vorkommt. Schreibe dein eigenes File um es zu testen. 2. Schreibe ein Programm, welches ein File liest und nachher ein neues File macht, in dem alle Zeilen in umgekehrter Richtung sind. Die Funktion toCharArray() der Klasse String ist vielleicht nützlich. 22 Objekte Abstraktion Wichtig für das erstellen sinnvoller Klassen ist, dass man sich zuerst bewusst wird, welche Informationen wir für unseren Zweck überhaupt brauchen. Brauchen wir für die Analyse der Gesundheit von Personen wirklich die Farbe des T-Shirts, welches sie bei der Messung getragen haben? Wissen wir diese überhaupt? Abstraktionen sind reduzierte Beschreibungen. Sie sind weder falsch noch richtig aber können für den Zweck nützlich oder nicht sein. ”Gerät das Musik spielen kann” ist für viele wohl die nützlichere Abstraktion eines iPods als ”Gehäuse mit Halbleiterplatinen drin”. Trotzdem sind beide Abstraktionen korrekt. Attribute Attribute speichern den Zustand eines Objektes. Sollte kein Konstruktor (dazu später) vorhanden sein, werden sie bei der Erstellung des Objektes auf einen Wert gesetzt, der 0 entspricht. Für Objekte ist dies null. Die sogenannten null Reference ist ein Wert, der vereinfacht gesagt anzeigt, dass kein Objekt existiert beziehungsweise die Variable auf kein Objekt zeigt. Es ist verboten, auf Attribute und Methoden einer null reference zuzugreifen, es erzeugt einen Laufzeitfehler. In folgendem Beispiel möchte ich aufzeigen, was Attribute sind und wie man testet, ob etwas null ist. Dafür kann man auch Shortcircuit evaluation ausnutzen. p u b l i c c l a s s Main { p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) { Car c a r = new Car ( ) ; System . out . p r i n t l n ( c a r . w h e e l s + \" \" + c a r . c u b i c C a p a c i t y ) ; i f ( c a r . brand != n u l l ) { // Check i f brand S t r i n g e x i s t s System . out . p r i n t l n ( brand ) ; } e l s e { System . out . p r i n t l n ( \"No Brand found \" ) ; } i f ( c a r != n u l l && c a r . w h e e l s < 4 ) { // Use s h o r t c i r c u i t e v a l u a t i o n t o w r i t e s i m p l e r code System . out . p r i n t l n ( \"what a funny c a r \" ) ; } } } c l a s s Car { i n t w h e e l s ; d o u b l e c u b i c C a p a c i t y ; S t r i n g brand ; } // Output o f t h e whole program : // 0 0 . 0 // No Brand found // what a funny c a r Methoden Klassen können zwei verschiedene Arten von Methoden beinhalten. Statische Methoden und Instanzmethoden. Statische Methoden sind schon bekannt, Math.abs() ist zum Beispiel eine statische Methode. Statische Metho- den existieren innerhalb einer Klasse genau einmal und können nur auf andere statische Methoden und Attribute 23 zugreifen. Im Gegensatz dazu hat jedes Objekt seine eigenen Instanzmethoden. Instanzmethoden können auf al- le Attribute des Objektes zugreifen. Instanzmethoden müssen immer über ein Objekt aufgerufen werden, also zum Beispiel: object.myInstanceMethod();. Statische Methoden werden immer über die Klasse aufgerufen, zum Beispiel: MyClass.myStaticMethod();. Das Objekt, auf welchem die Instanzmethode aufgerufen wird, heisst Im- pliziter Parameter und kann über das Keyword this aufgerufen werden. Folgendes Beispiel soll die Unterscheide verdeutlichen. p u b l i c c l a s s Main { p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) { Point p o i n t O b j e c t = new Point ( ) ; p o i n t O b j e c t . x = 5 ; p o i n t O b j e c t . y = 1 0 ; System . out . p r i n t l n ( p o i n t O b j e c t . d i s t a n c e T o O r i g i n ( ) ) ; System . out . p r i n t l n ( Point . c o n s t a n t S q u a r e ( ) ) ; System . out . p r i n t l n ( p o i n t O b j e c t . c o n s t a n t S q u a r e ( ) ) ; // System . o u t . p r i n t l n ( P o i n t . d i s t a n c e T o O r i g i n ( ) ) ; Doesn ’ t work } } c l a s s Point { d o u b l e x ; d o u b l e y ; s t a t i c i n t CONSTANT = 1 0 ; p u b l i c d o u b l e d i s t a n c e T o O r i g i n ( ) { r e t u r n Math . s q r t ( x∗x + y∗y ) ; // Here I c o u l d a c c e s s CONSTANT } p u b l i c s t a t i c i n t c o n s t a n t S q u a r e ( ) { r e t u r n CONSTANT ∗ CONSTANT; // In t h i s method I can ’ t a c c e s s x or y } } // Output o f t h e whole program : // 11.180339887498949 // 100 // 100 Konstruktoren Bis jetzt haben wir neue Objekte immer mit dem default Constructor konstruiert. Dies ist ein Anfang, es geht aber auch besser. Wir können nämlich auch einen eigene Konstruktoren schreiben. So sehen sie aus: public MyClass(...) {...}. Wie wir sehen wird kein Rückgabewert deﬁniert. Möchte man mehrere Konstruktoren schrei- ben, kommen die selben Regeln zum Zug wie beim Überladen von Methoden (dazu später mehr). Wir können auch den default constructor überschreiben, dazu ebenfalls später mehr. In folgendem Beispiel füge ich der Klasse Point mehrere Konstruktoren hinzu. p u b l i c c l a s s Main { p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) { Point p1 , p2 , p3 ; p1 = new Point ( 2 . 0 , 2 . 5 ) ; p2 = new Point ( 3 ) ; p3 = new Point ( ) ; System . out . p r i n t l n ( p1 . x + \" \" p1 . y ) ; // 2 . 0 2 . 5 24 System . out . p r i n t l n ( p2 . x + \" \" p2 . y ) ; // 3 . 0 3 . 0 System . out . p r i n t l n ( p3 . x + \" \" p3 . y ) ; // 1 . 0 1 . 0 } } c l a s s Point { d o u b l e x ; d o u b l e y ; p u b l i c Point ( d o u b l e x I n i t , d o u b l e y I n i t ) { x = x I n i t ; y = y I n i t ; } p u b l i c Point ( d o u b l e xy ) { x = xy ; y = xy ; } p u b l i c Point ( ) { // O v e r r i d e o f d e f a u l t c o n s t r u c t o r x = 1 ; y = 1 ; } } Namensräume Encapsulation Die Idee von Encapsulation ist, die Implementationsdetails einer Klasse vor dem Klienten der Klasse zu verstecken. Dadurch werden die Daten des Objektes vor unbeabsichtigten oder unerwünschten Operationen geschützt. Durch die Trennung von Verhalten (extern sichtbar) und Zustand/Implementation (intern) wird erlaubt, dass man die Implementation einer Klasse ändert, ohne die Klienten ändern zu müssen. Dies setzt natürlich voraus, dass man sich Gedanken über das verhalten der Klasse zu Beginn macht. Um Attribute vor der Aussenwelt der Klasse zu schützen, wird das Keyword private benutzt. Insgesamt sieht dies dann so aus: private type name; als konkretes Beispiel private int answer;. Nur Methoden die innerhalb der Klasse deﬁniert sind können auf private Attribute zugreifen. Getter und Setter Methoden Um von ausserhalb der Klasse auf private Attribute zuzugreifen, muss man Accessor und Mutator Methoden zur Verfügung stellen. Dadurch kann die Klasse zum Beispiel Buchführen über die Anzahl der Abfragen eines Wertes oder Regeln vorgeben, an welche sich die Werte halten müssen. Zur Illustration das folgende Beispiel: p u b l i c c l a s s Main { p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) { Point p1 = new Point ( ) ; } } c l a s s Point { 25 p r i v a t e d o u b l e x ; p r i v a t e d o u b l e y ; p u b l i c Point ( ) { // O v e r r i d e o f d e f a u l t c o n s t r u c t o r x = 1 ; y = 1 ; } p u b l i c d o u b l e getX ( ) { // G e t t e r X r e t u r n x ; } p u b l i c d o u b l e getY ( ) { // G e t t e r Y r e t u r n Y; } p u b l i c v o i d setX ( d o u b l e v a l u e ) { i f ( v a l u e > 0 && v a l u e < 1 0 0 ) // S p e c i a l Rule f o r x x = v a l u e ; } p u b l i c v o i d setY ( d o u b l e v a l u e ) { i f ( v a l u e > 0 && v a l u e < 1 0 0 ) // S p e c i a l Rule f o r y y = v a l u e ; } } Methoden können ebenfalls private gemacht werden. Shadowing Generell gilt in Java, dass eine Variable im Block, in welchem sie deﬁniert wurde und in allen Blöcken innerhalb dieses Blockes gültig ist und dass es keine zwei gültigen Variablen mit dem selben Namen geben darf. Nun führen wir eine Ausnahme ein. Lokale Variablen und Argumente innerhalb einer Funktion oder des Konstruktors dürfen nämlich gleich heissen wie ein Attribut der Klasse der Funktion. Diese Argumente oder lokalen Variablen verdecken die Attribute, das nennt man Shadowing. Um trotzdem auf die Attribute zugreifen zu können benützt man das Keyword this. Folgendes Beispiel zeigt wie. p u b l i c c l a s s Main { p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) { Point p1 ; p1 = new Point ( 2 . 0 , 2 . 5 ) ; } } c l a s s Point { d o u b l e x ; d o u b l e y ; p u b l i c Point ( d o u b l e x , d o u b l e y ) { t h i s . x = x ; // t h i s . x / t h i s . y s i n d d i e A t t r i b u t e d e r K l a s s e t h i s . y = y ; } 26 } static Wie bereits beschrieben sind static Variablen und Methoden nicht Teil eines Objekts sondern Teil einer Klasse. static Variablen existieren nur einmal, unabhängig wie viele Objekte der Klasse existieren. Statische Variablen und Methoden sollten die Ausnahme sein. Insbesondere ist zu beachten, dass static Variablen, wenn sie nicht final sind geändert werden können und sich folglich für alle Objekte und Klienten der Klasse, sollten die Variablen nicht private sein, ändern. Dadurch kann man schnell die Übersicht verlieren und mit mühsamen Bugs konfrontiert sein. Deswegen macht man sehr häuﬁg statische Variablen, die nach aussen sichtbar sind, final. Module Module sind Teile eines Programms, welche nicht direkt ausgeführt werden können und von Klienten verwendet werden sollen. Math ist ein Beispiel dafür. Um diese Module zu schreiben benützt man statische Methoden und Fel- der. Dadurch sehen wir auch, wie wir auf statische Methoden beziehungsweise Attribute zugreifen können, nämlich so: Class.method(parameters) beziehungsweise Class.attribute. In einem konkreten Beispiel: Math.abs(-5) beziehungsweise Math.PI. Overloading In Java ist es möglich, dass in einer Klasse mehrere Methoden mit demselben Namen vorkommen, wenn sie über unterschiedliche Parameter verfügen. Dabei müssen sich die Parameter mindestens in ihrer Anzahl, oder in ihren Typen unterscheiden, lediglich unterschiedliche Namen sind nicht möglich. Dieses Konzept nennt sich Überladung oder Overlading von Methoden. Ein anderer Rückgabetyp ist nicht möglich. Dazu ein kleines Beispiel: p u b l i c c l a s s O v e r l o a d i n g { p u b l i c i n t add ( i n t a , i n t b ) { r e t u r n a + b ; } p u b l i c i n t add ( i n t a ) { r e t u r n add ( a , 1 ) ; // o f t m a l s A u f r u f e i n e r Version mit mehr Parametern ( mit Konstanten ) } p u b l i c i n t add ( i n t b ) { // d i e s e Method i s t n i c h t e r l a u b t r e t u r n add ( b , 0 ) ; } p u b l i c i n t add ( b o o l e a n a ) { // d i e s e a b e r i s t e r l a u b t r e t u r n 0 ; } } Übungen 1. Finde alle Fehler im folgenden Programm: 27 1 p u b l i c c l a s s Main { 2 p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) { 3 Point p1 ; 4 p1 = new Point ( 2 . 0 , 2 . 5 ) ; 5 System . out . p r i n t l n ( p1 . x + \" \" + p1 . y + \" \" + p1 . l e n g t h ) ; 6 Point [ ] p o i n t A r r = new Point [ Random . n e x t I n t ( 1 0 0 ) + 1 ] 7 f o r ( i n t i = 0 ; i < p o i n t A r r . l e n g t h − 1 ; i ++) { 8 p o i n t A r r [ i ] = new Point (Random . n e x t I n t ( 1 0 0 ) , Random . n e x t I n t ( 1 0 0 ) ) ; 9 } 10 System . out . p r i n t l n ( p o i n t A r r [ i ] . x + \" \" p o i n t A r r [ i ] . y ) ; 11 } 12 } 13 14 c l a s s Point { 15 d o u b l e x ; 16 d o u b l e y ; 17 p r i v a t e d o u b l e l e n g t h ; 18 19 p u b l i c Point ( d o u b l e x , d o u b l e y ) { 20 t h i s . x = x ; // t h i s . x / t h i s . y s i n d d i e A t t r i b u t e d e r K l a s s e 21 t h i s . y = y ; 22 t h i s . l e n g t h = Math . s q r t ( x ∗ x + y ∗ y ) ; 23 } 24 25 p u b l i c Point ( ) { 26 x = p1 . x ; 27 y = p1 . x 28 } 29 } 28 Lösungen 1. • In Zeile 5 kann nicht auf p1.length zugegriﬀen werden, da das Attribut private ist. • i ist nur innerhalb des Loops deﬁniert, darum existiert es in Zeile 10 nicht mehr. • Zeile 7: Es werden nicht alle Punkte initialisiert weil der Loop nicht weit genug geht, darum gibt es bei Zeile 10 eine NullPointerException. (Wenn man annimmt, dass i korrekt ausserhalb des for-Loops deﬁniert worden wäre.) • Im Namespace der Klasse Point ist p1 nicht deﬁniert, darum sind Zeilen 24 und 25 falsch. 29 Arbeiten mit Objekten und Klassen Einführung In der Vorlesung wurden in diesem Kapitel ein Paar Beispiele zu Objekten besprochen. Daher folgen nun einige weitere Übungsaufgaben. Beispiel Zuerst eine Beispielklasse für die nachfolgenden Übungen, eine weitere Version von Point: p u b l i c c l a s s Point { p r i v a t e i n t x = 1 ; p r i v a t e i n t y = 1 ; // auch beim D e f i n i e r e n d e r A t t r i b u t e kann man S t a n d a r d w e r t e angeben , das // e r s p a r t uns h i e r das U e b e r s c h r e i b e n d e s d e f a u l t C o n s t u r c t o r s . p u b l i c s t a t i c f i n a l i n t ANTWORT = 4 2 ; p u b l i c s t a t i c S t r i n g f r a g e n ( ) { r e t u r n \" Die Antwort i s t \" + ANTWORT + \" . \" ; } p u b l i c i n t getX ( ) { r e t u r n x ; } p u b l i c v o i d setX ( i n t x ) { i f ( x >= 0 ) t h i s . x = x ; } p u b l i c i n t getY ( ) { r e t u r n y ; } p u b l i c v o i d setY ( i n t y ) { i f ( y >= 0 ) t h i s . y = y ; } p u b l i c l o n g g e t D i s t a n c e T o O r i g e n ( ) { r e t u r n Math . round ( e x a c t D i s t a n c e ( ) ) ; } p r i v a t e d o u b l e e x a c t D i s t a n c e ( ) { r e t u r n Math . s q r t ( x∗x + y∗y ) ; } } 30 Übungen 1. Der folgende Code verwendet (als Klient) die obenstehende Point-Klasse. Was wird durch ihn ausgegeben? System . out . p r i n t l n ( Point . f r a g e n ( ) ) ; Point p = new Point ( ) ; Point p2 = n u l l ; p . setX ( 8 ) ; p . setY ( −1); System . out . p r i n t l n ( \"Der Punkt b e f i n d e t s i c h b e i ( \" + p . getX ( ) + \" , \" + p . getY ( ) + \" ) . \" ) ; System . out . p r i n t l n ( p . g e t D i s t a n c e T o O r i g e n ( ) ) ; 2. Nun wird versucht, die folgenden Codezeilen jeweils einzeln direkt nach dem Code aus der vorhergehenden Aufgabe auszuführen. Gib an, ob dies erfolgreich ist. Falls es fehlschlägt, gib an, ob der Code gar nicht Kompiliert, oder ob es erst zur Laufzeit zu einem Fehler kommt. 1 i n t antw = Point .ANTWORT; 2 S t r i n g was = p . f r a g e n ( ) ; 3 i n t x = Point . x ; 4 i n t y = p . y ; 5 i n t y = p2 . getY ( ) ; 3. Pippi Langstrumpf meint, dass zwei mal drei vier ergebe. Daher ist sie mit der Multiplikation in Java unzufrieden, und du sollst ihr ein Modul schreiben, das multiplizieren kann. Dazu soll es eine Funktion anbieten, die zwei Ints als Argumente nimmt und einen Int zurückgibt, wobei sie für zwei mal drei vier zurückgeben sollte.;) Du darfst in dem Modul auch noch weitere Funktionen einbauen, (z.B. solle es neun geben, wenn man zu zwei mal drei nochmal drei dazu nimmt) und einige (statische) Attribute ergänzen. (z.B. eine Glückszahl) 4. Pippi hat keine Lust, ein Modul zu verwenden, denn das sei nur etwas für Erwachsene. Daher sollst du ein Programm schreiben, das das Modul verwendet. Es soll immer fortwährend zwei Zahlen von der Konsole auslesen, sie „richtig“ multiplizieren und das Ergebnis ausgeben. Da das Programm auch für Kinder geeignet sein soll, darf es unter keinen Umständen abstürzen, wenn etwas anderes als eine Zahl eingegeben wird. 5. Einige Programme enthalten sogenannte Easter Eggs. Dabei handelt es sich um verstecke, meist witzige Funktionen. Eines kann z.B. gefunden werden, indem in Firefox „about:robots“ in die Adresszeile eingegeben wird. Da das in Aufgabe 4. geschriebene Programm sowieso ein Witz ist, kann es gut mit einem Easter Egg erweitert werden: Immer wenn der Benutzer das Wort „Glück“ in die Konsole eintippt, soll umgehend die Glückszahl ausgegeben werden. 31 Lösungen 1. Ausgabe: Die Antwort i s t 4 2 . Der Punkt b e f i n d e t s i c h b e i ( 8 , 1 ) . 8 2. Lösung: 1 E r f o l g r e i c h 2 E r f o l g r e i c h ( E c l i p s e g i b t a b e r e i n e Warnung aus ) 3 K o m p i l i e r t n i c h t , da x n i c h t s t a t i c i s t 4 K o m p i l i e r t n i c h t , da x n i c h t s i c h t b a r i s t 5 V e r u r s a c h t beim Ausfuehren e i n e N u l l P o i n t e r E x c e p t i o n , da p2 == n u l l i s t 32 Vererbung Einführung In den vorhergehenden Kapiteln haben wir gesehen, wie Konzepte (als Abstraktion, d.h. Reduktion auf die rele- vanten Informationen) in Klassen dargestellt werden können. Es kommt dabei oft vor, dass ähnliche, aber doch verschiedene Konzepte dargestellt werden sollen. So könnte man in einem Beispiel Fahrzeuge haben, und als Spe- zialformen davon Autos und Fahrräder. Diese Konzepte haben viele gemeinsame Eigenschaften (z.B. eine Anzahl an Rädern) und Funktionen (z.B. fahren). Um wiederzugeben, dass ein Konzept eine Spezialform von einem anderen ist, wird Vererbung (Englisch inheritan- ce) eingesetzt. Dadurch kann auch vermieden werden, dass gemeinsame Eigenschaften und Funktionen mehrfach implementiert werden müssen. Um anzugeben, dass eine Klasse, die Subclass (oder Kindklasse) von einer anderen Klasse, der Superclass (oder Elternklasse) erbt, wird das Keyword extends verwendet. Dadurch übernimmt die Subclass alle Attribute und alle Methoden der Supperclass. Jedoch können in der Kindklasse die Methoden der Elternklasse überschrieben (overriden) werden, so dass sie ein anderes verhalten zeigen. Beispiel p u b l i c c l a s s V e h i c l e { p u b l i c i n t numberOfWheels ; p u b l i c V e h i c l e ( i n t w h e e l s ) { t h i s . numberOfWheels = w h e e l s ; } p u b l i c v o i d d r i v e ( ) { System . out . p r i n t l n ( \"Woosh\" ) ; } } p u b l i c c l a s s Car e x t e n d s V e h i c l e { p u b l i c Car ( ) { s u p e r ( 4 ) ; } @Override p u b l i c v o i d d r i v e ( ) { System . out . p r i n t l n ( \"Brumm\" ) ; } } p u b l i c c l a s s B i c y c l e e x t e n d s V e h i c l e { p u b l i c B i c y c l e ( ) { s u p e r ( 2 ) ; } @Override p u b l i c v o i d d r i v e ( ) { System . out . p r i n t l n ( \" S u r r r \" ) ; } } 33 Interfaces Im Zusammenhang mit Vererbung ist auch das Konzept eines Interfaces wichtig. Ein Interface ist ähnlich wie eine Klasse, die jedoch nicht instanziiert werden kann. (Also ähnlich wie eine abstrakte Klasse) Zudem dürfen Interfaces keine Implementationen für Funktionen enthalten, sie geben also nur die Signaturen von Methoden vor. Weiter erbt eine Klasse nie von einem Interface, stattdessen wird ein Interface implementiert, (Dies wird durch das implements Keyword angegeben) wobei eine Klasse auch mehrere Interfaces implementieren kann. (Hingegen kann eine Klasse in Java immer nur von einer Klasse erben) Im vorhergehen Beispiel könnte man, wenn man nicht will, dass generische Vehicles erstellt werden können, Vehicle durch ein Interface ersetzten. (Dann wäre aber die nachfolgende Übung nicht mehr ganz korrekt) Übungen 1. Gegeben ist der folgende Code, der die Klassen aus dem vorherigen Beispiel verwendet: V e h i c l e [ ] v e h i c l e s = new V e h i c l e [ 3 ] ; v e h i c l e s [ 0 ] = new V e h i c l e ( 7 ) ; v e h i c l e s [ 1 ] = new Car ( ) ; v e h i c l e s [ 2 ] = new B i c y c l e ( ) ; f o r ( i n t i = 0 ; i < v e h i c l e s . l e n g t h ; i ++) { v e h i c l e s [ i ] . d r i v e ( ) ; System . out . p r i n t l n ( \" V e h i c l e \" + i + \" has \" + v e h i c l e s [ i ] . numberOfWheels + \" w h e e l s . \" ) ; Was wird durch diesen Code ausgegeben? 2. In dieser Aufgabe sollen einige Klassen geschrieben werden, die verschiedene Typen von Flugzeugen darstellen. Ein Flugzeug hat jeweils eine Anzahl an Sitzplätzen, eine aktuelle Geschwindigkeit sowie eine maximale Geschwindigkeit. Zudem soll eine Methode zum setzen der aktuellen Geschwindigkeit vorhanden sein, die sicherstellt, dass die maximale Geschwindigkeit nie überschritten wird. Analog dazu sollen auch Attribute und Methoden für die Flughöhe vorhanden sein. Die benötigten Flugzeugtypen und ihre Speziﬁkationen sind in der folgenden Tabelle angegeben. Alle Flugzeuge sollen (direkt oder indirekt) Subclassen von einer (abstrakten) Klasse Flugzeug sein. Dabei soll eine Vererbungsstruktur so aufgebaut werden, das möglichst wenig Code doppelt geschrieben werden muss. Name Anzahl Sitzplätze Max Geschwindigkeit (Knoten) Max Flughöhe (Fuss) Kleinﬂugzeug 10 300 30’000 Ultraleichtﬂugzeug 2 130 15’000 Segelﬂugzeug 2 150 15’000 Grossraumﬂugzeug Variabel* 600 40’000 *Soll dem Konstruktor als Argument übergeben werden. 3. (Zusatzaufgabe) Die vorherige Aufgabe soll nun so erweitert werden, dass ein Aufruf von System.out. println(flugzeug); (wobei flugzeug eine Referenz zu einer Instanz von irgendeiner der zuvor erstellten Klassen ist) dazu führt, dass sinnvolle Informationen über die referenzierte Instanz ausgegeben werden. 34 Lösungen 1. Ausgabe: Woosh V e h i c l e 0 has 7 w h e e l s . Brumm V e h i c l e 1 has 4 w h e e l s . S u r r r V e h i c l e 2 has 2 w h e e l s . 35 Exceptions Einführung Bis jetzt wurde in einigen Beispielen (z.B. aus der Vorlesung) im Falle eines Fehlers, zum Beispiel einer fehlerhaften Eingabe oder eines ungültigen Argumentes, einfach das Programm beendet. Das ist aber oftmals keine besonders elegante Lösung. So wäre es unpraktisch, wenn ein Taschenrechnerprogramm abstürzt, wenn eine Division durch 0 auftritt. Allgemein wäre es dazu praktisch, wenn eine Funktion der Funktion, die sie aufgerufen hat, mitteilen könnte, wenn irgendetwas schief ging. (z.B weil ungültige Argumente übergeben wurden) Das wird in Java durch Exceptions ermöglicht. Eine Exception (zu Deutsch Ausnahme) kann durch eine Methode geworfen werden, wenn ein Fehler auftritt. Dadurch wird die Excpetion an die Methode, welche die werfende Methode aufgerufen hat, weitergegeben. Diese aufrufende Methode kann die Exception fangen (”catchen”), und versuchen, den Fehler zu behandeln. Falls die Exception jedoch nicht gefangen wird, wird sie wiederum an die aufrufende Methode der aufrufenden Methode weitergegeben. So wird weiter verfahren, bis eine Methode die Exception fängt, oder aber die main-Methode des Programms erreicht wird. Falls auch die main-Methode die Exception nicht fängt, wird das Programm beendet, und es wird eine Fehlermeldung auf der Konsole ausgegeben. Zum Fangen einer Exception wird ein sogenannter try-chatch-Blcok verwendet. (Siehe Beispiel unten) checked und unchecked Exceptions Es gibt zwei Typen von Exceptions. Einerseits solche, die vom Programm behandelt werden können, diese heissen checked Exceptions. Immer wenn es möglich ist, dass eine solche Exception geworfen wird, muss sie entweder gefangen werden, oder die aktuelle Methode muss ankündigen, dass diese Exception geworfen wird. (Dafür wird das throws Keyword in der Methodensignatur verwendet) Dazu gehört beispielsweise die FileNotFoundException. Anderseits gibt es aber auch unchekced Exceptions, dies werden in der Regel durch das Java Laufzeitsystem geworfen. Diese können zwar auch gefangen werden, aber das ist oft nicht sinnvoll, den oftmals ist das Programm nicht in der Lage, diese Fehler zu beheben. Denn solche Exception deuten entweder auf einen Fehler im Programm (z.B. bei einer NullPointerException) oder ein Problem bei der Laufzeitumgebung, die ein Programm nicht beheben kann (z.B. OutOfMemoryError), hin. Daher ist es bei solche Exceptions oftmals die einzige sinnvolle Lösung, das Programm abstürzen zu lassen. Beispiele new FileReader(\"Dateiname\") kann eine FileNotFoundException werfen. Das ist eine checked Exception, d.h. sie kann entweder gefangen (und behandelt) werden, ... p u b l i c s t a t i c Scanner o p e n F i l e ( ) { t r y { r e t u r n new Scanner ( new F i l e R e a d e r ( \" data . t x t \" ) ) ; } c a t c h ( FileNotFoundException ex ) { System . out . p r i n t l n ( \" F e h l e r : Die D a t e i mit den Daten e x i s t i e r t n i c h t . \" ) ; r e t u r n n u l l ; } } ... oder es muss angekündigt werden, dass möglicherweise eine solche Exception geworfen wird. p u b l i c s t a t i c Scanner openFileThrowing ( ) throws FileNotFoundException { r e t u r n new Scanner ( new F i l e R e a d e r ( \" data . t x t \" ) ) ; } 36 Anders hier: Dieser Code führt deﬁnitiv zu einer NullPointerException, aber diese muss weder gefangen noch angekündigt werden. Sie sollte meistens zu einem Programmabsturz führen. p u b l i c s t a t i c i n t r e a d I n t ( ) { Scanner s c = n u l l ; // d e r Scanner i s t n u l l . . . r e t u r n s c . n e x t I n t ( ) ; // . . . daher wird h i e r e i n e N u l l P o i n t e r E x c e p t i o n g e w o r f e n . } Da eine Division durch 0 (mit Ints) nicht möglich ist, wirft diese Methode in diesem Fall eine IllegalArgumentEx- ception, die zudem auch eine hilfreiche Nachricht enthält. Die IllegalArgumentException ist aber unchecked, und muss daher nicht angekündigt werden. p u b l i c s t a t i c i n t d i v i d e ( i n t a , i n t b ) { i f ( b == 0 ) { throw new I l l e g a l A r g u m e n t E x c e p t i o n ( \" D i v i s i o n durch 0 n i c h t m o e l g l i c h . \" ) ; } r e t u r n a/b ; } Wenn hingegen nicht geprüft wird, ob der Divisor 0 ist, so kann es bei der Division zu einer ArithmeticException kommen. Diese wird durch das Laufzeitsystem geworfen, und ist ebenfalls eine unchecked Exception. p u b l i c s t a t i c i n t d i v i d e U n s a f e ( i n t a , i n t b ) { r e t u r n a/b ; // Wenn b == 0 i s t , so wird h i e r e i n e E x c e p t i o n g e w o r f e n . } Übungen 1. Was wird durch den folgenden Code, der die obenstehenden Funktionen verwendet, ausgegeben, wenn keine Datei mit dem Namen ”data.txt” im Arbeitsverzeichnis existiert? Beachte dabei, dass beim Catchen eines bestimmten Typs von Exceptions auch alle Subtypen davon gecatcht werden. Zudem wird von einem try- catch-Block immer nur eine Excpetion gefangen. Denn nachdem die erste Exception geworfen wurde, wird die Ausführung des Codes im try-Block abgebrochen. o p e n F i l e ( ) ; t r y { openFileThrowing ( ) ; } c a t c h ( FileNotFoundException e ) { System . out . p r i n t l n ( \" F e h l e r : D a t e i e x i s t i e r t n i c h t . \" ) ; } t r y { i n t i = r e a d I n t ( ) ; d i v i d e ( i , 0 ) ; } c a t c h ( N u l l P o i n t e r E x c e p t i o n e ) { System . out . p r i n t l n ( \" N u l l P o i n t e r E x c e p t i o n ! Das Program i s t kaput ! \" ) ; } c a t c h ( E x c e p t i o n e ) { System . out . p r i n t l n ( \" I r g e n d e w a s u n e r w a r t e t s g i n g s c h i e f . \" ) ; } t r y { d i v i d e ( 7 , 0 ) ; d i v i d e U n s a f e ( 1 , 0 ) ; } c a t c h ( RuntimeException e ) { System . out . p r i n t l n ( \" F e h l e r : \" + e . getMessage ( ) ) ; } 37 2. Passe deine Lösung zur Aufgabe 2. aus dem vorherigen Kapitel so an, dass jeweils eine IllegalArgument- Exception (mit einer hilfreichen Nachricht) geworfen wird, wenn versucht wird, die aktuelle Geschwindigkeit oder Flughöhe auf einen ungültigen Wert zu setzten. 38 Lösungen 1. Ausgabe: F e h l e r : Die D a t e i mit den Daten e x i s t i e r t n i c h t . F e h l e r : D a t e i e x i s t i e r t n i c h t . N u l l P o i n t e r E x c e p t i o n ! Das Program i s t kaput ! F e h l e r : D i v i s i o n durch 0 n i c h t m o e g l i c h . 39 Generische Programmierung Einführung In einigen Übungsserien kam es vor, dass eine Struktur, die Daten speichert, z.B. eine verkettete Liste, umgeschrie- ben werden musste, um einen anderen Type an Daten zu speichern. So gab es zwei verschiedene verkettete Listen für Personen und Integers. Diese unterschieden sich aber im wesentlichen nur im Type des Feldes value, ansonsten enteilten sie fast ausschliesslich duplizierten Code. Als Lösung für dieses Problem existiert in Java das Konzept der generischen Programmierung. Dieses ermöglicht sogenannte Typenparameter, damit kann einer Klasse dann, wenn eine Instanz davon erstellt wird, ein (oder mehrere) Typen als Argument übergeben werden. Dadurch ist es möglich, die in der Klasse verwendeten Typen erst beim Instanziieren festzulegen, zuvor können sie allgemein (generisch) gehalten werden. Dadurch wird es beispielsweise möglich, dieselbe Listenimplementation für verschiedene Datentypen zu verwenden. Dennoch kann aber sichergestellt werden, dass in einer bestimmten Listeninstanz nur Daten von einem bestimmten Type gespeichert werden. Somit lassen sich unübersichtliche Casts und Typenfehler zur Laufzeit vermeiden. Gerade auch in den Standardbibliotheken von Java existieren viele generische Klassen. Beispiel Im folgenden der Code eines sehr generischen Paares, in dem jegliche Kombinationen von zwei Werten gespeichert werden können. p u b l i c c l a s s Paar<TypeA , TypeB> { p u b l i c TypeA a ; p u b l i c TypeB b ; Paar ( TypeA i n i t A , TypeB i n i t B ) { a = i n i t A ; b = i n i t B ; } @Override p u b l i c S t r i n g t o S t r i n g ( ) { r e t u r n \" ( \" + a + \" , \" + b + \" ) \" ; } } Collections Im Programmen muss man oft grössere Mengen an Daten speichern, organisieren und verarbeiten. Dafür existieren in den Java-Bibliotheken (java.util) verschiedenste Implementationen von Datenstrukturen, wie Listen und Sets (Mengen). Diese Implementationen basieren auf einigen abstrakten Klassen und Implementieren verschiedene allge- meine Interfaces. Dadurch entstehen die sogenannten abstrakten Datentypen. Diese erlauben es beispielsweise, dass verschiedene Implementationen von Listen als Argument für eine Funktion verwendet werden können. Gleichzeitig garantieren diese Interfaces aber auch, dass gewisse Funktionen vorhanden sind. Dadurch ist es beispielsweise mög- lich, mit einem for-each-Loop über alle Elemente in einer (möglicherweise abstrakten) Datenstruktur zu iterieren. Dabei werden sogenannte Iterators verwendet. Dazu ein kurzes Beispiel: L i s t <I n t e g e r > l i s t = Arrays . a s L i s t ( 1 , 2 , 3 ) ; f o r ( i n t i : l i s t ) System . out . p r i n t l n ( i ) ; 40 Die Implementationen und Interfaces aus diesem sogenannten Collections Framework sind generisch (d.h sie verfü- gen über Typenparameter). Dadurch können mit diesen Datenstrukturen alle möglichen Typen von Daten verwaltet werden. Übungen 1. Was wird ausgegeben, wenn der folgende Code, der die vorhergehende Punkt-Klasse verwendet, ausgeführt wird? Paar<I n t e g e r , I n t e g e r > punkt = new Paar<I n t e g e r , I n t e g e r >(7 , 8 ) ; Paar<Double , Double> genauerPunkt = new Paar<Double , Double > ( 5 . 3 , 0 . 1 + punkt . b ) ; Paar<I n t e g e r , S t r i n g > e i n t r a g = new Paar<I n t e g e r , S t r i n g >(1 , \" H a l l o \" ) ; Paar<S t r i n g , S t r i n g > heyDu = new Paar<S t r i n g , S t r i n g >(\"Hey\" , \"Du\" ) ; e i n t r a g . b = \"Hans\" ; punkt . b = punkt . a + 1 ; System . out . p r i n t l n ( \"Punkt : \" + punkt ) ; System . out . p r i n t l n ( \" ge n a ue r Punkt : \" + genauerPunkt ) ; System . out . p r i n t l n ( e i n t r a g . b + \" i s t E i n t r a g \" + e i n t r a g . a ) ; System . out . p r i n t ( heyDu ) ; Falls ihr nun genug habt von derartigen Fragen: Das war die letzte in diesem Skript. 2. In der Musterlösung zur Übung 7 ﬁndet ihr in der Datei LinkedIntList.java eine Implementation einer Einfach verketteten Liste, in der Integers gespeichert werden können. Passen sie diese Liste so an, dass sie generisch wird und somit für beliebige Typen verwendet werden kann. Dazu sollte die LinkedList-Klasse und die dazugehörende ListNode-Klasse je einen Typenparameter erhalten. 41 Lösungen 1. Ausgabe: Punkt : ( 7 , 8 ) g e na u e r Punkt : ( 5 . 3 , 8 . 1 ) Hans i s t E i n t r a g 1 ( Hey , Du) 42 Systematisches Programmieren Pre- und Postconditions Oftmals müssen die Argumente, die einer Methode übergeben werden, bestimmte Kriterien erfüllen. So funktioniert z.B. die in der Vorlesung präsentierte gcd-Methode nur für x>=0 und y>0 korrekt. Eine solche Bedingung, die am Anfang einer Methode (oder allgemeiner vor einem Stück Code) gelten muss, nennt man Precondition. (zu Deutsch Vorbedingung) Ebenfalls sollen nach einem Methodenaufruf gewisse Bedingungen (z.B. für das Resultat) gelten. Eine Bedingung, die nach einer Methode (oder einem Stück Code) gelten muss, nennt man Postcondition. (zu Deutsch Nachbedin- gung) Diese Bedingungen werden als logische Formeln dargestellt, und sie müssen unter den vorliegenden Variablenwerten (bzw. Werten von Argumenten) wahr sein. Damit erlauben es derartige Pre- und Postconditions auch, formale Beweise über Programme (oder Teile davon) zu führen. Dadurch kann die Korrektheit des Codes nachgewiesen werden. Zudem kann in Java zur Laufzeit eines Programms geprüft werden, ob die Bedingungen erfüllt sind. Dazu wird das assert-Keyword, gefolgt von der Bedingung, verwendet. Wenn eine so eingefügte Bedienungen nicht erfüllt ist, wird ein AssertionError geworfen. Dies allerdings nur, wenn Assertions aktiviert sind. Hoare Tripels Ein Hoare Tripel ist ein Programm mit einer Precondition und einer Postcondition, wir stellen es folgendermassen dar: {P} S {Q}, wobei P die Precondition, S das Programmsegment (bzw. Statement) und Q die Postcondition ist. Ein Hoare Triple ist genau dann gültig, wenn für jeden Zustand (Werte von Variablen), der P erfüllt, die Ausführung von S zu einem Zustand führt, der Q erfüllt. Ansonsten ist das Tripel ungültig. Bei simplen Hoare Tripels kann man schnell sehen, ob diese gültig sind. Hingegen wird es bei etwas komplizierteren Konstrukten (z.B. mit längeren Programmsequenzen oder Loops) schnell unübersichtlich. Es existieren aber genaue Regeln, die Schritt für Schritt auf das Hoare Tripple angewendet werden können, um seine Gültigkeit zu prüfen. Die Details zu diesen Regeln werden auf den Folien der Vorlesung gut dargestellt. (Vorlesungen vom 12.12, 15.12 und 22.12.2017, bzw. im Herbstsemester 2018 vom 11.12, 14.12 und 18.12.2018) Mit diesen Regeln kann entweder vorwärts geschlossen werden, d.h. man wendet den Eﬀekt des Programmsegments auf die Precondition an. Hingegen kann man aber auch rückwärts schliessen, dabei wird das Programmsegment dann rückwärts auf die Postcondition angewendet. Beim Rückwertsschlissen ist das Konzept der schwächsten Precondition (weakest precondition) wichtig. Dabei wird die schwächste Precondition zu einem Programmsegment und einer Postcondition gesucht, so dass ein gültiges Hoare Tripple entsteht. Die schwächste Precondition zu einem Programmsegment S und einer Postcondition Q wird mit wp(S, Q) bezeichnet. Loops Ein interessanter (aber auch komplexer) Fall sind Loops. Bei diesen wird eine sogenannte Invariante benötigt. Dies ist eine Bedingung, die sowohl vor dem Ausführen des Loops, als auch nach jeder einzelnen Iteration durch den Loop gültig ist. Sie wird meist mit I bezeichnet. Die Details dazu sind auf den Folien vom 19.12.2017 (bzw. 18.12.2018) anschaulich dargestellt. 43 Ein paar Worte zu JUnit-Tests In den Übungen kamen das eine oder andere mal auch JUnit-Tests vor. Auf die genauen Implementationen möchte ich hier nicht eingehen, dafür ﬁnden sich in den Übungen und Musterlösungen genügend Beispiele. Häuﬁger standen Studierende hingegen vor dem Problem, welches die richtige Strategie ist, um Tests zu ﬁnden, die auch wirklich Bugs oﬀenlegen. Eine Möglichkeit ist, sich Pre- und Postconditions anzuschauen, und dann zu bestimmen, welche Werte dort am Rand des Deﬁnitionsbereich der zulässigen Werte liegen. Wenn ich Beispielsweise eine Funktion testen möchte, die herausﬁnden soll, ob eine gegebene positive Zahl eine Primzahl ist, würde ich 0 testen, weil es die kleinste positive Zahl ist und 2, weil es die kleinste Primzahl ist und vielleicht auch noch den grösstmöglichen Integer, obwohl dies wohl eine ganze Weile dauern würde. Natürlich sollten auch andere spezielle Fälle plus wenige Standardfälle getestet werden, nur alle Zahlen zwischen 20 und 30 zu testen ist aber weniger sinnvoll. Übungen 1. Gib an, ob die folgenden Hoare Tripples gültig sind oder nicht. Dabei kannst du annehmen, dass es sich bei allen Variablen um Ints handelt, und es nie zu Over-/Underﬂow kommt. a) { t r u e } x = x∗x ; {x > 0} b) {x != 0} x x∗x ; {x >= 0} c) {a > 0} i f ( y > 5 ) { x = y ; z = 2 ; } e l s e { x = a ; z = a ; } {x > 0 && z > 0} d) {a >= 0} i f ( y > 5 ) { x = y ; } e l s e { x = a ; } {x > 0} 2. Gib eine Invariante zum Loop im nachfolgenden Hoare Triple an, so dass damit seine Korrektheit gezeigt werden kann. (Widerum unter der Annahme, dass alle Variablen Ints sind, und es nie zu Over-/Underﬂow kommt) 44 { z == 1 && a == x && x >= 0} w h i l e ( a > 0 ) { z = z ∗ y ; a−−; } { z = y^x} 45 Lösungen 1. a) ungültig b) gültig c) gültig d) ungültig 2. mögliche Invariante: { z == pow ( y , x − a ) && a >= 0} 46","libVersion":"0.3.1","langs":""}