{"path":"sem2/PProg/VRL/extra/kuhn/PProg-w10-kuhn.pdf","text":"Parallel Programming Session 10 Spring 2024, Sarah Kuhn Schedule Post-Discussion Assignment 9 Theory Recap: Semaphores, Monitors, Barriers, Conditional Locks Ink. Implementation Pre-Discussion Assignment 10 Kahoot Filter Lock Implementation Will upload one onto the polybox so you have it for exam prep. Last week Locks& locks with atomics Last week Locks& locks with atomics Atomic registers & atomic operations (read-modify write operations) locks :: O(n). Vs. O(1) space Last week Locks& locks with atomics Atomic registers & atomic operations (read-modify write operations) locks :: O(n). Vs. O(1) space Optimizations Last week Locks& locks with atomics Atomic registers & atomic operations (read-modify write operations) locks :: O(n). Vs. O(1) space Optimizations (TATAS + exponential Backoff) Last week Locks& locks with atomics Atomic registers & atomic operations (read-modify write operations) locks :: O(n). Vs. O(1) space Optimizations (TATAS + exponential Backoff) Deadlock Refresher: Deadlock Deadlock : easily happens when we use locks wrong Refresher: Deadlock Deadlock : easily happens when we use locks wrong strategies to avoid it : 1.) 2.) 3.) Refresher: Deadlock Deadlock : easily happens when we use locks wrong strategies to avoid it : 1.) global locking 2.) non-overlapping locking 3.) ordered locking (IDs, alphabetically etc) Post-Discussion Ex.9 Recap Correct CS & lock: Again Correct CS & lock: Mutual exclusion: No more then one process executing in the critical section Progress/Deadlock-free: When no process is in the critical section, any process that requests entry must be permitted without delay No starvation (bounded wait): If any process tries to enter its critical section then that process must eventually succeed. Assignment 09.1 Draw the diagram based on the code given Analyize the code on relevant information: Assignment 09.1 Draw the diagram based on the code given Analyize the code on relevant information: What are global variables (is seen btw threads) What is local per process ? Assignment 09.1 Draw the diagram based on the code given Analyize the code on relevant information: What are global variables (is seen btw threads) What is local per process ? Assignment 09.1 Draw the diagram based on the code given Analyize the code on relevant information: What are global variables (is seen btw threads) What is local per process ? Enumerate the code/ instruction on read/write Assignment 09.1 Draw state space diagram based on this Assignment 09.1 How do we call this phenomena ? Assignment 09.1 How do we call this phenomena ? Loop without CS ==> Livelock Assignment 09.1 How did you resolve it ? Assignment 09.1 • One way to solve the livelock problem is to impose an ordering when acquiring the lock on the shared resource. • Or one of the spouses can actually take the spoon after certain number of retries How did you resolve it ? Assignment 09 • One way to solve the livelock problem is to impose an ordering when acquiring the lock on the shared resource. • Or one of the spouses can actually take the spoon after certain number of retries How did you resolve it ? we as programmers assign priorities Assignment 09 Is a livelock still a correct critical section ? Assignment 09 Is a livelock still a correct critical section ? Mutual exclusion Assignment 09 Is a livelock still a correct critical section ? Mutual exclusion Progress/Deadlock-free: No starvation (bounded wait): Assignment 09 Is a livelock still a correct critical section ? Mutual exclusion Progress/Deadlock-free: When no process is in the critical section, any process that requests entry must be permitted without delay No starvation (bounded wait): If any process tries to enter its critical section then that process must eventually succeed. Assignment 09.2 Data contention + cost of atomic operations Assignment 09.2 Data contention + cost of atomic operations Update a value seen by multiple threads -> CAS is a possible option Assignment 09.2 Data contention + cost of atomic operations Update a value seen by multiple threads -> CAS is a possible option Structure of CAS: optimistic part : prepare the updates without locking etc. Assignment 09.2 Data contention + cost of atomic operations Update a value seen by multiple threads -> CAS is a possible option Structure of CAS: optimistic part : prepare the updates without locking etc. validation part : execute the case -> only successful if between your preparation and CAS nothing changed Assignment 09.2 Data contention + cost of atomic operations Update a value seen by multiple threads -> CAS is a possible option Structure of CAS: optimistic part : prepare the updates without locking etc. validation part : execute the case -> only successful if between your preparation and CAS nothing changed -> all of that in a do-while-loop bc if update failed, retry. Assignment 09.2 preparation Assignment 09.2 preparation try to update Assignment 09.2 b.) Is this optimal? Improvement options ? Assignment 09.2 expensive very high contention for the state many of the threads retry the atomic operation Contention on the memory bus A way to improve ? Assignment 09.2 expensive very high contention for the state many of the threads retry the atomic operation Contention on the memory bus A way to improve ? back-off mechanism (avoid unnecessary retries) Assignment 09.2 Better option with backoff Last week Empirical conclusion: Backoff really has a big impact Input Implementation using synchronized ? What is the difference ? Input Implementation using synchronized ? What is the difference ? pessimistic locking (even lock for preparing the updates)Theory Recap Semaphores Allow N threads in the CS Used to restrict the number of threads that can access a specific resource Semaphores Allow N threads in the CS Used to restrict the number of threads that can access a specific resource Semaphore Semaphores Allow N threads in the CS Used to restrict the number of threads that can access a specific resource API: acquire() gets a permit, if no permit available block Semaphores: Implementation 49 Semaphore: Counter with initial value s≥0 and the following atomic operations: acquire(S) { wait until S > 0 dec(S) } Semaphores Allow N threads in the CS Used to restrict the number of threads that can access a specific resource API: acquire() gets a permit, if no permit available block release() gives up permit, releases a blocking acquire Semaphores: Implementation 51 Semaphore: integer-valued abstract data type S with some initial value s≥0 and the following atomic operations: acquire(S) { wait until S > 0 dec(S) } release(S) { inc(S) } 52 2 Semaphore Thread 1 Thread 2 Thread 3 53 1 Thread 1 Thread 2 Thread 3 acquire CS Semaphore 54 0 Thread 1 Thread 2 Thread 3 acquire CS acquire CS Semaphore 55 0 Thread 1 Thread 2 Thread 3 Semaphore acquire acquire CS acquire CS 56 0 Thread 1 Thread 2 Thread 3 Semaphore acquire acquire CS release acquire CS release 57 2 Thread 1 Thread 2 Thread 3 Semaphore acquire 58 1 Thread 1 Thread 2 Thread 3 Semaphore acquire CS Think of semaphores as bike rentals Usage Example Allow access to a pool Usage Example Allow access to a pool exist Semaphores in Java but in this course we usually implement them ourselves Lock vs. Semaphore Would you agree when I say semaphore is just a lock which n threads can hold ? Lock vs. Semaphore Would you agree when I say semaphore is just a lock with access for n threads ? Semaphore is way more abstract than just a lock that n-threads can hold. differences: Semaphore is more than that Lock vs. Semaphore Would you agree when I say semaphore is just a lock with access for n threads ? Semaphore is way more abstract than just a lock that n-threads can hold. differences: # of threads that can acquire: 1 vs n who can release: lock owner vs anyone Lock vs. Semaphore Would you agree when I say semaphore is just a lock with access for n threads ? Semaphore is way more abstract than just a lock that n-threads can hold. differences: # of threads that can acquire: 1 vs n who can release: lock owner vs anyone can call release() even though I don’t own it -> no notion of ownership Implemeting What we need for a semaphore : Nr. of threads to allow into cs Can we implement a lock using semaphores ? Implemeting What we need for a semaphore : #thread to allow into cs Can we implement a lock using semaphores ? Implementing a rendez-vous (== meeting point of two threads) using semaphores. Rendez-Vous Location in the code where thread P and Q wait for the other to arrive. Rendez-Vous Location in the code where thread P and Q wait for the other to arrive. Use 2 semaphores to say that thread P, Q has arrived. Rendez-Vous, to do !Rendez-Vous, to do ! how much of «our work is protected by each lock» Semaphores We now know use cases: lock, rendez-vous etc. Semaphores We now know use cases: lock, rendez-vous etc. But how do we really implement the semaphore itself? Which concepts we learned can we reuse now ? Semaphores We now know use cases: lock, rendez-vous etc. But how do we really implement the semaphore itself? Which concepts we learned can we reuse now ? homework given in the lecture Any ideas ? Semaphores Via monitors (synchronized & wait, notify) ->in the homework Via Monitors (preview) Via Monitors (preview) Via Monitors (solution) Semaphores Via monitors (synchronized & wait, notify) ->in the homework Via atomic operations (atomic int as a counter, CAS to update) Via atomics Via monitors (synchronized & wait, notify) PC Queues with SemaphoresProblemProblem We already know it, remember ? Monitors intrinsic lock + wait/notify Monitors intrinsic lock + wait/notify use it with conditions –release and wait for them PC Queues how much of «our work is protected by each lock» Monitors intrinsic lock + wait/notify use it with conditions – release and wait for them Why? Monitors intrinsic lock + wait/notify use it with conditions – release and wait for them Why? Avoid busy-waiting (spinning loops) Monitors in JavaMonitors in Java “using a Java monitor” -> use synchronized (object) + wait()/notify() Monitors in Java “using a Java monitor” -> use synchronized (object) + wait()/notify() In your method: Monitors how much of «our work is protected by each lock» Granularity how much of «our work is protected by each lock» Monitors P/C Queue Example synchronized void enqueue(long x) { if (isFull()){ try { wait(); } catch (InterruptedException e) {} doEnqueue(x); notifyAll(); } synchronized long dequeue() { long x; if (isEmpty()){ try { wait(); } catch (InterruptedException e) {} x = doDequeue(); notifyAll(); return x; } What’s wrong with this code ? PC QueuesNotify() Just a random thread from the queue will be woken up Monitors…. Monitors allow us Mutex Cooperation/ Communication Monitors…. Monitors allow us Mutex Cooperation/ Communication Would wish that we can specific which condition to notify/ wait for Lock Conditions make a thread wait for a condition Lock Conditions signal threads that a specific condition has been met Lock Conditions signal threads that a specific condition has been met Monitor vs Lock ConditionsMonitor vs Lock ConditonsLock Conditions Can be used to implement monitors& more ! Lock Conditions Can be used to implement monitors! Java Locks provide conditions that can be instantiated Condition notFull = lock.newCondition(); Lock Conditions Can be used to implement monitors! Java Locks provide conditions that can be instantiated Condition notFull = lock.newCondition(); Java conditions offer .await() – the current thread waits until condition is signaled Lock Conditions Can be used to implement monitors! Java Locks provide conditions that can be instantiated Condition notFull = lock.newCondition(); Java conditions offer .await() – the current thread waits until condition is signaled .signal() – wakes up one thread waiting on this condition Lock Conditions Can be used to implement monitors! Java Locks provide conditions that can be instantiated Condition notFull = lock.newCondition(); Java conditions offer .await() – the current thread waits until condition is signaled .signal() – wakes up one thread waiting on this condition .signalAll() – wakes up all threads waiting on this condition Lock Conditions Can be used to implement monitors! Java Locks provide conditions that can be instantiated Condition notFull = lock.newCondition(); Java conditions offer .await() – the current thread waits until condition is signaled .signal() – wakes up one thread waiting on this condition .signalAll() – wakes up all threads waiting on this condition Similar to notify() and notifyAll() just on a more specific queue Conditions P/C Queue Example Global lock on the queue synchronized void enqueue(long x) { if (isFull()){ try { wait(); } catch (InterruptedException e) {} doEnqueue(x); notifyAll(); } Conditions P/C Queue Example Global lock on the queue Conditions on the lock Conditions P/C Queue Example Global lock on the queue Conditions on the lock I think of lock conditions as distributing tickets with that name f.eg “notFull” tickets Conditions P/C Queue Example BEFORE: synchronized void enqueue(long x) { while(isFull()){ try { wait(); } catch (InterruptedException e) {}doEnqueue(x); notifyAll(); } Conditions P/C Queue Example BEFORE: synchronized void enqueue(long x) { while(isFull()){ try { wait(); } catch (InterruptedException e) {}doEnqueue(x); notifyAll(); } Conditions P/C Queue Example BEFORE: synchronized void enqueue(long x) { while(isFull()){ try { wait(); } catch (InterruptedException e) {}doEnqueue(x); notifyAll(); } Conditions P/C Queue Example BEFORE: synchronized void enqueue(long x) { while(isFull()){ try { wait(); } catch (InterruptedException e) {}doEnqueue(x); notifyAll(); } Conditions P/C Queue Example BEFORE: synchronized void enqueue(long x) { while(isFull()){ try { wait(); } catch (InterruptedException e) {}doEnqueue(x); notifyAll(); } Procedure synchronized -> lock.lock(), lock.unlock() Wait() -> condition from while loop await NotfiyAll() -> signal the specific condition Conditions P/C Queue Example BEFORE: synchronized long dequeue() { long x; while(isEmpty()){ try { wait(); } catch (InterruptedException e) {} x = doDequeue(); notifyAll(); return x; } public long dequeue() { Conditions P/C Queue Example BEFORE: synchronized long dequeue() { long x; while(isEmpty()){ try { wait(); } catch (InterruptedException e) {} x = doDequeue(); notifyAll(); return x; } public long dequeue() { lock.lock() try{ while(isEmpty()){ notEmpty.await(); } x = doDequeue(); notFull.signal() return x; }finally{ lock.unlock(); } } Conditions P/C Queue Example BEFORE: synchronized long dequeue() { long x; while(isEmpty()){ try { wait(); } catch (InterruptedException e) {} x = doDequeue(); notifyAll(); return x; } public long dequeue() { lock.lock() try{ while(isEmpty()){ notEmpty.await(); } x = doDequeue(); notFull.signal() return x; }finally{ lock.unlock(); } } Conditions P/C Queue Example BEFORE: synchronized long dequeue() { long x; while(isEmpty()){ try { wait(); } catch (InterruptedException e) {} x = doDequeue(); notifyAll(); return x; } public long dequeue() { lock.lock() try{ while(isEmpty()){ notEmpty.await(); } x = doDequeue(); notFull.signal() return x; }finally{ lock.unlock(); } } Conditions P/C Queue Example BEFORE: synchronized long dequeue() { long x; while(isEmpty()){ try { wait(); } catch (InterruptedException e) {} x = doDequeue(); notifyAll(); return x; } public long dequeue() { lock.lock() try{ while(isEmpty()){ notEmpty.await(); } x = doDequeue(); notFull.signal() return x; }finally{ lock.unlock(); } } Conditions P/C Queue ExampleWhat have we seen? Semaphores: letting in n threads but not good for communication + complicated What have we seen? Semaphores: letting in n threads but not good for communication + complicated Lock conditions: What have we seen? Semaphores: letting in n threads but not good for communication + complicated Lock conditions: like wait (notify for monitors but now with external locks) multiple waiting queues What have we seen? Semaphores: letting in n threads but not good for communication + complicated Lock conditions: like wait (notify for monitors but now with external locks) multiple waiting queues NOW: Barriers BarriersBarriers via Monitors Code example BarriersTwo-Phase Barrier with Semaphores how much of «our work is protected by each lock» Barriers Pre-Discussion Ex.10 Task 1 - Dining Philosophers 150 Originally proposed by E. W. Dijkstra Imagine five philosophers who spend their lives thinking and eating. They sit around a circular table with five chairs with a big plate of spaghetti. However, there are only five chopsticks available. Task 1 - Dining Philosophers 151 Each philosopher thinks and when he gets hungry picks up the two chopsticks closest to him. • If a philosopher can pick up BOTH chopsticks, he eats for a while. • After a philosopher finishes eating, he puts down the chopsticks and starts to think again. How can a deadlock occur here? Task 1 - Dining Philosophers 152 Each philosopher thinks and when he gets hungry picks up the two chopsticks closest to him. • If a philosopher can pick up BOTH chopsticks, he eats for a while. • After a philosopher finishes eating, he puts down the chopsticks and starts to think again. How can a deadlock occur here? We need to break the cyclic dependency somehow. Find a solution that… 153 • Makes deadlocks impossible • Has no starvation • More than one parallel eating philosopher is possible Task 2 – Monitors, Conditions and Bridges 155 Only either 3 cars or one truck may be on the bridge at each moment. Implement Classes BridgeMonitor and BridgeCondition Task 2 – Monitors, Conditions and Bridges 156 Only either 3 cars or one truck may be on the bridge at each moment. Implement Classes BridgeMonitor and BridgeCondition Look at slides about monitors, everything you should need What we are givenWhat we need Count cars and trucks currently on bridge with volatile variables What we need Count cars and trucks currently on bridge with volatile variables What we need Count cars and trucks currently on bridge with volatile variables Wait for bridge to become available Conditions Create conditions: Conditions Create conditions: f.eg conditions like: What we need Count cars and trucks currently on bridge with volatile variables Wait for bridge to become available When available, increment count. Spoiler:Task 3 – Semaphores and Databases 165 Use semaphores to implement login and logout database functionality that supports up to 10 concurrent users Use barrier to implement 2-phase backup functionality. Task 3 – Semaphores and Databases 166 Implement Classes MySemaphore and MyBarrier Use monitors for both to avoid busy loop Try to understand the existing DatabaseJava implementation before implementing your own semaphore and barrier. We basically did that already in the exercise class, else look into the slides again. Key points Update value with CAS Build a lock with a Semaphore Implement a Semaphore with Monitors (in exercise), with CAS (did in class) Def. Rendez-Vous & implement it with 2 Semaphores Monitors vs Lock Conditions What is a Barrier VIS Teaching Awards Let’s start kahoot See you next week J","libVersion":"0.3.2","langs":""}