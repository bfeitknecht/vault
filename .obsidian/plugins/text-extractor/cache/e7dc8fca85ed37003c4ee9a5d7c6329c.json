{"path":"sem4/FMFP/pvw/FMFP-pvw-s03.pdf","text":"Formal Methods and Functional Programming PVW July 14-19, 2025 Wochenplan Mittwoch Big-Step-Semantics (Nat. Semantics)Definitions ⊢ ⟨s, σ⟩ → σ′ ⇐⇒ there exists a finite derivation tree ending in ⟨s, σ⟩ → σ′ ⊢ ⟨s, σ⟩ → σ′ ⇐⇒ ∃T .root(T ) ≡ ⟨s, σ⟩ → σ′ Definitions Wir sagen, dass ein statement terminiert genau dann wenn: ∃T .root(T ) ≡ ⟨s, σ⟩ → σ′ Two statements s1 and s2 are semantically equivalent iff ∀σ, σ′.(⊢ ⟨s1, σ⟩ → σ′ ⇐⇒ ⊢ ⟨s2, σ⟩ → σ′) Übung I ▶ What function does the IMP statement s compute when the variable x initially stores a non-negative integer? ▶ Let σ be a state with σ(x) = 2. Prove that there is a state σ′ with σ′(y ) = 4 such that ⟨s, σ⟩ → σ′ using the rules of the big-step semantics for IMP. Übung I ▶ What function does the IMP statement s compute when the variable x initially stores a non-negative integer? ▶ Let σ be a state with σ(x) = 2. Prove that there is a state σ′ with σ′(y ) = 4 such that ⟨s, σ⟩ → σ′ using the rules of the big-step semantics for IMP. Übung II (Standard Exam Exercise) Consider the extension of the programming language IMP with the statement repeat s until b where s is a statement and b is a Boolean expression. ⟨s, σ⟩ → σ′ ⟨repeat s until b, σ⟩ → σ′ (REPT) if B[b]σ′ = tt ⟨s, σ⟩ → σ′′ ⟨repeat s until b, σ′′⟩ → σ′ ⟨repeat s until b, σ⟩ → σ′ (REPF) if B[b]σ′′ = ff ▶ Prove that, for all σ, σ′,b, s: ⊢ ⟨repeat s until b, σ⟩ → σ′ ⇒ ⊢ ⟨s; while not b do s end, σ⟩ → σ′ Übung II (Standard Exam Exercise) Consider the extension of the programming language IMP with the statement repeat s until b where s is a statement and b is a Boolean expression. ⟨s, σ⟩ → σ′ ⟨repeat s until b, σ⟩ → σ′ (REPT) if B[b]σ′ = tt ⟨s, σ⟩ → σ′′ ⟨repeat s until b, σ′′⟩ → σ′ ⟨repeat s until b, σ⟩ → σ′ (REPF) if B[b]σ′′ = ff ▶ Prove that, for all σ, σ′,b, s: ⊢ ⟨repeat s until b, σ⟩ → σ′ ⇒ ⊢ ⟨s; while not b do s end, σ⟩ → σ′ Üben ▶ PVW, Page 52. Exercise 1.3 ▶ FS25, 4A (warmup), 4B (induction) ▶ Basically, every past exam SOS - Structural Operational SemanticsStructural Operational Semantics ▶ Fokus liegt auf individuellen Schritten ▶ ⟨s, σ⟩ →1 σ′ Hat terminiert und finaler state ist σ′ ▶ ⟨s, σ⟩ →1 ⟨s′, σ′⟩ Hat s noch nicht fertig ausgeführt. ▶ Eine Konfiguration steckt fest, wenn es kein γ gibt, so dass ⟨s, σ⟩ →1 γ. γ kann ein terminal (σ′) oder non-terminal (⟨s′, σ′⟩) sein. ▶ ⊢ ⟨s, σ⟩ →1 γ ⇐⇒ ∃T .root(T ) ≡ ⟨s, σ⟩ →1 γ A finite derivation tree exists, ending in ⟨s, σ⟩ →1 γ. ▶ γ → k 1 γ′ genau k-Schritt Ausführung. ▶ γ → ∗ 1 γ′ ⇐⇒ ∃k .γ → k 1 γ′ Structural Operational Semantics ▶ Fokus liegt auf individuellen Schritten ▶ ⟨s, σ⟩ →1 σ′ Hat terminiert und finaler state ist σ′ ▶ ⟨s, σ⟩ →1 ⟨s′, σ′⟩ Hat s noch nicht fertig ausgeführt. ▶ Eine Konfiguration steckt fest, wenn es kein γ gibt, so dass ⟨s, σ⟩ →1 γ. γ kann ein terminal (σ′) oder non-terminal (⟨s′, σ′⟩) sein. ▶ ⊢ ⟨s, σ⟩ →1 γ ⇐⇒ ∃T .root(T ) ≡ ⟨s, σ⟩ →1 γ A finite derivation tree exists, ending in ⟨s, σ⟩ →1 γ. ▶ γ → k 1 γ′ genau k-Schritt Ausführung. ▶ γ → ∗ 1 γ′ ⇐⇒ ∃k .γ → k 1 γ′ Structural Operational Semantics ▶ Fokus liegt auf individuellen Schritten ▶ ⟨s, σ⟩ →1 σ′ Hat terminiert und finaler state ist σ′ ▶ ⟨s, σ⟩ →1 ⟨s′, σ′⟩ Hat s noch nicht fertig ausgeführt. ▶ Eine Konfiguration steckt fest, wenn es kein γ gibt, so dass ⟨s, σ⟩ →1 γ. γ kann ein terminal (σ′) oder non-terminal (⟨s′, σ′⟩) sein. ▶ ⊢ ⟨s, σ⟩ →1 γ ⇐⇒ ∃T .root(T ) ≡ ⟨s, σ⟩ →1 γ A finite derivation tree exists, ending in ⟨s, σ⟩ →1 γ. ▶ γ → k 1 γ′ genau k-Schritt Ausführung. ▶ γ → ∗ 1 γ′ ⇐⇒ ∃k .γ → k 1 γ′ Structural Operational Semantics ▶ Fokus liegt auf individuellen Schritten ▶ ⟨s, σ⟩ →1 σ′ Hat terminiert und finaler state ist σ′ ▶ ⟨s, σ⟩ →1 ⟨s′, σ′⟩ Hat s noch nicht fertig ausgeführt. ▶ Eine Konfiguration steckt fest, wenn es kein γ gibt, so dass ⟨s, σ⟩ →1 γ. γ kann ein terminal (σ′) oder non-terminal (⟨s′, σ′⟩) sein. ▶ ⊢ ⟨s, σ⟩ →1 γ ⇐⇒ ∃T .root(T ) ≡ ⟨s, σ⟩ →1 γ A finite derivation tree exists, ending in ⟨s, σ⟩ →1 γ. ▶ γ → k 1 γ′ genau k-Schritt Ausführung. ▶ γ → ∗ 1 γ′ ⇐⇒ ∃k .γ → k 1 γ′ Structural Operational Semantics ▶ Fokus liegt auf individuellen Schritten ▶ ⟨s, σ⟩ →1 σ′ Hat terminiert und finaler state ist σ′ ▶ ⟨s, σ⟩ →1 ⟨s′, σ′⟩ Hat s noch nicht fertig ausgeführt. ▶ Eine Konfiguration steckt fest, wenn es kein γ gibt, so dass ⟨s, σ⟩ →1 γ. γ kann ein terminal (σ′) oder non-terminal (⟨s′, σ′⟩) sein. ▶ ⊢ ⟨s, σ⟩ →1 γ ⇐⇒ ∃T .root(T ) ≡ ⟨s, σ⟩ →1 γ A finite derivation tree exists, ending in ⟨s, σ⟩ →1 γ. ▶ γ → k 1 γ′ genau k-Schritt Ausführung. ▶ γ → ∗ 1 γ′ ⇐⇒ ∃k .γ → k 1 γ′ Derivation Sequence Für statements können wir derivation sequences aufschreiben: x := 3; while x == 3 do x := 5 end ⟨x := 3; while x == 3 do x := 5 end, σ⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 3]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ3⟩ → 1 1 ⟨x := 5; while x == 3 do x := 5 end, σ3⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 5]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ5⟩ → 1 1 ⟨skip, σ5⟩ → 1 1 σ[x → 5] \"Provide the derivation sequence, as well as the derivation tree for the first step\". Derivation Sequence Für statements können wir derivation sequences aufschreiben: x := 3; while x == 3 do x := 5 end ⟨x := 3; while x == 3 do x := 5 end, σ⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 3]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ3⟩ → 1 1 ⟨x := 5; while x == 3 do x := 5 end, σ3⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 5]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ5⟩ → 1 1 ⟨skip, σ5⟩ → 1 1 σ[x → 5] \"Provide the derivation sequence, as well as the derivation tree for the first step\". Derivation Sequence Für statements können wir derivation sequences aufschreiben: x := 3; while x == 3 do x := 5 end ⟨x := 3; while x == 3 do x := 5 end, σ⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 3]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ3⟩ → 1 1 ⟨x := 5; while x == 3 do x := 5 end, σ3⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 5]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ5⟩ → 1 1 ⟨skip, σ5⟩ → 1 1 σ[x → 5] \"Provide the derivation sequence, as well as the derivation tree for the first step\". Derivation Sequence Für statements können wir derivation sequences aufschreiben: x := 3; while x == 3 do x := 5 end ⟨x := 3; while x == 3 do x := 5 end, σ⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 3]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ3⟩ → 1 1 ⟨x := 5; while x == 3 do x := 5 end, σ3⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 5]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ5⟩ → 1 1 ⟨skip, σ5⟩ → 1 1 σ[x → 5] \"Provide the derivation sequence, as well as the derivation tree for the first step\". Derivation Sequence Für statements können wir derivation sequences aufschreiben: x := 3; while x == 3 do x := 5 end ⟨x := 3; while x == 3 do x := 5 end, σ⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 3]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ3⟩ → 1 1 ⟨x := 5; while x == 3 do x := 5 end, σ3⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 5]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ5⟩ → 1 1 ⟨skip, σ5⟩ → 1 1 σ[x → 5] \"Provide the derivation sequence, as well as the derivation tree for the first step\". Derivation Sequence Für statements können wir derivation sequences aufschreiben: x := 3; while x == 3 do x := 5 end ⟨x := 3; while x == 3 do x := 5 end, σ⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 3]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ3⟩ → 1 1 ⟨x := 5; while x == 3 do x := 5 end, σ3⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 5]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ5⟩ → 1 1 ⟨skip, σ5⟩ → 1 1 σ[x → 5] \"Provide the derivation sequence, as well as the derivation tree for the first step\". Derivation Sequence Für statements können wir derivation sequences aufschreiben: x := 3; while x == 3 do x := 5 end ⟨x := 3; while x == 3 do x := 5 end, σ⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 3]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ3⟩ → 1 1 ⟨x := 5; while x == 3 do x := 5 end, σ3⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 5]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ5⟩ → 1 1 ⟨skip, σ5⟩ → 1 1 σ[x → 5] \"Provide the derivation sequence, as well as the derivation tree for the first step\". Derivation Sequence Für statements können wir derivation sequences aufschreiben: x := 3; while x == 3 do x := 5 end ⟨x := 3; while x == 3 do x := 5 end, σ⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 3]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ3⟩ → 1 1 ⟨x := 5; while x == 3 do x := 5 end, σ3⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 5]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ5⟩ → 1 1 ⟨skip, σ5⟩ → 1 1 σ[x → 5] \"Provide the derivation sequence, as well as the derivation tree for the first step\". Derivation Sequence Für statements können wir derivation sequences aufschreiben: x := 3; while x == 3 do x := 5 end ⟨x := 3; while x == 3 do x := 5 end, σ⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 3]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ3⟩ → 1 1 ⟨x := 5; while x == 3 do x := 5 end, σ3⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 5]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ5⟩ → 1 1 ⟨skip, σ5⟩ → 1 1 σ[x → 5] \"Provide the derivation sequence, as well as the derivation tree for the first step\". Derivation Sequence Für statements können wir derivation sequences aufschreiben: x := 3; while x == 3 do x := 5 end ⟨x := 3; while x == 3 do x := 5 end, σ⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 3]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ3⟩ → 1 1 ⟨x := 5; while x == 3 do x := 5 end, σ3⟩ → 1 1 ⟨while x == 3 do x := 5 end, σ[x → 5]⟩ → 1 1 ⟨if x == 3 then x := 5; while x == 3 do x := 5 end else skip end, σ5⟩ → 1 1 ⟨skip, σ5⟩ → 1 1 σ[x → 5] \"Provide the derivation sequence, as well as the derivation tree for the first step\". Induktive Beweise ▶ Wir verwenden strong induction, aber über die länge der derivation sequence. ▶ Ändern ⟨s, σ⟩ → ∗ 1 σ′ to ⟨s, σ⟩ → k 1 σ′ ▶ Induktion über k . ▶ Anstelle der Case Distinction über die letzte regel, machen wir zuerst eine case distinction über k = 0 (hält oft triviallerweise) und k > 0. Im k > 0 case machen wir eine weitere case distinction über die letzte Regel vom Tree, welcher der erste Schritt begründed. BeispielPrüfungs AufgabeTermination Das Statement s wird im State σ... ▶ terminieren, gdw. es einen endliche derivation sequence gibt, welche mit ⟨s, σ⟩ startet. ▶ nicht terminieren, gdw. es eine unendliche derivation sequence gibt, welche mit ⟨s, σ⟩ startet. Achtung: Aussagen über Terminierung muss man immmer im Zusammenhang mit einem State treffen. Semantic Equivalence In SOS, zwei Statements s1 and s2 sind semantic equivalent if for all states σ, both: ▶ für alle stuck oder terminal configurations γ, es gilt, dass ⟨s1, σ⟩ → ∗ 1 γ ⇐⇒ ⟨s2, σ⟩ → ∗ 1 γ ▶ Es gibt eine unendliche derivation sequence von ⟨s1, σ⟩ aus gibt, genau dann wenn es eine von ⟨s2, σ⟩ aus gibt. Sind diese beiden equivalent? ▶ x := 3; y := 4 ▶ x := 5; y := 4; x := 3 Und diese zwei? ▶ x := 3; while x == 3 do y := 4 end ▶ x := 3; while x == 3 do x := 4 end Semantic Equivalence In SOS, zwei Statements s1 and s2 sind semantic equivalent if for all states σ, both: ▶ für alle stuck oder terminal configurations γ, es gilt, dass ⟨s1, σ⟩ → ∗ 1 γ ⇐⇒ ⟨s2, σ⟩ → ∗ 1 γ ▶ Es gibt eine unendliche derivation sequence von ⟨s1, σ⟩ aus gibt, genau dann wenn es eine von ⟨s2, σ⟩ aus gibt. Sind diese beiden equivalent? ▶ x := 3; y := 4 ▶ x := 5; y := 4; x := 3 Und diese zwei? ▶ x := 3; while x == 3 do y := 4 end ▶ x := 3; while x == 3 do x := 4 end Semantic Equivalence In SOS, zwei Statements s1 and s2 sind semantic equivalent if for all states σ, both: ▶ für alle stuck oder terminal configurations γ, es gilt, dass ⟨s1, σ⟩ → ∗ 1 γ ⇐⇒ ⟨s2, σ⟩ → ∗ 1 γ ▶ Es gibt eine unendliche derivation sequence von ⟨s1, σ⟩ aus gibt, genau dann wenn es eine von ⟨s2, σ⟩ aus gibt. Sind diese beiden equivalent? ▶ x := 3; y := 4 ▶ x := 5; y := 4; x := 3 Und diese zwei? ▶ x := 3; while x == 3 do y := 4 end ▶ x := 3; while x == 3 do x := 4 end Üben ▶ PVW Seite 55, 2.1, 2.2 ▶ HS23, Assignment 4","libVersion":"0.5.0","langs":""}