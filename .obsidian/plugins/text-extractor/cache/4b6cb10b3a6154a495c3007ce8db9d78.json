{"path":"sem3/A&D/UE/e/A&D-e-u04.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 14 October 2024 Johannes Lengler, David Steurer Kasper Lindberg, Lucas Slot, Hongjie Chen, Manuel Wiedmer Algorithms & Data Structures Exercise sheet 4 HS 24 The solutions for this sheet are submitted on Moodle until 20 October 2024, 23:59. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. Master theorem. The following theorem is very useful for running-time analysis of divide-and- conquer algorithms. Theorem 1 (master theorem). Let a, C > 0 and b ≥ 0 be constants and T : N → R+ a function such that for all even n ∈ N, T (n) ≤ aT (n/2) + Cn b. (1) Then for all n = 2k, k ∈ N, the following statements hold (i) If b > log2 a, T (n) ≤ O(nb). (ii) If b = log2 a, T (n) ≤ O(nlog2 a · log n).1 (iii) If b < log2 a, T (n) ≤ O(nlog2 a). If the function T is increasing, then the condition n = 2k can be dropped. If (1) holds with “=”, then we may even conclude that T (n) = Θ(nb), T (n) = Θ(nlog2 a · log n), and T (n) = Θ(nlog2 a) in cases (i), (ii), and (iii), respectively. This generalizes some results that you have already seen in this course. For example, the (worst-case) running time of Karatsuba’s algorithm satisfies T (n) ≤ 3T (n/2) + 100n, so we have a = 3 and b = 1 < log2 3, hence T (n) ≤ O(nlog2 3). Another example is binary search: its running time satisfies T (n) ≤ T (n/2) + 100, so a = 1 and b = 0 = log2 1, hence T (n) ≤ O(log n). Exercise 4.1 Applying the master theorem. For this exercise, assume that n is a power of two (that is, n = 2k, where k ∈ N0). In the following, you are given a function T : N → R+ defined recursively and you are asked to find its asymptotic behavior by applying the master theorem. (a) Let T (1) = 1, T (n) = 4T (n/2) + 100n for n > 1. Using the master theorem, show that T (n) ≤ O(n2). (b) Let T (1) = 5, T (n) = T (n/2) + 3 2 n for n > 1. Using the master theorem, show that T (n) ≤ O(n). 1For this asymptotic bound we assume n ≥ 2 so that n log2 a · log n > 0. (c) Let T (1) = 4, T (n) = 4T (n/2) + 7 2 n2 for n > 1. Using the master theorem, show that T (n) ≤ O(n2 log n). Exercise 4.2 Asymptotic notations. (a) (This subtask is from January 2019 exam). For each of the following claims, state whether it is true or false. You don’t need to justify your answers. claim true false n log n ≤ O( √n) □ □ log(n!) ≥ Ω(n2) □ □ nk ≥ Ω(kn), if 1 < k ≤ O(1) □ □ log3 n4 = Θ(log7 n8) □ □ (b) (This subtask is from August 2019 exam). For each of the following claims, state whether it is true or false. You don’t need to justify your answers. claim true false n log n ≥ Ω(n1/2) □ □ log7(n8) = Θ(log3(n√n)) □ □ 3n4 + n2 + n ≥ Ω(n2) □ □ (∗) n! ≤ O(nn/2) □ □ Note that the last claim is challenge. It was one of the hardest tasks of the exam. If you want a 6 grade, you should be able to solve such exercises. Sorting and Searching. Exercise 4.3 Formal proof of correctness for Insertion Sort (1 point). 2 Algorithm 1 Insertion Sort (input: array A[1 . . . n]). for j = 1, . . . , n do if j > 1 then for i = j − 1, . . . , 1 do if A[i + 1] < A[i] then Swap A[i + 1] and A[i] Prove correctness of this algorithm by mathematical induction. Hint: Use the invariant I(j): “After j iterations the first j elements are sorted.” Exercise 4.4 Searching in a weirdly-sorted array (1 point). Let n ≥ 2 and suppose we are given an array A[1 . . . n] containing n unique integers, that satisfies the following property: there is an integer 1 ≤ k ≤ n − 1 such that the subarrays A[1 . . . k] and A[k + 1 . . . n] are sorted (in ascending order), and A[n] < A[1]. We call such an array weirdly-sorted, and we call k the pivot. (a) Given a weirdly-sorted array A[1 . . . n] containing n unique integers, provide an algorithm in pseu- docode that finds the pivot 1 ≤ k ≤ n − 1 such that the subarrays A[1 . . . k] and A[k + 1 . . . n] are sorted (in ascending order). The runtime of your algorithm should be at most O(log n). Hint: Be careful of edge-cases. Hint: For an index 1 ≤ m ≤ n, think of a simple condition involving A[1], A[n] you could check to see if m is to the left or to the right of the pivot. (b) Given a weirdly-sorted array A[1 . . . n] containing n unique integers, and an integer ℓ ∈ N, provide an algorithm in pseudocode that determines whether A contains ℓ as an entry. The runtime of your algorithm should be at most O(log n). You may use the algorithm of part (a) as a subroutine even if you did not solve that part. You may also use algorithms from the lecture as subroutines. Exercise 4.5 Counting function calls in loops (cont’d) (1 point). For each of the following code snippets, compute the number of calls to f as a function of n ∈ N. We denote this number by T (n), i.e. T (n) is the number of calls the algorithm makes to f depending on the input n. Then T is a function from N to R+. For part (a), provide both the exact number of calls and a maximally simplified asymptotic bound in Θ notation. For part (b), it is enough to give a maximally simplified asymptotic bound in Θ notation. For the asymptotic bounds, you may assume that n ≥ 10. Algorithm 2 (a) i ← 1 while i ≤ n do j ← 1 while i√j ≤ n do f () j ← j + 1 i ← i + 1 3 Hint: You may use the formula for a finite geometric series without proof n∑ i=0 ari = a(rn+1 − 1) r − 1 for r ̸= 1. Algorithm 3 (b) function A(n) i ← 1 while i ≤ n do j ← i while j ≤ n do f () f () j ← j + 1 i ← i + 1 k ← ⌊ n 2 ⌋ for ℓ = 1 . . . 3 do if k > 0 then A(k) You may assume that the function T : N → R+ denoting the number of calls of the algorithm to f is increasing. Hint: Recall exercise 0.1. Use the master theorem twice to get T (n) ≤ O(·) and T (n) ≥ Ω(·) which implies T (n) = Θ(·). (c)* Prove that the function T : N → R+ from the code snippet in part (b) is indeed increasing. Hint: You can show the following statement by mathematical induction: “For all n′ ∈ N with n′ ≤ n we have T (n′ + 1) ≥ T (n′)”. 4","libVersion":"0.5.0","langs":""}