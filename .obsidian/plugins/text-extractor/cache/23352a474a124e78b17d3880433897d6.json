{"path":"sem2/PProg/PV/exams/PProg-FS20-exam.pdf","text":"Vor und Nachname (Druckbuchstaben): Legi Nummer: 252-0029-00L Parallele Programmierung ETH/CS: FS 2020 Semesterpr¨ufung Mittwoch, 19.08.2020 120 Minuten Diese Pr¨ufung enth¨alt 27 Seiten (inklusive Deckblatt) und 13 Aufgaben. ¨Uberpr¨ufen Sie nach Beginn der Pr¨ufung, dass keine Seiten fehlen. Schreiben Sie die Legi-Nummer oben auf jede einzelne Seite. Sie haben 120 Minuten Zeit f¨ur die L¨osung der Pr¨ufung. Falls Sie sich durch irgendjemanden oder irgendetwas gest¨ort f¨uhlen, melden Sie dies einer Auf- sichtsperson. Wir sammeln die Pr¨ufung zum Schluss ein, stellen Sie sicher, dass Ihre Pr¨ufung von einem Assistenten eingezogen wird. Wenn Sie fr¨uher abgeben wollen melden Sie sich und wir holen die Pr¨ufung ab. Vorzeitige Abgaben sind nur bis 15 Minuten vor Pr¨ufungsende m¨oglich. Wenn Sie zur Toilette m¨ussen, melden Sie dies einer Aufsichtsperson durch Handzeichen. Es darf zur gleichen Zeit immer nur eine Person zur Toilette. ‹ L¨osungen m¨ussen lesbar sein. L¨osungen mit unklarer Reihenfolge oder anderweitig un- verst¨andlicher Pr¨asentation k¨onnen zu Punktabz¨ugen f¨uhren. Verwenden Sie keinen Blei- stift und keine rot oder orange-farbenen Stifte. ‹ Falls mehr Platz ben¨otigt wird, schreiben Sie auf die leeren Seiten am Ende der Pr¨ufungsunterlagen. Versehen Sie die Aufgabe mit einem klaren Hinweis, falls das der Fall ist. ‹ Multiple-choice Fragen werden minimal mit 0 Punkten bewertet, es werden keine negativen Punkte erteilt. ‹ Die Aufgabenstellungen sind in Deutsch und Englisch gegeben. Die Aufgaben k¨onnen auf Deutsch oder Englisch beantwortet werden. ‹ Legen Sie ihre ETH Karte zur Identit¨ats¨uberpr¨ufung gut sichtbar vor sich auf den Tisch. ‹ In dieser Pr¨ufung sind keine Hilfsmittel oder mitgebrachte Unterlagen erlaubt, ausser ein W¨orterbuch f¨ur fremdsprachige Studierende. Insbesondere alle kommunikationsf¨ahigen, pro- grammierbaren und/oder speicherf¨ahigen Ger¨ate wie bspw. Smartphones, Smartwatches, etc. sind nicht erlaubt. Bei unehrlichem Handeln gelten die Strafnormen der Disziplinarordnung der ETH. ‹ Eine pl¨otzlich auftretende Erkrankung muss bei der Pr¨ufungsaufsicht explizit angezeigt wer- den — ebenso zwingend erforderlich ist eine Mitteilung, die Pr¨ufung aus medizinischen Gr¨unden nicht beenden zu k¨onnen. Studierende mit Fieber, Husten, Atemnot, Verlust des Geschmacksinns, Muskelschmerzen d¨urfen nicht an der Pr¨ufungen teilneh- men. Die Pr¨ufungsaufsicht ist befugt, Studierende, die oﬀensichtliche Krankheits- symptome zeigen, aus der Pr¨ufung zu weisen. Question: 1 2 3 4 5 6 7 8 9 10 11 12 13 Total Points: 5 6 11 6 5 13 14 14 16 6 7 8 9 120 Score: Parallele Programmierung - Semesterpr¨ufung - Seite 2 von 27 Mittwoch, 19.08.2020 Diese Seite ist absichtlich leer. This page is intentionally left blank. Parallele Programmierung - Semesterpr¨ufung - Seite 3 von 27 Mittwoch, 19.08.2020 Speedup, Amdahl, Gustafson (11 points) 1. (5)Gegeben ist ein Programm mit einem unbe- kannten Anteil an parallelisierbarer Arbeit. Auf einem Rechner mit einem Prozessor betr¨agt die Laufzeit 10 Stunden. Mit 25 Prozessoren ist die Laufzeit 2 Stunden. Was ist der Anteil nicht parallelisierbarer Arbeit gem¨ass Amdahl’s Ge- setz? Geben Sie alle Rechenschritte an. Assume we are running a program where the fraction of parallelizable work is un- known. On a single-processor machine, the program takes 10 hours. With 25 proces- sors, the program takes 2 hours. Accord- ing to Amdahl’s law, what is the fraction of non-parallelizable work in the program? Show all calculation steps. 2. (6)Eine Firma verwendet ein Programm P und m¨ochte es in einer Laufzeit von weniger als ei- ner Stunde ausf¨uhren. Auf einem Rechner mit einem Prozessor l¨auft P in 4 Stunden. Mit 2 Prozessoren l¨auft P in 3 Stunden. Ist es m¨oglich das Ziel von einer Stunde zu erreichen, indem die Anzahl der Prozessoren erh¨oht wird? Be- gr¨unden Sie ihre Antwort und geben Sie alle Rechenschritte an. Assume a company has a program P and our goal is to make it run in less than an hour. On a single-processor machine, the program P runs in 4 hours. On a machine with 2 processors, the program P runs in 3 hours. Is it possible to achieve the one hour target by increasing the number of processors? Justify your answer and show all calculation steps. Parallele Programmierung - Semesterpr¨ufung - Seite 4 von 27 Mittwoch, 19.08.2020 Pipelining (11 points) 3. Vier Konditoren in einer B¨ackerei teilen 4 Arbeitsger¨ate miteinander. Um eine Schachtel Brownies herzustellen ben¨otigt jeder die Ger¨ate in folgender Reihenfolge: Die Mikrowelle (,,mi- crowave“) f¨ur 5 Minuten, den Mixer (,,blen- der“) f¨ur 10 Minuten, den Ofen (,,oven“) f¨ur 20 Minuten und das Schneidebrett (,,cutting board“) f¨ur 5 Minuten. Four pastry chefs in a bakery share four appliances with each other. Preparing a box of brownies requires everyone to use the appliances in the following order: the microwave for 5 minutes, the blender for 10 minutes, the oven for 20 minutes, and ﬁnally the cutting board for 5 minutes. microwave 5 min blender 10 min oven 20 min cutting board 5 min Abbildung 1: Die Browniepipeline. Figure 2: The brownie cooking pipeline. Sie k¨onnen den folgenden Platz f¨ur Notizen ver- wenden. You can use the following space to take notes. (a) (3)Nehmen Sie an, dass die Brownies in streng sequentieller Reihenfolge hergestellt werden (ein Konditor beginnt erst, wenn ein anderer mit dem Schneidbrett fertig ist). Berechnen Sie, wie lange die 4 Konditoren ben¨otigen um je eine Schachtel Brownies herzustellen. Was ist der Throughput pro Stunde? Geben Sie alle Rechenschritte an. Assuming they would prepare the brownies in strictly sequential order (one chef starts only after the other has ﬁn- ished with the cutting board), calculate how long would it take for four chefs to each make a box of brownies. What is the throughput per hour? Show all cal- culation steps. Parallele Programmierung - Semesterpr¨ufung - Seite 5 von 27 Mittwoch, 19.08.2020 (b) (4)Angenommen wir heben die Einschr¨ankung auf, dass in sequentieller Reihenfolge gear- beitet werden muss (d.h. wenn Konditoren verschiedene Ger¨ate verwenden, k¨onnen sie gleichzeitig arbeiten). Berechnen Sie, wie lan- ge es dauert bis jeder Konditor eine Schachtel Brownies hergestellt hat. Wie gross ist der Pipeline-Speedup gegen¨uber der vorherigen Aufgabe? Geben Sie alle Rechenschritte an. Assume we remove the rule of sequen- tial order above (i.e., if the chefs are us- ing diﬀerent appliances, they can work at the same time), calculate how long would it take for four chefs to each make a box of brownies. What is the pipeline speedup compared to the ﬁrst approach? Show all calculation steps. (c) (4)Angenommen hoher Throughput der Pipeli- ne ist wichtig, wie w¨urden Sie die Pipeline balancieren? Um dies zu erreichen d¨urfen Sie die Laufzeit von einem oder mehreren Schrit- ten erh¨ohen. Assuming the high throughput of the pipeline is important, how would you make the pipeline balanced? To achieve this, you are allowed to increase the ex- ecution time of one or more stages. microwave ...... min blender ...... min oven ...... min cutting board ...... min Parallele Programmierung - Semesterpr¨ufung - Seite 6 von 27 Mittwoch, 19.08.2020 Task Graphs (11 points) 4. Abbildung 2 zeigt den Task-Graphen eines Al- gorithmus’. Die Zahl in einem Knoten bezeich- net die ben¨otigte Ausf¨uhrungszeit f¨ur den je- weiligen Berechnungsschritt. Figure 2 shows the task graph for an algo- rithm. The number in each node denotes the execution time per task. 50 30 100 100 20 10 100 20 20 10 Abbildung 2: Task-Graph. Figure 2: Task graph. (a) (3)Markieren Sie den kritischen Pfad des Task- Graphen in Abbildung 2. Was ist die Ausf¨uhrungszeit des kritischen Pfads? Mark the critical path of the task graph shown in Figure 2. What is the execu- tion time of the critical path? (b) (3)Was ist die minimale Anzahl Prozessoren, die n¨otig sind um den Task-Graphen in Abbil- dung 2 so schnell wie m¨oglich auszuf¨uhren? What is the minimum number of proces- sors necessary to execute the task graph in Figure 2 as quickly as possible? Parallele Programmierung - Semesterpr¨ufung - Seite 7 von 27 Mittwoch, 19.08.2020 5. (5)In der Vorlesung haben wir drei Standardmus- ter des parallelen Programmierens gesehen: In the lectures, we have seen three com- monly used patterns in parallel program- ming: Map e.g., [0, 1, 2, 3] 2∗x −−→ [0, 2, 4, 6] Reduce e.g., [0, 1, 2, 3] max −−−→ 3 Pack e.g., [0, 1, 2, 3] x>1 −−→ [2, 3] Wie sieht der optimale Task-Graph (d.h. mit den wenigsten Konten) f¨ur jedes dieser Mus- ter aus? Nehmen Sie an, dass der Code auf ei- ner Maschine mit 4 Prozessoren ausgef¨uhrt wird und nie mehr als 4 Berechnungsschritte par- allel ausgef¨uhrt werden. F¨ur diese Frage sind Ausf¨uhrungszeiten nicht relevant, sondern nur die Anzahl der Berechnungsschritte und ihre Abh¨angigkeiten. How does the optimal task graph (i.e., with minimum number of nodes) look like for each pattern? You can assume that the code is executed on a machine with 4 pro- cessors and no more than 4 tasks would run in parallel. For this question, the ex- ecution time of tasks is not relevant, only the number of tasks and their dependen- cies. Map Vervollst¨andigen Sie den Task-Graphen Complete the task graph Reduce Vervollst¨andigen Sie den Task-Graphen Complete the task graph Pack Vervollst¨andigen Sie den Task-Graphen Complete the task graph Parallele Programmierung - Semesterpr¨ufung - Seite 8 von 27 Mittwoch, 19.08.2020 Wait/Notify (13 points) 6. Ein beliebtes Restaurant hat einen endlosen Ansturm an Kunden, aber eine maximale Kapa- zit¨at von 50. Dieses Restaurant und seine Kell- ner modellieren wir als Threads. Um die Arbeit gleichm¨assig zu verteilen darf ein Kellner nur Kunden bedienen, wenn er nicht mehr Kunden bedient hat als andere Kellner. A popular restaurant in town has a never- ending lineup of customers, but has a max- imum capacity of 50. The restaurant and its waiters are modelled as threads. To spread the workload evenly, a waiter may serve customers only if he has not served more customers than other waiters. (a) (13)Vervollst¨andigen Sie das folgende Code- Skelett gem¨ass der Beschreibung in den Kommentaren. Ihre L¨osung sollte notify(), notifyAll(), wait() und das synchronized-Schl¨usselwort verwenden um Ihr Programm korrekt zu synchronisieren, aber Sie sollen keine unn¨otige Synchronisa- tion einf¨uhren. In dieser Aufgabe m¨ussen Sie Exceptions nicht behandeln. Complete the following code skeleton ac- cording to the description in the com- ments. Make sure that your solu- tion is properly synchronized by using notify(), notifyAll(), wait() and the synchronized keyword where re- quired, but do not introduce unneces- sary synchronization. For this task, you do not need to handle exceptions. public class Restaurant extends Thread { private ArrayList<Waiter> waiters = new ArrayList<Waiter>(); private Queue<Customer> customers = new LinkedList<>(); private final int customerLimit = 50; public Restaurant(ArrayList<Waiter> waiters) { this.waiters = waiters; } // Das Restaurant wiederholt undendlich lange: // 1. Wartet, falls die Restaurantkapazit¨at erreicht ist // 2. F¨ugt Kunden an das Ende der Queue an // 3. Benachrichtigt Kellner ¨uber hinzugef¨ugte Kunden /* The Restaurant repeats forever: 1. Waits if the restaurant capacity is full 2. Adds customers to the back of the queue 3. Notifies waiters about newly added customers */ public void run() { while(true) { ................................................. ................................................. ................................................. ................................................. ................................................. customers.add(new Customer()); ................................................. ................................................. ................................................. ................................................. } } Parallele Programmierung - Semesterpr¨ufung - Seite 9 von 27 Mittwoch, 19.08.2020 public synchronized Customer getCustomer() { return customers.remove(); } // Wird von Kellner-Threads aufgerufen. /* Should be called by the waiter threads. */ public synchronized boolean shouldWaiterServe(Waiter waiter) { ................................................. ................................................. ................................................. for (int i = 0; i < waiters.size(); i++) { ................................................. ................................................. ................................................. ................................................. } ................................................. } } public class Waiter extends Thread { private Restaurant restaurant; private int servedCustomers = 0; public Waiter(Restaurant restaurant) { this.restaurant = restaurant; } // Ein Kellner wiederholt undendlich lange: // 1. Wartet, falls es keine Kunden zu bedienen gibt ODER // falls er mehr Kunden bedient hat als andere Kellner. // 2. Bedient den n¨achsten Kunden in der Queue /* A waiter repeats forever: 1. Waits if there are no customers to serve OR if they have served more customers than another waiter. 2. Serves the next customer in the customer queue */ public void run() { while (true) { ................................................. ................................................. ................................................. ................................................. ................................................. serveCustomer(restaurant.getCustomer()); ................................................. ................................................. ................................................. ................................................. } } Parallele Programmierung - Semesterpr¨ufung - Seite 10 von 27 Mittwoch, 19.08.2020 public int getServedCustomers() { return servedCustomers; } private void serveCustomer(Customer customer){ ................................................. ................................................. System.out.println(\"Served Customer: \" + customer); } } public class Customer { public Customer() {} } Parallele Programmierung - Semesterpr¨ufung - Seite 11 von 27 Mittwoch, 19.08.2020 Fork/Join Framework (14 points) 7. Wir m¨ochten eine Sequenz von Zahlen v0, . . . , vn ver¨andern, indem wir zu jeder Zahl den Wert der vorhergehenden Zahl addieren. Das heisst, der Wert vi an Position i wird zu vi ← vi + vi−1 ge¨andert. Nur die erste Zahl bleibt unver¨andert, da es keine vorhergehende Zahl gibt. Die sequentielle Version sowie einige Beispiele sind hier gegeben: Given a sequence of numbers v0, . . . , vn, we want to update the sequence by adding the preceding value to each value. That is, the value vi at position i should be up- dated as vi ← vi + vi−1. The only excep- tion is the ﬁrst element, which remains un- changed since no preceding number exists. The sequential version along with a few ex- amples is provided below: [0, 1, 2, 3] → [0, 1, 3, 5] [0, 1, 1, 3] → [0, 1, 2, 4] public void prevSum(int[] data) { for(int i = 1; i < data.length; ++i) { data[i] = data[i] + data[i-1]; } } (a) (10)Vervollst¨andigen Sie das Code-Skelett auf der n¨achsten Seite. Ihre L¨osung muss die Berechnung direkt auf dem Array data (in-place) vornehmen. Verwenden Sie keine zus¨atzlichen Datenstrukturen (z.B. Arrays, Listen, Hashmaps, etc.). Stellen Sie sicher, dass die Daten so auf die Sub-Tasks verteilt werden, dass alle ungef¨ahr gleich viel Arbeit haben. In dieser Aufgabe m¨ussen Sie Exceptions nicht behandeln. Complete the code skeleton on the next page using the ForkJoin framework. The solution has to perform the computation in-place (i.e., directly update the data array) without us- ing any auxiliary data structures (e.g., arrays, lists, hashmaps, etc.). Make sure to split the data such that subtasks have roughly the same amount of work. For this task, you do not need to handle exceptions. Parallele Programmierung - Semesterpr¨ufung - Seite 12 von 27 Mittwoch, 19.08.2020 public void fjPrevSum(int[] data) { ForkJoinPool fjp = new ForkJoinPool(); PrevSumFJ task = new PrevSumFJ(data, 0, data.length, ..................); fjp.invoke(task); } class PrevSumFJ extends .......................... { private int[] data; private int start; private int length; .......................... .......................... public PrevSumFJ( int[] data, int start, int length, .......................... .......................... ) { this.data = data; this.start = start; this.length = length; .......................... .......................... .......................... } protected ............ compute() { if (length == 1) { ............................................................... ............................................................... ............................................................... ............................................................... } ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. ................................................................. } } Parallele Programmierung - Semesterpr¨ufung - Seite 13 von 27 Mittwoch, 19.08.2020 (b) (4)In der vorherigen Aufgabe haben wir je- dem PrevSumFJ Task eine Referenz auf das zugrundeliegende Array data gegeben. Das heisst, alle Tasks arbeiten auf demselben Ar- ray data. Hat Ihre L¨osung Data-Races? Be- gr¨unden Sie Ihre Antwort. In the previous task, we passed a ref- erence to the underlying data array to each PrevSumFJ task. That is, all the tasks operate on the same array data. Does your code contain data races? Jus- tify your answer. Parallele Programmierung - Semesterpr¨ufung - Seite 14 von 27 Mittwoch, 19.08.2020 Locks (14 points) 8. (a) (3)Kreuzen Sie alle wahren Aussagen an. Mark all true statements. ⃝ Ein Lock darf keine Deadlocks erzeugen um korrekt zu sein. A lock must be deadlock-free to be con- sidered correct. ⃝ Ein Lock muss wait-free sein um korrekt zu sein. A lock must be wait-free to be consid- ered correct. ⃝ Ein Lock muss starvation-free sein um kor- rekt zu sein. A lock must be starvation-free to be considered correct. ⃝ Ein Lock f¨ur n Threads ben¨otigt O(n) Spei- cherplatz. A lock for n threads requires O(n) stor- age space. ⃝ Ein Lock f¨ur n Threads kann unter Ver- wendung von ausschliesslich atomaren Re- gistern implementiert werden. A lock for n threads can be imple- mented using only atomic registers. ⃝ Ein starvation-freies lock ist immer auch fair. A starvation-free lock is always fair. (b) (6)Auf eine sortierte, verkettete Liste l, welche die Knoten head, a, b, c, d und tail enth¨alt, wenden wir die Operation insert(e) gefolgt von contains(d) an. Es ﬁnden keine Opera- tionen parallel statt. Wie viele Locks werden w¨ahrend dieser Operationen genommen/frei- gegeben f¨ur verschiedene Implementierungs- varianten von l? Begr¨unden Sie ihre Antwor- ten. On a sorted, linked list l which contains the nodes head, a, b, c, d, tail we per- form the operation insert(e) followed by contains(d). No other operation happen in parallel. How many lock aquisition- s/releases are necessary for these oper- ations for diﬀerent implementation vari- ants of l? Make sure to justify your an- swers. Die Liste l ist mittels coarse-grained synchro- nisation implementiert. The list l is implemented using coarse- grained synchronization. Die Liste l ist mittels ﬁne-grained synchroni- sation implementiert. The list l is implemented using ﬁne- grained synchronization. Die Liste l ist mittels optimistic synchronisa- tion implementiert. The list l is implemented using opti- mistic synchronization. Parallele Programmierung - Semesterpr¨ufung - Seite 15 von 27 Mittwoch, 19.08.2020 (c) (5)Beweisen Sie, dass das unten angegebe- ne Lock gegenseitigen Ausschluss f¨ur zwei Threads gew¨ahrleistet. Sie k¨onnen von se- quentiell konsistentem Speicher ausgehen. Wenden Sie eine der in der Vorlesung gezeig- ten Beweistechniken an. For the lock shown below, give a formal proof that it provides mutual exclusion for two threads. Assume a sequentially consistent memory. Use one of the proof techniques you saw in the lecture. class Peterson implements Lock { private boolean[] flag = new boolean[2]; private int victim; public void lock() { int i = ThreadID.get(); int j = 1 - i; flag[i] = true; victim = i; while(flag[j] && victim == i) { }; } public void unlock() { int i = ThreadID.get(); flag[i] = false; } } Parallele Programmierung - Semesterpr¨ufung - Seite 16 von 27 Mittwoch, 19.08.2020 Linearizability (16 points) 9. (a) (6)Geben Sie eine Deﬁnition f¨ur die folgenden Begriﬀe (im Zusammenhang mit Linearisier- barkeit) an: Give deﬁnitions for the following terms (used in the context of linearizability): Equivalent histories Sequential history Well formed history (b) (2)Zeichnen Sie f¨ur jeden Methodenaufrufe einen Linearisierungspunkt ein. Die Linea- risierungspunkte der ersten beiden Aufrufe wurden bereits als Beispiel eingetragen. Al- le Objekte sind atomare Register, welche mit Null initialisiert wurden. Mark a linearization point for each of the method calls. The ﬁrst two calls have been marked as an example. All ob- jects are atomic registers and initialized to zero. Parallele Programmierung - Semesterpr¨ufung - Seite 17 von 27 Mittwoch, 19.08.2020 (c) (8)Geben Sie f¨ur jede der gegebenen Histori- en an, ob diese linearisierbar und / oder se- quentiell konsistent sind. Alle Objekte sind atomare Register welche mit Null initializiert wurden. Indicate for each of the given history if it is linearizable and / or sequentially con- sistent. All objects are atomic registers and initialized to zero. ⃝ Die Historie ist linearisierbar. The history is linearizable. ⃝ Die Historie ist sequentiell konsistent. The history is sequentially consistent. ⃝ Die Historie ist linearisierbar. The history is linearizable. ⃝ Die Historie ist sequentiell konsistent. The history is sequentially consistent. A:r.write(1) B.r.write(2) A:void A:r.write(3) B:void B:r.read() B:1 A.void ⃝ Die Historie ist linearisierbar. The history is linearizable. ⃝ Die Historie ist sequentiell konsistent. The history is sequentially consistent. A:r.write(2) A:void A:r.write(1) A:void B:r.read() B:2 Parallele Programmierung - Semesterpr¨ufung - Seite 18 von 27 Mittwoch, 19.08.2020 ⃝ Die Historie ist linearisierbar. The history is linearizable. ⃝ Die Historie ist sequentiell konsistent. The history is sequentially consistent. Parallele Programmierung - Semesterpr¨ufung - Seite 19 von 27 Mittwoch, 19.08.2020 Barriers (6 points) 10. (a) (3)Das folgende Program ist ein Versuch eine Barriere in Java zu implementieren. Es funk- tioniert nicht wie vorgesehen. Erkl¨aren Sie warum. The following program is an attempt to implement a barrier in Java. It does not work as intended. Explain why. 1 class NonBarrier1 implements Barrier { 2 final int n; // number of expected threads 3 int nDone = 0; // number of arrived threads 4 5 public synchronized void wait() { 6 nDone += 1; 7 if (nDone == n) notifyAll(); 8 else while(nDone < n) wait(); 9 nDone -= 1; 10 } 11 } Parallele Programmierung - Semesterpr¨ufung - Seite 20 von 27 Mittwoch, 19.08.2020 (b) (3)Jemand schl¨agt die folgende “korre- gierte” Variante der obigen Barrieren- Implementation vor. Erkl¨aren Sie das Problem mit dieser Barriere. Gibt es einen Anwendungsfall, in dem diese Barriere funktioniert? Someone suggests the following as a “correction” to the above barrier imple- mentation. Explain what is the prob- lem with this barrier. Is there a use-case where this barrier works? 1 class NonBarrier2 implements Barrier { 2 final int n; // number of expected threads 3 int nDone = 0; // number of arrived threads 4 5 public synchronized void wait() { 6 nDone += 1; 7 if(nDone == n) notifyAll(); 8 else while(nDone < n) wait(); 9 } 10 } Parallele Programmierung - Semesterpr¨ufung - Seite 21 von 27 Mittwoch, 19.08.2020 Wait-free (7 points) 11. (a) (3)Vervollst¨andigen die das unten abgebilde- te Zustandsdiagramm eines Bin¨ar-Konsens Protokolls. Markieren Sie f¨ur jeden nicht- Ausgabezustand ob es sich um einen biva- lenten, univalenten oder kritischen Zustand handelt. Complete the state diagram of a binary consensus protocol depicted below. For each non-output state indicate if it is bi- valent, univalent, or critical. (b) (4)Ein dreiwertiges Register kann die Wer- te ⊥, 0, 1 aufnehmen und stellt die atoma- ren Methoden compareAndSet(), read() und write() mit der bekannten Semantik zur Verf¨ugung. Jedes solche Register ist zu Be- ginn ⊥. Geben Sie einen Algorithmus an, welcher ein solches Register benutzt um n- thread Consensus zu l¨osen f¨ur bin¨are Einga- ben, d.h., 0 oder 1. A ternary register can hold the values ⊥, 0, 1, and provides atomic methods compareAndSet(), read(), and write() with the usual meaning. Each such regis- ter is initially ⊥. Give an algorithm that uses one such register to solve n-thread consensus if the inputs of the threads are binary, that is, either 0 or 1. Parallele Programmierung - Semesterpr¨ufung - Seite 22 von 27 Mittwoch, 19.08.2020 Message passing (8 points) 12. (a) (6)Nutzen Sie MPI um die Methode int AddNums(int x) zu implementieren, welche von jedem Prozess in MPI.COMM WORLD ein- mal aufgerufen wird, und die Summe aller ¨ubergebenen Werte zur¨uck gibt. Nutzen Sie ausschliesslich die unten angegebenen Metho- den. Use MPI to implement the method int AddNums(int x), which is called once by every process in MPI.COMM WORLD and re- turns the sum of all passed values. Only use the Methods given below. 1 // Usable Methods: 2 // MPI.COMM_WORLD.send(buffer, numItems, MPI.INT, dest, tag); 3 // MPI.COMM_WORLD.recv(buffer, numItems, MPI.INT, src, tag); 4 5 public int AddNums(int x) { 6 int rank = MPI.COMM_WORLD.Rank(); 7 int size = MPI.COMM_WORLD.Size(); 8 9 int sum = 0; 10 int[] buf = new int[1]; 11 12 if (rank == 0) { 13 for (int src = 1; src < size; ++src) { 14 MPI.COMM_WORLD.recv(buf, 1, MPI.INT, src, 0); 15 sum += buf[0]; 16 } 17 sum += x; 18 buf[0] = sum; 19 for (int dst = 1; dst < size; ++dst) { 20 MPI.COMM_WORLD.send(buf, 1, MPI.INT, dst, 0); 21 } 22 } else { 23 buf[0] = x; 24 MPI.COMM_WORLD.send(buf, 1, MPI.INT, 0, 0); 25 MPI.COMM_WORLD.recv(buf, 1, MPI.INT, 0, 0); 26 sum = buf[0]; 27 } 28 29 return sum; 30 } (b) (2)Die Einschr¨ankung, nur die Methoden send und recv zu verwenden, wird aufgehoben. Welche MPI Methode k¨onnen Sie verwen- den, um obiges Problem mit einem einzigen MPI Aufruf zu l¨osen? Welche MPI Metho- de k¨onnen Sie verwenden, wenn das Resul- tat nur von einem einzigen Prozess ben¨otigt wird? The restriction to only use the send and recv functions has been lifted. Which MPI method could you use to solve the above problem with a single MPI call? Which MPI method could you use if the result is only needed on a single process? Parallele Programmierung - Semesterpr¨ufung - Seite 23 von 27 Mittwoch, 19.08.2020Parallele Programmierung - Semesterpr¨ufung - Seite 24 von 27 Mittwoch, 19.08.2020 Mixer (9 points) 13. (a) (1)Unter welchen Bedingungen sind ein Lock und eine Semaphore semantisch equivalent? Under which conditions are a lock and a semaphore semantically equivalent? (b) (2)K¨onnen Transaktionen in einem Software Transactional Memory System Deadlocks er- zeugen? Begr¨unden Sie ihre Antwort. Can transactions in a Software Transac- tional Memory system induce deadlocks? Justify your answer. (c) (2)Ist das Folgende ein korrektes Sortiernetz- werk f¨ur vier Engaben? Wenn nein, warum nicht? Die Eingaben werden auf der lin- ken Seite der horizontalen Linien zugef¨uhrt, Komparatoren werden durch vertikale Linien symbolisiert. Is the following a correct sorting network for four inputs? If not, why? Inputs are applied to the left side of the horizontal lines, comparators are symbolized by the vertical lines. (d) (4)Zeigen Sie, dass wenn Bin¨ar-Konsensus mit- tels atomaren Register f¨ur zwei Threads unl¨osbar ist, ist es auch f¨ur n threads, mit n > 2 unl¨osbar. Show that if binary consensus using atomic registers is impossible for two threads, then it is also impossible for n threads, where n > 2. Parallele Programmierung - Semesterpr¨ufung - Seite 25 von 27 Mittwoch, 19.08.2020 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu ﬁnden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found. Parallele Programmierung - Semesterpr¨ufung - Seite 26 von 27 Mittwoch, 19.08.2020 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu ﬁnden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found. Parallele Programmierung - Semesterpr¨ufung - Seite 27 von 27 Mittwoch, 19.08.2020 Grading Scale The point shown are the smallest number of points to get the indicated grade. points grade 0 1 4.3 1.25 8.6 1.5 13 1.75 17.3 2 21.6 2.25 26 2.5 30.3 2.75 34.6 3 39 3.25 43.3 3.5 47.6 3.75 52 4 58.3 4.25 64.6 4.5 71 4.75 77.3 5 83.6 5.25 90 5.5 96.3 5.75 102.6 6","libVersion":"0.3.2","langs":""}