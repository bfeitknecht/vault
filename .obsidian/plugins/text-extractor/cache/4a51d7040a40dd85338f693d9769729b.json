{"path":"sem4/FMFP/UE/e/FMFP-u03-e.pdf","text":"Formal Methods and Functional Programming Exercise Sheet 3 252-0058-00L March 3, 2025 For the first part of the course, there will be both pen-and-paper exercises and programming exercises. The programming exercises are uploaded on Code Expert: https://expert.ethz.ch/enrolled/SS25/fmfp/exercises Happy coding! As for the pen-and paper exercises, each week you may hand in your solution to the exercise marked with a (⋆) and receive feedback from your TA. You are encouraged to do so. Of course, if you have any questions about the solutions of the other exercises, please also reach out to your TA! Exercises marked as weekly headaches are challenging bonus problems. They are just meant as supplements to test your FMFP skills. 1(⋆). Induction (a) Write down the induction scheme for natural numbers as a proof rule. Hint: The conclusion of your rule should be Γ ⊢ ∀n : Nat. P . (b) In the first week, you saw two implementations for computing the Fibonacci numbers. Namely, Louis Reasoner wrote the Haskell program fibLouis :: Int -> Int fibLouis 0 = 0 -- fibLouis.1 fibLouis 1 = 1 -- fibLouis.2 fibLouis n = fibLouis (n - 1) + fibLouis (n - 2) -- fibLouis.3 whereas Eva La Tour wrote the Haskell program fibEva :: Int -> Int fibEva n = fst (aux n) -- fibEva.1 where aux 0 = (0, 1) -- aux.1 aux n = next (aux (n - 1)) -- aux.2 next (a, b) = (b, a + b) -- next.1 Prove that fibLouis and fibEva compute the same function on the naturals, i.e., show that ∀n : N at. fibLouis n = fibEva n. You first have to prove that ∀n : N at. aux n = (fibLouis n, fibLouis (n + 1)) using induction over n. Hint: Identify the predicate P used in the induction. Use the linear equational reasoning style and justify each reasoning step by referring to the equation names given in the comments above. 1 Formal Methods and Functional Programming Exercise Sheet 3 252-0058-00L March 3, 2025 2. Lists (a) Let g be the function defined as g x y = 1 + y. Evaluate foldr g 0 [1,2,3] by hand and show all intermediate steps (as in Week 1). What function is computed if [1,2,3] is replaced by an arbitrary list? (b) What function is computed by foldr (:) [] ? Prove your claim! (c) The function filterMap :: (b->Bool)->(a->b)->[a]->[b] is defined as fol- lows. filterMap p f = filter p. map f Note that the . above is function composition. Another possible definition is based on foldr: filterMap' p f = foldr aux e assuming that aux and e are defined appropriately. Give definitions for aux and e such that filterMap = filterMap'. 2","libVersion":"0.3.2","langs":""}