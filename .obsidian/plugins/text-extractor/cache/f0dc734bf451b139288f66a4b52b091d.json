{"path":"sem3/TIN/VRL/extra/TI-nwehrl-w01.pdf","text":"Theoretische Informatik HS24 Nicolas Wehrli ¨Ubungsstunde 01 25. September 2024 ETH Z ¨urich nwehrl@ethz.ch 1 Heute 1 Organisation 2 Grundbegriffe Alphabet Wort Sprache 3 Algorithmische Probleme 4 Kolmogorov Komplexit¨at 2 Organisation Organisation Kontakt In der ¨Ubungsstunde Per Mail an nwehrl@student.ethz.ch Discord: .blackphoenyx, bzw. Nicolas[TI] WhatsApp-Chat QR-Code und Link per Mail Aufgaben 50% der Punkte reichen f ¨ur Teilnahme an Midterms (zu empfehlen) Gruppeneinteilung heute LaTex Empfehlung, Overleaf, Template Abgaben per Moodle Webseite: https://n.ethz.ch/∼nwehrl/TheoInf 3 Grundbegriffe Notation F ¨ur eine Menge A bezeichnet |A| die Kardinalit¨at von A und P(A) = {S | S ⊆ A} die Potenzmenge von A. In diesem Kurs definieren wir N = {0, 1, 2, . . . }. 4 Alphabet Definition Alphabet Eine endliche, nichtleere Menge Σ heisst Alphabet. Die Elemente eines Alpha- bets werden Buchstaben (Zeichen, Symbole) genannt. Beispiele Σbool = {0, 1} Σlat = {a, ..., z} ΣTastatur = Σlat ∪ {A, ..., Z, , >, <, (, ), ..., !} Σlogic = {0, 1, (, ), ∧, ∨, ¬} Σabc = {a, b, c} (unser Beispiel f ¨ur weitere Definitionen) 5 Wort Definition Wort - Sei Σ ein Alphabet. Ein Wort ¨uber Σ ist eine endliche (eventuell leere) Folge von Buchstaben aus Σ. - Das leere Wort λ ist die leere Buchstabenfolge. - Die L¨ange |w| eines Wortes w ist die L¨ange des Wortes als Folge, i.e. die Anzahl der Vorkommen von Buchstaben in w. - Σ∗ ist die Menge aller W ¨orter ¨uber Σ. Σ+ := Σ∗ \\ {λ} ist Menge aller nichtleeren W ¨orter ¨uber Σ. - Seien x ∈ Σ∗ und a ∈ Σ. Dann ist |x|a definiert als die Anzahl der Vorkom- men von a in x. Achtung Metavariablen! I.e. Das a steht hier f ¨ur einen beliebigen Buchstaben aus Σ und nicht nur f ¨ur den Buchstaben ’a’, der in Σ sein k ¨onnte. 6 Wort Bemerkungen - Wir schreiben W ¨orter ohne Komma, i.e. eine Folge x1, x2, ..., xn schreiben wir x1x2...xn. - |λ| = 0 aber | | = 1 von ΣTastatur. - Der Begriff Wort als Fachbegriff der Informatik entspricht nicht der Bedeutung des Begriffs Wort in nat ¨urlichen Sprachen! - E.g. Mit kann der Inhalt eines Buches oder ein Programm als ein Wort ¨uber ΣTastatur betrachtet werden. Beispiel Verschiedene W ¨orter ¨uber Σabc: a, aa, aba, cba, caaaab etc. 7 Konkatentation Die Verkettung (Konkatenation) f ¨ur ein Alphabet Σ ist eine Abbildung Kon: Σ∗ × Σ∗ → Σ∗, so dass Kon(x, y) = x · y = xy f ¨ur alle x, y ∈ Σ∗. - Die Verkettung Kon (i.e. Kon von einem Kon ( ¨uber das gleiche Alphabet Σ)) ist eine assoziative Operation ¨uber Σ∗. Kon(u, Kon(v, w)) = Kon(Kon(u, v), w), ∀u, v, w ∈ Σ∗ - x · λ = λ · x = x, ∀x ∈ Σ∗ - =⇒ (Σ∗, Kon) ist ein Monoid mit neutralem Element λ. - Kon nur kommutativ, falls |Σ| = 1. - |xy| = |x · y| = |x| + |y|. (Wir schreiben ab jetzt xy statt Kon(x, y)) 8 Konkatentation - Beispiel Beispiel Wir betrachten wieder Σabc. Sei x = abba, y = cbcbc, z = aaac. - Kon(x, Kon(y, z)) = Kon(x, yz) = xyz = abbacbcbcaaac - |xy| =|abbacbcbc| = 9 = 4 + 5 = |abba| + |cbcbc| = |x| + |y| 9 Reversal und Iteration F ¨ur eine Wort a = a1a2...an, wobei ∀i ∈ {1, 2, ..., n}. ai ∈ Σ, bezeichnet aR = anan−1...a1 die Umkehrung (Reversal) von a. Sei Σ ein Alphabet. F ¨ur alle x ∈ Σ∗ und alle i ∈ N definieren wir die i-te Iteration xi von x als x0 = λ, x 1 = x und xi = xx i−1. 10 Reversal und Iteration - Beispiele Beispiel Wir betrachten wieder Σabc. Sei x = abba, y = cbcbc, z = aaac. - zR = (aaac)R = caaa - xR = (abba)R = abba - x0 = λ - y2 = yy2−1 = yy = cbcbccbcbc - z3 = zz2 = zzz = aaacaaacaaac - (xRzR)R = ((abba)R(aaac)R)R = (abbacaaa)R = aaacabba 11 Teilwort, Pr¨afix und Suffix Seien v, w ∈ Σ∗ f ¨ur ein Alphabet Σ. - v heisst ein Teilwort von w ⇐⇒ ∃x, y ∈ Σ∗ : w = xvy - v heisst ein Pr¨afix von w ⇐⇒ ∃y ∈ Σ∗ : w = vy - v heisst ein Suffix von w ⇐⇒ ∃x ∈ Σ∗ : w = xv - v ̸= λ heisst ein echtes Teilwort (Pr¨afix, Suffix) von w ⇐⇒ v ̸= w und v Teilwort (Pr¨afix, Suffix) von w 12 Teilwort, Pr¨afix und Suffix - Beispiel Beispiel Wir betrachten wieder Σabc. Sei x = abba, y = cbcbc, z = aaac. - bc ist ein echtes Suffix von y - abba ist kein echtes Teilwort von x. - cbcb ist ein echtes Teilwort und echtes Pr¨afix von y. - ac ist ein echtes Suffix. - abba ist ein Suffix, Pr¨afix und Teilwort von x. 13 Teilw ¨orter - Beispielaufgabe 1 Sei Σ ein Alphabet und sei w ∈ Σ∗ ein Wort der L¨ange n ∈ N \\ {0}. Wie viele unterschiedliche Teilw ¨orter kann w h ¨ochstens haben? Wir haben w = w1w2...wn mit wi ∈ Σ f ¨ur i = 1, ..., n. Wie viele Teilw ¨orter beginnen mit w1? Wie viele Teilw ¨orter beginnen mit w2? Wir haben also n + (n − 1) + ... + 1 = n(n+1) 2 Teilw ¨orter. Etwas fehlt aber in unserer Berechnung. . . Das leere Wort λ ist auch ein Teilwort! Also haben wir n(n+1) 2 + 1 Teilw ¨orter. 14 Teilw ¨orter - Beispielaufgabe 2 Sei Σ = {a, b, c} und n ∈ N. Bestimme die Anzahl der W ¨orter aus Σn, die das Teilwort a enthalten. In solchen Aufgaben ist es manchmal einfach, das Gegenteil zu berechnen und so auf die L ¨osung zu kommen. Wie viele W ¨orter aus Σn enthalten das Teilwort a nicht? Da wir jetzt die Anzahl W ¨orter der L¨ange n wollen, die nur b und c enthalten, kommen wir auf |{b, c}|n = 2n. Daraus folgt, dass genau |Σ|n − 2n = 3n − 2n W ¨orter das Teilwort a enthalten. 15 Teilw ¨orter - Beispielaufgabe 3 Sei Σ = {a, b, c} und n ∈ N \\ {0}. Bestimme die Anzahl der W ¨orter aus Σn, die das Teilwort aa nicht enthalten. Wir bezeichnen die Menge aller W ¨orter mit L¨ange n ¨uber Σ, die aa nicht enthalten als Ln. Schauen wir mal die ersten zwei F¨alle an: L1 = {a, b, c} =⇒ |L1| = 3 L2 = {ab, ac, ba, bb, bc, ca, cb, cc} =⇒ |L2| = 8 16 Teilw ¨orter - Beispielaufgabe 3 Nun k ¨onnen wir f ¨ur m ≥ 3 jedes Wort w ∈ Lm als Konkatination w = x · y · z, |y| = |z| = 1 schreiben, wobei wir zwei F¨alle unterscheiden: (a) z ̸= a In diesem Fall kann y ∈ {a, b, c} sein, ohne dass die Teilfolge aa entsteht und somit ist xy ein beliebiges Wort aus Lm−1. Dann k ¨onnten wir alle W ¨orter in diesem Case durch Lm−1 · {b, c} beschreiben, was uns die Kardinalit¨at 2 · |Lm−1| gibt. (b) z = a In diesem Fall muss y ̸= a sein, da sonst aa entstehen w ¨urde. Somit kann xy nur in b oder c enden. x kann aber ein beliebiges Wort der L¨ange m − 2 sein. Deshalb k ¨onnen wir alle W ¨orter in diesem Case durch Lm−2 · {b, c} · {a} beschreiben. Kardinalit¨at: 2 · |Lm−2|. 17 Teilw ¨orter - Beispielaufgabe 3 Daraus folgt |Ln| =    3 n = 1 8 n = 2 2|Ln−1| + 2|Ln−2| n ≥ 3 18 Kanonische Ordnung Sei Σ = {s1, s2, ..., sm}, m ≥ 1, ein Alphabet und sei s1 < s2 < ... < sm eine Ordnung auf Σ. Wir definieren die kanonische Ordnung auf Σ∗ f ¨ur u, v ∈ Σ∗ wie folgt: u < v ⇐⇒ |u| < |v| ∨ (|u| = |v| ∧ u = x · si · u ′ ∧ x · sj · v ′) f ¨ur irgendwelche x, u′, v′ ∈ Σ∗ und i < j. 19 Kanonische Ordnung - Beispiel Sei Σabc = {a, b, c} und wir betrachten folgende Ordnung auf Σabc: c < a < b. Was w¨are die kanonische Ordnung folgender W ¨orter? – c, abc, aaac, aaab, bacc, a, λ λ, c, a, abc, aaac, aaab, bacc 20 Sprache Eine Sprache L ¨uber einem Alphabet Σ ist eine Teilmenge von Σ∗. - Das Komplement L∁ der Sprache L bez ¨uglich Σ ist die Sprache Σ∗ \\ L. - L∅ = ∅ ist die leere Sprache. - Lλ = {λ} ist die einelementige Sprache, die nur aus dem leeren Wort besteht. Konkatenation von Sprachen Sind L1 und L2 Sprachen ¨uber Σ, so ist L1 · L2 = L1L2 = {vw | v ∈ L1 und w ∈ L2} die Konkatenation von L1 und L2. 21 Iteration von Sprachen Ist L eine Sprache ¨uber Σ, so definieren wir L 0 := Lλ und Li+1 := L i · L f ¨ur alle i ∈ N, L ∗ = ⋃ i∈N Li und L + = ⋃ i∈N\\{0} L i = L · L ∗. L∗ nennt man den Kleene’schen Stern von L. Man bemerke, dass Σi = {x ∈ Σ∗ | |x| = i}, L∅L = L∅ = ∅ und Lλ · L = L. 22 Sprachen - Beispiel M ¨ogliche Sprachen ¨uber Σabc - L1 = ∅ - L2 = {λ} - L3 = {λ, ab, baca} - L4 = Σ∗ abc, L5 = Σ + abc, L6 = Σabc oder L7 = Σ27 abc - L8 = {c}∗ = {ci | i ∈ N} - L9 = {ap | p ist prim.} - L10 = {cia3i2baic | i ∈ N} λ ist ein Wort ¨uber jedes Alphabet. Aber es muss nicht in jeder Sprache enthalten sein! 23 Lemmas ¨uber Sprachen Seien L1, L2 und L3 Sprachen ¨uber einem Alphabet Σ. Dann gilt L1L2 ∪ L1L3 = L1(L2 ∪ L3) (1) L1(L2 ∩ L3) ⊆ L1L2 ∩ L1L3 (2) Weshalb nicht ’=’ bei (2)? Sei Σ = Σbool = {0, 1}, L1 = {λ, 1}, L2 = {0} und L3 = {10}. Dann haben wir L1(L2 ∩ L3) = ∅ ̸= {10} = L1L2 ∩ L1L3. Beweise im Buch/Vorlesung 24 Aufgaben Aufgabe 2.10 Seien L1, L2 und L3 Sprachen ¨uber dem Alphabet {0}. Gilt L1(L2 ∩ L3) = L1L2 ∩ L1L3? Aufgabe 2.11 Seien L1 ⊆ Σ∗ 1 und L2, L3 ⊊ Σ∗ 2 f ¨ur zwei Alphabete Σ1 und Σ2 mit Σ1 ∩ Σ2 = ∅. Gilt L1(L2 ∩ L3) = L1L2 ∩ L1L3? 25 Von einem Alphabet zum anderen Seien Σ1 und Σ2 zwei beliebige Alphabete. Ein Homomorphismus von Σ∗ 1 nach Σ∗ 2 ist jede Funktion h : Σ∗ 1 → Σ∗ 2 mit den folgenden Eigenschaften: (i) h(λ) = λ und (ii) h(uv) = h(u) · h(v) f ¨ur alle u, v ∈ Σ∗ 1. Wir k ¨onnen Probleme etc. in anderen Alphabeten kodieren. So wie wir verschiedenste Konzepte, die wir auf Computer ¨ubertragen in Σbool kodieren. 26 Algorithmische Probleme Vorl¨aufige Definition des Begriffs Algorithmus Mathematische Definition folgt in Kapitel 4 (Turingmaschinen). Vorerst betrachten wir Programme, die f ¨ur jede zul¨assige Eingabe halten und eine Ausgabe liefern, als Algorithmen. Wir betrachten ein Programm (Algorithmus) A als Abbildung A : Σ∗ 1 → Σ∗ 2 f ¨ur beliebige Alphabete Σ1 und Σ2. Dies bedeutet, dass (i) die Eingaben als W ¨orter ¨uber Σ1 kodiert sind, (ii) die Ausgaben als W ¨orter ¨uber Σ2 kodiert sind und (iii) A f ¨ur jede Eingabe eine eindeutige Ausgabe bestimmt. A und B ¨aquivalent ⇐⇒ Eingabealphabet Σ gleich, A(x) = B(x), ∀x ∈ Σ∗ Ie. diese Notion von ” ¨Aquivalenz” bezieht sich nur auf die Ein und Ausgabe. 27 Entscheidungsprobleme Das Entscheidungsproblem (Σ, L) f ¨ur ein gegebenes Alphabet Σ und eine ge- gebene Sprache L ⊆ Σ∗ ist, f ¨ur jedes x ∈ Σ∗ zu entscheiden, ob x ∈ L oder x /∈ L. Ein Algorithmus A l ¨ost das Entscheidungsproblem (Σ, L), falls f ¨ur alle x ∈ Σ∗ gilt: A(x) =    1, falls x ∈ L, 0, falls x /∈ L. Wir sagen auch, dass A die Sprache L erkennt. 28 Why do we care Wenn f ¨ur eine Sprache L ein Algorithmus existiert, der L erkennt, sagen wir, dass L rekursiv ist. Wir sind oft an spezifischen Eigenschaften von W ¨ortern aus Σ∗ interessiert, die wir mit einer Sprache L ⊆ Σ∗ beschreiben k ¨onnen. Dabei sind dann L die W ¨orter, die die Eigenschaft haben und L∁ = Σ∗ \\ L die W ¨orter, die diese Eigenschaft nicht haben. Jetzt ist die allgemeine Formulierung von Vorteil! 29 Why do we care - Beispiele i. Primzahlen finden: Entscheidungsproblem (Σbool, Lp) wobei Lp = {x ∈ (Σbool)∗ | Nummer(x) ist prim}. ii. Syntaktisch korrekte Programme: Entscheidungsproblem (ΣTastatur, LC++) wobei LC++ = {x ∈ (ΣTastatur)∗ | x ist ein syntaktisch korrektes C++ Programm}. iii. Hamiltonkreise finden: Entscheidungsproblem (Σ, HK) wobei Σ = {0, 1, #} und HK= {x ∈ Σ∗ | x kodiert einen Graphen, der einen Hamiltonkreis enth¨alt.} ¨Aquivalenzprobleme ⊂ Entscheidungsprobleme 30 Funktion, Relation Seien Σ und Γ zwei Alphabete. - Wir sagen, dass ein Algorithmus A eine Funktion (Transformation) f : Σ∗ → Γ∗ berechnet (realisiert), falls A(x) = f (x) f ¨ur alle x ∈ Σ∗ - Sei R ⊆ Σ∗ × Γ∗ eine Relation in Σ∗ und Γ∗. Ein Algorithmus A berechnet R (bzw. l ¨ost das Relationsproblem R), falls f ¨ur jedes x ∈ Σ∗, f ¨ur das ein y ∈ Γ∗ mit (x, y) ∈ R existiert, gilt: (x, A(x)) ∈ R 31 Optimierungsprobleme Ein Optimierungsproblem ist ein 6-Tupel U = (ΣI, ΣO, L, M, cost, goal), wo- bei: (i) ΣI ist ein Alphabet (genannt Eingabealphabet), (ii) ΣO ist ein Alphabet (genannt Ausgabealphabet), (iii) L ⊆ Σ∗ I ist die Sprache der zul¨assigen Eingaben (als Eingaben kommen nur W ¨orter in Frage, die eine sinnvolle Bedeutung haben). Ein x ∈ L wird ein Problemfall (Instanz) von U genannt. (iv) M ist eine Funktion von L nach P(Σ∗ O), und f ¨ur jedes x ∈ L ist M(x) die Menge der zul¨assigen L ¨osungen f ¨ur x, (v) cost ist eine Funktion, cost: ⋃x∈L(M(x) × {x}) → R+, genannt Kosten- funktion, (vi) goal ∈ {Minimum, Maximum} ist das Optimierungsziel. 32 Optimierungsprobleme Eine zul¨assige L ¨osung α ∈ M(x) heisst optimal f ¨ur den Problemfall x des Optimierungsproblems U, falls cost(α, x) = OptU (x) = goal{cost(β, x) | βM(x)}. Ein Algorithmus A l ¨ost U, falls f ¨ur jedes x ∈ L (i) A(x) ∈ M(x) (ii) cost(A(x), x) = goal{cost(β, x) | β ∈ M(x)}. 33 Kolmogorov Komplexit¨at Algorithmen generieren W ¨orter Sei Σ ein Alphabet und x ∈ Σ∗. Wir sagen, dass ein Algorithmus A das Wort x generiert, falls A f ¨ur die Eingabe λ die Ausgabe x liefert. Beispiel: An : begin f o r i = 1 t o n ; w r i t e ( 0 1 ) ; end An generiert (01)n. 34 Aufz¨ahlungsalgorithmus Sei Σ ein Alphabet und sei L ⊆ Σ∗. A ist ein Aufz¨ahlungsalgorithmus f ¨ur L, falls A f ¨ur jede Eingabe n ∈ N \\ {0} die Wortfolge x1, ..., xn ausgibt, wobei x1, ..., xn die kanonisch n ersten W ¨orter in L sind. 35 Information messen Kolmogorov-Komplexit¨at F ¨ur jedes Wort x ∈ (Σbool)∗ ist die Kolmogorov-Komplexit¨at K(x) des Wortes x das Minimum der bin¨aren L¨angen, der Pascal-Programme, die x generieren. K(x) ist die k ¨urzestm ¨ogliche L¨ange einer Beschreibung von x. Die einfachste (und triviale) Beschreibung von x, ist wenn man x direkt angibt. x kann aber eine Struktur oder Regelm¨assigkeit haben, die eine Komprimierung erlaubt. 36 Kolmogorov-Komplexit¨at - Beispiel Beispiel Sei w = 0101010101010101010101010101010101010101. Die L¨ange von w ist |w| = 40 und die triviale Beschreibungl¨ange w¨are wie gegeben 40. Aber durch die Regelm¨assigkeit von einer 20-fachen Wiederholung der Sequenz 01, k ¨onnen w auch durch (01)20 beschreiben. Hierbei ist die Beschreibungsl¨ange ein wenig mehr als 4 Zeichen. 37 Grundlegende Resultate Es existiert eine Konstante d, so dass f ¨ur jedes x ∈ (Σbool)∗ K(x) ≤ |x| + d Die Kolmogorov-Komplexit¨at einer nat ¨urlichen Zahl n ist K(n) = K(Bin(n)). F ¨ur jede Zahl n ∈ N \\ {0} existiert ein Wort wn ∈ (Σbool)n, so dass K(wn) ≥ |wn| = n 38","libVersion":"0.3.2","langs":""}