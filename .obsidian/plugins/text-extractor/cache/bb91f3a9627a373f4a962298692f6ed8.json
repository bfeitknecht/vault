{"path":"sem2/DDCA/PV/cheatsheets/DDCA-cheatsheet-FS24-bs.pdf","text":"Verilog Discipline D Flip Flop Full-AdderDDCA by Simon module flop(input clu, wire [3 : 0] example ; Hierarchy : A system divided in to modules of smaller input [3: 0] d, assign sum = ab u c - in ; Complexity Binary Numbers output re g [3: 0] al; assign cout = (a &b) (a &cin) (b&cin) Modularity : Having well divined functions and always & (posedgeck) Counter 2 interfaces An N-bit binary number ranges from O to IN -1. begin alwaysaf begin Regularity : Encouraging uniformity , so modules can The rightmost bit is the least significant bit LSB. qEd ; count-next = count ; be easily re - u s e d Th e MSB is defined as the opposit . 1 byte = Sbits end count . next += 1 ; goal to reduce : Are a , Speed & Throughput , Power & Enery Little Endian : Kleinstes Byte zuerst synchronous , if it should be end problems suc h as : Power Consumptions , Heat , Clock Skew, Pipeline Haz. Big Endian : grösstes Byte zuerst asynchronous add rst to sensitivity always aposedge clk) 20 = 1 23 = S 26 = 64 29 = 512 230= 10731741824 list . count E count-next ; Sign/Magnitude : problem is : Addition doesn't wo r k . O ha s 2 = 2 24 = 16 27 = 128 210 = 102 4 = Kilo Non-Blocking : in parallel/ tw o representations : 100 4000 Giga -> ifdandq ar e multiple bits wide, end of block One's complement : range E(1) , 2-1]23 I 4 25 I 32 28 = 25 62 = 1048157 6 = Mega the code implements multiple flip-flops. Blocking : = immediately/ mus t in v er t all process wa it s Ad d itio n : negativ numbers Hex . Dez. Binary Hex . Dez . Binary Hex . Dez . Binary Hex . Dez. Binary Number Format : N'BXX : #Bits Base (e. g . b ,h) Numbera bits. Carry ou t added at the end. 00 0000 Y 4 0100 S g 1000 C 12 1100 Wir e Assignment : Two's complement : range [C217 , 20) 1 1 0001 5 0101 9 9 1001 D 13 1101 wire [15 : 0] a , b , 2 ; 11 sets a , ba ndc to busses negative number represented : 2 2 0010 6 6 0110 A 101010 E 14 1110 input a , b, 1 both a , b 1 bit inputs - reversing all bits - 3 3 0011 7 7 0 111 B 11 1011 F 15 1111 Correct Code : - ad d 1 = 1 GHz , pico = 10-1 na no = 10-3s · wires : can't be on the left of = / in an always block , ar e & used to connect input and output. sign-Extension : Sign bit is copied to MSB . Logic Gates · Legs : can't be connected to output port of a module , can't be used [ 0011 -, 00000011, 1011 - 111111011 AND G NAND G OR D NOR S in input port declaration, only on the left in always blocks. Zero-Extension : Ze ro is copied to MSB. A A A · O : check if na mes match and if all ports ar e assigned. 0011-100000011 , - not multiple assignments to the sa me signal 1011 - 200001011· i - i - na mes can't start with numbers :2 good -Sign/One, p com p G 10 G G 11 G 1 O - no module recursion Sign/One's Two's Two's 100 1 0 T 1 0 1 1 S O Mag com p com p Mag T 1 1 T 1 G T 1 1 T 1 g Combinational vs. Sequential : + 0 000 000, 000 - 0100 111 000 Comb: all left hand signals get assigned , all inputs ar e in sensitivity list, 1001 001 001 - 1 101110111 XNOR S XO R S all outputs ar e assigned 2on o 010 010 - 2110101 110 B 3011011 011 - 3111100 101 S - 4.- - 111 G 10 G 1 1= · T L . g . 4 integer bits , 3 fraction bits = 0 + 27 2+0 + 2 = 270 = 6 .75 1 0 0 1 S 1 ISA and Microarchitecture Fixed-Point Numbers 0110110 T 1 1 T 1 O - ~ (AVB) The ISA is the interface betweenTh e microarchitecture specifies - > For neg . num : -7 .5- 7 . 5 --in v e r t -1 + 1 - software and hardware ( , what the underlying implementation MoatingPoint Numbers #MXBF(Mantissa , Base , Exponent) Building Blocks the programmer sees\"). that actually executes the 1-bit Sign , 8-bit Exp , 23-bit Fra c tio n . Instruc tion Set Arch ite c t u re instructions . Transf: num- numz- 1 . (nume k) + 2 (Var .2- don't MUX : Decoder : (Var3 (Biasing) ad d a fixed number to exp) inc lude the 1) Special Cases Nums diff . to represent Num Sig Exp Fraction select on e input, n inputs , 2\" outputs , on e output is 1 0 X 00.. 000 ...0 log, (n) - bit control signal depending on they input pattern (01/011 ... 100 ... 0 Transistors NaN X 11 ....1 + 0 Combinational Sequential Logic MOS transistors work like a switch there ar e cMos pMos Pull-up Net . Comb: - no memory Seg: -h as memor y two types of MOS transistors . PMOS conducts , al * D D - no cyclic paths depends on prior inputs when G is LOW , MOS is the opposite. I Il * nMos - combines inputs to ex . Flip-Flops (register) => pull-down Net . get output Building Blocks : Conductors (Alu , Copper) , Insulators(Glass , Air) -n o wir e driver by 2 wires : Semiconductors (Silicon , Germanium ex . MUX O 1 A B A B Boolean Algebra Adders ↓ ↓ ↓ ↓ D-Latch Co HA CotFA t Li bistable circuit (0 or 1) Da Do Do Q Duality : Bool statement stays correct if 0 . 1 and t interchanged Half Ad d er : Full Adder : transparent mode : nputpropagat seit & BubblePushing : Do- Y 7 - y Adding multiple 1-bit numbers in : - linear structure CLR Definitions : Complement : Ä , B, c Min t er m : AND jair (A . B . I) An Br ↑ Bo-free structure latch mode : the output is stored ( = opaque mode) jaiv : including Literal : variables A , i Maxterm : ORia ir (E++c) Ripple Carry Adder : -F . to all input variables Implicant: AND (A . B . E) Curse of the carry : s so Risingedgeiggered D Flip-Flop CLK - Most sign . outp . of the ad d er depends on the least sign . exput. 2 back to back latches controlled by complementary CLK CL U O CL U Rules : X + X = X X + x = 1 X . (y + z) = (X . y) + (x - z)x . (x + y) = X Adding multiplembers with : A B · (LK = 0 = (1 transp., L20paque, D - > N1 D MX . x = X X . = 0 X . y +7 - z + yz = X y + E - z X . y + x . y = X ~ · CLU= 1 = (1 opaque , 12 transp , N1- Q De Morgan : (X + y + 2 + ... ) = E . Y . z ...., (X . Y . z . . .. ) = E + y + z + ... Array of Ripple Carry Adders : Dr En CLU Product of Sum : Sum of Product : - Fr A B A B D: : A + B 10 I A . B · Carry Save Princip le -maxterm 0 G G ~ minterm · Carry Propagate Adder S Q (latch ) G 1 * S X = (A+ B) . (A+B)01 % (x = (A.5) + (A . B) Reduce all to two with CSP then RC A : Q (FF) 1 1 : A + B 1 1 A . B Register : Multiple parallel FF tha t sto re mor e than 1 bit Shifters En ab le d FF EN CLU NAND Operations The ena ble in pu t (EN) controls DQ EN = 0 : rem ain state NOT : AA OR : AA . BB AND : AB . AB : shift and fill new with O when new da ta is stored. EN = 1 : new StateS [ : sa me as Resettable FF CL U Tarnaugh Maps : used to minimize boolean equations, they work (3) : shift and fill new with old MSB synchronous : re s e t at chedge - > d)well with up to 4 variables. Some rules : asynchronous : immediately · use fewest circles possible · only size 22m ROR ,ROL: rotate left I right Setta ble FF RESET · all must only contain 1s ALU A B Set = 1 = ) Q = 1 , set = 0 = no r ma l (implement with OR) ABC X Grey Code -N - N F2: 0 Func tion - 000 1 YA 3 000 A & B Finite State Machine 001 1 C 00 01 1110 A . C 8 . 001 Al B k-registers=> FSM is in on e of the finite 2 unique states. 0100 O 1 011 no t used I 7 1 & F2 010 A + B g 1 18 1001 11 cout I + 100 A & B Goes through different state , where each state depends on the prev. 1011 101 Al-B state and the input. 1101 => X = B + A . [ ze ro 3 [n - 1] 110 A - B Moore : Output depends only on current state 111 O extend 111 SLT Mealy : Output depends on the current state and the input State Encodings : · Binary Encoding (minimizes flip-flops), 00. 01 , 10 , 11 Delay : Propagation Delay tod : = max delay from ip . to op . -N · One-Hot (max. flip-flops, min . next state logic & Contamination Delay ted : = min-1- Y 0001 , 0010 , 0100 , 1000 min . output logic Designing a FSM glitch : When a single input change cau s e mult. · identify inputs outputs outputs changes · state transition diagram · write state transition & output table · write boolean equations for next state Area of FSM · # FF = # bits for state x2 · # logic gates = count next state and output logic Correctness of state diagram · reset-line · not multiple transitions : no unmarked transitions for the sa me input · initial state (if no reset) · no missing transitions · no mix of Moore/Measly labeling 2 FSM Example (Traffic Light Controler) Timing Verification Inputs : CLU , RESET , Ta Ti Setup time : time before the clock edge that Activate/sensitize : Set of inputs to trigger wrong outp . Outputs : La , Lis da ta mus t be stab le Propagate : Mak e sure faulty behavior re ach e s obsv . point . Hold time : time afte r the clock edge tha t Observe/compare: triggered fault output I expected output- State Transition Diagram Encoded State Transition Table da ta mus t be sta b le stimuli - stimuli - golden TA cureeputs Nester Aperture time : time arround clock edge tha t da ta er a t o r on mei Re s e t Ta Sta te Encoding mus t be sta b le ~ vo - La : Yellow Se So Ta Ti Sie So so 00 Clock skew : Shew is the difference between ES . Screens 51 000 x 0 1 St 01 tw o clock edges I HDL appli - model under - , acquirepra: red Li : re d O G X 0 O S2 10 V O ! I x 10 S3 11 cycles per sec o nd 1MHz = 10Hz & 1 GHz = 189Hz l ⑦ re s p. 1 x 0 1 1 La : re d & 1x % ↑Picosecond10nsen 1Gtz Verilog S3 10 X : Yellow 1 Nano = 10-9 ; pico = 10-12 initial - Statements starts on ce at the beginning , no re p e a t TB CLU CLk · statem ents ha v e to be blocking ( =)- I moduletestbench(); Calculations use K-maps , Pos .... Encoded Output Table I I Q1 4 D2 , I re g a , b , c , clki Current re g [3 : 0] testrectors [10000 : 03 ; S. = S. So state Outputs Output Encoding R1 R2 wir e y ; Sol = (5· Jo Fa) + (SiJoTB( Se So LanLazLB1Li2 green 00 = propagationdel fo m function UnderTest prod(a(a) .. b (b) , . < (c) , y(y7); Lan = Se 0 0 0 0 1 0 yellow 01 always Il no sens . lis t = always ex e c u t e s Lao = S: So 010110 red 10 T begin Lie = 5. 101000 tpd = propagation delay through G E clu = 1 ; #5 ; clu = 0 ; #5 ; LBO = SiSo 11 10 01 tid = contamination- end . d In it ial -- b = binary , re a d m e m h = Le x a Schematic CLK Setup Tim e Constraint & begin( Si I Se LA1 without skew : Tc < +pcqttpd + Isetup + +shew E 5) readmemb (\"example .tv\" , testvector) ; Hold Tim e Constraint · re s e t = 1 ; #27 ; reset = 0 ; end Th ⑧ Ot so s. 8 - LA0 without skew : Thold Isnew > tcq + ted = always& (posedge clu) Do-LB1 Synchronizer = begin 11 #1 important for hold time ⑯ To lower the probability of metastable outputs in . # 1 ; Sa , b , c , exp3 = testrector [rectornum] ; TB ⑧ - LBO Asynchronous inputs an d in general as low as poss. end Se So RS' MTBF : mean time between failures in itial begin / sequential blo c k E a = 0 ; b = 1 ; c = 0 ; #10 ; llapply inputs , wa it 10n s = if (y ! == 1) $display(1000 failed\") ; E end Find mistakes in FSM endmodule - Moore/Mealy labelling mixed -Tra n s itio n changes co v e r all different inputs . using testvector file -> good for automatization - Reset Signal -S tate labelling Equivalent module definitions : module (input a , output b) ; endmo dule module (a , b) ; in put a ; Output b ; endmodule 3 MIPS (million instructions per sec o nd Memorie Single Cycle Re a d - De cod e -> Find operands -- operation -- w rit e re su lt Each datate has a unique address Flip-Flops #fast , parallel acce s s , ↓4 Expensive = Program Cou n te r += 4 ; (1 wo rd = 32 bit = 4 bytes) Static RAM ↑ fast ,oh e word at a time , ↓less Expensive CPI : cycles per instruction R-Type : Register for all operands (04 = 0) Dynamic RA M ↓ slower , \" , reading des tr mem con t. . ↑ Cheaper Clock period : critical pa th- c lo c k speed f - lop (6) Ir s (5) /r + (5) /rd (5 ) /s h amt (511 funct (6) Hard disk/Flash It Slow , no n-vo la tile , ↑↑ Cheaper Clock frequency : 1/clock period (cycles/second & rs , rt : so ur c e reg ., rd : destination reg ., funct : function ac tiv e wordline given N instructions , program executesin : NxCPIx(1/f) /op ·Opera tio n cod e (0 for R-Type) , sha mt : shift amou n t Memory Arrays Address N content to bitline 1 Type :Instruc tions with an immediate constant value - 2Vrows , Mc ols -M Single cycle critical path : lop(6) /rs(5)/rt(5) / imm (16)/ - Array siz e = 2NxM Data · Tc = +pcq-PC + tmem max(trFread , tsext +mux) + tauttmem rs , rt : re g . oper ., imm : C's compl . imm ., op : opcode - horizontal lines : wo rd lin e + tmux + trfsetup J. Type : Jump Branch Instructions - ve rtic a l lin es : bitline lop(6)/addr (26) - Address dec oder activates on e wo rd lin e · but mostly : Tc = +pcq-PC + 2 . t mem triread + ta u tmux trfsetup Types of Memorie E . G : calculated Tc = 925ps , 100 billion ins tr Vo la tile Memory : power off loses da ta (SDRAM) 925 The caller calls a function, while the callee gets Non-volatile Memory : -- = keeps da ta 5 N = 100 .109 = 1011 called. CP95109 2 .5 seconds. Th e caller needs to take car e of the temporary registers Logic (LUT) $ to - $ + 9 , while the calle d needs to sa v e and restore the Tru th ta ble => output of wo rd b it Array preserved registers $ 50-$ 57 . Argument va lu e s ($90-$93), A 89 000 Pipelined MIPS re t u r n va lu e ($v0) B 0 11 X = AB Ad d pipelined registers between 5 main stages :- Assembly i O · 1 z = A + B Fetc h/D ec ode / Execute/Memory I Write b a c k- 1 1 ad d , sub,... mnemonic X yz y = Av B tazardsIn sw$53 , 1 ($0) # re ad write memory wo r d int o $53 Pipeline I - L 1) 25 6x 3 men module with 1 re a d /w rite po rt Data Hazard · re g va l . is not written back to reg . file , op is ut Timm tazard ·module dmem (input CIk Control next instr . is not decided yet yet lu i $51 , 0x 2 0 4 0 #loaden d ad d re ss input we ! fü enable (caused by branches ori $51 , 0x 0 0 0 0 0x 2 0 4 0 0000 input [7 : 0] a 8-b it ad d re ss SIt $+5, $+4 , $+3 # +5 = 1( +47 + 3 input [2 : 0] wa I /3-b itw rite da ta Handle Data Hazards : output (2 : 0] rd ) ; /3-b it re a d data - NOp (No Operation) : insert at compile time Stack reg[2: 0] RAM [255: 07 ; - Rearrange Code -- grows down assign rd = RA M[a ] ; - Forw ard data at runtime : read after wr it e (1cyle) - Stall the pro c esso r-- : addi Sp, Sp, always& (posedge Cu ) · Iw needs at least 2 cycles => forward not possSw jal proc2 if (we) RAM <= wd ; Address Segment · ew Stall = Deode and Fetc h reg , forced to hold val. Zw $rai O($sp) endmodule OX FFFFFFFC Reserved => Flushing ex e c u te st a t e addi Sp , $ p Mips Memory Map Stac k Handle Control Hazards : ↓ - Instructions : = Te x t beg : 4 stages flushed as branch misprediction penalty Data Dynam ic -Glob al/s tatic : allocated before Dat a Pipeline Performance Example - Dynam ic : allocated continuously ↑ · 25 % loads , 10 % Stores , 11 % bra nc hes , Size : at most 132 = 4GB Hea p 2 % jumps , 52 % R-type Stack : faster , light va ria b le s Static Data · Suppose . 40 % of le used by next in s tr. Heap : slow er , complex data structures Te x t · 25% bra nc h misprediction 6 x 00000000 Reserved · All jumps flush ne xt ins truc tionSingle Cycle vs . Mult . Cycle ↓ Sc : all instr . 1-cycle =- speed := slowest ins tr . d ↑ mc : instr . -s malle r pieces = ticycle time = Clock free CPIew = 1 . (0 . 6) + 2 . (04) = 1 . 4 - simpler instr . finish faster tha n complex ins tr . CPLbeq = 1 . (0 .75) + 2 . (0 . 25) = 1 . 25 ↓BUT:. mor e complex control , ↑ control ove rh e ad Average CPI · not necessarily faster, depends on (PIandclkfrea = 1025)(1 .4) + 0 .1 + 10 .11)( .25) + 10 .02)(2) + 0 . 52 = 1 . 15 ↓Sc : mult . inst . of men . - adders . Mc can sha re tho se > MC T shared re s o u rc e s = ↑ ove r h e a d for sequential processing load sto re bea jumps ! rtyp e 4 ISA (Instruction Set Ar.) vs. Microarchitecture Pipelining Verilog Modu les : The idea is to process multiple instructions at on ce by keeping - Instructions : opcodes , adressing each stage occupied. In reality there ar e a few problems : latch modes , data types, instruction - Pipelining Resource contention , can be fixed by duplication , increased throughput always & (* ) begin type and format , registers, - In-order vs. Out-of-Order ex e c . or detection and stalling if (e n ) 9 = d ; condition codes - Memory adress scheduling policy Long latency operations end - Memory : adress space , alignment, - Speculative execution Data dependencies , there ar e flow (read after write) , output adressability, virtual memory - Superscalar processing (write after write) and anti (write after read) dependencies. D - Type FF with ena ble management - Clock gating The last two exist due to a limited amount of registers. always & (posedge (4) begin 11 FF triggered by - Call , interrupt and exception - Caching : levels , size , associativity , Handling flow dependencies if (en) a = d ; Signal alle with an handling replacement policies · stall · eliminate at software level · predict values end ena ble input en - 0 : memory mapped us. instructions - Error correction · da ta forwarding do something else (fine-grained multithreading) sw itch - Power & Thermal management - Physical structure * W -> D : internal register file forwarding always go (* ) - Multiprocessing/Multithreading - Instruction latency M -> E : Operand forwarding begin support - Physical memory page siz e Pipeline Stages cas e (P ) - Access control , priority and privilege - Instruction issue width · Fetch : CPU reads instructions from instruction memory 2b 11 :... - Memory-mapped location of - reservation stage capacity · Decode :CPU reads so ur c e operands from register file and : exception vectors I - # pipeline stages - decodes instruction to control signals default :... - Function of each bit in a program - - latency of branch miss · Execute : CPU performs a computation with the ALU endc a se mable branch prediction register prediction · Memory : CPU reads/writes data memory end - Order of execution of loads and - fetch width of superscalar· Writeback : CPU writes result to register file stores in multi-core CPU CPU s - Program counter width -# non-programmable CPU Interlocking & Scoreboarding Risc and Cis c - Hardware FP-exception support registers Detection of data dependencies to ensur e correct execution. Reduced-/ Complex instruction set computers - Vector instruction support RISC : - CPU endianness Memory \"Simplicity favors regularity\" - Virtual page size -Consistent in s tru c tion format Build a single port SRAM 102 4\"32 . - same number of operands Performance Evaluation \"Make the com m on cas e fast \" · CP1 : cycles per instruction · MIPS : million instructions ↓ see = MHz CP) - inc ludes only simple , commonly used ins truc tions · 14C : instructions per cycle · Time = #instr .. CPI . Fe 512 x32 SRAM - Ha rdw a re to decode an d ex e c instr : simple , sma ll , fast 10 9 - Mor e complex instr . can be performed by multiple simple instr. · MHz : frequency , 10 ocycles/sec . Speedup = oldTime/newTime ADDR bit s = ADR28 :0 D po 32 \"Smaller is faster\" 32 32 · higher MHz # higher MIPS , IPS could be lower WEX S WE - MIPS includes only a small number of registers 32x32bit · higher MI PS less time , could need mor e instructions ak * CLK \"Good design demands good compromises\" Single-Cycle Machines 512 x32 SRAM - Mult . in str . formats also in Risc : ad d , Iw (3/2 reg . oper .) Each instruction takes a single clock cycle an d all state , D Do 3, Risc Cis c + easy to build Di fixed In s t r . length va ria b le In s t . length updates ar e made at the end of the cycle. & & WE - slowest instruction determines cycle time CLK Simplified Instructions Complex Instructions diverse Multi-Cycle Machines 1 bit , = ADDR (9] Load/store Arch ite c tu re Mem-to-Mem Operations Instruction processing is broken into multiple stages cycles, Adv . Disad . Adv . Disadv state updates happen during execution and architectural updates Synchronous RSt Asynchronous Rst Performance Code Desity CodeDensity Complexityat the end. Instruction processing consists of two components : · Datapath relay and transform da ta Power efficient Easy to Program Cost of design/ always @ (posedge clk) always &) Easier to optimize manufacture · Control logic FSM that determins control signals begin posedge all , slow In speed+ slowest stage determines cycle time if Creset) 91'b0 ; posedge reset( Dataflow else 9 =d ; begin In a dataflow machine , a programm consists of dataflow nodes. end if Creset) 91'b0 ; A node fires (executes) when all its inputs ar e ready. ↑ else 9 =d ; 11Both ar e D-Type FF- end 5 Jump MemtoReg Control MemWrite Unit Bra nc h ALUControl 2 : 0 - Pa src 31 : 26 Op ALUSC 5 : 0 Funct RegDst RegWrite CLK CLK CLR I O I 25 : 21 WES SrcA Zero WE 1 O PC PC A RD Instr A1 RD 1 E ALUR es u lt Read Data O Re su lt 1 A RB 1 In stru c tion Memory 20 :16 A2 RD2 ⑧ SrcB Data A3 Register 1 WriteData Memory WD3 WD File 20 : 16 PCJump 15 : 11 1 Write Reg 4 : 0 PC Plus4 4 15 : 0 Sign Extend SignImm 2 PCBranch j 27 : 0 31 :28 25 0, G","libVersion":"0.3.2","langs":""}