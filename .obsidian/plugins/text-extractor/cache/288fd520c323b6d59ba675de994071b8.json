{"path":"sem2/PProg/VRL/extra/kuhn/PProg-w02-kuhn.pdf","text":"Parallel Programming Session 2 Spring 2024 Schedule Prepara&on assignment 2 Coding Remarks Big theory recap (thread, process, context switch, parallelism, locks etc. etc.) Pre-Discussion assignment 2 Did I understand ? Exam Task Quiz Preparations Import assignment2.zip in Eclipse Run the projects unit-tests in Eclipse Understand output of unit-tests Did the test fail or succeed? Why did the test fail? Start coding and keep checking if tests pass Import ProjectAdd to Git Important: Select same directory as for assignment 1 If you don‚Äôt have a repo yet, contact me or come during the break -> Team -> Share Project Running Junit TestsQuick Coding Remarks Try to make your code as readable as possible Include high-level comments that explain why you are doing something (much beHer than a line-by-line commentary of your code) Keep aHenKon what Eclipse reports: If you need more info about funcKons, classes etc: hHps://docs.oracle.com/en/java/javase/17/docs/api/index.html Java Doc (h#ps://docs.oracle.com/en/java/javase/17/docs/api/index.html) Method Signature Seman>c descrip>on what the method does Parameter descrip>on Possible occurring errors Theory Recap Terminology Overview: h1ps://cgl.ethz.ch/teaching/parallelprog23/pages/terminology.html Be familiar with these deÔ¨ÅniBons Process CollecBons of bits on the disk Process CollecBons of bits on the disk Start program: OS makes it to a process Process CollecBons of bits on the disk Start program: OS makes it to a process OS sees mulBple processes with a context now we can excute it on CPU Process CollecBons of bits on the disk Start program: OS makes it to a process OS sees mulBple processes with a context now we can excute it on CPU Threads Thread Definition divide process further into threads Each process has min. 1 thread: main thread Thread Definition divide process further into threads Each process has min. 1 thread: main thread Share same context -> address space, variables: same memory why do we need that ? Thread Definition divide process further into threads Each process has min. 1 thread (example: garbage collector in Java) Share same context -> address space, variables: same memory why do we need that ? lightweight, have less context: inherit from process Thread Definition divide process further into threads Each process has min. 1 thread (example: garbage collector in Java) Share same context -> address space, variables: same memory why do we need that ? lightweight, have less context: inherit from process OS sees process & system level threads but not the Java threads (get mapped to OS threads) Where ? Threads are a reappearing structure Hardware (CPU) Opera8ng Systems Programming Languages Java Thread Class Virtual/green threads Where ? Threads are a reappearing structure Hardware (CPU) Opera8ng Systems Programming Languages Java Thread Class Virtual/green threads daemon vs non-daemon Thread Properties (in our course) Threads can create other threads Threads (from same class) execute same program but with diÔ¨Äerent arguments CommunicaBon between threads: wriBng to Ô¨Åelds of shared objects How can we do that such that only one thread at a Bme writes to it ? Thread Properties (in our course) Threads can create other threads Threads (from same class) execute same program but with diÔ¨Äerent arguments CommunicaBon between threads: wriBng to Ô¨Åelds of shared objects How can we do that such that only one thread at a Bme writes to it ? SYNCHRONIZATION Thread vs. Process Each process has a own context (values on the stack/heap, instrucBon counter etc.) Thread vs. Process Each process has a own context (values on the stack/heap, instrucBon counter etc.) Each running unit of a program is a process (example: mulBple tabs in a browser) Thread vs. Process Each process has a own context (values on the stack/heap, instrucBon counter etc.) Each running unit of a program is a process (example: mulBple tabs in a browser) Subdivisions of a OS process are threads -> share resources of the process Threads are like ‚Äúworkers‚Äù which execute statements of the program Thread vs. ProcessThread vs. Process single core, 3 threads, context switching Thread vs. Process single core, 3 threads, context switching How many cores ? How many threads ? Scheduling/Context Switch Decision which process is running Decision which thread inside a process is running Scheduling/Context Switch Decision which process is running Decision which thread inside a process is running Scheduler black box: divides Bme and gives it to diÔ¨Äerent processes& threads. Scheduling/Context Switch Decision which process is running Decision which thread inside a process is running Scheduler black box: divides Bme and gives it to diÔ¨Äerent processes& threads. ! Can interrupt at any Bme and switch at any Bme ! üò≠ Scheduling/Context Switch Decision which process is running Decision which thread inside a process is running Scheduler black box: divides Bme and gives it to diÔ¨Äerent processes& threads. ! Can interrupt at any Bme and switch at any Bme ! context switch: de-schedule thread for another thread generally: Thread content switch is lighter than process switch (only CPU registers) üò≠ Scheduling/Context Switch Decision which process is running Decision which thread inside a process is running Scheduler black box: divides Bme and gives it to diÔ¨Äerent processes& threads. ! Can interrupt at any Bme and switch at any Bme ! context switch: de-schedule thread for another thread üò≠ State Model:Thread t=Thread.currentThread();Parallelism vs ConcurrencyParallelism vs Concurrency in parallel: threads are scheduled at the same 1me on diÔ¨Äerent cores concurrent: life1me of threads overlap Parallelism vs Concurrency in parallel: threads are scheduled at the same 1me on diÔ¨Äerent cores concurrent: life1me of threads overlap Threads can run concurrently eventhough they are never scheduled at the same 1me Parallelism vs Concurrency in parallel: threads are scheduled at the same 1me on diÔ¨Äerent cores concurrent: life1me of threads overlap Threads can run concurrently eventhough they are never scheduled at the same 1me Example: 3 threads on a single-core CPU, constantly context switch run concurrently but are never schedulded at the same &me ( never parallel) Parallelism vs Concurrency 3 runnable threads: Q: Schedule one thread -> run un:l it dies ‚Äì> next thread -> run un:l it dies -> third thread -> run un:l dead Is this parallelism and/ or concurrency ? Parallelism vs Concurrency Q: Schedule one thread -> run un:l it dies ‚Äì> next thread -> run un:l it dies -> third thread -> run un:l dead Is this parallelism and/ or concurrency ? Yes ,ist s:ll concurrency because their life:me overlap. Only because a thread is not running, it doesn‚Äòt mean it is dead. While thread 1 was running, thread 2 and thread 3 were runnable. Parallelism vs Concurrency Concurrency: dealing with mul4ple things (threads) at the same 4me that (Don‚Äòt have to be schedulded at the same 4me.) Parallelism: actually doing mul4ple things at the same 4me Busy waiting Busy wai8ng: threads keeps checking a condi8on ‚Äì> using CPU-8me for useless work Join() Join(): pauses the thread un8l all the threads running on it are terminated. (Calls to join need to be in try-catch block because of possible excep8on.) -> see this later today. Join() Join(): pauses/deschedules the thread un8l all the threads running on it are terminated. Code with join example -> inline() code exmaple via eclispe Join() order is important. We could accidentally create a sequen8al program. Slows down code. Join() When could join() be worse (less eÔ¨Écient) than busy wai8ng ? Interrupted() Way to interrupt a thread t.interrupt() t.interrupt() doesn‚Äòt return anything -> t.isInterrupted() (true/false) Interrupted() Way to interrupt a thread t.interrupt() t.interrupt() doesnt return anything -> t.isInterrupted() (true/false) reason why we need try-catch around t.join () interrupted while wai8ng for join yields excep8on Interrupted() Remember from this: interrupt thread Will throw InterruptedExcepBon If in method: sleep(), join(), wait() Interrupted() Remember from this: interrupt thread Will throw InterruptedException interrupt Ô¨Çag will be set Check t.isInterrupted() If in method: sleep(), join(), wait() Why synchronize Interleavings: possible execu8on order Bad interleaving: faulty execu8on order, yields wrong result ->BAD Why synchronize Interleavings: possible execu8on order Bad interleaving: faulty execu8on order, yields wrong result Race condi8on: execu8on of program depends on real-8me execu8on order -> scheduler! When bad interleavings are possible. Why synchronize Interleavings: possible execu8on order Bad interleaving: faulty execu8on order, yields wrong result Race condi8on: execu8on of program depends on real-8me execu8on order -> scheduler! When bad interleavings are possible Cri8cal sec8on: Code that only one thread at a 8me should execute bad interleavings?bad interleavings?That‚Äôs why we need locksLocks Write the equivalent version of NEXT WEEK Monitor/intrinsic Lock What is the beneÔ¨Åt of this version ? NEXT WEEK Monitor/intrinsic Lock What if we have a sta:c method ? Methods we call without an object. NEXT WEEK Monitor/intrinsic Lock What if we have a sta:c method ? Methods we call without an object. Synchronize on the myClass.Object NEXT WEEK Let‚Äôs test NEXT WEEK Pre-Discussion Ex.2 Task A To start with, print to the console \"Hello Thread!\" from a new thread. How do you check that the statement was indeed printed from a thread that is diÔ¨Äerent to the main thread of your applica>on? Furthermore, ensure that your program (i.e., the execu>on of main thread) Ô¨Ånishes only aMer the thread execu>on Ô¨Ånishes. Task A op)on 1: Extend class Thread Run() vs. Start() Both execute run method method of Runnable object √† use thread.start() Run executes in current thread Start creates new thread and executes in new thread context Task A op)on 2: Implement Runnable DemoTask BTask B Run the method computePrimeFactors on a single thread other than the main thread. Measure the execu>on >me of sequen>al execu>on (on the main thread) and execu>on using a single thread. Is there any no>ceable diÔ¨Äerence? Task C op)on 1: Measures real >me elapsed including >me when the thread is not running. op)on 2: Measures thread cpu >me excluding >me when the thread is not running. Task C Measured execuBon Bme not always the same Average over mulBple runs (the more the be1er) Calculate variance Task D Before you parallelize the loop in Task E, design how the work should be split between the threads by implemen>ng method Par>>onData. Each thread should process roughly equal amount of elements. BrieÔ¨Çy describe your solu>on and discuss alterna>ve ways to split the work. Task D: Split the work between the threads Par%%onData(20,3) Par$$onData(int length, int numPar$$ons) { ‚Ä¶ } Input length (20) Par%%onData(20,1) Par%%onData(20,2) ? Task D: Split the work between the threads Par$$onData(int length, int numPar$$ons) { ‚Ä¶ } Input length (20) a) Par>>onData(20,1) b) Par>>onData(20,2) c) Par>>onData(20,3) d) Par>>onData(20,3) both c) and d) are correct solu0ons for this exercise Task D Several ways with diÔ¨Äerent performance depending on task and data If input is random: Spliang the input into half works well If input is sorted: Ô¨Årst half Ô¨Ånishes faster than 2nd half √† maybe split on odd/even indices Task D What about (length>0 and numPar::ons>0) and length<numPar::ons? ‚Ä¢ ?? ‚Ä¢ ?? And (length<=0 or numPar::ons<=0)? ‚Ä¢ ?? ‚Ä¢ ?? Par$$onData(int length, int numPar$$ons) { ‚Ä¶ } Task E Parallelize the loop execu>on in computePrimeFactors using a conÔ¨Ågurable number of threads. Task F Think of how you would create a plot that shows the execuBon speed-up of your implementa>on, for n = 1, 2, 4, 8, 16, 32, 64, 128 threads and the input array size of 100, 1000, 10000, 100000 look like. Task G Measure the execu>on >me of your parallel implementa>on for n = 1, 2, 4, 8, 16, 32, 64, 128 threads and the input array size of input.length = 100, 1000, 10000, 100000. Discuss the diÔ¨Äerences in the two plots from task F and G. Speed Up Sub-linear: usually (parallelizaBon overhead, workload imbalance etc.) Super-linear: not possible in theory, but Modern hardware properBes (local/remote memory) Bug (this course assumes this) Did I really understand? Process vs. thread Context switch & scheduler State model of the threads ( new, runnable, running, blocked, terminated ) Parallelism vs concurrency Busy waiBng & join() Interrupted () (bad) interleaving, race condiBon criBcal secBon monitor/intrinsic lock Past Exam Taskfinally h]ps://quizizz.com/admin/quiz/621cc87fe4751b001dec9ad0?source=quiz_share Task A) Task B) Task C) Task D) Task E) Task F) (plot) Task G) Tasks ‚≠ê (‚ò†) ‚ùó‚≠ê ‚ùó‚≠ê ‚ùó‚≠ê ‚≠ê‚≠ê ‚ùó‚≠ê‚≠ê Creating Threads in Java‚≠ê ‚≠ê‚≠ê See you next week J","libVersion":"0.3.2","langs":""}