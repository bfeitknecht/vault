{"path":"sem3/AuD/UE/s/AuD-u02-s.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 2 October 2023 Johannes Lengler, David Steurer Lucas Slot, Manuel Wiedmer, Hongjie Chen, Ding Jingqiu Algorithms & Data Structures Exercise sheet 2 HS 23 The solutions for this sheet are submitted at the beginning of the exercise class on 9 October 2023. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. Exercise 2.1 Induction. (a) Prove via mathematical induction that for all integers n ≥ 5, 2n > n 2 . Solution: • Base Case. Let n = 5. Then: 2 5 = 32 > 25 = 5 2 . • Induction Hypothesis. Assume that the property holds for some positive integer k ≥ 5, that is, 2k > k2 . • Inductive Step. We must show that the property holds for k + 1. 2 k+1 = 2 · 2k I.H. > 2 · k2 = k2 + k2 ≥ k2 + 5k = k2 + 2k + 3k ≥ k2 + 2k + 15 > k2 + 2k + 1 = (k + 1)2 . By the principle of mathematical induction, 2n > n2 is true for every positive integer n ≥ 5. (b) Let x be a real number. Prove via mathematical induction that for every positive integer n, we have (1 + x) n = n∑ i=0 ( n i )x i , where (n i ) = n! i!(n − i)! . We use a standard convention 0! = 1, so (n 0) = (n n ) = 1 for every positive integer n. Hint: Y ou can use the following fact without justification: for every 1 ≤ i ≤ n, (n i ) + ( n i − 1 ) = (n + 1 i ) . Solution: We will use the identity from the hint to show (via mathematical induction) that (1 + x) n = n∑ i=0 ( n i ) xi . • Base Case. Let n = 1. Then (1 + x)1 = (1 0)x0 + (1 1 )x1 = ∑n i=0 (n i )xi. • Induction Hypothesis. Assume that the property holds for some positive integer k, that is, (1 + x) k = k∑ i=0 ( k i ) xi. • Inductive Step. We must show that the property holds for k + 1. (1 + x) k+1 = (1 + x)(1 + x) k I.H. = (1 + x) k∑ i=0 ( k i ) xi = ( k∑ i=0 ( k i ) xi) + ( k∑ i=0 ( k i ) xi+1) = ( k∑ i=0 ( k i ) xi) + ( k+1∑ i=1 ( k i − 1 )xi) = ( k 0 ) x0 + k∑ i=1 (( k i ) xi + ( k i − 1 ) xi) + ( k k ) xk+1 = ( k + 1 0 ) x0 + k∑ i=1 (k + 1 i ) xi + ( k + 1 k + 1 ) xk+1 = k+1∑ i=0 (k + 1 i )x i. By the principle of mathematical induction, the property is true for every positive integer n. Asymptotic Notation When we estimate the number of elementary operations executed by algorithms, it is often useful to ignore constant factors and instead use the following kind of asymptotic notation, also called O- Notation. We denote by R+ the set of all (strictly) positive real numbers and by N the set of all (strictly) positive integers. Let N be a set of possible inputs. 2 Definition 1 (O-Notation). For f : N → R+, O(f ) := {g : N → R+ | ∃C > 0 ∀n ∈ N g(n) ≤ C · f (n)}. We write f ≤ O(g) to denote f ∈ O(g). Some textbooks use here the notation f = O(g). We believe the notation f ≤ O(g) helps to avoid some common pitfalls in the context of asymptotic notation. Instead of working with this definition directly, it is often easier to use limits in the way provided by the following theorem. Theorem 1 (Theorem 1.1 from the script). Let N be an infinite subset of N and f : N → R+ and g : N → R+. • If lim n→∞ f (n) g(n) = 0, then f ≤ O(g) and g ̸≤ O(f ). • If lim n→∞ f (n) g(n) = C ∈ R+, then f ≤ O(g) and g ≤ O(f ). • If lim n→∞ f (n) g(n) = ∞, then f ̸≤ O(g) and g ≤ O(f ). The following theorem can also be helpful when working with O-notation. Theorem 2. Let f, g, h : N → R+. If f ≤ O(h) and g ≤ O(h), then 1. For every constant c > 0, c · f ≤ O(h). 2. f + g ≤ O(h). Notice that for all real numbers a, b > 1, loga n = loga b · logb n (where loga b is a positive constant). Hence loga n ≤ O(logb n). So you don’t have to write bases of logarithms in asymptotic notation, that is, you can just write O(log n). Exercise 2.2 O-notation quiz. (a) For all the following functions the variable n ranges over N. Prove or disprove the following state- ments. Justify your answer. (1) 2n5 + 10n2 ≤ O( 1 100 n6) Solution: True by Theorem 1, since lim n→∞ 2n5 + 10n2 1 100 n6 = lim n→∞ 200 1 n + 1000 1 n4 = 0. (2) n10 + 2n2 + 7 ≤ O(100n9) Solution: False by Theorem 1, since lim n→∞ n10 + 2n2 + 7 100n9 = lim n→∞ 1 100 n + 1 50 1 n7 + 7 100 1 n9 = ∞. 3 (3) e1.2n ≤ O(en) Solution: False by Theorem 1, since lim n→∞ e1.2n en = lim n→∞ e1.2n−n = lim n→∞ e0.2n = ∞. (4)* n 2n+3 n+1 ≤ O(n2) Solution: True by Theorem 1, since lim n→∞ n 2n+3 n+1 n2 = lim n→∞ n 2n+3 n+1 −2 = lim n→∞ n 2n+3−2n−2 n+1 = lim n→∞ n 1 n+1 = lim n→∞ e log n n+1 = 1. (b) Find f and g as in Theorem 1 such that f ≤ O(g), but the limit limn→∞ f (n) g(n) does not exist. This proves that the first point of Theorem 1 provides a sufficient, but not a necessary condition for f ≤ O(g). Solution: We define the following two functions f, g : N → R+. Let f (n) = 2 + (−1)n and g(n) = 1. We have f (n) g(n) = 2+(−1)n 1 = 2 + (−1)n, which has no limit when n → ∞. However, for any n ∈ N, f (n) ≤ 3g(n) and thus f ≤ O(g). Exercise 2.3 Asymptotic growth of ∑n i=1 1 i (1 point). The goal of this exercise is to show that the sum ∑n i=1 1 i behaves, up to constant factors, as log(n) when n is large. Formally, we will show ∑n i=1 1 i ≤ O(log n) and log n ≤ O( ∑n i=1 1 i ) as functions from N≥2 to R+. For parts (a) to (c) we assume that n = 2k is a power of 2 for k ∈ N0 = N ∪ {0}. We will generalise the result to arbitrary n ∈ N in part (d). For j ∈ N, define Sj = 2j ∑ i=2j−1+1 1 i . (a) For any j ∈ N, prove that Sj ≤ 1. Hint: Find a common upper bound for all terms in the sum and count the number of terms. Solution: For any i between 2j−1 + 1 and 2j, we have 1 i ≤ 1 2j−1 . In the sum Sj = ∑2j i=2j−1+1 1 i there are 2j − (2j−1 + 1) + 1 = 2j − 2j−1 = 2j−1 terms. Thus, we get Sj = 2j ∑ i=2j−1+1 1 i ≤ 2 j−1 · 1 2j−1 = 1. 4 (b) For any j ∈ N, prove that Sj ≥ 1 2 . Solution: For any i between 2j−1 + 1 and 2j, we have 1 i ≥ 1 2j . In the sum Sj = ∑2j i=2j−1+1 1 i there are again 2j−1 terms. Thus, we get Sj = 2j ∑ i=2j−1+1 1 i ≥ 2j−1 · 1 2j = 1 2 . (c) For any k ∈ N0, prove the following two inequalities 2k ∑ i=1 1 i ≤ k + 1 and 2k ∑ i=1 1 i ≥ k + 1 2 . Hint: You can use that ∑2k i=1 1 i = 1 + ∑k j=1 Sj. Use this, together with parts (a) and (b), to prove the required inequalities. Solution: By parts (a) and (b), we have that 1 2 ≤ Sj ≤ 1 for any j ∈ N. Thus, we get, using the hint, 2k ∑ i=1 1 i = 1 + k∑ j=1 Sj ≤ 1 + k∑ j=1 1 = k + 1. Similarly, we have 2k ∑ i=1 1 i = 1 + k∑ j=1 Sj ≥ 1 + k∑ j=1 1 2 ≥ 1 2 + k 2 = k + 1 2 . (d)* For arbitrary n ∈ N, prove that n∑ i=1 1 i ≤ log2(n) + 2 and n∑ i=1 1 i ≥ log2 n 2 . Hint: Use the result from part (c) for k1 = ⌈log2 n⌉ and k2 = ⌊log2 n⌋. Here, for any x ∈ R, ⌈x⌉ is the smallest integer that is at least x and ⌊x⌋ is the largest integer that is at most x. For example, ⌈1.5⌉ = 2, ⌊1.5⌋ = 1 and ⌈3⌉ = ⌊3⌋ = 3. In particular, for any x ∈ R, x ≤ ⌈x⌉ < x + 1 and x ≥ ⌊x⌋ > x − 1. Solution: 5 We want to apply part (c) to k1 = ⌈log2 n⌉. Note that n ≤ 2k1. Now, using that for any i ∈ N, 1 i ≥ 0, we get n∑ i=1 1 i ≤ 2k1∑ i=1 1 i ≤ k1 + 1 = ⌈log2 n⌉ + 1 ≤ log2(n) + 2. Applying part (c) to k2 = ⌊log2 n⌋ (note that n ≥ 2k2) and again using that 1 i ≥ 0 for any i ∈ N, we get n∑ i=1 1 i ≥ 2k2∑ i=1 1 i ≥ k2 + 1 2 = ⌊log2 n⌋ + 1 2 ≥ (log2(n) − 1) + 1 2 = log2(n) 2 . Exercise 2.4 Asymptotic growth of ln(n!). Recall that the factorial of a positive integer n is defined as n! = 1 × 2 × · · · × (n − 1) × n. For the following functions n ranges over N≥2. (a) Show that ln(n!) ≤ O(n ln n). Hint: You can use the fact that n! ≤ nn for n ∈ N≥2 without proof. Solution: From the hint, we have n! ≤ nn, which implies using the monotonicity of the logarithm that ln(n!) ≤ n ln n and thus ln(n!) ≤ O(n ln n). (b) Show that n ln n ≤ O(ln(n!)). Hint: You can use the fact that ( n 2 ) n 2 ≤ n! for n ∈ N≥2 without proof. Solution: From the hint, we have n! ≥ ( n 2 )n/2. Now, by the monotonicity of the logarithm we have ln(n!) ≥ ln (( n 2 )n/2) = n 2 (ln n − ln 2) , so n ln n ≤ 2 ln(n!) + n ln 2. Now, note that n ln 2 ≤ ln 2 + ∑n i=2 ln(i) = ln 2 + ln(n!) ≤ 2 ln(n!) since n ≥ 2. Thus, n ln n ≤ 2 ln(n!) + n ln 2 ≤ 4 ln(n!), which shows n ln n ≤ O(ln(n!)). Exercise 2.5 Testing equations (2 points). Your friend sends you a piece of code that computes his favorite function f : N → N. For n ∈ N, we want to test if the equation f (a) + f (b) + f (c) = f (d) can be satisfied using positive integers 1 ≤ a, b, c, d ≤ n. Your friend completed Algorithms and Data Structures last year, and so you may assume that his code computes f (k) in O(1) for any k ∈ N. You may also assume simple arithmetic operations on integers can be performed in O(1). Finally, you may initialize an array of size k in time O(k). (a) Design a simple O(n4) algorithm that outputs “YES” if there exist integers 1 ≤ a, b, c, d ≤ n such that f (a) + f (b) + f (c) = f (d) and “NO” otherwise. Solution: 6 The algorithm can simply check all n4 tuples (a, b, c, d) of positive integers by using four nested loops with indices (a, b, c, d) that iterate over all integers in [1, n]. For each such tuple, we check whether f (a) + f (b) + f (c) = f (d) in time O(1) and report success (“YES”) if we ever find a satisfying tuple. Otherwise, we return failure (“NO”). The algorithm checks all n4 possibilities, hence it is trivially correct and its runtime is clearly O(n4). (b) Assume that f (k) ≤ k3 for all k ∈ N. Modify your previous algorithm so that it works in time O(n3) under this assumption. Motivate briefly why it still works. Hint: You could use a helper array of size n3 to get rid of one of the loops in your previous algorithm. The helper array could save which values the function f can take. Solution: We create a helper array H[1, . . . , n3] of size n3, whose entries are initially all zero. Using a single loop, we set H[f (d)] = 1 for all 1 ≤ d ≤ n. Then we loop over the tuples (a, b, c) with 1 ≤ a, b, c ≤ n. For each such tuple, we compute α = f (a)+f (b)+f (c) in time O(1) and report success (“YES”) if we ever find a tuple with H[α] = 1. Otherwise, we return failure (“NO”). The runtime of the algorithm is O(n3): we need O(n3) to initialize the array, O(n) to set the correct entries to 1, and O(n3) to loop over the integers 1 ≤ a, b, c ≤ n. For correctness, note that 1 ≤ f (d) ≤ n3 for all 1 ≤ d ≤ n, and so we do not run into ‘out of bounds’ errors. (c)* Assume that f (k) ≤ k2 for all k ∈ N. Modify your previous algorithm so that it works in time O(n2) under this assumption. Motivate briefly why it still works. Hint: You could use a helper array again. Note that f (a) + f (b) + f (c) = f (d) implies that f (a) + f (b) = f (d) − f (c). Solution: The approach is similar to before, but now we create an array H[1, . . . , 2n2] of size 2n2 whose entries are initially all zero. Then, using a double loop we set H[f (a) + f (b)] = 1 for all tuples (a, b) with 1 ≤ a, b ≤ n. Then we loop over the tuples (c, d) with 1 ≤ c, d ≤ n. For each such tuple, we compute α = f (d) − f (c) in time O(1) and report success (“YES”) if we ever find a tuple with α ≥ 1 and H[α] = 1. Otherwise, we return failure (“NO”). The runtime of the algorithm is O(n2): We need O(n2) to initialize the array, O(n2) to set the correct entries to 1, and O(n2) to loop over the integers 1 ≤ c, d ≤ n. For correctness, note that 1 ≤ f (a) + f (b) ≤ 2n2 for all 1 ≤ a, b ≤ n, and so we do not run into ‘out of bounds’ errors. 7","libVersion":"0.3.2","langs":""}