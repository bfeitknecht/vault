{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s07-conclusion.pdf","text":"Conclusion David Basin Department of Computer Science ETH Z¨urich Functional Programming David Basin 1 Programming paradigms • Haskell is a so-called pure functional programming language \u0011 It is “pure” in that functions have by default no side effects \u0011 Features list comprehension, higher-order functions, strong type system, algebraic data types, lazy evaluation, . . . • Other FP languages: LISP, Scheme, SML, Ocaml, F#, Scala, . . . \u0011 None of their type systems guarantees side-effect freeness • Other programming paradigms imperative: e.g., Pascal, C, and FORTRAN object-oriented: e.g., Smalltalk, Java, and C++ logic: e.g., Prolog • From computer scientists one can expect some “multi-linguality” Functional Programming Spring Semester, 2025 David Basin 2 Programming languages: why study another one? • All general-purpose programming languages are equivalent Formally: they are Turing complete and can express the same class of (partial, recursive) functions • Although the same functions can be computed, algorithms are formalized differently Formalization as a RAM is different from formalization in Java, which is different from formalization in Haskell . . . • Approaches have their pros and cons We summarize some of the important differences Functional Programming Spring Semester, 2025 David Basin 3 Values versus states (I) • A functional program describes values sumSquares :: Int -> Int sumSquares 0 = 0 -- Direct description sumSquares n = n*n + sumSquares (n-1) -- Described by equations constituting the function definition. Functional Programming Spring Semester, 2025 David Basin 4 Values versus states (II) • An imperative program describes how memory is updated. s = 0; i = 0; while (i < n) { i = i+1; s = i*i + s; } \u0011 Consists of commands that update the content of memory. \u0011 Memory models primitive data. \u0011 No analogy to data-driven solutions where computation driven by need to generate data rather than explicitly by programmer. sumSquares’ n = sum (map (^2) [1 .. n]) Functional Programming Spring Semester, 2025 David Basin 5 Functions and variables • Functional programs \u0011 Function returns value depending only on input sumSquares n = n ∗ n + sumSquares (n − 1) sumSquares 6 = 6 ∗ 6 + sumSquares (6 − 1) \u0011 Analogous to functions in mathematics f (x, y) = 2 · x − y f (6, 3) = 2 · 6 − 3 • This referential transparency fails for imperative programs • Critical difference: variables in functional programs do not vary! Functional Programming Spring Semester, 2025 David Basin 6 Program verification (functional) • Functional programs describe their properties sumSquares 0 = 0 or for n > 0, sumSquares n = n ∗ n + sumSquares(n − 1) • Proofs through equational reasoning or by induction sumSquares 1 = 1 ∗ 1 + sumSquares (1 − 1) = 1 + 0 = 1 Functional Programming Spring Semester, 2025 David Basin 7 Program verification (imperative) • Imperative programs lack referential transparency class test { static int y=0; static int f(int x) { y = y+1; return(y); }; public static void main (String args[]){ System.out.println(f(0)); System.out.println(f(0)); } } • Verification with respect to program points using pre-/postconditions describing sets of states • It is (relatively) difficult to verify non-trivial programs Functional Programming Spring Semester, 2025 David Basin 8 Compositionality • Functional programs \u0011 Functions serve both as building blocks and as glue \u0011 Referential transparency enables compositional reasoning • Imperative programs \u0011 Control-structures such as if-then-else are glue that construct commands from commands if b then c1 else c2 while b do c \u0011 Glue is fixed! \u0011 Less compositional reasoning due to lack of referential transparency Functional Programming Spring Semester, 2025 David Basin 9 Types and abstraction • Functional programs \u0011 Strong type system ⇒ fewer errors at runtime \u0011 Polymorphism and type classes (Haskell/ghc) \u0011 Abstraction over data and control • Imperative programs \u0011 Typically a weaker type system ⇒ more runtime errors \u0011 Abstraction over data through object orientation and generics \u0011 Cumbersome abstraction over control Functional Programming Spring Semester, 2025 David Basin 10 Efficiency • Functional programs \u0011 Programs are high-level and far from machine architecture, but referential transparency enables further optimizations. \u0011 Lazy evaluation more difficult to implement • Imperative programs \u0011 Complexity is easier to assess and control \u0011 Closer to hardware level \u0011 Direct influence on representation of data in memory • Haskell programs can often be optimized to ≤ 2 ∗ speed of C • Other factors are often more important than efficiency, e.g., developer productivity, correctness, safety (no buffer overflows), libraries, . . . Functional Programming Spring Semester, 2025 David Basin 11 Haskell Outlook Functional Programming Spring Semester, 2025 David Basin 12 Haskell usage • Haskell has a thriving and exceptionally friendly user community Website: www.haskell.org Maling List: haskell-cafe@haskell.org Blogs: planet.haskell.org IRC: #haskell on freenode.net Reddit: www.reddit.com/r/haskell/ Libraries: hackage.haskell.org • Commercial users of functional programming \u0011 Website: wiki.haskell.org/Haskell in industry \u0011 Credit Suisse: Modeling and analysis of financial products \u0011 Galois: High-assurance applications (e.g., for the US DoD) \u0011 Bluespec: Hardware design languages and automation Functional Programming Spring Semester, 2025 David Basin 13 Haskell research • Functional programming is an active research topic Conferences: ICFP, Haskell Symposium, IFL, POPL Abstraction: embedded languages, generic programming Concurrency: Data Parallel Haskell, STM Efficiency: compilation techniques, data structures Correctness: type and proof systems, testing ⇒ Haskell is likely to become even better in the future Functional Programming Spring Semester, 2025 David Basin 14 Research highlight: the L4.verified project • A truly trustworthy, high-performance operating system kernel with a machine-checked proof of its functional correctness w.r.t. a high level, formal description of its expected behavior. • Website: trustworthy.systems/projects/TS/l4.verified/ Functional Programming Spring Semester, 2025 David Basin 15 Mechanized theorem proving • Complex formal proofs are constructed using proof assistants • In our research group, we use the Isabelle/HOL proof assistant • We have lab courses on this from time to time. Chance for an exciting student project, bachelor/master thesis. Functional Programming Spring Semester, 2025 David Basin 16 End of part I • Starting next class: part II on Formal Methods Peter M¨uller takes over. • If you are interested in a student project, bachelors thesis, or masters thesis using functional programming or logic, please contact one of the organizers of this course or visit www.infsec.ethz.ch/education/studentProjects.html Functional Programming Spring Semester, 2025","libVersion":"0.5.0","langs":""}