{"path":"sem2/DDCA/VRL/extra/slides/DDCA-L16-microarchitecture.pdf","text":"Carnegie Mellon 1 Digital Design and Computer Architecture Mohammad Sadrosadati Frank K. Gürkaynak Adapted from Digital Design and Computer Architecture, David Money Harris & Sarah L. Harris ©2007 Elsevier http://safari.ethz.ch/ddca Microarchitecture Carnegie Mellon 2 In This Lecture ¢ Overview of the MIPS Microprocessor ¢ RTL Design Revisited ¢ Single-Cycle Processor ¢ Performance Analysis Carnegie Mellon 3 Introduction ¢ Microarchitecture: § How to implement an architecture in hardware ¢ Processor: § Datapath: functional blocks § Control: control signals Physics Devices Analog Circuits Digital Circuits Logic Micro- architecture Architecture Operating Systems Application Software electrons transistors diodes amplifiers filters AND gates NOT gates adders memories datapaths controllers instructions registers device drivers programs Carnegie Mellon 4 Microarchitecture ¢ Multiple implementations for a single architecture: ¢ Single-cycle (this week) § Each instruction executes in a single cycle ¢ Multicycle (in the book, we will not cover it) § Each instruction is broken up into a series of shorter steps § One instruction is executed piece-wise § Allows re-use of components (ALU, memory) ¢ Pipelined (just after we finish this one) § Each instruction is broken up into a series of steps § Multiple instructions execute at once § Better for performance Carnegie Mellon 5 What does our Microprocessor do ? ¢ Program is in memory, stored as a series of instructions. ¢ Basic execution is: § Read one instruction § Decode what it wants § Find the operands either from registers or from memory § Perform the operation as dictated by the instruction § Write the result (if necessary) § Go to the next instruction Carnegie Mellon 6 What are the Basic Components of MIPS? ¢ The main pieces § Memory to store program § Registers to access data fast § Data memory to store more data § An ALU to perform the core function Carnegie Mellon 7 What are the Basic Components of MIPS? ¢ The main pieces § Memory to store program § Registers to access data fast § Data memory to store more data § An ALU to perform the core function ¢ Some auxiliary pieces § A program counter to tell where to find next instruction § Some logic to decode instructions § A way to manipulate the program counter for branches Carnegie Mellon 8 What are the Basic Components of MIPS? ¢ The main pieces § Memory to store program § Registers to access data fast § Data memory to store more data § An ALU to perform the core function ¢ Some auxiliary pieces § A program counter to tell where to find next instruction § Some logic to decode instructions § A way to manipulate the program counter for branches ¢ Today we will see how it all comes together Carnegie Mellon 9 RTL Design Revisited ¢ Registers store the current state ¢ Combinational logic determines next state § Data moves from one register to another (datapath) § Control signals move data through the datapath § Control signals depend on state and input ¢ Clock moves us from state to another Carnegie Mellon 10 Let us Start with Building the Processor ¢ Program is stored in a (read-only) memory as 32- bit binary values. ¢ Memory addresses are also 32-bit wide, allowing (in theory) 232 = 4 Gigabytes of addressed memory. ¢ The actual address is stored in a register called PC. addi $t0, $s3, -12 Machine CodeAssembly Code lw $t2, 32($0) add $s0, $s1, $s2 sub $t0, $t3, $t5 0x8C0A0020 0x02328020 0x2268FFF4 0x016D4022 Address Instructions 0040000C 0 1 6 D 4 0 2 2 2 2 6 8 F F F 4 0 2 3 2 8 0 2 0 8 C 0 A 0 0 2 0 00400008 00400004 00400000 Stored Program Main Memory PC Carnegie Mellon 11 What to do with the Program Counter? reg [31:0] PC_p, PC_n; // Present and next state of PC // […] assign PC_n <= PC_p + 4; // Increment by 4; always @ (posedge clk, negedge rst) begin if (rst == ‘0’) PC_p <= 32’h00400000; // default else PC_p <= PC_n; // when clk end ¢ The PC needs to be incremented by 4 during each cycle (for the time being). ¢ Initial PC value (after reset) is 0x00400000 Carnegie Mellon 12 We have an Instruction Now What ? ¢ There are different types of instructions § R type (three registers) § I type (the one with immediate values) § J type (for changing the flow) ¢ First only a subset of MIPS instructions: § R type instructions: and, or, add, sub, slt § Memory instructions: lw, sw § Branch instructions: beq ¢ Later we will add addi and j Carnegie Mellon 13 R-Type MIPS instructions ¢ Register-type: 3 register operands: § rs, rt: source registers § rd: destination register ¢ Other fields: § op: the operation code or opcode (0 for R-type instructions) § funct: the function together, the opcode and function tell the computer what operation to perform § shamt: the shift amount for shift instructions, otherwise it’s 0 op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits R-Type Carnegie Mellon 14 R-Type Examples add $s0, $s1, $s2 sub $t0, $t3, $t5 Assembly Code 0 17 18 16 0 32 Field Values 0 11 13 8 0 34 op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits 000000 10001 10010 10000 00000 100000 op rs rt rd shamt funct 000000 01011 01101 01000 00000 100010 Machine Code 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits (0x02328020) (0x016D4022) Note the order of registers in the assembly code: add rd, rs, rt Carnegie Mellon 15 We Need a Register File ¢ Store 32 registers, each 32-bit § 25 == 32, we need 5 bits to address each ¢ Every R-type instruction uses 3 register § Two for reading (RS, RT) § One for writing (RD) ¢ We need a special memory with: § 2 read ports (address x2, data out x2) § 1 write port (address, data in) Carnegie Mellon 16 Register File input [4:0] a_rs, a_rt, a_rd; input [31:0] di_rd; input we_rd; output [31:0] do_rs, do_rt; reg [31:0] R_arr [31:0]; // Array that stores regs // Circuit description assign do_rs = R_arr[a_rs]; // Read RS assign do_rt = R_arr[a_rt]; // Read RT always @ (posedge clk) if (we_rd) R_arr[a_rd] <= di_rd; // write RD Carnegie Mellon 17 Register File input [4:0] a_rs, a_rt, a_rd; input [31:0] di_rd; input we_rd; output [31:0] do_rs, do_rt; reg [31:0] R_arr [31:0]; // Array that stores regs // Circuit description; add the trick with $0 assign do_rs = (a_rs != 5’b00000)? // is address 0? R_arr[a_rs] : 0; // Read RS or 0 assign do_rt = (a_rt != 5’b00000)? // is address 0? R_arr[a_rt] : 0; // Read RT or 0 always @ (posedge clk) if (we_rd) R_arr[a_rd] <= di_rd; // write RD Carnegie Mellon 18 ALU Does the Real Work in a Processor ALU N N N 3 A B Y F F2:0 Function 000 A & B 001 A | B 010 A + B 011 not used 100 A & ~B 101 A | ~B 110 A - B 111 SLT Carnegie Mellon 19 Review: ALU +201 A B Cout Y301F2 F1:0 [N-1] S NN N N N NNN N 2ZeroExtend F2:0 Function 000 A & B 001 A | B 010 A + B 011 not used 100 A & ~B 101 A | ~B 110 A - B 111 SLT Carnegie Mellon 20 So far so good ¢ We have most of the components for MIPS § We still do not have data memory Carnegie Mellon 21 So far so good ¢ We have most of the components for MIPS § We still do not have data memory ¢ We can implement all R-type instructions § Assuming our ALU can handle all of the functions § At the moment we do not have the shifter § We know what to do for more functions. Carnegie Mellon 22 So far so good ¢ We have most of the components for MIPS § We still do not have data memory ¢ We can implement all R-type instructions § Assuming our ALU can handle all of the functions § At the moment we do not have the shifter § We know what to do for more functions. ¢ …but not much else § No memory access § No immediate values § No conditional branches, no absolute jumps Carnegie Mellon 23 Data Memory input [15:0] addr; // Only 16 bits in this example input [31:0] di; input we; output [31:0] do; reg [65535:0] M_arr [31:0]; // Array for Memory // Circuit description assign do = M_arr[addr]; // Read memory always @ (posedge clk) if (we) M_arr[addr] <= di; // write memory ¢ Will be used to store the bulk of data Carnegie Mellon 24 Let us Read (then Write) to Memory ¢ The main memory can have up to 232 bytes § It needs an 32-bit address for the entire memory. § In practice much smaller memories are used ¢ We need the lw instruction to read from memory § I-type instruction § We need to calculate the address from an immediate value and a register. § Maybe we can use the ALU to add immediate to the register? Carnegie Mellon 25 I-Type ¢ Immediate-type: 3 operands: § rs, rt: register operands § imm: 16-bit two’s complement immediate ¢ Other fields: § op: the opcode § Simplicity favors regularity: all instructions have opcode § Operation is completely determined by the opcode op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type Carnegie Mellon 26 Differences between R-type and I-type ¢ Changes to Register file § RS + sign extended immediate is the address § RS is always read. § For some instructions RT is read as well § If one register is written it is RT, not RD § The write_data_in can come from Memory or ALU § Not all I-type instructions write to register file ¢ Changes to ALU § Used to calculate memory address, add function needed during non R-type operations § Result is also used as address for the data memory § One input is no longer RT, but the immediate value Carnegie Mellon 27 Now Writing to Memory is Similar ¢ We need the sw instruction to write to memory § I-type instruction § Address calculated the same way § Unlike, previous step, there is no writing back to register. § But we need to enable the write enable of the memory Carnegie Mellon 28 Our MIPS Datapath has Several Options ¢ ALU inputs § Either RT or Immediate ¢ Write Address of Register File § Either RD or RT ¢ Write Data In of Register File § Either ALU out or Data Memory Out ¢ Write enable of Register File § Not always a register write ¢ Write enable of Memory § Only when writing to memory (sw) Carnegie Mellon 29 Our MIPS Datapath has Several Options ¢ ALU inputs § Either RT or Immediate (MUX) ¢ Write Address of Register File § Either RD or RT (MUX) ¢ Write Data In of Register File § Either ALU out or Data Memory Out (MUX) ¢ Write enable of Register File § Not always a register write (MUX) ¢ Write enable of Memory § Only when writing to memory (sw) (MUX) All these options are our control signals Carnegie Mellon 30 Let us Develop our Control Table Instruction Op5:0 RegWrite RegDst AluSrc MemWrite MemtoReg ALUOp § RegWrite: Write enable for the register file § RegDst: Write to register RD or RT § AluSrc: ALU input RT or immediate § MemWrite: Write Enable § MemtoReg: Register data in from Memory or ALU § ALUOp: What operation does ALU do Carnegie Mellon 31 Let us Develop our Control Table Instruction Op5:0 RegWrite RegDst AluSrc MemWrite MemtoReg ALUOp R-type 000000 1 1 0 0 0 funct § RegWrite: Write enable for the register file § RegDst: Write to register RD or RT § AluSrc: ALU input RT or immediate § MemWrite: Write Enable § MemtoReg: Register data in from Memory or ALU § ALUOp: What operation does ALU do Carnegie Mellon 32 Let us Develop our Control Table Instruction Op5:0 RegWrite RegDst AluSrc MemWrite MemtoReg ALUOp R-type 000000 1 1 0 0 0 funct lw 100011 1 0 1 0 1 add § RegWrite: Write enable for the register file § RegDst: Write to register RD or RT § AluSrc: ALU input RT or immediate § MemWrite: Write Enable § MemtoReg: Register data in from Memory or ALU § ALUOp: What operation does ALU do Carnegie Mellon 33 Let us Develop our Control Table Instruction Op5:0 RegWrite RegDst AluSrc MemWrite MemtoReg ALUOp R-type 000000 1 1 0 0 0 funct lw 100011 1 0 1 0 1 add sw 101011 0 X 1 1 X add § RegWrite: Write enable for the register file § RegDst: Write to register RD or RT § AluSrc: ALU input RT or immediate § MemWrite: Write Enable § MemtoReg: Register data in from Memory or ALU § ALUOp: What operation does ALU do Carnegie Mellon 34 Now we are much better ¢ We have almost all components for MIPS ¢ We already had (nearly) all R-type instructions § Our ALU can implement some functions § We know what to do for more functions. ¢ Now we can also Read and Write to memory ¢ Conditional Branches are still missing § Until know, PC just increases by 4 every time. § We need to somehow be able to influence this. Carnegie Mellon 35 Branch if equal: BEQ ¢ From Appendix B: Opcode: 000100 If ([rs]==[rt]) PC= BTA BTA = Branch Target Address = PC+4 +(SignImm <<2) Carnegie Mellon 36 Branch if equal: BEQ ¢ From Appendix B: Opcode: 000100 If ([rs]==[rt]) PC= BTA BTA = Branch Target Address = PC+4 +(SignImm <<2) ¢ We need ALU for comparison § Subtract RS – RT § We need a ‘zero’ flag, if RS equals RT Carnegie Mellon 37 Branch if equal: BEQ ¢ From Appendix B: Opcode: 000100 If ([rs]==[rt]) PC= BTA BTA = Branch Target Address = PC+4 +(SignImm <<2) ¢ We need ALU for comparison § Subtract RS – RT § We need a ‘zero’ flag, if RS equals RT ¢ We also need a Second Adder § The immediate value has to be added to PC+4 Carnegie Mellon 38 Branch if equal: BEQ ¢ From Appendix B: Opcode: 000100 If ([rs]==[rt]) PC= BTA BTA = Branch Target Address = PC+4 +(SignImm <<2) ¢ We need ALU for comparison § Subtract RS – RT § We need a ‘zero’ flag, if RS equals RT ¢ We also need a Second Adder § The immediate value has to be added to PC+4 ¢ PC has now two options § Either PC+4 or the new BTA Carnegie Mellon 39 More Control Signals Instruction Op5:0 RegWrite RegDst AluSrc Branch MemWrite MemtoReg ALUOp R-type 000000 1 1 0 0 0 0 funct lw 100011 1 0 1 0 0 1 add sw 101011 0 X 1 0 1 X add beq 000100 0 X 0 1 0 X sub ¢ New Control Signal § Branch: Are we jumping or not ? Carnegie Mellon 40 We are almost done ¢ We have almost all components for MIPS ¢ We already had (nearly) all R-type instructions § Our ALU can implement some functions § We know what to do for more functions. ¢ Now we can also Read and Write to memory ¢ We also have conditional branches ¢ Absolute jumps are still missing § J-type instructions § The next PC address is directly determined Carnegie Mellon 41 Machine Language: J-Type ¢ Jump-type § 26-bit address operand (addr) § Used for jump instructions (j) op addr 6 bits 26 bits J-Type 0000 0000 0100 0000 0000 0000 1010 0000JTA 26-bit addr (0x0100028) (0x004000A0) 0000 0000 0100 0000 0000 0000 1010 0000 0 1 0 0 0 2 8 000011 00 0001 0000 0000 0000 0010 1000 op addr Machine CodeField Values 3 0x0100028 6 bits 26 bits (0x0C100028) op imm 6 bits 26 bits Carnegie Mellon 42 Jump: J ¢ From Appendix B: Opcode: 000010 PC= JTA JTA = Jump Target Address = {(PC+4)[31:28], addr,2’b0} ¢ No need for ALU § Assemble the JTA from PC and 26-bit immediate ¢ No need for memory, register file ¢ One more option (mux + control signal) for PC Carnegie Mellon 43 Even More Control Signals Instruction Op5:0 RegWrite RegDst AluSrc Branch MemWrite MemtoReg ALUOp Jump R-type 000000 1 1 0 0 0 0 funct 0 lw 100011 1 0 1 0 0 1 add 0 sw 101011 0 X 1 0 1 X add 0 beq 000100 0 X 0 1 0 X sub 0 j 000010 0 X X X 0 X X 1 ¢ New Control Signal § Jump: Direct jump yes or no Carnegie Mellon 44 Now we are Almost Done ¢ We have all major parts § We can implement, R, I, J type instructions § We can calculate, branch, and jump § We would be able to run most programs Carnegie Mellon 45 Now we are Almost Done ¢ We have all major parts § We can implement, R, I, J type instructions § We can calculate, branch, and jump § We would be able to run most programs ¢ Still we can improve: § ALU can be improved for more ‘funct’ § We do not have a shifter. § Or a multiplier. § More I-type functions (only lw and sw supported) § More J-type functions (jal, jr) Carnegie Mellon 46 Now the original slides once again ¢ The following slides will repeat what we just did ¢ Consistent with the text book Carnegie Mellon 47 MIPS State Elements CLK A RD Instruction Memory A1 A3 WD3 RD2 RD1 WE3 A2 CLK Register File A RD Data Memory WD WEPCPC' CLK 32 32 32 32 32 32 32 32 32 32 5 5 5 § Program counter: 32-bit register § Instruction memory: Takes input 32-bit address A and reads the 32-bit data (i.e., instruction) from that address to the read data output RD. § Register file: The 32-element, 32-bit register file has 2 read ports and 1 write port § Data memory: Has a single read/write port. If the write enable, WE, is 1, it writes data WD into address A on the rising edge of the clock. If the write enable is 0, it reads address A onto RD. Carnegie Mellon 48 Single-Cycle Datapath: lw fetch ¢ STEP 1: Fetch instruction CLK A RD Instruction Memory A1 A3 WD3 RD2 RD1 WE3 A2 CLK Register File A RD Data Memory WD WEPC PC' Instr CLK lw $s3, 1($0) # read memory word 1 into $s3 op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type Carnegie Mellon 49 Single-Cycle Datapath: lw register read ¢ STEP 2: Read source operands from register file Instr CLK A RD Instruction Memory A1 A3 WD3 RD2 RD1 WE3 A2 CLK Register File A RD Data Memory WD WE PCPC' 25:21 CLK lw $s3, 1($0) # read memory word 1 into $s3 op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type Carnegie Mellon 50 Single-Cycle Datapath: lw immediate ¢ STEP 3: Sign-extend the immediate SignImm CLK A RD Instruction Memory A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File A RD Data Memory WD WE PCPC' Instr 25:21 15:0 CLK lw $s3, 1($0) # read memory word 1 into $s3 op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type Carnegie Mellon 51 Single-Cycle Datapath: lw address ¢ STEP 4: Compute the memory address SignImm CLK A RD Instruction Memory A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File A RD Data Memory WD WE PCPC' Instr 25:21 15:0 SrcB ALUResult SrcA Zero CLK ALUControl2:0ALU 010 lw $s3, 1($0) # read memory word 1 into $s3 op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type Carnegie Mellon 52 Single-Cycle Datapath: lw memory read ¢ STEP 5: Read from memory and write back to register file A1 A3 WD3 RD2 RD1 WE3 A2 SignImm CLK A RD Instruction Memory CLK Sign Extend Register File A RD Data Memory WD WE PCPC' Instr 25:21 15:0 SrcB20:16 ALUResult ReadData SrcA RegWrite Zero CLK ALUControl2:0ALU 0101 lw $s3, 1($0) # read memory word 1 into $s3 op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type Carnegie Mellon 53 Single-Cycle Datapath: lw PC increment ¢ STEP 6: Determine address of next instruction SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File A RD Data Memory WD WE PCPC' Instr 25:21 15:0 SrcB 20:16 ALUResult ReadData SrcA PCPlus4 Result RegWrite Zero CLK ALUControl2:0ALU 0101 lw $s3, 1($0) # read memory word 1 into $s3 op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type Carnegie Mellon 54 Single-Cycle Datapath: sw ¢ Write data in rt to memory SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File A RD Data Memory WD WE PCPC' Instr 25:21 20:16 15:0 SrcB 20:16 ALUResult ReadData WriteData SrcA PCPlus4 Result MemWriteRegWrite Zero CLK ALUControl2:0ALU 10100 sw $t7, 44($0) # write t7 into memory address 44 op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type Carnegie Mellon 55 Single-Cycle Datapath: R-type Instructions ¢ Read from rs and rt, write ALUResult to register file SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File 0 1 0 1 A RD Data Memory WD WE 0 1 PCPC' Instr 25:21 20:16 15:0 SrcB 20:16 15:11 ALUResult ReadData WriteData SrcA PCPlus4 WriteReg4:0 Result RegDst MemWrite MemtoRegALUSrcRegWrite Zero CLK ALUControl2:0ALU 0 varies1 001 add t, b, c # t = b + c op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits R-Type Carnegie Mellon 56 Single-Cycle Datapath: beq ¢ Determine whether values in rs and rt are equal Calculate BTA = (sign-extended immediate << 2) + (PC+4) SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File 0 1 0 1 A RD Data Memory WD WE 0 1 PC0 1 PC' Instr 25:21 20:16 15:0 SrcB 20:16 15:11 <<2+ ALUResult ReadData WriteData SrcA PCPlus4 PCBranch WriteReg4:0 Result RegDst Branch MemWrite MemtoRegALUSrcRegWrite Zero PCSrc CLK ALUControl2:0ALU 0 1100 x0x 1 beq $s0, $s1, target # branch is taken Carnegie Mellon 57 Complete Single-Cycle Processor SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File 0 1 0 1 A RD Data Memory WD WE 0 1 PC0 1 PC' Instr 25:21 20:16 15:0 5:0 SrcB 20:16 15:11 <<2+ ALUResult ReadData WriteData SrcA PCPlus4 PCBranch WriteReg4:0 Result 31:26 RegDst Branch MemWrite MemtoReg ALUSrc RegWrite Op Funct Control Unit Zero PCSrc CLK ALUControl2:0ALU Carnegie Mellon 58 Control Unit RegDst Branch MemWrite MemtoReg ALUSrc Opcode5:0 Control Unit ALUControl2:0Funct5:0 Main Decoder ALUOp1:0 ALU Decoder RegWrite Carnegie Mellon 59 ALU Does the Real Work in a Processor ALU N N N 3 A B Y F F2:0 Function 000 A & B 001 A | B 010 A + B 011 not used 100 A & ~B 101 A | ~B 110 A - B 111 SLT Carnegie Mellon 60 Review: ALU +201 A B Cout Y301F2 F1:0 [N-1] S NN N N N NNN N 2ZeroExtend F2:0 Function 000 A & B 001 A | B 010 A + B 011 not used 100 A & ~B 101 A | ~B 110 A - B 111 SLT Carnegie Mellon 61 Control Unit: ALU Decoder ALUOp1:0 Meaning 00 Add 01 Subtract 10 Look at Funct 11 Not Used ALUOp1:0 Funct ALUControl2:0 00 X 010 (Add) X1 X 110 (Subtract) 1X 100000 (add) 010 (Add) 1X 100010 (sub) 110 (Subtract) 1X 100100 (and) 000 (And) 1X 100101 (or) 001 (Or) 1X 101010 (slt) 111 (SLT) RegDst Branch MemWrite MemtoReg ALUSrc Opcode5:0 Control Unit ALUControl2:0Funct5:0 Main Decoder ALUOp1:0 ALU Decoder RegWrite Carnegie Mellon 62 Control Unit: Main Decoder Instruction Op5:0 RegWrite RegDst AluSrc Branch MemWrite MemtoReg ALUOp1:0 R-type 000000 1 1 0 0 0 0 10 lw 100011 1 0 1 0 0 1 00 sw 101011 0 X 1 0 1 X 00 beq 000100 0 X 0 1 0 X 01 SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File 0 1 0 1 A RD Data Memory WD WE 0 1 PC0 1 PC' Instr 25:21 20:16 15:0 5:0 SrcB 20:16 15:11 <<2+ ALUResult ReadData WriteData SrcA PCPlus4 PCBranch WriteReg4:0 Result 31:26 RegDst Branch MemWrite MemtoReg ALUSrc RegWrite Op Funct Control Unit Zero PCSrc CLK ALUControl2:0ALU Carnegie Mellon 63 Single-Cycle Datapath Example: or SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File 0 1 0 1 A RD Data Memory WD WE 0 1 PC0 1 PC' Instr 25:21 20:16 15:0 5:0 SrcB 20:16 15:11 <<2+ ALUResult ReadData WriteData SrcA PCPlus4 PCBranch WriteReg4:0 Result 31:26 RegDst Branch MemWrite MemtoReg ALUSrc RegWrite Op Funct Control Unit Zero PCSrc CLK ALUControl2:0ALU 001 0 0 1 0 0 1 0 Carnegie Mellon 64 Extended Functionality: addi SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File 0 1 0 1 A RD Data Memory WD WE 0 1 PC0 1 PC' Instr 25:21 20:16 15:0 5:0 SrcB 20:16 15:11 <<2+ ALUResult ReadData WriteData SrcA PCPlus4 PCBranch WriteReg4:0 Result 31:26 RegDst Branch MemWrite MemtoReg ALUSrc RegWrite Op Funct Control Unit Zero PCSrc CLK ALUControl2:0ALU ¢ No change to datapath Carnegie Mellon 65 Control Unit: addi Instruction Op5:0 RegWrite RegDst AluSrc Branch MemWrite MemtoReg ALUOp1:0 R-type 000000 1 1 0 0 0 0 10 lw 100011 1 0 1 0 0 1 00 sw 101011 0 X 1 0 1 X 00 beq 000100 0 X 0 1 0 X 01 addi 001000 1 0 1 0 0 0 00 Carnegie Mellon 66 Extended Functionality: j SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File 0 1 0 1 A RD Data Memory WD WE 0 1 PC 0 1 PC' Instr 25:21 20:16 15:0 5:0 SrcB 20:16 15:11 <<2+ ALUResult ReadData WriteData SrcA PCPlus4 PCBranch WriteReg4:0 Result 31:26 RegDst Branch MemWrite MemtoReg ALUSrc RegWrite Op Funct Control Unit Zero PCSrc CLK ALUControl2:0ALU0 1 25:0 <<2 27:0 31:28 PCJump Jump Carnegie Mellon 67 Control Unit: Main Decoder Instruction Op5:0 RegWrite RegDst AluSrc Branch MemWrite MemtoReg ALUOp1:0 Jump R-type 000000 1 1 0 0 0 0 10 0 lw 100011 1 0 1 0 0 1 00 0 sw 101011 0 X 1 0 1 X 00 0 beq 000100 0 X 0 1 0 X 01 0 j 000100 0 X X X 0 X XX 1 Carnegie Mellon 68 Processor Performance ¢ How fast is my program? § Every program consists of a series of instructions § Each instruction needs to be executed. Carnegie Mellon 69 Processor Performance ¢ How fast is my program? § Every program consists of a series of instructions § Each instruction needs to be executed. ¢ So how fast are my instructions ? § Instructions are realized on the hardware § They can take one or more clock cycles to complete § Cycles per Instruction = CPI Carnegie Mellon 70 Processor Performance ¢ How fast is my program? § Every program consists of a series of instructions § Each instruction needs to be executed. ¢ So how fast are my instructions ? § Instructions are realized on the hardware § They can take one or more clock cycles to complete § Cycles per Instruction = CPI ¢ How much time is one clock cycle? § The critical path determines how much time one cycle requires = clock period. § 1/clock period = clock frequency = how many cycles can be done each second. Carnegie Mellon 71 Processor Performance ¢ Now as a general formula § Our program consists of executing N instructions. § Our processor needs CPI cycles for each instruction. § The maximum clock speed of the processor is f, and the clock period is therefore T=1/f Carnegie Mellon 72 Processor Performance ¢ Now as a general formula § Our program consists of executing N instructions. § Our processor needs CPI cycles for each instruction. § The maximum clock speed of the processor is f, and the clock period is therefore T=1/f ¢ Our program will execute in N x CPI x (1/f) = N x CPI x T seconds Carnegie Mellon 73 How can I Make the Program Run Faster? N x CPI x (1/f) Carnegie Mellon 74 How can I Make the Program Run Faster? N x CPI x (1/f) ¢ Reduce the number of instructions § Make instructions that ‘do’ more (CISC) § Use better compilers Carnegie Mellon 75 How can I Make the Program Run Faster? N x CPI x (1/f) ¢ Reduce the number of instructions § Make instructions that ‘do’ more (CISC) § Use better compilers ¢ Use less cycles to perform the instruction § Simpler instructions (RISC) § Use multiple units/ALUs/cores in parallel Carnegie Mellon 76 How can I Make the Program Run Faster? N x CPI x (1/f) ¢ Reduce the number of instructions § Make instructions that ‘do’ more (CISC) § Use better compilers ¢ Use less cycles to perform the instruction § Simpler instructions (RISC) § Use multiple units/ALUs/cores in parallel ¢ Increase the clock frequency § Find a ‘newer’ technology to manufacture § Redesign time critical components § Adopt pipelining Carnegie Mellon 77 Single-Cycle Performance ¢ TC is limited by the critical path (lw) SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File 0 1 0 1 A RD Data Memory WD WE 0 1 PC0 1 PC' Instr 25:21 20:16 15:0 5:0 SrcB 20:16 15:11 <<2+ ALUResult ReadData WriteData SrcA PCPlus4 PCBranch WriteReg4:0 Result 31:26 RegDst Branch MemWrite MemtoReg ALUSrc RegWrite Op Funct Control Unit Zero PCSrc CLK ALUControl2:0ALU1 010 0 1 0 1 0 0 Carnegie Mellon 78 Single-Cycle Performance ¢ Single-cycle critical path: § Tc = tpcq_PC + tmem + max(tRFread, tsext + tmux) + tALU + tmem + tmux + tRFsetup ¢ In most implementations, limiting paths are: § memory, ALU, register file. § Tc = tpcq_PC + 2tmem + tRFread + tmux + tALU + tRFsetup SignImm CLK A RD Instruction Memory+ 4 A1 A3 WD3 RD2 RD1 WE3 A2 CLK Sign Extend Register File 0 1 0 1 A RD Data Memory WD WE 0 1 PC0 1 PC' Instr 25:21 20:16 15:0 5:0 SrcB 20:16 15:11 <<2+ ALUResult ReadData WriteData SrcA PCPlus4 PCBranch WriteReg4:0 Result 31:26 RegDst Branch MemWrite MemtoReg ALUSrc RegWrite Op Funct Control Unit Zero PCSrc CLK ALUControl2:0ALU1 010 0 1 0 1 0 0 Carnegie Mellon 79 Single-Cycle Performance Example Element Parameter Delay (ps) Register clock-to-Q tpcq_PC 30 Register setup tsetup 20 Multiplexer tmux 25 ALU tALU 200 Memory read tmem 250 Register file read tRFread 150 Register file setup tRFsetup 20 Tc = Carnegie Mellon 80 Single-Cycle Performance Example Element Parameter Delay (ps) Register clock-to-Q tpcq_PC 30 Register setup tsetup 20 Multiplexer tmux 25 ALU tALU 200 Memory read tmem 250 Register file read tRFread 150 Register file setup tRFsetup 20 Tc = tpcq_PC + 2tmem + tRFread + tmux + tALU + tRFsetup = [30 + 2(250) + 150 + 25 + 200 + 20] ps = 925 ps Carnegie Mellon 81 Single-Cycle Performance Example ¢ Example: For a program with 100 billion instructions executing on a single-cycle MIPS processor: Carnegie Mellon 82 Single-Cycle Performance Example ¢ Example: For a program with 100 billion instructions executing on a single-cycle MIPS processor: Execution Time = # instructions x CPI x TC = (100 × 109)(1)(925 × 10-12 s) = 92.5 seconds Carnegie Mellon 83 What Did We Learn? ¢ How to determine the performance of processors § CPI § Clock speed § Number of instructions ¢ Single-cycle MIPS architecture § Learned individual components § ALU § Data Memory § Instruction Memory § Register File § Discussed implementation of some instructions § Explained the control flow","libVersion":"0.3.2","langs":""}