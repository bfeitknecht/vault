{"path":"sem4/FMFP/PV/exams/finals/FMFP-FS17.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Exam August 14, 2017, 9:00 – 12:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud. No.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 34 pages; the back page of this booklet is page 34. After the exam begins, check that your exam papers are complete (4 assignments for the FP part, 4 assignments and 2 pages of background material for the FM part). 2. You may complete the assignments in any order. We recommend spending roughly half of your time on each of the two parts of the exam. 3. Only write on the exam paper and extra paper sheets which are given by the assis- tants. Do not take any of this paper out of the exam: submit it all. Write your ﬁrst and last name and your student number on every sheet of paper that you write on. 4. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 5. For the FP part of the exam, you may use any functions from the Haskell Prelude in your solutions (without giving their deﬁnitions), unless speciﬁed otherwise. 6. Write clearly in the sense of logic, language, and readability. Label all rule applica- tions in your derivation trees. The clarity of your arguments and explanations aﬀects your grade. 7. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 8 ∑ Max. points 11 8 10 11 5 15 10 10 80 Your points Formal Methods and Functional Programming, Exam, SS17 2 Part I: Functional Programming Formal Methods and Functional Programming, Exam, SS17 4 Assignment 1: Typing (11 points) (a) Recall the following functions from the Haskell libraries. (4 points) (+) :: Num a => a -> a -> a map :: (a -> b) -> [a] -> [b] fst :: (a, b) -> a snd :: (a, b) -> b Determine whether the following expressions are well-typed or not. If so, then state the most general type; otherwise justify informally why the expression is not typable. 1. \\x y -> y x x 2. \\x y -> y x y 3. \\x -> fst x (snd x) 4. map (\\x -> x + x) [] Formal Methods and Functional Programming, Exam, SS17 5 Assignment 1 continues on the next page. Formal Methods and Functional Programming, Exam, SS17 6 (b) Formally infer the most general type of the following expression using (7 points) the Mini-Haskell typing rules. Label every proof step with the rule used. Ø (λy. λx. y (x (y, 0))) (λx. iszero x) ∶∶ . . . Recall the proof rules for the Mini-Haskell type system: Var . . . , x ∶ τ, . . . Ø x ∶∶ τ Γ, x ∶ σ Ø t ∶∶ τ Abs Γ Ø λx. t ∶∶ σ → τ Γ Ø t1 ∶∶ σ → τ Γ Ø t2 ∶∶ σ App Γ Ø t1 t2 ∶∶ τ Int Γ Ø n ∶∶ Int True Γ Ø T rue ∶∶ Bool False Γ Ø F alse ∶∶ Bool Γ Ø t ∶∶ Int iszero Γ Ø iszero t ∶∶ Bool Γ Ø t1 ∶∶ Int Γ Ø t2 ∶∶ Int BinOp Γ Ø (t1 op t2) ∶∶ Int for op ∈ {+, ∗} Γ Ø t0 ∶∶ Bool Γ Ø t1 ∶∶ τ Γ Ø t2 ∶∶ τ if Γ Ø if t0 then t1 else t2 ∶∶ τ Γ Ø t1 ∶∶ τ1 Γ Ø t2 ∶∶ τ2 Tuple Γ Ø (t1, t2) ∶∶ (τ1, τ2) Γ Ø t ∶∶ (τ1, τ2) fst Γ Ø fst t ∶∶ τ1 Γ Ø t ∶∶ (τ1, τ2) snd Γ Ø snd t ∶∶ τ2 Formal Methods and Functional Programming, Exam, SS17 7Formal Methods and Functional Programming, Exam, SS17 8 Assignment 2: Proofs about funct. programs (8 points) Consider the following Haskell declaration. xrev :: [a] -> [a] xrev xs = go xs [] --xrev where go [] ys = ys --go.1 go (x:xs) ys = go xs (x:ys) --go.2 Prove that for all ﬁnite lists xs :: [a] the equality xrev (xrev xs) = xs holds. Structure your proof clearly and justify every proof step. Hint: You may want to prove the auxiliary lemma go (go xs ys) zs = go ys (xs ++ zs). The Haskell function ++ is deﬁned as following: (++) :: [a] -> [a] -> [a] (++) [] ys = ys --app.1 (++) (x:xs) ys = x : (xs ++ ys) --app.2 You may use the following auxiliary lemma without providing a proof for it: xs ++ [] = xs --app_Nil For any other auxiliary lemma that you use, you must provide a full proof (even if that lemma was already proved in the lecture). Formal Methods and Functional Programming, Exam, SS17 9Formal Methods and Functional Programming, Exam, SS17 10 Assignment 3: Fun with lists (10 points) In this assignment, you may use any function from one subproblem to solve the subsequent subproblems, even if you have not provided a deﬁnition for the function itself. 1. Run-length encoding is a lossless data compression algorithm in which runs of data (that is, sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run. (a) Deﬁne a function group :: Eq a => [a] -> [[a]] that groups (3 points) consecutive equal elements of a list into sublists. For example: group [1,1,1,5,2,2,2,2,7,7] = [[1,1,1], [5], [2,2,2,2], [7,7]] (b) Deﬁne a function encode :: Eq a => [a] -> [(a,Int)] that (2 points) computes the run-length encoding of a list using the function group. For example: encode \"FFFFFMMMMFFPPP\" = [('F',5), ('M',4), ('F',2), ('P',3)] encode [1,1,1,5,2,2,2,2,7,7] = [(1,3), (5,1), (2,4), (7,2)] (c) Deﬁne a function decode :: [(a,Int)] -> [a] that decodes a (1 point) run-length encoding. For example: decode [('F',5), ('M',4), ('F',2), ('P',3)] = \"FFFFFMMMMFFPPP\" decode [(1,3), (5,1), (2,4), (7,2)] = [1,1,1,5,2,2,2,2,7,7] Formal Methods and Functional Programming, Exam, SS17 11 Assignment 3 continues on the next page. Formal Methods and Functional Programming, Exam, SS17 12 2. (a) Write a function iterate :: (a -> a) -> a -> [a] such that (2 points) iterate f x returns an inﬁnite list of repeated applications of f to x. iterate f x = [x, f x, f (f x),...] Do not use the iterate function from Prelude in this exercise. (b) The look-and-say sequence is the sequence of below integers: (2 points) 1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, . . . where the nth term in generated by reading the (n − 1)st term aloud: The ﬁrst term is 1. 1 is read oﬀ as “one 1” or 11. 11 is read oﬀ as “two 1s” or 21. 21 is read oﬀ as “one 2, then one 1” or 1211. 1211 is read oﬀ as “one 1, one 2, then two 1s” or 111221. 111221 is read oﬀ as “three 1s, two 2s, then one 1” or 312211, and so on. Deﬁne the inﬁnite sequence looknsay :: [[Int]], where each number is rep- resented by the list of its digits. For example: take 5 looknsay = [[1], [1,1], [2,1], [1,2,1,1], [1,1,1,2,2,1]] Hint: You may ﬁnd the functions iterate and encode useful. Formal Methods and Functional Programming, Exam, SS17 13Formal Methods and Functional Programming, Exam, SS17 14 Assignment 4: Navigating in rose trees (11 points) A rose tree is a tree data structure with a variable and unbounded number of branches per node. Here, we consider rose trees with labeled leaves and unlabeled nodes: data Rose a = Leaf a | Node [Rose a] An example element of type Rose String is fmfp = Node [Node [Leaf \"F\"], Node [], Node [Leaf \"F\", Leaf \"P\"], Leaf \"M\"] or pictorially Node Node Leaf \"F\" Node Node Leaf \"M\" Leaf \"F\" Leaf \"P\" 1. (a) Give the type of the canonical fold function foldRose on rose trees (1 point) Hint: foldRose id concat fmfp should be type correct. (b) Deﬁne the canonical fold function foldRose on rose trees (2 points) (c) What does foldRose id concat fmfp evaluate to? (1 point) (d) Using foldRose, deﬁne the map function (1 point) mapRose :: (a -> b) -> Rose a -> Rose b on rose trees. Do not use recur- sion in the deﬁnition of mapRose. Formal Methods and Functional Programming, Exam, SS17 15 Assignment 4 continues on the next page. Formal Methods and Functional Programming, Exam, SS17 16 The zipper data structure provides a way to eﬃciently navigate in a given rose tree. The zipper (u,p) consists of two parts: • a focused subtree u (bold in the ﬁgure), and • a data structure p (dashed) that turns the tree “inside out” by de- scribing the path from the focused subtree to the root of the rose tree t along with the other subtrees left and right of the path (dotted). data Path a = Top | Step [Rose a] (Path a) [Rose a] type Zipper a = (Rose a, Path a) u t p As a more concrete example, consider the zippers focusF = (Leaf \"F\", Step [] (Step [Node [],Node [Leaf \"F\"]] Top [Leaf \"M\"]) [Leaf \"P\"]) focusP = (Leaf \"P\", Step [Leaf \"F\"] (Step [Node [],Node [Leaf \"F\"]] Top [Leaf \"M\"]) []) which focus on two diﬀerent labeled leaves of the binary inner Node in the fmfp tree. Pictorially, focusF (right) is obtained from fmfp (left) as follows: Node Node Leaf \"F\" Node Node Leaf \"M\" Leaf \"F\" Leaf \"P\" (Leaf \"F\", Step Step [] [♠] ) [♡,♢] [♣] Top ♡ ♢ ♣ ♠ 2. In this exercise we want to perform easy navigation tasks with zippers. (a) Deﬁne a function unfocus :: Zipper a -> Rose a that reassembles (2 points) the whole tree that the given zipper represents. For example, unfocus focusF and unfocus focusP should both evaluate to fmfp. (b) Deﬁne a function goto :: [Int] -> Zipper a -> Maybe (Zipper a) (4 points) that inputs an address addr given by a list of integers and a zipper (u, p) and tries to navigate the focus of the zipper to a subtree of u uniquely determined by addr as follows: If addr == [] then we are already there. Otherwise, the head of addr determines to which of the children one should navigate (0-based indexing) and proceed recursively with the tail of addr. Make sure that the function returns Nothing in case the address leaves the bounds of the given tree. For example: goto [2,0] (fmfp, Top) = Just focusF goto [2,1] (fmfp, Top) = Just focusP goto [2,0,0] (fmfp, Top) = Nothing goto [1,0] (fmfp, Top) = Nothing goto [4] (fmfp, Top) = Nothing Hint: The Prelude functions (!!), take, and drop may be useful. Formal Methods and Functional Programming, Exam, SS17 17Formal Methods and Functional Programming, Exam, SS17 18 Part II: Formal Methods Formal Methods and Functional Programming, Exam, SS17 20 Assignment 5 (5 points) Consider an extension of the IMP programming language with the Eiﬀel loop: from s1 until b loop s2 end We describe the semantics of the Eiﬀel loop informally: • The statement s1 is the loop initialization. • The execution of an Eiﬀel loop consists of performing its loop initialization followed by the loop process. If b evaluates to true, the loop process terminates without changing the state. If b evaluates to false, the loop process is the execution of s2 followed by a new loop process. Provide derivation rules for the Eiﬀel loop in the structural operational (Small Step) semantics. In your derivation rules, do not use the following IMP constructs: while, for, repeat. Formal Methods and Functional Programming, Exam, SS17 21Formal Methods and Functional Programming, Exam, SS17 22 Assignment 6 (15 points) Consider the following two IMP statements. sA is deﬁned as while b1 do if b2 then s else skip end end sB is deﬁned as while b1 do s end Prove that the following proposition holds with respect to the natural (Big Step) se- mantics: ∀σ, σ′, b1, b2, s ⋅ (Q (b2, s) ∧ B[[b2]]σ = tt∧ Ø `sA, σe → σ′) Ô⇒ Ø `sB, σe → σ′ where Q(b, s) means that the statement s does not aﬀect the Boolean expression b and is formally deﬁned as: Q(b, s) ≡ ∀σ, σ′⋅ Ø `s, σe → σ′ Ô⇒ B[[b]]σ = B[[b]]σ′. Formal Methods and Functional Programming, Exam, SS17 23Formal Methods and Functional Programming, Exam, SS17 24Formal Methods and Functional Programming, Exam, SS17 25Formal Methods and Functional Programming, Exam, SS17 26 Assignment 7 (10 points) Consider the following IMP statement pow : k := 0; r := a; while (k < n) do k := k + 1; r := r*r end Your task is to construct a proof outline that proves the following Hoare triple: {a = A ∧ 0 < A ∧ n = N ∧ 0 ≤ N } pow {⇓ r = A 2N } Clearly state which loop invariant and loop variant you use in your proof outline. Formal Methods and Functional Programming, Exam, SS17 27Formal Methods and Functional Programming, Exam, SS17 28Formal Methods and Functional Programming, Exam, SS17 29Formal Methods and Functional Programming, Exam, SS17 30 Assignment 8 (10 points) (A) (6 points) Consider the following transition system that models a vending machine. Initially (s1), the vending machine is idle. It is then possible to select a beverage (s2) or insert money (s3). The selection can be modiﬁed any number of times, and money can be requested back before selecting a beverage. Once a selection and payment are made (s4), the vending machine releases a beverage (s5) and returns to the idle state. The extra labels on each state indicate which of three atomic propositions s (selection), p (payment) and d (beverage) are true in that state. s1 {} s3 {p} s2 {s} s4 {s, p} s5 {d} For each of the following LTL formulas, state whether or not the formula deﬁnes a property which is valid in the given transition system and justify your answer: if the property is valid then brieﬂy explain why; if it is not valid then provide a counterexample (in the form of a computation). 1. j[(s ∨ p) 2. [[p ⇒ nd Formal Methods and Functional Programming, Exam, SS17 31 3. j(p ⇒ [d) 4. j([d ⇒ p) (B) (2 points) Is the formula j[(s ∨ p) a regular safety property? If yes, give the regular expression that describes the bad preﬁxes of the property. If not, explain why. (Note: this was the ﬁrst formula used in part A). (C) (2 points) Does the formula [[p ⇒ nd describe a safety property, a liveness property, neither, or both? Justify your answer. (Note: this was the second formula used in part A). Formal Methods and Functional Programming, Exam, SS17 32Formal Methods and Functional Programming, Exam, SS17 33 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ∶∶= skip T x := e T s; s T if b then s else s end T while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). Natural Semantics (Big-Step Semantics) (SkipNS) `skip, σe → σ (AssNS) `x := e, σe → σ[x ( A[[e]]σ] `s1, σe → σ′ `s2, σ′e → σ′′ (SeqNS) `s1;s2, σe → σ′′ `s1, σe → σ′ (IfTNS) `if b then s1 else s2 end, σe → σ′ if B[[b]]σ = tt `s2, σe → σ′ (IfFNS) `if b then s1 else s2 end, σe → σ′ if B[[b]]σ = ﬀ `s, σe → σ′ `while b do s end, σ′e → σ′′ (WhTNS) `while b do s end, σe → σ′′ if B[[b]]σ = tt (WhFNS) `while b do s end, σe → σ if B[[b]]σ = ﬀ Formal Methods and Functional Programming, Exam, SS17 34 Structural Operational Semantics (Small-Step Semantics) (SkipSOS) `skip, σe →1 σ (AssSOS) `x := e, σe →1 σ[x ( A[[e]]σ] `s1, σe →1 σ′ (Seq1SOS) `s1;s2, σe →1 `s2, σ′e `s1, σe →1 `s′ 1, σ′e (Seq2SOS) `s1;s2, σe →1 `s′ 1;s2, σ′e (IfTSOS) `if b then s1 else s2 end, σe →1 `s1, σe if B[[b]]σ = tt (IfFSOS) `if b then s1 else s2 end, σe →1 `s2, σe if B[[b]]σ = ﬀ (WhileSOS) `while b do s end, σe →1 `if b then s;while b do s end else skip end, σe Axiomatic Semantics (partial correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ( e] } x := e { P } { P } s1 { Q } { Q } s2 { R } (SeqAx) { P } s1;s2 { R } { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P′ } s { Q′ } (ConsAx) { P } s { Q } if P à P′ and Q′ à Q Axiomatic Semantics (total correctness) As for partial correctness above, except for the following rule, which replaces (WhAx) : { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P à 0 ≤ e","libVersion":"0.5.0","langs":""}