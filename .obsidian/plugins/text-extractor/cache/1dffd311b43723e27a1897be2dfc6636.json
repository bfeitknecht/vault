{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s10-IMP.pdf","text":"Formal Methods and Functional Programming Introduction to Language Semantics Peter M¨uller Programming Methodology Group ETH Zurich 2. Introduction to Language Semantics 2.1 The Language IMP [N&N, p. 7–9] 2.2 Semantics of IMP Expressions [N&N, p. 9–14] 2.3 Properties of the Expression Semantics [N&N, p. 15–17] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 34 The Language IMP Expressions Boolean and arithmetic expressions No side-effects in expressions Variables All variables range over integers All variables are initialized IMP does not include Heap allocation and pointers Variable declarations Procedures Concurrency (But, we will discuss some as extensions later) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 35 Syntax of IMP: Example y := 1; while x > 1 do y := y * x; x := x - 1 end David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 36 Concrete Syntax of IMP: Characters and Tokens Characters Letter = ’A’ | . . . | ’Z’ | ’a’ | . . . | ’z’ Digit = ’0’ | ’1’ | ’2’ | ’3’ | ’4’ | ’5’ | ’6’ | ’7’ | ’8’ | ’9’ Tokens Ident = Letter { Letter | Digit }* Numeral = Digit | Numeral Digit Var = Ident David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 37 Concrete and Abstract Syntax of IMP: Expressions Arithmetic expressions Aexp = ’(’ Aexp Op Aexp ’)’ | Var | Numeral Op = ’+’ | ’-’ | ’*’ data Aexp = Bin Op Aexp Aexp | Var String | Num Integer data Op = Add | Sub | Mul Boolean expressions Bexp = ’(’ Bexp ’or’ Bexp ’)’ | ’(’ Bexp ’and’ Bexp ’)’ | ’not’ Bexp | Aexp Rop Aexp Rop = ’=’ | ’#’ | ’<’ | ’<=’ | ’>’ | ’>=’ data Bexp = Or Bexp Bexp | And Bexp Bexp | Not Bexp | Rel Rop Aexp Aexp data Rop = Eq | Neq | Le | Leq | Ge | Geq David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 38 Concrete and Abstract Syntax of IMP: Statemens Stm = ’skip’ | Var ’:=’ Aexp | ’(’ Stm ’;’ Stm ’)’ | ’if’ Bexp ’then’ Stm ’else’ Stm ’end’ | ’while’ Bexp ’do’ Stm ’end’ data Stm = Skip | Assign String Aexp | Seq Stm Stm | If Bexp Stm Stm | While Bexp Stm We omit parentheses if permitted by the usual operator precedence David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 39 Meta-variables Meta-variables denote an arbitrary element of a syntactic category, e.g., an arbitrary statement We follow naming conventions for meta-variables: n for numerals (Numeral) x, y , z for variables (Var) e, e′, e1, e2 for arithmetic expressions (Aexp) b, b1, b2 for boolean expressions (Bexp) s, s ′, s1, s2 for statements (Stm) Meta-variables are written in math font (e.g., x, y , e, . . . ) Program variables are written in typewriter font We use the naming conventions to avoid the need for explicit types For example, when we write ∀x.P(x), we mean ∀x ∈ Var.P(x) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 40 Meta-variables vs. Program Variables Meta-variables x and y stand for arbitrary program variables Program variables x and y are concrete variables in a program We write ≡ for syntactic equality on variables, statements, etc. x = y might evaluate to true in some states, but x ≡ y is always false (not syntactically equal) x ≡ y might be true (i.e., they both could denote the same program variable) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 41 2. Introduction to Language Semantics 2.1 The Language IMP 2.2 Semantics of IMP Expressions 2.3 Properties of the Expression Semantics David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 42 Semantic Functions Syntactic category: Numeral Semantic category: Val = Z 101 - 5 101 - 101 Semantic functions map elements of syntactic categories to elements of semantic categories To define the semantics of IMP, we need semantic functions for Numerals (syntactic category Numeral) Arithmetic expressions (syntactic category Aexp) Arithmetic operators (syntactic category Op) Boolean expressions (syntactic category Bexp) Relational operators (syntactic category Rop) Statements (syntactic category Stm) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 43 Semantics of Numerals The semantic function N ∶ Numeral → Val maps a numeral n to an integer value N [[n]] N [[0]] = 0 N [[1]] = 1 . . . N [[8]] = 8 N [[9]] = 9 N [[n 0]] = N [[n]] × 10 + 0 N [[n 1]] = N [[n]] × 10 + 1 . . . N [[n 8]] = N [[n]] × 10 + 8 N [[n 9]] = N [[n]] × 10 + 9 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 44 States x+1 - ?? The meaning of an expression depends on the values bound to the variables that occur in it A state is a total function, associating a value with each program variable State ∶ Var → Val We use σ as a meta-variable for states David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 45 Constructing and Comparing States We define a designated (constant) state σzero, in which all variables have the value 0: σzero(x) = 0 for all x Updating States: σ[y ↦ v ] is the function that overrides the association of y in σ by y ↦ v . (σ[y ↦ v ])(x) = { v if x ≡ y σ(x) if x /≡ y Two states σ1 and σ2 are equal if they are equal as functions: σ1 = σ2 ⇔ ∀x.(σ1(x) = σ2(x)) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 46 Semantics of Arithmetic Expressions The semantic function A ∶ Aexp → State → Val maps an arithmetic expression e and a state σ to a value A[[e]]σ A[[x]]σ = σ(x) A[[n]]σ = N [[n]] A[[e1 op e2]]σ = A[[e1]]σ op A[[e2]]σ for op ∈ Op op is the operation Val × Val → Val corresponding to op David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 47 Semantics of Boolean Expressions The semantic function B ∶ Bexp → State → Bool maps a boolean expression b and a state σ to a truth value B[[b]]σ B[[e1 op e2]]σ = { tt if A[[e1]]σ op A[[e2]]σ ff otherwise op ∈ Rop; op is the relation Val × Val corresponding to op David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 48 Boolean Expressions (cont’d) B[[b1 or b2]]σ = { tt if B[[b1]]σ = tt or B[[b2]]σ = tt ff otherwise B[[b1 and b2]]σ = { tt if B[[b1]]σ = tt and B[[b2]]σ = tt ff otherwise B[[not b]]σ = { tt if B[[b]]σ = ff ff otherwise David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 49 2. Introduction to Language Semantics 2.1 The Language IMP 2.2 Semantics of IMP Expressions 2.3 Properties of the Expression Semantics David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 50 Inductive Definitions The semantics is given by recursive definitions of functions A and B The values for the basic elements (e.g., x) are defined directly The values for composite elements are defined inductively in terms of the immediate constituents A[[x]]σ = σ(x) A[[n]]σ = N [[n]] A[[e1 op e2]]σ = A[[e1]]σ op A[[e2]]σ for op ∈ Op Since the decomposition of the elements is unique, the definition gives a well-defined function (proof shortly) Inductive definitions suggest proofs by structural induction David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 51 Reminder: Structural Induction data Nat = Zero | Succ Nat Induction over structure of terms Γ ⊢ P(Zero) Γ, P(m) ⊢ P(Succ m) Γ ⊢ ∀n ∈ Nat.P(n) m not free in Γ In this part of the course, we write P(m) instead of P[n ↦ m] Second premise needs to be proved for all m Sufficient to show P(Zero), P(Succ Zero), . . . Useful (see first half of the course) to prove theorems like ∀x, y , z ∈ Nat. plus x (plus y z) = plus (plus x y ) z Structural induction on x helps because plus is defined inductively (over its first argument) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 52 Structural Induction over Programs Recall: abstract syntax is defined as algebraic data type data Aexp = Bin Op Aexp Aexp | Var String | Num Integer data Op = Add | Sub | Mul We can prove properties of syntactic elements via structural induction In proofs, we will use the concrete syntax instead of the terms of the abstract syntax to identify the cases Γ ⊢ P(x) Γ ⊢ P(n) Γ, P(e1), P(e2) ⊢ P(e1 op e2) (∗) Γ ⊢ ∀e ∈ Aexp.P(e) ∗(x, n, e1, e2, op not free in Γ) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 53 Inductive Definitions: Example New arithmetic expression: -e Inductive definition of A[[-e]]σ A[[-e]]σ = 0-A[[e]]σ e is a subterm of -e When proving a property by structural induction on Aexp, the case for -e may assume the induction hypothesis for e Non-inductive definition of A[[-e]]σ A[[-e]]σ = A[[0-e]]σ 0-e is not a subterm of -e When proving a property by structural induction on Aexp, the case for -e must not assume the induction hypothesis for 0-e David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 54 Using Structural Induction Lemma: The equations for N define a total function N ∶ Numeral → Val To prove the lemma, we show that for each n ∈ Numeral there is exactly one v ∈ Val such that N [[n]] = v N is defined inductively over the structure of the numeral: N [[0]] = 0 N [[1]] = 1 . . . N [[8]] = 8 N [[9]] = 9 N [[n 0]] = N [[n]] × 10 + 0 N [[n 1]] = N [[n]] × 10 + 1 . . . N [[n 8]] = N [[n]] × 10 + 8 N [[n 9]] = N [[n]] × 10 + 9 This suggests proving the lemma by structural induction on n David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 55 Proof: N is a Total Function Case: n ≡ d, for some digit d There are ten further cases for the ten different possible digits. In each case, N maps d to exactly one value in Val. Case: n ≡ n1 d, for some numeral n1 and digit d We show here the case d ≡ 0 (the other nine cases are analogous). Our induction hypothesis (for n1) tells us: there is exactly one v1 ∈ Val such that N [[n1]] = v1 The equations for N define N [[n1 0]] = N [[n1]] × 10 + 0 Therefore, N [[n]] = v1 × 10 + 0 Since multiplication and addition are total functions, we can conclude that there is exactly one value for v1 × 10 + 0 and, thus, for N [[n]] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 56 A is a Total Function Lemma: The equations for A define a total function A ∶ Aexp → State → Val To prove the lemma, we show that for each e ∈ Aexp and σ ∈ State there is exactly one v ∈ Val such that A[[e]]σ = v A is defined inductively over the structure of the expression: A[[x]]σ = σ(x) A[[n]]σ = N [[n]] A[[e1 op e2]]σ = A[[e1]]σ op A[[e2]]σ for op ∈ Op This suggests a proof by structural induction on e David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 57 Proof: A is a Total Function 1. Case: e ≡ n, for some numeral n The equations define A[[n]]σ = N [[n]]. By the previous lemma, N is a total function and, thus, N [[n]] yields exactly one value in Val 2. Case: e ≡ x, for some variable x The equations define A[[x]]σ = σ(x). σ is a total function, σ(x) ∈ Val 3. Case: e ≡ e1 op e2, for some e1, e2 and op ∈ Op Our induction hypothesis gives us the property for e1 and e2 (sub-terms of e By applying the induction hypothesis for both e1 and e2, we get: (a) there is exactly one v1 ∈ Val such that A[[e1]]σ = v1 and (b) there is exactly one v2 ∈ Val such that A[[e2]]σ = v2 The equations for A define A[[e1 op e2]]σ = A[[e1]]σ op A[[e2]]σ By using (a) and (b), we get: A[[e1 op e2]]σ = v1 op v2 Since op is a total function (addition, subtraction, or multiplication), we can conclude that there is exactly one value for v1 op v2 and, thus, for A[[e1 op e2]]σ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 58 Free Variables Arithmetic expressions FV(e1 op e2) = FV(e1) ∪ FV(e2) FV(n) = ∅ FV(x) = {x} Boolean expressions FV(e1 op e2) = FV(e1) ∪ FV(e2) FV(not b) = FV(b) FV(b1 or b2) = FV(b1) ∪ FV(b2) FV(b1 and b2) = FV(b1) ∪ FV(b2) Statements FV(skip) = ∅ FV(x:=e) = {x} ∪ FV(e) FV(s1;s2) = FV(s1) ∪ FV(s2) FV(if b then s1 else s2 end) = FV(b) ∪ FV(s1) ∪ FV(s2) FV(while b do s end) = FV(b) ∪ FV(s) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 59 Substitution Substitution “ [x ↦ e]” replaces each free occurrence of variable x by e Arithmetic expressions (e1 op e2)[x ↦ e] ≡ (e1[x ↦ e] op e2[x ↦ e]) n[x ↦ e] ≡ n y [x ↦ e] ≡ { e if x ≡ y y otherwise Boolean expressions (e1 op e2)[x ↦ e] ≡ (e1[x ↦ e] op e2[x ↦ e]) (not b)[x ↦ e] ≡ not (b[x ↦ e]) (b1 or b2)[x ↦ e] ≡ (b1[x ↦ e] or b2[x ↦ e]) (b1 and b2)[x ↦ e] ≡ (b1[x ↦ e] and b2[x ↦ e]) We will use the following substitution lemma (see exercises for proof): B[[b[x ↦ e]]]σ ⇔ B[[b]]σ[x ↦ A[[e]]σ] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 60 Syntactic Abbreviations if b then s end if b then s else skip end true 1=1 false 0=1 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 61","libVersion":"0.5.0","langs":""}