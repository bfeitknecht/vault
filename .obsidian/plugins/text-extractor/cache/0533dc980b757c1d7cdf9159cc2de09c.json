{"path":"sem2/PProg/VRL/slides/PProg-L17-lock-problems.pdf","text":"spcl.inf.ethz.ch @spcl_eth TORSTEN HOEFLER Parallel Programming, Spring 2024, Lecture 17: Spinlocks, Deadlocks, Semaphores 200 Pflop/s peak #1 top500 57 Pflop/s real app 27,360 V100 GPUs spcl.inf.ethz.ch @spcl_eth 2 Some months later Gordon Bell Award 2019 spcl.inf.ethz.ch @spcl_eth ▪ So far: ▪ Bad interleavings and data races and why they happen ▪ Memory ordering and how we formalize it to drive proofs ▪ Implementation of locks using atomic or safe registers (Peterson lock) ▪ Multi-process locks (using SWMR registers) ▪ Now: ▪ Implementation of locks with Read-Modify-Write operations ▪ Concurrency on a higher level: Deadlocks, Semaphores, Barriers ▪ Learning goals: ▪ Understand pitfalls in very simple synchronization algorithms ▪ This is very important to design correct parallel codes 3 Learning goals for today spcl.inf.ethz.ch @spcl_eth Process P (1) loop non-critical section flag[P] = true victim = P while(flag[Q] && victim == P); critical section flag[P] = false More concise than Decker: Peterson Lock (recap) Process Q (2) loop non-critical section flag[Q] = true victim = Q while(flag[P] && victim == Q); critical section flag[Q] = false let P=1, Q=2; volatile boolean array flag[1..2] = [false, false]; volatile integer victim = 1 I am interested but you go first We both are interested And you go first 4 spcl.inf.ethz.ch @spcl_eth Register: basic memory object, can be shared or not i.e., in this context register ≠ register of a CPU Register r : operations r.read() and r.write(v) Atomic Register: ▪ An invocation J of r.read or r.write takes effect at a single point 𝝉(𝑱) in time ▪ 𝝉(𝑱) always lies between start and end of the operation J ▪ Two operations J and K on the same register always have a different effect time 𝝉(𝑱) ≠ 𝝉(𝑲) ▪ An invocation J of r.read() returns the value v written by the invocation K of r.write(v) with closest preceding effect time 𝝉(𝑲) Atomic register (recap) 5 spcl.inf.ethz.ch @spcl_eth int[] level(#threads), int[] victim(#threads) lock(me) { for (int i=1; i<n; ++i) { level[me] = i; victim[i] = me; while (∃k ≠ me: level[k] >= i && victim[i] == me) {}; } } unlock(me) { level[me] = 0; } 6 The Filter Lock (recap) Other threads are at same or higher level And I have to wait non-CS with n threads n-1 threads n-2 threads 2 threads CS ... 1 2 n 0 spcl.inf.ethz.ch @spcl_eth lock(me): flag[me] = true; label[me] = max(label[0], ... , label[n-1]) + 1; while (∃k ≠ me: flag[k] && (k,label[k]) <l (me, label[me])) {}; unlock(me): flag[me] = false; 7 Bakery algorithm (recap) integer array[0..n-1] label = [0, ..., 0] boolean array[0..n-1] flag = [false, ..., false] 𝑘, 𝑙𝑘 <l 𝑗, 𝑙𝑗 ⇔ 𝑙𝑘 < 𝑙𝑗 or (𝑙𝑘 = 𝑙𝑗 and 𝑘 < 𝑗) SWMR «I want the lock» SWMR «ticket number» spcl.inf.ethz.ch @spcl_eth class BakeryLock { AtomicIntegerArray flag; // there is no AtomicBooleanArray AtomicIntegerArray label; final int n; BakeryLock(int n) { this.n = n; flag = new AtomicIntegerArray(n); label = new AtomicIntegerArray(n); } int MaxLabel() { int max = label.get(0); for (int i = 1; i<n; ++i) max = Math.max(max, label.get(i)); return max; } ... 8 Bakery Lock in Java boolean Conflict(int me) { for (int i = 0; i < n; ++i) if (i != me && flag.get(i) != 0) { int diff = label.get(i) - label.get(me); if (diff < 0 || diff == 0 && i < me) return true; } return false; } public void Acquire(int me) { flag.set(me, 1); label.set(me, MaxLabel() + 1); while(Conflict(me)); } public void Release(int me) { flag.set(me, 0); } } spcl.inf.ethz.ch @spcl_eth Shared memory locations (atomic registers) come with different access requirements • Multi-Reader-Single-Writer (flag[], label[] in Bakery) • Multi-Reader-Multi-Writer (victim in Peterson) ▪ Theorem 5.1 in [1]: “If S is a [atomic] read/write system with at least two processes and S solves mutual exclusion with global progress [deadlock-freedom], then S must have at least as many variables as processes” 9 In general [1]: I and 10,000,000 threads! spcl.inf.ethz.ch @spcl_eth … that may not quite fulfil its purpose! AND we cannot do better, can we? ▪ Is mutual exclusion really implemented like this? ▪ NO! Why? - space lower bound linear in the number of maximum threads! - without precautions (volatile variables) our assumptions on memory reordering does not hold. Memory barriers in hardware are expensive. - algorithms are not wait-free (more later) ▪ But we proved that we cannot do better. What now!? ▪ Change (extend) the model with architecture engineering! - modern multiprocessor architectures provide special instructions for atomically reading and writing at once! 10 We have constructed something … spcl.inf.ethz.ch @spcl_eth 11 Hardware Support for Parallelism Read-Modify-Write Operations spcl.inf.ethz.ch @spcl_eth 12 Hardware support for atomic operations: Example (x86) CMPXCHG mem, reg «compares the value in Register A with the value in a memory location If the two values are equal, the instruction copies the value in the second operand to the first operand and sets the ZF flag in the flag registers to 1. Otherwise it copies the value in the first operand to the A register and clears ZF flag to 0» «The LOCK prefix causes certain kinds of memory read-modify-write instructions to occur atomically» From the AMD64 Architecture Programmer’s Manual R. Hudson: IA memory ordering: https://www.youtube.com/watch?v=WUfvvFD5tAA (2008) spcl.inf.ethz.ch @spcl_eth 13 Hardware support for atomic operations: Example (ARM) LDREX <rd>, <rn> «Loads a register from memory and if the address has the shared memory attribute, mark the physical address as exclusive access for the executing processor in a shared monitor» STREX <rd>, <rm>, <rn> «performs a conditional store to memory. The store only occurs if the executing processor has exclusive access to the memory addressed» From the ARM Architecture Reference Manual spcl.inf.ethz.ch @spcl_eth Typical instructions Test-And-Set (TAS) Example TSL register, flag (Motorola 68000) Compare-And-Swap (CAS) Example: LOCK CMPXCHG (Intel x86) Example: CASA (Sparc) Load Linked / Store Conditional Example LDREX/STREX (ARM) Example LL / SC (MIPS, POWER, RISC V) 14 Hardware support for atomic operations Atomic instructions are typically much slower than simple read & write operations [1]! [1]: H. Schweizer, M. Besta, T. Hoefler: Evaluating the Cost of Atomic Operations on Modern Architectures, ACM PACT’15 spcl.inf.ethz.ch @spcl_eth boolean TAS(memref s) if (mem[s] == 0) { mem[s] = 1; return true; } else return false; 15 Semantics of TAS and CAS int CAS (memref a, int old, int new) oldval = mem[a]; if (old == oldval) mem[a] = new; return oldval;atomicatomic ▪ are Read-Modify-Write («atomic») operations ▪ enable implementation of a mutex with O(1) space (in contrast to Filter lock, Bakery lock etc.) ▪ are needed for lock-free programming (later in this course) spcl.inf.ethz.ch @spcl_eth 16 Implementation of a spinlock using simple atomic operations Init (lock) lock = 0; Acquire (lock) while !TAS(lock); // wait Release (lock) lock = 0; Test and Set (TAS) Compare and Swap (CAS) Init (lock) lock = 0; Acquire (lock) while (CAS(lock, 0, 1) != 0); Release (lock) CAS(lock, 1, 0); ignore result spcl.inf.ethz.ch @spcl_eth 17 Read-Modify-Write in Java spcl.inf.ethz.ch @spcl_eth Need support for atomic operations on a high level. Available in Java (from JDK 5) with class java.util.concurrent.atomic.AtomicBoolean Operations boolean set(); boolean get(); boolean compareAndSet(boolean expect, boolean update); boolean getAndSet(boolean newValue); 18 Let's try it. atomically set to value update iff current value is expect. Return true on success. sets newValue and returns previous value. spcl.inf.ethz.ch @spcl_eth ▪ The JVM bytecode does not offer atomic operations like CAS. [It does, however, support monitors via instructions monitorenter, monitorexit, we will understand this later] ▪ But there is a (yet undocumented) class sun.misc.Unsafe offering direct mappings from java to underlying machine / OS. ▪ Direct mapping to hardware is not guaranteed – operations on AtomicBoolean are not guaranteed lock-free 19 How does this work? (for experts) spcl.inf.ethz.ch @spcl_eth (source: grepcode.com) 20 Example: java.util.concurrent.atomic.AtomicInteger (for experts) ... spcl.inf.ethz.ch @spcl_eth public class TASLock implements Lock { AtomicBoolean state = new AtomicBoolean(false); public void lock() { while(state.getAndSet(true)) {} } public void unlock() { state.set(false); } ... } 21 TASLock in Java Spinlock: Try to get the lock. Keep trying until the lock is acquired (return value is false). unlock release the lock (set to false) spcl.inf.ethz.ch @spcl_eth TAS n = 1, elapsed= 224, normalized= 224 n = 2, elapsed= 719, normalized= 359 n = 3, elapsed= 1914, normalized= 638 n = 4, elapsed= 3373, normalized= 843 n = 5, elapsed= 4330, normalized= 866 n = 6, elapsed= 6075, normalized= 1012 n = 7, elapsed= 8089, normalized= 1155 n = 8, elapsed= 10369, normalized= 1296 n = 16, elapsed= 41051, normalized= 2565 n = 32, elapsed= 156207, normalized= 4881 n = 64, elapsed= 619197, normalized= 9674 22 Simple TAS Spin Lock – Measurement Results ▪ run n threads ▪ each thread acquires and releases the TASLock a million times ▪ repeat scenario ten times and add up runtime ▪ record time per thread Intel core i7@3.4 GHz, 4 cores + HT spcl.inf.ethz.ch @spcl_eth sequential bottleneck contention: threads fight for the bus during call of getAndSet() cache coherency protocol invalidates cached copies of the lock variable on other processors 23 Why? Bus cache memory cachecache spcl.inf.ethz.ch @spcl_eth public void lock() { do while(state.get()) {} while (!state.compareAndSet(false, true)); } public void unlock() { state.set(false); } 24 Test-and-Test-and-Set (TATAS) Lock spcl.inf.ethz.ch @spcl_eth 25 Measurement 0 2000 4000 6000 8000 10000 12000 0 10 20 30 40 50 60 70 TAS TTAS number threads ms/ thread note that this varies strongly between machines and JVM implementations and even between runs. Take it as a qualitative statement spcl.inf.ethz.ch @spcl_eth 26 TATAS does not generalize ▪ Example: Double-Checked Locking Problem: Memory ordering leads to race-conditions! spcl.inf.ethz.ch @spcl_eth Observation ▪ (too) many threads fight for access to the same resource ▪ slows down progress globally and locally Solution ▪ threads go to sleep with random duration ▪ increase expected duration each time the resource is not free 27 TATAS with backoff ☺ ☺ spcl.inf.ethz.ch @spcl_eth public void lock() { Backoff backoff = null; while (true) { while (state.get()) {}; // spin reading only (TTAS) if (!state.getAndSet(true)) // try to acquire, returns previous val return; else { // backoff on failure try { if (backoff == null) // allocation only on demand backoff = new Backoff(MIN_DELAY, MAX_DELAY); backoff.backoff(); } catch (InterruptedException ex) {} } } } 28 Lock with Backoff spcl.inf.ethz.ch @spcl_eth class Backoff {... public void backoff() throws InterruptedException { int delay = random.nextInt(limit); if (limit < maxDelay) { // double limit if less than max limit = 2 * limit; } Thread.sleep(delay); } } 29 exponential backoff spcl.inf.ethz.ch @spcl_eth 30 Measurement 0 2000 4000 6000 8000 10000 12000 0 10 20 30 40 50 60 70 TAS TTAS BackoffLock number threads ms/ thread yeah! spcl.inf.ethz.ch @spcl_eth Deadlock 31 spcl.inf.ethz.ch @spcl_eth class BankAccount { … synchronized void withdraw(int amount) {…} synchronized void deposit(int amount) {…} synchronized void transferTo(int amount, BankAccount a) { this.withdraw(amount); a.deposit(amount); } } 32 Deadlocks – Motivation Thread aquires second lock in a.deposit. Can this become a problem? Consider a method to transfer money between bank accounts spcl.inf.ethz.ch @spcl_eth Suppose x and y are instances of class BankAccount 33 Deadlocks – Motivation acquire lock for x withdraw from x acquire lock for y acquire lock for y withdraw from y acquire lock for x Thread 1: x.transferTo(1,y)Time Thread 2: y.transferTo(1,x) x y class BankAccount { … synchronized void withdraw(int amount) {…} synchronized void deposit(int amount) {…} synchronized void transferTo(int amount, BankAccount a) { this.withdraw(amount); a.deposit(amount); } } spcl.inf.ethz.ch @spcl_eth Deadlock: two or more processes are mutually blocked because each process waits for another of these processes to proceed. 34 Deadlocks","libVersion":"0.3.2","langs":""}