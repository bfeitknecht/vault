{"path":"sem4/DMDB/UE/slides/DMDB-s06-functional-dependency.pdf","text":"Joris Belder Data Modelling & Databases jbelder@student.ethz.ch Exercise 6: Functional Dependencies Spring 25 ▪ We will go through the questions one by one ▪ Necessary background knowledge is explained before each question ▪ Please do ask if anything is unclear! Contents Functional Dependencies are a tool ▪ For analysing data redundancy ▪ For understanding good schema design Symptoms of data redundancy and bad schemas are ▪ Data duplication ▪ Extra business logic Data Redundancy Data anomalies are a symptom of bad schemas/data redundancy Question 1 – Deletion Anomaly Deletion Anomaly: The unintended loss of data due to the deletion of other data Transaction ID Amount Remaining Balance 0 -200 1900 1 +300 2200 2 -400 1800 3 +200 2000 Removing all transactions removes all balance information as well (assuming it is not stored elsewhere). Transaction ID Amount Remaining Balance Person should still have 2100,- but this is not stored in the DB Question 2 – Update Anomaly Update Anomaly: Data inconsistencies as a result of partial updates Transaction ID Amount Remaining Balance 0 -200 1900 1 +300 2200 2 -400 1800 3 +200 2000 Updating the Amount value in one row will cause inconsistencies in Remaining Balance Transaction ID Amount Remaining Balance 0 -200 1900 1 +200 2100 2 -400 1800 3 +200 2000 Question 3 – Insertion Anomaly Insertion Anomaly: The inability to add data to the DB due to the absence of other data Transaction ID Amount Remaining Balance 0 -200 1900 1 +300 2200 2 -400 1800 3 +200 2000 The schema does not allow us to indicate the Remaining Balance without first having a transaction Transaction ID Amount Remaining Balance We cannot store that the person has 2100,- in their bank account So what is a Functional Dependency? 𝛼 → 𝛽 iff. ∀𝑟, 𝑠 ∈ 𝑅: 𝑟. 𝛼 = 𝑠. 𝛼 ⇒ 𝑟. 𝛽 = 𝑠. 𝛽 a b 1 x 2 z 3 a … … a b You‘ve already seen functional dependencies with keys. A key determines the whole relation! How do I obtain Functional Dependencies? ▪ In general: Depends on what you model. You‘ll probably have an intuitive feeling in the exact application. ➢ For example, most entities have some form of identifier which uniquely determines the entity, such as a Student Id(entifier) for a Student ▪ Once you have them, you can use the Armstrong’s Axioms to derive others ▪ A change in the Functional Dependencies, may require the schema to be redesigned Think well about all Functional Dependencies in your domain ▪ Consider the following relation instance Question 4 Student_Id Student_Address Lecture Teaching_Assistant 1234 Rämistrasse 72 DMDB Bob 1280 Rennweg 19 PProg Scott 1235 Rämistrasse 72 VisCom Sarah 1299 Börsenstrasse 42 PProg Benjamin 1356 Klusplatz 45 QCom Benjamin ▪ Is it possible to formally deduce all functional dependencies? It is not. Deducing all functional dependencies requires knowledge of what the attributes represent. You need so-called domain knowledge. Which functional dependencies can be obtained from this ER diagram? Question 5 – FDs from ER How to read this? • Choose a group of all but one entities • Look at the cardinality of the excluded entity • If the cardinality is 1, there is an FD ▪ Movie, Actor, Director → Production ▪ Movie, Actor, Production → Director Closure – How far can we get with given attributes? ▪ You may know of a related concept called a „transitive closure“ from different courses like discrete mathematics. ▪ In DMDB: the closure tells you which attributes are determined, given some attribute(s) 𝛼: • Which attributes are (indirectly) determined by 𝛼 given a set of functional dependencies: 𝛼+ = 𝑦 ∈ ℛ 𝐹 ⊢ 𝛼 → 𝑦} ▪ Example: What is the closure of a key? • Answer: All attributes of the relation Closure algorithm – Visual Intuition 𝑎 𝑏 𝑐 𝑑 𝑒 𝑒 𝑎 How to get the closure of 𝑎 given 𝑎 → 𝑏 𝑏𝑒 → 𝑑 𝑒𝑐 → 𝑑 𝑎 𝑏 Iterate until no changeClosure so far: Only one iteration as there‘s no change anymore: 𝑒 is not in the closure of 𝑎! Closure algorithm closure(set<attribute> a, set<FD> F): a’ = a; do { a_old = a’; foreach FD (b -> c) in F { if (b subsetOf a’) { a’ = a’ union c; } } while (a’ != a_old); return a’; Question 6 - Closures • (6) 𝐴 → 𝐵 because of (1). • (7) 𝐴 → 𝐶 because of (1). • (8) 𝐴 → 𝐸 transitive property (6) and (3). • (9) 𝐴 → 𝐹 transitive property from (8) and (2). • (10) 𝐴 → 𝐺 because of (5). • Therefore, 𝐴+ = {𝐴, 𝐵, 𝐶, 𝐸, 𝐹, 𝐺}. Given a relation 𝑅 𝐴, 𝐵, 𝐶, 𝐷, 𝐸, 𝐹, 𝐺 and the following five FDs: 1. 𝐴 → 𝐵𝐶 2. 𝐸 → 𝐶𝐹 3. 𝐵 → 𝐸 4. 𝐶𝐷 → 𝐸𝐹 5. 𝐴 → 𝐺 Select all attributes that constitute the closure of 𝐴. Question 7 - Closures Select all attributes that constitute the closure of 𝐺. • 𝐺+ = {𝐺}. There‘s no 𝐺 on the left… Given a relation 𝑅 𝐴, 𝐵, 𝐶, 𝐷, 𝐸, 𝐹, 𝐺 with the following five FDs: 1. 𝐴 → 𝐵𝐶 2. 𝐸 → 𝐶𝐹 3. 𝐵 → 𝐸 4. 𝐶𝐷 → 𝐸𝐹 5. 𝐴 → 𝐺 Keys - Again ▪ Lecture 2: „Candidate Key: minimal set of fields that identify each tuple uniquely“ ▪ A key is now defined as a functional dependency which determines the whole relation: 𝛼 ⊆ ℛ is a candidate key iff ➢ 𝛼 →. ℛ Some subset of fields (must be minimal for a candidate key) Our relation 𝛼 → 𝛽 is minimal iff ∀𝐴 ∈ 𝛼: (𝛼 − 𝐴 ) ↛ 𝛽 This means: we cannot remove any attribute for candidate keys! Superkeys? ▪ Superkey = Candidate key + possibly other attributes ➢ formally, this is a superset of a candidate key ▪ Trivial Superkeys: ➢ Every (candidate) key ➢ The whole relation Question 8 – Candidate vs. Superkeys Now consider the following relation 𝑅 𝐴, 𝐵, 𝐶, 𝐷, 𝐸, 𝐹, 𝐺 and the following functional dependencies: 𝐵 → 𝐴𝐹 𝐴 → 𝐺 𝐴 → 𝐵 𝐵 → 𝐶 𝐴𝐺 → 𝐵𝐷 𝐹 → 𝐸 𝐴 functionally determines the whole relation: Informal closure sketch: 𝐴 → 𝐵, 𝐴 → 𝐺 {𝐴, 𝐵, 𝐺} 𝐵 → 𝐴𝐹, 𝐵 → 𝐶 {𝐴, 𝐵, 𝐶, 𝐹, 𝐺} 𝐴𝐺 → 𝐵𝐷 {𝐴, 𝐵, 𝐶, 𝐷, 𝐹, 𝐺} 𝐹 → 𝐸 {𝐴, 𝐵, 𝐶, 𝐷, 𝐸, 𝐹, 𝐺} … which is the whole relation! 𝐵 also functionally determines the whole relation. 𝐵 → 𝐴𝐹, thus 𝐵 determines 𝐴 and we know that 𝐴 is a key. Question 8 – Candidate vs. Superkeys Now consider the following relation 𝑅 𝐴, 𝐵, 𝐶, 𝐷, 𝐸, 𝐹, 𝐺 and the following functional dependencies: 𝐵 → 𝐴𝐹 𝐴 → 𝐺 𝐴 → 𝐵 𝐵 → 𝐶 𝐴𝐺 → 𝐵𝐷 𝐹 → 𝐸 Candidate keys are minimal! … but that isn‘t minimal at all! … while superkeys are just a subset of a key. 𝐴𝐵𝐶𝐷𝐸𝐹𝐺 is the whole relation, so it trivially is a superkey Question 8 – Candidate vs. Superkeys Now consider the following relation 𝑅 𝐴, 𝐵, 𝐶, 𝐷, 𝐸, 𝐹, 𝐺 and the following functional dependencies: 𝐵 → 𝐴𝐹 𝐴 → 𝐺 𝐴 → 𝐵 𝐵 → 𝐶 𝐴𝐺 → 𝐵𝐷 𝐹 → 𝐸 No… Both 𝐴 and 𝐵 are candidate keys. 𝐴𝐵 is not minimal 𝐴 is already a key, thus 𝐴𝐹 is a superset of a key 𝐸 is just on the right and doesn‘t determine 𝑅. Thus not a candidate key 𝐴𝐵 is superset of candidate keys 𝐴 and 𝐵 and is thus a superkey Question 8 – Candidate vs. Superkeys Now consider the following relation 𝑅 𝐴, 𝐵, 𝐶, 𝐷, 𝐸, 𝐹, 𝐺 and the following functional dependencies: 𝐵 → 𝐴𝐹 𝐴 → 𝐺 𝐴 → 𝐵 𝐵 → 𝐶 𝐴𝐺 → 𝐵𝐷 𝐹 → 𝐸 Question 9 Now consider the following relation 𝑅 𝐴, 𝐵, 𝐶, 𝐷, 𝐸, 𝐹, 𝐺 and the following functional dependencies: 𝐵 → 𝐴𝐹 𝐴 → 𝐺 𝐴 → 𝐵 𝐵 → 𝐶 𝐴𝐺 → 𝐵𝐷 𝐹 → 𝐸 1. 𝐴 → 𝐵 → 𝐴𝐹 𝐹 ∈ 𝐴 + 2. Removing 𝐹 → 𝐸 Results in 𝐸 ∉ 𝐴 + Thus 𝐴 would not be a key 3. 𝐹 → 𝐸 4. 𝐴 → 𝐺 𝐴 → 𝐴𝐺 → 𝐵𝐷 𝐴 → 𝐵 Armstrong’s Axioms ▪ Reflexivity ➢ 𝑎 → 𝑏𝑐, implies that 𝑎 → 𝑏 and 𝑎 → 𝑐 ▪ Augmentation ➢ 𝑎 → 𝑏, implies that 𝑎𝑐 → 𝑏𝑐 ▪ Transitivity ➢ 𝑎 → 𝑏 and 𝑏 → 𝑐, implies that 𝑎 → 𝑐 They are Complete and Sound (𝐹 ⊨ 𝛼 → 𝛽 ⇔ 𝐹 ⊢ 𝛼 → 𝛽) Question 10 – Armstrong’s Axioms Given 𝑎 → 𝑏, 𝑎𝑏 → 𝑐 and 𝑎𝑐 → 𝑑, show that 𝑎 → 𝑑 𝑎 → 𝑏 𝑎 → 𝑎𝑏 (Augmentation) 𝑎 → 𝑐 (Transitivity) 𝑎 → 𝑎𝑐 (Augmentation) 𝑎 → 𝑑 (Transitivity) Question 11 – Armstrong’s Axioms Given that 𝑏 is the primary key in some schema ℛ 𝑎, 𝑏, … , show ℛ ∖ {𝑎} → 𝑎 𝑏 → ℛ (From 𝑏 being the primary key) 𝑏 ∪ ℛ ∖ {𝑎} → ℛ ∪ ℛ ∖ {𝑎} (Augmentation) ℛ ∖ {𝑎} → ℛ ℛ ∖ {𝑎} → 𝑎 (Reflexivity) ▪ We aim to construct a relation 𝑅 for which 𝐹 ⊨ 𝛼 → 𝛽 holds, but 𝛼 → 𝛽 does not, given 𝛽 ⊈ 𝛼+ ▪ Step 1: Prove that 𝑅 does not satisfy 𝛼 → 𝛽 ➢ Make sure that for the same value of 𝛼, 𝛽 has different values in 𝑅 ▪ Step 2: Prove that 𝑅 satisfies 𝐹 ➢ For some 𝛾 → 𝜃 ∈ 𝐹. If 𝛾 ⊆ 𝛼+, then 𝐹 ⊢ 𝛼 → 𝛾 → 𝜃. Which follows from 𝐹 ⊢ 𝛼 → 𝛽 ⇔ 𝛽 ⊆ 𝛼+ and transitivity. Thus 𝜃 ⊆ 𝛼+ and 𝑅 ⊨ 𝛾 → 𝜃. ➢ If 𝛾 ⊈ 𝛼+, then 𝛾 must take different values in 𝑅, such that 𝑅 ⊨ 𝛾 → 𝜃 nonetheless. Armstrong’s Axioms Completeness ProofQuestion 12 – Armstrong’s Axioms Completeness To prove the completeness of Armstrong’s Axioms (𝐹 ⊨ 𝛼 → 𝛽 ⇒ 𝐹 ⊢ 𝛼 → 𝛽), a counterexample was shown in the lecture. Given some subset of attributes 𝜇 ⊂ ℛ ∖ 𝛼+ and 𝛿 ⊂ 𝛼+, is the following relation instance a valid counterexample as well? ▪ The counterexample requires ℛ ∖ α+ to have different values for the same 𝛼+ such that 𝛼 → 𝛽 does not hold for step 1 ▪ The counterexample requires that for some 𝛾 ⊈ 𝛼+, 𝛾 takes different values in the relation instance for step 2 ▪ These properties are maintained by the relation instance and thus it is a valid counterexample 𝜶+ 𝓡 ∖ (𝜶+ ∪ 𝝁) μ 111 … 111 000 … 000 111 … 111 111 … 111 111 … 111 000 … 000 Question 13 – Armstrong’s Axioms Completeness To prove the completeness of Armstrong’s Axioms (𝐹 ⊨ 𝛼 → 𝛽 ⇒ 𝐹 ⊢ 𝛼 → 𝛽), a counterexample was shown in the lecture. Given some subset of attributes 𝜇 ⊂ ℛ ∖ 𝛼+ and 𝛿 ⊂ 𝛼+, is the following relation instance a valid counterexample as well? ▪ The counterexample requires ℛ ∖ α+ to have different values for the same 𝛼+ such that 𝛼 → 𝛽 does not hold for step 1 ▪ The counterexample requires that for some 𝛾 ⊈ 𝛼+, 𝛾 takes different values in the relation instance for step 2 ▪ The first property is not maintained as both values of 𝛼+ are different, thus 𝛼 → 𝛽 is satisfied 𝜶+ ∖ 𝜹 𝓡 ∖ 𝜶+ 𝜹 111 … 111 000 … 000 111 … 111 111 … 111 111 … 111 000 … 000 Minimal basis/cover ▪ Set of FDs which is „as small as it gets“: ▪ Suppose you are given a set of FDs 𝐹. ▪ Idea: Simplify 𝐹 as much as possible while still remaining equivalent to 𝐹. →A minimal basis must be equivalent to 𝐹 →A minimal basis cannot be made smaller by deleting an FD or deleting an attribute from the left-hand side →You mostly use your intuition and some Armstrong’s Axioms to calculate the minimal basis →Somewhat tricky to get right and requires paperwork. Question 14: Computing the minimal basisThere are multiple ways to get to the minimal basis/cover ▪ There are cases where the minimal basis is not unique ▪ The algorithm given in the lecture allows you to have freedom and may even lead to different solutions. ▪ It might help coming up with the reductions – especially transitivity - of the minimal basis by visually drawing the closure. 𝑎 𝑏 𝑐 𝑑 𝑒 𝑒 Question 16 – Minimal Basis Exercise 15 guides you through it step by step. Only FD (1) is split, also, we remove duplicate 𝐴 → 𝐵 There are no trivial FDs Question 16 – Minimal Basis We check if we can simplify 𝐴𝐵 → 𝐶. Turns out we can remove both 𝐴 and 𝐵 𝐴 → 𝐵 is duplicated and 𝐴 → 𝐶 is implied by transitivity Question 17 – Minimal BasisQuestion 17 – Minimal Basis 𝐶 → 𝐴 already determines 𝐴, thus: simplify 𝐴𝐶𝐷 → 𝐵 to 𝐶𝐷 → 𝐵 𝐶 → 𝐴 already. 𝐸 can be removed Step 3: is one attribute in LHS in the closure of the others? Question 17 – Minimal Basis Duplicates Start with 𝐶𝐷 𝐷 → 𝐸 𝐶𝐸 → 𝐹 𝐶𝐹 → 𝐵 Start with 𝐶𝐹 𝐶𝐹 → 𝐵 𝐵𝐶 → 𝐷 Step 4: Is RHS in closure of LHS when excluding the chosen FD? Question 17 – Minimal Basis It may be non-trivial to see that this is in fact a minimal basis. Check if you can remove any argument. If you want to practice more with computing the Minimal Basis, you can make use of this website.Decomposition of Relations ▪ We‘d like to have a good DB design → Thus, we might want to decompose relations to not suffer from redundancy ▪ It should remain sound! ▪ Bad relations combine several concepts ➢ Thus: decompose them so that each concept in one relation ➢ 𝑅 ⇝ 𝑅1 … 𝑅𝑛 ▪ Def: Lossless Decomposition ➢ 𝑅 = 𝑅1 ⋈ 𝑅2 … ⋈ 𝑅𝑛 ▪ Preservation of Dependencies ➢ 𝐹𝐷 𝑅 + = 𝐹𝐷 𝑅1 ∪ ⋯ ∪ 𝐹𝐷 𝑅𝑛 + Decomposition Lemma ▪ When is a decomposition lossless? ▪ Let ℛ = ℛ1 ∪ ℛ2 ▪ Consider the decomposition of 𝑅: ➢ 𝑅1 = Πℛ1(𝑅) ➢ 𝑅2 = Πℛ2(𝑅) ▪ This decomposition is lossless (i.e., 𝑅 = 𝑅1 ⋈ 𝑅2), if ➢ (ℛ1∩ ℛ2) → ℛ1 OR ➢ (ℛ1∩ ℛ2) → ℛ2 ▪ ℛ1 𝑎, 𝑏, 𝑐 , ℛ2 𝑑, 𝑒, 𝑓 ▪ No way to join the schemas ▪ 𝑎, 𝑏, 𝑐 in different relation from 𝑒 ▪ Not lossless and not FD preserving Question 18 – Relation Decomposition Given a schema ℛ 𝑎, 𝑏, 𝑐, 𝑑, 𝑒, 𝑓 and the following FDs satisfied by the schema 𝑎𝑏𝑐 → 𝑒, 𝑑 → 𝑒𝑓, determine whether the following schema decompositions are lossless and or FD preserving 𝒂 𝒃 𝒄 𝒅 𝒆 𝒇 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 𝒂 𝒃 𝒄 1 1 1 1 1 1 1 1 2 𝒅 𝒆 𝒇 1 2 1 2 2 1 3 3 3 ⋈ ▪ ℛ1 𝑎, 𝑏, 𝑐, 𝑒 , ℛ2 𝑑, 𝑒, 𝑓 ▪ ℛ1 ∩ ℛ2 ↛ ℛ1 ∨ ℛ2 ▪ Joining the schemas leads to more rows than before ▪ Not lossless, but FD preserving Question 19 – Relation Decomposition Given a schema ℛ 𝑎, 𝑏, 𝑐, 𝑑, 𝑒, 𝑓 and the following FDs satisfied by the schema 𝑎𝑏𝑐 → 𝑒, 𝑑 → 𝑒𝑓, determine whether the following schema decompositions are lossless and or FD preserving 𝒂 𝒃 𝒄 𝒅 𝒆 𝒇 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 𝒂 𝒃 𝒄 𝒆 1 1 1 2 1 1 1 2 1 1 2 3 𝒅 𝒆 𝒇 1 2 1 2 2 1 3 3 3 ⋈ 𝒂 𝒃 𝒄 𝒅 𝒆 𝒇 1 1 1 1 2 1 1 1 1 2 2 1 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 ▪ ℛ1 𝑎, 𝑏, 𝑐, 𝑑, 𝑒 , ℛ2 𝑑, 𝑒, 𝑓 ▪ ℛ1 ∩ ℛ2 → ℛ1 ∨ ℛ2 ▪ Lossless and FD preserving! Question 20 – Relation Decomposition Given a schema ℛ 𝑎, 𝑏, 𝑐, 𝑑, 𝑒, 𝑓 and the following FDs satisfied by the schema 𝑎𝑏𝑐 → 𝑒, 𝑑 → 𝑒𝑓, determine whether the following schema decompositions are lossless and or FD preserving 𝒂 𝒃 𝒄 𝒅 𝒆 𝒇 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 𝒂 𝒃 𝒄 𝒅 𝒆 1 1 1 1 2 1 1 1 2 2 1 1 2 3 3 𝒅 𝒆 𝒇 1 2 1 2 2 1 3 3 3 ⋈ 𝒂 𝒃 𝒄 𝒅 𝒆 𝒇 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 ▪ ℛ1 𝑎, 𝑏, 𝑐, 𝑑 , ℛ2 𝑑, 𝑒, 𝑓 ▪ ℛ1 ∩ ℛ2 → ℛ1 ∨ ℛ2 ▪ 𝑎, 𝑏, 𝑐 in different relation from 𝑒 ▪ Lossless, but not FD preserving Question 21 – Relation Decomposition Given a schema ℛ 𝑎, 𝑏, 𝑐, 𝑑, 𝑒, 𝑓 and the following FDs satisfied by the schema 𝑎𝑏𝑐 → 𝑒, 𝑑 → 𝑒𝑓, determine whether the following schema decompositions are lossless and or FD preserving 𝒂 𝒃 𝒄 𝒅 𝒆 𝒇 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 𝒂 𝒃 𝒄 𝒅 1 1 1 1 1 1 1 2 1 1 2 3 𝒅 𝒆 𝒇 1 2 1 2 2 1 3 3 3 ⋈ 𝒂 𝒃 𝒄 𝒅 𝒆 𝒇 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 Question 22 All SQL queries look similar and encode functional dependencies. They contain: 1. GROUP BY 𝛼 2. COUNT (DISTINCT 𝛽) > 1 → How many different values of 𝛽 are there? An FD only allows 1! SELECT [LHS] FROM R GROUP BY [LHS] HAVING COUNT(DISTINCT [RHS]) > 1; Assume you are given a relational schema ℛ 𝐴, 𝐵, 𝐶, 𝐷, 𝐸, 𝐹 and the following functional dependencies: • 𝐴 → 𝐹 • 𝐵, 𝐹 → 𝐸 • 𝐸 → 𝐶, 𝐷 Decide which of the SQL queries should always return an empty result set. We need to find out whether β is within the closure of ⍺. → Use closure algorithm Question 22 SELECT B,F FROM R GROUP BY B,F HAVING COUNT(DISTINCT D) > 1; SELECT E FROM R GROUP BY E HAVING COUNT(DISTINCT C) > 1; Using the closure algorithm we find 𝐵𝐹 → 𝐸 → 𝐶𝐷 Hence 𝐵𝐹 → 𝐷 meaning the query is always empty. 𝐸 → 𝐶𝐷 meaning 𝐸 → 𝐶 Hence the query is always empty 𝐴 → 𝐹 𝐵, 𝐹 → 𝐸 𝐸 → 𝐶, 𝐷 Question 22 SELECT A FROM R GROUP BY A HAVING COUNT(F) > 1; SELECT B,F FROM R GROUP BY B,F HAVING COUNT(DISTINCT D) > 1; Seems tempting to use 𝐴 → 𝐹. However it is COUNT(F), not COUNT(DISTINCT F) . Thus all tuples with the same 𝐴 are counted, which may be > 1 𝐴 → 𝐹 𝐵, 𝐹 → 𝐸 𝐸 → 𝐶, 𝐷 𝐵𝐹 → 𝐸 → 𝐶, 𝐷 meaning 𝐵, 𝐹 → 𝐷. Hence the query is always empty ▪ How many tuples are returned by SELECT a,b FROM R? ▪ No DISTINCT keyword ▪ All tuples in 𝑅 are returned ▪ 400 tuples Question 23 - SQL Let 𝑅 be a relation instance of schema ℛ 𝑎, 𝑏, 𝑐, 𝑑 with 400 tuples and let 𝐹 = {𝑎 → 𝑏𝑐, 𝑐 → 𝑑}. Given is that 𝑅 ⊨ 𝐹 and that the following SQL query SELECT DISTINCT a FROM R returns 200 tuples. ▪ How many tuples are returned by SELECT DISTINCT a,b FROM R? ▪ 𝑎 → 𝑏 (Reflexivity) ▪ Each distinct 𝑎 has the same 𝑏 as per the FD ▪ 200 distinct values of 𝑎 ▪ 200 tuples Question 24 - SQL Let 𝑅 be a relation instance of schema ℛ 𝑎, 𝑏, 𝑐, 𝑑 with 400 tuples and let 𝐹 = {𝑎 → 𝑏𝑐, 𝑐 → 𝑑}. Given is that 𝑅 ⊨ 𝐹 and that the following SQL query SELECT DISTINCT a FROM R returns 200 tuples. ▪ How many tuples are returned by SELECT DISTINCT a,d FROM R? ▪ 𝑎 → 𝑐 (Reflexivity) ▪ 𝑎 → 𝑑 (Transitivity) ▪ Each distinct 𝑎 has the same 𝑑 as per the FD ▪ 200 distinct values of 𝑎 ▪ 200 tuples Question 25 - SQL Let 𝑅 be a relation instance of schema ℛ 𝑎, 𝑏, 𝑐, 𝑑 with 400 tuples and let 𝐹 = {𝑎 → 𝑏𝑐, 𝑐 → 𝑑}. Given is that 𝑅 ⊨ 𝐹 and that the following SQL query SELECT DISTINCT a FROM R returns 200 tuples. ▪ How many tuples are returned by SELECT DISTINCT c,d FROM R? ▪ 𝑎 → 𝑐 (Reflexivity) ▪ 𝑎 → 𝑑 (Transitivity) ▪ 200 distinct values of 𝑎 so at most 200 distinct values of 𝑐 and 𝑑 ▪ ≤200 tuples Question 26 - SQL Let 𝑅 be a relation instance of schema ℛ 𝑎, 𝑏, 𝑐, 𝑑 with 400 tuples and let 𝐹 = {𝑎 → 𝑏𝑐, 𝑐 → 𝑑}. Given is that 𝑅 ⊨ 𝐹 and that the following SQL query SELECT DISTINCT a FROM R returns 200 tuples. Functional dependencies are a stepping stone ▪ FD‘s are a rather small topic in DMDB ▪ FDs are still a core concept ▪ Exam usually mixes questions about FDs and normal forms. Thank → you.","libVersion":"0.5.0","langs":""}