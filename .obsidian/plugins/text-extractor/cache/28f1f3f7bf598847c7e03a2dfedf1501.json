{"path":"sem4/DMDB/UE/slides/DMDB-s06-functional-dependency.pdf","text":"Joris Belder Data Modelling & Databases jbelder@student.ethz.ch Exercise 6: Functional Dependencies Spring 25 â–ª We will go through the questions one by one â–ª Necessary background knowledge is explained before each question â–ª Please do ask if anything is unclear! Contents Functional Dependencies are a tool â–ª For analysing data redundancy â–ª For understanding good schema design Symptoms of data redundancy and bad schemas are â–ª Data duplication â–ª Extra business logic Data Redundancy Data anomalies are a symptom of bad schemas/data redundancy Question 1 â€“ Deletion Anomaly Deletion Anomaly: The unintended loss of data due to the deletion of other data Transaction ID Amount Remaining Balance 0 -200 1900 1 +300 2200 2 -400 1800 3 +200 2000 Removing all transactions removes all balance information as well (assuming it is not stored elsewhere). Transaction ID Amount Remaining Balance Person should still have 2100,- but this is not stored in the DB Question 2 â€“ Update Anomaly Update Anomaly: Data inconsistencies as a result of partial updates Transaction ID Amount Remaining Balance 0 -200 1900 1 +300 2200 2 -400 1800 3 +200 2000 Updating the Amount value in one row will cause inconsistencies in Remaining Balance Transaction ID Amount Remaining Balance 0 -200 1900 1 +200 2100 2 -400 1800 3 +200 2000 Question 3 â€“ Insertion Anomaly Insertion Anomaly: The inability to add data to the DB due to the absence of other data Transaction ID Amount Remaining Balance 0 -200 1900 1 +300 2200 2 -400 1800 3 +200 2000 The schema does not allow us to indicate the Remaining Balance without first having a transaction Transaction ID Amount Remaining Balance We cannot store that the person has 2100,- in their bank account So what is a Functional Dependency? ğ›¼ â†’ ğ›½ iff. âˆ€ğ‘Ÿ, ğ‘  âˆˆ ğ‘…: ğ‘Ÿ. ğ›¼ = ğ‘ . ğ›¼ â‡’ ğ‘Ÿ. ğ›½ = ğ‘ . ğ›½ a b 1 x 2 z 3 a â€¦ â€¦ a b Youâ€˜ve already seen functional dependencies with keys. A key determines the whole relation! How do I obtain Functional Dependencies? â–ª In general: Depends on what you model. Youâ€˜ll probably have an intuitive feeling in the exact application. â¢ For example, most entities have some form of identifier which uniquely determines the entity, such as a Student Id(entifier) for a Student â–ª Once you have them, you can use the Armstrongâ€™s Axioms to derive others â–ª A change in the Functional Dependencies, may require the schema to be redesigned Think well about all Functional Dependencies in your domain â–ª Consider the following relation instance Question 4 Student_Id Student_Address Lecture Teaching_Assistant 1234 RÃ¤mistrasse 72 DMDB Bob 1280 Rennweg 19 PProg Scott 1235 RÃ¤mistrasse 72 VisCom Sarah 1299 BÃ¶rsenstrasse 42 PProg Benjamin 1356 Klusplatz 45 QCom Benjamin â–ª Is it possible to formally deduce all functional dependencies? It is not. Deducing all functional dependencies requires knowledge of what the attributes represent. You need so-called domain knowledge. Which functional dependencies can be obtained from this ER diagram? Question 5 â€“ FDs from ER How to read this? â€¢ Choose a group of all but one entities â€¢ Look at the cardinality of the excluded entity â€¢ If the cardinality is 1, there is an FD â–ª Movie, Actor, Director â†’ Production â–ª Movie, Actor, Production â†’ Director Closure â€“ How far can we get with given attributes? â–ª You may know of a related concept called a â€transitive closureâ€œ from different courses like discrete mathematics. â–ª In DMDB: the closure tells you which attributes are determined, given some attribute(s) ğ›¼: â€¢ Which attributes are (indirectly) determined by ğ›¼ given a set of functional dependencies: ğ›¼+ = ğ‘¦ âˆˆ â„› ğ¹ âŠ¢ ğ›¼ â†’ ğ‘¦} â–ª Example: What is the closure of a key? â€¢ Answer: All attributes of the relation Closure algorithm â€“ Visual Intuition ğ‘ ğ‘ ğ‘ ğ‘‘ ğ‘’ ğ‘’ ğ‘ How to get the closure of ğ‘ given ğ‘ â†’ ğ‘ ğ‘ğ‘’ â†’ ğ‘‘ ğ‘’ğ‘ â†’ ğ‘‘ ğ‘ ğ‘ Iterate until no changeClosure so far: Only one iteration as thereâ€˜s no change anymore: ğ‘’ is not in the closure of ğ‘! Closure algorithm closure(set<attribute> a, set<FD> F): aâ€™ = a; do { a_old = aâ€™; foreach FD (b -> c) in F { if (b subsetOf aâ€™) { aâ€™ = aâ€™ union c; } } while (aâ€™ != a_old); return aâ€™; Question 6 - Closures â€¢ (6) ğ´ â†’ ğµ because of (1). â€¢ (7) ğ´ â†’ ğ¶ because of (1). â€¢ (8) ğ´ â†’ ğ¸ transitive property (6) and (3). â€¢ (9) ğ´ â†’ ğ¹ transitive property from (8) and (2). â€¢ (10) ğ´ â†’ ğº because of (5). â€¢ Therefore, ğ´+ = {ğ´, ğµ, ğ¶, ğ¸, ğ¹, ğº}. Given a relation ğ‘… ğ´, ğµ, ğ¶, ğ·, ğ¸, ğ¹, ğº and the following five FDs: 1. ğ´ â†’ ğµğ¶ 2. ğ¸ â†’ ğ¶ğ¹ 3. ğµ â†’ ğ¸ 4. ğ¶ğ· â†’ ğ¸ğ¹ 5. ğ´ â†’ ğº Select all attributes that constitute the closure of ğ´. Question 7 - Closures Select all attributes that constitute the closure of ğº. â€¢ ğº+ = {ğº}. Thereâ€˜s no ğº on the leftâ€¦ Given a relation ğ‘… ğ´, ğµ, ğ¶, ğ·, ğ¸, ğ¹, ğº with the following five FDs: 1. ğ´ â†’ ğµğ¶ 2. ğ¸ â†’ ğ¶ğ¹ 3. ğµ â†’ ğ¸ 4. ğ¶ğ· â†’ ğ¸ğ¹ 5. ğ´ â†’ ğº Keys - Again â–ª Lecture 2: â€Candidate Key: minimal set of fields that identify each tuple uniquelyâ€œ â–ª A key is now defined as a functional dependency which determines the whole relation: ğ›¼ âŠ† â„› is a candidate key iff â¢ ğ›¼ â†’. â„› Some subset of fields (must be minimal for a candidate key) Our relation ğ›¼ â†’ ğ›½ is minimal iff âˆ€ğ´ âˆˆ ğ›¼: (ğ›¼ âˆ’ ğ´ ) â†› ğ›½ This means: we cannot remove any attribute for candidate keys! Superkeys? â–ª Superkey = Candidate key + possibly other attributes â¢ formally, this is a superset of a candidate key â–ª Trivial Superkeys: â¢ Every (candidate) key â¢ The whole relation Question 8 â€“ Candidate vs. Superkeys Now consider the following relation ğ‘… ğ´, ğµ, ğ¶, ğ·, ğ¸, ğ¹, ğº and the following functional dependencies: ğµ â†’ ğ´ğ¹ ğ´ â†’ ğº ğ´ â†’ ğµ ğµ â†’ ğ¶ ğ´ğº â†’ ğµğ· ğ¹ â†’ ğ¸ ğ´ functionally determines the whole relation: Informal closure sketch: ğ´ â†’ ğµ, ğ´ â†’ ğº {ğ´, ğµ, ğº} ğµ â†’ ğ´ğ¹, ğµ â†’ ğ¶ {ğ´, ğµ, ğ¶, ğ¹, ğº} ğ´ğº â†’ ğµğ· {ğ´, ğµ, ğ¶, ğ·, ğ¹, ğº} ğ¹ â†’ ğ¸ {ğ´, ğµ, ğ¶, ğ·, ğ¸, ğ¹, ğº} â€¦ which is the whole relation! ğµ also functionally determines the whole relation. ğµ â†’ ğ´ğ¹, thus ğµ determines ğ´ and we know that ğ´ is a key. Question 8 â€“ Candidate vs. Superkeys Now consider the following relation ğ‘… ğ´, ğµ, ğ¶, ğ·, ğ¸, ğ¹, ğº and the following functional dependencies: ğµ â†’ ğ´ğ¹ ğ´ â†’ ğº ğ´ â†’ ğµ ğµ â†’ ğ¶ ğ´ğº â†’ ğµğ· ğ¹ â†’ ğ¸ Candidate keys are minimal! â€¦ but that isnâ€˜t minimal at all! â€¦ while superkeys are just a subset of a key. ğ´ğµğ¶ğ·ğ¸ğ¹ğº is the whole relation, so it trivially is a superkey Question 8 â€“ Candidate vs. Superkeys Now consider the following relation ğ‘… ğ´, ğµ, ğ¶, ğ·, ğ¸, ğ¹, ğº and the following functional dependencies: ğµ â†’ ğ´ğ¹ ğ´ â†’ ğº ğ´ â†’ ğµ ğµ â†’ ğ¶ ğ´ğº â†’ ğµğ· ğ¹ â†’ ğ¸ Noâ€¦ Both ğ´ and ğµ are candidate keys. ğ´ğµ is not minimal ğ´ is already a key, thus ğ´ğ¹ is a superset of a key ğ¸ is just on the right and doesnâ€˜t determine ğ‘…. Thus not a candidate key ğ´ğµ is superset of candidate keys ğ´ and ğµ and is thus a superkey Question 8 â€“ Candidate vs. Superkeys Now consider the following relation ğ‘… ğ´, ğµ, ğ¶, ğ·, ğ¸, ğ¹, ğº and the following functional dependencies: ğµ â†’ ğ´ğ¹ ğ´ â†’ ğº ğ´ â†’ ğµ ğµ â†’ ğ¶ ğ´ğº â†’ ğµğ· ğ¹ â†’ ğ¸ Question 9 Now consider the following relation ğ‘… ğ´, ğµ, ğ¶, ğ·, ğ¸, ğ¹, ğº and the following functional dependencies: ğµ â†’ ğ´ğ¹ ğ´ â†’ ğº ğ´ â†’ ğµ ğµ â†’ ğ¶ ğ´ğº â†’ ğµğ· ğ¹ â†’ ğ¸ 1. ğ´ â†’ ğµ â†’ ğ´ğ¹ ğ¹ âˆˆ ğ´ + 2. Removing ğ¹ â†’ ğ¸ Results in ğ¸ âˆ‰ ğ´ + Thus ğ´ would not be a key 3. ğ¹ â†’ ğ¸ 4. ğ´ â†’ ğº ğ´ â†’ ğ´ğº â†’ ğµğ· ğ´ â†’ ğµ Armstrongâ€™s Axioms â–ª Reflexivity â¢ ğ‘ â†’ ğ‘ğ‘, implies that ğ‘ â†’ ğ‘ and ğ‘ â†’ ğ‘ â–ª Augmentation â¢ ğ‘ â†’ ğ‘, implies that ğ‘ğ‘ â†’ ğ‘ğ‘ â–ª Transitivity â¢ ğ‘ â†’ ğ‘ and ğ‘ â†’ ğ‘, implies that ğ‘ â†’ ğ‘ They are Complete and Sound (ğ¹ âŠ¨ ğ›¼ â†’ ğ›½ â‡” ğ¹ âŠ¢ ğ›¼ â†’ ğ›½) Question 10 â€“ Armstrongâ€™s Axioms Given ğ‘ â†’ ğ‘, ğ‘ğ‘ â†’ ğ‘ and ğ‘ğ‘ â†’ ğ‘‘, show that ğ‘ â†’ ğ‘‘ ğ‘ â†’ ğ‘ ğ‘ â†’ ğ‘ğ‘ (Augmentation) ğ‘ â†’ ğ‘ (Transitivity) ğ‘ â†’ ğ‘ğ‘ (Augmentation) ğ‘ â†’ ğ‘‘ (Transitivity) Question 11 â€“ Armstrongâ€™s Axioms Given that ğ‘ is the primary key in some schema â„› ğ‘, ğ‘, â€¦ , show â„› âˆ– {ğ‘} â†’ ğ‘ ğ‘ â†’ â„› (From ğ‘ being the primary key) ğ‘ âˆª â„› âˆ– {ğ‘} â†’ â„› âˆª â„› âˆ– {ğ‘} (Augmentation) â„› âˆ– {ğ‘} â†’ â„› â„› âˆ– {ğ‘} â†’ ğ‘ (Reflexivity) â–ª We aim to construct a relation ğ‘… for which ğ¹ âŠ¨ ğ›¼ â†’ ğ›½ holds, but ğ›¼ â†’ ğ›½ does not, given ğ›½ âŠˆ ğ›¼+ â–ª Step 1: Prove that ğ‘… does not satisfy ğ›¼ â†’ ğ›½ â¢ Make sure that for the same value of ğ›¼, ğ›½ has different values in ğ‘… â–ª Step 2: Prove that ğ‘… satisfies ğ¹ â¢ For some ğ›¾ â†’ ğœƒ âˆˆ ğ¹. If ğ›¾ âŠ† ğ›¼+, then ğ¹ âŠ¢ ğ›¼ â†’ ğ›¾ â†’ ğœƒ. Which follows from ğ¹ âŠ¢ ğ›¼ â†’ ğ›½ â‡” ğ›½ âŠ† ğ›¼+ and transitivity. Thus ğœƒ âŠ† ğ›¼+ and ğ‘… âŠ¨ ğ›¾ â†’ ğœƒ. â¢ If ğ›¾ âŠˆ ğ›¼+, then ğ›¾ must take different values in ğ‘…, such that ğ‘… âŠ¨ ğ›¾ â†’ ğœƒ nonetheless. Armstrongâ€™s Axioms Completeness ProofQuestion 12 â€“ Armstrongâ€™s Axioms Completeness To prove the completeness of Armstrongâ€™s Axioms (ğ¹ âŠ¨ ğ›¼ â†’ ğ›½ â‡’ ğ¹ âŠ¢ ğ›¼ â†’ ğ›½), a counterexample was shown in the lecture. Given some subset of attributes ğœ‡ âŠ‚ â„› âˆ– ğ›¼+ and ğ›¿ âŠ‚ ğ›¼+, is the following relation instance a valid counterexample as well? â–ª The counterexample requires â„› âˆ– Î±+ to have different values for the same ğ›¼+ such that ğ›¼ â†’ ğ›½ does not hold for step 1 â–ª The counterexample requires that for some ğ›¾ âŠˆ ğ›¼+, ğ›¾ takes different values in the relation instance for step 2 â–ª These properties are maintained by the relation instance and thus it is a valid counterexample ğœ¶+ ğ“¡ âˆ– (ğœ¶+ âˆª ğ) Î¼ 111 â€¦ 111 000 â€¦ 000 111 â€¦ 111 111 â€¦ 111 111 â€¦ 111 000 â€¦ 000 Question 13 â€“ Armstrongâ€™s Axioms Completeness To prove the completeness of Armstrongâ€™s Axioms (ğ¹ âŠ¨ ğ›¼ â†’ ğ›½ â‡’ ğ¹ âŠ¢ ğ›¼ â†’ ğ›½), a counterexample was shown in the lecture. Given some subset of attributes ğœ‡ âŠ‚ â„› âˆ– ğ›¼+ and ğ›¿ âŠ‚ ğ›¼+, is the following relation instance a valid counterexample as well? â–ª The counterexample requires â„› âˆ– Î±+ to have different values for the same ğ›¼+ such that ğ›¼ â†’ ğ›½ does not hold for step 1 â–ª The counterexample requires that for some ğ›¾ âŠˆ ğ›¼+, ğ›¾ takes different values in the relation instance for step 2 â–ª The first property is not maintained as both values of ğ›¼+ are different, thus ğ›¼ â†’ ğ›½ is satisfied ğœ¶+ âˆ– ğœ¹ ğ“¡ âˆ– ğœ¶+ ğœ¹ 111 â€¦ 111 000 â€¦ 000 111 â€¦ 111 111 â€¦ 111 111 â€¦ 111 000 â€¦ 000 Minimal basis/cover â–ª Set of FDs which is â€as small as it getsâ€œ: â–ª Suppose you are given a set of FDs ğ¹. â–ª Idea: Simplify ğ¹ as much as possible while still remaining equivalent to ğ¹. â†’A minimal basis must be equivalent to ğ¹ â†’A minimal basis cannot be made smaller by deleting an FD or deleting an attribute from the left-hand side â†’You mostly use your intuition and some Armstrongâ€™s Axioms to calculate the minimal basis â†’Somewhat tricky to get right and requires paperwork. Question 14: Computing the minimal basisThere are multiple ways to get to the minimal basis/cover â–ª There are cases where the minimal basis is not unique â–ª The algorithm given in the lecture allows you to have freedom and may even lead to different solutions. â–ª It might help coming up with the reductions â€“ especially transitivity - of the minimal basis by visually drawing the closure. ğ‘ ğ‘ ğ‘ ğ‘‘ ğ‘’ ğ‘’ Question 16 â€“ Minimal Basis Exercise 15 guides you through it step by step. Only FD (1) is split, also, we remove duplicate ğ´ â†’ ğµ There are no trivial FDs Question 16 â€“ Minimal Basis We check if we can simplify ğ´ğµ â†’ ğ¶. Turns out we can remove both ğ´ and ğµ ğ´ â†’ ğµ is duplicated and ğ´ â†’ ğ¶ is implied by transitivity Question 17 â€“ Minimal BasisQuestion 17 â€“ Minimal Basis ğ¶ â†’ ğ´ already determines ğ´, thus: simplify ğ´ğ¶ğ· â†’ ğµ to ğ¶ğ· â†’ ğµ ğ¶ â†’ ğ´ already. ğ¸ can be removed Step 3: is one attribute in LHS in the closure of the others? Question 17 â€“ Minimal Basis Duplicates Start with ğ¶ğ· ğ· â†’ ğ¸ ğ¶ğ¸ â†’ ğ¹ ğ¶ğ¹ â†’ ğµ Start with ğ¶ğ¹ ğ¶ğ¹ â†’ ğµ ğµğ¶ â†’ ğ· Step 4: Is RHS in closure of LHS when excluding the chosen FD? Question 17 â€“ Minimal Basis It may be non-trivial to see that this is in fact a minimal basis. Check if you can remove any argument. If you want to practice more with computing the Minimal Basis, you can make use of this website.Decomposition of Relations â–ª Weâ€˜d like to have a good DB design â†’ Thus, we might want to decompose relations to not suffer from redundancy â–ª It should remain sound! â–ª Bad relations combine several concepts â¢ Thus: decompose them so that each concept in one relation â¢ ğ‘… â‡ ğ‘…1 â€¦ ğ‘…ğ‘› â–ª Def: Lossless Decomposition â¢ ğ‘… = ğ‘…1 â‹ˆ ğ‘…2 â€¦ â‹ˆ ğ‘…ğ‘› â–ª Preservation of Dependencies â¢ ğ¹ğ· ğ‘… + = ğ¹ğ· ğ‘…1 âˆª â‹¯ âˆª ğ¹ğ· ğ‘…ğ‘› + Decomposition Lemma â–ª When is a decomposition lossless? â–ª Let â„› = â„›1 âˆª â„›2 â–ª Consider the decomposition of ğ‘…: â¢ ğ‘…1 = Î â„›1(ğ‘…) â¢ ğ‘…2 = Î â„›2(ğ‘…) â–ª This decomposition is lossless (i.e., ğ‘… = ğ‘…1 â‹ˆ ğ‘…2), if â¢ (â„›1âˆ© â„›2) â†’ â„›1 OR â¢ (â„›1âˆ© â„›2) â†’ â„›2 â–ª â„›1 ğ‘, ğ‘, ğ‘ , â„›2 ğ‘‘, ğ‘’, ğ‘“ â–ª No way to join the schemas â–ª ğ‘, ğ‘, ğ‘ in different relation from ğ‘’ â–ª Not lossless and not FD preserving Question 18 â€“ Relation Decomposition Given a schema â„› ğ‘, ğ‘, ğ‘, ğ‘‘, ğ‘’, ğ‘“ and the following FDs satisfied by the schema ğ‘ğ‘ğ‘ â†’ ğ‘’, ğ‘‘ â†’ ğ‘’ğ‘“, determine whether the following schema decompositions are lossless and or FD preserving ğ’‚ ğ’ƒ ğ’„ ğ’… ğ’† ğ’‡ 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 ğ’‚ ğ’ƒ ğ’„ 1 1 1 1 1 1 1 1 2 ğ’… ğ’† ğ’‡ 1 2 1 2 2 1 3 3 3 â‹ˆ â–ª â„›1 ğ‘, ğ‘, ğ‘, ğ‘’ , â„›2 ğ‘‘, ğ‘’, ğ‘“ â–ª â„›1 âˆ© â„›2 â†› â„›1 âˆ¨ â„›2 â–ª Joining the schemas leads to more rows than before â–ª Not lossless, but FD preserving Question 19 â€“ Relation Decomposition Given a schema â„› ğ‘, ğ‘, ğ‘, ğ‘‘, ğ‘’, ğ‘“ and the following FDs satisfied by the schema ğ‘ğ‘ğ‘ â†’ ğ‘’, ğ‘‘ â†’ ğ‘’ğ‘“, determine whether the following schema decompositions are lossless and or FD preserving ğ’‚ ğ’ƒ ğ’„ ğ’… ğ’† ğ’‡ 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 ğ’‚ ğ’ƒ ğ’„ ğ’† 1 1 1 2 1 1 1 2 1 1 2 3 ğ’… ğ’† ğ’‡ 1 2 1 2 2 1 3 3 3 â‹ˆ ğ’‚ ğ’ƒ ğ’„ ğ’… ğ’† ğ’‡ 1 1 1 1 2 1 1 1 1 2 2 1 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 â–ª â„›1 ğ‘, ğ‘, ğ‘, ğ‘‘, ğ‘’ , â„›2 ğ‘‘, ğ‘’, ğ‘“ â–ª â„›1 âˆ© â„›2 â†’ â„›1 âˆ¨ â„›2 â–ª Lossless and FD preserving! Question 20 â€“ Relation Decomposition Given a schema â„› ğ‘, ğ‘, ğ‘, ğ‘‘, ğ‘’, ğ‘“ and the following FDs satisfied by the schema ğ‘ğ‘ğ‘ â†’ ğ‘’, ğ‘‘ â†’ ğ‘’ğ‘“, determine whether the following schema decompositions are lossless and or FD preserving ğ’‚ ğ’ƒ ğ’„ ğ’… ğ’† ğ’‡ 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 ğ’‚ ğ’ƒ ğ’„ ğ’… ğ’† 1 1 1 1 2 1 1 1 2 2 1 1 2 3 3 ğ’… ğ’† ğ’‡ 1 2 1 2 2 1 3 3 3 â‹ˆ ğ’‚ ğ’ƒ ğ’„ ğ’… ğ’† ğ’‡ 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 â–ª â„›1 ğ‘, ğ‘, ğ‘, ğ‘‘ , â„›2 ğ‘‘, ğ‘’, ğ‘“ â–ª â„›1 âˆ© â„›2 â†’ â„›1 âˆ¨ â„›2 â–ª ğ‘, ğ‘, ğ‘ in different relation from ğ‘’ â–ª Lossless, but not FD preserving Question 21 â€“ Relation Decomposition Given a schema â„› ğ‘, ğ‘, ğ‘, ğ‘‘, ğ‘’, ğ‘“ and the following FDs satisfied by the schema ğ‘ğ‘ğ‘ â†’ ğ‘’, ğ‘‘ â†’ ğ‘’ğ‘“, determine whether the following schema decompositions are lossless and or FD preserving ğ’‚ ğ’ƒ ğ’„ ğ’… ğ’† ğ’‡ 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 ğ’‚ ğ’ƒ ğ’„ ğ’… 1 1 1 1 1 1 1 2 1 1 2 3 ğ’… ğ’† ğ’‡ 1 2 1 2 2 1 3 3 3 â‹ˆ ğ’‚ ğ’ƒ ğ’„ ğ’… ğ’† ğ’‡ 1 1 1 1 2 1 1 1 1 2 2 1 1 1 2 3 3 3 Question 22 All SQL queries look similar and encode functional dependencies. They contain: 1. GROUP BY ğ›¼ 2. COUNT (DISTINCT ğ›½) > 1 â†’ How many different values of ğ›½ are there? An FD only allows 1! SELECT [LHS] FROM R GROUP BY [LHS] HAVING COUNT(DISTINCT [RHS]) > 1; Assume you are given a relational schema â„› ğ´, ğµ, ğ¶, ğ·, ğ¸, ğ¹ and the following functional dependencies: â€¢ ğ´ â†’ ğ¹ â€¢ ğµ, ğ¹ â†’ ğ¸ â€¢ ğ¸ â†’ ğ¶, ğ· Decide which of the SQL queries should always return an empty result set. We need to find out whether Î² is within the closure of âº. â†’ Use closure algorithm Question 22 SELECT B,F FROM R GROUP BY B,F HAVING COUNT(DISTINCT D) > 1; SELECT E FROM R GROUP BY E HAVING COUNT(DISTINCT C) > 1; Using the closure algorithm we find ğµğ¹ â†’ ğ¸ â†’ ğ¶ğ· Hence ğµğ¹ â†’ ğ· meaning the query is always empty. ğ¸ â†’ ğ¶ğ· meaning ğ¸ â†’ ğ¶ Hence the query is always empty ğ´ â†’ ğ¹ ğµ, ğ¹ â†’ ğ¸ ğ¸ â†’ ğ¶, ğ· Question 22 SELECT A FROM R GROUP BY A HAVING COUNT(F) > 1; SELECT B,F FROM R GROUP BY B,F HAVING COUNT(DISTINCT D) > 1; Seems tempting to use ğ´ â†’ ğ¹. However it is COUNT(F), not COUNT(DISTINCT F) . Thus all tuples with the same ğ´ are counted, which may be > 1 ğ´ â†’ ğ¹ ğµ, ğ¹ â†’ ğ¸ ğ¸ â†’ ğ¶, ğ· ğµğ¹ â†’ ğ¸ â†’ ğ¶, ğ· meaning ğµ, ğ¹ â†’ ğ·. Hence the query is always empty â–ª How many tuples are returned by SELECT a,b FROM R? â–ª No DISTINCT keyword â–ª All tuples in ğ‘… are returned â–ª 400 tuples Question 23 - SQL Let ğ‘… be a relation instance of schema â„› ğ‘, ğ‘, ğ‘, ğ‘‘ with 400 tuples and let ğ¹ = {ğ‘ â†’ ğ‘ğ‘, ğ‘ â†’ ğ‘‘}. Given is that ğ‘… âŠ¨ ğ¹ and that the following SQL query SELECT DISTINCT a FROM R returns 200 tuples. â–ª How many tuples are returned by SELECT DISTINCT a,b FROM R? â–ª ğ‘ â†’ ğ‘ (Reflexivity) â–ª Each distinct ğ‘ has the same ğ‘ as per the FD â–ª 200 distinct values of ğ‘ â–ª 200 tuples Question 24 - SQL Let ğ‘… be a relation instance of schema â„› ğ‘, ğ‘, ğ‘, ğ‘‘ with 400 tuples and let ğ¹ = {ğ‘ â†’ ğ‘ğ‘, ğ‘ â†’ ğ‘‘}. Given is that ğ‘… âŠ¨ ğ¹ and that the following SQL query SELECT DISTINCT a FROM R returns 200 tuples. â–ª How many tuples are returned by SELECT DISTINCT a,d FROM R? â–ª ğ‘ â†’ ğ‘ (Reflexivity) â–ª ğ‘ â†’ ğ‘‘ (Transitivity) â–ª Each distinct ğ‘ has the same ğ‘‘ as per the FD â–ª 200 distinct values of ğ‘ â–ª 200 tuples Question 25 - SQL Let ğ‘… be a relation instance of schema â„› ğ‘, ğ‘, ğ‘, ğ‘‘ with 400 tuples and let ğ¹ = {ğ‘ â†’ ğ‘ğ‘, ğ‘ â†’ ğ‘‘}. Given is that ğ‘… âŠ¨ ğ¹ and that the following SQL query SELECT DISTINCT a FROM R returns 200 tuples. â–ª How many tuples are returned by SELECT DISTINCT c,d FROM R? â–ª ğ‘ â†’ ğ‘ (Reflexivity) â–ª ğ‘ â†’ ğ‘‘ (Transitivity) â–ª 200 distinct values of ğ‘ so at most 200 distinct values of ğ‘ and ğ‘‘ â–ª â‰¤200 tuples Question 26 - SQL Let ğ‘… be a relation instance of schema â„› ğ‘, ğ‘, ğ‘, ğ‘‘ with 400 tuples and let ğ¹ = {ğ‘ â†’ ğ‘ğ‘, ğ‘ â†’ ğ‘‘}. Given is that ğ‘… âŠ¨ ğ¹ and that the following SQL query SELECT DISTINCT a FROM R returns 200 tuples. Functional dependencies are a stepping stone â–ª FDâ€˜s are a rather small topic in DMDB â–ª FDs are still a core concept â–ª Exam usually mixes questions about FDs and normal forms. Thank â†’ you.","libVersion":"0.5.0","langs":""}