{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s02b-lists.pdf","text":"Lists and Abstraction David Basin Department of Computer Science ETH Z¨urich Functional Programming David Basin 1 List type • Types we have seen \u0011 Base types: Int, Char, Bool, Double, . . . \u0011 Type constructors: (T1, . . . , Tk) • List types, a new type constructor If T is a type, then [T ] is a type • Elements of [T ] \u0011 Empty list [ ] :: [T ] \u0011 Non-empty list (x : xs) :: [T ], if x :: T and xs :: [T ]. • Short hand: 1 : (2 : (3 : [ ])) written as [1, 2, 3] Functional Programming Spring Semester, 2025 David Basin 2 Examples and notation ? [’a’,’a’,’b’] :: [Char] \"aab\" :: [Char] ? [’a’,’a’,’b’] == \"aab\" True Haskell supports various abbreviations ? [3..6] [3, 4, 5, 6] :: [Int] ? [6..3] [] :: [Int] [n, p..m] means count from n to m in steps of p − n ? [7,6..3] [7, 6, 5, 4, 3] :: [Int] ? [0.0, 0.3 .. 1.0] [0.0,0.3,0.6,0.8999999999999999] :: [Double] Functional Programming Spring Semester, 2025 David Basin 3 Functions on lists — sumList • Function sumList :: [Int] -> Int must specify: \u0011 how to compute with the empty list [ ] \u0011 how to compute with the non-empty list (x : xs) • Computation Empty list [ ] ↦→ 0 Non-empty list (x : xs) ↦→ x + sum of list xs sumList [] = 0 sumList (x:xs) = x + sumList xs ? sumList [1..100] -- 100 * 101 / 2 5050 :: Int Functional Programming Spring Semester, 2025 David Basin 4 Standard functions on lists • length length [] = 0 length (x:xs) = 1 + length xs • append (not only for strings!) [] ++ ys = ys (x:xs) ++ ys = x:(xs++ys) N.B.: (++) and (:) have different types! ? [2] ++ [3,4,5] == [2,3,4,5] True ? 2 : [3,4,5] == [2,3,4,5] True ? [2] : [3,4,5] ... Error ... Functional Programming Spring Semester, 2025 David Basin 5 Patterns (lists and in general) • Pattern matching has two purposes \u0011 checks if an argument has the proper form \u0011 binds values to variables • Example: (x : xs) matches with [2, 3, 4] (= 2 : 3 : 4 : [] = 2 : [3, 4]) x = 2 xs = [3, 4] • Another example (pattern matching during let-binding) ? let ([x,y,z],t) = ([1,2,3],(20,30)) in x + y 3 :: Int ? let ([x,y,z],t) = ([1,2,3,4],(20,30)) in x + y Pattern match fails... Functional Programming Spring Semester, 2025 David Basin 6 Patterns — details • Patterns are inductively defined (additional cases later) Constants: −2, ′1 ′, True, [ ] Variables: x, foo Wild card: Tuples: (p1, p2, . . . , pk), where pi are patterns Non-empty lists: (p1 : p2), where pi are patterns • Moreover, patterns required to be linear. This means that each variable can occur at most once. • Examples: [(x, foo), ] ((x, y), ) 1 : (2 : (x, y)) • Counterexamples: (x ++ y, z) and [x, y, z, x] Functional Programming Spring Semester, 2025 David Basin 7 Pattern matching • Define pattern p matches term a by recursion on p. Constant p = c: succeeds if c = a Variable p = x: succeeds and with binding x = a Wild card p = : succeeds but with no binding Tuple p = (p1, . . . , pk): succeeds if a = (a1, . . . , ak) and pi matches ai, for i ∈ {1, . . . , k} Non-empty list p = (p1 : p2): succeeds if a is a nonempty list a1 : a2 and p1 matches a1 and p2 matches a2 • Successful or not? Binding? \u0011 ([x], y) matches ([1], 2 + 3)? \u0011 [x] matches [1, 2]? [x, y] matches [1]? \u0011 x : y matches [1, 2]? x : (y : z) matches [1, 2]? \u0011 [x, x] matches [1, 1]? [x, 1 + 1] matches [1, 2]? Functional Programming Spring Semester, 2025 David Basin 8 Examples • Zipper function zip [2, 3, 4] [4, 5, 78] = [(2, 4), (3, 5), (4, 78)] zip [2, 3] [1, 2, 3] = [(2, 1), (3, 2)] N.B.: extra elements in a longer list are discarded. • Implementing zip zip (x:xs) (y:ys) = (x,y) : zip xs ys zip _ _ = [] • Which functions are implemented here? f (False, False) = False g (True, _ ) = True f (_, _ ) = True g (_, True) = True g (_, _ ) = False Functional Programming Spring Semester, 2025 David Basin 9 Intermezzo — advice on recursion “Defining recursive functions is like riding a bicycle: it looks easy when someone else is doing it; it may seem impossible when you first try to do it yourself, but becomes simple and natural with practice.” — G. Hutton, Programming in Haskell Define function drop removes the first n elements of a list. Step 1: Define the type: drop :: Int -> [Int] -> [Int] Step 2: Enumerate the cases: drop 0 [] = ... drop 0 (x:xs) = ... drop n [] = ... drop n (x:xs) = ... Step 3: Define the simple cases: drop 0 [] = [] drop 0 (x:xs) = x:xs drop n [] = [] Step 4: Define the other cases: drop n (x:xs) = drop (n-1) xs Step 5: Generalize and simplify. Suggestions? Functional Programming Spring Semester, 2025 David Basin 10 Example: insertion sort Insertion sort: [7, 3, 9, 2] • First sort rest: [2, 3, 9] • Insert head: [2, 3, 7,9] isort :: [Int] -> [Int] isort [3,9,2] isort [] = [] = ins 3 (isort [9,2]) isort (x:xs) = ins x (isort xs) = ins 3 (ins 9 (isort [2])) = ins 3 (ins 9 (ins 2 (isort []))) ins :: Int -> [Int] -> [Int] = ins 3 (ins 9 (ins 2 [])) ins a [] = [a] = ins 3 (ins 9 [2]) ins a (x:xs) = ins 3 (2 : (ins 9 [])) | a <= x = a : (x : xs) = 2 : (ins 3 (ins 9 [])) | otherwise = x : ins a xs = 2 : (ins 3 [9]) = 2 : 3 : [9] = [2,3,9] -- next evaluation step -- evaluation of argument needed Functional Programming Spring Semester, 2025 David Basin 11 Insertion sort — complexity • Processing list [x1, . . . , xn] of size n results in ins x1 (ins x2 (. . . (ins xn [ ]) . . . )) • Complexity of computing ins a [x1, x2, . . . , xn] Best case: a ≤ x1: 1 step Worst case: a > xn: n steps Average: n/2 steps (assuming all input sequences equally likely) • Complexity of insertion sort: Best case: n steps, i.e., O(n) Worst case: 1 + 2 + · · · + n = n(n + 1)/2, i.e., O(n2) Average: 1/2 + 2/2 + · · · + (n − 1)/2 + n/2, also O(n2) Functional Programming Spring Semester, 2025 David Basin 12 Quick sort • Quick sort: [7, 3, 8, 2, 9] \u0011 Split into head and tail: 7 and [3, 8, 2, 9] \u0011 Partition tail into parts ≤ 7 and > 7: [3, 2] and [8, 9] \u0011 Recursively sort parts: [2, 3] and [8, 9] \u0011 Concatenate with head in the middle: [2, 3] ++ [7] ++ [8, 9] = [2, 3, 7, 8, 9] qsort [] = [] qsort (x:xs) = qsort (lesseq x xs) ++ [x] ++ qsort (greater x xs) where lesseq _ [] = [] lesseq x (y:ys) | (y <= x) = y : lesseq x ys | otherwise = lesseq x ys greater _ [] = [] greater x (y:ys) | (y > x) = y : greater x ys | otherwise = greater x ys • Complexity: O(n log n) on average. Worst case? Functional Programming Spring Semester, 2025 David Basin 13 List comprehension • Notation for sequential processing of list elements \u0011 Analogous to set comprehension in set theory {2 · x | x ∈ X} \u0011 Haskell notation: [2*x | x <- xs] ? [2*x | x <- [1,2,3,4,5]] [2, 4, 6, 8, 10] ? [n ‘mod‘ 2 == 0 | n <- [2,4,7]] [True,True,False] • Can be augmented with guards: [2*x | x <- xs, pred1(x), ...] ? [2*x | x <- [0,1,2,3,4,5,6], x ‘mod‘ 2 == 0, x > 3] [8, 12] • What is computed here? q [] = [] q (p:xs) = q [x | x<-xs, x <= p] ++ [p] ++ q [x | x<-xs, x > p] Functional Programming Spring Semester, 2025 David Basin 14 Program development with list comprehension A larger example • Objective: a (mini-)library database • A design method for programs “in the small” 1. Specify the requirements 2. Fix the types (input/output representation) 3. Implement each function • For systems “in the large”, design is substantially more difficult Topic for software engineering courses Functional Programming Spring Semester, 2025 David Basin 15 Step 1: requirements analysis Which functionality is required? 1. Given a person p, which books has p borrowed? 2. Given a book b, who has borrowed b? Assumption: many-to-many relation between (copies of) books and persons 3. Is a book lent out? Functional Programming Spring Semester, 2025 David Basin 16 Step 2: types • We define two types to represent books and people type Person = String -- Note that types always start with type Book = String -- a capital letter • Database: list of (Person, Book)-pairs type Database = [(Person,Book)] • Example myDB = [(\"Alice\", \"Postman Pat\"), (\"Anna\", \"All Alone\"), (\"Alice\", \"Spot\"), (\"Rory\", \"Postman Pat\")] Functional Programming Spring Semester, 2025 David Basin 17 Types (cont.) • Each kind of functionality implemented by a separate function 1. Which books has person p borrowed? books :: Database -> Person -> [Book] 2. Who has borrowed book b? borrowers :: Database -> Book -> [Person] 3. Is a book b on loan? borrowed :: Database -> Book -> Bool • Further functionality could also be specified E.g., checking out or returning a book Functional Programming Spring Semester, 2025 David Basin 18 Step 3: implementation • books:: Database -> Person -> [Book] books db p = [bk | (per,bk) <- db, per == p] • borrowers :: Database -> Book -> [Person] borrowers db b = [per | (per,bk) <- db, bk == b] • borrowed :: Database -> Book -> Bool borrowed db b = borrowers db b /= [] Functional Programming Spring Semester, 2025 David Basin 19 Complete program and examples type Person = String type Book = String type Database = [(Person,Book)] myDB = [(\"Alice\", \"Postman Pat\"), (\"Anna\", \"All Alone\"), (\"Alice\", \"Spot\"), (\"Rory\", \"Postman Pat\")] books db p = [bk | (per,bk) <- db, per == p] borrowers db b = [per | (per,bk) <- db, bk == b] borrowed db b = borrowers db b /= [] ? books myDB \"Alice\" [\"Postman Pat\", \"Spot\"] ? borrowers myDB \"All Alone\" [\"Anna\"] ? borrowed myDB \"Postman Pat\" True Functional Programming Spring Semester, 2025 David Basin 20 Correctness — Induction Functional Programming Spring Semester, 2025 David Basin 21 Review: induction over natural numbers • Rule for induction over N . Proof by induction: to prove P for all natural numbers n. Base case: prove P [n ↦→ 0] Step case: prove ∀m ∈ N . P [n ↦→ m] → P [n ↦→ m + 1] i.e., Fix an arbitrary m (not free in P ) Induction hypothesis: P [n ↦→ m] To prove: P [n ↦→ m + 1] • Once proven, we know, for example, P [n ↦→ 17] since \u0011 P [n ↦→ 0] holds, and \u0011 P [n ↦→ 0] → P [n ↦→ 1] . . . and. . . P [n ↦→ 16] → P [n ↦→ 17] \u0011 since all n ∈ N are reachable in finitely many steps, we know that P holds, for every n ∈ N . • Reflects that N is the least set such that 0 ∈ N and if n ∈ N , then so is n + 1 ∈ N . Functional Programming Spring Semester, 2025 David Basin 22 Induction over lists • How are elements in [T ] constructed? [ ] :: [T ] and (y : ys) :: [T ], if y :: T and ys :: [T ] • Corresponds to following rule Proof by induction: to prove P for all xs in [T ] Base case: prove P [xs ↦→ [ ]] Step case: prove ∀y :: T, ys :: [T ]. P [xs ↦→ ys] → P [xs ↦→ y : ys], i.e., Fix arbitrary y :: T and ys :: [T ] (both not free in P ) Induction hypothesis: P [xs ↦→ ys] To prove: P [xs ↦→ y : ys] • Like with numbers: induction can be seen as a “machine” that establishes a property for all lists. E.g., P [xs ↦→ [3, 20]] follows since P [xs ↦→ []] → P [xs ↦→ 20 : []] → P [xs ↦→ 3 : 20 : []]. Functional Programming Spring Semester, 2025 David Basin 23 Example 1: sum and double sumList [] = 0 double [] = [] sumList (x:xs) = x + sumList xs double (x:xs) = (2*x) : double xs Proof by induction: P ≡ sumList (double xs) = 2 · sumList xs Base case: P [xs ↦→ []] sumList (double [ ]) = sumList [ ] = 0 2 · sumList [ ] = 2 · 0 = 0 Step case: ∀y, ys. P [xs ↦→ ys] → P [xs ↦→ y : ys] Fix arbitrary y :: Int and ys :: [Int] (they are not free in P ). Induction hypothesis: sumList (double ys) = 2 · sumList ys To prove: sumList (double (y : ys)) = 2 · sumList (y : ys) sumList (double (y : ys)) = sumList ((2 · y) : double ys) = 2 · y + sumList (double ys) = 2 · y + 2 · sumList ys = 2 · (y + sumList ys) = 2 · sumList (y : ys)Functional Programming Spring Semester, 2025 David Basin 24 Example 2: associativity of append [] ++ ys = ys (x:xs) ++ ys = x : (xs ++ ys) Proof by induction: on xs Q ≡ (xs ++ ys) ++ zs = xs ++ (ys ++ zs) Base case: ([ ] ++ ys) ++ zs = ys ++ zs = [ ] ++ (ys ++ zs) Step case: Fix arbitrary a and as Induction hypothesis: (as ++ ys) ++ zs = as ++ (ys ++ zs) To prove: ((a : as) ++ ys) ++ zs = (a : as) ++ (ys ++ zs) ((a : as) ++ ys) ++ zs = (a : (as ++ ys)) ++ zs = a : ((as ++ ys) ++ zs) = a : (as ++ (ys ++ zs)) = (a : as) ++ (ys ++ zs) Functional Programming Spring Semester, 2025 David Basin 25 Induction: difficulties • How do we select an induction variable? P ≡ sumList (double xs) = 2 · sumList xs Q ≡ (xs ++ ys) ++ zs = xs ++ (ys ++ zs) \u0011 Induction on ys or zs fails. \u0011 E.g., induction on zs, requires in step case Q[zs ↦→ a : as] (xs ++ ys) ++ (a : as) = xs ++ (ys ++ (a : as)) Not possible either to further simplify or to use Q[zs ↦→ as]. • Requires planning in order to use the induction hypothesis • Auxiliary lemmas are sometimes also needed. Functional Programming Spring Semester, 2025 David Basin 26 Example 3: rev and qrev rev [] = [] qrev xs = aux (xs, []) rev (x:xs) = rev xs ++ [x] aux ([], ys) = ys aux (x:xs, ys) = aux (xs, x:ys) • Append is O(n) in first argument [a1, a2, . . . , an] ++ xs = a1 : ([a2, . . . , an] ++ xs) = . . . n − 1 times . . . = a1 : (a2 : . . . : (an : xs) . . . ) • rev is O(n2) (average append: n/2 steps) rev [a1, a2, . . . , an] = rev [a2, . . . , an] ++ [a1] = . . . n − 1 times . . . = (. . . ([ ] ++ [an]) ++ . . . ++ [a2]) ++ [a1] Functional Programming Spring Semester, 2025 David Basin 27 Example (cont.) • qrev is O(n) qrev [a1, . . . , an] = aux ([a1, . . . , an], [ ]) = aux ([a2, . . . , an], [a1]) = . . . n − 2 times . . . = aux ([ ], [an, . . . , a2, a1]) = [an, . . . , a2, a1] Functional Programming Spring Semester, 2025 David Basin 28 Relationship between rev and qrev • Is rev xs = qrev xs ? Base case: P [xs ↦→ [ ]] rev [ ] = [ ] = aux ([ ], [ ]) = qrev [ ] Step case: ∀y, ys. P [xs ↦→ ys] → P [xs ↦→ y : ys]. Fix arbitrary y and ys. Induction hypothesis: rev ys = qrev ys To prove: rev (y : ys) = qrev (y : ys) rev (y : ys) = rev ys ++ [y] qrev (y : ys) = aux (y : ys, [ ]) = aux (ys, [y]) • No proof! \u0011 We require rev ys ++ [y] = aux (ys, [y]) \u0011 Induction hypothesis only says rev ys = qrev ys = aux (ys, [ ]) Functional Programming Spring Semester, 2025 David Basin 29 Another induction attempt • To prove: rev xs ++ [x] = aux (xs, [x]). Let’s try induction again Base case: P [xs ↦→ [ ]] rev [ ] ++ [x] = [ ] ++ [x] = [x] = aux ([ ], [x]) Step case: ∀y, ys. P [xs ↦→ ys] → P [xs ↦→ y : ys]. Fix arbitrary y and ys. Induction hypothesis: rev ys ++ [x] = aux (ys, [x]) To prove: rev (y : ys) ++ [x] = aux (y : ys, [x]) rev (y : ys) ++ [x] = (rev ys ++ [y]) ++ [x] = rev ys ++ ([y] ++ [x]) = rev ys ++ [y, x] aux (y : ys, [x]) = aux (ys, [y, x]) • Problem: Induction hypothesis only proven for accumulator [x]. Rather than another induction, let’s try a generalization! Functional Programming Spring Semester, 2025 David Basin 30 Generalization • To prove rev xs ++ [x] = aux (xs, [x]), we prove rev xs ++ ys = aux (xs, ys) I.e., prove ∀xs. P , where P ≡ ∀ys. rev xs ++ ys = aux (xs, ys) • Recall proof rules for ∀x. Q \u0011 ∀-Introduction To prove: Γ ⊢ ∀x. Q Prove: Γ ⊢ Q, where x is not free in any assumption in Γ \u0011 ∀-Elimination From ∀x. Q we can conclude Q[x ↦→ t], for every t Functional Programming Spring Semester, 2025 David Basin 31 Prove: ∀xs. ∀ys. rev xs ++ ys = aux (xs, ys) Proof by induction: ∀xs. P by induction P ≡ ∀ys. rev xs ++ ys = aux (xs, ys) Base case: P [xs ↦→ [ ]] ∀ys. rev [ ] ++ ys = aux ([ ], ys) Using ∀-Introduction, it is sufficient to prove: rev [ ] ++ ys = aux ([ ], ys) Holds as rev [ ] ++ ys = [ ] ++ ys = ys = aux ([ ], ys) Functional Programming Spring Semester, 2025 David Basin 32 Proof (cont.) Step case: ∀a, as. P [xs ↦→ as] → P [xs ↦→ a : as]. Fix arbitrary a and as. Induction hypothesis: ∀ys. rev as ++ ys = aux (as, ys) To prove: ∀ys. rev (a : as) ++ ys = aux (a : as, ys) Using ∀-introduction, we reduce the goal (for ys arbitrary) to rev (a : as) ++ ys = aux (a : as, ys) From the definition and associativity of ++ , we know that rev (a : as) ++ ys = (rev as ++ [a]) ++ ys = rev as ++ ([a] ++ ys) = rev as ++ (a : ys) aux (a : as, ys) = aux (as, a : ys) But an instance of the induction hypothesis (∀-Elimination) is rev as ++ (a : ys) = aux (as, a : ys) QED Functional Programming Spring Semester, 2025 David Basin 33 Proof: summary and simplification • When proving by induction on xs that rev xs = qrev xs, (1) we got stuck in the step case with rev xs ++ [x] = aux (xs, [x]). • We have then proved the generalized statement ∀ys. rev xs ++ ys = aux (xs, ys). Do we still need the induction proof we started with? • No, our original proof goal (??) follows from the generalized one: rev xs = rev xs ++ [] = aux (xs, []) = qrev xs. Functional Programming Spring Semester, 2025 David Basin 34 Abstraction Functional Programming Spring Semester, 2025 David Basin 35 Until now . . . • We have only seen simple structuring techniques \u0011 sufficient though to construct all programs • Difference: language expressiveness versus usability/eloquence \u0011 Assembler versus modern programming languages \u0011 Quick sort with/without list comprehension q [] = [] q (p:xs) = q [x | x<-xs, x <= p] ++ [p] ++ q [x | x<-xs, x > p] • We will now examine different ways of \u0011 structuring programs \u0011 simplifying programs \u0011 improving their reusability Functional Programming Spring Semester, 2025 David Basin 36 Polymorphic types and reusability • Consider the following example: length [] = 0 length (x:xs) = 1 + length xs ? length [17,3,149] 3 :: Int ? length [\"eat\",\"the\",\"potato\",\"Jane\"] 4 :: Int • What is its type? [Int] -> Int, [String] -> Int, ... \u0011 The type is polymorphic: [t] -> Int, for all types t. • Often called parametric polymorphism \u0011 Generics in Java: static <T> int length(List<T> xs) ... \u0011 Differs from subtyping polymorphism, where methods can be applied to objects only of sub-classes. Functional Programming Spring Semester, 2025 David Basin 37 Types and reusability (cont.) • Polymorphic types contain type variables length :: [t] -> Int • Function typeable for all instances. Definition: A type w for f is a most general (also called principal) type iff for all types s for f , s is an instance of w. • Haskell has algorithms for type checking and type reconstruction \u0011 Haskell computes the principal type w, given a function f \u0011 If user provides a type t, then t must be an instance of w. I.e., one can only restrict the type \u0011 We will look at this in more detail later. • Type variables in Haskell start with a lower-case letter. Functional Programming Spring Semester, 2025 David Basin 38 Polymorphic types — examples • Functions over lists :type (++) (++) :: [a] -> [a] -> [a] :type zip zip :: [a] -> [b] -> [(a, b)] :type [] [] :: [a] • Identity id :: a -> a id x = x • Functions over tuples fst :: (a, b) -> a snd :: (a, b) -> b fst (x, y) = x snd (x, y) = y Functional Programming Spring Semester, 2025 David Basin 39 Higher-order functions First order: Arguments are base types or constructor types Int -> [Int] Second order: Arguments are themselves functions (Int -> Int) -> [Int] Third order: Arguments are functions, whose arguments are functions ((Int -> Int) -> Int) -> [Int] Higher-order functions: Functions of arbitrary order Functional Programming Spring Semester, 2025 David Basin 40 Example: map double :: [Int] -> [Int] double [] = [] double (x:xs) = (2*x) : double xs triple :: [Int] -> [Int] triple [] = [] triple (x:xs) = (3*x) : triple xs Same control structure, only different function application double [x1, . . . , xn] = [2·x1, . . . , 2·xn] triple [x1, . . . , xn] = [3·x1, . . . , 3·xn] Functional Programming Spring Semester, 2025 David Basin 41 Control structure can be abstracted map :: (a -> b) -> [a] -> [b] map f [] = [] -- higher-order as map f (x:xs) = f x : map f xs -- function f is an argument times2 x = 2 * x times3 x = 3 * x double xs = map times2 xs triple xs = map times3 xs Example of execution map times2 [2,3] = times2 2 : map times2 [3] = 4 : map times2 [3] = 4 : (times2 3 : map times2 []) = 4 : (6 : map times2 []) = 4 : (6 : []) = [4,6] Functional Programming Spring Semester, 2025 David Basin 42 Visualizing map map f [] = [] map f (x:xs) = f x : map f xs map f [1, 2, 3] = [f 1, f 2, f 3] : 1 : 2 : 3 [ ] : f 1 : f 2 : f 3 [ ] map f Note similarity to list comprehension: map f xs = [f x | x <- xs] Functional Programming Spring Semester, 2025 David Basin 43 Why functions as arguments? -- without map double [] = [] double (x:xs) = (2*x) : double xs -- with map double xs = map times2 xs Advantages: 1. Definition is easier to understand 2. Parts are easier to modify 3. Parts are easier to reuse 4. Correctness is simpler to understand and show Functional Programming Spring Semester, 2025 David Basin 44 Example: folding • Consider sumList [1,2,3] = 1+2+3 sumList [] = 0 sumList (x:xs) = x + sumList xs Is this an instance of map? • Generalization g [x1, x2, . . . , xk] = f (x1, f (x2, . . . , f (xk, 0) . . . )) E.g. sumList [1,2,3] = f (1, f (2, f (3, 0))), for f = (+) • Program foldr :: (a -> b -> b) -> b -> [a] -> b foldr f z [] = z foldr f z (x:xs) = f x (foldr f z xs) sumList xs = foldr (+) 0 xs Functional Programming Spring Semester, 2025 David Basin 45 Visualizing foldr foldr f z [] = z foldr f z (x:xs) = f x (foldr f z xs) foldr f z [1, 2, 3] = f (1, f (2, f (3, z)) : 1 : 2 : 3 [ ] f 1 f 2 f 3 z foldr f z foldr f z replaces (:) with f and [] with z. Functional Programming Spring Semester, 2025 David Basin 46 Example: reverse rev [] = [] rev (x:xs) = rev xs ++ [x] rev [1, 2, 3] = rev [2, 3] ++ [1] = (rev [3] ++ [2]) ++ [1] = ((rev [ ] ++ [3]) ++ [2]) ++ [1] = (([ ] ++ [3]) ++ [2]) ++ [1] = . . . = [3, 2, 1] atEnd 1 2 3 : [] : : 1 2 3 atEndfoldr atEnd [] [] [3] ++ [2] ++ ++ [1] [] atEnd Suggests program: atEnd x xs = xs ++ [x] rv xs = foldr atEnd [] xs Functional Programming Spring Semester, 2025 David Basin 47 Example execution atEnd x xs = xs ++ [x] foldr f z [] = z rv xs = foldr atEnd [] xs foldr f z (x:xs) = f x (foldr f z xs) Executes as follows: rv [1, 2, 3] = foldr atEnd [ ] [1, 2, 3] = atEnd 1 (foldr atEnd [ ] [2, 3]) = (foldr atEnd [ ] [2, 3]) ++ [1] = (atEnd 2 (foldr atEnd [ ] [3])) ++ [1] = ((foldr atEnd [ ] [3]) ++ [2]) ++ [1] = (atEnd 3 (foldr atEnd [ ] [ ]) ++ [2]) ++ [1] = (((foldr atEnd [ ] [ ]) ++ [3]) ++ [2]) ++ [1] = ([ ] ++ [3]) ++ [2]) ++ [1] = . . . = [3, 2, 1] Correctness: prove ∀xs. rev xs = rv xs Functional Programming Spring Semester, 2025 David Basin 48 More examples of foldr We can now easily define some standard Haskell functions: concat xs = foldr (++) [] xs ? concat [[1,2,3],[4],[5,6]] [1,2,3,4,5,6] :: [Int] and bs = foldr (&&) True bs ? and [True,True,False] False :: Bool or bs = foldr (||) False bs ? or [True,True,False] True :: Bool pcons (x,y) (xs,ys) = (x:xs, y:ys) unzip xs = foldr pcons ([],[]) xs ? unzip [(1,2),(3,4),(5,6)] ([1,3,5],[2,4,6]) :: ([Int],[Int]) Exercise: Express map in terms of foldr. Functional Programming Spring Semester, 2025 David Basin 49 λ-expressions • Consider the following functions times2 x = 2 * x atEnd x xs = xs ++ [x] double xs = map times2 xs rv xs = foldr atEnd [] xs • Haskell provides notation to write functions like times2 and atEnd in-line ? map (\\x -> 2 * x) [2,3,4] [4,6,8] ? foldr (\\x xs -> xs ++ [x]) [] [1,2,3,4] [4,3,2,1] N.B.: \\x xs -> xs ++ [x] is a shorthand for \\x -> \\xs -> xs ++ [x] • Church’s λ-notation (character “\\” used instead of “λ”) usual λ-calculus Declaration f (x) = x + 3 λx. x + 3 Application f (5) (λx. x + 3)(5) Reduction (substitution) (x + 3)[x ↦→ 5] (x + 3)[x ↦→ 5] Result (from evaluation) 8 8 Functional Programming Spring Semester, 2025 David Basin 50 Example: function composition and iteration • Function composition f ◦ g as a function (.) :: (b -> c) -> (a -> b) -> (a -> c) (f . g) x = f (g x) • Function iteration iter :: Int -> (a -> a) -> a -> a iter 0 f x = x iter n f x = f (iter (n-1) f x) • Examples times2 x = 2 * x times3 x = 3 * x ? (times2 . times3) 5 30 :: Int ? iter 4 times2 1 16 :: Int ? iter 4 times3 1 81 :: Int Functional Programming Spring Semester, 2025 David Basin 51 Functions as values • Functions can be returned as values • Example twice :: (t -> t) -> (t -> t) twice f = f . f ? twice times3 1 9 :: Int ? (twice . twice) times3 1 -- 3^4 = 81 81 :: Int ? twice (times3 . times3) 1 81 :: Int Functional Programming Spring Semester, 2025 David Basin 52 Functions as values (cont.) • Iter (higher-order argument) iter 0 f x = x iter n f x = f (iter (n-1) f x) • Iter (higher-order argument and result) id x = x iter :: Int -> (a -> a) -> a -> a iter 0 f = id iter n f = f . (iter (n-1) f) • Functions cannot be displayed, but they can be applied ? iter 2 times2 ... Error ... ? let f = iter 2 times2 in f 5 20 :: Int Functional Programming Spring Semester, 2025 David Basin 53 Evaluation example iter 0 f = id id x = x iter n f = f . (iter (n-1) f) (f . g) x = f (g x) times2 x = 2 * x let f = iter 2 times2 in f 5 Can be calculated as follows let f = iter 2 times2 in f 5 = (iter 2 times2) 5 = (times2 . (iter (2-1) times2)) 5 = times2 ((iter (2-1) times2) 5) = 2 * ((iter (2-1) times2) 5) = 2 * ((times2 . iter (1-1) times2) 5) = 2 * (times2 ((iter (1-1) times2) 5)) = 2 * (2 * ((iter (1-1) times2) 5)) = 2 * (2 * (id 5)) = 2 * (2 * 5) = ... = 20 Functional Programming Spring Semester, 2025 David Basin 54 Example: logging • Suppose we want to log all recursive calls to gcd in a list. type Log = [(Integer, Integer)] gcdLog :: Integer -> Integer -> Log -> (Integer, Log) gcdLog x y log | x == y = (x, log’) | x > y = gcdLog (x-y) y log’ | otherwise = gcdLog x (y-x) log’ where log’ = log ++ [(x, y)] > gcdLog 6 4 [] (2,[(6,4),(2,4),(2,2)]) • Appending to the log is linear in the log’s size. Repeated appending causes quadratic run-time. Can we do better? Functional Programming Spring Semester, 2025 David Basin 55 Difference lists Difference list: function [a] -> [a] that prepends a list to its argument Example: [1,2,3] as a difference list dl123 = \\xs -> [1,2,3] ++ xs : 1 : 2 : 3 [] ordinary list [1,2,3] \\xs -> : 1 : 2 : 3 xs difference list dl123 The parameter is like a hole at the list’s end. Functional Programming Spring Semester, 2025 David Basin 56 Difference lists type DList a = [a] -> [a] empty :: DList a -- empty list empty = \\xs -> xs sngl :: a -> DList a -- singleton list sngl x = \\xs -> x : xs -- concatenation (higher-order!) app :: DList a -> DList a -> DList a ys ‘app‘ zs = \\xs -> ys (zs xs) fromList :: [a] -> DList a -- conversion from lists fromList ys = \\xs -> ys ++ xs toList :: DList a -> [a] -- conversion to lists toList ys = ys [] \\xs -> • \\xs -> : x • • \\ -> ys • \\ -> zs \\ xs->• \\(y1:y2:...:[]) xs -> • • \\ -> ys [] Functional Programming Spring Semester, 2025 David Basin 57 Logging with difference lists I type DLog = DList[(Integer, Integer)] gcdDLog :: Integer -> Integer -> DLog -> (Integer, DLog) gcdDLog x y log | x == y = (x, log’) | x > y = gcdLog (x-y) y log’ | otherwise = gcdLog x (y-x) log’ where log’ = log ‘app‘++sngl[(x, y)] gcdDLog 6 4 empty = gcdDLog 2 4 (empty ‘app‘ sngl (6,4)) = gcdDLog 2 2 ((empty ‘app‘ sngl (6,4)) ‘app‘ sngl (2,4)) = (2, ((empty ‘app‘ sngl (6,4)) ‘app‘ sngl (2,4)) ‘app‘ sngl (2,2)) Functional Programming Spring Semester, 2025 David Basin 58 Logging with difference lists II Let’s evaluate the log: empty = \\xs -> xs sngl x = \\xs -> x : xs ys ‘app‘ zs = \\xs -> ys (zs xs) toList xs = xs [] toList (((empty ‘app‘ sngl (6,4)) ‘app‘ sngl (2,4)) ‘app‘ sngl (2,2)) = (((empty ‘app‘ sngl (6,4)) ‘app‘ sngl (2,4)) ‘app‘ sngl (2,2)) [] = ((empty ‘app‘ sngl (6,4)) ‘app‘ sngl (2,4)) (sngl (2,2) []) = (empty ‘app‘ sngl (6,4)) (sngl (2,4) (sngl (2,2) [])) = empty (sngl (6,4) (sngl (2,4) (sngl (2,2) []))) = sngl (6,4) (sngl (2,4) (sngl (2,2) [])) = (6,4) : sngl (2,4) (sngl (2,2) []) = (6,4) : (2,4) : sngl (2,2) [] = (6,4) : (2,4) : (2,2) : [] • Appending to the end of a difference list takes O(1). • Getting the head takes O(n) where n = number of appends. • Getting the remaining elements is O(1) each. • N.B. Cons “:” is infix right-associative. Result = [(6,4),(2,4),(2,2)] Functional Programming Spring Semester, 2025 David Basin 59 Partial application • Functions of multiple arguments . . . multiply :: Int -> Int -> Int multiply a b = a * b • . . . can be partially applied ? :type multiply 7 Int -> Int ? :type map (a -> b) -> [a] -> [b] ? map (multiply 7) [1,2,3,4] [7, 14, 21, 28] :: [Int] • Application and types If f :: t1 → t2 → · · · → tn → t and e1 :: t1, . . . , ek :: tk then f e1 . . . ek :: tk+1 → · · · → tn → t Functional Programming Spring Semester, 2025 David Basin 60 How many arguments do functions have? • Each function takes exactly one argument \u0011 multiply :: Int -> Int -> Int means multiply :: Int -> (Int -> Int) \u0011 Application multiply 2 3 means (multiply 2) 3 \u0011 Partial application is consistent with the view (= illusion) that functions take multiple arguments • Operator sections: if ⊕ is an infix binary operator (a ⊕) ≡ λx. a ⊕ x (⊕ a) ≡ λx. x ⊕ a • Example ? map ((2*).(3*)) [1,2,3] [6,12,18] Functional Programming Spring Semester, 2025 David Basin 61 Multiple arguments versus tupling f :: (Int,Int) -> Int g :: Int -> Int -> Int f (x,y) = x * y + 17 g x y = x * y + 17 • Tuple arguments: no partial application • But equivalent in the following sense: curry :: ((a,b) -> c) -> a -> b -> c uncurry :: (a -> b -> c) -> (a,b) -> c curry f = f’ where f’ x1 x2 = f (x1,x2) uncurry f’ = f where f (x1,x2) = f’ x1 x2 • “Curry” like “Haskell Brooks Curry” Functional Programming Spring Semester, 2025 David Basin 62 Examples f :: (Int,Int) -> Int g :: Int -> Int -> Int f (x,y) = x * y + 17 g x y = x * y + 17 ? f (3,4) 29 :: Int ? curry f 3 4 29 :: Int ? g (3,4) ... Error ... ? g 3 4 29 :: Int ? uncurry g (3,4) 29 :: Int Functional Programming Spring Semester, 2025 David Basin 63 Uncluttering notation • f $ x = f x right-associative operator for function application. Avoids parentheses: putStrLn (show (gcd 1000 (fib 6 + fib 10))) putStrLn $ show $ gcd 1000 $ fib 6 + fib 10 • Partial application and sections avoid notational clutter. E.g., operations on difference lists: empty = \\xs -> xs empty = id sngl x = \\xs -> x : xs sngl = (:) ys ‘app‘ zs = \\xs -> ys (zs xs) app = (.) fromList ys = \\xs -> ys ++ xs fromList = (++) toList ys = ys [] toList = ($[]) Functional Programming Spring Semester, 2025","libVersion":"0.5.0","langs":""}