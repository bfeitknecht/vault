{"path":"sem4/CN/VRL/extra/CN-s09-routing.pdf","text":"Computer Networks: Lecture 9: Routing Adrian Perrig Network Security Group ETH Zürich Photo: ETH Zürich / Gian Marco Castelberg Powers of Two Conversion & Useful Units 2n = 10m m ~ (n/10) * 3 n ~ (m/3) * 10 Fast conversion trick: • 210 ~ 103 , 220 ~ 106 , 230 ~ 109 • 20 = 1, 21 = 2, 22 = 4, 23 = 8, 24 = 16, 25 = 32, 26 = 64, 128, 256, 512, 1024 Seconds per day ~216 , seconds per year ~225 Schneier’s Applied Cryptography, p.18 • Probability to get hit by lightning per day (10-10 , 2-33 ) • Number of atoms on earth (1051 , 2170 ) • Number of atoms in the universe (1077 , 2265 ) • Time until next ice age (14,000, 214 years) • Age of the Universe (1010 , 233 years) 2 Where we are in the course … More fun in the Network Layer! • We’ve covered packet forwarding • Now we’ll learn about routing Physical Link Network Transport Application 3 Routing versus Forwarding Forward! packet Which way? Which way? Which way? Forwarding is the process of sending a packet on its way Routing is the process of deciding in which direction to send traffic 4 Mechanism Timescale / Adaptation Load-sensitive routing Seconds / Traffic hotspots Routing Minutes / Equipment failures Traffic Engineering Hours / Network load Network Provisioning Months / Network customers Perspective on Bandwidth Allocation Routing allocates network bandwidth adapting to failures; other mechanisms used at other timescales 5 Unicast Multicast AnycastBroadcast Delivery Models Different routing used for different delivery models 6 Goals of Routing Algorithms Property Meaning Correctness Finds paths that work Efficient paths Given path is minimal for some metric Full connectivity Doesn’t starve any nodes Fast convergence Recovers quickly after changes Scalability Efficient as network grows larger We want several properties of any routing scheme: 7 Rules of Routing Algorithms Who’s there? Decentralized, distributed setting • All nodes are alike; no controller • Nodes only know what they learn by exchanging messages with neighbors • Nodes operate concurrently • May be node/link/message failures 8 This time Last time Next time Network-Layer Topics Forwarding: IPv4, IPv6, NATs and all that Shortest path routing, Dijkstra Hierarchical routing (scalability) Intra-domain routing • Distance-Vector routing • Flooding • Link-state routing • Equal-cost multi-path • IS-IS and OSPF Inter-domain routing (BGP) 9 Shortest Path Routing, Dijkstra Algorithm Shortest Path Routing (§5.2) Best? A B C D E F G H Defining “best” paths with link costs • These are shortest path routes 11 What are “Best” paths anyhow? A B C D E F G H Many possibilities: • Latency, avoid circuitous paths • Bandwidth, avoid small pipes • Money, avoid expensive links • Hops, to reduce switching But only consider topology • Ignore workload, e.g., hotspots 12 Shortest Paths We’ll approximate “best” by a cost function that captures the factors • Often call lowest “shortest” 1. Assign each link a cost (distance) 2. Define best path between each pair of nodes as the path that has the lowest total cost (or is shortest) 3. Pick randomly to break any ties 13 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 Shortest Paths (2) • Find the shortest path A  E • All links are bidirectional, with equal costs in each direction • Can extend model to unequal costs if needed 14 Shortest Paths (3) A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 • ABCE is a shortest path • dist(ABCE) = 4 + 2 + 1 = 7 • This is less than: • dist(ABE) = 8 • dist(ABFE) = 9 • dist(AE) = 10 • dist(ABCDE) = 10 15 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 Shortest Paths (4) • Optimality property: • Subpaths of shortest paths are also shortest paths • ABCE is a shortest path So are ABC, AB, BCE, BC, CE 16 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 Sink Trees • Sink tree for a destination is the union of all shortest paths towards the destination • Similarly source tree • Find the sink tree for E 17 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 Sink Trees (2) Implications: • Only need to use destination to follow shortest paths • Each node only needs to send to next hop Forwarding table at a node • Lists next hop for each destination • Routing table may know more 18 Computing Shortest Paths with Dijkstra (§5.2.1) Source tree for E A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 How to compute shortest path given the network topology • With Dijkstra’s algorithm 19 By Hamilton Richards, CC-BY-SA-3.0, via Wikimedia Commons Edsger W. Dijkstra (1930-2002) Famous computer scientist • Programming languages • Distributed algorithms • Program verification Dijkstra’s algorithm, 1959 • Single-source shortest paths, given network with non-negative link costs 20 Dijkstra’s Algorithm Algorithm: • Mark all nodes tentative, set distances from source to 0 (zero) for source, and ∞ (infinity) for all other nodes • While tentative nodes remain: • Extract N, a node with lowest distance • Add link to N to the shortest path tree • Relax the distances of neighbors of N by lowering any better distance estimates 21 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 0 ∞ ∞ ∞ ∞ ∞ ∞ We’ll compute shortest paths from A ∞ Dijkstra’s Algorithm (2) Initialization 22 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 0 ∞ ∞ 10 4 ∞ ∞ ∞ Dijkstra’s Algorithm (3) Relax around A 23 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 0 ∞ 8 4 Distance fell! 6 7 7 ∞ Dijkstra’s Algorithm (4) Relax around B 24 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 0 7 4 Distance fell again! 6 7 7 8 9 Dijkstra’s Algorithm (5) Relax around C 25 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 0 7 4 Didn’t fall … 6 7 7 8 9 Dijkstra’s Algorithm (6) Relax around G (say) 26 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 0 7 4 Relax has no effect 6 7 7 8 9 Dijkstra’s Algorithm (7) Relax around F (say) 27 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 0 7 4 6 7 7 8 9 Dijkstra’s Algorithm (8) Relax around E 28 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 0 7 4 6 7 7 8 9 Dijkstra’s Algorithm (9) Relax around D 29 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 0 7 4 6 7 7 8 9 Dijkstra’s Algorithm (10) Finally, H … done 30 Dijkstra Comments Finds shortest paths in order of increasing distance from source • Leverages optimality property Runtime depends on efficiency of extracting min-cost node • Superlinear in network size (grows fast) Gives complete source/sink tree • More than needed for forwarding! • But requires complete topology 31 Hierarchical Routing I don’t!I route Combining Hosts and Routers How routing protocols work with IP • The Host/Router distinction 33 Recap from previous Lecture In the Internet: • Hosts on same network have IP addresses in the same IP prefix • Host performs ARP on IP address of destination • Hosts just send off-network traffic to the nearest router to handle • Host performs ARP on IP address of default router / gateway • Routers discover the routes to use • Routers use longest matching prefix algorithm to forward packets to next hop 34 Rest of network IP router “A” Single network (One IP prefix “P”) LAN switch Host/Router Combination Hosts attach to routers as IP prefixes • Router needs table to reach all hosts 35 P A B E 10 4 0 Network Topology for Routing Group hosts under IP prefix connected directly to router • One entry for all hosts 36 Network Topology for Routing (2) Routing now works as before! • Routers advertise IP prefixes for hosts • Router addresses are “/32” prefixes • Lets all routers find a path to hosts • Hosts find destination by sending packets to their router 37 To the West! West East Destination Hierarchical Routing How to scale routing with hierarchy in the form of regions • Route to regions, not individual nodes 38 Remember: Internet Growth Source: https://iotbusinessnews.com/2019/05/16/04619-internet-of-things-now-numbers-22-billion-devices-but-where-is-the-revenue/ 39 Remember: Forwarding Tables Keep Growing Ouch! Source: https://www.cidr-report.org 40 Impact of Routing Growth 1. Forwarding tables grow • Larger router memories, may increase lookup time 2. Routing messages grow • Need to keep all nodes informed of larger topology 3. Routing computation grows • Shortest path calculations grow faster than the size of the network 41 now Techniques to Scale Routing 1. IP prefixes • Route to blocks of hosts 2. Network hierarchy • Route to network regions 3. IP prefix aggregation • Combine, and split, prefixes 42 Hierarchical Routing Introduce a larger routing unit • IP prefix (address range of hosts) • Region, e.g., ISP network Route first to the region, then to the IP prefix within the region • Hide details within a region from outside of the region 43 Hierarchical Routing (2) 44 Hierarchical Routing (3) 45 1C is best route to region 5, except for destination 5C Hierarchical Routing (4) Penalty is longer paths 46 Observations Outside a region, nodes have one route to all hosts within the region • This gives savings in table size, messages and computation However, each node may have a different route to an outside region • Routing decisions are still made by individual nodes; there is no single decision made by a region 47 Today’s Internet: Hierarchical Routing with IP Prefixes • No statically defined regions • Use IP prefixes as “dynamic regions” • Routers keep detailed information about close destinations (long prefixes) • Short prefixes for far-away destinations 48 IP Prefix Aggregation and Subnets (§4.3) I’m the whole region Region 1 2 3 IP /16 IP1 /18 IP2 /18 IP3 /18 How to help scale routing by adjusting the size of IP prefixes • Split (subnets) and join (aggregation) 49 Recall IP addresses are allocated in blocks called IP prefixes, e.g., 18.31.0.0/16 • Hosts on one network are in the same prefix A “/N” prefix has the first N bits fixed and contains 232-N – 2 host addresses • E.g., “/24” • E.g., “/16” 50 Routers can change prefix lengths without affecting hosts Important Flexibility Routers keep track of prefix lengths • Use it to compute longest matching prefix More specific IP prefix • Longer prefix, fewer IP addresses Less specific (or more general) IP prefix • Shorter prefix, more IP addresses 51 I’m the whole region Region 1 2 3 IP /16 IP1 /18 IP2 /18 IP3 /18 Prefixes and Hierarchy IP prefixes already help to scale routing, but we can go further • Can use a less specific prefix to name a region made up of several prefixes More information at: www.route-aggregation.net 52 Subnets and Aggregation Two use cases for adjusting the size of IP prefixes; both reduce routing table size 1. Subnets • Internally split one less specific prefix into multiple more specific prefixes 2. Aggregation • Externally join multiple more specific prefixes into one large prefix 53 64K addresses One prefix sent to rest of Internet16K 32K 8K Company Rest of Internet Subnets Internally split up one IP prefix 54 Prefix 128.208.128/17 128.208.96/19 128.208.0/18 3rd byte in binary 1000 0000 0110 0000 0000 0000 128.208.0.0 128.209.0.0 128.208.128.0 128.208.96.0 Question: • What prefix is covered in addition by 128.208/16? 128.208/16 Visualizing the Prefixes 55 One prefix advertised to rest of Internet \\ ISPRest of Internet Aggregation Externally join multiple separate IP prefixes 56 192.24.0.0 192.24.32.0 192.24.16.0 192.24.8.0 192.24.12.0 192.24.16/20 (0001 xxxx) 192.24.0/21 (0000 0xxx) 192.24.8/22 (0000 10xx) Questions: • What prefix is covered in addition by 192.24.0/19? • What if that prefix belongs to someone outside these networks? Visualizing the Prefixes 57 Two Points of Aggregation 1. Optimize local routing table • Construct routing table with fewer entries but same longest-matching-prefix results • See “Compress forwarding table” in network-layer slides • See “Optimal Routing Table Constructor” algorithm in supplementary material at the end of these lecture slides 2. Decide which prefixes to advertise • Additional issue: router must make sure that nobody else can advertise a prefix that hides part of its address space 58 Aggregate Prefixes to Advertise Example: R1 controls 192.24.16/20 and 192.24.12/22. Question: Is it sufficient to advertise 192.24.0/19? Answer: No. R2 who owns 192.24.0/21 and 192.24.8/22 could advertise 192.24.0/20 and thus hide 192.24.12/22. 192.24.0.0 192.24.32.0 192.24.16.0 192.24.8.0 192.24.12.0 192.24.16/20 (0001 xxxx) 192.24.8/22 (0000 10xx) 192.24.12/22 (0000 11xx) 192.24.0/21 (0000 0xxx) 59 Distance-Vector Routing Intra-Domain Routing The Internet is a network of networks: autonomous systems (ASes) • These ASes interconnect with each other to form the global Internet • More in the next lecture on BGP Each AS can independently administer its own network • Define topology and networking equipment • Decide which protocols to use Intra-domain routing refers to routing within such an independent network • Intra-domain protocols: interior gateway protocols (IGPs) • Inter-domain routing is between multiple ASes: exterior gateway protocols (EGPs) 61 Here’s my vector! Here’s mine Distance-Vector Routing (§5.2.2) How to compute shortest paths in a distributed network • The Distance-Vector (DV) approach 62 Distance-Vector Routing Simple, early routing approach • Used in ARPANET, and RIP (Routing Information Protocol) One of two main approaches to routing • Uses distributed version of Bellman-Ford algorithm • Works, but very slow convergence after some failures Link-state algorithms are now typically used for intra-domain routing in practice • More involved, better behavior 63 Distance-Vector Setting Each node computes its forwarding table in a distributed setting: 1. Nodes know only the cost to their neighbors; not the topology 2. Nodes communicate only with their neighbors using messages 3. All nodes run the same algorithm (distributed Bellman-Ford) concurrently 4. Nodes and links may fail, messages may be lost 64 Distance-Vector Algorithm Each node maintains a vector of distances (the distance vector) to all destinations (also stores next hops for each destination) 1. Initialize vector with 0 (zero) cost to self, ∞ (infinity) to all other destinations 2. Periodically send vector to neighbors 3. Every round, after receiving vectors of all neighbors: • For each neighbor, add cost of link to neighbor to the vector received from that neighbor • Set all vector entries (except to self) to the minimum of all received values and set the corresponding neighbor as next hop 65 B C D A 2 6 7 3 3 To Cost A 0 B ∞ C ∞ D ∞ A’s initial vector Distance-Vector Example Consider a simple network. Each node runs on its own • E.g., node A can only talk to nodes B and D 66 A learns Cost Next 0 -- 3 B ∞ -- 7 D To B says D says A ∞ ∞ B 0 ∞ C ∞ ∞ D ∞ 0 B +3 D +7 ∞ ∞ 3 ∞ ∞ ∞ ∞ 7 B C D A 2 6 7 3 3 = learned better route DV Example (2) First exchange, A hears from B, D and finds 1-hop routes • A always learns min(B+3, D+7) 67 A learns Cost Next 0 -- 3 B ∞ -- 7 D To A says B says C says D says A 0 ∞ ∞ ∞ B ∞ 0 ∞ ∞ C ∞ ∞ 0 ∞ D ∞ ∞ ∞ 0 B C D A 2 6 7 3 3 B learns Cost Next 3 A 0 -- 6 C 3 D C learns Cost Next ∞ -- 6 B 0 -- 2 D D learns Cost Next 7 A 3 B 2 C 0 -- DV Example (3) First exchange for all nodes to find best 1-hop routes • E.g., B learns min(A+3, C+6, D+3) = learned better route 68 A learns Cost Next 0 -- 3 B 9 D 6 B To A says B says C says D says A 0 3 ∞ 7 B 3 0 6 3 C ∞ 6 0 2 D 7 3 2 0 B C D A 2 6 7 3 3 B learns Cost Next 3 A 0 -- 5 D 3 D C learns Cost Next 9 B 5 D 0 -- 2 D D learns Cost Next 6 B 3 B 2 C 0 -- DV Example (4) Second exchange for all nodes to find best 2-hop routes = learned better route 69 A learns Cost Next 0 -- 3 B 8 B 6 B To A says B says C says D says A 0 3 9 6 B 3 0 5 3 C 9 5 0 2 D 6 3 2 0 B C D A 2 6 7 3 3 B learns Cost Next 3 A 0 -- 5 D 3 D C learns Cost Next 8 D 5 D 0 -- 2 D D learns Cost Next 6 B 3 B 2 C 0 -- DV Example (5) Third exchange for all nodes to find best 3-hop routes = learned better route 70 A learns Cost Next 0 -- 3 B 8 B 6 B To A says B says C says D says A 0 3 8 6 B 3 0 5 3 C 8 5 0 2 D 6 3 2 0 B C D A 2 6 7 3 3 B learns Cost Next 3 A 0 -- 5 D 3 D C learns Cost Next 8 D 5 D 0 -- 2 D D learns Cost Next 6 B 3 B 2 C 0 -- DV Example (5) Fourth and subsequent exchanges; converged = learned better route 71 Distance-Vector Dynamics Adding routes: • News travels one hop per exchange • After n rounds, every node knows the shortest paths of up to n hops •  Fully converged after at most #nodes-1 rounds Removing routes • When a node fails, no more exchanges, other nodes forget But partitions (unreachable nodes in divided network) are a problem • “Count to infinity” scenario 72 “Count to infinity” scenario Desired convergence X DV Dynamics (2) • Good news travels quickly, bad news slowly (inferred) • Example: DV routing for destination A 73 DV Dynamics (3) Various heuristics to address “count-to-infinity” problem • e.g., “split horizon”, “poison reverse”: • Split horizon: do not send routes to the neighbor you learned them from • Poison reverse: stronger variant of “split horizon” where metric = ∞ for routes learned from neighbor sent back to that neighbor But none are very effective • Challenge: Can you design a topology where split horizon / poison reverse does not work well? Link state now favored in practice in intra-domain settings • Except when very resource-limited 74 RIP (Routing Information Protocol) DV protocol with hop count as metric • Infinity is 16 hops; limits network size • Includes split horizon, poison reverse Routers send vectors every 30 secs • Runs on top of UDP • Timeout in 180 secs to detect failures RIPv1 specified in RFC1058 (1988) 75 FloodingFlood! Flooding How to send a message to all nodes in the network with flooding • Simple mechanism, but inefficient 77 Flooding (2) • Rule used at each node: • Sends an incoming message on to all other neighbors • Remember the message so that it is only sent once over each link (called duplicate suppression) • Inefficient because one node may receive multiple copies of message 78 A B C D E F G H Flooding (3) Consider a flood from A; first reaches B via AB, E via AE 79 A B C D E F G H F gets 2 copies E and B send to each other Flooding (4) Next B floods BC, BE, BF, BG, and E floods EB, EC, ED, EF 80 A B C D E F G H F gets another copy Flooding (5) C floods CD, CH; D floods DC; F floods FG; G floods GF 81 A B C D E F G H Each link carries the message, and in at least one direction Flooding (6) H has no-one to flood … and we’re done 82 Flooding Details Remember message (to stop flood) using source and sequence number • Used for duplicate suppression, so same message is only sent once to neighbors • So subsequent message (with higher sequence number) will again be flooded To make flooding reliable, use stop-and-wait • Receiver acknowledges receipt, and sender resends if needed 83 Link-State Routing Flood! … then compute Link-State Routing (§5.2.1, §5.3) How to compute shortest paths in a distributed network • The Link-State (LS) approach 85 Link-State Routing One of two approaches to routing • Trades more computation than Distance-Vector for better dynamics Widely used in practice for intra-domain routing • Used in Internet/ARPANET from 1979 • Modern networks use OSPF and IS-IS for intra-domain routing 86 Link-State Setting Each node computes their forwarding table in the same distributed setting as Distance-Vector: 1. Node knows only the cost to its neighbors; not the topology 2. Node can talk only to its neighbors using messages 3. Nodes run the same algorithm concurrently 4. Nodes/links may fail, messages may be lost 87 Link-State Algorithm Proceeds in two phases: 1. Nodes flood topology in the form of link state packets • Each node learns full topology 2. Each node computes its own forwarding table • By running Dijkstra (or equivalent) Important: • All nodes need to optimize the same metric. • Two neighbors need to agree on cost of their link. • Link costs should be larger than zero. 88 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 Seq. # A 10 B 4 C 1 D 2 F 2 Node E’s LSP flooded to A, B, C, D, and F Phase 1: Topology Dissemination Each node floods link state packet (LSP) that describes their portion of the topology 89 Phase 2: Route Computation Each node has full topology • By combining all LSPs Each node simply runs Dijkstra • Some replicated computation, but finds required routes directly • Compile forwarding table from sink/source tree • That’s it folks! 90 To Next A C B C C C D D E -- F F G F H C A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 Forwarding Table Source Tree for E (from Dijkstra) E’s Forwarding Table 91 A B C D E F G H 2 1 10 2 2 4 2 4 4 3 3 3 XXXX Seq. # A 4 C 2 E 4 F 3 G ∞ B’s LSP Seq. # B 3 E 2 G ∞ F’s LSP Failure! Handling Changes On change, flood updated LSPs, and re-compute routes • E.g., nodes adjacent to failed link or node initiate 92 Handling Changes (2) Link failure • Both nodes notice, send updated LSPs • Link is removed from topology Node failure • All neighbors notice a link has failed • Failed node can’t update its own LSP • But it is OK: all links to node removed 93 Handling Changes (3) Addition of a link or node • Add LSP of new node to topology • Old LSPs are updated with new link Additions are the easy case … 94 Link-State Complications Things that can go wrong: • Seq. number reaches max, or is corrupted • Node crashes and loses seq. number • Network partitions then heals Strategy: • Include age on LSPs and forget old information that is not refreshed Much of the complexity is due to handling corner cases (as usual!) 95 Goal Distance-Vector Link-State Correctness Distributed Bellman-Ford Replicated Dijkstra Efficient paths Approx. with shortest paths Approx. with shortest paths Fair paths Approx. with shortest paths Approx. with shortest paths Fast convergence Slow – many exchanges Fast – flood and compute Scalability Excellent: storage/compute Moderate: storage/compute DV/LS Comparison 96 Equal-Cost Multi-Path Routing Equal-Cost Multi-Path Routing Use ABE as well as ABCE from AE A B C D E F G H More on shortest path routes • Allow multiple shortest paths 98 Multipath Routing Allow multiple routing paths from node to destination be used at once • Topology has them for redundancy • Using them can improve performance and reliability Questions: • How do we find multiple paths? • How do we send traffic along them? 99 A B C D E F G H 2 2 10 1 1 4 2 4 4 3 3 3 Equal-Cost Multipath Routes One form of multipath routing • Extends shortest path model by keeping set if there are ties Consider AE • ABE = 4 + 4 = 8 • ABCE = 4 + 2 + 2 = 8 • ABCDE = 4 + 2 + 1 + 1 = 8 • Use them all! 100 Tree DAG Source “Trees” With ECMP, source/sink “tree” is a directed acyclic graph (DAG) • Each node has set of next hops • Still a compact representation 101 Source “Trees” (2) A B C D E F G H 2 2 10 1 1 4 2 4 4 3 3 3 Find the source “tree” for E • Procedure is Dijkstra, simply remember set of next hops • Compile forwarding table similarly, may have set of next hops Straightforward to extend DV too • Just remember set of neighbors 102 Source Tree for E E’s Forwarding Table A B C D E F G H 2 2 10 1 1 4 2 4 4 3 3 3 Node Next hops A B, C, D B B, C, D C C, D D D E -- F F G F H C, D New for ECMP Source “Trees” (3) 103 Forwarding with ECMP Could randomly pick a next hop for each packet based on destination • Balances load, but adds jitter • Can also cause packet reordering Instead, try to always send packets from a given flow on the same path • Map flow identifier to single next hop • No jitter within flow, but less balanced How to identify flows? • Hash 5-tuple (Src IP, Dst IP, Src Port, Dst Port, Protocol) • Protocol is TCP or UDP • Use IPv6 Flow ID 104 A B C D E F G H 2 2 10 1 1 4 2 4 4 3 3 3 Multipath routes from F/E to C/H E’s Forwarding Choices Flow Possible next hops Example choice F  H C, D D F  C C, D D E  H C, D C E  C C, D C Use both paths to get to one destination Forwarding with ECMP (2) 105 IS-IS and OSPF Real-World Interior Gateway Protocols: IS-IS and OSPF Widely used in large enterprise and ISP networks • IS-IS = Intermediate System to Intermediate System • OSPF = Open Shortest Path First Link-state protocol with many added features • E.g., “Areas” for scalability 107 OSPF • Link-state routing protocol widely used for intra-domain routing • “Open”: specification is publicly available • First standardized in 1989 (RFC 1131) • Updated in 1998 to v2 (RFC 2328) • IPv6 support added in v3 (RFC 5340) 108 Areas in OSPF • OSPF splits the AS into different areas • Improves scalability: flooding only within each area • Like splitting the whole Internet into ASes • Areas are identified by 32-bit numbers, formatted as IP addresses (a.b.c.d) • Each area independently runs the link-state routing algorithm • Routers keep a link-state database for the areas they are connected to • An area’s topology is invisible from the outside • Only aggregated information is communicated • All areas are connected exclusively via a special backbone area • Backbone area must be contiguous • ID of backbone area: 0.0.0.0 109 Areas in OSPF AS Area Backbone area Router Link 110 Different Types of Routers in OSPF Internal routers Area border routers Backbone routers AS border routers AS Area Backbone area Router Link 111 Different Types of Routers in OSPF (2) Internal routers • Belong to a single area (not the backbone area) • Only run the LS routing algorithm with routers belonging to their respective area Backbone routers • Routers with a connection to the backbone area Area border routers • Special case of backbone routers • Belong to the backbone area and at least one other area • Run the LS routing algorithm for all connected areas • Condense topological information of their areas and distribute it to the backbone AS boundary routers • Routers connected to other ASes • Can be either internal or backbone routers • Advertise external routing information throughout the AS 112 OSPF Routing Algorithm Each router keeps a link-state database storing the area’s topology Routers send out link-state advertisements (LSAs) • LSAs are sent in IP packets • Contain originating router ID and its interfaces (with respective costs) • Area border routers and AS boundary routers distribute additional LSAs containing information of their connected area or AS, respectively • Can be authenticated using shared cryptographic keys and hash functions Link-state database is collection of all LSAs • Should be identical for all routers of an area 113 Other Properties of OSPF Supports equal-cost multipath • Routers can set up multiple paths to same destination Extensions for traffic engineering (OSPF-TE) • Can exchange additional information beyond link costs • Enables more elaborate traffic engineering 114 IS-IS Development started in 1987 (before OSPF) • OSPF loosely based on IS-IS • Standardized by ISO and IETF (RFC 1195) Very similar to OSPF • Link-state routing protocol • Dijkstra algorithm used to compute best paths • Network can be separated into areas 115 OSPF vs IS-IS OSPF IS-IS Purpose Designed for IP traffic Neutral towards layer-3 protocols Encapsulation Runs on top of IP Runs directly over layer 2 Area boundaries On routers Routers can belong to different areas On links Routers belong to a single area Backbone area Contiguous area 0.0.0.0 connects all other areas No backbone area IPv6 support Added in OSPF v3 Supported implicitly 116 Note: the following material is purely for your enjoyment to satisfy your curiosity. It will not be tested on the exam, except Bloom filters. Supplementary Material 117 Constructing a Routing Table • Recall: Number of entries in the routing tables are increasing as the Internet is growing • How to construct a routing table with the least possible entries that still maintains all the information required for forwarding? • Approach: Use subnets and prefix aggregation! • Optimal Routing Table Constructor (ORTC), presented in the following paper: “Constructing Optimal IP Routing Tables” by Richard P. Draves et al., published at INFOCOM 1999. 118 Routing Table at Router R Prefix Next hop * 1 00* 2 10* 2 11* 3 1 2 2 3 Binary Tree Representation of Routing table 0 1 0 0 1 Constructing a Routing Table 119 1 2 2 3 0 1 0 ? 1 0 1 1 1 ORTC: First Pass Propagate information from root to tree leafs 1. Normalize tree 2. Initialize new leafs with information from nearest ancestor 3. Remove information in interior nodes 120 {2} {2} {3} 0 1 0 {1} 1 0 1 {1, 2} {2, 3} {2} ORTC: Second Pass Calculate most prevalent hops at every level of the routing table 1. Percolate sets of next hops from leaves to root 2. Percolate: 121 {2} {1,2} } {2,3} } {2} {2} {3} 0 1 0 {1} 1 0 1 {1,2} {2,3} {2} {2} ORTC: Third Pass Select next hops for prefixes and eliminate redundant information 1. Each node has a set of possible next hops 2. Each node will inherit a next hop from the closest ancestor 3. If this inherited next hop is a member of the node’s set of potential next hops, it does not need a next hop on its own 122 {2} {3} 0 1 {1} 1 1 Optimal Routing Table Prefix Dst. * 2 01* 1 11* 3 Constructing an Optimal Routing Table 123 How to perform efficient Longest-Prefix Matching? Ternary Content-Addressable Memory (TCAM) A 100 Gbps link may carry approx 200 M packets per second (64-byte packets) • Only 5 ns time to perform lookup per packet! (without parallelization or pipelining) • From http://thyme.rand.apnic.net : 700’000 prefixes announced TCAM is a specialized type of high-speed memory • Searches entire content in single clock cycle • However, hierarchy is needed to handle large tables • Ternary: memory has three different states (0, 1, X) • Last state “X” referred to as “don't-care” or wildcard • Allows searches based on pattern-matching 124 Longest-Prefix Matching using TCAM • The wildcard state helps defining partial entries in the routing table • E.g., 10.11.12.* (resp. 10.11.12.0/24) • where * stands for any value in the last octet • Locate all possible matches in single cycle • Routing prefixes must be ordered by their prefix length • Priority encoder finds first match 125 10 11 12 00X 10 11 12 0X 10 11 12 1X X X X X Input: 10.11.12.65 more specific less specific .0100 0001 Match! TCAM Note: Numbers in blue and bold are in binary LPM using TCAM - Example 126 TCAM Power Consumption • Downside: expensive to build, consumes a lot of power, and thus generates a lot of heat that must be dissipated • TCAM consumes close to 30% of the overall power consumed by a high-end router • Prefix growth requires larger TCAM in routers! • Recent research: power-efficient TCAM cell, leveraging SRAM to emulate TCAM functionality, etc. 127 Finding Duplicates: Bloom Filter Problem: identify if an element is a duplicate Challenge: cannot store all previous elements Solution: Bloom filter provides probabilistic data structure for set membership testing • Setup: bit vector V with m bits, V = 0 • Insert element e • Compute k hash functions hi = Hi(e), where 0<hi<=m • Set all bits V[hi] = 1 • Test if element e’ has already been seen • Recompute k hash functions, test if all V[hi] =? 1 • If all bits are 1  “seen before”, otherwise “new” 128 • Initialization: • Insertion of e: H1(e) = 5, H2(e) = 2 • Test of e’=e: H1(e’) = 5, H2(e’) = 2 ⇒ seen before • Test of e’’≠e: H1(e’’) = 5, H2(e’’) = 1 ⇒ new • Test of e’’’≠e: H1(e’’’) = 2, H2(e’’’) = 5 ⇒ seen before? Bloom Filter 0 0 0 0 0 0 0 0 Bit Vector Index 7 0 0 0 1 0 0 1 0 0 Bit Vector 7 0 No FN, constant time insertion and test 129 • m: # of bits in BF • k: # of hash functions • n: # of inserted elements • P( FP ) = • k to minimize P(FP): k = • For that choice of k, resulting P(FP) = p = • Given optimal k, choice of optimal • Source: http://en.wikipedia.org/wiki/Bloom_filter Bloom Filter Parameters 130 Bloom Filter Size Examples • n = 10 6 • p = 1% • m = 9.6 * 10 6 bits ~ 1.2 Mbytes • k ~ 6.6  7 • With k = 7, p ~ 1% • p = 0.1% • m = 14.4 * 106 bits ~ 1.8 Mbytes • k = 10 131 How to Find Duplicates in Practice? • Problem: Bloom filter “fills up” • Simple approach: Reset Bloom filter periodically • Problems with simple approach? • Some false detections: fundamental problem with Bloom filters • Fail to provide “no FN” guarantee: some duplicates are not detected! • If duplicate arrives after reset, then it is not detected as duplicate 132 Duplicate Detection in Practice t I0 I1 I2 I3 I4 I5 Set Check Reset D0 D1 D2 D3 D2 D1 Expired FP TP 133 Duplicate Detection in Practice • Define maximum packet propagation time δ • Require time synchronization, max sync error σ • Split time up into time periods of duration Δ > δ + 2σ • Keep two Bloom filters B0 and B1 • B0 is reset at the beginning of time period i and filled during period i, where i mod 2 = 0 • Analogous for B1 • Each packet includes timestamp ts it is sent, in time period Ts • On packet arrival at router at tc, in time period Tc • Check if ts – σ ≤ tc ≤ ts + δ + σ; otherwise drop packet • Router checks both B0 and B1 to detect duplicate • If packet is not a duplicate, insert it into Bi where i = Tc mod 2 134 Details of Setting Time Duration • tsi: timestamp of packet i at sender, tci timestamp of arrival at router • δi: propagation delay of packet i • σ: max sync error • ⇒|(tsi + δ i) - tc|≤ σ • ⇒ tsi + δ i – σ ≤ tc ≤ tsi + δ i + σ • ⇒ ts – σ ≤ tc ≤ ts + δ + σ (because 0 ≤ δ i ≤ δ) • ⇒ For any claimed ts, packet is valid at router for at most δ + 2σ length of time • ⇒ If duration of time period Δ > δ + 2σ, packet is valid for at most two intervals (current and the next one) 135 Summary of Bloom Filters Basic operations • Insert an element • Membership test Properties • No FN, low FP • Time efficient: O(1) membership checking • Space efficient: constant number of bits per element for a given FP rate • But still O(N) memory overhead 136","libVersion":"0.3.2","langs":""}