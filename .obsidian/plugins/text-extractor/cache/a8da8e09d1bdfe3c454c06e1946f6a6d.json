{"path":"sem2/PProg/UE/s/PProg-u10-s.pdf","text":"Parallel Programming Assignment 10: Master Solution Spring Semester 2024 Dining Philosophers a) There is a possibility to deadlock: In the first step, each philosopher acquires the fork on their left side at the same time. Now that every philosopher has one fork in their left hand, they will try to pick up the fork on their right side, but this fork is already held by their neighbor. In this state, everyone waits for their neighbor on the right to release the fork, but since nobody has acquired both forks to eat, this will never happen and the philosophers will starve. The problem is that there is a cyclic dependency in the case described above: P1 waits for P5, P5 waits for P4, P4 waits for P3, P3 waits for P2, and P2 waits for P1. b) The correct solution is to break the cyclic dependency. This means that one philosopher, e.g. philoso- pher P5 has to pick up the forks in a different order. This could be achieved by introducing a order between the forks, and all the philosophers have to pick up the fork with the lower order first. This resolves the deadlock, because there are no cyclic dependencies any more. Note that introducing a timeout will not solve the problem: Even if the philosophers would release the fork after some time of waiting, it could still happen that they would do this at the same time. This would be a livelock, where all philosophers would constantly acquire and release the fork on their left, but nobody would get to eat. c) As there are only five forks and every philosopher needs two forks to eat, the maximum amount of philosophers eating concurrently is two, however there is a possibility that only one philosopher is eating. Consider P2, P3, P4 each acquiring the fork on their left und P1 acquires both forks. Nobody else, except P1 can now eat. All solutions to fix that problem require the philosophers to communicate in some way, i.e., intro- ducing a single lock for a pair of forks, or forming a queue of waiting philosophers and a central arbiter (”waiter”) which selects which philosopher can eat next. Monitors, Conditions and Bridges Find the solution in solution10.zip on the course web-page. Semaphores and Databases Find the solution in solution10.zip on the course web-page. a) See code. b) See code. As you can see in the code, once all threads have reached the barrier, we can simply set current = 0. As this is not possible with a Semaphore a more complicated construction with two Semaphores (“turnstyles”) is necessary. This was discussed in the lectures slide. c) The main difference is in how the waiting is implemented. • The simplest implementation uses a spin lock (loop checking the condition). The main reasons for this is its simplicity. Usually it has bad performance. • A better implementation uses Monitors. In one has understood Monitors and there is an effi- cient implementation to hand (i.e. in Java) then this is also a simple solution. Compared to spin locks the performance should be much better. • A third implementation could make use of queues. For example a semaphore could put all the waiting threads in a FIFO queue. And whenever more threads can be admitted (release() was called) the first thread of the queue is taken. Especially on systems that don’t provide a monitor implementation, this provides a simple alternative. 2","libVersion":"0.3.2","langs":""}