{"path":"sem4/DMDB/VRL/extra/slides/DMDB-s-w01-intro.pdf","text":"Data Modeling and Databases Spring Semester 2025 Administrative Introduction Introduction Gustavo Alonso Institute of Computing Platforms Department of Computer Science ETH Zürich 1 Administration Introduction 2 About us • Prof. Gustavo Alonso • Data Management • Distributed Systems • Cloud and Data Center Architecture • Head TA: Vasilis Mageirakos • Systems Group (systems.ethz.ch) • https://systems.ethz.ch/ • Covers wide rage of system related topics, including data processing and data management • Ample experience with database system design, including products and open source Introduction 3 Course organization • Lectures will be in the classroom and recorded • No live streaming • Exercises sessions will be in-person and not recorded • E-Exam (Moodle) in the exam session (August 2025) • Material (slides & exercises) available in the course Moodle • Exercises start in the third week • Exercises are not graded Introduction 4 Course Materials • We will use some textbooks but also other material • Standard database textbooks (next slide) • Manuals and product guides • Articles and specialized books • Reading material and references will be provided in the slides and in the web pages Introduction 5 Textbooks https://textbooks.inf.ethz.ch/lectures/4th-semester/49/ • [Hector] Garcia-Molina, [Jeffrey] Ullman, [Jennifer] Widom, \"Database systems : the complete book“ 2014 => ONLINE VERSION • Alfons Kemper, André Eickler, \"Datenbanksysteme : eine Einführung“ 2015 • Ramez A. Elmasri, Shamkant B. Navathe, \"Grundlagen von Datenbanksystemen“ 2009 • Alfons Kemper, Martin Wimmer, \"Übungsbuch Datenbanksysteme“ 2012 (Sometimes we also take content from this theory book. But you do not need to have it for the exam) Introduction 6 We are here to help you learn • The goal is that at the end of the course you: • Can program in SQL • Understand the basics of data management • Are familiar with the data structures and algorithms used in engines • Have a basic idea of the architecture of data processing systems • Q&A Forum on Moodle • Send email to TA list (sg-dmdb@lists.inf.ethz.ch) • Also feel free to drop us an email if you want to talk about research: DB systems, data processing in the cloud, hardware acceleration, ML systems … Introduction 7 Following the lecture • The course is not difficult • The material is not extensive • But it takes time to understand, especially the connections between the different parts • Language = SQL • Data Structures and Algorithms = indexes, operators, concurrency • System = optimization, memory management, architecture • Strongly recommended to follow the course and do the exercises as we go along. It is difficult to catch up during the summer if you do not attend the lectures Introduction 8 Why studying data management? Introduction 9 Motivation for the course • Data has become a precious commodity • Data Management has become a crucial component in IT • Data Management concepts and how to deal with large data collections in an efficient and effective manner is fundamental knowledge any computer scientist should have • The course will provide a broad perspective on data management systems, from traditional relational database engines to modern cloud data processing architectures Introduction 10 Why data management engines? • Databases and data management are at the heart of many key applications • The “assembly code” of data science • Organizing and processing information • Data management engines • Architecture and algorithms • Scalability and distribution • Cloud and new hardware • What you learn here will help you be more effective as a computer scientist or as a scientist dealing with data Introduction 11 A Database System (DBMS) • A DBMS is a tool that helps develop and run data-intensive applications. • Push the complexity of dealing with the data (storage, processing, consistency) to the database rather than to the program • Share the database • The Database is a tool • Many shapes and forms • Many applications Introduction 12 Why use a DBMS? • Avoid redundancy and inconsistency • Rich (declarative) access to the data • Synchronize concurrent data access • Recovery after system failures • Security and privacy • Facilitate reuse of the data • Reduce cost and pain of doing something useful • There is always an alternative!!! Introduction 13 How does a database look like • Until recently, a database often meant a relational database • Today, there are many forms of data management engines (or databases) • Principles and ideas behind relational databases apply to almost all forms of data management Introduction 14 Database Architecture Physical storage Blocks, files, segments Pages in memory Physical records Logical records (tuples) Logical data (tables, schemas) Relations, views Queries, Transactions (SQL) Record Interface Record Access Page access File Access Application Logical view (logical data) Access Paths Physical data in memory Page structure Storage allocation Introduction 15 Database Architecture (another view) https://docs.oracle.com/cd/E11882_01/server.112/e40540/pro cess.htm#CNCPT902 Introduction 16 The cloud • The cloud is the huge game changer: • New business model • Economies of scale • CapEx becomes OpEx • The cloud has brought higher efficiency through resource sharing … • … but has also changed the way we need to look at the problem … • … and the economics of computing https://www.mckinsey.com/industries/technology-media-and-telecommunications/our- insights/how-high-tech-suppliers-are-responding-to-the-hyperscaler-opportunity Introduction 17 Databases in the cloud Introduction 18 Databases in the cloud : Amazon Redshift Introduction https://docs.aws.amazon.com/redshift/latest/dg/c_high_level_system_architecture.html 19 A very rich space Introduction 20 SQL Accelerators From Oracle M7 documentation Introduction 21 New database architectures Introduction https://pages.awscloud.com/AQUA_Preview.html 22 A brief history of databases https://dsf.berkeley.edu/cs286/papers/goesaround-redbook2005.pdf Introduction 23 Hierarchical Model • At the very beginning, there was the hierarchical model. • IBM IMS (1968 – today) • and it still runs in many places! Introduction 24 IMS - Data Model • Data Model • Record Type: • Supplier, Part • Instance: • (id=0, name=ABB, country=CH) is an instance of the Record Type Supplier • Database Schema • A hierarchy of Record Types • Database Instance • A hierarchy of Instances ABB Part 1 Part 2 Part 1.1 Part 1.2 Supplier Part Schema Database Swisscom Introduction 25 IMS – Query Language • Query Language: • Record-at-a-time • Essentially traversal of the tree Supplier Part ABB Part 1 Part 2 Part 1.1 Part 1.2 Schema Database 01 DLI-FUNCTIONS. 05 DLI-GU PIC X(4) VALUE 'GU ‘. 05 DLI-GHU PIC X(4) VALUE 'GHU ‘. 05 DLI-GN PIC X(4) VALUE 'GN ‘. 05 DLI-GHN PIC X(4) VALUE 'GHN '. 05 DLI-GNP PIC X(4) VALUE 'GNP '. 05 DLI-GHNP PIC X(4) VALUE 'GHNP'. 05 DLI-ISRT PIC X(4) VALUE 'ISRT'. 05 DLI-DLET PIC X(4) VALUE 'DLET'. 05 DLI-REPL PIC X(4) VALUE 'REPL'. 05 DLI-CHKP PIC X(4) VALUE 'CHKP'. 05 DLI-XRST PIC X(4) VALUE 'XRST'. 05 DLI-PCB PIC X(4) VALUE 'PCB '. Get Unique Get Next Get Next within Parent https://www.tutorialspoint.com/ims_db Swisscom Introduction 26 IMS – Query Language Supplier Part ABB Part 1 Part 2 Part 1.1 Part 1.2 Schema Database https://www.tutorialspoint.com/ims_db Get unique Supplier (sname = \"ABB\") Until failure do Get next within parent (color = red) Enddo SwissCom Q2: Find all red parts supplied by supplier ABB …Hmm… This could be difficult (at least, unnatural) Q1: Find all suppliers for part A Part Supplier Better Schema for Q1 It might be difficult to have a single schema that provides a natural way to support both Q1 and Q2. Introduction 27 IMS – Limitation Supplier Part ABB Part 1 Part 2 Part 1.1 Part 1.2 Schema Database Swisscom ▪ Physical Data Independence: application should not know how data are stored. ➢ If your data is not really a tree, you end up storing redundant information. ➢ Redundancy is not only about space -- it is also one root causes of inconsistency. (e.g., Someone updated ABB/Part1 not SwissCom/Part1) ABB Part 1 Part 1.1 Part 1.2 Swisscom Part 1 Part 1.1Introduction 28 IMS –- Limitation Supplier Part ABB Part 1 Part 2 Part 1.1 Part 1.2 Schema Database SwissCom ▪ Data Independence: application should not know how data are stored. ➢ Requires changing the application (i.e., queries) when the physical data representation changes. ➢ It also causes problem when new functionalities require a different physical representation. Supplier Part Schema 1 Part Supplier Schema 2 Get unique Supplier (sname = \"ABB\") Until failure do Get next within parent (color = red) Enddo Q2: Find all red parts supplied by supplier ABB Introduction 29 IMS – Recap Supplier Part ABB Part 1 Part 2 Part 1.1 Part 1.2 Schema Database SwissCom • Data Model • Record Type, Instance, A hierarchy of Record Types • Query Language: • Record-at-a-time, Essentially traversals the tree • Problem 1: A hierarchical model might be too restrictive for many applications (and forcing a non-hierarchical apps into a tree-based model might cause problems such as data redundancy) • Problem 2: Do not provide (physical) data Independency. Require application changes when the physical data representation changes. • Problem 3: Require manual query optimization. When data distribution/application changes, re-optimization might be necessary. • There are applications in which all above problems are not really problems, for which IMS is a powerful tool (i.e., you are still triggering a lot of IMS queries every day) Introduction 30 Network Model -- Data Model • CODASYL Data Model (1969) • First integrated into COBOL • Data Model • Record Type: • Supplier, Part • Instance: • (0, ABB, CH) is an instance of the Record Type Supplier • Database Schema / Instance • Not a tree, but a network of Record Types / Instances Supplier Part ABB Part 1 Part 2 Schema Database SwissCom Supply supplies supplied_by Supply1 Supply2 Supply3 Introduction 31 Network Model -- Query Supplier Part ABB Part 1 Part 2 Schema Database SwissCom Supply supplies supplied_by Supply1 Supply2 Supply3 ▪ Query Language: ➢ Record-at-a-time ➢ Essentially traversals of the network Find Supplier (sname = \"B\") Until no-more { Find next Supply record in Supplies Find owner Part record in Supplied_by Get current record -check for red— } Q2: Find all red parts supplied by a supplier B Introduction 32 Network Model -- Query Supplier Part ABB Part 1 Part 2 Schema Database SwissCom Supply supplies supplied_by Supply1 Supply2 Supply3 ▪ Query Language: ➢ Record-at-a-time ➢ Essentially traversals the network Find Part (pname = \"A\") Until no-more { Find next Supply record in Supplied_by Find owner Supplier record in Supplies Get current record -do whatever—} Q1: Find all suppliers for part A Both queries are natural, compared with the hierarchical model. Introduction 33 Network Model -- Limitation Supplier Part ABB Part 1 Part 2 Schema Database SwissCom Supply supplies supplied_by Supply1 Supply2 Supply3 ▪ Data Independence: application should not know how data are stored. ➢ Same problem as the hierarchical model. Introduction 34 Network Model -- Limitation Supplier Part ABB Part 1 Part 2 Schema Database SwissCom Supply supplies supplied_by Supply1 Supply2 Supply3 ▪ Declarative Efficient Data Access: The system should be able to store and retrieve data efficiently, without users worrying about it (too much) ➢ Again, same problem as the hierarchical model. Find Supplier (sname = \"B\") Until no-more { Find next Supply record in Supplies Find owner Part record in Supplied_by Get current record -- check pname = \"A\" -- } Q3: Find all parts A supplied by supplier B Find Part (pname = \"A\") Until no-more { Find next Supply record in Supplied_by Find owner Supply record in Supplies Get current record -- check sname = \"B\" -- } Which query is faster depends on the data. Introduction 35 Network Model -- Recap Supplier Part ABB Part 1 Part 2 Schema Database SwissCom Supply supplies supplied_by Supply1 Supply2 Supply3 • Data Model • Record Type, Instance, A network of Record Types • Query Language: • Record-at-a-time, Essentially traversals the network • Problem 1: Do not provide (physical) data Independency. Require application changes when the physical data representation changes. • Problem 2: Require manual query optimization. When data distribution/application changes, re-optimization might be necessary. • Still needs a lot of work maintaining an application (whenever there is a change) • This inspired the relational model, the focus of our course. Introduction 36 Relational Model • Relational Model (1969) • Edgar F. Codd • One of the most popular today, the focus of this course • How does it work? • What are the advantages? • What are the limitations? Introduction 37 Relational Model -- Data Model • Data Model • Relations: Set of tuples of the same type (similar to Record Type) • Instance: • (0, ABB, CH) is an instance of the Supplier Relation • Database Schema • A set of relations • Database Instance • A set of instances for each relation. Database Supplier Part Schema Supply supplies supplied_by Supplier Part Schema Supplier Part Supply Schema sid sname country pid pnamesid pid … Supplier Supply Part Introduction 38 Relational Model -- Query • Query Language • Set-at-a-time • Set operations over relations ▪ Query Language: ➢ Record-at-a-time ➢ Essentially traversals the network Find Part (pname = \"A\") Until no-more { Find next Supply record in Supplied_by Find owner Supplier record in Supplies Get current record -do whatever—} Q1: Find all suppliers for part A {(𝑟, 𝑝): 𝑟 ∈ 𝑆𝑢𝑝𝑝𝑙𝑖𝑒𝑠 ∧ 𝑝 ∈ 𝑃𝑎𝑟𝑡𝑠 ∧ 𝑟. 𝑝𝑖𝑑 = 𝑝. 𝑝𝑖𝑑 ∧ 𝑝. 𝑛𝑎𝑚𝑒 = “𝐴”} SELECT S.sid, S.sname FROM Supplies S, Parts P WHERE S.pid = P.pid AND P.pname = \"A\"; Introduction 39 Relational Model -- Query • Query Language • Set-at-a-time • Set operations over relations ▪ Query Language: ➢ Record-at-a-time ➢ Essentially traversals the network Find Supplier (sname = \"B\") Until no-more { Find next Supply record in Supplies Find owner Part record in Supplied_by Get current record -check for red— } Q2: Find all red parts supplied by a supplier B SELECT * FROM Suppliers S1, Supplies S2, Parts P WHERE S1.sid = S2.sid AND S2.pid = P.pid AND S1.sname = \"B\" and P.color = \"red\"; {(𝑠, 𝑟, 𝑝): 𝑠 ∈ 𝑆𝑢𝑝𝑝𝑙𝑖𝑒𝑟𝑠 ∧ 𝑟 ∈ 𝑆𝑢𝑝𝑝𝑙𝑖𝑒𝑠 ∧ 𝑝 ∈ 𝑃𝑎𝑟𝑡𝑠 ∧ 𝑠. 𝑠𝑖𝑑 = 𝑟. 𝑠𝑖𝑑 ∧ 𝑟. 𝑝𝑖𝑑 = 𝑝. 𝑝𝑖𝑑 ∧ 𝑠. 𝑠𝑛𝑎𝑚𝑒 = ”𝐵” ∧ 𝑝. 𝑐𝑜𝑙𝑜𝑟 = “𝑟𝑒𝑑”} Introduction Relational Model ▪ Data Independence: application should not know how data are stored. ➢ The query assumes that relation is a BAG of examples, no assumptions on how data are stored and represented. ➢ Query won’t change if physical data representation changes. SELECT S.sid, S.sname FROM Supplies S, Parts P WHERE S.pid = P.pid AND P.pname = \"A\"; {(𝑟, 𝑝): 𝑟 ∈ 𝑆𝑢𝑝𝑝𝑙𝑖𝑒𝑠 ∧ 𝑝 ∈ 𝑃𝑎𝑟𝑡𝑠 ∧ 𝑟. 𝑝𝑖𝑑 = 𝑝. 𝑝𝑖𝑑 ∧ 𝑝. 𝑛𝑎𝑚𝑒 = “𝐴”} Introduction 41 Relational Model SELECT S.sid, S.sname FROM Supplies S, Parts P WHERE S.pid = P.pid AND P.pname = \"A\"; ▪ Declarative Efficient Data Access: The system should be able to store and retrieve data efficiently, without users worrying about it (too much) ➢ Queries are declarative (e.g., the query on the left -- it never specifies whether we should fetch tuple from Parts first or from Supplies first) ➢ This enables automatic query optimization in which the system automatically chooses the best execution plan. ➢ (Compare with the following imperative query in the network model) {(𝑟, 𝑝): 𝑟 ∈ 𝑆𝑢𝑝𝑝𝑙𝑖𝑒𝑠 ∧ 𝑝 ∈ 𝑃𝑎𝑟𝑡𝑠 ∧ 𝑟. 𝑝𝑖𝑑 = 𝑝. 𝑝𝑖𝑑 ∧ 𝑝. 𝑛𝑎𝑚𝑒 = “𝐴”} Find Part (pname = \"A\") Until no-more { Find next Supply record in Supplied_by Find owner Supplier record in Supplies Get current record -do whatever—} Introduction 42 The “Great Debate” (SIGMOD 1974) • It wasn’t clear whether the Relational Model is better than Network Model in the beginning. a) Nothing as complex as CODASYL can possibly be a good idea b) CODASYL does not provide acceptable data independence c) Record-at-a-time programming is too hard to optimize d) CODASYL and IMS are not flexible enough to easily represent common situations a) COBOL programmers cannot possibly understand the new-fangled relational languages b) It is impossible to implement the relational model efficiently c) CODASYL can represent tables, so what’s the big deal? Relational Advocate Network Advocate Lots of research into this - Both Sides Improved Over Time. - Market Chose Relational Model. Introduction 43 Recap • We have seen three different DMBS models --- hierarchical, network, & relational --- with two very different flavors --- declarative & imperative. • We see the importance of data indepedence and declarative performance optimization to the usability of a DMBS. • Designing data models and query languages are not trivial. Google Cloud Introduction 44 Lessons learned • The history of the relational model contains several important lessons: • How you store, place in memory, and query data are three different things • If they are tied together, things become difficult (physical data independence) • Writing programs for extracting knowledge out of data is not efficient • Writing queries that involve knowing how the data is organized is not efficient • The relational model won because it provided physical (and logical) data independence, and adopted relational algebra to reason about how data is manipulated and combined. Introduction 45","libVersion":"0.3.2","langs":""}