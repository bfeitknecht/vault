{"path":"sem4/FMFP/UE/s/FMFP-u06-s.pdf","text":"Formal Methods and Functional Programming Solutions Sheet 6 252-0058-00L March 24, 2025 1. Induction on Trees Proof. Let f::a->b and g::b->c be arbitrary functions. We show that ∀t::(Tree a). mapTree g (mapTree f t) = mapTree (g.f) t Let P:= mapTree g (mapTree f t) = mapTree (g.f) t, and we prove by induc- tion that ∀ t::(Tree a).P. Base Case: We show that P[t↦→Leaf] holds. mapTree g (mapTree f Leaf)= -- mapTree.1 mapTree g Leaf = -- mapTree.1 Leaf = -- mapTree.1 (reversed) mapTree (g.f) Leaf Step Case: Let x::a, l::Tree a, r::Tree a be arbitrary. We show that P[t↦→l] and P[t↦→r] imply P[t↦→Node x l r]. Hence assume IH:=P[t↦→l] , P[t↦→r]. mapTree g (mapTree f (Node x l r)) = -- mapTree.2 mapTree g (Node (f x) (mapTree f l) (mapTree f r)) = -- mapTree.2 Node (g (f x)) (mapTree g (mapTree f l)) (mapTree g (mapTree f r)) = -- IH Node (g (f x)) (mapTree (g.f) l) (mapTree (g.f) r) = -- def (.) Node ((g.f) x)) (mapTree (g.f) l) (mapTree (g.f) r) = -- mapTree.2 mapTree (g.f) (Node x l r) 2. Evaluation (a) Lazy evaluation: (\\x -> x (\\y -> x y)) (\\x -> (\\y -> y) x) t2 is substituted without evaluation = (\\x -> (\\y -> y) x) (\\y -> (\\x -> (\\y -> y) x) y) t2 is substituted without evaluation = (\\y -> y) (\\y -> (\\x -> (\\y -> y) x) y) 1 Formal Methods and Functional Programming Solutions Sheet 6 252-0058-00L March 24, 2025 t2 is substituted without evaluation = (\\y -> (\\x -> (\\y -> y) x) y) evaluation stops since no evaluation under an abstraction (b) Eager evaluation: (\\x -> x (\\y -> x y)) (\\x -> (\\y -> y) x) since t1 is evaluated, t2 is evaluated (prior to substitution) = (\\x -> x (\\y -> x y)) (\\x -> x) substitution of t2 = (\\x -> x) (\\y -> (\\x -> x) y) since evaluation is carried out under an abstraction and since t2 is evaluated prior to substitution, we obtain = (\\x -> x) (\\y -> y) substitution of t2 = \\y -> y evaluation stops since there is no application left 3. More Induction Consider the generalized statement P := ∀n::Int. sum (toList t) + n = addSum t n. Proof. We prove ∀t::Tree.P by structural induction on Tree. Base case: Fix an arbitrary x::Int and we show P[t↦→Leaf x]. Let n::Int be arbitrary. 2 Formal Methods and Functional Programming Solutions Sheet 6 252-0058-00L March 24, 2025 sum (toList (Leaf x)) + n = -- toList.1 sum [x] + n = -- sum.2 (x + sum []) + n = -- sum.1 (x + 0) + n = -- arith x + n = -- addSum.1 addSum (Leaf x) n Step Case: Let l::Tree and r::Tree be arbitrary. Assume IH.l:= P[t↦→l] and IH.r:=P[t↦→r], then show P[t↦→Node l r]. Let n::Int be arbitrary. sum (toList (Node l r)) + n = -- toList.2 sum (toList l ++ toList r) + n = -- Lem. 1 (sum (toList l) + sum (toList r)) + n = -- arith sum (toList l) + (sum (toList r) + n) = -- IH.l addSum l (sum (toList r) + n) -- IH.r addSum l (addSum r n) = -- addSum.2 addSum (Node l r) n Thus, in particular, sum (toList t) = addSum t 0 by arithmetic. Alternative solution: First prove that ∀ n. addSum t n = addSum t 0 + n by induction on Tree. Then, the original statement can be proven directly by induction. 3","libVersion":"0.5.0","langs":""}