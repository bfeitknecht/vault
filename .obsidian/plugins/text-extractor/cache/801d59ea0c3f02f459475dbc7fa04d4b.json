{"path":"sem3/TI/UE/s/TI-s-u03.pdf","text":"Departement Informatik Theoretische Informatik Prof. Dr. Dennis Komm Prof. Dr. Juraj Hromkoviˇc Dr. Hans-Joachim B¨ockenhauer Exemplary Solutions – Sheet 3 Z¨urich, October 11, 2024 Solution to Task 7 We use an indirect proof. Assume there were an infinite number of prime numbers that can be considered as random. By the definition, this means that there are infinitely many k ∈ N − {0} such that K(pk) ≥ ⌈log2(pk + 1)⌉ − 1 ≥ log2(pk) − 1 , (1) where pk denotes the k-th prime number. Moreover, for each m ∈ N − {0}, the m-th prime number pm can be computed by a Pascal program Cm that contains the binary encoding of m and tests, for all natural numbers in increasing order, whether they are prime (Erathostenes’ sieve) and outputs the m-th found prime number. All parts of this program, except for the binary representation of m, are of constant length. Thus, Cm has a length of ⌈log2(m + 1)⌉ + c ≤ log2 m + c′, for some constants c and c′ = c + 1. Let n ∈ N and let Prim(n) be te number of prime numbers less or equal n. Following the Prime Number Theorem, for all n > 67, we have that Prim(n) < n ln n − 3 2 . Since, by definition, we also have that m = Prim(pm), we get Prim(pm) = m < pm ln(pm) − 3 2 and finally K(pm) ≤ log2 ( pm ln(pm) − 3 2 ) + c′ = log2(pm) − log2 (ln(pm) − 3 2 ) + c′ . (2) From the two bounds (1) and (2) for the Kolmogorov complexity, we conclude that log2(pl) − 1 ≤ log2(pl) − log2 ( ln(pl) − 3 2 ) + c′ has to hold for infinitely many l ∈ N. This implies that these values l also satisfy log2 (ln(pl) − 3 2 ) ≤ c′ + 1 , which is impossible since c′ is a constant and log2(ln(pl) − 3/2) is growing with pl. Thus, our assumption was wrong and the claim follows. Solution to Task 8 (a) The following finite automaton accepts the language L1 = {w ∈ {a, b}∗ | w contains the subword abba}. q0 q1 q2 q3 q4 b a a b b a a b a, b This yields the following classes: Kl[q0] = {wbbb ∈ {a, b} ∗ | w does not contain the subword abba} ∪ {λ, b, bb} , Kl[q1] = {wa ∈ {a, b}∗ | wa does not contain the subword abba} , Kl[q2] = Kl[q1] · {b} , Kl[q3] = Kl[q2] · {b} = {a, b}∗ − (Kl[q0] ∪ Kl[q1] ∪ Kl[q2] ∪ L1) , Kl[q4] = L1. (b) We notice that L2 has the following alternative characterisation L2 = {w ∈ {a, b}∗ | |w|a ̸≡ |w|b (mod 2)} = {w ∈ {a, b} ∗ | |w| ≡ 1 (mod 2)}. Thus, L2 is accepted by this finite automaton: q0 q1 a, b a, b Its states induce the following classes: Kl[q0] = {w ∈ {a, b}∗ | |w| ≡ 0 (mod 2)} , Kl[q1] = {w ∈ {a, b}∗ | |w| ≡ 1 (mod 2)} = L2. Solution to Task 9 We notice that the state q4 is a trap state, i.e., if M reaches q4 while reading a word, it will stay in q4 and the input is not accepted. We further notice that M only ends up in q0 or q1 on words of the form ak for k ∈ N. More precisely, we have Kl[q0] = {a2k | k ∈ N} , Kl[q1] = {a2k+1 | k ∈ N}. If M reads the symbol b while in q1, it ends up in the trap state q4. If it reads b while in q0, it moves to q2 and then ‘measures’ the parity of the number of b’s in the suffix of the 2 given word by switching between q2 and q3. If M is in q2 or q3 and reads an a, it moves to the trap state. Thus we have Kl[q2] = Kl[q0] · {b2l+1 | l ∈ N} = {a2kb2l+1 | k, l ∈ N} , Kl[q3] = Kl[q0] · {b2l+2 | l ∈ N} = {a2kb2l+2 | k, l ∈ N} , Kl[q4] = {a, b}∗ − (Kl[q0] ∪ Kl[q1] ∪ Kl[q2] ∪ Kl[q3]). This yields L(M ) = Kl[q0] ∪ Kl[q3] = {a2kb2l | k, l ∈ N}. 3","libVersion":"0.5.0","langs":""}