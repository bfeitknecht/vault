{"path":"sem3/DMath/UE/s/DMath-s-u09.pdf","text":"ETH Z ¨urich, D-INFK HS 2024, 22. November 2024 Prof. Ueli Maurer Giovanni Deligios, Dr. Karen Klein Diskrete Mathematik Solution 9 9.1 Diffie-Hellman a) Let g ∈ ⟨Zn; ⊕⟩ be the generator, which Alice and Bob use as the basis. Alice chooses xA at random from {0, . . . , n − 1} and sends yA = Rn(g · xA). Analogously, Bob chooses xB at random from {0, . . . , n − 1} and sends yB = Rn(g · xB). The established shared key is kAB = Rn(g · xA · xB). As shown in Example 5.27, we have gcd(g, n) = 1. Therefore, Eve can use the Ex- tended GCD algorithm to efficiently find an a ∈ Z such that a · g ≡n 1. Then she can compute kAB using the eavesdropped messages yA and yB as kAB = Rn(a · yA · yB). This is because kAB ≡n g · xA · xB ≡n g · xA · (a · g) · xB ≡n a · (g · xA) · (g · xB) ≡n a · yA · yB b) Let us make Bob’s argument more explicit: The Diffie-Hellman protocol using a cyclic group G = ⟨g⟩ is insecure if the discrete logarithm problem in G is easy. Since by Theorem 5.7 there exists an isomorphism φ : G → Zn, one can compute x such that gx = h by instead computing x such that φ(g)x = φ(h). Since this can be done efficiently (both φ(g) and φ(h) are in Zn), Bob concludes that the discrete logarithm problem is easy in all cyclic groups. Bob’s argument is incorrect, because the above procedure is efficient only if the iso- morphism φ can be efficiently computed, which is not always the case. For example, computing the isomorphism given in the proof of Theorem 5.7 requires solving the discrete logarithm problem in G (so Bob’s procedure would give no advantage). 9.2 The Group Z∗ m a) The order of the group ⟨Z∗ 36; ⊙⟩ is φ(36). By Lemma 5.12, φ(36) = (2 − 1) · 22−1 · (3 − 1) · 3 2−1 = 2 · 2 · 3 = 12. Z∗ 36 consists of all numbers in Z36 which are relatively prime with 36, that is, Z∗ 36 = {1, 5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35}. b) We will verify for each a ∈ Z∗ 11 whether it is a generator (but more efficiently than by computing ⟨a⟩). An a ∈ Z∗ 11 is a generator if and only if ord(a) = 10. By Lagrange’s Theorem, ord(a) ∈ {1, 2, 5, 10}, so a is a generator if and only if ord(a) /∈ {1, 2, 5}, that is, if and only if a ̸= 1, a2 ̸= 1 and a5 ̸= 1. We can now compute R11(a2) and R11(a5) for all a ∈ {2, . . . , 10}. The generators are 2, 6, 7 and 8. Note. Another way to solve this exercise for any ⟨Z∗ m; ⊙⟩ is to first use Theorem 5.15 to determine whether ⟨Z∗ m; ⊙⟩ is cyclic. If so, it is isomorphic to ⟨Zφ(m); ⊕⟩. Now we find one generator g of Z∗ m (by trying all possibilities) and prove that for any i ∈ Zφ(m), gi is a generator if and only if gcd(i, φ(m)) = 1 (see Example 5.27). c) We prove that f : Z∗ nm → Z∗ n × Z∗ m, defined by f (x) = (Rn(x), Rm(x)) is an isomor- phism. Throughout the proof we will use the fact that gcd(Rm(x), m) = gcd(x, m) for any x, m, which follows from Lemma 4.2. f is a function. We show that f (x) ∈ Z∗ n × Z∗ m for all x ∈ Z∗ nm. Let x ∈ Z∗ nm, which means that gcd(x, nm) = 1. Let d = gcd(x, n). Then, d | x and d | n, which implies that d | x and d | nm, so by the definition of gcd, d | gcd(x, nm). Hence, d | 1, so d = 1. Therefore, gcd(Rn(x), n) = gcd(x, n) = 1, so Rn(x) ∈ Z∗ n. The proof that Rm(x) ∈ Z∗ m is analogous. f is surjective. Take any (a, b) ∈ Z∗ n × Z∗ m. Since gcd(m, n) = 1, by CRT, there exists an x ∈ Znm such that (Rn(x), Rm(x)) = (a, b). To show that x ∈ Z∗ nm, assume towards a contradiction that d = gcd(x, nm) > 1. Let p be an arbitrary prime in the decomposition of d. Since p | mn, by Lemma 4.7, p | n or p | m. In the first case, since also p | x, we get p | gcd(x, n). But gcd(x, n) = gcd(Rn(x), n) = gcd(a, n) = 1 (because a ∈ Z∗ n), so this is a contradiction. Analogously, in the second case we get p | gcd(b, m). f is injective. By CRT, the x defined above is unique in Znm, hence, it is also unique in Z∗ nm. f is a homomorphism. For any a, b ∈ Z∗ nm, f (a ⊙nm b) =(Rn(a ⊙nm b), Rm(a ⊙nm b)) =(Rn(Rnm(ab)), Rm(Rnm(ab))) =(Rn(ab), Rm(ab)) =(Rn(Rn(a) · Rn(b)), Rm(Rm(a) · Rm(b))) =(Rn(a) ⊙n Rn(b), Rm(a) ⊙m Rm(b)) =(Rn(a), Rm(a)) ⋆ (Rn(b), Rm(b)) 1 =f (a) ⋆ f (b). 9.3 An RSA Attack First, consider the case when n1, n2 and n3 are not relatively prime. Without loss of gen- erality, assume that gcd(n1, n2) > 1. We can now use the Extended GCD algorithm to compute p = gcd(n1, n2) and this way efficiently factorize n1. This allows us to compute the secret key of Alice and decrypt c1. 1The operation ⋆ on Z ∗ n × Z ∗ m is defined as (a1, b1) ⋆ (a2, b2) := (a1 ⊙n a2, b1 ⊙m b2). Secondly, assume that n1, n2 and n3 are relatively prime. Consider the following system of congruence equations: x ≡ c1 (mod n1) x ≡ c2 (mod n2) x ≡ c3 (mod n3) Let N = n1n2n3. Using the Chinese Remainder Theorem, we can efficiently find the solu- tion x0 to the above system of equations, such that 0 ≤ x0 < N . Notice now that m3 is also a solution to the system of equations, because ci ≡ m3 (mod ni) for i ∈ {1, 2, 3}. Moreover, since 0 ≤ m < ni for i ∈ {1, 2, 3}, we have 0 ≤ m3 < n1 ·n2 ·n3 = N . Since by the Chinese Remainder Theorem x0 is unique in {0, . . . , N − 1}, it follows that x0 = m3. What is left is to compute the cube root of x0 over Z, which can be done efficiently. Note. This attack is also possible for e > 3. However, for given e one needs e ciphertexts, each encrypted for a different recipient. 9.4 Elementary Properties of Rings a) We have (−a)b + ab distrib. = (−a + a)b def. inverse = 0b Lemma 5.17 (i) = 0. Therefore, (−a)b is the additive inverse of ab, which means that (−a)b = −ab. b) We have (−a)(−b) + (−(ab)) a) = (−a)(−b) + (−a)b distrib. = (−a)(−b + b) def. inverse = (−a)0 Lemma 5.17 (i) = 0. Therefore, (−a)(−b) is the additive inverse of −(ab), which means that (−a)(−b) = −(−(ab)) = ab. 9.5 More Elementary Properties of Rings a) In a previous version of this exercise the assumption that R is an integral domain was missing. However, the statement is false for general rings. To see this consider the ring ⟨Z8; ⊕8, 0, ⊙8, 1⟩. Consider the elements a = 2, b = 4 ∈ Z8, and let n = 3 and m = 5. Clearly, we have gcd(3, 5) = 1. Also, we have 2 3 = 8 ≡8 0 2 5 = 32 ≡8 0 4 3 = 64 ≡8 0 4 5 = 1024 ≡8 0 (1) however 2 ̸≡8 4. Assuming that R is an integral domain, the statement is true. First observe that if either m or n is 1 the statement is trivial. Therefore we can assume that m, n > 1. By Corollary 4.5 there exist integers x and y such that 1 = mx + ny. Observe that x and y have opposite signs. We know x ̸= 0, because otherwise ny = 1 which means n = 1. Similarly we get y ̸= 0. Therefore, if x > 0, then mx > 1 which in turn implies that 1 − mx = ny < 0, and because n is positive then y is negative. Assume without loss of generality that x > 0. In this case we can write 1 = mx − n(−y) or equivalently 1 + n(−y) = mx. From this we get a · (an) −y = a1+n(−y) = amx = (a m) x = (b m) x = b mx = b 1+n(−y) = b · (b n)−y = b · (a n) −y (2) Because R is an integral domain, from the equality a · (an) −y = b · (a n) −y we conclude that a = b by Lemma 5.20. If y < 0 the proof is identical writing 1 + m(−x) = ny. b) The statement is true. Let x = (1 − ab)−1. We have (1 − ba)(1 + bxa) = 1 − ba + (1 − ba)bxa (Distributivity) = 1 − ba + bxa − babxa (Distributivity) = 1 − ba + b(xa − abxa) (Distributivity) = 1 − ba + b((1 − ab)xa) (Distributivity) = (1 − ba) + ba = 1 ((1 − ab)x = 1 and − ba + ba = 0). (3) Similarly, (1 + bxa)(1 − ba) = 1 + bxa − ba − bxaba (Distributivity) = 1 − ba + bxa − bxaba (Distributivity) = 1 − ba + (bx − bxab)a (Distributivity) = 1 − ba + bx(1 − ab)a (Distributivity) = (1 − ba) + ba = 1 (x(1 − ab) = 1 and − ba + ba = 0). (4) 9.6 Properties of Commutative Rings a) From a|b it follows that ∃d b = ad and, thus, bc = (ad)c = a(dc). Hence, a|bc. b) From a|b it follows that ∃d b = ad and from a|c it follows that ∃e c = ae. By the distributive law, we have b + c = ad + ae = a(d + e). Hence, a|(b + c). 9.7 Ideals in Rings a) We have 0 = x0 ∈ (x). Let a, b ∈ (x). Than a = xk1 and b = xk2 for k1, k2 ∈ Z, so that a + b = x(k1 + k2) ∈ (x). This shows that (x) is an additive subgroup of R. Let a ∈ (x) and z ∈ Z. We have az = (xk)z = x(kz) ∈ (x) for some k ∈ Z. This shows that (x) is closed under multiplication by elements of Z. b) Let I be an ideal of Z. If I = {0} then I = (0). Let d be the smallest positive element of I. Suppose d ̸= 1. Let x ∈ I. We can write x = qd + r with 0 ≤ |r| < d. We can also rewrite this as r = x − qd, and since both x and qd are elements of I, then r ∈ I. We can assume r ≥ 0 (otherwise, −r ∈ I is positive). But then r is positive and smaller than d which means r = 0 by assumption on d. This shows I = (d). c) First of all 0 = 0x+0y ∈ (x, y). Also, if a, b ∈ (x, y) then a = xk1+yℓ1 and b = xk2+yℓ2 for some k1, k2, ℓ1, ℓ2 ∈ R. Therefore a + b = x(k1 + k2) + b(ℓ1 + ℓ2) ∈ (x, y). This shows that (x, y) is an additive subgroup of R. Let a ∈ (x, y) and r ∈ R. Then ar = (xk + yℓ) = x(kr) + y(ℓr) ∈ (x, y). This shows that (x, y) is closed under multiplication by elements of R. d) Suppose that there exists p(x) ∈ Z[x] such that (p(x)) = (2, x). If deg p(x) ≥ 1, then the product of deg p(x)f (x) ≥ 1 for all 0 ̸= f ∈ Z[x], so that 2 /∈ (p(x)). Suppose then that deg p(x) = 0. Since p(x) ∈ I, then p(x) = 2k for some k ∈ Z. But then p(x)f (x) ⇐⇒ (2k)(f (x)) = x. If a is the coefficient of the first degree term of f (x), we would have (2k)a = 2(ka) = 1, but 2 does not have an inverse in Z. This concludes the proof. The proof of subtask b) does not go through here because we cannot perform division with remainder in Z[x].","libVersion":"0.3.2","langs":""}