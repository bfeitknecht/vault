{"path":"sem4/FMFP/PV/exams/30-finals/FMFP-FS09.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Repetition Exam September 12th, 2009, 10:00 – 12:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Exam.-Nr.: 0 General Comments: 1. Check that your exam papers are complete (7 assignments). 2. Do not write on the exam sheets. Use a separate sheet of paper for every assignment and write your name on each of them. Additional sheets are available from the assistants. 3. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no prepared notes, etc. Do not use a pencil (Bleistift) and do not use the color red. 4. You may write your answers in English or German. Important: Write clearly in the sense of logic, language, and readability. 5. If you have a question regarding the meaning of a problem statement, you may ask one of the assistants in charge of the exam. Assignment 1 2 3 4 5 6 7 ∑ Max. points 5 2 2 3 4 4 3 23 Your points Grade Functional Programming Formal Methods and Functional Programming, Repetition Exam, FS09 0 Assignment 1: Typing, (3+2 points) Recall the types of the following functions from the Prelude: head :: [a] -> a 1 :: Num a => a (>) :: Ord a => a -> a -> Bool (a) Give the most general type for each of the following functions: 1. (\\a b c -> c b a) 2. (\\b -> ((\\x -> x), b 1)) 3. (\\xs x -> head xs True > x) (b) Recall the proof rules for the mini-Haskell type system: . . . , x : a, . . . ⊢ x :: a A ⊢ n :: Int A ⊢ True :: Bool A ⊢ False :: Bool A, x : σ ⊢ t :: τ A ⊢ (λx. t) :: σ → τ x /∈ A A ⊢ t1 :: σ → τ A ⊢ t2 :: σ A ⊢ (t1 t2) :: τ A ⊢ t :: Int A ⊢ (iszero t) :: Bool A ⊢ t1 :: Int A ⊢ t2 :: Int A ⊢ (t1 op t2) :: Int op ∈ {+, ×} A ⊢ t1 :: τ1 A ⊢ t2 :: τ2 A ⊢ (t1, t2) :: (τ1, τ2) A ⊢ t :: (τ1, τ2) A ⊢ (snd t) :: τ2 Formally prove the following typing judgement using the typing rules above: ⊢ (λc. (λx. iszero (c x))) (λx. snd x) :: (a, Int) → Bool Formal Methods and Functional Programming, Repetition Exam, FS09 1 Assignment 2: Induction, (2 points) Consider the following functions. rev :: [a] -> [a] rev [] = [] -- rev.1 rev (x:xs) = rev xs ++ [x] -- rev.2 (++) :: [a] -> [a] -> [a] (++) [] ys = ys -- app.1 (++) (x:xs) ys = x : (xs ++ ys) -- app.2 Formally prove that rev (xs ++ rev ys) = ys ++ rev xs holds for all xs and ys of type [a]. Hint: You can use the following lemmas without proof. Lemma 1: ∀xs::[a]. rev (rev xs) = xs. Lemma 2: ∀xs::[a]. xs ++ [] = xs. Lemma 3: ∀a,b,c::[a]. (a ++ b) ++ c = a ++ (b ++ c). Hint: Take care that all your stated claims are explicit about the quantiﬁcation of vari- ables, and justify all reasoning steps. Formal Methods and Functional Programming, Repetition Exam, FS09 2 Assignment 3: Lists, (2 points) Write a function risers :: Ord a => [a] -> [[a]] that splits a list xs :: [a] into the list of longest non-empty monotonically rising subsequences of xs. Example: risers [1,3,3,4,1,0,2,6] = [[1,3,3,4],[1],[0,2,6]] Assignment 4: Higher-Order Functions, (1+1+1 points) For a Tetris clone in Haskell, we chose to represent Tetris blocks by the datatype Block. data Dir = Left | Right | Up | Down data Block = Tile [(Dir, Block)] A value of type Dir denotes a unit movement in the corresponding direction. A value Block bs denotes a central tile and a list bs of neighboring blocks. The location of each neighboring block is given relative to the central tile. Assuming that the initial central tile is located at (0, 0), the value blockS :: Block blockS = Tile [(Left, Tile []), (Up, Tile [(Right, Tile [])])] corresponds to the following drawing. y x .. . . (0, 0)(−1, 0) (1, 1) (0, 1) Left Up Right (a) Write a function mapDir :: (Dir -> Dir) -> Block -> Block such that mapDir f b applies f to every direction in the block b. (b) Use the function mapDir to write a function rotateCw :: Block -> Block rotating the given block by 90 degrees clockwise around the initial central tile. (c) Write a function foldBlock :: ([(Dir,a)] -> a) -> Block -> a such that foldBlock f b folds the block b to a value of type a by recursively folding its neigh- boring blocks and combining the results using f. Formal Methods Syntax and Semantics of IMP Syntax Statements of the programming language IMP are given by the grammar s ::= skip ∣ ∣ x := e ∣ ∣ s; s ∣ ∣ if b then s else s end ∣ ∣ while b do s end where x ranges over the variables, e ranges over the arithmetic expressions, and b ranges over the Boolean expressions. Natural Semantics ⟨skip, σ⟩ → σ ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ → γ ⟨s2, γ⟩ → σ′ ⟨s1; s2, σ⟩ → σ′ ⟨s1, σ⟩ → σ′ ⟨if b then s1 else s2 end, σ⟩ → σ′ B[[b]]σ = tt ⟨s2, σ⟩ → σ′ ⟨if b then s1 else s2 end, σ⟩ → σ′ B[[b]]σ = ﬀ ⟨s, σ⟩ → γ ⟨while b do s end, γ⟩ → σ′ ⟨while b do s end, σ⟩ → σ′ B[[b]]σ = tt ⟨while b do s end, σ⟩ → σ B[[b]]σ = ﬀ Structural Operational Semantics ⟨skip, σ⟩ →1 σ ⟨x := e, σ⟩ →1 σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ →1 σ′ ⟨s1; s2, σ⟩ →1 ⟨s2, σ′⟩ ⟨s1, σ⟩ →1 ⟨s′ 1, σ′⟩ ⟨s1; s2, σ⟩ →1 ⟨s′ 1; s2, σ′⟩ ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s1, σ⟩ B[[b]]σ = tt ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s2, σ⟩ B[[b]]σ = ﬀ ⟨while b do s end, σ⟩ →1 ⟨if b then s; while b do s end else skip end, σ⟩ Axiomatic Semantics { P } skip { P } { P [x ↦→ e] } x := e { P } { P } s1 { R } { R } s2 { Q } { P } s1; s2 { Q } { b ∧ P } s1 { Q } { ¬B[[b]] ∧ P } s2 { Q } { P } if b then s1 else s2 end { Q } { B[[b]] ∧ P } s { P } { P } while b do s end { ¬B[[b]] ∧ P } { P ′ } s { Q′ } { P } s { Q } P ⇒ P ′ and Q′ ⇒ Q Formal Methods and Functional Programming, Repetition Exam, FS09 5 Assignment 5: Operational Semantics, (2+2 points) (a) Consider the following IMP statement w: while x # 0 do y := y * y; x := x - 1 end Use the natural semantics to prove that there is a state σ′ with σ′(y) = 16 such that ⟨w, σ⟩ → σ′, where σ is a state with σ(x) = 2 and σ(y) = 2. (b) Consider the extension of IMP with the operator par for parallel execution. The rules for the statement s1 par s2 in the structural operation semantics is as follows: ⟨s1, σ⟩ →1 ⟨s′ 1, σ′⟩ ⟨s1 par s2, σ⟩ →1 ⟨s′ 1 par s2, σ′⟩ ⟨s1, σ⟩ →1 σ′ ⟨s1 par s2, σ⟩ →1 ⟨s2, σ′⟩ ⟨s2, σ⟩ →1 ⟨s′ 2, σ′⟩ ⟨s1 par s2, σ⟩ →1 ⟨s1 par s′ 2, σ′⟩ ⟨s2, σ⟩ →1 σ′ ⟨s1 par s2, σ⟩ →1 ⟨s1, σ′⟩ Give two statements s1 and s2 such that for all states σ, the derivation sequences starting from the conﬁgurations ⟨s1, σ⟩ and ⟨s2, σ⟩ terminate but there is a deriva- tion sequence starting from ⟨s1 par s2, σ⟩ that does not terminate. Justify why ⟨s1 par s2, σ⟩ might not terminate. Assignment 6: Hoare Logic, (4 points) Consider the following IMP statement s, which checks whether x has any nontrivial divisor: y := 2; z := 0; while (y < x and z = 0) do if (x = y * (x/y)) then z := 1 else y := y + 1 end end Use Hoare logic to prove that the IMP statement s satisﬁes the Hoare triple { x is prime } s { z = 0 } You may present your proof as an inference tree or as a proof outline. Recall that an integer p is prime iﬀ p > 1 and ∀q. (2 ≤ q < p) =⇒ ¬(∃q′. qq′ = p). Formal Methods and Functional Programming, Repetition Exam, FS09 6 Assignment 7: Linear Temporal Logic (LTL), (1+2 points) Consider the following LTL formulas over the set AP = {p, q} of atomic propositions: ϕ = 2 ((3 p) ∧ ⃝ ⃝ q) ψ = ((¬p) U q) ∨ 2 ¬p (a) Give traces t and t ′ such that t |= ϕ and t′ |= ψ. (b) Which of the formulas ϕ and ψ describe safety properties? Justify your answers by using the deﬁnition of safety.","libVersion":"0.5.0","langs":""}