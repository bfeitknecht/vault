{"path":"HS23/AuD/UE/s/AuD-u13-s.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 18 December 2023 Johannes Lengler, David Steurer Lucas Slot, Manuel Wiedmer, Hongjie Chen, Ding Jingqiu Algorithms & Data Structures Exercise sheet 13 HS 23 This exercise sheet is not to be turned in. The solutions will be published at the end of the week, before Christmas. Exercise 13.1 Shortest path with negative edge weights (part I). Let G = (V, E, w) be a graph with edge weights w : E → Z and wmin = mine∈E w(e). Since Dijkstra’s algorithm must not be used whenever some edge weights are negative (i.e., wmin < 0), one could come up with the idea of applying a transformation to the edge weight of every edge e ∈ E, namely w′(e) = w(e) − wmin + 1, such that all weights become positive, and then find a shortest path P in G by running Dijkstra with these new edge weights w′. Show that this is not a good idea by providing an example graph G with a weight function w, such that the above approach finds a path P that is not a shortest path in G (this path P can start from the vertex of your choice). The example graph should have exactly 5 nodes and not all weights should be negative. Solution: Consider for example the following graph: s u w v t 1 1 1 -1-1 We have that wmin = mine∈E w(e) = −1, thus we add the value 1 − (−1) = 2 to every edge weight to obtain the following transformed graph: s u w v t 3 3 3 11 A shortest s-t-path in the transformed graph is (s, u, v, t). However, there is a shorter path in the original graph since the vertices (u, v, w, u) form a cycle with negative weight. Hence, for an arbitrary s-t-path in the original graph, we can always find a path with smaller weight by following this cycle once more. Exercise 13.2 Shortest path with negative edge weights (part II). We consider the following graph: 1 2 3 6 5 4 3 5 1 4 4 1 1 -4 5 1 2 2 (a) What is the length of the shortest path from vertex 1 to vertex 6? Solution: The shortest path from vertex 1 to vertex 6 is (1, 3, 5, 2, 6) and has length 5 − 4 + 1 + 1 = 3. (b) Consider Dijkstra’s algorithm (that fails here, because the graph has negative edge weights). Which path length from vertex 1 to vertex 6 is Dijkstra computing? State the sets S, V \\ S immediately before Dijkstra is making its first error and explain in words what goes wrong. Solution: With Dijkstra’s algorithm we find the path (1, 2, 6) that has length 4. The first mistake happens after having processed vertex 1. The sets at that point in time are S = {1} and V \\ S = {2, 3, 4, 5, 6}. To vertex 2, we know a path of length 3, to vertex 3 a path of length 5. To the other vertices, we do not know a path so far. Hence, Dijkstra’s algorithm chooses vertex 2 to continue, i.e., includes 2 into S, which corresponds to the assumption that we already know the shortest path to this vertex. This is clearly a mistake, since the path (1, 3, 5, 2) has only length 2. (c) Which efficient algorithm can be used to compute a shortest path from vertex 1 to vertex 6 in the given graph? What is the running time of this algorithm in general, expressed in n, the number of vertices, and m, the number of edges? Solution: We can use the algorithm of Bellman and Ford which runs in O(nm) time. (d) On the given graph, execute the algorithm by Floyd and Warshall to find all shortest paths. Express all entries of the (6 × 6 × 7)-table as 7 tables of size 6 × 6. (It is enough to state the path length in the entry without the predecessor vertex.) Mark the entries in the table in which one can see that the graph does not contain a negative cycle. Solution: Each of the following tables corresponds to a fixed value k ∈ {0, 1, 2, 3, 4, 5, 6} and contains the lengths of all shortest paths that use only interior vertices in {1, . . . , k}. Since all entries on the diagonal are non-negative, we can conclude that the graph does not contain any negative cycle. 2 from\\to 1 2 3 4 5 6 1 0 3 5 ∞ ∞ ∞ 2 1 0 4 ∞ 4 1 3 ∞ ∞ 0 1 -4 ∞ 4 ∞ ∞ ∞ 0 5 ∞ 5 ∞ 1 ∞ 2 0 ∞ 6 ∞ ∞ ∞ ∞ 2 0 k = 0 from\\to 1 2 3 4 5 6 1 0 3 5 ∞ ∞ ∞ 2 1 0 4 ∞ 4 1 3 ∞ ∞ 0 1 -4 ∞ 4 ∞ ∞ ∞ 0 5 ∞ 5 ∞ 1 ∞ 2 0 ∞ 6 ∞ ∞ ∞ ∞ 2 0 k = 1 from\\to 1 2 3 4 5 6 1 0 3 5 ∞ 7 4 2 1 0 4 ∞ 4 1 3 ∞ ∞ 0 1 -4 ∞ 4 ∞ ∞ ∞ 0 5 ∞ 5 2 1 5 2 0 2 6 ∞ ∞ ∞ ∞ 2 0 k = 2 from\\to 1 2 3 4 5 6 1 0 3 5 6 1 4 2 1 0 4 5 0 1 3 ∞ ∞ 0 1 -4 ∞ 4 ∞ ∞ ∞ 0 5 ∞ 5 2 1 5 2 0 2 6 ∞ ∞ ∞ ∞ 2 0 k = 3 from\\to 1 2 3 4 5 6 1 0 3 5 6 1 4 2 1 0 4 5 0 1 3 ∞ ∞ 0 1 -4 ∞ 4 ∞ ∞ ∞ 0 5 ∞ 5 2 1 5 2 0 2 6 ∞ ∞ ∞ ∞ 2 0 k = 4 from\\to 1 2 3 4 5 6 1 0 2 5 3 1 3 2 1 0 4 2 0 1 3 -2 -3 0 -2 -4 -2 4 7 6 10 0 5 7 5 2 1 5 2 0 2 6 4 3 7 4 2 0 k = 5 from\\to 1 2 3 4 5 6 1 0 2 5 3 1 3 2 1 0 4 2 0 1 3 -2 -3 0 -2 -4 -2 4 7 6 10 0 5 7 5 2 1 5 2 0 2 6 4 3 7 4 2 0 k = 6 Exercise 13.3 Invariant and correctness of algorithm (This exercise is from the January 2020 exam). Given is a weighted directed acyclic graph G = (V, E, w), where V = {1, . . . , n}. The goal is to find 3 the length of the longest path in G. Let’s fix some topological ordering of G and consider the array top[1, . . . , n] such that top[i] is a vertex that is on the i-th position in the topological ordering. Consider the following pseudocode: Algorithm 1 Find-length-of-longest-path(G, top) L[1], . . . , L[n] ← 0, . . . , 0 for i = 1, . . . , n do v ← top[i] L[v] ← max (u,v)∈E {L[u] + w((u, v) )} return max 1≤i≤n L[i] Here we assume that maximum over the empty set is 0. Show that the pseudocode above satisfies the following loop invariant INV(k) for 1 ≤ k ≤ n: After k iterations of the for-loop, L[top[j]] contains the length of the longest path that ends with top[j] for all 1 ≤ j ≤ k. Specifically, prove the following 3 assertions: i) INV(1) holds. ii) If INV(k) holds, then INV(k + 1) holds (for all 1 ≤ k < n). iii) INV(n) implies that the algorithm correctly computes the length of the longest path. State the running time of the algorithm described above in Θ-notation in terms of |V | and |E|. Justify your answer. Solution: Proof of i). In the first iteration we have v = top[1]. By the definition the first vertex in topological order has no incoming edges. Thus, L[top[1]] gets assigned the maximum over the empty set, which we assume to be 0. As a consequence, INV(1) holds as there is no longest path that ends at top[1] and L[top[1]] = 0. Proof of ii). In the (k + 1)-th iteration we have v = top[k + 1]. By the definition of topological ordering we have that all u ∈ V with (u, top[k + 1]) ∈ E are in {top[1], . . . , top[k]}. The length of the longest path via u ending at v can be decomposed into the length of the longest path ending at u plus the weight of the edge (u, v). Therefore, given INV(k), i.e., L[top[j]] contains the length of the longest path for all 1 ≤ j ≤ k, the maximum max (u,v)∈E {L[u] + w((u, v))} computes the length of the longest path ending at v. Consequently, INV(k + 1) holds given INV(k) holds. Proof of iii). IN V (n) implies that each entry L[v] contains the length of the longest path ending at v. Thus, com- puting the maximum max 1≤i≤n L[i] corresponds to computing the length of the longest path in G. 4 Running time: The running time is in Θ(|E| + |V |). The loop takes time Θ(|E| + |V |) since ∑v∈V deg−(v) = |E|, and taking the maximum at the end takes time Θ(|V |). Exercise 13.4 Cheap flights (This exercise is from the January 2020 exam). Suppose that there are n airports in the country Examistan. Between some of them there are direct flights. For each airport there exists at least one direct flight from this airport to some other airport. Totally there are m different direct flights between the airports of Examistan. For each direct flight you know its cost. The cost of each flight is a strictly positive integer. You can assume that each airport is represented by its number, i.e. the set of airports is {1, . . . , n}. (a) Model these airports, direct flights and their costs as a directed graph: give a precise description of the vertices, the edges and the weights of the edges of the graph G = (V, E, w) involved (if possible, in words and not formal). Solution: Each airport is a vertex in the directed graph. Two vertices u, v ∈ V are connected by a directed edge e ∈ E, if there exists a direct flight starting from airport u to airport v. The weight w(e) of the edge e = (u, v), is the cost of the direct flight from u to v. Notice that the graph might not be connected, but |E| ≥ |V |, since “For each airport there exists at least one direct flight from this airport to some other airport.” In points (b) and (c) you can assume that the directed graph is represented by a data structure that allows you to traverse the direct predecessors and direct successors of a vertex u in time O(deg−(u)) and O(deg+(u)) respectively, where deg−(u) is the in-degree of vertex u and deg+(u) is the out-degree of vertex u. (b) Suppose that you are at the airport S and you want to fill the array d of minimal traveling costs to each airport. That is, for each airport A, d[A] is a minimal cost that you must pay to travel from S to A. Name the most efficient algorithm that was discussed in lectures which solves the corresponding graph problem. If several such algorithms were described in lectures (with the same running time), it is enough to name one of them. State the running time of this algorithm in Θ-notation in terms of n and m. Solution: Name of the algorithm used to solve this problem: Dijkstra’s Algorithm Runtime: O(m+n log n) if implemented with Fibonnachy heap, O((m+n)·log n) if implemented with binary heap. (c) Now you want to know how many optimal routes there are to airport T . In other words, if cmin is the minimal cost from S to T then you want to compute the number of routes from S to T of cost cmin. Assume that the array d from (b) is already filled. Provide an as efficient as possible dynamic pro- gramming algorithm that takes as input the graph G from task (a), the array d from point (b) and the airports S and T , and outputs the number of routes from S to T of minimal cost. 5 Address the following aspects in your solution and state the running time of your algorithm: 1) Definition of the DP table: What are the dimensions of the table DP [. . .]? What is the meaning of each entry? 2) Computation of an entry: How can an entry be computed from the values of other entries? Specify the base cases, i.e., the entries that do not depend on others. 3) Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps? 4) Extracting the solution: How can the final solution be extracted once the table has been filled? 5) Running time: What is the running time of your algorithm? Provide it in Θ-notation in terms of n and m, and justify your answer. Hint: Note that the array d is a part of the input, so you don’t need to include the time that is required to fill this array to the running time here. Solution: Size of the DP table / Number of entries: We use a 1-dimensional DP table consisting of n entries. Meaning of a table entry: DP [i] is the number of optimal routes from S to the airport i. Computation of an entry (initialization and recursion): DP [S] = 1. If d[v] = ∞, DP [v] = 0. If v ̸= S and d[v] < ∞, then DP [v] = ∑ u:(u,v)∈E d[u]+w((u,v))=d[v] DP [u] . Order of computation: The order of the array d. That is, if d[i] < d[j], then i is before j in this order. Computing the result: The result is contained in DP [T ]. Running time in concise Θ-notation in terms of n and m. Justify your answer. We need Θ(n log n) time to sort the array d. To fill the DP table we need Θ(n + m), since the time required to compute DP [v] is Θ(deg−(v) + 1), and ∑ v∈V Θ(deg−(v) + 1) = Θ(n + m). Hence the running time of the algorithm described above is Θ(n log n + m). Exercise 13.5 Elevator. Consider the following definitions for a directed graph G = (V, E): 1. The out-degree of a vertex v ∈ V , denoted with degout(v), is the number of edges of E that start at v, i.e., degout(v) = |{(v, w) ∈ E | w ∈ V }|. 2. The in-degree of a vertex v ∈ V , denoted with degin(v), is the number of edges that end at v, i.e., degout(v) = |{(u, v) ∈ E | u ∈ V }|. 6 3. A Eulerian walk is a sequence v1, . . . , vk ∈ V such that k = |E| + 1 and {(vi, vi+1) | 1 ≤ i < k} = E. Note that this definition implies (vi, vi+1) being different edges for 1 ≤ i < k. In this exercise, you can use without proof the following result: Lemma 1. A directed graph G = (V, E) admits a Eulerian walk if, and only if, all of the following conditions holds: 1. At most one vertex v ∈ V is such that degout(v) = degin(v) + 1; 2. At most one vertex v ∈ V is such that degin(v) = degin(v) + 1; 3. Every vertex that satisfies neither (i) nor (ii) is such that degout(v) = degin(v); 4. The undirected graph G′ obtained by ignoring the direction of edges in G is connected. (a) Write down the pseudocode of an O(|V | + |E|) time algorithm that takes as input a directed graph G, and returns true if G has a Eulerian walk, and false otherwise. Justify its correctness and complexity. Solution: See Algorithm 2. At the exam, a more informal description would have been accepted too! For conditions 1-3, it is sufficient to compute the set of in- and out-neighbors (or simply the degrees) of all nodes and check the equations. This can be done straightforwardly in time O(|V | + |E|). For conditions 4, we perform a DFS from any vertex (here, vertex 0) on the undirected graph and check whether all vertices are marked (i.e., reached) by the algorithm. This can be done in O(|V | + |E|) (DFS) and O(|V |) (reachability check) respectively. In total, the complexity of our algorithm in O(|V | + |E|). (b) Alice is launching iFahrstuhl™, a start-up developing the next generation of elevators. Assume a building with n floors indexed from 1 to n and an elevator which has room for a single person. The elevator receives requests in the form of pairs (i, j) ∈ {1, . . . , n}2 of distinct floors between which a single person is willing to travel. Consider the scenario where m people want to use the elevator. For 1 ≤ t ≤ m, the t-th people want to go from floor it to floor jt. These requests are given as a finite set S = {(i1, j1), . . . , (im, jm)}. A finite set S = {(i1, j1), . . . , (im, jm)} of requests is called optimal if the pairs can be ordered such that all requests can be processed and the elevator is never empty when moving between two floors (except maybe on its way to fetching the first person). For example, for n = 5, the set S1 = {(2, 3), (4, 1), (3, 4)} is optimal, since it can ordered as {(2, 3), (3, 4), (4, 1)}, which means that the elevator can start on floor 2 to fetch person 1, go to floor 3, drop person 1 and fetch person 3, go to floor 4, drop person 3 and fetch person 2, go to floor 1, drop person 2, and terminate there. However, the set S2 = {(2, 3), (4, 1)} is not optimal, since there is no way a single elevator can satisfy both requests without moving empty from floor 3 to floor 4 or floor 1 to floor 2. Given a set of requests S, Alice’s elevators should be able to decide whether it’s optimal. Model the problem of detecting optimal sets of requests as a graph problem and provide an algorithm to solve it. Describe the vertex and edge set, edge weights (if needed), the graph problem you solve, the algorithm you use, and its complexity. To obtain full points, your algorithm should run in time O(n + |S|). 7 Algorithm 2 Check if a directed graph has a Eulerian path function DFS(in neighbors, out neighbors, v, marked) if marked[v] then continue else marked[v] ← True for w ∈ in neighbors[v] ∪ out neighbors[v] do DFS(in neighbors, out neighbors, w, marked) function CheckEulerian(V ,E) if |V | = 0 then return True out neighbors ← array[|V |] ▷ Initialized to ∅ in neighbors ← array[|V |] ▷ Initialized to ∅ for (v, w) ∈ E do ▷ Compute neighbors out neighbors[v] ← out neighbors[v] ∪ {w} in neighbors[w] ← in neighbors[w] ∪ {v} has plusone, has minusone = False, False ▷ Check conditions 1-3 for v ∈ V do if |out neighbors[v]| = |in neighbors[v]| then continue else if |out neighbors[v]| = |in neighbors[v]| + 1 then if has plusone then return False else has plusone = True else if |out neighbors[v]| = |in neighbors[v]| − 1 then if has minusone then return False else has minusone = True else return False marked ← bool[|V |] ▷ Initialized to False DFS(in neighbors, out neighbors, 0, marked) for v ∈ V do ▷ Check condition 4 if ¬marked[v] then return False return True 8 Solution: The problem is equivalent to the existence of an Euler path in the unweighted directed graph G1 = (V1, E1) defined by V1 = {1, . . . , n} E1 = S. We can use the algorithm from question (a) to find this Euler path. Its complexity is O(|V1|+|E1|) = O(n + |S|). (c) Alice’s startup has installed k single-person elevators in your n-floor building. Unfortunately, not all elevators can reach all floors. Hence, for each elevator j ∈ {1, . . . , k}, you are given a set Fj ⊆ {1, . . . , n} of floors it can reach. When you arrive in front of an elevator j, say on floor f ∈ Fj, you can immediately call it, after which you have to wait until it reaches your floor from its current position, moving at the constant speed of 1 time unit per floor. When the elevator arrives, you choose the destination floor f ′ ∈ Fj, and the elevator brings you to this floor at the constant speed of 0.5 time units per floor (for security reasons, the elevator is slower when it is not empty). The time spent moving between elevators on the same floor, calling the elevator or choosing the destination floor is negligible, since you are very fast at interacting with elevators. You are alone in the building at floor 1, with each elevator j being initally located on floor fj. You would like to go to floor n. What is the minimal amount of time that you have to travel using Alice’s elevators? If you cannot reach floor n, then output ∞. Model the problem as a graph problem and provide an algorithm to solve it. Describe the vertex and edge set, edge weights (if needed), the graph problem you solve, the algorithm you use, and its complexity. To obtain full points, your algorithm should run in time O((n + K) log n), where K = ∑k j=1|Fj|2. Solution: The cost of your journey between s and d using a sequence of elevators j1, . . . , jp and the sequence of floors k′ 0 = s, . . . , k′ p−1, k′ p = d will be the sum of the time spent in the various elevators, i.e.∑p ℓ=1(2 · |k′ ℓ − k′ ℓ−1|), and the time spent waiting for each elevator when calling them from your starting point, i.e. ∑p ℓ=1 |fjℓ − k′ ℓ−1|. The total waiting time is ∑p ℓ=1(|fjℓ − k′ ℓ−1| + 2 · |k′ ℓ − k′ ℓ′−1|). We note (i) that as all speeds are positive, you will never need to go twice through the same floor, (ii) that using the same elevator twice is useless (better than using it twice a → b and a′ → b′, you could have used it a → b′), and (iii) that to move from a to b, you will always pick the nearest available elevator, which will be at its initial position (since by (ii) you did not yet use it). In the end, our problem is equivalent to finding the shortest-path between vertices s and d in the following weighted graph G2 = (V2, E2, w2): V2 = {1, . . . , n} E2 = {(a, b) | j ∈ {1, . . . , k}, a ∈ Fj, b ∈ Fj, a ̸= b} w2((a, b)) = min{|fj − a| + 2 · |b − a| | j ∈ {1, . . . , k} ∧ a, b ∈ Fj} As all weights are positive, we can use Dijkstra’s algorithm to find the shortest path. Its runtime is O((|V2| + |E2|) log |V2|). The number of vertices is |V2| = n and the number of edges is |E2| ≤∑k j=1(|Fj|(|Fj| − 1)) = O(K). Hence, the overall complexity is O((n + K) log n). 9 (d) Continue the setting of (c). Elevator doors in your building need maintenance, but the people in your building also need elevators. In your building, there is exactly one elevator door per elevator and floor, which needs to be functional in order for the elevator to be used from or to this floor. Even if a door is not functional, the elevator can still be used between all other floors where a functional door is present. Alice wants to select as many elevator doors as possible to be maintained during the next working day such that all floors can be reached from each other using the elevators and the remaining functional doors (those not in maintenance). Model the problem as a graph problem and provide an algorithm to solve it. Describe the vertex and edge set, edge weights (if needed), the graph problem you solve, the algorithm you use, and its complexity. To obtain full points, your algorithm should run in time O((n + K′) log(n + K′)), where K′ = ∑p j=1|Fj|. Hint: Consider the set of vertices V = {v1, . . . , vn} ∪ {w1, . . . , wn} ∪ {elevator1, . . . , elevatorj} and use subgraphs (“gadgets”) of the form wi1 wi2 . . . wiq vi1 vi2 . . . viq elevatorj 0 0 0 1 1 1 where Fj = {i1, . . . , iq}. Solution: Call the gadget above Gj. This gadget represents the inside of elevator j (elevatorj), its doors (wiℓ), and the floors it serves (viℓ). To move from, say, floor s to floor d, you start at vs, use the door ws, enter elevatorj that brings you to floor d, then use the door wd to leave the elevator, and end at vd. Putting door wiℓ in maintenance removes the edge (viℓ, wiℓ) from the graph, as this door is no longer usable. Consider G3 = ⋃k j=1 Gj. Finding the maximal number M of doors that you can that you can maintain to ensure that all floors remain reachable from each other is equivalent to finding the minimal number of doors m = K′ − M that you must keep in function to ensure the same property. Now, the value m is exactly the value of the minimum spanning tree of G3. We can use, e.g., Kruskal’s algorithm to compute it, resulting in a O(|E3| log |E3|) runtime, where E3 denotes the edge set of G3. Since |E3| = ∑k j=1(2|Fj|) = 2K′ = O(K′), we get an overall complexity of O(K′ log K′). 10","libVersion":"0.3.2","langs":""}