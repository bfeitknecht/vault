{"path":"sem4/CN/UE/s/CN-u10-s.pdf","text":"Exercise 10: CDNs, Video Streaming, Framing, and Error Correction Question 1: CDNs True or false? Question 1.1 Anycast-based CDNs have greater flexibility in load management than DNS-based ones. Solution: FALSE. Using a DNS-based CDNs allows the operator to choose which IP address to serve back to a requester of a hostname (and thus has greater flexibility). DNS-based CDNs work by configuring different DNS records at different DNS servers for the same IP address. When a user requests a file by resolving a URL with the specific domain name the different DNS records direct the user to the desired hosts. Load balancing of Anycast-based CDNs is at the mercy of the (BGP) routing at ISP-level. This works by multiple hosts announcing the same IP prefix and hoping for good load balancing by the BGP longest prefix matching. Question 1.2 Exclusively-anycast-based services may resolve the same domain name to different IP addresses for different clients. Solution: FALSE. DNS-based CDNs enable the freedom to choose for each client which IP address the name request resolves to. Anycast-based means that all the client get the same IP address, and that the routing from the client using this IP address then potentially will lead to another host. Question 1.3 For DNS-based CDNs, the content provider must dynamically rewrite URLs for each client request. Solution: FALSE. The rewriting is not done dynamically for each client request, but statically at the server. Each client is served the same HTML with URLs for CDN-hosted objects already rewritten. Question 2: Video Streaming Question 2.1 Assume you are watching a video on Netflix, and your buffer contains 30s of unplayed video when the player starts to download chunk X. Assume chunk X to be 1.4MB and 4s long, your link bandwidth to be 1Mbps and the RTT between you and Netflix CDN to be of 50ms. Assume that downloading chunk 1 X contains sending a request (with tiny size) and receiving the data. All other delays are negligible. Assume that the player is using a single persistent TCP connection to download the segments. • Do you experience rebuffering? • If not, how many seconds of unplayed video will your buffer contain after the download of chunk X? Solution: The buffer length at the end of the download of segment X Bx,bef ore will be the buffer you have when the download of segment X starts (Bx−1), minus the time needed for the chunk X to be downloaded (∆download). In formula: Bx,bef ore = Bx−1 − ∆download Bx,bef ore = 30s − ∆download The time needed to download chunk X is the sum of two different delays: transmission delay and propagation delay. Defining as size(X) the size of chunk X (in this case, 1.4MB), duration(X) as the length of X (in this case, 4s), and as C the link capacity, we obtain: ∆download = size(X) C + RT T ∆download = 1.4M B 1M bps + 50ms ∆download = 11.2s + 0.05s = 11.25s The buffer length before segment X is added then Bx,bef ore = 30s − 11.25s = 18.75s. Being Bx,bef ore > 0, you don’t experience rebuffering. The final buffer length once segment X is added is then: Bx = Bx,bef ore + duration(X) Bx = 18.75s + 4s = 22.75s 2 Question 2.2 Assume now that the chunk size of segment X in KB is ∼ P oisson(3700KB), meaning that the chunk size follows a discrete distribution with granularity of 1KB. What is the probability of rebuffering? Solution: Rebuffering events happen whenever the player empties the buffer before the next segment is completely downloaded. In other words, the probability of having a rebuffering event is the probability of the download time of chunk X being greater than the client buffer when the download of chunk X starts. In formula: Prebuf = P (∆download > Bx−1) Prebuf = P ( P oisson(3700KB) C + RT T > Bx−1) Prebuf = P ( P oisson(3700KB) 1M bps + 0.05s > 30s) Prebuf = P (P oisson(3700KB) > 29.95s ∗ 1M bps) Prebuf = P (P oisson(3700KB) > 29.95M b) To compute the solution we need all the values to have the same order of magnitude (29.95M b = 3743.75KB, as it is at a granularity of 1KB: P (P oisson(3700KB) > 3743.75KB) = P (P oisson(3700KB > 3744KB)): Prebuf = P (P oisson(3700KB) > 3744KB) Prebuf = 1 − P (P oisson(3700KB) ≤ 3744KB) Given that the Poisson distribution definition (P (x = k) = e−λλk k! ), and that P (x ≤ k) = ∑k i=0 e−λλ i i! we obtain: Prebuf = 1 − 3744∑ i=0 e −37003700 i i! = 1 − 0.768 = 0.23 Question 3: Video Streaming True or false? 3 Question 3.1 Video resolution is a synonym of video bitrate. Solution: FALSE. The bitrate is the amount of encoded video data sent from the server to the client. The resulting resolution is determined by the quality of encoding and the device context (i.e. screen size, DPI). For example, doubling device screen size while maintaining the same bitrate will not result in the same resolution. Question 3.2 In video streaming, the entire content is usually provided as a single continuous flow of bytes at once. Solution: FALSE. Usually the video is divided into video segments (“chunks”) that are provided separately. Question 3.3 Adaptation algorithms may vary depending on users’ devices. Solution: TRUE: • Video buffer size can vary across devices. A device with a large buffer may benefit from a different algorithm (or at least a differently tuned algorithm) than one with a very small buffer. • Different network patterns occur in different environments, for example a mobile environment is different from a home TV. • Depending on the device, there might be different requirements in terms of the so called Quality of Experience (e.g. HDTV users might need a higher video quality in comparison to mobile users for the same QoE). Question 3.4 Usually, all chunks of a particular video content are stored exclusively on a single server. Solution: FALSE. To enable load balancing, redundancy and fault tolerance, video content is replicated across multiple servers. Question 3.5 Video chunks duration is typically in the order of seconds. Solution: TRUE. The video is divided into chunks to allow bitrate adaptation. Network condition changes, and the ability to detect and respond to them, happen on the granularity of seconds. 4 Question 3.6 Video providers usually geographically replicate their video content. Solution: TRUE. By means of CDNs, providers aim to reduce the end to end latency within end users and to be more fault-tolerant. Question 4: Video Chunk Size In VOD (Video-On-Demand) video streaming, video is divided into chunks of equal length. Discuss briefly what is the tradeoff between short and long video chunks. Solution: Too short video chunks might overload the server with tons of HTTP requests. Also, under an encoding perspective, having too short video chunks might also increase the frequency of key frames, increasing the chunk size in bytes and becoming then less efficient. On the other hand, with short video chunks one can make fine-grained decisions as the bandwidth fluctuates, being quicker in adapting its rate. Due to this reactivity, also the risk of incurring in too frequent quality switches increases. Too long video chunks reduce the risk of frequent quality switches, at the price of having less reactivity to bandwidth fluctuations and higher risk of rebuffering. In fact, in the DASH architecture, a chunk is playable once it has been completely downloaded. Imagine a corner case, i.e. we use a single chunk for the whole video: we would have to wait until the whole video is downloaded before playing it! Question 5: Adapting Video Quality You are starting your brand new video streaming service. Should you deploy the logic for adapting video quality over time on the client or on the server? Discuss pros and cons. Solution: Both solutions are possible, but the most intuitive one is implementing it client side. There are few reasons behind it: client-side: • The client player has direct access to its state variable (e.g. buffer) and it can easily estimate it’s current download bandwidth. server-side: • With a client side implementation of ABRs the computation is offloaded to the client. Even with a really simple adaptation logic, if a server would have to take care by itself of these decisions for all of its clients (potentially 5 millions), the amount of resources allocated for this purpose would be non-negligible. • On the other side, a server side implementation does not disclose imple- mentation details: the proprietary logic of the provider is more protected and can’t be easily reverse engineered. 6","libVersion":"0.5.0","langs":""}