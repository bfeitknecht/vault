{"path":"var/export/TI-bf-u09.pdf","text":"Basil Feitknecht, 23-922-099, Camil Schmid, 23-944-234, Dennis Küenzi, 21-559-315 25 Let M be the given 1-tape TM. Then, consider the inner conﬁguration In(C) for a conﬁguration C ∈ Konf(M). Since M always halts, the inner conﬁgurations cannot be encountered more than once. Thus, an upper bound on the number of inner conﬁgurations yields an upper bound on the time complexity. Recall that an inner conﬁguration is of the form In(C) = (q, i, x, j), where q ∈ Q is the current state, x ∈ Γ∗ is the current word on the working tape, i denotes the index of the read head on the input tape and j denotes the index of the position of the read / write head on the working tape. Then we explore the upper bound for all possible inner conﬁgurations on input words of length n. The number of states is trivially exactly |Q|. The index of the read head is at most n + 1, where n = |w| plus one for the initial symbol, w0 = ¢. The word on the working tape x = 01i12i2 … (k − 1) ik−1kkkk … can be upper bounded as the ﬁrst k symbols have space complexity of at most s(n) given by the deﬁnition of M. Lastly, the index on the working tape is at most s(n) + 1, as that limits the length of the word written there with regards for the initial symbol. As we have upper bounded the number of inner conﬁgurations it follows that the time complexity of M respects the given constraint, TimeM (n) ∈ O(n ⋅ s(n) k). □ |InKonfM (n)| ≤ |Q| ⋅ (n + 1) ⋅ s(n) k−1 ⋅ (s(n) + 1) ≤ c ⋅ n ⋅ s(n) k ∈ O(n ⋅ s(n) k) 26 a) To prove is that for any two languages L1, L2 ∈ NTIME(f) it holds that L1 ∪ L2 ∈ NTIME(f). Notice that the given function f is time-constructible, since it grows monotonically and is always greater or equal to its input. By deﬁnition of NTIME, it holds that there exist two non-deterministic MTM M1, M2 that accept the given languages, i.e. L1 = L(M1) and L2 = L(M2). Then it's given that TimeM1(n), TimeM2(n) ∈ O(f(n)). This is deﬁned as the duration of the longest computation on all inputs of length n. Then construct a non-deterministic MTM M that non-deterministically simulates M1 and M2 on some input x of length n. If there exists an accepting computation in either M1 or M2 then M accepts x. If this isn't the case, M rejects. Thus M accepts exactly the union of the two languages, i.e. L(M) = M1 ∪ M2. By construction we have TimeM (n) = max{TimeM1(n), TimeM2(n)}. Thus it follows that TimeM (n) ∈ O(f(n)) and hence L1 ∪ L2 ∈ NTIME(f). Informally it can be argued that a non-deterministic MTM that accepts the union of the two languages takes at most as long as the longer one of the two non-deterministic MTM that accept either one. Since this is still within the bounds of the space complexity class deﬁned by f, the union of the languages is in the same time complexity class. □ b) Let M1 be a non-deterministic MTM that accepts L = L(M1) with TimeM (n) ∈ O(f(n)) and let M2 be a deterministic MTM that accepts L′ = L(M2) with TimeM2(n) ∈ O(f(n)), by the deﬁnitions of the complexity classes NTIME(f) and TIME(f). Then we prove that L − L′ ∈ NTIME(f) by describing the construction of a non-deterministic MTM M that accepts L − L′ = L(M) with TimeM (n) ∈ O(f(n)). For an input x of length n, ﬁrst M simulates M1 to determine if x ∈ L. If it isn't, M rejects x. Then in a second step, M simulates M2 on x and accepts if x ∉ L′, else it rejects. Hence L(M) = {x ∈ L : x ∉ L′} = L − L′, with TimeM (n) = TimeM1(n) + TimeM2(n) which is trivially in O(f(n)). Thus L − L′ ∈ NTIME(f) Informally this can be understood as stating that the problem of deciding the language L − L′ isn't any \"easier\" by subtracting all words of a language in deterministic time complexity, since TIME(t) ⊆ NTIME(t) for any function t by lemma 6.6. □ 27 Let's obtain a subset L′ ⊆ L such that L′ ∉ LRE. To construct it, consider all words wi ∈ L in canonical order such that the i- th TM Mi per canonical order of KodTM does not accept wi, i.e. L′ = {wi ∈ L ∣ Mi(wi) / C✓}. For the sake of contradiction, assume L′ ∈ LRE. Then there exists a TM M such that L(M) = L′ with index j ∈ N of the canonical order in KodTM. Case distinction on the word wj. If it's in the subset language wj ∈ L′, then M = Mj accepts it Mj(wj). By construction however, it holds that wj ∉ L(Mj) = L′. Contradiction. If wj ∉ L′, the TM rejects it Mj(wj), since L′ = L(Mj). By deﬁnition of the subset language however, this implies that wj ∈ L′. Contradiction. As both scenarios lead to a contradiction, our initial assumption must be wrong and hence it follows that L′ ∉ LRE. □ ⊢M ∗","libVersion":"0.5.0","langs":""}