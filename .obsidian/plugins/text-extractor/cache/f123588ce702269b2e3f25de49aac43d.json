{"path":"sem3/AuD/UE/e/AuD-u07-e.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 6 November 2023 Johannes Lengler, David Steurer Lucas Slot, Manuel Wiedmer, Hongjie Chen, Ding Jingqiu Algorithms & Data Structures Exercise sheet 7 HS 23 The solutions for this sheet are submitted at the beginning of the exercise class on 13 November 2023. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. Exercise 7.1 1-3 subset sums (1 point). Let A[1, . . . , n] be an array containing n positive integers, and let b ∈ N. We want to know if there exists a subset I ⊆ {1, 2, . . . , n}, together with multipliers ci ∈ {1, 3}, i ∈ I such that: b = ∑ i∈I ci · A[i]. If this is possible, we say b is a 1-3 subset sum of A. For example, if A = [16, 4, 2, 7, 11, 1] and b = 61, we could write b = 3 · 16 + 4 + 3 · 2 + 3 · 1. Describe a DP algorithm that, given an array A[1, . . . , n] of positive integers, and a positive integer b ∈ N returns True if and only if b is a 1-3 subset sum of A. Your algorithm should have asymptotic runtime complexity at most O(b · n). In your solution, address the following aspects: 1. Dimensions of the DP table: What are the dimensions of the DP table? 2. Subproblems: What is the meaning of each entry? 3. Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others. 4. Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps? 5. Extracting the solution: How can the solution be extracted once the table has been filled? 6. Running time: What is the running time of your solution? Exercise 7.2 Road trip. You are planning a road trip for your summer holidays. You want to start from city C0, and follow the only road that goes to city Cn from there. On this road from C0 to Cn, there are n − 1 other cities C1, . . . , Cn−1 that you would be interested in visiting (all cities C1, . . . , Cn−1 are on the road from C0 to Cn). For each 0 ≤ i ≤ n, the city Ci is at kilometer ki of the road for some given 0 = k0 < k1 < . . . < kn−1 < kn. You want to decide in which cities among C1, . . . , Cn−1 you will make an additional stop (you will stop in C0 and Cn anyway). However, you do not want to drive more than d kilometers without making a stop in some city, for some given value d > 0 (we assume that ki < ki−1 + d for all i ∈ [n] so that this is satisfiable), and you also don’t want to travel backwards (so from some city Ci you can only go forward to cities Cj with j > i). (a) Provide a dynamic programming algorithm that computes the number of possible routes from C0 to Cn that satisfy these conditions, i.e., the number of allowed subsets of stop-cities. Your algorithm should have O(n2) runtime. Address the same six aspects as in Exercise 7.1 in your solution. (b) If you know that ki > ki−1 + d/10 for every i ∈ [n], how can you turn the above algorithm into a linear time algorithm (i.e., an algorithm that has O(n) runtime) ? Exercise 7.3 Safe pawn lines. On an N × M chessboard (N being the number of rows and M the number of columns), a safe pawn line is a set of M pawns with exactly one pawn per column of the chessboard, and such that every two pawns from adjacent columns are located diagonally to each other. When a pawn line is not safe, it is called unsafe. The first two chessboards below show safe pawn lines, the latter two unsafe ones. The line on the third chessboard is unsafe because pawns d4 and e4 are located on the same row (rather than diagonally); the line on the fourth chessboard is unsafe because pawn a5 has no diagonal neighbor at all. 6 0Z0Z0Z 5 Z0Z0Z0 4 0Z0o0Z 3 o0o0o0 2 0o0Z0o 1 Z0Z0Z0 a b c d e f 4 pZp 3 ZpZ 2 0Z0 1 Z0Z a b c 4 0Z0opZ 3 Z0o0Zp 2 0o0Z0Z 1 o0Z0Z0 a b c d e f 5 o0Z0Z 4 0Z0o0 3 Z0o0o 2 0o0Z0 1 Z0Z0Z a b c d e Describe a DP algorithm that, given N, M > 0, counts the number of safe pawn lines on an N × M chessboard. In your solution, address the same six aspects as in Exercise 7.1. Your solution should have complexity at most O(N M ). Exercise 7.4 String counting (1 point). Given a binary string S ∈ {0, 1}n of length n, let f (S) be the number of times “11” occurs in the string, i.e. the number of times a 1 is followed by another 1. In particular, the occurrences do not need to be disjoint. For example f (“111011”) = 3 because the string contains three 1 that are followed by another 1 (underlined). Given n and k, the goal is to count the number of binary strings S of length n with f (S) = k. Describe a DP algorithm that, given positive integers n and k with k < n, reports the required number. In your solution, address the same six aspects as in Exercise 7.1. Your solution should have complexity at most O(nk). 2 Hint: Define a three dimensional DP table DP [1 . . . n][0 . . . k][0 . . . 1]. Hint: The entry DP [i][j][l] counts the number of strings of length i with j occurrences of “11” that end in l (where 1 ≤ i ≤ n, 0 ≤ j ≤ k and 0 ≤ l ≤ 1). Exercise 7.5 Approximately solving knapsack (1 point). Consider a knapsack problem with n items with values vi ∈ N and weights wi ∈ N for i ∈ {1, 2, . . . , n}, and weight limit W ∈ N. Assume1 that wmax := max1≤i≤n wi ≤ W and also that W ≤ ∑n i=1 wi. For a set of items I ⊆ {1, 2, . . . , n}, we write v(I) = ∑ i∈I vi and w(I) = ∑ i∈I wi for the total value (resp. weight) of I. So, the solution to a knapsack problem is given by opt := max {v(I) : I ⊆ {1, 2, . . . , n}, w(I) ≤ W } . Let ε > 0. We say a set of items I ⊆ {1, 2, . . . , n} is ε-feasible if it violates the weight limit by at most a factor 1 + ε, that is, if w(I) ≤ (1 + ε) · W. In this exercise, we construct an algorithm that finds an ε-feasible set I with v(I) ≥ opt in polynomial time in n and 1/ε. (a) Let k ∈ N. Consider a ‘rounded version’ of the knapsack problem above obtained by replacing the weights wi by: ̃wi := k · ⌊ wi k ⌋ . Recall the dynamical programming algorithm you have seen in the lecture which solves the knapsack problem in time O(n · W ). Explain how to modify this algorithm to solve the ‘rounded version’ in time O((W/k) · n). For simplicity, you may assume that W is an integer multiple of k for this part. Hint: After rounding, all the ̃wi are integer multiples of k. Use this to reduce the number of table entries you have to compute in the dynamical programming algorithm. We write optk for the optimum solution value of the rounded problem in part (a). From now on, you may assume that your modified algorithm also returns a set Ik with v(Ik) = optk and ∑ i∈Ik ̃wi ≤ W . (b) Explain why optk ≥ opt. (c) Set ε := (nk)/wmax. Show that w(Ik) ≤ (1 + ε) · W , that is, show that Ik is ε-feasible. Hint: Show that wi ≤ ̃wi + k for each i ∈ {1, 2, . . . , n}. We know that ∑ i∈Ik ̃wi ≤ W . Combine these facts to show that w(Ik) := ∑ i∈Ik wi ≤ W + n · k. Finally, use the fact that W/wmax ≥ 1 to conclude your proof. (d) Now let ε > 0 be arbitrary. Describe an algorithm that finds an ε-feasible set I of items with v(I) ≥ opt in time O(n3/ε). Prove the runtime guarantee and correctness of your algorithm. Hint: Apply the algorithm of part (a) to the rounded problem with k = (wmax · ε)/n. For simplicity, you may assume that this k is an integer in your proof. Then, use the assumption that W ≤ ∑n i=1 wi (≤ n · wmax) to bound the runtime of the algorithm in terms of n and 1/ε. Finally, use part (b) and part (c) to show correctness. 1Why are these assumptions reasonable? 3 (e)* Let ε = 1/100. Give an example of a knapsack problem which has an ε-feasible solution I with value v(I) = 2 · opt, Your example should satisfy wmax ≤ W and W ≤ ∑n i=1 wi. 4","libVersion":"0.3.2","langs":""}