{"path":"sem2a/DDCA/VRL/slides/DDCA-L06-arithmetic-circuits.pdf","text":"Carnegie Mellon 1 Digital Design and Computer Architecture Mohammad Sadrosadati Frank K. Gürkaynak Adapted from Digital Design and Computer Architecture, David Money Harris & Sarah L. Harris ©2007 Elsevier http://safari.ethz.ch/ddca Combinational Circuits in Processors Arithmetic Circuits Carnegie Mellon 2 In This Lecture ¢ Why are arithmetic circuits so important ¢ Adders § Adding two binary numbers § Adding more than two binary numbers § Circuits Based on Adders ¢ Multipliers ¢ Functions that do not use adders ¢ Arithmetic Logic Units Carnegie Mellon 3 Motivation: Arithmetic Circuits ¢ Core of every digital circuit § Everything else is side-dish, arithmetic circuits are the heart of the digital system ¢ Determines the performance of the system § Dictates clock rate, speed, area § If arithmetic circuits are optimized performance will improve ¢ Opportunities for improvement § Novel algorithms require novel combinations of arithmetic circuits, there is always room for improvement Carnegie Mellon 4 Example: ARM Microcontroller ¢ Most popular embedded micro controller. ¢ Contains: § Multiplier § Accumulator § ALU/Adder § Shifter § Incrementer Carnegie Mellon 5 Example: ARM Instructions Carnegie Mellon 6 Arithmetic Based Instructions of ARM MOV MVN MRS MSR ADD ADC SUB SBC RSB RSC MUL MLA UMULL UMLAL SMULL SMLAL CMP CMN QADD QDADD QSUB SMUL SMULA SMULW SMLAW CLZ TST TEQ AND XOR OR BIC B BL BX BLX LD,STR LD,STRT LD,STRB LD,STRBT LDRSB LD,STRH LDRSH LD,STM LD,STMIB LD,STMIA LD,STMDB LD,STMDA LD,STRD PLD SWP SWI BKPT CDP MRC,MCR MRRC,MCRR Carnegie Mellon 7 Types of Arithmetic Circuits ¢ In order of complexity: § Shift / Rotate § Compare § Increment / Decrement § Negation § Addition / Subtraction § Multiplication § Division § Square Root § Exponentation § Logarithmic / Trigonometric Functions Carnegie Mellon 8 Relation Between Arithmetic Operators Carnegie Mellon 9 Addition ¢ Addition is the most important operation in computer arithmetic. Our topics will be: § Adding 1-bit numbers : Counting bits § Adding two numbers : Basics of addition § Circuits based on adders : Subtractors, Comparators § Adding multiple numbers : Chains of Adders ¢ Later we will also talk about fast adder architectures Carnegie Mellon 10 Half-Adder (2,2) Counter ¢ The Half Adder (HA) is the simplest arithmetic block ¢ It can add two 1-bit numbers, result is a 2-bit number ¢ Can be realized easily Carnegie Mellon 11 Full-Adder (3,2) Counter ¢ The Full Adder (FA) is the essential arithmetic block ¢ It can add three 1-bit numbers, result is a 2-bit number ¢ There are many realizations both at gate and transistor level. ¢ Since it is used in building many arithmetic operations, the performance of one FA influences the overall performance greatly. Carnegie Mellon 12 Adding Multiple 1-bit Numbers Carnegie Mellon 13 Adding Multiple Digits ¢ Similar to decimal addition ¢ Starting from the right, each digit is added ¢ The carry from one digit is added to the digit to the left Carnegie Mellon 14 Adding Multiple Digits ¢ Similar to decimal addition ¢ Starting from the right, each digit is added ¢ The carry from one digit is added to the digit to the left Carnegie Mellon 15 Ripple Carry Adder (RCA) Carnegie Mellon 16 Curse of the Carry The most significant outputs of the adder depends on the least significant inputs Carnegie Mellon 17 Adding Multiple Numbers ¢ Multiple fast adders not a good idea § If more than 2 numbers are to be added, multiple fast adders are not really efficient ¢ Use an array of ripple carry adders § Popular and efficient solution ¢ Use carry save adder trees § Instead of using carry propagate adders (the adders we have seen so far), carry save adders are used to reduce multiple inputs to two, and then a single carry propagate adder is used to sum up. Carnegie Mellon 18 Array of Ripple Carry Adders Carnegie Mellon 19 Carry Save Principle ¢ Reduces three numbers to two with a single gate delay C + S = E + F + G Carnegie Mellon 20 Carry Save Principle Z = D + E + F + G + H ¢ An array of carry save adders reduce the inputs to two ¢ A final (fast) carry propagate adder (CPA) merges the two numbers ¢ Performance mostly dictated by CPA CSA1 CSA2 CSA3 CPA D E F G H Z C1 S1 C2 S2 C3 S3 Carnegie Mellon 21 Multipliers ¢ Largest common arithmetic block § Requires a lot of calculation ¢ Has three parts § Partial Product Generation § Carry Save Tree to reduce partial products § Carry Propagate Adder to finalize the addition ¢ Adder performance (once again) is important ¢ Many optimization alternatives Carnegie Mellon 22 Decimal Multiplication Carnegie Mellon 23 Binary Multiplication 0 1 0 1 0 0 1 1 Partial Products 1 0 0 1 0 1 1 1 0 1 0 1 1 0 0 1 0 1 0 1 1 0 0 1 0 1 0 1 1 0 0 1 0 0 0 00 000 0 1 0 1 1 0 0 1 0 1 0 1 1 0 0 1 0 0 0 00 000 0 0 0 00 000 0 0 1 00 110 0 1 10 1 110 89 55 4895 Carnegie Mellon 24 For n-bit Multiplier m-bit Multiplicand ¢ Generate Partial Products § For each bit of the multiplier the partial product is either § when ‘0’: all zeroes § when ‘1’: the multiplicand achieved easily by AND gates ¢ Reduce Partial Products § This is the job of a carry save adder ¢ Generate the Result (n + m bits) § This is a large, fast Carry Propagate Adder Carnegie Mellon 25 Parallel Multiplier Carnegie Mellon 26 Parallel Multiplier Carnegie Mellon 27 Operations Based on Adders ¢ Several well-known arithmetic operation are based on adders: § Negator § Incrementer § Subtracter § Adder Subtracter § Comparator Carnegie Mellon 28 Negating Two’s Complement Numbers Adder 0 Co -A A 1 A ¢ To negate a two’s complement number -A = A + 1 ¢ All bits are inverted ¢ One is added to the result ¢ Can be realized easily by an adder. ¢ B input is optimized away Carnegie Mellon 29 Incrementer ¢ B input is zero ¢ Carry In (Cin) of the adder can be used as the Increment (Inc) input ¢ Decrementer similar in principle Carnegie Mellon 30 Subtracter ¢ B input is inverted ¢ Cin of the adder is used to complement B Carnegie Mellon 31 Subtracter ¢ B input is inverted ¢ Cin of the adder is used to complement B ¢ It can be made programmable so that both additions and subtractions can be performed at the same time Carnegie Mellon 32 Comparator ¢ Based on a Subtractor (A = B) = EQ (A != B) = EQ (A > B) = GE EQ (A >= B) = GE (A < B) = GE (A <= B) = GE + EQ Carnegie Mellon 33 Functions Realized Without Adders ¢ Not all arithmetic functions are realized by using adders § Shift / Rotate Units ¢ Binary Logic functions are also used by processors § AND § OR § XOR § NOT These are implemented very easily Carnegie Mellon 34 Shifters ¢ Logical shifter: shifts value to left or right and fills empty spaces with 0’s § Ex: 11001 >> 2 = ?? § Ex: 11001 << 2 = ?? ¢ Arithmetic shifter: same as logical shifter, but on right shift, fills empty spaces with the old most significant bit (msb). § Ex: 11001 >>> 2 = ?? § Ex: 11001 <<< 2 = ?? ¢ Rotator: rotates bits in a circle, such that bits shifted off one end are shifted into the other end § Ex: 11001 ROR 2 = ?? § Ex: 11001 ROL 2 = ?? Carnegie Mellon 35 Shifters ¢ Logical shifter: shifts value to left or right and fills empty spaces with 0’s § Ex: 11001 >> 2 = 00110 § Ex: 11001 << 2 = 00100 ¢ Arithmetic shifter: same as logical shifter, but on right shift, fills empty spaces with the old most significant bit (msb). § Ex: 11001 >>> 2 = 11110 § Ex: 11001 <<< 2 = 00100 ¢ Rotator: rotates bits in a circle, such that bits shifted off one end are shifted into the other end § Ex: 11001 ROR 2 = 01110 § Ex: 11001 ROL 2 = 00111 Carnegie Mellon 36 Shifter Design A 3:0 Y 3:0 shamt1:0 >> 2 4 4 A3 A2 A1 A0 Y3 Y2 Y1 Y0 shamt1:0 00 01 10 11 S 1:0 S 1:0 S 1:0 S 1:0 00 01 10 11 00 01 10 11 00 01 10 11 2 Carnegie Mellon 37 Shifters as Multipliers and Dividers ¢ A left shift by N bits multiplies a number by 2N § Ex: 00001 << 2 = 00100 (1 × 22 = 4) § Ex: 11101 << 2 = 10100 (-3 × 22 = -12) ¢ The arithmetic right shift by N divides a number by 2N § Ex: 01000 >>> 2 = 00010 (8 ÷ 22 = 2) § Ex: 10000 >>> 2 = 11100 (-16 ÷ 22 = -4) Carnegie Mellon 38 Other Functions ¢ We have covered 90% of the arithmetic functions commonly used in a CPU ¢ Division § Dedicated architectures not very common § Mostly implemented by existing hardware (multipliers, subtractors comparators) iteratively ¢ Exponential, Logarithmic, Trigonometric Functions § Dedicated hardware (less common) § Numerical approximations: exp(x) = 1 + x2/2! + x3/3! + … § Look-up tables (more common) Carnegie Mellon 39 Arithmetic Logic Unit The reason why we study digital circuits: the part of the CPU that does something (other than copying data) ¢ Defines the basic operations that the CPU can perform directly § Other functions can be realized using the existing ones iteratively. (i.e. multiplication can be realized by shifting and adding) ¢ Mostly, a collection of resources that work in parallel. § Depending on the operation one of the outputs is selected Carnegie Mellon 40 Example: Arithmetic Logic Unit (ALU), pg243 ALU N N N 3 A B Y F F2:0 Function 000 A & B 001 A | B 010 A + B 011 not used 100 A & ~B 101 A | ~B 110 A - B 111 SLT Carnegie Mellon 41 Example: ALU Design +201 A B Cout Y301F2 F1:0 [N-1] S NN N N N NNN N 2ZeroExtend F2:0 Function 000 A & B 001 A | B 010 A + B 011 not used 100 A & ~B 101 A | ~B 110 A - B 111 SLT Carnegie Mellon 42 Set Less Than (SLT) Example ¢ Configure a 32-bit ALU for the set if less than (SLT) operation. Suppose A = 25 and B = 32. § A is less than B, so we expect Y to be the 32-bit representation of 1 (0x00000001). +201 A B Cout Y301F2 F1:0 [N-1] S NN N N N NNN N 2ZeroExtend Carnegie Mellon 43 Set Less Than (SLT) Example ¢ Configure a 32-bit ALU for the set if less than (SLT) operation. Suppose A = 25 and B = 32. § A is less than B, so we expect Y to be the 32-bit representation of 1 (0x00000001). § For SLT, F2:0 = 111. § F2 = 1 configures the adder unit as a subtracter. So 25 - 32 = -7. § The two’s complement representation of -7 has a 1 in the most significant bit, so S31 = 1. § With F1:0 = 11, the final multiplexer selects Y = S31 (zero extended) = 0x00000001 +201 A B Cout Y301F2 F1:0 [N-1] S NN N N N NNN N 2ZeroExtend Carnegie Mellon 44 What Did We Learn? ¢ How can we add, subtract, multiply binary numbers ¢ What other circuits depend on adders § Subtracter § Incrementer § Comparator § Important part of Multiplier ¢ Other functions (shifting) ¢ How is an Arithmetic Logic Unit constructed","libVersion":"0.3.2","langs":""}