{"path":"sem4/FMFP/PV/exams/20-midterms/FMFP-FS08.pdf","text":"Computer Science Department Dr. F. Klaedtke Dr. C. Sprenger Formal Methods and Functional Programming Midterm April 11th, 2008, 8:15 – 10:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. Check that your exam papers are complete (5 assignments). 2. Write your name on every sheet. Additional sheets are available from the assistants. 3. This is a closed book exam: the only resources allowed are pens. No laptops, no cell phones, no prepared notes, etc. Do not use a pencil (Bleistift) and do not use the color red. 4. You may write your answers in English or German. Important: Write clearly in the sense of logic, language, and readability. The clarity of your arguments and explanations aﬀects your grade. 5. Comment your Haskell code. 6. If you have a question regarding the meaning of a problem statement, you may ask one of the assistants in charge of the exam. Assignment 1 2 3 4 5 ∑ Max. points 6 4 3 6 4 23 Your points Grade Formal Methods and Functional Programming, Midterm, SS08 1 Assignment 1 (6 points) (a) State the most general type of the following well-typed Haskell expressions. You do not have to formally prove your claims. I. (\\x -> snd x) (fst, \\y z -> map y (’e’:z)) II. \\x y z -> tail x == map (/= z) y (b) Explain why the Haskell expression \\x y -> y < filter x (\"c\":y:\"a\":[]) is not well-typed. (c) Recall the typing rules for mini-Haskell: . . . , x : a, . . . ⊢ x :: a A ⊢ n :: Int A ⊢ T rue :: Bool A ⊢ F alse :: Bool A, x : σ ⊢ t :: τ A ⊢ (λx. t) :: σ → τ x /∈ A A ⊢ t1 :: σ → τ A ⊢ t2 :: σ A ⊢ (t1 t2) :: τ A ⊢ t :: Int A ⊢ (iszero t) :: Bool A ⊢ t1 :: Int A ⊢ t2 :: Int A ⊢ (t1 op t2) :: Int op ∈ {+, ×} A ⊢ t0 :: Bool A ⊢ t1 :: τ A ⊢ t2 :: τ A ⊢ (if t0 then t1 else t2) :: τ A ⊢ t1 :: τ1 A ⊢ t2 :: τ2 A ⊢ (t1, t2) :: (τ1, τ2) A ⊢ t :: (τ1, τ2) A ⊢ (fst t) :: τ1 A ⊢ t :: (τ1, τ2) A ⊢ (snd t) :: τ2 Using the typing rules above, formally prove that λx. (λy. λz. z (y + 5)) (fst x) has the type (Int, a) → (Int → b) → b. (d) We extend mini-Haskell with the let construct that binds a term t1 locally to a variable x in term t2. The extended term language is as follows, where V is a set of variables and Z is the set of integers: t ::= V ∣ ∣ (λx. t) ∣ ∣ (t1 t2) ∣ ∣ True ∣ ∣ False ∣ ∣ (iszero t) ∣ ∣ Z ∣ ∣ (t1 + t2) ∣ ∣ (t1 × t2) ∣ ∣ (if t0 then t1 else t2) ∣ ∣ (t1, t2) ∣ ∣ (fst t) ∣ ∣ (snd t) ∣ ∣ (let x = t1 in t2) Give the typing rule for the let construct. Formal Methods and Functional Programming, Midterm, SS08 2 Assignment 2 (4 points) Consider the algebraic data type data Tree a = Leaf | Node a (Tree a) (Tree a) and the following functions treeFold :: (a -> b -> b -> b) -> b -> Tree a -> b treeFold f e Leaf = e treeFold f e (Node y l r) = f y (treeFold f e l) (treeFold f e r) subtrees :: Tree a -> [Tree a] subtrees t = treeFold (\\y l r -> (Node y (head l) (head r)) : (l++r)) [Leaf] t subtrees’ :: Tree a -> [Tree a] subtrees’ Leaf = [Leaf] subtrees’ (Node y l r) = (Node y l r) : (subtrees’ l ++ subtrees’ r) Prove that for all ﬁnite trees x::Tree a, it holds that subtrees x = subtrees’ x. Hint: You can use the following lemma without proof: For all ﬁnite trees x::Tree a, it holds that head (subtrees x) = x. Assignment 3 (3 points) (a) Deﬁne an algebraic data type LTree a b for trees, where (i) each inner node is labeled with a value of type a and can either one or two children, and (ii) each leaf is labeled with a value of type b. (b) Two trees t1 and t2 have the same shape if there is a bijection π between the children of the root of t1 and the children of the root of t2 such that for each child c of t1’s root, the subtree of t1 with root c has the same shape as the subtree of t2 with root π(c). Deﬁne a function shape :: LTree a b -> LTree c d -> Bool, where shape t1 t2 returns true if and only if both trees have the same shape. Formal Methods and Functional Programming, Midterm, SS08 3 Assignment 4 (6 points) A ﬁnite directed graph can be represented by a ﬁnite list of pairs, where a pair (x,y) represents an edge from vertex x to vertex y. In this case, y is said to be a direct successor of x. type DiGraph a = [(a,a)] As a simple example, consider the following directed graph a b c d which would be represented as follows: simple_gr :: DiGraph Char simple_gr = [(’b’,’a’),(’a’,’c’),(’c’,’b’),(’c’,’d’)] (a) Write a function directSuccessors :: Eq a => DiGraph a -> a -> [a] such that directSuccessors gr x is a list of all direct successors of x in the directed graph gr. Examples: directSuccessors simple_gr ’c’ = [’b’,’d’] directSuccessors simple_gr ’d’ = [] (b) A path in a directed graph is a nonempty sequence v0, . . . , vn of vertices such that for each i < n, there is an edge from vi to vi+1 in the graph. Write a function isPath :: Eq a => DiGraph a -> [a] -> Bool such that isPath gr vs returns true, if and only if the list of vertices vs is a path in the directed graph gr. Example: isPath simple_gr [] = False isPath simple_gr [’a’,’d’] = False isPath simple_gr [’a’,’c’,’d’] = True (c) Given a directed graph gr, then y is a successor of x in gr, if and only if there exists a path from x to y in gr. Write a function successors :: Eq a => DiGraph a -> a -> [a] such that successors gr x returns a duplicate free list of all successors of x in the directed graph gr. Examples: successors simple_gr ’b’ = [’b’,’a’,’c’,’d’] successors simple_gr ’d’ = [’d’] Note: The ordering of the elements in the returned list is not relevant. Formal Methods and Functional Programming, Midterm, SS08 4 Assignment 5 (4 points) (a) Deﬁne a function split :: Char -> String -> [String] that splits a string, which consists of substrings separated by a separator, into a list of strings. Examples: split ’#’ \"foo##goo\" = [\"foo\",\"\",\"goo\"] split ’#’ \"#\" = [\"\",\"\"] (b) Deﬁne a function center :: [String] -> [String] that centers the strings in the list by appending spaces to the left and right. For the argument list l, center l should return a list with the original strings enclosed in spaces so that all strings in the resulting list have the same length and the original string is centered in the string with added spaces (i.e. when x spaces are appended to the left and y to the right, then |x − y| ≤ 1 must hold). Example: center [\"fullness\",\"of\",\"exposition\",\"is\",\"necessary\"] = [\" fullness \", \" of \", \"exposition\", \" is \", \"necessary \"] Hint: You can use the predeﬁned functions maximum :: Ord a => [a] -> a and replicate :: Int -> a -> [a], where maximum l returns the maximal element in the list l and replicate n x returns the list of length n, where x is the value of every element.","libVersion":"0.5.0","langs":""}