{"path":"sem1/DMath/UE/s/DMath-u06-s.pdf","text":"ETH Z ¨urich, D-INFK HS 2023, 3. November 2023 Prof. Ueli Maurer Giovanni Deligios Diskrete Mathematik Solution 6 6.1 Partial Order Relations a) i) 11 and 12 are incomparable, since 11 ̸ | 12 and 12 ̸ | 11. ii) 4 and 6 are incomparable, since 4 ̸ | 6 and 6 ̸ | 4. iii) 5 and 15 are comparable, since 5 | 15. iv) 42 and 42 are comparable, since 42 | 42. b) The elements (a, b) ∈ A, such that (a, b) ≤lex (2, 5) are: (2, 1), (2, 5) and (1, n) for all n ∈ N \\ {0}. Justiﬁcation: Let (a, b) ∈ A. We distinguish the following cases: Case a = 1: Since 1 | 2, we have (a, b) ≤lex (2, 5) for any b. Case a = 2: Since 1 and 5 are the only natural numbers which divide 5, we have (a, b) ≤lex (2, 5) only for b ∈ {1, 5}. Case a > 2: Since a ̸ | 2, (a, b) ≤lex (2, 5) cannot hold for any b. c) ({1, 3, 6, 9, 12}, | ) is not a lattice, since 9 and 12 do not have a common upper bound. d) (A; ̂≼) is a poset. To prove this, we show that ̂≼ is a partial order on A. Reﬂexivity: For any a ∈ A, by the reﬂexivity of ≼, we have a ≼ a, hence, a ̂≼a. Antisymmetry: Let a, b ∈ A be such that a ̂≼b and b ̂≼a. This means that b ≼ a and a ≼ b By the antisymmetry of ≼, it follows that a = b. Transitivity: Let a, b, c ∈ A be such that a ̂≼b and b ̂≼c. This means that b ≼ a and c ≼ b. By the transitivity of ≼, we have c ≼ a. Hence, a ̂≼c. 6.2 Hasse Diagrams a) The Hasse diagrams of the posets ({1, 2, 3}; ≤) and ({1, 2, 3, 5, 6, 9}; | ) are as follows: 3 6 9 2 2 3 5 1 1 In both cases, 1 is the least and the only minimal element. In the poset ({1, 2, 3}; ≤), the greatest and the only maximal element is 3. In the poset ({1, 2, 3, 5, 6, 9}; | ) there is no greatest element. The maximal elements in this poset are 5, 6 and 9. 6.3 The Lexicographic Order For posets (A; ≼) and (B; ⊑) the lexicographic order ≤lex on A × B is deﬁned by (a1, b1) ≤lex (a2, b2) :⇐⇒ a1 ≺ a2 ∨ (a1 = a2 ∧ b1 ⊑ b2) We show that ≤lex is a partial order relation. Reﬂexivity: Take any (a1, b1) ∈ A × B. Since ⊑ is reﬂexive, we have b1 ⊑ b1. Hence, it is true that (a1 = a1 ∧ b1 ⊑ b1) and, thus, (a1, b1) ≤lex (a1, b1). Antisymmetry: Take any (a1, b1) and (a2, b2) in A × B such that (a1, b1) ≤lex (a2, b2) and (a2, b2) ≤lex (a1, b1). This means that a1 ≺ a2| {z } (1) ∨ (a1 = a2 ∧ b1 ⊑ b2) | {z } (2) and a2 ≺ a1| {z } (3) ∨ (a2 = a1 ∧ b2 ⊑ b1) | {z } (4) . We have to show that (a1, b1) = (a2, b2). The proof proceeds by case distinction. (1) and (3): We have a1 ≼ a2 ∧ a1 ̸= a2 and a2 ≼ a1 ∧ a2 ̸= a1. But since ≼ is antisymmetric, it follows that a1 = a2, which is a contradiction with a1 ̸= a2. Therefore, this case cannot occur. (1) and (4): We have a1 ≼ a2 ∧ a1 ̸= a2 and a2 = a1∧b2 ⊑ b1, which is a contradiction. Therefore, this case also cannot occur. (2) and (3): We have a1 = a2∧b1 ⊑ b2 and a2 ≼ a1 ∧ a2 ̸= a1, which is a contradiction. Therefore, this case cannot occur as well. (2) and (4): We have a1 = a2∧b1 ⊑ b2 and a2 = a1∧b2 ⊑ b1. Since ⊑ is antisymmetric, it follows that b1 = b2. But we also have a1 = a2 and, thus, (a1, b1) = (a2, b2). Transitivity: Take any (a1, b1), (a2, b2), (a3, b3) in A × B such that (a1, b1) ≤lex (a2, b2) and (a2, b2) ≤lex (a3, b3). This means that a1 ≺ a2| {z } (1) ∨ (a1 = a2 ∧ b1 ⊑ b2) | {z } (2) and a2 ≺ a3| {z } (3) ∨ (a2 = a3 ∧ b2 ⊑ b3) | {z } (4) . We have to show that (a1, b1) ≤lex (a3, b3). The proof proceeds by case distinction. (1) and (3): We have a1 ≺ a2 and a2 ≺ a3. Since ≼ is transitive we have a1 ≼ a3. Moreover, if we had a1 = a3, the antisymmetry of ≼ would imply that a1 = a2, a contradiction to a1 ≺ a2. Thus, a1 ̸= a3, and therefore a1 ≺ a3. Hence, (a1, b1) ≤lex (a3, b3). (1) and (4): We have a1 ≺ a2 and a2 = a3 ∧ b2 ⊑ b3. Hence, a1 ≺ a3 and, therefore, (a1, b1) ≤lex (a3, b3). (2) and (3): We have a1 = a2 ∧ b1 ⊑ b2 and a2 ≺ a3. Hence, a1 ≺ a3 and, therefore, (a1, b1) ≤lex (a3, b3). (2) and (4): We have a1 = a2 ∧ b1 ⊑ b2 and a2 = a3 ∧ b2 ⊑ b3. It follows that a1 = a3. Since ⊑ is transitive, we also have b1 ⊑ b3. Therefore, (a1, b1) ≤lex (a3, b3). 6.4 Inverses of Functions We prove the two implications separately. ( =⇒ ) Let g be a function such that g ◦ f = id. We show that f is injective. Assume that f (a) = f (b) for some a, b ∈ A. Then a = (g ◦ f )(a) (g ◦ f = id) = g(f (a)) (def. ◦) = g(f (b)) (f (a) = f (b)) = (g ◦ f )(b) (def. ◦) = b (g ◦ f = id) ( ⇐= ) Assume that f is injective. We construct a function g such that g ◦ f = id as follows. For any b ∈ Im(f ), by the injectivity of f , there exists a unique a such that f (a) = b, and we deﬁne g(b) = a. For b ̸∈ Im(f ), we deﬁne g(b) = b. We have g ◦ f = id, because for any a ∈ A, f (a) ∈ Im(f ), so g(f (a)) = a. Note: The choice g(b) = b in case b ̸∈ Im(f ) is irrelevant. For example, we could set g(b) = a0 for some ﬁxed a0 ∈ A. 6.5 Countability and Uncountability a) We prove the implication indirectly. Assume that B is countable. Then B ≼ N (Def- inition 3.42). Since A ≼ B (by assumption) and B ≼ N, we get A ≼ N (Lemma 3.15 (a)), that is, A is countable (Deﬁnition 3.42). b) We show an injection from {0, 1}∞ into S. Consider the function1 ψ : {0, 1}∞ → S f 7→ g where g : {0, 1} → {0, 1}∞ is the (constant) function such that g(0) = g(1) = f . We show that ψ is injective, that is, for all f, f ′ ∈ {0, 1}∞ if ψ(f ) = ψ(f ′) then f = f ′ (the indirect implication of Deﬁnition 3.39-1). Let g = ψ(f ) and g′ = ψ(f ′) and suppose g = g′. We have f = g(0) = g′(0) = f ′. Therefore ψ is an injection from the uncountable set {0, 1}∞ (Theorem 3.18) into S. This means {0, 1}∞ ≼ S (Deﬁnition 3.42-(ii)) and the claim follows from subtask (a). 6.6 The Hunt for the Red October The set Z × Z of possible parameters (v, s0) is countable due to the fact that Z is countable (see Example 3.57) and Corollary 3.20. Thus, due to Theorem 3.17 there exists a bijection ψ : N → Z × Z. The strategy is to attempt the parameters in the sequence ψ(0), ψ(1), ψ(2), . . . 1We interpret the set {0, 1}∞ as the set of functions N → {0, 1}. Since ψ is a bijection, Svetlana will ﬁnd the correct values (̂v, ̂s0) ∈ Z × Z in the i-th attempt (we start to count from zero), where i = ψ−1(̂v, ̂s0). Hence, Svetlana only needs ﬁnitely many attempts, so she is guaranteed to ﬁnd the correct parameters in a ﬁnite time. 6.7 More Countability a) The set of all Java programs is countable. Every Java program can be seen as a ﬁnite binary sequence. That is, there is an injection from the set of all Java programs to the set {0, 1}∗ of ﬁnite binary sequences. By Theorem 3.18, this set is countable. b) This set is uncountable. To prove this, we notice that {0, 1}∞ ⊆ A, which implies that {0, 1}∞ ≼ A (Lemma 3.15). Since {0, 1}∞ is uncountable, A must be uncountable as well (if A was countable, the transitivity of ≼ would imply that {0, 1}∞ is countable, which is a contradiction). An alternative proof. We can also apply directly the diagonalization argument. Assume towards a contradiction that there is a bijection f : N → A. Let βi,j denote the j-th number in the i-th sequence. We deﬁne a new sequence as follows: α def = R10(β0,0 + 1), R10(β1,1 + 1), R10(β2,2 + 1), . . . , where R10(a) denotes the remainder when a is divided by 10. Of course, α ∈ A. Moreover, there is no n ∈ N such that α = f (n), since α disagrees with a sequence f (n) on position n. c) This set is uncountable. We can deﬁne an injective function f : [0, 1] → C by f (x) =(x, √1 − x2). Hence, we have [0, 1] ≼ C. Since [0, 1] is uncountable, C must be uncountable as well (if C was countable, the transitivity of ≼ would imply that [0, 1] is countable as well, which is a contradiction). Note: The fact that the interval [0, 1] is uncountable follows from Theorem 3.23 and the fact that any element of {0, 1}∞ can be interpreted as the binary expansion of a number in the interval [0, 1], and vice versa. d) To begin, consider the subset P ⊆ N of prime numbers and consider the inclusion function i : P → N, p 7→ p. (1) The function i is injective, as i(p) = i(p′) clearly implies p = p′. This means P ≼ N (Deﬁnition 3.42). Since P is inﬁnite (hint), then P ∼ N (Theorem 3.17), or equivalently there exists a bijection between N and P. Let ϕ : N → P be such a bijective function. We prove that S is uncountable by exhibiting an injection from {0, 1}∞ to S. In what follows, we understand the set {0, 1}∞ as the set of functions N → {0, 1}. Consider the following function ψ : {0, 1}∞ → S, f 7→ g (2) where g is deﬁned as follows: g(n) =  | | 1 if n = 1, 0 if n ̸= 1 and n is not prime , f (ϕ−1(n)) otherwise. (3) First of all, we prove that ψ is well deﬁned, that is, for all f ∈ {0, 1}∞ it holds that ψ(f ) ∈ S. Let f ∈ {0, 1}∞ and let g = ψ(f ). Let n ∈ N such that g(n) = 0. There are three cases to consider. - The ﬁrst case is that n = 0. In this case, for all m ∈ N we have 0 ∤ m so that there is nothing to check. - The second case is that n /∈ {0, 1} and n is not prime. In this case, if n | m then m ̸= 1 and m is not prime, so that g(m) = 0. - The last case is that n is prime. In this case, if n | m then m is not prime, so that g(m) = 0. This shows that g ∈ S. Next, we show that ψ is injective. Suppose that ψ(f ) = ψ(f ′) for some f, f ′ ∈ {0, 1}∞. Let g = ψ(f ) and g′ = ψ(f ′). This means that for all n ∈ N it holds that g(n) = g′(n). We want to show that f (n) = f ′(n) for all n ∈ N. Let n ∈ N. Since ϕ is bijective we have n = ϕ−1(p) for some p ∈ P. Therefore f (n) = f (ϕ−1(p)) (n = ϕ−1(p)) = g(p) (Deﬁnition of g) = g′(p) (g(n) = g′(n) for all n ∈ N) = f ′(ϕ−1(p)) (Deﬁnition of g) = f ′(n) (n = ϕ−1(p)). (4) This shows that ψ is injective.","libVersion":"0.3.1","langs":""}