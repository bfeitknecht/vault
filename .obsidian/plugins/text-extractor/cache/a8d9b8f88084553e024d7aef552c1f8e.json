{"path":"sem3/EProg/VRL/extra/slides/EProg-slides-w02.pdf","text":"252-0027 EinfÃ¼hrung in die Programmierung 2. Erste Java-Programme Manuela Fischer, Malte Schwerhoff Departement Informatik ETH ZÃ¼rich 2. Erste Java-Programme 2.1 EinfÃ¼hrung: Vom Quelltext zur Ausgabe 2.2 Methoden I: Programmstrukturierung 2.3 Einfache Berechnungen 2.4 Input und Random 2.5 Logische Aussagen Ã¼ber Programm(segment)e 2 Java-Programme erstellen und ausfÃ¼hren Zwei MÃ¶glichkeiten: 3 B) Einzelne Anweisungen ï‚§ FÃ¼r jede Anweisung â€¦ ï‚§ Lesen (Read) ï‚§ Evaluieren (AusfÃ¼hren) ï‚§ Ausgeben (Print) ï‚§ REPL ï‚§ Read-Evaluate-Print Loop A) Ganzes Programm ï‚§ FÃ¼r jede Datei â€¦ ï‚§ Erstellen ï‚§ AusfÃ¼hren ï‚§ Modifizieren Folgt jetzt Java: Vom Quellcode zu Ausgabe 4 Java-Programm (Quellcode) Java-Anweisung Java-Anweisung Java-Anweisung Java-Anweisung Ausgabe (Grafik) Ausgabe (Text) Die Note ist: 6.0 Ausgabe (...) 0929095 8395798 9216320 0082134 Java-Programm (Prozessor- Instruktionen) Check Befehl Befehl Befehl Check Check Befehl Prozessor + Laufzeit- system Ãœbersetzt und prÃ¼ft FÃ¼hrt aus und prÃ¼ft CompilerEditor Java-Programme Erstellen und AusfÃ¼hren ï‚§ Ganzes Programm: FÃ¼r jede Datei â€¦ ï‚§ Erstellen â€” mit einem Editor ï‚§ AusfÃ¼hren â€” Compiler Ã¼bersetzt, Prozessor fÃ¼hrt aus ï‚§ Modifizieren â€” nach Analyse der erhaltenen Ausgabe ï‚§ Entwicklungsumgebungen (Â«integrated development environmentsÂ» = IDE) wie Eclipse ï‚§ Enthalten notwendige Komponenten und FunktionalitÃ¤t ï‚§ Sind Industriestandard, aber nicht zwingend notwendig 56 Java und Eclipse ï‚§ Viele Aspekte ï‚§ Zuerst: Fokus auf das wichtigste ï‚§ Sie kennen Java/Eclipse schon: super ï‚§ Aber denken Sie an die, die noch nicht so weit sind ï‚§ Schrittweise erklÃ¤ren wir mehr Konzepte ï‚§ Was uns (jetzt) nicht interessiert: abdecken ï‚§ KÃ¶nnen diese Teile nicht ignorieren ï‚§ MÃ¼ssen diese Teile (fÃ¼rs Erste) akzeptieren 789 Unser erstes Java-Programm ï‚§ Viele Aspekte nicht zwingend notwendig fÃ¼rs Erste VerstÃ¤ndnis ï‚§ Ziele: Programme 1. lesen, 2. verstehen, 3. erstellen/modifizieren ï‚§ Wir kÃ¶nnen leider nicht alle davon vollstÃ¤ndig ignorieren â€¦ 10 Unser erstes Java-Programm Notwendige Struktur fÃ¼r ein eigenstÃ¤ndiges Java-Programm Von uns implementierte FunktionalitÃ¤t 11 Unser erstes Java-Programm Wichtig (fÃ¼r den Anfang) 1. Programmname gleich Dateiname 2. Eine Klasse (class) pro Programm/Datei 12 Unser erstes Java-Programm ï‚§ main: Java-Methode (Java-Code den wir ausfÃ¼hren kÃ¶nnen) ï‚§ Methode enthÃ¤lt mehrere Anweisungen ï‚§ Hier: println(\"â€¦\") â€” gibt Text zwischen AnfÃ¼hrungszeichen aus EBNF ï‚§ HÃ¤lt die Syntaxregeln von Java-Programmen fest ï‚§ Beispiel: Bezeichner (Namen) in Programmen ï‚§ Bezeichner (Â«identifierÂ») mÃ¼ssen Anforderungen erfÃ¼llen, z.B. ï‚§ Bezeichner muss mindestens ein Zeichen lang sein ï‚§ â€¦ muss mit einem (Unicode-)Buchstaben anfangen ï‚§ â€¦ kann Buchstaben oder Ziffern (0-9) enthalten 13Wer es genau wissen mÃ¶chte: Java Language Specs Â§3.8 EBNF-Regeln fÃ¼r Java (vereinfacht) EBNF-Beschreibung fÃ¼r einzelne Bezeichner (<identifier>): <lowercaseletter> âŸµ a | b | c | ... |z <uppercaseletter> âŸµ A | B | C | ... | Z <letter> âŸµ <lowercaseletter> | <uppercaseletter> <digit> âŸµ 0 | 1 | 2 | ... | 9 <identifier> âŸµ <letter> { <letter> | <digit> } 14 EBNF-Regeln fÃ¼r Java (vereinfacht) 15 EBNF-Beschreibung fÃ¼r ganze Programme (<javaprogram>): <javaprogram> âŸµ public class <identifier> { <methoddefinition> } <methoddefinition> âŸµ public static void main ( String [] <identifier> ) { <statementsequence> } Aufreihung von Anweisungen: <statementsequence> ï‚§ Methode enthÃ¤lt eine Aufreihung (Â«sequenceÂ») von Anweisungen (Â«statementsÂ») ï‚§ MÃ¶gliche Anweisungen ï‚§ Ein-/Ausgabe ï‚§ Verzweigungen ï‚§ Schleifen ï‚§ Methoden-/Funktionsaufrufe ï‚§ â€¦ 16 Aufreihung von Anweisungen: statementsequence ï‚§ MÃ¶gliche Anweisungen ï‚§ Methoden-/Funktionsaufrufe ï‚§ â€¦ ï‚§ Wichtig fÃ¼r viele Programmiersprachen, inklusive Java 17 1. Aufruf (global/lokal bekannter) Methoden Format: methodenName(); 2. Methodenaufruf fÃ¼r ein Objekt (Beispiel folgt) Format: objekt.methodenName(); Typisch fÃ¼r Java Beispiel Mit dem Objekt System.out kÃ¶nnen wir mit der println- Methode Text ausgeben System.out.println(â€¦); Mehr Ã¼ber Text in ein paar Minuten â€” es gibt viele Methoden fÃ¼r Textbearbeitung jshell> \"Hello\".toUpperCase(); 18 MethodeObjekt Einschub: Objekte ï‚§ Zentrales Konzept der Programmierung â€“ zunÃ¤chst (stark) vereinfacht, spÃ¤ter mehr Details ï‚§ Objekt (vereinfacht): Kann von Programm erstellt, gelesen und verÃ¤ndert werden ï‚§ Hat einen Zustand âœ Ansammlung an Werten ï‚§ Hat ein Verhalten âœ Operationen (fÃ¼r oder mit diesem Objekt) ï‚§ Hat eine IdentitÃ¤t âœ Objekte kÃ¶nnen unterschieden werden ï‚§ Intuitives Beispiel: ï‚§ 5 âˆˆ â„• â€”Wert (eine FÃ¼nf ist und bleibt eine FÃ¼nf) ï‚§ Tabelle (mit Werten aus â„•) â€” Objekt, kann z.B. sortiert werden 1920 AusfÃ¼hren (automatisch Ã¼bersetzt â€“ sonst geht AusfÃ¼hrung nicht) Java-Programme und Compilerfehler ï‚§ Wir kÃ¶nnen Programmteile ignorieren, aber nicht weglassen ï‚§ Sonst kÃ¶nnen wir das Java-Programm nicht Ã¼bersetzen ï‚§ Ãœbersetzen (kompilieren, Â«compileÂ») = in ausfÃ¼hrbare Form bringen ï‚§ Es gibt Fehlermeldungen wenn wir Teile weglassen/falsch schreiben 21 Java-Programm (Quellcode) Java Anweisungen Java Anweisungen Ausgabe ... FÃ¼hrt aus und prÃ¼ft Compiler Java-Programm (Prozessor- Instruktionen) P1 Befehl P1 Befehl P1 Befehl P1 Check Ãœbersetzt und prÃ¼ft 222324 RÃ¼ckmeldungen des Compilers sind nicht immer direkt verstÃ¤ndlich Weiter gehtâ€™s â€¦ 2526 Leicht zu Ã¼bersehen: die letzte } fehlt Zusammenfassung public class name { public static void main(String[] args) { statement; statement; ... statement; } } 27 Klasse = ein Programm mit Namen name Folge von Anweisungen = FunktionalitÃ¤t des Programm Methode main = Beginn der AusfÃ¼hrung des Programms Zusammenfassung ï‚§ Jedes (ausfÃ¼hrbare) Java-Programm besteht aus 1. Einer Datei mit Namen Â«ProgrammName.javaÂ» 2. die eine Klasse Namens Â«ProgrammNameÂ» hat 3. die eine Methode Namens Â«mainÂ» enthÃ¤lt ï‚§ die eine Reihe von Anweisungen enthÃ¤lt ï‚§ die automatisch ausgefÃ¼hrt wird wenn wir auf klicken ï‚§ SpÃ¤ter: Programme mit mehreren Dateien und Klassen 28 Namen: Java-Programme und -Klassen Jedes Programm braucht einen Namen, z.B. public class HelloWorld {â€¦} ï‚§ Regel: Dateiname gleich Programmname HelloWorld.java ï‚§ Konventionen: Jedes Einzelwort startet mit einem Grossbuchstaben (Â«upper camel caseÂ») 29 Namen: Methoden Jede Methode braucht einen Namen, z.B. public static void main(String[] args) {â€¦} ï‚§ Konvention: ï‚§ FÃ¤ngt mit einem Kleinbuchstaben an ï‚§ Weitere Einzelworte starten mit einem Grossbuchstaben (Â«lower camel caseÂ»). ï‚§ Weiteres Beispiel: toUpperCase Weitere Regeln und Konventionen folgen spÃ¤ter. 30 Namen: Reservierte Bezeichner 31 ï‚§ SchlÃ¼sselwort (Â«keywordÂ»): Ein Bezeichner, der reserviert ist, weil er fÃ¼r die Sprache eine besondere Bedeutung hat. In Java: abstract default if private this assert do implements protected throw boolean double import public throws break else instanceof return transient byte enum int short try case extends interface static var catch final long strictfp void char finally native super volatile class float new switch while continue for package synchronized false true null const goto Kommentare: Syntax Kommentare (Â«commentsÂ») sind Notizen im Programmtext, die ï‚§ Menschen beim Verstehen des Programmes helfen (sollen) ï‚§ Keinen Einfluss auf die ProgrammausfÃ¼hrung haben ï‚§ 2 Varianten 1. // Text bis zum Ende der Zeile (d.h. einzeilig) 2. /* Text bis zum schliessenden Stern-SchrÃ¤gstrich-Paar (d.h. mehrzeilig) */ 32 /* * Das vermutlich einfachste Java-Programm der Welt. * Author: ChatBot3000 */ public class HelloWorld { // Hinweis: Parameter args aktuell nicht genutzt public static void main(String[] args) { System.out.println(\"Moin!\"); // TODO: \"Hoi\" besser? } // main() endet hier } 33 Kommentare: BeispielZeichenketten ï‚§ Zeichenketten (Â«stringsÂ») ï‚§ Folge von Zeichen (Â«charactersÂ») ï‚§ Eingeschlossen in \"-AnfÃ¼hrungszeichen (Â«double quotesÂ») ï‚§ Drei Beispiele: \"Hallo Welt\", \"hallo welt\", \"3+2\" ï‚§ EinschrÃ¤nkungen 1. Nur eine Zeile lang: \"Dies hier ist kein Java-String, da mehrzeilig\" 2. Darf Zeichen \" nicht enthalten: \"So geht \"es\" nicht\" 34 Zeichenketten: Sonderzeichen Es gibt Ersatzdarstellungen (Â«escape sequencesÂ») mit denen ein Sonderzeichen ausgedrÃ¼ckt werden kann ï‚§ Fangen alle mit \\ (RÃ¼ckwÃ¤rtsschrÃ¤gstrich, Â«backslashÂ») an, z.B. \\n Neue Zeile (Â«new line characterÂ») \\\" AnfÃ¼hrungszeichen, Â«double quotesÂ», Â«quotation markÂ» \\\\ RÃ¼ckwÃ¤rtsschrÃ¤gstrich, Â«backslashÂ» \\t Tabulator, Â«tabÂ» ï‚§ Vorangestelltes \\ heisst Maskierungszeichen Â«escape characterÂ» 35 Sonderzeichen: Beispiele ï‚§ Code: System.out.println( \"\\\\Hallo\\nWie\\tgeht's \\\"uns\\\"?\\\\\\\\\"); ï‚§ Ausgabe: \\Hallo Wie geht's \"uns\"?\\\\ 36 Sonderzeichen: Fragen 1. Was wird jeweils ausgegeben? System.out.println(\"a\\tb\\\\\\tc\"); System.out.println(\"'\"); System.out.println(\"\\\"\\\"\\\"\"); System.out.println(\"C:\\neuer-S\\tiefel\"); 2. Welche Zeichenkette fÃ¼hrt zu folgender Ausgabe? / \\ /// \\\\\\ 37 Bemerkung: println vs. print ï‚§ println(str): Gibt effektiv str gefolgt von \"\\n\" aus ï‚§ D.h. nach der Ausgabe von str erfolgt ein Zeilenumbruch ï‚§ print(str): Gibt nur str aus ï‚§ Erlaubt es, eine zusammenhÃ¤ngende Ausgabe (eine Zeile) Ã¼ber mehre prints zu verteilen ï‚§ KÃ¼nstliches Beispiel: ï‚§ Einsatz spÃ¤ter sinnvoller, wenn wir AusdrÃ¼cke (und Schleifen) kennen 38 System.out.print(\"OberflÃ¤che = \"); System.out.print(\"700\"); System.out.println(\" cm2\"); Java OberflÃ¤che = 700 cm2 Ausgabe Java-Programme Erstellen und AusfÃ¼hren Zwei MÃ¶glichkeiten: 39 B) Einzelne Anweisungen ï‚§ FÃ¼r jede Anweisung â€¦ ï‚§ Lesen (Read) ï‚§ Evaluieren (AusfÃ¼hren) ï‚§ Ausgeben (Print) ï‚§ REPL ï‚§ Read-Evaluate-Print Loop A) Ganzes Programm ï‚§ FÃ¼r jede Datei â€¦ ï‚§ Erstellen ï‚§ AusfÃ¼hren ï‚§ Modifizieren Bisher Jetzt kurz 40 Ein Java-Befehl (hier: ein Methodenaufruf)Resultierende Ausgabe JShell REPL: Start Aufruf JShell auf der Kommandozeile 41 JShell REPL: Methoden Eingabe einer Methode â€¢ Methode jetzt global bekannt â€¢ Kein public static notwendig â€¢ Praktisch fÃ¼r kleine Programme Methodenaufruf und erzeugte Ausgabe 42 JShell REPL: AutovervollstÃ¤ndigung Tab(ulator)-Taste â€¢ Listet existierende Befehlsoptionen auf â€¢ VervollstÃ¤ndigt, falls eindeutig â€¢ Zeigt Hilfe zu Standardmethoden an Java-Programme Erstellen und AusfÃ¼hren ï‚§ Zwei MÃ¶glichkeiten ï‚§ FÃ¼r jede Datei âœ skaliert, fÃ¼r grÃ¶ssere Programme ï‚§ FÃ¼r einzelne Anweisungen âœ flexible, fÃ¼r schnelle Experimente ï‚§ Regeln fÃ¼r Java-Programme bleiben dieselben ï‚§ Scheint manchmal nicht der Fall zu sein â€“ liegt daran, dass die REPL den Code im Hintergrund in ein Â«vollstÃ¤ndigesÂ» Java-Programm einbettet ï‚§ Fokus dieser Vorlesung: Arbeiten mit Dateien, da essenziell fÃ¼r komplexere Programme 43 2. Erste Java-Programme 2.1 EinfÃ¼hrung: Vom Quelltext zur Ausgabe 2.2 Methoden I: Programmstrukturierung 2.3 Einfache Berechnungen 2.4 Input und Random 2.5 Logische Aussagen Ã¼ber Programm(segment)e 44 Methoden: Was? ï‚§ Methode: Benannte Sequenz von Anweisungen 45 ï‚§ Beispiel: main (im Program HelloWorld) ï‚§ Methode enthÃ¤lt Anweisungen ï‚§ Diese werden beim Methodenaufruf ausgefÃ¼hrt (main wird beim Programmstart automatisch aufgerufen) Methoden: Warum? ï‚§ Methoden strukturieren die Anweisungen ï‚§ Anstatt alle Anweisungen in einer Methode (main) unterzubringen ï‚§ Methoden erlauben es, Wiederholungen zu vermeiden ï‚§ Nur einmal im Programm(text) ï‚§ Aber mehrfach aufrufbar und somit ausfÃ¼hrbar ï‚§ Jede Methode stellt eine neue, spezialisierte Anweisung dar ï‚§ Idee hinter Programmierbibliotheken 46 Programmentwicklung: Grobes Rezept 1. Gesamtaufgabe in Teilaufgaben zerlegen ï‚§ Erfordert ProblemverstÃ¤ndnis und ProblemlÃ¶sestrategien 2. Teilaufgaben in separaten Methoden lÃ¶sen ï‚§ Teilaufgaben sind kleiner, LÃ¶sungen daher einfacher zu implementieren 3. TeillÃ¶sungen zu GesamtlÃ¶sung zusammensetzen ï‚§ Siehe Punkt 1 47 Einstiegsbeispiel ï‚§ Aufgabe: Programm, das Text ausgibt ï‚§ Gesucht: 48 -------- Warnung: sichern Sie die Daten -------- Lange ErklÃ¤rung -------- Warnung: sichern Sie die Daten -------- Aufgabe Programm Ausgabe ï‚§ Wie zerlegen? Wie weit/kleinteilig zerlegen? ï‚§ Keine fixen Regeln, die immer zum Erfolg fÃ¼hren ï‚§ Keine objektiv beste Zerlegung ï‚§ Stattdessen: Heuristiken ï‚§ Jede Methode sollte eine klare Aufgabe haben ï‚§ Ausbildung: Hinweise (Â«hintsÂ»), Vorgaben ï‚§ Beruf: Erfahrung, Diskussionen ï‚§ Zerlegung ï‚§ Bisher nur relevant fÃ¼r Menschen, aber dem Computer egal ï‚§ Neu auch relevant fÃ¼r KI-gestÃ¼tzte Entwicklung (fokussierte Prompts)49 Programm Aufgabe T1 Teil2 T3 Zerlegen in Teilaufgaben T1, T2, ..., TnEinstiegsbeispiel: 1. Zerlegung ï‚§ Aufgabe: Programm, das Text ausgibt ï‚§ 1. Zerlegung ï‚§ Teilaufgabe Ti: i-te Zeile in einer println() Anweisung ausgeben ï‚§ Anweisung Ai fÃ¼r Teilaufgabe Ti ï‚§ Ai hintereinander ausfÃ¼hren âœ Gesamtausgabe erhalten 50 Aufgabe T1 â€¦ Tn -------- Warnung: sichern Sie die Daten -------- Lange ErklÃ¤rung -------- Warnung: sichern Sie die Daten -------- Ausgabe AnA1 â€¦ Code 1. Zerlegung public class PrintExampleV1 { public static void main(String[] args) { System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Lange ErklÃ¤rung\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } // Ende main } 51 Code 1. Zerlegung 52 public class PrintExampleV1 { public static void main(String[] args) { System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Lange ErklÃ¤rung\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } // Ende main } -------- Warnung: sichern Sie die Daten -------- Lange ErklÃ¤rung -------- Warnung: sichern Sie die Daten -------- AusgabeJava ï‚§ Beobachtung: Redundanz (Wiederholungen im Programm) ï‚§ Gesucht: Zerlegung, die die Struktur der Aufgabe widerspiegelt Zerlegen in Teilaufgaben ï‚§ Sich wiederholende Teilauf- gaben erkennen, so dass die Anweisungen fÃ¼r (viele) Ti wiederverwendbar sind ï‚§ Anweisungen fÃ¼r Ti in Methode Mi ï‚§ Methoden (statt einzelner Anweisungen) hinterein- ander ausfÃ¼hren 5353 Aufgabe Programm Auf- gabe T1 Tn A1 â€¦ Anâ€¦ Auf- gabe v1: zu kleinteilig v2: besser? T2 T2T1 T3 M1 M3M2 M2 Einstiegsbeispiel ï‚§ Aufgabe: Programm, das Text ausgibt ï‚§ 2. Zerlegung ï‚§ Teilaufgabe T1 : drucke Warnung ï‚§ Teilaufgabe T2 : drucke ErklÃ¤rung ï‚§ Resultierendes Programm ï‚§ M1; M2; M1; 54 -------- Warnung: sichern Sie die Daten -------- Lange ErklÃ¤rung -------- Warnung: sichern Sie die Daten -------- Code 2. Zerlegung public class PrintExampleV2 { public static void main(String[] args) { // GesamtlÃ¶sung printWarning(); printExplanation(); printWarning(); } public static void printWarning() { // T1 bzw. M1 System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } public static void printExplanation() { // T2 bzw. M2 System.out.println(\"Lange ErklÃ¤rung\"); } } 55 Wie entstehen Methoden? 56 class method main statement statement statement statement statement statement statement statement statement MÃ¶glichkeit A: Im Nachhinein 1. Entwickeln des Algorithmus ï‚§ ProblemverstÃ¤ndnis, LÃ¶sungsidee ï‚§ Aufteilung in Teilprobleme 2. Implementation des Algorithmus ï‚§ In einem StÃ¼ck, z.B. alles in main() Wie entstehen Methoden? MÃ¶glichkeit A: Im Nachhinein 1. Entwickeln des Algorithmus ï‚§ ProblemverstÃ¤ndnis, LÃ¶sungsidee ï‚§ Aufteilung in Teilprobleme 2. Implementation des Algorithmus ï‚§ In einem StÃ¼ck, z.B. alles in main() 3. Code nachtrÃ¤glich aufteilen ï‚§ Wiederverwendbare FunktionalitÃ¤t identifizieren, Redundanz vermeiden 57 class method main stepOne() statement stepTwo() method stepOne statement statement method stepTwo statement statement Vorteile? Nachteile?Wie entstehen Methoden? MÃ¶glichkeit B: Teilproblemen folgend 1. Entwickeln des Algorithmus ï‚§ ProblemverstÃ¤ndnis, LÃ¶sungsidee ï‚§ Aufteilung in Teilprobleme ï‚§ Wiederkehrende Teilprobleme direkt identifizieren 2. Implementation des Algorithmus ï‚§ In einzelnen, von Teilproblemen abgeleiteten Methoden 58 class method main stepOne() statement stepTwo() method stepOne statement statement method stepTwo statement statement Wie entstehen Methoden? MÃ¶glichkeit B (Teilproblemen folgend) ist grundsÃ¤tzlich vorzuziehen ï‚§ Strukturiert den Entwicklungsprozess (kleine, Ã¼berschaubare Einheiten statt einem langen Codeblock) ï‚§ Vermeidet Redundanz (statt diese im Nachhinein zu entfernen) ï‚§ ErmÃ¶glicht Teamarbeit (fÃ¼r uns nicht wichtig, aber in der Praxis essenziell) 59 MÃ¶glichkeit A kann aber ï‚§ FÃ¼r den Anfang einfacher sein ï‚§ Â«LokalÂ» fÃ¼r die Entwicklung einzelner Methoden genutzt werden Methodenaufrufe public class PrintExampleV2 { public static void main(String[] args) { printWarning(); printExplanation(); printWarning(); } public static void printWarning() { ... } public static void printExplanation() { ... } } 60 ï‚§ Beobachtung: Methodenaufruf im Format methName(); ï‚§ Nur fÃ¼r statische Methoden (SchlÃ¼sselwort static) ï‚§ Nicht-statische Methoden schauen wir uns spÃ¤ter an (Aufrufformat obj.methName();) ï‚§ Aber wie lÃ¤uft ein Methoden- aufruf eigentlich ab â€¦? ZunÃ¤chst: Linearer Kontrollfluss 61 ï‚§ Sequenzen von Anweisungen werden, wie im Programmtext stehend, von oben nach unten* ausgefÃ¼hrt ï‚§ Dies nennt sich linearer Kontrollfluss (Â«linear control flowÂ») public class ControlFlowExample1 { public static void main(String[] args) { System.out.println(\"Zeile 1\"); System.out.println(\"Zeile 2\"); System.out.println(\"Zeile 3\"); } } * Verzweigungen und Schleifen lernen wir spÃ¤ter kennen Java Zeile 1 Zeile 2 Zeile 3 Ausgabe Kontrollfluss mit Methodenaufrufen 62 main() { statement1; name(); statement2; } name() { statement3; statement4; } ï‚§ Die Anweisung name() stellt einen Methodenaufruf (Â«callÂ», Â«invocationÂ») dar ï‚§ Wird sie ausgefÃ¼hrt dann 1. Spring die AusfÃ¼hrung (der Kontrollfluss) an den Anfang der entsprechenden Methode 2. Werden die Anweisungen innerhalb der Methode von oben nach unten (linear) ausgefÃ¼hrt 3. Springt die AusfÃ¼hrung zurÃ¼ck hinter den (nun beendeten) Methodenaufruf Kontrollfluss mit Methodenaufrufen 63 main() { statement1; name(); statement2; } name() { statement3; statement4; } Effektiv werden die Anweisungen hier daher wie folgt ausgefÃ¼hrt: 1. statement1; 2. statement3; 3. statement4; 4. statement2; Kontrollfluss mit Methodenaufrufen 64 main() { statement1; name(); statement2; } name() { statement3; statement4; } Hinweis: Die Reihenfolge der Methoden im Programmtext ist (in Java) irrelevant name() { statement3; statement4; } main() { statement1; name(); statement2; } == GrÃ¶sseres Beispiel: Schrittweise AusfÃ¼hrung 65 public class ControlFlowExample2 { public static void main(String[] args) { System.out.println(\"Anfang\"); message1(); System.out.println(\"Mitte\"); message2(); System.out.println(\"Ende\"); } public static void message1() { System.out.println(\"1. Nachricht\"); } public static void message2() { message1(); System.out.println(\"2. Nachricht\"); } } Anfang 1. Nachricht Mitte 1. Nachricht 2. Nachricht Ende Java Ausgabemain(â€¦) { â€¦println(\"Anfang\"); // msg1() â€¦println(\"1. N't\"); â€¦println(\"Mitte\"); // msg2() // msg1() â€¦println(\"1. N't\"); â€¦println(\"2. N't\"); â€¦println(\"Ende\"); } GrÃ¶sseres Beispiel: MÃ¶gliche ErklÃ¤rungshilfe 66 main(â€¦) { â€¦println(\"Anfang\"); msg1(); â€¦println(\"Mitte\"); msg2(); â€¦println(\"Ende\"); } msg1() { â€¦println(\"1. N't\"); } msg2() { msg1(); â€¦println(\"2. N't\"); } Die Darstellung rechts visualisiert indirekt den Aufrufstapel â€” lernen wir spÃ¤ter kennen Eine neue Aufgabe â€¦ ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 67 Schreiben Sie ein Programm, dass diese Figuren ausgibt Entwicklungsschritte ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 68 Version 1: Ohne Ausnutzen der Struktur 1. Programm mit leerer main-Methode erstellen 2. ErwÃ¼nschte Ausgabe in main kopieren; fÃ¼r jede Zeile eine entsprechende println- Anweisung 3. Programm ausfÃ¼hren; erwartete und erhaltene Ausgabe vergleichen Programm Version 1 69 public class Figures1 { public static void main(String[] args) { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(\"+--------+\"); System.out.println(); System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"| STOP |\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"+--------+\"); } // method \"main\" } // class \"Figures1\"...... Entwicklungsschritte ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 70 Version 2: Mit Ausnutzen der Struktur, mit Redundanz 1. Vorhandene Strukturen identifizieren 2. main-Methode in separate Methoden aufteilen, basierend auf obiger Strukturierung 3. Programm ausfÃ¼hren; erwartete und erhaltene Ausgabe vergleichen Entwicklungsschritte ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 71 Strukturen in dieser Figur (von oben nach unten) ï® Â«SechseckÂ» âœ Methode hexagon() ï® Â«WanneÂ» âœ tub() ï® Â«StopschildÂ» âœ stopSign() ï® Â«HutÂ» âœ hat() public static void hexagon() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); } public static void tub() { System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(\"+--------+\"); System.out.println(); } Programm Version 2 72 public class Figures2 { public static void main(String[] args) { hexagon(); tub(); stopSign(); hat(); }......... public static void hat() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"+--------+\"); } } // class \"Figures2\" Programm Version 2 (Fortsetzung) 73 public static void stopSign() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"| STOP |\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); }.........Entwicklungsschritte ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 74 Version 3: Mit Ausnutzen der Struktur, ohne Redundanz 1. Vorhandene (Teil-) Strukturen und Redundanzen identifizieren 2. Methoden so erstellen, dass Redundanzen (soweit mÃ¶glich/sinnvoll) vermieden werden 3. Code kommentieren 4. Programm ausfÃ¼hren Redundanz in der Ausgabe ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 75 Mehrfach auftretende Teilstrukturen ï® Obere HÃ¤lfte Hexagon âœ Methode hexagonTop() ï® Untere HÃ¤lfte Hexagon âœ hexagonBottom() ï® Trennlinie âœ line() // Draws the top half of a hexagon. public static void hexagonTop() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); } // Draws a hexagon's bottom half. public static void hexagonBottom() { System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); } Programm Version 3 76 // Author: Maija MeikÃ¤lÃ¤inen, 24-135-678 // Prints several figures, split up into // methods that capture common // (sub)structures. public class Figures3 { public static void main(String[] args) { hexagon(); System.out.println(); tub(); System.out.println(); stopSign(); System.out.println(); hat(); }......... Programm Version 3 (Fortsetzung) 77 // Draws a stopSign. public static void stopSign() { hexagonTop(); System.out.println(\"| STOP |\"); hexagonBottom(); } // Draws a hat-shaped figure. public static void hat() { hexagonTop(); line(); } } // class \"Figures3\" // Draws a complete hexagon. public static void hexagon() { hexagonTop(); hexagonBottom(); } // Draws a tub-shaped figure. public static void tub() { hexagonBottom(); line(); } // Draws a line. public static void line() { System.out.println(\"+--------+\"); }.........Ãœbungsaufgabe /\\ / \\ / \\ / \\ +-------+ | | | | | | +-------+ | | | ISS | | | +-------+ | | | | | | +-------+ /\\ / \\ / \\ / \\ 78 Schreiben Sie ein Programm, dass diese Rakete ausgibt: 2. Erste Java-Programme 2.3 Einfache Berechnungen 2.3.1 EinfÃ¼hrung: Typen, Variablen, Werte 2.3.2 AusdrÃ¼cke Ã¼ber Basistypen 2.3.3 Variablendeklaration und -initialisierung 79 (Sinnvolles) Arbeiten mit Daten ï‚§ Programme operieren auf Daten, z.B. eines Boots ï‚§ HÃ¶he, LÃ¤nge, Tiefe; Kaufpreis; Name; Standort; â€¦ ï‚§ Nicht alle Operationen (Berechnungen) sind sinnvoll LÃ¤nge mal Breite mal HÃ¶he 75% des Kaufpreises Finde kÃ¼rzesten Weg zwischen Standort und vorgestern Starte eine Hausbootzucht ï‚§ Ziel von Programmiersprachen: Sinnvolle Berechnungen ermÃ¶glichen, unsinnige verhindern 80Bootgrafik erzeugt mit Image Creator in Bing ï ïƒ» ï ïƒ» Typen: Was? ï‚§ Ein Typ (Â«typeÂ») beschreibt eine Kategorie von Werten/Daten ï‚§ Ã„hnlich zu mathematischen Mengen ï‚§ Z.B. â„¤ (ganze Zahlen) vs. â„š (rationale Zahlen) ï‚§ Typen beschreiben Eigenschaften von Daten ï‚§ Bestimmt die Operationen, die fÃ¼r diese Werte mÃ¶glich sind ï‚§ Z.B. Typen Â«BoatÂ» vs. Â«KatzeÂ» â€” welche Eigenschaften/Operationen teilen sie, welche unterscheiden sie? 81 Typen: Warum? ï‚§ Viele Programmiersprachen erfordern explizite Typangaben ï‚§ Sicherheit (Probleme verhindern/erkennen) â€” fÃ¼r EProg wichtig ï‚§ Dokumentation â€” fÃ¼r EProg wichtig ï‚§ Effizienz â€” fÃ¼r EProg nicht/weniger wichtig ï‚§ Sicherheit: Typen verhindern Fehler ï‚§ Kann AHV-Nummer nicht zum Gehalt addieren ï‚§ Dokumentation: Typen spezifizieren die Teile einer Berechnung ï‚§ Was wird erwartet (Preis? Standort?), was wird berechnet? 82 Acht primitive Typen (Â«primitive typesÂ»): fÃ¼r Zahlen, Buchstaben und Wahrheitswerte. Beispiele: Name Beschreibung Beispiele ï‚§ int ganze Zahlen -2147483648, -3, 0, 42, 2147483647 ï‚§ long grosse ganze Zahlen 42, -3, 0, 9223372036854775807 ï‚§ double reelle Zahlen 3.1, -0.25, 9.4e3 ï‚§ char (einzelne) Buchstaben 'a', 'X', '?', '\\n' ï‚§ boolean Wahrheitswerte true, false 83 Primitive Typen in Java Wer es genau wissen mÃ¶chte: Java Language Specs Â§4.2 ï‚§ Die Programmiersprache legt fest, wie ein Typ implementiert ist ï‚§ Implementiert = Darstellung der Werte und Definition der Operationen ï‚§ Interne Darstellung aller Werte durch Nullen und Einsen ï‚§ 97 âœ 01100001 ï‚§ \"ab\" âœ 01100001 01100010 ï‚§ Was bedeutet 01100001? âœ Typen wichtig ï‚§ \"a\".toUpperCase() sinnvoll, aber 97.toUpperCase() nicht ASCII-Tabelle \"a\" 97 01100001 \"b\" 98 01100010 84 Typen: Von Bitfolgen zu DatenAnwendung: OberflÃ¤che eines Quaders 85 ï‚§ Gegeben: Dimensionen eines Quaders ï‚§ Aufgabe: Java-Programm zur Berechnung der OberflÃ¤che ï‚§ OberflÃ¤che in cm2: 2 â‹… (70 â‹… 27 + 27 â‹… 40 + 40 â‹… 70) 70 cm 40 cm 27 cm Quader: Klaus-Dieter Keller, via Wikimedia, CC BY-SA 3.0 public class Quader { // OberflÃ¤chenberechnung fÃ¼r einen bestimmten Quader public static void main(String[] args) { System.out.print(\"Die OberflÃ¤che betrÃ¤gt \"); System.out.print(2 * (70 * 27 + 27 * 40 + 40 * 70)); System.out.println(\" cm2\"); } } 86 Ausgabe: Die OberflÃ¤che betrÃ¤gt 11540 cm2 70 cm 40 cm 27 cm Entsprechendes Programm public class Quader { // OberflÃ¤chenberechnung fÃ¼r einen bestimmten Quader public static void main(String[] args) { System.out.print(\"Die OberflÃ¤che betrÃ¤gt \"); System.out.print(2 * (70 * 27 + 27 * 40 + 50 * 70)); System.out.println(\" cm2\"); } } 87 Ausgabe: Die OberflÃ¤che betrÃ¤gt 12940 cm2 70 cm 40 cm 27 cm Unaufmerksamkeit â€¦ Fehler sind schnell gemacht 88 Variablen ï‚§ Variablen (Â«variablesÂ») geben Werte (z.B. 40) sinnvolle Namen (z.B. height) ï‚§ Konzept aus der Mathematik bekannt ï‚§ In Berechnungen werden Variablen durch ihre Werte Â«ersetztÂ» ï‚§ Z.B. height * height steht (hier) fÃ¼r 40 * 40 und ergibt daher 1600 ï‚§ Aber Programmvariablen kÃ¶nnen sich Ã¤ndern (spÃ¤ter mehr) ï‚§ Erforderlich fÃ¼r Variablen in Java: Name und Type ï‚§ Hier wÃ¤ren ganzzahlige Werte sinnvoll âœ int-getypte Variable 89 public static void main(String[] args) { int length; int height; int depth; length = 70; height = 40; depth = 27; System.out.print(\"Die OberflÃ¤che betrÃ¤gt \"); System.out.print(2 * (length*depth + depth*height + height*length)); System.out.println(\" cm2\"); } Ausgabe: Die OberflÃ¤che betrÃ¤gt 11540 cm2 Programm mit Variablen } // Deklarationen } // Initialisierung durch Wertzuweisungen Variablendeklaration Eine Variable muss deklariert (Â«declaredÂ») werden (d.h. bekannt gemacht werden, angekÃ¼ndigt werden) ï‚§ Syntax: type name; ï‚§ FÃ¼r einen gÃ¼ltigen Java-Typ type (wir lernen viele Typen kennen) ï‚§ Variable name kann nun jeden Wert vom Typ type speichern ï‚§ Beispiel: int height; ï‚§ Variablenname (fast) frei wÃ¤hlbar ï‚§ Regel: Kein Java-SchlÃ¼sselwort, muss mit einem Buchstaben anfangen ï‚§ Konvention: Camel-Case, mit kleinem Buchstaben beginnend 90 Variablendeklaration und -initialisierung ï‚§ Eine Variable kann deklariert und direkt initialisiert (Â«initialisedÂ»> (d.h. einen Wert bekommen) ï‚§ Syntax: type name = expression; ï‚§ FÃ¼r einen Typ type und einen dazu passenden Ausdruck expression (mehr zu AusdrÃ¼cken spÃ¤ter, zunÃ¤chst Ausdruck â‰ˆ Wert) ï‚§ Beispiel: int height = 40; ï‚§ Das Zeichen = bedeutet Zuweisung (Â«assignmentÂ») ï‚§ Effekt: Variable hat ab jetzt diesen Wert ï‚§ Eine Zuweisung ist keine mathematische Gleichheit, auch wenn der Operator leider so aussieht. SpÃ¤ter mehr dazu. 9192 public static void main(String[] args) { int length = 70; int height = 40; int depth = 27; System.out.print(\"Die OberflÃ¤che betrÃ¤gt \"); System.out.print(2 * (length*depth + depth*height + height*length)); System.out.println(\" cm2\"); } Ausgabe: Die OberflÃ¤che betrÃ¤gt 11540 cm2 Programm mit Variablen } // Deklaration und direkte Initialisierung 93 public static void main(String[] args) { int length; System.out.print(length); } ï‚§ Lokale Variablen von primitivem Typ (etwas anderes kennen wir bisher nicht) haben keinen Standardwert, sondern mÃ¼ssen explizit initialisiert werden ï‚§ Wird versucht, den Wert einer (solchen) uninitialisierten Variable zu nutzen, gibt es einen Compilerfehler Standard-Initialisierung fÃ¼r Basistypen? Compilation problem: Local variable x not initialized Die JShell verhÃ¤lt sich hier anders und initialisiert solche Variablen mit einem Standardwert, z.B. 0 fÃ¼r int Variablennamen als Dokumentation ï‚§ Variablennamen sind Computern egal â€” aber Menschen nicht ï‚§ Gute Namen helfen beim Verstehen eines Programs ï‚§ Selbstbeschreibend (z.B. length, lunchPreference, twintAccount) ï‚§ Halbwegs kurz (lengthInMM vs. lengthInTheMetricSystemUnitMillimeter) ï‚§ Unterscheidbar (im Kontext) (name1, name2 vs. firstName, middleName) 94 Variablennamen als Dokumentation ï‚§ Gute Namen zu finden ist nicht (immer) einfach ï‚§ Insbesondere Ã¼ber Berechnungen mit Zwischenwerten hinweg (salary, salaryAfterRaise, salaryAfterRaiseWithChristmasBonus, â€¦) ï‚§ Kurze Name (z.B. i, x, n) OK fÃ¼r kurzlebige Variablen ï‚§ Namen sind wichtig! Aber seien Sie pragmatisch, nicht dogmatisch 95 Typen als Dokumentation ï‚§ Java unterstÃ¼tzt Typinferenz (Â«type inferenceÂ»), d.h. Typ- informationen kÃ¶nnen manchmal weggelassen werden. Bsp.: ï‚§ Empfehlung: Typen explizit angeben âœ Dokumentation Welche Werte kann result nun haben â€” Wahrheitswerte ((un)bekannt), Zeichenketten (Name), Zahlen (Postleitzahl)? 96 int score = 99; String name = \"GhÃ¼s\"; var score = 99; var name = \"GhÃ¼s\"; var result = findHomeCityForLegi(\"24-135-987\"); Wer definiert Typen? GÃ¼ltige Java-Typen sind ï‚§ Immer verfÃ¼gbare Basistypen (eingebaute Typen) ï‚§ Primitive Typen, z.B. int ï‚§ Typen aus Javas Standardbibliothek, z.B. String ï‚§ Benutzerdefinierte Typen (spÃ¤ter mehr dazu) ï‚§ Von uns ï‚§ Aus Bibliotheken Dritter 97 2. Erste Java-Programme 2.3 Einfache Berechnungen 2.3.1 EinfÃ¼hrung: Typen, Variablen, Werte 2.3.2 AusdrÃ¼cke Ã¼ber Basistypen 2.3.3 Variablendeklaration und -initialisierung 98 Basistypen ï‚§ 27 und 2 * (length*depth + â€¦) sind AusdrÃ¼cke (Â«expressionsÂ») ï‚§ Was sind die Regeln fÃ¼r AusdrÃ¼cke? ï‚§ ZunÃ¤chst fÃ¼r Zahlen (int, double) ï‚§ EBNF-Regel expr 99 â€¦ int depth = 27; â€¦println(2 * (length*depth + depth*height + height*length)); <integer> âŸµ [<sign>] {<digit>} <number> âŸµ <integer> | <integer> . {<digit>} | <sign> . {digit} <op> âŸµ + | - | * | / | % <atom> âŸµ <number> | <identifier> <term> âŸµ ( <expr> ) | <atom> <expr> âŸµ <term> {<op> <term>} EBNF-Beschreibung Ausdruck (expr) 1. (UnvollstÃ¤ndige) Beschreibung fÃ¼r Java-AusdrÃ¼cke ï‚§ Keine Ãœberraschungen ... wie in der Mathematik/Schule ï‚§ number beschreibt Zahl-Literale (Â«number literalsÂ») 2. Beschreibt nur die Syntax â€” keine Typen, keine Semantik 100 Arithmetische Operatoren ï‚§ Operatoren (Â«operatorsÂ»): Bilden AusdrÃ¼cke aus TeilausdrÃ¼cken ï‚§ + Addition - Subtraktion (oder Negation) ï‚§ * Multiplikation / Division % Modulo (Rest) ï‚§ MÃ¼ssen festlegen, was Â«X â¨‚ YÂ» bedeutet (â¨‚ Operator; X, Y int-getypte AusdrÃ¼cke) ï‚§ Was ist das Ergebnis (Semantik)? ï‚§ Was fÃ¼r einen Typ hat das Ergebnis? 101 Arithmetische Operatoren: Ergebnisse Operatoren +, *, -: Wie in der Mathematik â€” zumindest fast ï‚§ Zahlen intern als endliche Bitfolge reprÃ¤sentiert: FÃ¼r int/long sind es 32/64 Bits. D.h. es gibt eine kleinste und grÃ¶sste Zahl. ï‚§ Verhalten: MIN â€“ 1 gleich MAX, MAX + 1 gleich MIN ï‚§ Unter-/Ãœberlauf, wie bei einer Uhr ï‚§ Wird in Digitaltechnik (2. Semester) im Detail besprochen 102Uhr: HackaLittleBit, via Wikimedia, CC BY-SA 4.0 Arithmetische Operatoren: Typen ï‚§ FÃ¼r Operatoren +, *, -, /, %: TypA â¨‚ TypA ergibt TypA ï‚§ Beispiele ï‚§ 2 * 3 ergibt 6 mit Typ int (weil 2 und 3 ints sind) ï‚§ -(7) ergibt -7 mit Typ int (weil 7 ein int ist) ï‚§ Naheliegende Fragen 1. Welchen int-Wert liefert, z.B. 5 / 2? âœ jetzt 2. Welchen Typ liefert TypA â¨‚ TypB? âœ spÃ¤ter 103 Ganzzahlige Division mit / ï‚§ Division zweier ganzer Zahlen ergibt wieder eine ganze Zahl ï‚§ Die mathematisch anfallenden Nachkommastellen werden abgeschnitten (Â«truncatedÂ») ï‚§ Beispiele ï‚§ 5 / 2 ergibt 2 (nicht 2,5) ï‚§ 10 / 6 ergibt 1 (nicht 1,666â€¦) ï‚§ 32 / -5 ergibt -6 (nicht -6,4) ï‚§ Division durch 0 fÃ¼hrt zum Programmabbruch (Laufzeitfehler) 104 Rest ganzzahliger Division mit % ï‚§ Der Modulo-Operator % liefert den Rest ganzzahliger Division ï‚§ Beispiele ï‚§ 5 % 2 ergibt 1 ï‚§ 10 % 6 ergibt 4 ï‚§ 32 / -5 ergibt 2 ï‚§ Es gilt stehts: (a / b) * b + (a % b) ergibt a ï‚§ Division durch 0 fÃ¼hrt zum Programmabbruch 105 EinsatzmÃ¶glichkeiten Modulo-Operator ï‚§ Bestimme die letzte Ziffer einer ganzen Zahl ï‚§ 230857 % 10 ist 7 ï‚§ Bestimmte letzten 4 Ziffern ï‚§ 658236489 % 10000 ist 6489 ï‚§ Entscheide, ob eine Zahl gerade ist ï‚§ 7 % 2 ergibt 1 ï‚§ 42 % 2 ergibt 0 106 Fragen: Was ist das Ergebnis von â€¦ 1. 10 / 4 2. -23 / 11 3. 8 % 20 4. 2 % 2 5. 11 % -4 6. -11 % -4 7. -11 % 4 107 AusdrÃ¼cke mit mehreren Operatoren ï‚§ ZunÃ¤chst: Mehrfach der gleiche Operator â¨‚ ï‚§ Was bedeutet Â«X â¨‚ Y â¨‚ ZÂ»? ï‚§ 7 + 5 + 3 âœ (7 + 5) + 3 ï‚§ 64 / 8 / 2 âœ (64 / 8) / 2 (nicht 64 / (8 / 2)) ï‚§ Gegeben Â«X â¨‚ Y â¨‚ ZÂ», zu welchem Operator gehÃ¶rt Y: dem linken, dem rechten? 108 AssoziativitÃ¤t ï‚§ Die AssoziativitÃ¤t (Â«associativityÂ») eines Operators bestimmt, wie ein Operand verwendet wird ï‚§ Ist ein Operator â¨‚ ï‚§ Linksassoziativ (Â«left-associativeÂ») âœ X â¨‚ Y â¨‚ Z gleich (X â¨‚ Y) â¨‚ Z ï‚§ Rechtsassoziativ (Â«right-associativeÂ») âœ X â¨‚ Y â¨‚ Z gleich X â¨‚ (Y â¨‚ Z) 109 AssoziativitÃ¤t ï‚§ Beispiele fÃ¼r OperatorassoziativitÃ¤t ï‚§ Linksassoziativ: +, *, /, % ï‚§ Rechtsassoziative: spÃ¤ter ï‚§ Nebenbemerkung: In der Mathematik ist ein Operator assoziativ, falls gilt, dass (X â¨‚ Y) â¨‚ Z gleich X â¨‚ (Y â¨‚ Z) 110 AusdrÃ¼cke mit verschiedenen Operatoren ï‚§ Was bedeutet Â«X â¨‚ Y âŠ™ ZÂ» fÃ¼r zwei verschiedenen Operatoren â¨‚ und âŠ™? ï‚§ Beispiel: 2 + 6 * 5 âœ 2 + (6 * 5) (nicht (2 + 6) * 5) ï‚§ Operand Y wird mit dem Operator mit der hÃ¶heren PrÃ¤zedenz (Â«precedenceÂ») verknÃ¼pft ï‚§ Auch BindungsstÃ¤rke oder Rangordnung genannt ï‚§ Bei den uns bisher bekannten Operatoren gilt Â«Punkt vor StrichÂ» ï‚§ D.h. *, /, % binden stÃ¤rker als +, - 111 Implizite Klammerung 1. Operand wird vom Operator mit hÃ¶herer PrÃ¤zedenz gebunden 2. Wenn zwei Operatoren dieselbe PrÃ¤zedenz haben, dann entscheidet die AssoziativitÃ¤t 3. Wenn zwei Operatoren dieselbe PrÃ¤zedenz und AssoziativitÃ¤t haben, dann werden die (Teil-)AusdrÃ¼cke von links nach rechts ausgewertet ï‚§ Explizite Klammern verwenden ï‚§ Wenn eine andere Auswertung gewÃ¼nscht ï‚§ Wenn AusdrÃ¼cke komplexer werden (âœ Lesbarkeit) 112 Implizite Klammerung: Beispiel 6 + x / 2 * y / und * binden (gleich) stÃ¤rker als + / links von *, daher / zuerst âœ 6 + (x / 2) * y danach * âœ 6 + ((x / 2) * y) zuletzt + âœ (6 + ((x / 2) * y)) 113 AusdrucksbÃ¤ume 114 Ein (vollstÃ¤ndig geklammerter) Ausdruck lÃ¤sst sich als Ausdrucksbaum (Â«expression treeÂ») darstellen + * % 4*1 2 3 5 (1 * 2) + ((3 * 5) % 4) Ausdruck Baum Evaluationsreihenfolge 115 Die Operanden eines Operators werden von links nach rechts ausgewertet/evaluiert (Â«evaluatedÂ») âœ Ergebnisberechnung + * % 4*1 2 3 5 (1 * 2) + ((3 * 5) % 4) \\_/ | 2 + ((3 * 5) % 4) \\_/ | 2 + ( 15 % 4) \\____/ | 2 + 3 \\___________/ | 5 2 3 15 5 Fragen: Wozu evaluieren diese AusdrÃ¼cke? 1. 9 / 5 ergibt 1 2. 695 % 20 ergibt 15 3. 7 + 6 * 5 ergibt 37 4. 7 * 6 + 5 ergibt 47 5. 248 % 100 / 5 ergibt 9 6. 6 * 3 - 9 / 4 ergibt 16 7. 6 + 18 % (17 - 12) ergibt 9 116 Typ double fÃ¼r Kommazahlen ï‚§ Beispielliterale vom Typ double: ï‚§ 6.022, -42.0 â€” wie ganze Zahlen, aber mit einem Punkt ï‚§ 1e2, 1e-3, 2.143e17 â€” Exponentenschreibweise XeY steht fÃ¼r ğ‘‹ğ‘‹ â‹… 10 ğ‘Œğ‘Œ ï‚§ Arithmetische Operatoren +, -, *, /, % auch fÃ¼r double definiert ï‚§ Division nun wie erwartet: 15.0 / 2.0 ergibt 7.5 ï‚§ AssoziativitÃ¤t und PrÃ¤zedenz wie bisher 117 Beispielevaluation ï‚§ 2.0 * 2.4 + 2.25 * 4.0 / 2.0 ï‚§ \\___/ | ï‚§ 4.8 + 2.25 * 4.0 / 2.0 ï‚§ \\___/ | ï‚§ 4.8 + 9.0 / 2.0 ï‚§ \\_____/ | ï‚§ 4.8 + 4.5 ï‚§ \\____________/ | ï‚§ 9.3 118 Double ungleich reelle Zahlen ï‚§ Werte vom Typ double werden intern mit 64 Bit dargestellt âœ endliche Darstellung ï‚§ GrÃ¶sste/kleinste Werte ï‚§ Rundungsfehler (LÃ¼cken im Wertebereich) ï‚§ double-Werte heissen Fliesskommazahlen (Â«floating point numbersÂ»). Grobe Idee: ï‚§ 0,01 Â· 107 = 1,0 Â· 105 = 100 Â· 103 Normalisierung durch Exponentenanpassung (Â«Komma fliesstÂ») ï‚§ 64 Bit fÃ¼r das Paar (Vorkommazahl, Exponent) â€” platzeffiziente Speicherung ï‚§ Details in Digitaltechnik (2. Semester) und Numerische Methoden (3. Sem.) 119 AusdrÃ¼cke mit verschiedenen Typen ï‚§ FÃ¼r Operatoren +, *, -, /, %: TypA â¨‚ TypA ergibt TypA ï‚§ Welchen Typ liefert der gemischte Ausdruck TypA â¨‚ TypB? ï‚§ 3 / 2.0 ergibt â€¦? Das gleiche wie 3.0 / 2? ï‚§ Kombination int/long und double ergibt double ï‚§ 3 / 2.0 und 3.0 / 2 ergeben 1.5 ï‚§ 4.0 / 2 ergibt 2.0 (nicht den int 2) ï‚§ Umwandlung (Â«conversionÂ») vom kleineren zum grÃ¶sseren Typ ï‚§ Separat fÃ¼r jeden Operator bzw. dessen Operanden ï‚§ Implizit (automatisch) â€“ explizite Typumwandlungen spÃ¤ter 120 ïƒ¼ Beispielevaluation Umwandlung geschieht fÃ¼r jeden Operator 121 ï‚§ 7 / 3 * 1.2 + 3 / 2 ï‚§ \\_/ | ï‚§ 2 * 1.2 + 3 / 2 ï‚§ \\___/ | 2.4 + 3 / 2 ï‚§ \\_/ | ï‚§ 2.4 + 1 ï‚§ \\________/ | ï‚§ 3.4 + / 3 2 1 * 1.2/ 7 3 2.4 2 3.4 Typherleitung Baumstruktur auch praktisch fÃ¼r die Typherleitung 122 + / 3 2 int * 1.2/ 7 3 double int double Fragen: Wozu evaluieren diese AusdrÃ¼cke? 1. 4 + 8 / 3.0 * 6 + 5 ergibt 25.0 2. 9.0 / (2.0 / 3) + 7 ergibt 20.5 3. 7 % 3 * 2 + 4.0 * 3 / 2 ergibt 8.0 4. 9 / (2 / 3) + 7 ergibt Laufzeitfehler 5. 20 % 8 + 15 / 27 / (3 % 6) ergibt 4 123 Explizite Typumwandlungen ï‚§ Gesehen: Impliziten Umwandlungen bei Operatoren ï‚§ Beispiel: 1.0 / 4 ergibt double ï‚§ Explizite Typumwandlung heissen Â«CastÂ» (Â«Type CastÂ») ï‚§ Anwendungen ï‚§ PrÃ¤zision erhÃ¶hen: z.B. int zu double casten, damit eine Division das gewÃ¼nschte exakte Ergebnis liefert ï‚§ PrÃ¤zision senken: z.B. um ungewollte Nachkommenstellen abzuschneiden 124 Explizite Typumwandlungen ï‚§ Syntax:(type) expression ï‚§ Beispiele ï‚§ (double) 19 / 5 ergibt 3.8 (statt 3) ï‚§ (int) (2.1e3 / 1.3e4 * 100) ergibt 16 (statt 16.15â€¦) ï‚§ (type) ist ein Operator ï‚§ Der Â«cast operatorÂ» ï‚§ Binder stÃ¤rker (hÃ¶here PrÃ¤zedenz) als arithmetische Operatoren ï‚§ UnÃ¤r und rechtsassoziativ â€” wandelt nur den Operanden rechts daneben um ï‚§ FÃ¼r fast alle primitiven Typen verfÃ¼gbar 125 Cast-Operator ï‚§ Cast-Operator bezieht sich nur auf seinen rechten Operanden ï‚§ Was ergeben â€¦? ï‚§ (double) 1 + 1 / 2 ergibt 1.0 ï‚§ 1 + (double) 1 / 2 ergibt 1.5 ï‚§ (double) (2 + 1 + 1) / 3 ergibt 1.333â€¦ 1. Java vs. Python: Modulo mit negativen Zahlen Abschluss numerische AusdrÃ¼cke Die Folien dieser Vorlesung zeigen die Regeln (z.B. PrÃ¤zedenzen) fÃ¼r Java. FÃ¼r andere Programmiersprachen gelten (eventuell) andere Regeln. Beispiele: 127 1. Python vs. Excel: PrÃ¤zedenz Negation und Potenzierung Abschluss numerische AusdrÃ¼cke ï‚§ Java kennt noch weitere numerische Datentypen und Literalformate ï‚§ Regeln und Verhalten analog zu bisher Gezeigtem (int und double), unterscheiden sich in unterstÃ¼tzten Wertebereichen ï‚§ Details fÃ¼r uns nicht weiter relevant âœ bei Bedarf nachschlagen ï‚§ Beispiele (Auswahl) ï‚§ Typ short, Wertebereich -128 to 127 (keine eigenen Literale) ï‚§ Typ long, Wertebereich -263 to 263 â€“ 1 (Literale mit Suffix L, z.B. 9876543210L) ï‚§ Typ char (Zeichen, spÃ¤ter mehr), Wertebereich 0 bis 65535 (Literale z.B. 'g', '\\u042Eâ€™) ï‚§ Weitere Integer-Literalformate (Auswahl) ï‚§ Mit Dezimaltrenner, z.B. 10_000, 1_000_000 ï‚§ Hexadezimal (z.B. 0xFF) 128Relevante Java-Spezifikation auf docs.oracle.com: Typen, Literale 129 Zwischenstand Typen und Operationen 1. Primitive Typen â€“ Beispiele int und double ï‚§ Haben Werte (4, 2.17) und Operationen (Division mittels /) gesehen 2. Typen aus der Java-Standardbibliothek â€“ Beispiel String ï‚§ Haben Werte bereits gesehen (\"hello\", \"2 + 3\") ï‚§ Jetzt: Verkettung mittels Plus-Operator ï‚§ SpÃ¤ter: Operationen mittels Methoden (\"hello\".toUpperCase()) ï‚§ 3. SpÃ¤ter: Selbst entwickelte Typen 130 Zeichenketten verketten ï‚§ Verkettung (Konkatenation, Â«concatenationÂ») von String: Der Operator + erlaubt es, zwei Strings zusammenzufÃ¼gen ï‚§ \"You\" + \"Tube\" ergibt \"YouTube\" ï‚§ \":\" + \"-\" + \")\" ergibt \":-)\" ï‚§ Verkettung kann verschiedene Typen kombinieren ï‚§ Was sollte/kÃ¶nnte 3 + \" Grad Celsius\" ergeben? 131 Einschub: Standarddarstellung als String ï‚§ In Java gibt es fÃ¼r jeden Wert eine Darstellung als String ï‚§ Gilt fÃ¼r alle Typen ï‚§ Standarddarstellung immer vorhanden âœ kann jeden Wert mittels println(â€¦) ausgeben ï‚§ Standarddarstellung mÃ¶glicherweise nicht ideal; kann fÃ¼r selbstentwickelte Typen auch geÃ¤ndert werden ï‚§ FÃ¼r primitive Typen und Strings wie zu erwarten, z.B. ï‚§ FÃ¼r 42 und -36.7 wie erwartet \"42\" und \"-36.7Â« ï‚§ Mit int x = 77 fÃ¼r x wie erwartet \"77\" 132 ZurÃ¼ck zur Zeichenkettenverkettung ï‚§ Verkettung eines Strings mit einem Wert anderen Typs: Verkettung mit der Standarddarstellung des anderen Werts ï‚§ 3 + \" Grad Celsius\" ergibt \"3 Grad Celsius\" ï‚§ \"Olympia \" + 2024 ergibt \"Olympia 2024Â« ï‚§ Praktisch fÃ¼r die Erzeugung von Ausgabe double grade = 5.25 + 0.25; System.out.println(\"PrÃ¼fungsnote ist \" + grade); // erzeugt Ausgabe \"PrÃ¼fungsnote ist 5.5\" Fragen: Wozu evaluieren diese AusdrÃ¼cke? Auswertungsregeln wie gehabt ï‚§ 12 â€“ 3 + 5 ï‚§ 2 + 3 + \" Zehen\" ï‚§ \"Nummer \" + 3 + 2 ï‚§ \"Nummer\" + 2 * 3 ï‚§ \"Note \" + (4.8 + 5.2) / 2 ï‚§ \"Note \" + 4.8 + 5.2 / 2 133 2. Erste Java-Programme 2.3 Einfache Berechnungen 2.3.1 EinfÃ¼hrung: Typen, Variablen, Werte 2.3.2 AusdrÃ¼cke Ã¼ber Basistypen 2.3.3 Variablendeklaration und -initialisierung 134 Variablen â€“ Bereits bekannt Deklarationen (AnkÃ¼ndigung/Bekanntmachung mit Typinformation) Initialisierung (erstmalige Wertzuweisung; Schreibzugriff) Zuweisung (Schreibzugriff) Auswertung (Evaluation; Lesezugriff) 135 double inch; inch = 6.4; double centimeter = inch * 2.54; System.out.println( inch + \"\\\" sind \" + centimeter + \"cm\"); inch = 22; System.out.println( inch + \"\\\" sind \" + inch * 2.54 + \"cm\"); Deklaration Deklaration einer Variable: Reserviert Speicherplatz gross genug fÃ¼r Werte des entsprechenden Typs 136 int teeth; teeth = 28; double speed = 0.83; ... ... int âœ 32 Bit Platz double âœ 64 Bit Kennen Speicherplatz unter Namen Â«teethÂ» Â«speedÂ» Deklaration Deklaration einer Variable: Reserviert Speicherplatz gross genug fÃ¼r Werte des entsprechenden Typs ï‚§ Intuitive Vorstellung eines Â«Speicherbands mit benannten ZellenÂ» fÃ¼r uns ausreichend ï‚§ Weitere technische Details z.B. in Compiler Design 137 ... ... int âœ 32 Bit Platz double âœ 64 Bit Kennen Speicherplatz unter Namen Â«teethÂ» Â«speedÂ» int teeth; teeth = 28; double speed = 0.83; Initialisierung Initialisierung einer Variable: Erstmaliges Schreiben (Zuweisen) eines Werts in den reservierten Speicherplatz 138 int teeth; teeth = 28; double speed = 0.83; 28 0.83... ... teeth speed MÃ¶gliche Fehler ï‚§ Fehlende Deklaration (jede Variable muss deklariert werden) ï‚§ Nutzung vor Deklaration ï‚§ Mehrfachdeklaration (Typen irrelevant) 139 // int teeth; teeth = 28; Unresolved compilation problem: teeth cannot be resolved to a variable teeth = 28; int teeth; Unresolved compilation problem: teeth cannot be resolved to a variable int teeth; long teeth; Unresolved compilation problem: Duplicate local variable teeth MÃ¶gliche Fehler ï‚§ Fehlende Initialisierung (lokale Variablen haben keinen Standardwert) ï‚§ Initialisierung mit Wert falschen Typs 140 int teeth; println(teeth); Unresolved compilation problem: The local variable teeth may not have been initialized int teeth; teeth = \"28\"; Unresolved compilation problem: Type mismatch: cannot convert from String to int Zuweisung Zuweisung einer Variable: Schreiben eines (neuen) Werts in den entsprechenden Speicherplatz 141 int teeth = 28; teeth = (13 + 17) / 2; ... teeth 2815 16 Evaluation Auswerten einer Variable: In Aus- drÃ¼cken evaluiert eine Variable zu dem Wert, den die Speicherzelle zu diesem Zeitpunkt hat 142 int teeth = 28; println( teeth ); teeth = (13 + 17) / 2; println( teeth + 1 ); ... teeth 2815 Java 28 16 Ausgabe Evaluation + Zuweisung Variable evaluiert zum aktuellen Wert âœ neuer Wert kann von diesem abhÃ¤ngen 143 int teeth = 28; teeth = teeth + 1; ... teeth 2829 Zuweisung ist keine Gleichheit! ï‚§ Mathematik: ğ‘¥ğ‘¥ = ğ‘¥ğ‘¥ + 1 (Â«x ist gleich sich selbst plus 1Â») sinnfrei ï‚§ Informatik: Sinnvoll, da eine Zuweisung einen Effekt hat (ZustandsÃ¤nderung) Animierte Folie, evtl. Vorlesungsaufzeichnung anschauen 2. Erste Java-Programme 2.1 EinfÃ¼hrung: Vom Quelltext zur Ausgabe 2.2 Methoden I: Programmstrukturierung 2.3 Einfache Berechnungen 2.4 Input und Random 2.5 Logische Aussagen Ã¼ber Programm(segment)e 145 Interaktive Programme ï‚§ Programm kann auf Benutzer (AusfÃ¼hrer:in des Programms) reagieren ï‚§ Z.B. Lesen eines Input-Texts ï‚§ Aufforderung zur Eingabe eines Inputs ï‚§ Einlesen des durch Benutzer getippten Inputs in Variable ï‚§ Ausgabe von Text auf Bildschirm ï‚§ Verschiedene Input-Quellen mÃ¶glich, z.B. ï‚§ Konsole (Â«consoleÂ») ï‚§ Datei ï‚§ Website ï‚§ Datenbank ï‚§ Und viele mehr 146 Konsole (Â«consoleÂ») ï‚§ FrÃ¼her: mit Computer verbundenes externes GerÃ¤t ï‚§ Heute: Fenster im User Interface ï‚§ Standard-Input (System.in in Java) ï‚§ Standard-Output (System.out in Java) 147 Eclipse verwendet ein Fenster um System.in und System.out zu zeigen! Konsole: User LPfi on the Swedish Wikipedia (on Commons: LPfi) [CC BY-SA ] Input ist komplex ï‚§ Unterschiedliche Input-Quellen ï‚§ Verhalten von Benutzer ist nicht vorhersehbar oder kontrollierbar ï‚§ Fehlerhafte Eingaben mÃ¼ssen abgefangen werden ï‚§ Umwandeln der Darstellung auf Konsole zu Darstellung in Programm (z.B. dezimal zu binÃ¤r) ï‚§ Mehr dazu in Â«Digital Design and Computer ArchitectureÂ» im FrÃ¼hling In Java: Scanner bietet diese FunktionalitÃ¤t fÃ¼r Input an ï‚§ bei Output kÃ¼mmert sich z.B. println darum 148 Scanner: Syntax ï‚§ Scanner aus Bibliothek java.util importieren ï‚§ import java.util.Scanner; ï‚§ Scanner-Objekt konstruieren mit Angabe der Input-Quelle ï‚§ Scanner name = new Scanner(System.in); ï‚§ Aufruf einer Methode mit Punktnotation (Â«dot notationÂ») 149 Input-QuelleEin neues Objekt (eines nicht-primitiven Typs) kann mit dem Keyword new erstellt werden! Scanner: Eine Auswahl von Methoden 150 Method Description nextInt() reads an int from the user and returns it nextDouble() reads a double from the user â€¦ next() reads a one-word String from the user â€¦ nextLine() reads a one-line String from the user â€¦ Scanner myConsole = new Scanner(System.in); int alter = myConsole.nextInt(); System.out.println(\"Ihr Alter: \" + alter); Scanner: Dokumentation https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Scanner.html ï‚§ Alle Informationen und noch viel mehr ï‚§ Ignorieren Sie (vorerst), was Sie nicht verstehen 151 Scanner: Ablauf der Eingabe ï‚§ Ausgabe eines Prompts (Eingabeaufforderung) an Benutzer ï‚§ Erscheint im Konsolenfenster ï‚§ Information an Benutzer, dass (und welche) Eingabe erwartet wird ï‚§ Eingabe des Inputs durch Benutzer ï‚§ Unterbruch des Programms bis Eingabe erfolgt ist ï‚§ Eingabe wird beendet durch Enter-Taste ï‚§ Erscheint im gleichen Konsolenfenster wie Ausgabe ï‚§ Programm wird fortgesetzt 152 Scanner: Beispiel 1 153 import java.util.Scanner; public class UserInputExample { public static void main(String[] args) { Scanner myConsole = new Scanner(System.in); System.out.print (\"Wie alt sind Sie? \"); // Prompt int alter = myConsole.nextInt(); int jahre = 65 â€“ alter; System.out.println(jahre + \"Jahre bis zur Pensionierung\"); } } Wie alt sind Sie? 33 Jahre bis zur Pensionierung 32 Scanner: Warnung zu Resource Leak ï‚§ geÃ¶ffnete Ressourcen (Dateien, â€¦) mÃ¼ssen wieder geschlossen werden ï‚§ geschieht z.B. in einem try-Block (mehr dazu spÃ¤ter) ï‚§ Scanner ohne diesen Block fÃ¼hrt zu Warnung ï‚§ Warnung kann fÃ¼r den Moment ignoriert werden! 154 Scanner: Beispiel 2 155 import java.util.Scanner; public class UserInputExample { public static void main(String[] args) { Scanner myConsole = new Scanner(System.in); System.out.print(\"Zwei Zahlen bitte: \"); // Prompt int a = myConsole.nextInt(); int b = myConsole.nextInt(); int product = a * b; System.out.println(product); } } mehrere Zahlen in einer Zeile (bis Enter) lesen Zwei Zahlen bitte: 42 6 7 Beispiel: Falscher Input System.out.print(\"Wie alt sind Sie? \"); int alter = myConsole.nextInt(); Wie alt sind Sie? Exception in thread \"main\" java.util.InputMismatchException at java.util.Scanner.throwFor(Scanner.java:964) at java.util.Scanner.next(Scanner.java:1619) at java.util.Scanner.nextInt(Scanner.java:2284) ... Zweiunddreissig Falscher Input-Typ Eingabeelement (Â«tokenÂ») 157 ï‚§ Folge von Zeichen, die vom Scanner am StÃ¼ck gelesen werden ï‚§ Scanner muss wissen, wo Beschreibung aufhÃ¶rt (und anfÃ¤ngt) ï‚§ Separiert durch Zwischenraum (Â«whitespaceÂ») ï‚§ Leerzeichen (Â«spaceÂ», Â«blankÂ»), Tabulator (Â«tabÂ»), neue Zeile (Â«new lineÂ») ï‚§ Kann kontextabhÃ¤ngig sein ï‚§ 45 18 $2.50 hello world ï‚§ $2.50 \"hello world\" 1.456E12 \"45 18\" ï‚§ Erwartete Zeichen hÃ¤ngen von Methode ab ï‚§ Z.B. Unterschied zwischen nextInt() und nextDouble() ï‚§ Braucht Beschreibung von legalen Zeichenfolgen (EBNF!) ï‚§ Fehlermeldung (zur Laufzeit), falls Token nicht den richtigen Typ/die richtige Form hat! Beispiel: next() 158 Scanner console = new Scanner(System.in); System.out.print(\"What is your name? \"); String name = console.next(); name = name.toUpperCase(); System.out.println(name + \" has \" + name.length() + \" letters \"); What is your name? Minnie MINNIE has 6 letters What is your name? Minnie Mouse MINNIE has 6 letters What is your name? \"Minnie Mouse\" \"MINNIE has 7 letters Liest ein Wort bis zum Zwischenraum Beispiel: nextLine() 159 Scanner console = new Scanner(System.in); System.out.print(\"What is your name? \"); String name = console.nextLine(); name = name.toUpperCase(); System.out.println(name + \" has \" + name.length() + \" letters \" + What is your name? Minnie MINNIE has 6 letters What is your name? Minnie Mouse MINNIE MOUSE has 12 letters What is your name? \"Minnie Mouse\" \"MINNIE MOUSE\" has 14 letters Liest eine Zeile Zufallszahlen (Â«random numbersÂ») ï‚§ Oft als Ersatz fÃ¼r Zahlen-Input 160 random {adjective} zufÃ¤llig willkÃ¼rlich [wahllos] zufallsbedingt Zufalls- dem Zufall Ã¼berlassen (aus EN-DE-WÃ¶rterbuch) (Pseudo-)Zufallszahlengenerator Random ï‚§ Random aus Bibliothek java.util importieren ï‚§ import java.util.Random; ï‚§ Random-Objekt konstruieren ï‚§ Random name = new Random(); ï‚§ Verschiedene Methoden fÃ¼r unterschiedliche Modi 161 Method Description nextInt() returns a â€random integerâ€ nextInt(n) returns a â€randomâ€ integer in the range [0, n) in other words: returns a number from {0, â€¦, n â€“ 1} at â€randomâ€ nextDouble() returns a â€œrandom realâ€ number in the range [0.0, 1.0) HÃ¤ufige Szenarien ï‚§ ZufÃ¤llige ganze Zahl aus [1, n] ï‚§ 1 + rand.nextInt(n) ï‚§ ZufÃ¤llige ganze Zahl aus [min, max] ï‚§ min + rand.nextInt(max â€“ min + 1) ï‚§ ZufÃ¤llige reelle Zahl aus [min, max] ï‚§ min + rand.nextDouble() * (max â€“ min) ï‚§ ZufÃ¤lliges Objekt aus einer Menge von n Objekten ï‚§ Beliebige Nummerierung der Objekte mit [1, n] oder [0, n-1] 162 Beispiel 1: WÃ¼rfel 163 import java.util.Random; public class DiceThrow { public static void main(String[] args) { Random rand = new Random(); int face = 1 + rand.nextInt(6); System.out.println(\"You threw a \" + face); } } Beispiel-Output: You threw a 6 Beispiel 2: ZufÃ¤llige Note in [1.0, 6.0] 164 import java.util.Random; public class RandomGrade { public static void main(String[] args) { Random rand = new Random(); double r = 5.0 * rand.nextDouble(); // 0 <= r <= 5 double grade = 1.0 + r; System.out.println(\"You got a \" + grade); } } Beispiel-Output: You got a 4.2 Beispiel 3: ZufÃ¤llige gerade Zahl zwischen 4 und 12 165 import java.util.Random; public class RandomGrade { public static void main(String[] args) { Random rand = new Random(); int r = 2 * rand.nextInt(5) + 4; System.out.println(r); } } Beispiel-Output: 6 2. Erste Java-Programme 2.5 Logische Aussagen Ã¼ber Programm(segment)e 2.5.1 Motivation, Aussagen, logisches Schliessen 2.5.2 Hoare-Tripel fÃ¼r Zuweisungen 166 Vogelperspektive Softwareentwicklung ï‚§ Grosse Programme werden aus einzelnen Modulen (Methoden, Klassen, Bibliotheken, â€¦) zusammen -gesetzt âœ Modulare Entwicklung ï‚§ Voraussetzung: Es muss klar spezifiziert werden, was ein Modul leisten soll ï‚§ FÃ¼r Modulentwickler/innen: Wann ist das Modul vollstÃ¤ndig bzw. was fehlt noch? ï‚§ FÃ¼r Modulnutzer/innen: Wie ist das Modul zu benutzen? Was kann ich erwarten? 167Bild mit Handy-Komponenten: ifixit.com Beispielspezifikationen Spezifikationen in Â«mathematischer SpracheÂ» (Logik âœ Diskrete Mathematik), damit eindeutig und beweisbar ï‚§ Vorbedingung (Â«preconditionÂ»): Was muss vor dem Aufruf gelten? ï‚§ Nachbedingung (Â«postconditionÂ»): Was gilt nach dem Aufruf? ï‚§ Hier als spezielle Java-Kommentare ins Programm geschrieben 168 // PRE: true // POST: âˆ€ i. vi â‰¤ vi+1 void sort(vector v) { ... // viel und komplexer Code ... } // PRE: x â‰¥ 0 // POST: result2 = x double sqrt(double x) { ... // viel und komplexer Code ... } result bezieht sich auf das Ergebnis der Berechnung (den RÃ¼ckgabewert der Methode) Vor- und Nachbedingungen: Zwei Perspektiven Eine Spezifikation aus Vor- und Nachbedingung etabliert quasi einen Vertrag: ï‚§ Entwickler/in muss nicht alle Nutzungen kennen; verlÃ¤sst sich auf die Vorbedingung ï‚§ Nutzer/in muss die Implementation nicht kennen; verlÃ¤sst sich auf die Nachbedingung 169 // PRE: x â‰¥ 0 // POST: result2 = x double sqrt(double x) double sqrt(double x) { // Kann x â‰¥ 0 annehmen // ... Code ... // Muss result2 = x garantieren } // Muss x â‰¥ 0 garantieren y = sqrt(x); // Kann y2 = x annehmen Methodenentwickler Methodennutzer Nutzen spezifizierter Software ï‚§ Vision ï‚§ Jedes Modul erhÃ¤lt eine formale Spezifikation ï‚§ Programm entsteht durch Kombination passender Module ï‚§ Mathematischer Beweis, dass das gesamte Programm das gewÃ¼nschte Ergebnis liefert/sich wie gewÃ¼nscht verhÃ¤lt ï‚§ FÃ¼r uns nÃ¼tzlich: Denken in Spezifikationen hilft beim Programmieren und kann die Entwicklung lenken ï‚§ Wir nutzen die Ideen und Konzepte informell/intuitiv ï‚§ Formale Theorie folgt dann in Formal Methods (4. Semester) 170Apfel-Puzzle: mathematica.stackexchange.com Einstieg: Aussagen Ã¼ber Programmsegmente ï‚§ Wir wollen eine Aussage Ã¼ber obige Berechnung tÃ¤tigen ï‚§ Muss Variable (Endergebnis) z involvieren ï‚§ Beziehen sich immer auf einen bestimmten Programmpunkt (Zeile) ï‚§ Diese Aussage ist die Nachbedingung des obigen Codes ï‚§ Beispiel: z > 0 (gilt dies?) 171 int u = ...; // u hat irgendeinen Wert int x = 17; int y = 42; int z = u + x + y; (Logische) Aussagen 172 ï‚§ Aussage (Â«assertionÂ»): Behauptung, die entweder wahr oder falsch ist ï‚§ Wir fragen dann oft Â«Ist die Aussage wahr?Â» oder Â«Gilt sie?Â» ï‚§ Â«LogischÂ» heisst hier Â«im Sinne der mathematischen LogikÂ» ï‚§ Diverse Beispiele: ï‚§ EProg ist ein Fach im Basisjahr Informatik ï‚§ Seebach ist der Hauptort des Kantons ZÃ¼rich ï‚§ 11 ist eine Primzahl ï‚§ 13 ist eine gerade Zahl ï‚§ x â‰¥ 0 (hÃ¤ngt von x ab) ï‚§ x geteilt durch 2 ergibt 8 (hÃ¤ngt von x ab) (Logische) Aussagen ï‚§ Aussage: Behauptung, die entweder wahr oder falsch ist ï‚§ Nicht alle Aussagen sind wahr ï‚§ Sind evtl. nur unter bestimmten Bedingungen wahr (z.B. Â«x % 5 ist 3Â») ï‚§ Wichtig ist, dass es Sinn macht zu fragen, ob die Aussage wahr oder falsch ist ï‚§ FÃ¼r uns: Im Kontext der Entwicklung eines Programms 173 int u = ...; int x = 17; int y = 42; int z = u + x + y; // Gilt Â«z > 0Â»? Aussagen in EProg ï‚§ Wir schreiben Aussagen als Kommentare in den Quelltext ï‚§ Kommentare âœ keine Bedeutung fÃ¼r Java, fÃ¼r uns aber schon ï‚§ Geschweifter Klammern Â«{â€¦}Â» sind Ã¼bliche Notation (LehrbÃ¼cher, Formal Methods) ï‚§ Die Kommentarzeichen Â«//Â» lassen wir aus PlatzgrÃ¼nden i.d.R. weg ï‚§ Wir nehmen mathematische Zahlen an: â„• statt int, d.h. keine ÃœberlÃ¤ufe (aber weiterhin ganzzahlige Division, d.h. 5 / 2 ist 2) 174 // {x > 0 und x < y} z = x * y; // {z > 0} {x > 0 und x < y} ... Falls Sie Vorkenntnisse haben: Wir nehmen ausserdem seiteneffektfreie AusdrÃ¼cke sowie sequenzielle AusfÃ¼hrung an VorwÃ¤rtsschliessen: Vorgehen ï‚§ Start: WÃ¤hlen (wissen, raten) einer sinnvollen Vorbedingung (Precondition = Assertion0) ï‚§ Schrittweise: Herleiten der nÃ¤chsten Aussage (Assertioni) durch Einbeziehen des Effekts der nÃ¤chsten Anweisung (Statementi) ï‚§ Ziel: Herleiten einer gÃ¼ltigen Nachbedingung (Postcondition = Assertionn) 175 {Precondition} Statement1; {Assertion1} Statement2; {Assertion2} ... Statementn; {Postcondition} ï‚§ VorwÃ¤rts = Â«Welche Garantien (Nachbedingung) kann mein Code, unter der gewÃ¤hlten Vorbedingung, geben?Â» VorwÃ¤rtsschliessen: Beispiel ï‚§ Wir wÃ¤hlen als Vorbedingung u > 0 ï‚§ Pro Schritt: Wenn vorher Aussage Ai-1 gilt, welche Aussage Ai gilt dann nach AusfÃ¼hrung des nÃ¤chsten Statements Si? ï‚§ Dann gilt die Nachbedingung z > 59 (warum?) 176 {u > 0} x = 17; {u > 0 âˆ§ x == 17} y = 42; {u > 0 âˆ§ x == 17 âˆ§ y == 42} z = u + x + y; {u > 0 âˆ§ x == 17 âˆ§ y == 42 âˆ§ z == u + 17 + 42} In Aussagen nutzen wir Â«==Â» fÃ¼r (mathematische) Gleichheit RÃ¼ckwÃ¤rtsschliessen: Vorgehen ï‚§ Start: WÃ¤hlen (wissen, raten) einer sinnvollen Nachbedingung ï‚§ Schrittweise: Herleiten der vorherigen Aussage (Assertioni) durch Einbeziehen des Effekts der nÃ¤chsten Anweisung (Statementi) ï‚§ Ziel: Herleiten einer notwendigen und hinreichenden Vorbedingung 177 {Precondition} Statement1; ... {Assertionn-2} Statementn-1; {Assertionn-1} Statementn; {Postcondition} ï‚§ RÃ¼ckwÃ¤rts = Â«Welche Vorbedingung braucht mein Code, damit er die gewÃ¤hlten Garantien (Nachbedingung) geben kann?Â» RÃ¼ckwÃ¤rtsschliessen: Beispiel ï‚§ Wir wÃ¤hlen als Nachbedingung z > 0 ï‚§ Pro Schritt: Wenn nach Statement Si Aussage Ai gelten soll, welche Aussage Ai-1 muss dann vor der AusfÃ¼hrung von Si gelten? ï‚§ Dann muss die Vorbedingung u > -59 gelten (warum?) 178 {u + 17 + 42 > 0} x = 17; {u + x + 42 > 0} y = 42; {u + x + y > 0} z = u + x + y; {z > 0} Vor-/RÃ¼ckwÃ¤rts: Gemeinsamkeit Beide Paare aus Vor- und Nachbedingung (Â«VertrÃ¤geÂ») sind gÃ¼ltig: Wenn vor der ProgrammausfÃ¼hrung die Vorbedingung gilt, dann gilt nach der AusfÃ¼hrung die Nachbedingung. 179 {u > 0} x = 17; {u > 0 âˆ§ x == 17} y = 42; {u > 0 âˆ§ x == 17 âˆ§ y == 42} z = u + x + y; {u > 0 âˆ§ x == 17 âˆ§ y == 42 âˆ§ z == u + 17 + 42} Vorw. {u > -59} x = 17; {u + x + 42 > 0} y = 42; {u + x + y > 0} z = u + x + y; {z > 0} RÃ¼ckw. Vor-/RÃ¼ckwÃ¤rts: Unterschiede VorwÃ¤rts ï‚§ Erscheint anfangs Â«natÃ¼rlicherÂ», da es dem (linearen) Kontrollfluss folgt ï‚§ HÃ¤lt viele Details in den Aussagen fest, die letztendlich irrelevant sind 180 {u > 0} x = 17; {u > 0 âˆ§ x == 17} y = 42; {u > 0 âˆ§ x == 17 âˆ§ y == 42} z = u + x + y; {u > 0 âˆ§ x == 17 âˆ§ y == 42 âˆ§ z == u + 17 + 42} Vorw. {u > -59} x = 17; {u + x + 42 > 0} y = 42; {u + x + y > 0} z = u + x + y; {z > 0} RÃ¼ckw. RÃ¼ckwÃ¤rts ï‚§ Code Â«rÃ¼ckwÃ¤rtszulesenÂ» erfordert Ãœbung, aber fÃ¼hrt zu einer neuen Sicht auf das Programm ï‚§ Grosser praktischer Nutzen: Sie (mÃ¼ssen) verstehen, was jede Anweisung zum Erreichen des gewÃ¼nschten Endzustands beitrÃ¤gt Aussagen zur Laufzeit: assert-Anweisung ï‚§ In Java-Programmen kÃ¶nnen Aussagen durch assert- Anweisungen ausgedrÃ¼ckt werden ï‚§ Syntax: assert expr; ï‚§ FÃ¼r einen gÃ¼ltigen Java-Ausdruck expr (mit Typ boolean âœ spÃ¤ter mehr) ï‚§ Daher keine geschweiften Klammern ({â€¦}) um die Aussage ï‚§ Beispiel: assert x > 0; ï‚§ Semantik: Programmabbruch, falls Aussage nicht hÃ¤lt ï‚§ Hilfreich, um eigene Annahmen zu Ã¼berprÃ¼fen 181 2. Erste Java-Programme 2.5 Logische Aussagen Ã¼ber Programm(segment)e 2.5.1 Motivation, Aussagen, logisches Schliessen 2.5.2 Hoare-Tripel fÃ¼r Zuweisungen 182 Hoare-Logik: Hintergrund ï‚§ Tony Hoare entwickelte in den 1970er Jahren einen formalen Ansatz, um Eigenschaften von Programmen beweisen zu kÃ¶nnen âœ Hoare-Logik (Â«Hoare logicÂ») ï‚§ Genutzt von z.B. Amazon, Microsoft, Airbus; aber auch von kleineren Firmen in CH, ZH ï‚§ Formale Beweise, plus Tools, in Formal Methods (4. Semester) ï‚§ Im (Arbeits-)Alltag genÃ¼gt es oft, weniger detailliert zu argumentieren, als es Hoare-Logik erfordert 183 {Precondition} statement1; {Assertion1} statement2; {Assertion2} ... statementn; {Postcondition} ï‚§ Unsere Ziele: Grundlegende Konzepte einfÃ¼hren und Ã¼ben, so dass 1. Sie fÃ¼r einfache Programme (relativ) genau argumentieren kÃ¶nnen 2. Ihnen der Einstieg in Formal Methods etwas leichter fÃ¤llt Logik und Programmentwicklung ï‚§ Sich mit Aussagen Ã¼ber Programmen zu beschÃ¤ftigen ist eine gute Schulung, systematisch zu programmieren ï‚§ Wir kÃ¶nnen Aussagen machen Ã¼ber ZustÃ¤nde (der AusfÃ¼hrung) eines Programms (und spÃ¤ter auch eines Objekts) ï‚§ D.h. wir kÃ¶nnen den Effekt eines Programms (semi-)formal beschreiben ï‚§ Wichtig fÃ¼r die Definition von Schnittstellen (zwischen Modulen), wenn wir entscheiden mÃ¼ssen, welche Bedingungen erfÃ¼llt sein mÃ¼ssen (z.B. um eine Methode aufzurufen) 184 Hoare-Tripel: Syntax ï‚§ Ein Hoare-Tripel (Â«Hoare tripleÂ»), auch 3-Tupel genannt, besteht aus zwei Aussagen und einem Programmsegment: ï‚§ Bestandteile eines Tripels ï‚§ P ist die Vorbedingung (Precondition, z.B. u > -59) ï‚§ S ist eine Anweisung (Statement; bzw. mehrere Anweisungen) ï‚§ Q ist die Nachbedingung (Postcondition, z.B. z > -59) 185 {P} S {Q} Hoare-Tripel: Bedeutung ï‚§ Ein Hoare-Tripel {P} S {Q} ist gÃ¼ltig wenn (und nur wenn): ï‚§ FÃ¼r jeden Zustand, fÃ¼r den P gÃ¼ltig ist, ergibt die AusfÃ¼hrung von S immer einen Zustand, fÃ¼r den Q gÃ¼ltig ist. ï‚§ Informell: Wenn P wahr ist vor der AusfÃ¼hrung von S, dann muss Q nachher wahr sein ï‚§ Andernfalls ist das Hoare-Tripel ungÃ¼ltig. 186 Hoare-Tripel etablieren ï‚§ Wie etablieren (â‰ˆ beweisen) wir ein Hoare-Tripel {P} S {Q}? ï‚§ FÃ¼r jede Java-Anweisung gibt es genaue Regeln, die eine Vor- und Nachbedingung (fÃ¼r diese Anweisung) in Beziehung setzen ï‚§ Regel fÃ¼r Zuweisungen ï‚§ Regel fÃ¼r aufeinander folgende Anweisungen ï‚§ Regel fÃ¼r Verzweigungen, Schleifen (spÃ¤ter) ï‚§ â€¦ ï‚§ Regeln existieren als VorwÃ¤rts- und RÃ¼ckwÃ¤rts-Version ï‚§ Wir lernen nur die RÃ¼ckwÃ¤rts-Regeln kennen, da relevanter 187 Hoare-Logik-Regel fÃ¼r Zuweisungen 188 ï‚§ Ziel: Wir wollen ein Tripel {P} X = E {Q} etablieren, also zeigen, dass es gÃ¼ltig ist ï‚§ P und Q sind Platzhalter fÃ¼r beliebige Aussagen ï‚§ X ist ein Platzhalter fÃ¼r eine beliebige Java-Variable ï‚§ E ist ein Platzhalter fÃ¼r einen beliebigen Java-Ausdruck ï‚§ Regel (Vorgehen, um GÃ¼ltigkeit zu zeigen) 1. Erhalte Q' durch: Ersetzen aller Vorkommen von X in Q durch E 2. Zeige, dass P â‡’ Q' gilt (Implikation, d.h. das Q' gilt wenn P gilt) ErklÃ¤rung 189 Intuition: Warum ergibt diese Regel Sinn? ï‚§ Schritt 1 (syntaktische Ersetzung von X durch E) 1. Nach der Zuweisung soll Q gelten 2. Die Zuweisung Ã¤ndert den Wert von X auf E â€“ sonst Ã¤ndert sich nichts âœ Wenn wir die Aussage Q mit E statt X formulieren (= Q'), muss diese Aussage bereits vor der Zuweisung gegolten haben ï‚§ Schritt 2 (Implikation) 1. Gerade argumentiert: Wenn Q' vor der Zuweisung gilt, gilt danach Q 2. P â‡’ Q' bedeutet, dass P eine stÃ¤rkere Vorbedingung als Q' ist âœ P ist daher eine hinreichende Vorbedingung (damit am Ende Q gilt) 1. Bilden von Q' durch Er- setzen aller X in Q durch E 2. Zeigen, dass P â‡’ Q' gilt {P} X = E {Q}Beispiel 1 190 1. Bilden von Q' durch Er- setzen aller X in Q durch E 2. Zeigen, dass P â‡’ Q' gilt {P} X = E {Q} {b + 25 > 30} a = b + 25; {a > 30} ï‚§ Tripel ist gÃ¼ltig ï‚§ X ist a, E ist b + 25, ï‚§ Q ist a > 30, P ist b + 25 > 30 ï‚§ Q' ist b + 25 > 30 ï‚§ P impliziert Q' trivialerweise, denn P ist gleich Q' Erinnerung: Wir gehen in Aussagen von mathematischen Zahlen aus, d.h. b + 25 fÃ¼hrt nie zu einem Ãœberlauf Beispiel 2 191 1. Bilden von Q' durch Er- setzen aller X in Q durch E 2. Zeigen, dass P â‡’ Q' gilt {P} X = E {Q} {b > 5} a = b + 25; {a > 30} ï‚§ Tripel ist gÃ¼ltig ï‚§ X ist a, E ist b + 25 ï‚§ Q ist a > 30, P ist b > 5 ï‚§ Q' ist b + 25 > 30 ï‚§ (b > 5) âŸ¹ (b + 25 > 30) (Beweis: einfache Formelumstellung) Beispiel 3 192 1. Bilden von Q' durch Er- setzen aller X in Q durch E 2. Zeigen, dass P â‡’ Q' gilt {P} X = E {Q} {b > 0} a = b + 25; {a > 30} ï‚§ Tripel ist nicht gÃ¼ltig ï‚§ X ist a, E ist b + 25 ï‚§ Q ist a > 30, P ist b > 0 ï‚§ Q' ist b + 25 > 30 ï‚§ P impliziert Q' nicht (Gegenbeispiel: wenn b den Wert 2 hat) Welche der folgenden Tripel sind (un)gÃ¼ltig? Fragen I 193 {x > 0} y = x + 1; {y > 1} {x > 100} y = x + 1; {y > 1} Bsp4 Bsp5 {v â‰  1} w = v * v; {w â‰  v} Bsp6 Welche der folgenden Tripel sind (un)gÃ¼ltig? Fragen II 194 {age > 94} age = age + 1; {age > 95} Bsp7 {y % z == 0} x = y / z; {y == x * z} Bsp8 Erinnerung: In Aussagen nutzen wir Â«==Â» fÃ¼r Gleichheit Aussagen kombinieren ï‚§ Beobachtung Programmentwicklung ï‚§ Gegeben zwei Programmsegmente S1 und S2, ergibt die Kombination S1; S2 ein grÃ¶sseres Programm ï‚§ D.h. wir entwickeln grÃ¶ssere Programme aus kleineren (ModularitÃ¤t) ï‚§ Analog fÃ¼r Tripel ï‚§ Gegeben {P1} S1 {Q1} und {P2} S2 {Q2} ï‚§ Wir mÃ¶chten diese zu {P1} S1; S2 {Q2} kombinieren 195 Hoare-Logik: Aussagen kombinieren 196 ï‚§ Wenn zwei Aussagen aufeinander treffen, muss die vorherige Aussage die darauf folgende implizieren {P1} S1; {Q1} {P2} S2; {Q2} {P1}{P2} S; {Q} ï‚§ Analog ï‚§ falls P1 âŸ¹ P2 ï‚§ --- falls Q1 âŸ¹ Q2 Die Kombination links erfordert, dass 1. Tripel {P1} S1 {Q1} gÃ¼ltig ist 2. Tripel {P2} S2 {Q2} gÃ¼ltig ist 3. Q1 âŸ¹ P2 gilt {P} S; {Q1}{Q2} Hoare-Logik: Aussagen kombinieren 197 Intuition ï‚§ Wenn P2 ausreicht, um S2 so auszufÃ¼hren, dass nachher Q2 gilt â€¦ ï‚§ â€¦ und wenn Q1 stÃ¤rker ist als P2 â€¦ ï‚§ â€¦ dann reicht auch Q1 aus, um S2 erfolgreich auszufÃ¼hren {P1} S1; {Q1} {P2} S2; {Q2} Die Kombination links erfordert, dass 1. Tripel {P1} S1 {Q1} und {P2} S2 {Q2} gÃ¼ltig sind 2. Q1 âŸ¹ P2 gilt Hoare-Logik-Regel fÃ¼r Anweisungsfolgen 198 ï‚§ Das Tripel {P} S1; S2 {Q} ist gÃ¼ltig, genau dann wenn ï‚§ Aussage R existiert, so dass 1. {P} S1 {R} gÃ¼ltig ist 2. {R} S2 {Q} gÃ¼ltig ist Beispiel 199 Finde R, so dass gilt 1. {P} S1 {R} 2. {R} S2 {Q} {P} S1; S2 {Q} {x > 0} y = x + 1; z = y * y {z > y} Mit R gleich y > 1 kÃ¶nnen wir GÃ¼ltigkeit zeigen: {x > 0} y = x + 1; {y > 1} z = y * y {z > y} 1. Tripel {x > 0} y = x + 1 {y > 1} ist gÃ¼ltig (Zuweisungsregel: x > 0 impliziert x + 1 > 0) 2. Tripel {y > 1} z = y + y {z > y} ist gÃ¼ltig (Zuweisungsregel: y > 1 impliziert y * y > y) Vorgehen fÃ¼r Anweisungsfolgen 200 ï‚§ Situation: Entscheide, ob {P} S1; S2 {Q} gÃ¼ltig ist ï‚§ Empfohlenes Vorgehen: {P} {R'} S1; {R} S2; {Q} 1. Wende bekannte Regeln an, um Folgendes zu erhalten: 2. Zeige Implikation P âŸ¹ R' Beispiel 201 {x > 0} {(x + 1) * (x + 1) > (x + 1)} y = x + 1; {y * y > y} z = y * y {z > y} 1. Regeln anwenden: 2. Implikation zeigen: (x > 0) âŸ¹ (x+1) * (x+1) > (x+1) hÃ¤lt, denn fÃ¼r x â‰¥ 2 ist x2 > x ï‚§ Frage: Ist {x > 0} y = x + 1; z = y * y {z > y} gÃ¼ltig? ï‚§ Antwort daher: Ja Frage ï‚§ Welche der folgenden Tripel sind gÃ¼ltig? 202 {true} x = y; z = x; {y == z} {x == 7 âˆ§ y == 5} t = x; y = x; x = t; {y == 7 âˆ§ x == 5} True als Vorbedingung bedeutet Â«keinerlei AnforderungÂ» (Anfangs- werte von x, y und z sind irrelevant) Welche Aussagen wollen wir? ï‚§ Gleicher Code, unterschiedliche (gÃ¼ltige) Tripel ï‚§ Frage: Gibt es Â«bessereÂ» und Â«besteÂ» Aussagen bzw. Tripel? ï‚§ Welches A-Tripel ist Â«besserÂ»? Welches B-Tripel? Warum? ï‚§ Was kÃ¶nnte eine allgemeine Definition von Â«besserÂ» sein? ï‚§ Besser fÃ¼r â€¦ wen eigentlich? 203 {a > 0 âˆ§ b > 0} x = a + b; {x > 0} vs. A1 {a + b > 0} x = a + b; {x > 0} A2 {true} x = y + 1; {x > y} {true} x = y + 1; {x == y + 1} vs. B1 B2 StÃ¤rkere und schwÃ¤chere Aussagen ï‚§ Wir kÃ¶nnen stÃ¤rkere und schwÃ¤chere Aussagen unterscheiden ï‚§ Wenn P1 âŸ¹ P2 gilt, dann ist P1 stÃ¤rker als P2 (und P2 schwÃ¤cher als P1) ï‚§ Beispiele 204 {a > 0 âˆ§ b > 0} x = a / b; {x > 0} vs. A1 {a + b > 0} x = a + b; {x > 0} A2 {true} x = y + 1; {x > y} {true} x = y + 1; {x == y + 1} vs. B1 B2 ï‚§ (a > 0 âˆ§ b > 0) âŸ¹ (a + b > 0), d.h. A1 hat die stÃ¤rkere Vorbedingung ï‚§ (x == y + 1) âŸ¹ (x > y), d.h. B2 hat die stÃ¤rkere Nachbedingung Beste Tripel? Zwei Perspektiven Perspektive 1: Sie mÃ¶chten existierenden Code nutzen (d.h. wir nehmen an, dass der Code Â«fixiertÂ» ist) 205 {P?} code {Q?} ï‚§ Je schwÃ¤cher die Vorbedingung, desto Ã¶fter nutzbar (breiter einsetzbar) ist der Code ï‚§ Beispiel: {a + b > 0} erlaubt den Einsatz in mehr Situationen (ist weniger Â«anspruchsvollÂ») als {a > 0 âˆ§ b > 0} ï‚§ Je stÃ¤rker die Nachbedingung, desto mehr Garantien bekommen Sie (desto mehr wissen Sie) als Code-Nutzer/in ï‚§ Beispiel: Mit {x == y + 1} wissen Sie, dass der Abstand zwischen x und y genau eins ist, anders als bei {x > y} Beste Tripel? Zwei Perspektiven Perspektive 2: Sie mÃ¼ssen Code fÃ¼r jemanden schreiben (wir nehmen an, dass die Anforderungen/das Tripel Â«fixiertÂ» sind) 206 {P} code? {Q} ï‚§ StÃ¤rkere Vorbedingung âœ mehr Garantien fÃ¼r Sie, d.h. Ihre Aufgabe wird einfacher ï‚§ Intuitives Beispiel: Â«Entwickeln Sie eine Texterkennung fÃ¼r englische BuchstabenÂ» vs. Â«â€¦ fÃ¼r BuchstabenÂ» ï‚§ SchwÃ¤chere Nachbedingung âœ Potenziell mehr Wahlfreiheit, daher eventuell einfacher, fÃ¼r Sie ï‚§ Intuitives Beispiel: Â«Endergebnis ist grÃ¶sser als nÂ» vs. Â«Endergebnis ist die nÃ¤chste Primzahl grÃ¶sser als nÂ» Automatisierung ï‚§ Es gibt (semi-)automatische* Algorithmen, um 1. Die schwÃ¤chste Vorbedingung, fÃ¼r gegebenen Code und Nachbedingung, zu berechnen 2. Die stÃ¤rkste Nachbedingung, fÃ¼r gegebenen Code und Vorbedingung, zu berechnen ï‚§ Zum Beispiel berechnet die kennengelernte Regel fÃ¼r Zuweisungen (Â«ersetze Vorkommnisse der zugewiesenen Variablen â€¦Â») die schwÃ¤chste Vorbedingung 207 * FÃ¼r relative einfache Programme; Problem letztendlich unentscheidbar (âœ Theoretische Informatik), daher braucht es * menschliche Hilfe. Details fÃ¼r EProg nicht relevant. {P?} code {Q} {P} code {Q?}","libVersion":"0.3.2","langs":""}