{"path":"sem3/EProg/VRL/extra/slides/EProg-slides-w02.pdf","text":"252-0027 Einführung in die Programmierung 2. Erste Java-Programme Manuela Fischer, Malte Schwerhoff Departement Informatik ETH Zürich 2. Erste Java-Programme 2.1 Einführung: Vom Quelltext zur Ausgabe 2.2 Methoden I: Programmstrukturierung 2.3 Einfache Berechnungen 2.4 Input und Random 2.5 Logische Aussagen über Programm(segment)e 2 Java-Programme erstellen und ausführen Zwei Möglichkeiten: 3 B) Einzelne Anweisungen  Für jede Anweisung …  Lesen (Read)  Evaluieren (Ausführen)  Ausgeben (Print)  REPL  Read-Evaluate-Print Loop A) Ganzes Programm  Für jede Datei …  Erstellen  Ausführen  Modifizieren Folgt jetzt Java: Vom Quellcode zu Ausgabe 4 Java-Programm (Quellcode) Java-Anweisung Java-Anweisung Java-Anweisung Java-Anweisung Ausgabe (Grafik) Ausgabe (Text) Die Note ist: 6.0 Ausgabe (...) 0929095 8395798 9216320 0082134 Java-Programm (Prozessor- Instruktionen) Check Befehl Befehl Befehl Check Check Befehl Prozessor + Laufzeit- system Übersetzt und prüft Führt aus und prüft CompilerEditor Java-Programme Erstellen und Ausführen  Ganzes Programm: Für jede Datei …  Erstellen — mit einem Editor  Ausführen — Compiler übersetzt, Prozessor führt aus  Modifizieren — nach Analyse der erhaltenen Ausgabe  Entwicklungsumgebungen («integrated development environments» = IDE) wie Eclipse  Enthalten notwendige Komponenten und Funktionalität  Sind Industriestandard, aber nicht zwingend notwendig 56 Java und Eclipse  Viele Aspekte  Zuerst: Fokus auf das wichtigste  Sie kennen Java/Eclipse schon: super  Aber denken Sie an die, die noch nicht so weit sind  Schrittweise erklären wir mehr Konzepte  Was uns (jetzt) nicht interessiert: abdecken  Können diese Teile nicht ignorieren  Müssen diese Teile (fürs Erste) akzeptieren 789 Unser erstes Java-Programm  Viele Aspekte nicht zwingend notwendig fürs Erste Verständnis  Ziele: Programme 1. lesen, 2. verstehen, 3. erstellen/modifizieren  Wir können leider nicht alle davon vollständig ignorieren … 10 Unser erstes Java-Programm Notwendige Struktur für ein eigenständiges Java-Programm Von uns implementierte Funktionalität 11 Unser erstes Java-Programm Wichtig (für den Anfang) 1. Programmname gleich Dateiname 2. Eine Klasse (class) pro Programm/Datei 12 Unser erstes Java-Programm  main: Java-Methode (Java-Code den wir ausführen können)  Methode enthält mehrere Anweisungen  Hier: println(\"…\") — gibt Text zwischen Anführungszeichen aus EBNF  Hält die Syntaxregeln von Java-Programmen fest  Beispiel: Bezeichner (Namen) in Programmen  Bezeichner («identifier») müssen Anforderungen erfüllen, z.B.  Bezeichner muss mindestens ein Zeichen lang sein  … muss mit einem (Unicode-)Buchstaben anfangen  … kann Buchstaben oder Ziffern (0-9) enthalten 13Wer es genau wissen möchte: Java Language Specs §3.8 EBNF-Regeln für Java (vereinfacht) EBNF-Beschreibung für einzelne Bezeichner (<identifier>): <lowercaseletter> ⟵ a | b | c | ... |z <uppercaseletter> ⟵ A | B | C | ... | Z <letter> ⟵ <lowercaseletter> | <uppercaseletter> <digit> ⟵ 0 | 1 | 2 | ... | 9 <identifier> ⟵ <letter> { <letter> | <digit> } 14 EBNF-Regeln für Java (vereinfacht) 15 EBNF-Beschreibung für ganze Programme (<javaprogram>): <javaprogram> ⟵ public class <identifier> { <methoddefinition> } <methoddefinition> ⟵ public static void main ( String [] <identifier> ) { <statementsequence> } Aufreihung von Anweisungen: <statementsequence>  Methode enthält eine Aufreihung («sequence») von Anweisungen («statements»)  Mögliche Anweisungen  Ein-/Ausgabe  Verzweigungen  Schleifen  Methoden-/Funktionsaufrufe  … 16 Aufreihung von Anweisungen: statementsequence  Mögliche Anweisungen  Methoden-/Funktionsaufrufe  …  Wichtig für viele Programmiersprachen, inklusive Java 17 1. Aufruf (global/lokal bekannter) Methoden Format: methodenName(); 2. Methodenaufruf für ein Objekt (Beispiel folgt) Format: objekt.methodenName(); Typisch für Java Beispiel Mit dem Objekt System.out können wir mit der println- Methode Text ausgeben System.out.println(…); Mehr über Text in ein paar Minuten — es gibt viele Methoden für Textbearbeitung jshell> \"Hello\".toUpperCase(); 18 MethodeObjekt Einschub: Objekte  Zentrales Konzept der Programmierung – zunächst (stark) vereinfacht, später mehr Details  Objekt (vereinfacht): Kann von Programm erstellt, gelesen und verändert werden  Hat einen Zustand ➜ Ansammlung an Werten  Hat ein Verhalten ➜ Operationen (für oder mit diesem Objekt)  Hat eine Identität ➜ Objekte können unterschieden werden  Intuitives Beispiel:  5 ∈ ℕ —Wert (eine Fünf ist und bleibt eine Fünf)  Tabelle (mit Werten aus ℕ) — Objekt, kann z.B. sortiert werden 1920 Ausführen (automatisch übersetzt – sonst geht Ausführung nicht) Java-Programme und Compilerfehler  Wir können Programmteile ignorieren, aber nicht weglassen  Sonst können wir das Java-Programm nicht übersetzen  Übersetzen (kompilieren, «compile») = in ausführbare Form bringen  Es gibt Fehlermeldungen wenn wir Teile weglassen/falsch schreiben 21 Java-Programm (Quellcode) Java Anweisungen Java Anweisungen Ausgabe ... Führt aus und prüft Compiler Java-Programm (Prozessor- Instruktionen) P1 Befehl P1 Befehl P1 Befehl P1 Check Übersetzt und prüft 222324 Rückmeldungen des Compilers sind nicht immer direkt verständlich Weiter geht’s … 2526 Leicht zu übersehen: die letzte } fehlt Zusammenfassung public class name { public static void main(String[] args) { statement; statement; ... statement; } } 27 Klasse = ein Programm mit Namen name Folge von Anweisungen = Funktionalität des Programm Methode main = Beginn der Ausführung des Programms Zusammenfassung  Jedes (ausführbare) Java-Programm besteht aus 1. Einer Datei mit Namen «ProgrammName.java» 2. die eine Klasse Namens «ProgrammName» hat 3. die eine Methode Namens «main» enthält  die eine Reihe von Anweisungen enthält  die automatisch ausgeführt wird wenn wir auf klicken  Später: Programme mit mehreren Dateien und Klassen 28 Namen: Java-Programme und -Klassen Jedes Programm braucht einen Namen, z.B. public class HelloWorld {…}  Regel: Dateiname gleich Programmname HelloWorld.java  Konventionen: Jedes Einzelwort startet mit einem Grossbuchstaben («upper camel case») 29 Namen: Methoden Jede Methode braucht einen Namen, z.B. public static void main(String[] args) {…}  Konvention:  Fängt mit einem Kleinbuchstaben an  Weitere Einzelworte starten mit einem Grossbuchstaben («lower camel case»).  Weiteres Beispiel: toUpperCase Weitere Regeln und Konventionen folgen später. 30 Namen: Reservierte Bezeichner 31  Schlüsselwort («keyword»): Ein Bezeichner, der reserviert ist, weil er für die Sprache eine besondere Bedeutung hat. In Java: abstract default if private this assert do implements protected throw boolean double import public throws break else instanceof return transient byte enum int short try case extends interface static var catch final long strictfp void char finally native super volatile class float new switch while continue for package synchronized false true null const goto Kommentare: Syntax Kommentare («comments») sind Notizen im Programmtext, die  Menschen beim Verstehen des Programmes helfen (sollen)  Keinen Einfluss auf die Programmausführung haben  2 Varianten 1. // Text bis zum Ende der Zeile (d.h. einzeilig) 2. /* Text bis zum schliessenden Stern-Schrägstrich-Paar (d.h. mehrzeilig) */ 32 /* * Das vermutlich einfachste Java-Programm der Welt. * Author: ChatBot3000 */ public class HelloWorld { // Hinweis: Parameter args aktuell nicht genutzt public static void main(String[] args) { System.out.println(\"Moin!\"); // TODO: \"Hoi\" besser? } // main() endet hier } 33 Kommentare: BeispielZeichenketten  Zeichenketten («strings»)  Folge von Zeichen («characters»)  Eingeschlossen in \"-Anführungszeichen («double quotes»)  Drei Beispiele: \"Hallo Welt\", \"hallo welt\", \"3+2\"  Einschränkungen 1. Nur eine Zeile lang: \"Dies hier ist kein Java-String, da mehrzeilig\" 2. Darf Zeichen \" nicht enthalten: \"So geht \"es\" nicht\" 34 Zeichenketten: Sonderzeichen Es gibt Ersatzdarstellungen («escape sequences») mit denen ein Sonderzeichen ausgedrückt werden kann  Fangen alle mit \\ (Rückwärtsschrägstrich, «backslash») an, z.B. \\n Neue Zeile («new line character») \\\" Anführungszeichen, «double quotes», «quotation mark» \\\\ Rückwärtsschrägstrich, «backslash» \\t Tabulator, «tab»  Vorangestelltes \\ heisst Maskierungszeichen «escape character» 35 Sonderzeichen: Beispiele  Code: System.out.println( \"\\\\Hallo\\nWie\\tgeht's \\\"uns\\\"?\\\\\\\\\");  Ausgabe: \\Hallo Wie geht's \"uns\"?\\\\ 36 Sonderzeichen: Fragen 1. Was wird jeweils ausgegeben? System.out.println(\"a\\tb\\\\\\tc\"); System.out.println(\"'\"); System.out.println(\"\\\"\\\"\\\"\"); System.out.println(\"C:\\neuer-S\\tiefel\"); 2. Welche Zeichenkette führt zu folgender Ausgabe? / \\ /// \\\\\\ 37 Bemerkung: println vs. print  println(str): Gibt effektiv str gefolgt von \"\\n\" aus  D.h. nach der Ausgabe von str erfolgt ein Zeilenumbruch  print(str): Gibt nur str aus  Erlaubt es, eine zusammenhängende Ausgabe (eine Zeile) über mehre prints zu verteilen  Künstliches Beispiel:  Einsatz später sinnvoller, wenn wir Ausdrücke (und Schleifen) kennen 38 System.out.print(\"Oberfläche = \"); System.out.print(\"700\"); System.out.println(\" cm2\"); Java Oberfläche = 700 cm2 Ausgabe Java-Programme Erstellen und Ausführen Zwei Möglichkeiten: 39 B) Einzelne Anweisungen  Für jede Anweisung …  Lesen (Read)  Evaluieren (Ausführen)  Ausgeben (Print)  REPL  Read-Evaluate-Print Loop A) Ganzes Programm  Für jede Datei …  Erstellen  Ausführen  Modifizieren Bisher Jetzt kurz 40 Ein Java-Befehl (hier: ein Methodenaufruf)Resultierende Ausgabe JShell REPL: Start Aufruf JShell auf der Kommandozeile 41 JShell REPL: Methoden Eingabe einer Methode • Methode jetzt global bekannt • Kein public static notwendig • Praktisch für kleine Programme Methodenaufruf und erzeugte Ausgabe 42 JShell REPL: Autovervollständigung Tab(ulator)-Taste • Listet existierende Befehlsoptionen auf • Vervollständigt, falls eindeutig • Zeigt Hilfe zu Standardmethoden an Java-Programme Erstellen und Ausführen  Zwei Möglichkeiten  Für jede Datei ➜ skaliert, für grössere Programme  Für einzelne Anweisungen ➜ flexible, für schnelle Experimente  Regeln für Java-Programme bleiben dieselben  Scheint manchmal nicht der Fall zu sein – liegt daran, dass die REPL den Code im Hintergrund in ein «vollständiges» Java-Programm einbettet  Fokus dieser Vorlesung: Arbeiten mit Dateien, da essenziell für komplexere Programme 43 2. Erste Java-Programme 2.1 Einführung: Vom Quelltext zur Ausgabe 2.2 Methoden I: Programmstrukturierung 2.3 Einfache Berechnungen 2.4 Input und Random 2.5 Logische Aussagen über Programm(segment)e 44 Methoden: Was?  Methode: Benannte Sequenz von Anweisungen 45  Beispiel: main (im Program HelloWorld)  Methode enthält Anweisungen  Diese werden beim Methodenaufruf ausgeführt (main wird beim Programmstart automatisch aufgerufen) Methoden: Warum?  Methoden strukturieren die Anweisungen  Anstatt alle Anweisungen in einer Methode (main) unterzubringen  Methoden erlauben es, Wiederholungen zu vermeiden  Nur einmal im Programm(text)  Aber mehrfach aufrufbar und somit ausführbar  Jede Methode stellt eine neue, spezialisierte Anweisung dar  Idee hinter Programmierbibliotheken 46 Programmentwicklung: Grobes Rezept 1. Gesamtaufgabe in Teilaufgaben zerlegen  Erfordert Problemverständnis und Problemlösestrategien 2. Teilaufgaben in separaten Methoden lösen  Teilaufgaben sind kleiner, Lösungen daher einfacher zu implementieren 3. Teillösungen zu Gesamtlösung zusammensetzen  Siehe Punkt 1 47 Einstiegsbeispiel  Aufgabe: Programm, das Text ausgibt  Gesucht: 48 -------- Warnung: sichern Sie die Daten -------- Lange Erklärung -------- Warnung: sichern Sie die Daten -------- Aufgabe Programm Ausgabe  Wie zerlegen? Wie weit/kleinteilig zerlegen?  Keine fixen Regeln, die immer zum Erfolg führen  Keine objektiv beste Zerlegung  Stattdessen: Heuristiken  Jede Methode sollte eine klare Aufgabe haben  Ausbildung: Hinweise («hints»), Vorgaben  Beruf: Erfahrung, Diskussionen  Zerlegung  Bisher nur relevant für Menschen, aber dem Computer egal  Neu auch relevant für KI-gestützte Entwicklung (fokussierte Prompts)49 Programm Aufgabe T1 Teil2 T3 Zerlegen in Teilaufgaben T1, T2, ..., TnEinstiegsbeispiel: 1. Zerlegung  Aufgabe: Programm, das Text ausgibt  1. Zerlegung  Teilaufgabe Ti: i-te Zeile in einer println() Anweisung ausgeben  Anweisung Ai für Teilaufgabe Ti  Ai hintereinander ausführen ➜ Gesamtausgabe erhalten 50 Aufgabe T1 … Tn -------- Warnung: sichern Sie die Daten -------- Lange Erklärung -------- Warnung: sichern Sie die Daten -------- Ausgabe AnA1 … Code 1. Zerlegung public class PrintExampleV1 { public static void main(String[] args) { System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Lange Erklärung\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } // Ende main } 51 Code 1. Zerlegung 52 public class PrintExampleV1 { public static void main(String[] args) { System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Lange Erklärung\"); System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } // Ende main } -------- Warnung: sichern Sie die Daten -------- Lange Erklärung -------- Warnung: sichern Sie die Daten -------- AusgabeJava  Beobachtung: Redundanz (Wiederholungen im Programm)  Gesucht: Zerlegung, die die Struktur der Aufgabe widerspiegelt Zerlegen in Teilaufgaben  Sich wiederholende Teilauf- gaben erkennen, so dass die Anweisungen für (viele) Ti wiederverwendbar sind  Anweisungen für Ti in Methode Mi  Methoden (statt einzelner Anweisungen) hinterein- ander ausführen 5353 Aufgabe Programm Auf- gabe T1 Tn A1 … An… Auf- gabe v1: zu kleinteilig v2: besser? T2 T2T1 T3 M1 M3M2 M2 Einstiegsbeispiel  Aufgabe: Programm, das Text ausgibt  2. Zerlegung  Teilaufgabe T1 : drucke Warnung  Teilaufgabe T2 : drucke Erklärung  Resultierendes Programm  M1; M2; M1; 54 -------- Warnung: sichern Sie die Daten -------- Lange Erklärung -------- Warnung: sichern Sie die Daten -------- Code 2. Zerlegung public class PrintExampleV2 { public static void main(String[] args) { // Gesamtlösung printWarning(); printExplanation(); printWarning(); } public static void printWarning() { // T1 bzw. M1 System.out.println(\"\\n--------\\n\"); System.out.println(\"Warnung: sichern Sie die Daten\\n\"); System.out.println(\"\\n--------\\n\"); } public static void printExplanation() { // T2 bzw. M2 System.out.println(\"Lange Erklärung\"); } } 55 Wie entstehen Methoden? 56 class method main statement statement statement statement statement statement statement statement statement Möglichkeit A: Im Nachhinein 1. Entwickeln des Algorithmus  Problemverständnis, Lösungsidee  Aufteilung in Teilprobleme 2. Implementation des Algorithmus  In einem Stück, z.B. alles in main() Wie entstehen Methoden? Möglichkeit A: Im Nachhinein 1. Entwickeln des Algorithmus  Problemverständnis, Lösungsidee  Aufteilung in Teilprobleme 2. Implementation des Algorithmus  In einem Stück, z.B. alles in main() 3. Code nachträglich aufteilen  Wiederverwendbare Funktionalität identifizieren, Redundanz vermeiden 57 class method main stepOne() statement stepTwo() method stepOne statement statement method stepTwo statement statement Vorteile? Nachteile?Wie entstehen Methoden? Möglichkeit B: Teilproblemen folgend 1. Entwickeln des Algorithmus  Problemverständnis, Lösungsidee  Aufteilung in Teilprobleme  Wiederkehrende Teilprobleme direkt identifizieren 2. Implementation des Algorithmus  In einzelnen, von Teilproblemen abgeleiteten Methoden 58 class method main stepOne() statement stepTwo() method stepOne statement statement method stepTwo statement statement Wie entstehen Methoden? Möglichkeit B (Teilproblemen folgend) ist grundsätzlich vorzuziehen  Strukturiert den Entwicklungsprozess (kleine, überschaubare Einheiten statt einem langen Codeblock)  Vermeidet Redundanz (statt diese im Nachhinein zu entfernen)  Ermöglicht Teamarbeit (für uns nicht wichtig, aber in der Praxis essenziell) 59 Möglichkeit A kann aber  Für den Anfang einfacher sein  «Lokal» für die Entwicklung einzelner Methoden genutzt werden Methodenaufrufe public class PrintExampleV2 { public static void main(String[] args) { printWarning(); printExplanation(); printWarning(); } public static void printWarning() { ... } public static void printExplanation() { ... } } 60  Beobachtung: Methodenaufruf im Format methName();  Nur für statische Methoden (Schlüsselwort static)  Nicht-statische Methoden schauen wir uns später an (Aufrufformat obj.methName();)  Aber wie läuft ein Methoden- aufruf eigentlich ab …? Zunächst: Linearer Kontrollfluss 61  Sequenzen von Anweisungen werden, wie im Programmtext stehend, von oben nach unten* ausgeführt  Dies nennt sich linearer Kontrollfluss («linear control flow») public class ControlFlowExample1 { public static void main(String[] args) { System.out.println(\"Zeile 1\"); System.out.println(\"Zeile 2\"); System.out.println(\"Zeile 3\"); } } * Verzweigungen und Schleifen lernen wir später kennen Java Zeile 1 Zeile 2 Zeile 3 Ausgabe Kontrollfluss mit Methodenaufrufen 62 main() { statement1; name(); statement2; } name() { statement3; statement4; }  Die Anweisung name() stellt einen Methodenaufruf («call», «invocation») dar  Wird sie ausgeführt dann 1. Spring die Ausführung (der Kontrollfluss) an den Anfang der entsprechenden Methode 2. Werden die Anweisungen innerhalb der Methode von oben nach unten (linear) ausgeführt 3. Springt die Ausführung zurück hinter den (nun beendeten) Methodenaufruf Kontrollfluss mit Methodenaufrufen 63 main() { statement1; name(); statement2; } name() { statement3; statement4; } Effektiv werden die Anweisungen hier daher wie folgt ausgeführt: 1. statement1; 2. statement3; 3. statement4; 4. statement2; Kontrollfluss mit Methodenaufrufen 64 main() { statement1; name(); statement2; } name() { statement3; statement4; } Hinweis: Die Reihenfolge der Methoden im Programmtext ist (in Java) irrelevant name() { statement3; statement4; } main() { statement1; name(); statement2; } == Grösseres Beispiel: Schrittweise Ausführung 65 public class ControlFlowExample2 { public static void main(String[] args) { System.out.println(\"Anfang\"); message1(); System.out.println(\"Mitte\"); message2(); System.out.println(\"Ende\"); } public static void message1() { System.out.println(\"1. Nachricht\"); } public static void message2() { message1(); System.out.println(\"2. Nachricht\"); } } Anfang 1. Nachricht Mitte 1. Nachricht 2. Nachricht Ende Java Ausgabemain(…) { …println(\"Anfang\"); // msg1() …println(\"1. N't\"); …println(\"Mitte\"); // msg2() // msg1() …println(\"1. N't\"); …println(\"2. N't\"); …println(\"Ende\"); } Grösseres Beispiel: Mögliche Erklärungshilfe 66 main(…) { …println(\"Anfang\"); msg1(); …println(\"Mitte\"); msg2(); …println(\"Ende\"); } msg1() { …println(\"1. N't\"); } msg2() { msg1(); …println(\"2. N't\"); } Die Darstellung rechts visualisiert indirekt den Aufrufstapel — lernen wir später kennen Eine neue Aufgabe … ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 67 Schreiben Sie ein Programm, dass diese Figuren ausgibt Entwicklungsschritte ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 68 Version 1: Ohne Ausnutzen der Struktur 1. Programm mit leerer main-Methode erstellen 2. Erwünschte Ausgabe in main kopieren; für jede Zeile eine entsprechende println- Anweisung 3. Programm ausführen; erwartete und erhaltene Ausgabe vergleichen Programm Version 1 69 public class Figures1 { public static void main(String[] args) { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(\"+--------+\"); System.out.println(); System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"| STOP |\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"+--------+\"); } // method \"main\" } // class \"Figures1\"...... Entwicklungsschritte ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 70 Version 2: Mit Ausnutzen der Struktur, mit Redundanz 1. Vorhandene Strukturen identifizieren 2. main-Methode in separate Methoden aufteilen, basierend auf obiger Strukturierung 3. Programm ausführen; erwartete und erhaltene Ausgabe vergleichen Entwicklungsschritte ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 71 Strukturen in dieser Figur (von oben nach unten)  «Sechseck» ➜ Methode hexagon()  «Wanne» ➜ tub()  «Stopschild» ➜ stopSign()  «Hut» ➜ hat() public static void hexagon() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); } public static void tub() { System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(\"+--------+\"); System.out.println(); } Programm Version 2 72 public class Figures2 { public static void main(String[] args) { hexagon(); tub(); stopSign(); hat(); }......... public static void hat() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"+--------+\"); } } // class \"Figures2\" Programm Version 2 (Fortsetzung) 73 public static void stopSign() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); System.out.println(\"| STOP |\"); System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); System.out.println(); }.........Entwicklungsschritte ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 74 Version 3: Mit Ausnutzen der Struktur, ohne Redundanz 1. Vorhandene (Teil-) Strukturen und Redundanzen identifizieren 2. Methoden so erstellen, dass Redundanzen (soweit möglich/sinnvoll) vermieden werden 3. Code kommentieren 4. Programm ausführen Redundanz in der Ausgabe ______ / \\ / \\ \\ / \\______/ \\ / \\______/ +--------+ ______ / \\ / \\ | STOP | \\ / \\______/ ______ / \\ / \\ +--------+ 75 Mehrfach auftretende Teilstrukturen  Obere Hälfte Hexagon ➜ Methode hexagonTop()  Untere Hälfte Hexagon ➜ hexagonBottom()  Trennlinie ➜ line() // Draws the top half of a hexagon. public static void hexagonTop() { System.out.println(\" ______\"); System.out.println(\" / \\\\\"); System.out.println(\"/ \\\\\"); } // Draws a hexagon's bottom half. public static void hexagonBottom() { System.out.println(\"\\\\ /\"); System.out.println(\" \\\\______/\"); } Programm Version 3 76 // Author: Maija Meikäläinen, 24-135-678 // Prints several figures, split up into // methods that capture common // (sub)structures. public class Figures3 { public static void main(String[] args) { hexagon(); System.out.println(); tub(); System.out.println(); stopSign(); System.out.println(); hat(); }......... Programm Version 3 (Fortsetzung) 77 // Draws a stopSign. public static void stopSign() { hexagonTop(); System.out.println(\"| STOP |\"); hexagonBottom(); } // Draws a hat-shaped figure. public static void hat() { hexagonTop(); line(); } } // class \"Figures3\" // Draws a complete hexagon. public static void hexagon() { hexagonTop(); hexagonBottom(); } // Draws a tub-shaped figure. public static void tub() { hexagonBottom(); line(); } // Draws a line. public static void line() { System.out.println(\"+--------+\"); }.........Übungsaufgabe /\\ / \\ / \\ / \\ +-------+ | | | | | | +-------+ | | | ISS | | | +-------+ | | | | | | +-------+ /\\ / \\ / \\ / \\ 78 Schreiben Sie ein Programm, dass diese Rakete ausgibt: 2. Erste Java-Programme 2.3 Einfache Berechnungen 2.3.1 Einführung: Typen, Variablen, Werte 2.3.2 Ausdrücke über Basistypen 2.3.3 Variablendeklaration und -initialisierung 79 (Sinnvolles) Arbeiten mit Daten  Programme operieren auf Daten, z.B. eines Boots  Höhe, Länge, Tiefe; Kaufpreis; Name; Standort; …  Nicht alle Operationen (Berechnungen) sind sinnvoll Länge mal Breite mal Höhe 75% des Kaufpreises Finde kürzesten Weg zwischen Standort und vorgestern Starte eine Hausbootzucht  Ziel von Programmiersprachen: Sinnvolle Berechnungen ermöglichen, unsinnige verhindern 80Bootgrafik erzeugt mit Image Creator in Bing     Typen: Was?  Ein Typ («type») beschreibt eine Kategorie von Werten/Daten  Ähnlich zu mathematischen Mengen  Z.B. ℤ (ganze Zahlen) vs. ℚ (rationale Zahlen)  Typen beschreiben Eigenschaften von Daten  Bestimmt die Operationen, die für diese Werte möglich sind  Z.B. Typen «Boat» vs. «Katze» — welche Eigenschaften/Operationen teilen sie, welche unterscheiden sie? 81 Typen: Warum?  Viele Programmiersprachen erfordern explizite Typangaben  Sicherheit (Probleme verhindern/erkennen) — für EProg wichtig  Dokumentation — für EProg wichtig  Effizienz — für EProg nicht/weniger wichtig  Sicherheit: Typen verhindern Fehler  Kann AHV-Nummer nicht zum Gehalt addieren  Dokumentation: Typen spezifizieren die Teile einer Berechnung  Was wird erwartet (Preis? Standort?), was wird berechnet? 82 Acht primitive Typen («primitive types»): für Zahlen, Buchstaben und Wahrheitswerte. Beispiele: Name Beschreibung Beispiele  int ganze Zahlen -2147483648, -3, 0, 42, 2147483647  long grosse ganze Zahlen 42, -3, 0, 9223372036854775807  double reelle Zahlen 3.1, -0.25, 9.4e3  char (einzelne) Buchstaben 'a', 'X', '?', '\\n'  boolean Wahrheitswerte true, false 83 Primitive Typen in Java Wer es genau wissen möchte: Java Language Specs §4.2  Die Programmiersprache legt fest, wie ein Typ implementiert ist  Implementiert = Darstellung der Werte und Definition der Operationen  Interne Darstellung aller Werte durch Nullen und Einsen  97 ➜ 01100001  \"ab\" ➜ 01100001 01100010  Was bedeutet 01100001? ➜ Typen wichtig  \"a\".toUpperCase() sinnvoll, aber 97.toUpperCase() nicht ASCII-Tabelle \"a\" 97 01100001 \"b\" 98 01100010 84 Typen: Von Bitfolgen zu DatenAnwendung: Oberfläche eines Quaders 85  Gegeben: Dimensionen eines Quaders  Aufgabe: Java-Programm zur Berechnung der Oberfläche  Oberfläche in cm2: 2 ⋅ (70 ⋅ 27 + 27 ⋅ 40 + 40 ⋅ 70) 70 cm 40 cm 27 cm Quader: Klaus-Dieter Keller, via Wikimedia, CC BY-SA 3.0 public class Quader { // Oberflächenberechnung für einen bestimmten Quader public static void main(String[] args) { System.out.print(\"Die Oberfläche beträgt \"); System.out.print(2 * (70 * 27 + 27 * 40 + 40 * 70)); System.out.println(\" cm2\"); } } 86 Ausgabe: Die Oberfläche beträgt 11540 cm2 70 cm 40 cm 27 cm Entsprechendes Programm public class Quader { // Oberflächenberechnung für einen bestimmten Quader public static void main(String[] args) { System.out.print(\"Die Oberfläche beträgt \"); System.out.print(2 * (70 * 27 + 27 * 40 + 50 * 70)); System.out.println(\" cm2\"); } } 87 Ausgabe: Die Oberfläche beträgt 12940 cm2 70 cm 40 cm 27 cm Unaufmerksamkeit … Fehler sind schnell gemacht 88 Variablen  Variablen («variables») geben Werte (z.B. 40) sinnvolle Namen (z.B. height)  Konzept aus der Mathematik bekannt  In Berechnungen werden Variablen durch ihre Werte «ersetzt»  Z.B. height * height steht (hier) für 40 * 40 und ergibt daher 1600  Aber Programmvariablen können sich ändern (später mehr)  Erforderlich für Variablen in Java: Name und Type  Hier wären ganzzahlige Werte sinnvoll ➜ int-getypte Variable 89 public static void main(String[] args) { int length; int height; int depth; length = 70; height = 40; depth = 27; System.out.print(\"Die Oberfläche beträgt \"); System.out.print(2 * (length*depth + depth*height + height*length)); System.out.println(\" cm2\"); } Ausgabe: Die Oberfläche beträgt 11540 cm2 Programm mit Variablen } // Deklarationen } // Initialisierung durch Wertzuweisungen Variablendeklaration Eine Variable muss deklariert («declared») werden (d.h. bekannt gemacht werden, angekündigt werden)  Syntax: type name;  Für einen gültigen Java-Typ type (wir lernen viele Typen kennen)  Variable name kann nun jeden Wert vom Typ type speichern  Beispiel: int height;  Variablenname (fast) frei wählbar  Regel: Kein Java-Schlüsselwort, muss mit einem Buchstaben anfangen  Konvention: Camel-Case, mit kleinem Buchstaben beginnend 90 Variablendeklaration und -initialisierung  Eine Variable kann deklariert und direkt initialisiert («initialised»> (d.h. einen Wert bekommen)  Syntax: type name = expression;  Für einen Typ type und einen dazu passenden Ausdruck expression (mehr zu Ausdrücken später, zunächst Ausdruck ≈ Wert)  Beispiel: int height = 40;  Das Zeichen = bedeutet Zuweisung («assignment»)  Effekt: Variable hat ab jetzt diesen Wert  Eine Zuweisung ist keine mathematische Gleichheit, auch wenn der Operator leider so aussieht. Später mehr dazu. 9192 public static void main(String[] args) { int length = 70; int height = 40; int depth = 27; System.out.print(\"Die Oberfläche beträgt \"); System.out.print(2 * (length*depth + depth*height + height*length)); System.out.println(\" cm2\"); } Ausgabe: Die Oberfläche beträgt 11540 cm2 Programm mit Variablen } // Deklaration und direkte Initialisierung 93 public static void main(String[] args) { int length; System.out.print(length); }  Lokale Variablen von primitivem Typ (etwas anderes kennen wir bisher nicht) haben keinen Standardwert, sondern müssen explizit initialisiert werden  Wird versucht, den Wert einer (solchen) uninitialisierten Variable zu nutzen, gibt es einen Compilerfehler Standard-Initialisierung für Basistypen? Compilation problem: Local variable x not initialized Die JShell verhält sich hier anders und initialisiert solche Variablen mit einem Standardwert, z.B. 0 für int Variablennamen als Dokumentation  Variablennamen sind Computern egal — aber Menschen nicht  Gute Namen helfen beim Verstehen eines Programs  Selbstbeschreibend (z.B. length, lunchPreference, twintAccount)  Halbwegs kurz (lengthInMM vs. lengthInTheMetricSystemUnitMillimeter)  Unterscheidbar (im Kontext) (name1, name2 vs. firstName, middleName) 94 Variablennamen als Dokumentation  Gute Namen zu finden ist nicht (immer) einfach  Insbesondere über Berechnungen mit Zwischenwerten hinweg (salary, salaryAfterRaise, salaryAfterRaiseWithChristmasBonus, …)  Kurze Name (z.B. i, x, n) OK für kurzlebige Variablen  Namen sind wichtig! Aber seien Sie pragmatisch, nicht dogmatisch 95 Typen als Dokumentation  Java unterstützt Typinferenz («type inference»), d.h. Typ- informationen können manchmal weggelassen werden. Bsp.:  Empfehlung: Typen explizit angeben ➜ Dokumentation Welche Werte kann result nun haben — Wahrheitswerte ((un)bekannt), Zeichenketten (Name), Zahlen (Postleitzahl)? 96 int score = 99; String name = \"Ghüs\"; var score = 99; var name = \"Ghüs\"; var result = findHomeCityForLegi(\"24-135-987\"); Wer definiert Typen? Gültige Java-Typen sind  Immer verfügbare Basistypen (eingebaute Typen)  Primitive Typen, z.B. int  Typen aus Javas Standardbibliothek, z.B. String  Benutzerdefinierte Typen (später mehr dazu)  Von uns  Aus Bibliotheken Dritter 97 2. Erste Java-Programme 2.3 Einfache Berechnungen 2.3.1 Einführung: Typen, Variablen, Werte 2.3.2 Ausdrücke über Basistypen 2.3.3 Variablendeklaration und -initialisierung 98 Basistypen  27 und 2 * (length*depth + …) sind Ausdrücke («expressions»)  Was sind die Regeln für Ausdrücke?  Zunächst für Zahlen (int, double)  EBNF-Regel expr 99 … int depth = 27; …println(2 * (length*depth + depth*height + height*length)); <integer> ⟵ [<sign>] {<digit>} <number> ⟵ <integer> | <integer> . {<digit>} | <sign> . {digit} <op> ⟵ + | - | * | / | % <atom> ⟵ <number> | <identifier> <term> ⟵ ( <expr> ) | <atom> <expr> ⟵ <term> {<op> <term>} EBNF-Beschreibung Ausdruck (expr) 1. (Unvollständige) Beschreibung für Java-Ausdrücke  Keine Überraschungen ... wie in der Mathematik/Schule  number beschreibt Zahl-Literale («number literals») 2. Beschreibt nur die Syntax — keine Typen, keine Semantik 100 Arithmetische Operatoren  Operatoren («operators»): Bilden Ausdrücke aus Teilausdrücken  + Addition - Subtraktion (oder Negation)  * Multiplikation / Division % Modulo (Rest)  Müssen festlegen, was «X ⨂ Y» bedeutet (⨂ Operator; X, Y int-getypte Ausdrücke)  Was ist das Ergebnis (Semantik)?  Was für einen Typ hat das Ergebnis? 101 Arithmetische Operatoren: Ergebnisse Operatoren +, *, -: Wie in der Mathematik — zumindest fast  Zahlen intern als endliche Bitfolge repräsentiert: Für int/long sind es 32/64 Bits. D.h. es gibt eine kleinste und grösste Zahl.  Verhalten: MIN – 1 gleich MAX, MAX + 1 gleich MIN  Unter-/Überlauf, wie bei einer Uhr  Wird in Digitaltechnik (2. Semester) im Detail besprochen 102Uhr: HackaLittleBit, via Wikimedia, CC BY-SA 4.0 Arithmetische Operatoren: Typen  Für Operatoren +, *, -, /, %: TypA ⨂ TypA ergibt TypA  Beispiele  2 * 3 ergibt 6 mit Typ int (weil 2 und 3 ints sind)  -(7) ergibt -7 mit Typ int (weil 7 ein int ist)  Naheliegende Fragen 1. Welchen int-Wert liefert, z.B. 5 / 2? ➜ jetzt 2. Welchen Typ liefert TypA ⨂ TypB? ➜ später 103 Ganzzahlige Division mit /  Division zweier ganzer Zahlen ergibt wieder eine ganze Zahl  Die mathematisch anfallenden Nachkommastellen werden abgeschnitten («truncated»)  Beispiele  5 / 2 ergibt 2 (nicht 2,5)  10 / 6 ergibt 1 (nicht 1,666…)  32 / -5 ergibt -6 (nicht -6,4)  Division durch 0 führt zum Programmabbruch (Laufzeitfehler) 104 Rest ganzzahliger Division mit %  Der Modulo-Operator % liefert den Rest ganzzahliger Division  Beispiele  5 % 2 ergibt 1  10 % 6 ergibt 4  32 / -5 ergibt 2  Es gilt stehts: (a / b) * b + (a % b) ergibt a  Division durch 0 führt zum Programmabbruch 105 Einsatzmöglichkeiten Modulo-Operator  Bestimme die letzte Ziffer einer ganzen Zahl  230857 % 10 ist 7  Bestimmte letzten 4 Ziffern  658236489 % 10000 ist 6489  Entscheide, ob eine Zahl gerade ist  7 % 2 ergibt 1  42 % 2 ergibt 0 106 Fragen: Was ist das Ergebnis von … 1. 10 / 4 2. -23 / 11 3. 8 % 20 4. 2 % 2 5. 11 % -4 6. -11 % -4 7. -11 % 4 107 Ausdrücke mit mehreren Operatoren  Zunächst: Mehrfach der gleiche Operator ⨂  Was bedeutet «X ⨂ Y ⨂ Z»?  7 + 5 + 3 ➜ (7 + 5) + 3  64 / 8 / 2 ➜ (64 / 8) / 2 (nicht 64 / (8 / 2))  Gegeben «X ⨂ Y ⨂ Z», zu welchem Operator gehört Y: dem linken, dem rechten? 108 Assoziativität  Die Assoziativität («associativity») eines Operators bestimmt, wie ein Operand verwendet wird  Ist ein Operator ⨂  Linksassoziativ («left-associative») ➜ X ⨂ Y ⨂ Z gleich (X ⨂ Y) ⨂ Z  Rechtsassoziativ («right-associative») ➜ X ⨂ Y ⨂ Z gleich X ⨂ (Y ⨂ Z) 109 Assoziativität  Beispiele für Operatorassoziativität  Linksassoziativ: +, *, /, %  Rechtsassoziative: später  Nebenbemerkung: In der Mathematik ist ein Operator assoziativ, falls gilt, dass (X ⨂ Y) ⨂ Z gleich X ⨂ (Y ⨂ Z) 110 Ausdrücke mit verschiedenen Operatoren  Was bedeutet «X ⨂ Y ⊙ Z» für zwei verschiedenen Operatoren ⨂ und ⊙?  Beispiel: 2 + 6 * 5 ➜ 2 + (6 * 5) (nicht (2 + 6) * 5)  Operand Y wird mit dem Operator mit der höheren Präzedenz («precedence») verknüpft  Auch Bindungsstärke oder Rangordnung genannt  Bei den uns bisher bekannten Operatoren gilt «Punkt vor Strich»  D.h. *, /, % binden stärker als +, - 111 Implizite Klammerung 1. Operand wird vom Operator mit höherer Präzedenz gebunden 2. Wenn zwei Operatoren dieselbe Präzedenz haben, dann entscheidet die Assoziativität 3. Wenn zwei Operatoren dieselbe Präzedenz und Assoziativität haben, dann werden die (Teil-)Ausdrücke von links nach rechts ausgewertet  Explizite Klammern verwenden  Wenn eine andere Auswertung gewünscht  Wenn Ausdrücke komplexer werden (➜ Lesbarkeit) 112 Implizite Klammerung: Beispiel 6 + x / 2 * y / und * binden (gleich) stärker als + / links von *, daher / zuerst ➜ 6 + (x / 2) * y danach * ➜ 6 + ((x / 2) * y) zuletzt + ➜ (6 + ((x / 2) * y)) 113 Ausdrucksbäume 114 Ein (vollständig geklammerter) Ausdruck lässt sich als Ausdrucksbaum («expression tree») darstellen + * % 4*1 2 3 5 (1 * 2) + ((3 * 5) % 4) Ausdruck Baum Evaluationsreihenfolge 115 Die Operanden eines Operators werden von links nach rechts ausgewertet/evaluiert («evaluated») ➜ Ergebnisberechnung + * % 4*1 2 3 5 (1 * 2) + ((3 * 5) % 4) \\_/ | 2 + ((3 * 5) % 4) \\_/ | 2 + ( 15 % 4) \\____/ | 2 + 3 \\___________/ | 5 2 3 15 5 Fragen: Wozu evaluieren diese Ausdrücke? 1. 9 / 5 ergibt 1 2. 695 % 20 ergibt 15 3. 7 + 6 * 5 ergibt 37 4. 7 * 6 + 5 ergibt 47 5. 248 % 100 / 5 ergibt 9 6. 6 * 3 - 9 / 4 ergibt 16 7. 6 + 18 % (17 - 12) ergibt 9 116 Typ double für Kommazahlen  Beispielliterale vom Typ double:  6.022, -42.0 — wie ganze Zahlen, aber mit einem Punkt  1e2, 1e-3, 2.143e17 — Exponentenschreibweise XeY steht für 𝑋𝑋 ⋅ 10 𝑌𝑌  Arithmetische Operatoren +, -, *, /, % auch für double definiert  Division nun wie erwartet: 15.0 / 2.0 ergibt 7.5  Assoziativität und Präzedenz wie bisher 117 Beispielevaluation  2.0 * 2.4 + 2.25 * 4.0 / 2.0  \\___/ |  4.8 + 2.25 * 4.0 / 2.0  \\___/ |  4.8 + 9.0 / 2.0  \\_____/ |  4.8 + 4.5  \\____________/ |  9.3 118 Double ungleich reelle Zahlen  Werte vom Typ double werden intern mit 64 Bit dargestellt ➜ endliche Darstellung  Grösste/kleinste Werte  Rundungsfehler (Lücken im Wertebereich)  double-Werte heissen Fliesskommazahlen («floating point numbers»). Grobe Idee:  0,01 · 107 = 1,0 · 105 = 100 · 103 Normalisierung durch Exponentenanpassung («Komma fliesst»)  64 Bit für das Paar (Vorkommazahl, Exponent) — platzeffiziente Speicherung  Details in Digitaltechnik (2. Semester) und Numerische Methoden (3. Sem.) 119 Ausdrücke mit verschiedenen Typen  Für Operatoren +, *, -, /, %: TypA ⨂ TypA ergibt TypA  Welchen Typ liefert der gemischte Ausdruck TypA ⨂ TypB?  3 / 2.0 ergibt …? Das gleiche wie 3.0 / 2?  Kombination int/long und double ergibt double  3 / 2.0 und 3.0 / 2 ergeben 1.5  4.0 / 2 ergibt 2.0 (nicht den int 2)  Umwandlung («conversion») vom kleineren zum grösseren Typ  Separat für jeden Operator bzw. dessen Operanden  Implizit (automatisch) – explizite Typumwandlungen später 120  Beispielevaluation Umwandlung geschieht für jeden Operator 121  7 / 3 * 1.2 + 3 / 2  \\_/ |  2 * 1.2 + 3 / 2  \\___/ | 2.4 + 3 / 2  \\_/ |  2.4 + 1  \\________/ |  3.4 + / 3 2 1 * 1.2/ 7 3 2.4 2 3.4 Typherleitung Baumstruktur auch praktisch für die Typherleitung 122 + / 3 2 int * 1.2/ 7 3 double int double Fragen: Wozu evaluieren diese Ausdrücke? 1. 4 + 8 / 3.0 * 6 + 5 ergibt 25.0 2. 9.0 / (2.0 / 3) + 7 ergibt 20.5 3. 7 % 3 * 2 + 4.0 * 3 / 2 ergibt 8.0 4. 9 / (2 / 3) + 7 ergibt Laufzeitfehler 5. 20 % 8 + 15 / 27 / (3 % 6) ergibt 4 123 Explizite Typumwandlungen  Gesehen: Impliziten Umwandlungen bei Operatoren  Beispiel: 1.0 / 4 ergibt double  Explizite Typumwandlung heissen «Cast» («Type Cast»)  Anwendungen  Präzision erhöhen: z.B. int zu double casten, damit eine Division das gewünschte exakte Ergebnis liefert  Präzision senken: z.B. um ungewollte Nachkommenstellen abzuschneiden 124 Explizite Typumwandlungen  Syntax:(type) expression  Beispiele  (double) 19 / 5 ergibt 3.8 (statt 3)  (int) (2.1e3 / 1.3e4 * 100) ergibt 16 (statt 16.15…)  (type) ist ein Operator  Der «cast operator»  Binder stärker (höhere Präzedenz) als arithmetische Operatoren  Unär und rechtsassoziativ — wandelt nur den Operanden rechts daneben um  Für fast alle primitiven Typen verfügbar 125 Cast-Operator  Cast-Operator bezieht sich nur auf seinen rechten Operanden  Was ergeben …?  (double) 1 + 1 / 2 ergibt 1.0  1 + (double) 1 / 2 ergibt 1.5  (double) (2 + 1 + 1) / 3 ergibt 1.333… 1. Java vs. Python: Modulo mit negativen Zahlen Abschluss numerische Ausdrücke Die Folien dieser Vorlesung zeigen die Regeln (z.B. Präzedenzen) für Java. Für andere Programmiersprachen gelten (eventuell) andere Regeln. Beispiele: 127 1. Python vs. Excel: Präzedenz Negation und Potenzierung Abschluss numerische Ausdrücke  Java kennt noch weitere numerische Datentypen und Literalformate  Regeln und Verhalten analog zu bisher Gezeigtem (int und double), unterscheiden sich in unterstützten Wertebereichen  Details für uns nicht weiter relevant ➜ bei Bedarf nachschlagen  Beispiele (Auswahl)  Typ short, Wertebereich -128 to 127 (keine eigenen Literale)  Typ long, Wertebereich -263 to 263 – 1 (Literale mit Suffix L, z.B. 9876543210L)  Typ char (Zeichen, später mehr), Wertebereich 0 bis 65535 (Literale z.B. 'g', '\\u042E’)  Weitere Integer-Literalformate (Auswahl)  Mit Dezimaltrenner, z.B. 10_000, 1_000_000  Hexadezimal (z.B. 0xFF) 128Relevante Java-Spezifikation auf docs.oracle.com: Typen, Literale 129 Zwischenstand Typen und Operationen 1. Primitive Typen – Beispiele int und double  Haben Werte (4, 2.17) und Operationen (Division mittels /) gesehen 2. Typen aus der Java-Standardbibliothek – Beispiel String  Haben Werte bereits gesehen (\"hello\", \"2 + 3\")  Jetzt: Verkettung mittels Plus-Operator  Später: Operationen mittels Methoden (\"hello\".toUpperCase())  3. Später: Selbst entwickelte Typen 130 Zeichenketten verketten  Verkettung (Konkatenation, «concatenation») von String: Der Operator + erlaubt es, zwei Strings zusammenzufügen  \"You\" + \"Tube\" ergibt \"YouTube\"  \":\" + \"-\" + \")\" ergibt \":-)\"  Verkettung kann verschiedene Typen kombinieren  Was sollte/könnte 3 + \" Grad Celsius\" ergeben? 131 Einschub: Standarddarstellung als String  In Java gibt es für jeden Wert eine Darstellung als String  Gilt für alle Typen  Standarddarstellung immer vorhanden ➜ kann jeden Wert mittels println(…) ausgeben  Standarddarstellung möglicherweise nicht ideal; kann für selbstentwickelte Typen auch geändert werden  Für primitive Typen und Strings wie zu erwarten, z.B.  Für 42 und -36.7 wie erwartet \"42\" und \"-36.7«  Mit int x = 77 für x wie erwartet \"77\" 132 Zurück zur Zeichenkettenverkettung  Verkettung eines Strings mit einem Wert anderen Typs: Verkettung mit der Standarddarstellung des anderen Werts  3 + \" Grad Celsius\" ergibt \"3 Grad Celsius\"  \"Olympia \" + 2024 ergibt \"Olympia 2024«  Praktisch für die Erzeugung von Ausgabe double grade = 5.25 + 0.25; System.out.println(\"Prüfungsnote ist \" + grade); // erzeugt Ausgabe \"Prüfungsnote ist 5.5\" Fragen: Wozu evaluieren diese Ausdrücke? Auswertungsregeln wie gehabt  12 – 3 + 5  2 + 3 + \" Zehen\"  \"Nummer \" + 3 + 2  \"Nummer\" + 2 * 3  \"Note \" + (4.8 + 5.2) / 2  \"Note \" + 4.8 + 5.2 / 2 133 2. Erste Java-Programme 2.3 Einfache Berechnungen 2.3.1 Einführung: Typen, Variablen, Werte 2.3.2 Ausdrücke über Basistypen 2.3.3 Variablendeklaration und -initialisierung 134 Variablen – Bereits bekannt Deklarationen (Ankündigung/Bekanntmachung mit Typinformation) Initialisierung (erstmalige Wertzuweisung; Schreibzugriff) Zuweisung (Schreibzugriff) Auswertung (Evaluation; Lesezugriff) 135 double inch; inch = 6.4; double centimeter = inch * 2.54; System.out.println( inch + \"\\\" sind \" + centimeter + \"cm\"); inch = 22; System.out.println( inch + \"\\\" sind \" + inch * 2.54 + \"cm\"); Deklaration Deklaration einer Variable: Reserviert Speicherplatz gross genug für Werte des entsprechenden Typs 136 int teeth; teeth = 28; double speed = 0.83; ... ... int ➜ 32 Bit Platz double ➜ 64 Bit Kennen Speicherplatz unter Namen «teeth» «speed» Deklaration Deklaration einer Variable: Reserviert Speicherplatz gross genug für Werte des entsprechenden Typs  Intuitive Vorstellung eines «Speicherbands mit benannten Zellen» für uns ausreichend  Weitere technische Details z.B. in Compiler Design 137 ... ... int ➜ 32 Bit Platz double ➜ 64 Bit Kennen Speicherplatz unter Namen «teeth» «speed» int teeth; teeth = 28; double speed = 0.83; Initialisierung Initialisierung einer Variable: Erstmaliges Schreiben (Zuweisen) eines Werts in den reservierten Speicherplatz 138 int teeth; teeth = 28; double speed = 0.83; 28 0.83... ... teeth speed Mögliche Fehler  Fehlende Deklaration (jede Variable muss deklariert werden)  Nutzung vor Deklaration  Mehrfachdeklaration (Typen irrelevant) 139 // int teeth; teeth = 28; Unresolved compilation problem: teeth cannot be resolved to a variable teeth = 28; int teeth; Unresolved compilation problem: teeth cannot be resolved to a variable int teeth; long teeth; Unresolved compilation problem: Duplicate local variable teeth Mögliche Fehler  Fehlende Initialisierung (lokale Variablen haben keinen Standardwert)  Initialisierung mit Wert falschen Typs 140 int teeth; println(teeth); Unresolved compilation problem: The local variable teeth may not have been initialized int teeth; teeth = \"28\"; Unresolved compilation problem: Type mismatch: cannot convert from String to int Zuweisung Zuweisung einer Variable: Schreiben eines (neuen) Werts in den entsprechenden Speicherplatz 141 int teeth = 28; teeth = (13 + 17) / 2; ... teeth 2815 16 Evaluation Auswerten einer Variable: In Aus- drücken evaluiert eine Variable zu dem Wert, den die Speicherzelle zu diesem Zeitpunkt hat 142 int teeth = 28; println( teeth ); teeth = (13 + 17) / 2; println( teeth + 1 ); ... teeth 2815 Java 28 16 Ausgabe Evaluation + Zuweisung Variable evaluiert zum aktuellen Wert ➜ neuer Wert kann von diesem abhängen 143 int teeth = 28; teeth = teeth + 1; ... teeth 2829 Zuweisung ist keine Gleichheit!  Mathematik: 𝑥𝑥 = 𝑥𝑥 + 1 («x ist gleich sich selbst plus 1») sinnfrei  Informatik: Sinnvoll, da eine Zuweisung einen Effekt hat (Zustandsänderung) Animierte Folie, evtl. Vorlesungsaufzeichnung anschauen 2. Erste Java-Programme 2.1 Einführung: Vom Quelltext zur Ausgabe 2.2 Methoden I: Programmstrukturierung 2.3 Einfache Berechnungen 2.4 Input und Random 2.5 Logische Aussagen über Programm(segment)e 145 Interaktive Programme  Programm kann auf Benutzer (Ausführer:in des Programms) reagieren  Z.B. Lesen eines Input-Texts  Aufforderung zur Eingabe eines Inputs  Einlesen des durch Benutzer getippten Inputs in Variable  Ausgabe von Text auf Bildschirm  Verschiedene Input-Quellen möglich, z.B.  Konsole («console»)  Datei  Website  Datenbank  Und viele mehr 146 Konsole («console»)  Früher: mit Computer verbundenes externes Gerät  Heute: Fenster im User Interface  Standard-Input (System.in in Java)  Standard-Output (System.out in Java) 147 Eclipse verwendet ein Fenster um System.in und System.out zu zeigen! Konsole: User LPfi on the Swedish Wikipedia (on Commons: LPfi) [CC BY-SA ] Input ist komplex  Unterschiedliche Input-Quellen  Verhalten von Benutzer ist nicht vorhersehbar oder kontrollierbar  Fehlerhafte Eingaben müssen abgefangen werden  Umwandeln der Darstellung auf Konsole zu Darstellung in Programm (z.B. dezimal zu binär)  Mehr dazu in «Digital Design and Computer Architecture» im Frühling In Java: Scanner bietet diese Funktionalität für Input an  bei Output kümmert sich z.B. println darum 148 Scanner: Syntax  Scanner aus Bibliothek java.util importieren  import java.util.Scanner;  Scanner-Objekt konstruieren mit Angabe der Input-Quelle  Scanner name = new Scanner(System.in);  Aufruf einer Methode mit Punktnotation («dot notation») 149 Input-QuelleEin neues Objekt (eines nicht-primitiven Typs) kann mit dem Keyword new erstellt werden! Scanner: Eine Auswahl von Methoden 150 Method Description nextInt() reads an int from the user and returns it nextDouble() reads a double from the user … next() reads a one-word String from the user … nextLine() reads a one-line String from the user … Scanner myConsole = new Scanner(System.in); int alter = myConsole.nextInt(); System.out.println(\"Ihr Alter: \" + alter); Scanner: Dokumentation https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Scanner.html  Alle Informationen und noch viel mehr  Ignorieren Sie (vorerst), was Sie nicht verstehen 151 Scanner: Ablauf der Eingabe  Ausgabe eines Prompts (Eingabeaufforderung) an Benutzer  Erscheint im Konsolenfenster  Information an Benutzer, dass (und welche) Eingabe erwartet wird  Eingabe des Inputs durch Benutzer  Unterbruch des Programms bis Eingabe erfolgt ist  Eingabe wird beendet durch Enter-Taste  Erscheint im gleichen Konsolenfenster wie Ausgabe  Programm wird fortgesetzt 152 Scanner: Beispiel 1 153 import java.util.Scanner; public class UserInputExample { public static void main(String[] args) { Scanner myConsole = new Scanner(System.in); System.out.print (\"Wie alt sind Sie? \"); // Prompt int alter = myConsole.nextInt(); int jahre = 65 – alter; System.out.println(jahre + \"Jahre bis zur Pensionierung\"); } } Wie alt sind Sie? 33 Jahre bis zur Pensionierung 32 Scanner: Warnung zu Resource Leak  geöffnete Ressourcen (Dateien, …) müssen wieder geschlossen werden  geschieht z.B. in einem try-Block (mehr dazu später)  Scanner ohne diesen Block führt zu Warnung  Warnung kann für den Moment ignoriert werden! 154 Scanner: Beispiel 2 155 import java.util.Scanner; public class UserInputExample { public static void main(String[] args) { Scanner myConsole = new Scanner(System.in); System.out.print(\"Zwei Zahlen bitte: \"); // Prompt int a = myConsole.nextInt(); int b = myConsole.nextInt(); int product = a * b; System.out.println(product); } } mehrere Zahlen in einer Zeile (bis Enter) lesen Zwei Zahlen bitte: 42 6 7 Beispiel: Falscher Input System.out.print(\"Wie alt sind Sie? \"); int alter = myConsole.nextInt(); Wie alt sind Sie? Exception in thread \"main\" java.util.InputMismatchException at java.util.Scanner.throwFor(Scanner.java:964) at java.util.Scanner.next(Scanner.java:1619) at java.util.Scanner.nextInt(Scanner.java:2284) ... Zweiunddreissig Falscher Input-Typ Eingabeelement («token») 157  Folge von Zeichen, die vom Scanner am Stück gelesen werden  Scanner muss wissen, wo Beschreibung aufhört (und anfängt)  Separiert durch Zwischenraum («whitespace»)  Leerzeichen («space», «blank»), Tabulator («tab»), neue Zeile («new line»)  Kann kontextabhängig sein  45 18 $2.50 hello world  $2.50 \"hello world\" 1.456E12 \"45 18\"  Erwartete Zeichen hängen von Methode ab  Z.B. Unterschied zwischen nextInt() und nextDouble()  Braucht Beschreibung von legalen Zeichenfolgen (EBNF!)  Fehlermeldung (zur Laufzeit), falls Token nicht den richtigen Typ/die richtige Form hat! Beispiel: next() 158 Scanner console = new Scanner(System.in); System.out.print(\"What is your name? \"); String name = console.next(); name = name.toUpperCase(); System.out.println(name + \" has \" + name.length() + \" letters \"); What is your name? Minnie MINNIE has 6 letters What is your name? Minnie Mouse MINNIE has 6 letters What is your name? \"Minnie Mouse\" \"MINNIE has 7 letters Liest ein Wort bis zum Zwischenraum Beispiel: nextLine() 159 Scanner console = new Scanner(System.in); System.out.print(\"What is your name? \"); String name = console.nextLine(); name = name.toUpperCase(); System.out.println(name + \" has \" + name.length() + \" letters \" + What is your name? Minnie MINNIE has 6 letters What is your name? Minnie Mouse MINNIE MOUSE has 12 letters What is your name? \"Minnie Mouse\" \"MINNIE MOUSE\" has 14 letters Liest eine Zeile Zufallszahlen («random numbers»)  Oft als Ersatz für Zahlen-Input 160 random {adjective} zufällig willkürlich [wahllos] zufallsbedingt Zufalls- dem Zufall überlassen (aus EN-DE-Wörterbuch) (Pseudo-)Zufallszahlengenerator Random  Random aus Bibliothek java.util importieren  import java.util.Random;  Random-Objekt konstruieren  Random name = new Random();  Verschiedene Methoden für unterschiedliche Modi 161 Method Description nextInt() returns a ”random integer” nextInt(n) returns a ”random” integer in the range [0, n) in other words: returns a number from {0, …, n – 1} at ”random” nextDouble() returns a “random real” number in the range [0.0, 1.0) Häufige Szenarien  Zufällige ganze Zahl aus [1, n]  1 + rand.nextInt(n)  Zufällige ganze Zahl aus [min, max]  min + rand.nextInt(max – min + 1)  Zufällige reelle Zahl aus [min, max]  min + rand.nextDouble() * (max – min)  Zufälliges Objekt aus einer Menge von n Objekten  Beliebige Nummerierung der Objekte mit [1, n] oder [0, n-1] 162 Beispiel 1: Würfel 163 import java.util.Random; public class DiceThrow { public static void main(String[] args) { Random rand = new Random(); int face = 1 + rand.nextInt(6); System.out.println(\"You threw a \" + face); } } Beispiel-Output: You threw a 6 Beispiel 2: Zufällige Note in [1.0, 6.0] 164 import java.util.Random; public class RandomGrade { public static void main(String[] args) { Random rand = new Random(); double r = 5.0 * rand.nextDouble(); // 0 <= r <= 5 double grade = 1.0 + r; System.out.println(\"You got a \" + grade); } } Beispiel-Output: You got a 4.2 Beispiel 3: Zufällige gerade Zahl zwischen 4 und 12 165 import java.util.Random; public class RandomGrade { public static void main(String[] args) { Random rand = new Random(); int r = 2 * rand.nextInt(5) + 4; System.out.println(r); } } Beispiel-Output: 6 2. Erste Java-Programme 2.5 Logische Aussagen über Programm(segment)e 2.5.1 Motivation, Aussagen, logisches Schliessen 2.5.2 Hoare-Tripel für Zuweisungen 166 Vogelperspektive Softwareentwicklung  Grosse Programme werden aus einzelnen Modulen (Methoden, Klassen, Bibliotheken, …) zusammen -gesetzt ➜ Modulare Entwicklung  Voraussetzung: Es muss klar spezifiziert werden, was ein Modul leisten soll  Für Modulentwickler/innen: Wann ist das Modul vollständig bzw. was fehlt noch?  Für Modulnutzer/innen: Wie ist das Modul zu benutzen? Was kann ich erwarten? 167Bild mit Handy-Komponenten: ifixit.com Beispielspezifikationen Spezifikationen in «mathematischer Sprache» (Logik ➜ Diskrete Mathematik), damit eindeutig und beweisbar  Vorbedingung («precondition»): Was muss vor dem Aufruf gelten?  Nachbedingung («postcondition»): Was gilt nach dem Aufruf?  Hier als spezielle Java-Kommentare ins Programm geschrieben 168 // PRE: true // POST: ∀ i. vi ≤ vi+1 void sort(vector v) { ... // viel und komplexer Code ... } // PRE: x ≥ 0 // POST: result2 = x double sqrt(double x) { ... // viel und komplexer Code ... } result bezieht sich auf das Ergebnis der Berechnung (den Rückgabewert der Methode) Vor- und Nachbedingungen: Zwei Perspektiven Eine Spezifikation aus Vor- und Nachbedingung etabliert quasi einen Vertrag:  Entwickler/in muss nicht alle Nutzungen kennen; verlässt sich auf die Vorbedingung  Nutzer/in muss die Implementation nicht kennen; verlässt sich auf die Nachbedingung 169 // PRE: x ≥ 0 // POST: result2 = x double sqrt(double x) double sqrt(double x) { // Kann x ≥ 0 annehmen // ... Code ... // Muss result2 = x garantieren } // Muss x ≥ 0 garantieren y = sqrt(x); // Kann y2 = x annehmen Methodenentwickler Methodennutzer Nutzen spezifizierter Software  Vision  Jedes Modul erhält eine formale Spezifikation  Programm entsteht durch Kombination passender Module  Mathematischer Beweis, dass das gesamte Programm das gewünschte Ergebnis liefert/sich wie gewünscht verhält  Für uns nützlich: Denken in Spezifikationen hilft beim Programmieren und kann die Entwicklung lenken  Wir nutzen die Ideen und Konzepte informell/intuitiv  Formale Theorie folgt dann in Formal Methods (4. Semester) 170Apfel-Puzzle: mathematica.stackexchange.com Einstieg: Aussagen über Programmsegmente  Wir wollen eine Aussage über obige Berechnung tätigen  Muss Variable (Endergebnis) z involvieren  Beziehen sich immer auf einen bestimmten Programmpunkt (Zeile)  Diese Aussage ist die Nachbedingung des obigen Codes  Beispiel: z > 0 (gilt dies?) 171 int u = ...; // u hat irgendeinen Wert int x = 17; int y = 42; int z = u + x + y; (Logische) Aussagen 172  Aussage («assertion»): Behauptung, die entweder wahr oder falsch ist  Wir fragen dann oft «Ist die Aussage wahr?» oder «Gilt sie?»  «Logisch» heisst hier «im Sinne der mathematischen Logik»  Diverse Beispiele:  EProg ist ein Fach im Basisjahr Informatik  Seebach ist der Hauptort des Kantons Zürich  11 ist eine Primzahl  13 ist eine gerade Zahl  x ≥ 0 (hängt von x ab)  x geteilt durch 2 ergibt 8 (hängt von x ab) (Logische) Aussagen  Aussage: Behauptung, die entweder wahr oder falsch ist  Nicht alle Aussagen sind wahr  Sind evtl. nur unter bestimmten Bedingungen wahr (z.B. «x % 5 ist 3»)  Wichtig ist, dass es Sinn macht zu fragen, ob die Aussage wahr oder falsch ist  Für uns: Im Kontext der Entwicklung eines Programms 173 int u = ...; int x = 17; int y = 42; int z = u + x + y; // Gilt «z > 0»? Aussagen in EProg  Wir schreiben Aussagen als Kommentare in den Quelltext  Kommentare ➜ keine Bedeutung für Java, für uns aber schon  Geschweifter Klammern «{…}» sind übliche Notation (Lehrbücher, Formal Methods)  Die Kommentarzeichen «//» lassen wir aus Platzgründen i.d.R. weg  Wir nehmen mathematische Zahlen an: ℕ statt int, d.h. keine Überläufe (aber weiterhin ganzzahlige Division, d.h. 5 / 2 ist 2) 174 // {x > 0 und x < y} z = x * y; // {z > 0} {x > 0 und x < y} ... Falls Sie Vorkenntnisse haben: Wir nehmen ausserdem seiteneffektfreie Ausdrücke sowie sequenzielle Ausführung an Vorwärtsschliessen: Vorgehen  Start: Wählen (wissen, raten) einer sinnvollen Vorbedingung (Precondition = Assertion0)  Schrittweise: Herleiten der nächsten Aussage (Assertioni) durch Einbeziehen des Effekts der nächsten Anweisung (Statementi)  Ziel: Herleiten einer gültigen Nachbedingung (Postcondition = Assertionn) 175 {Precondition} Statement1; {Assertion1} Statement2; {Assertion2} ... Statementn; {Postcondition}  Vorwärts = «Welche Garantien (Nachbedingung) kann mein Code, unter der gewählten Vorbedingung, geben?» Vorwärtsschliessen: Beispiel  Wir wählen als Vorbedingung u > 0  Pro Schritt: Wenn vorher Aussage Ai-1 gilt, welche Aussage Ai gilt dann nach Ausführung des nächsten Statements Si?  Dann gilt die Nachbedingung z > 59 (warum?) 176 {u > 0} x = 17; {u > 0 ∧ x == 17} y = 42; {u > 0 ∧ x == 17 ∧ y == 42} z = u + x + y; {u > 0 ∧ x == 17 ∧ y == 42 ∧ z == u + 17 + 42} In Aussagen nutzen wir «==» für (mathematische) Gleichheit Rückwärtsschliessen: Vorgehen  Start: Wählen (wissen, raten) einer sinnvollen Nachbedingung  Schrittweise: Herleiten der vorherigen Aussage (Assertioni) durch Einbeziehen des Effekts der nächsten Anweisung (Statementi)  Ziel: Herleiten einer notwendigen und hinreichenden Vorbedingung 177 {Precondition} Statement1; ... {Assertionn-2} Statementn-1; {Assertionn-1} Statementn; {Postcondition}  Rückwärts = «Welche Vorbedingung braucht mein Code, damit er die gewählten Garantien (Nachbedingung) geben kann?» Rückwärtsschliessen: Beispiel  Wir wählen als Nachbedingung z > 0  Pro Schritt: Wenn nach Statement Si Aussage Ai gelten soll, welche Aussage Ai-1 muss dann vor der Ausführung von Si gelten?  Dann muss die Vorbedingung u > -59 gelten (warum?) 178 {u + 17 + 42 > 0} x = 17; {u + x + 42 > 0} y = 42; {u + x + y > 0} z = u + x + y; {z > 0} Vor-/Rückwärts: Gemeinsamkeit Beide Paare aus Vor- und Nachbedingung («Verträge») sind gültig: Wenn vor der Programmausführung die Vorbedingung gilt, dann gilt nach der Ausführung die Nachbedingung. 179 {u > 0} x = 17; {u > 0 ∧ x == 17} y = 42; {u > 0 ∧ x == 17 ∧ y == 42} z = u + x + y; {u > 0 ∧ x == 17 ∧ y == 42 ∧ z == u + 17 + 42} Vorw. {u > -59} x = 17; {u + x + 42 > 0} y = 42; {u + x + y > 0} z = u + x + y; {z > 0} Rückw. Vor-/Rückwärts: Unterschiede Vorwärts  Erscheint anfangs «natürlicher», da es dem (linearen) Kontrollfluss folgt  Hält viele Details in den Aussagen fest, die letztendlich irrelevant sind 180 {u > 0} x = 17; {u > 0 ∧ x == 17} y = 42; {u > 0 ∧ x == 17 ∧ y == 42} z = u + x + y; {u > 0 ∧ x == 17 ∧ y == 42 ∧ z == u + 17 + 42} Vorw. {u > -59} x = 17; {u + x + 42 > 0} y = 42; {u + x + y > 0} z = u + x + y; {z > 0} Rückw. Rückwärts  Code «rückwärtszulesen» erfordert Übung, aber führt zu einer neuen Sicht auf das Programm  Grosser praktischer Nutzen: Sie (müssen) verstehen, was jede Anweisung zum Erreichen des gewünschten Endzustands beiträgt Aussagen zur Laufzeit: assert-Anweisung  In Java-Programmen können Aussagen durch assert- Anweisungen ausgedrückt werden  Syntax: assert expr;  Für einen gültigen Java-Ausdruck expr (mit Typ boolean ➜ später mehr)  Daher keine geschweiften Klammern ({…}) um die Aussage  Beispiel: assert x > 0;  Semantik: Programmabbruch, falls Aussage nicht hält  Hilfreich, um eigene Annahmen zu überprüfen 181 2. Erste Java-Programme 2.5 Logische Aussagen über Programm(segment)e 2.5.1 Motivation, Aussagen, logisches Schliessen 2.5.2 Hoare-Tripel für Zuweisungen 182 Hoare-Logik: Hintergrund  Tony Hoare entwickelte in den 1970er Jahren einen formalen Ansatz, um Eigenschaften von Programmen beweisen zu können ➜ Hoare-Logik («Hoare logic»)  Genutzt von z.B. Amazon, Microsoft, Airbus; aber auch von kleineren Firmen in CH, ZH  Formale Beweise, plus Tools, in Formal Methods (4. Semester)  Im (Arbeits-)Alltag genügt es oft, weniger detailliert zu argumentieren, als es Hoare-Logik erfordert 183 {Precondition} statement1; {Assertion1} statement2; {Assertion2} ... statementn; {Postcondition}  Unsere Ziele: Grundlegende Konzepte einführen und üben, so dass 1. Sie für einfache Programme (relativ) genau argumentieren können 2. Ihnen der Einstieg in Formal Methods etwas leichter fällt Logik und Programmentwicklung  Sich mit Aussagen über Programmen zu beschäftigen ist eine gute Schulung, systematisch zu programmieren  Wir können Aussagen machen über Zustände (der Ausführung) eines Programms (und später auch eines Objekts)  D.h. wir können den Effekt eines Programms (semi-)formal beschreiben  Wichtig für die Definition von Schnittstellen (zwischen Modulen), wenn wir entscheiden müssen, welche Bedingungen erfüllt sein müssen (z.B. um eine Methode aufzurufen) 184 Hoare-Tripel: Syntax  Ein Hoare-Tripel («Hoare triple»), auch 3-Tupel genannt, besteht aus zwei Aussagen und einem Programmsegment:  Bestandteile eines Tripels  P ist die Vorbedingung (Precondition, z.B. u > -59)  S ist eine Anweisung (Statement; bzw. mehrere Anweisungen)  Q ist die Nachbedingung (Postcondition, z.B. z > -59) 185 {P} S {Q} Hoare-Tripel: Bedeutung  Ein Hoare-Tripel {P} S {Q} ist gültig wenn (und nur wenn):  Für jeden Zustand, für den P gültig ist, ergibt die Ausführung von S immer einen Zustand, für den Q gültig ist.  Informell: Wenn P wahr ist vor der Ausführung von S, dann muss Q nachher wahr sein  Andernfalls ist das Hoare-Tripel ungültig. 186 Hoare-Tripel etablieren  Wie etablieren (≈ beweisen) wir ein Hoare-Tripel {P} S {Q}?  Für jede Java-Anweisung gibt es genaue Regeln, die eine Vor- und Nachbedingung (für diese Anweisung) in Beziehung setzen  Regel für Zuweisungen  Regel für aufeinander folgende Anweisungen  Regel für Verzweigungen, Schleifen (später)  …  Regeln existieren als Vorwärts- und Rückwärts-Version  Wir lernen nur die Rückwärts-Regeln kennen, da relevanter 187 Hoare-Logik-Regel für Zuweisungen 188  Ziel: Wir wollen ein Tripel {P} X = E {Q} etablieren, also zeigen, dass es gültig ist  P und Q sind Platzhalter für beliebige Aussagen  X ist ein Platzhalter für eine beliebige Java-Variable  E ist ein Platzhalter für einen beliebigen Java-Ausdruck  Regel (Vorgehen, um Gültigkeit zu zeigen) 1. Erhalte Q' durch: Ersetzen aller Vorkommen von X in Q durch E 2. Zeige, dass P ⇒ Q' gilt (Implikation, d.h. das Q' gilt wenn P gilt) Erklärung 189 Intuition: Warum ergibt diese Regel Sinn?  Schritt 1 (syntaktische Ersetzung von X durch E) 1. Nach der Zuweisung soll Q gelten 2. Die Zuweisung ändert den Wert von X auf E – sonst ändert sich nichts ➜ Wenn wir die Aussage Q mit E statt X formulieren (= Q'), muss diese Aussage bereits vor der Zuweisung gegolten haben  Schritt 2 (Implikation) 1. Gerade argumentiert: Wenn Q' vor der Zuweisung gilt, gilt danach Q 2. P ⇒ Q' bedeutet, dass P eine stärkere Vorbedingung als Q' ist ➜ P ist daher eine hinreichende Vorbedingung (damit am Ende Q gilt) 1. Bilden von Q' durch Er- setzen aller X in Q durch E 2. Zeigen, dass P ⇒ Q' gilt {P} X = E {Q}Beispiel 1 190 1. Bilden von Q' durch Er- setzen aller X in Q durch E 2. Zeigen, dass P ⇒ Q' gilt {P} X = E {Q} {b + 25 > 30} a = b + 25; {a > 30}  Tripel ist gültig  X ist a, E ist b + 25,  Q ist a > 30, P ist b + 25 > 30  Q' ist b + 25 > 30  P impliziert Q' trivialerweise, denn P ist gleich Q' Erinnerung: Wir gehen in Aussagen von mathematischen Zahlen aus, d.h. b + 25 führt nie zu einem Überlauf Beispiel 2 191 1. Bilden von Q' durch Er- setzen aller X in Q durch E 2. Zeigen, dass P ⇒ Q' gilt {P} X = E {Q} {b > 5} a = b + 25; {a > 30}  Tripel ist gültig  X ist a, E ist b + 25  Q ist a > 30, P ist b > 5  Q' ist b + 25 > 30  (b > 5) ⟹ (b + 25 > 30) (Beweis: einfache Formelumstellung) Beispiel 3 192 1. Bilden von Q' durch Er- setzen aller X in Q durch E 2. Zeigen, dass P ⇒ Q' gilt {P} X = E {Q} {b > 0} a = b + 25; {a > 30}  Tripel ist nicht gültig  X ist a, E ist b + 25  Q ist a > 30, P ist b > 0  Q' ist b + 25 > 30  P impliziert Q' nicht (Gegenbeispiel: wenn b den Wert 2 hat) Welche der folgenden Tripel sind (un)gültig? Fragen I 193 {x > 0} y = x + 1; {y > 1} {x > 100} y = x + 1; {y > 1} Bsp4 Bsp5 {v ≠ 1} w = v * v; {w ≠ v} Bsp6 Welche der folgenden Tripel sind (un)gültig? Fragen II 194 {age > 94} age = age + 1; {age > 95} Bsp7 {y % z == 0} x = y / z; {y == x * z} Bsp8 Erinnerung: In Aussagen nutzen wir «==» für Gleichheit Aussagen kombinieren  Beobachtung Programmentwicklung  Gegeben zwei Programmsegmente S1 und S2, ergibt die Kombination S1; S2 ein grösseres Programm  D.h. wir entwickeln grössere Programme aus kleineren (Modularität)  Analog für Tripel  Gegeben {P1} S1 {Q1} und {P2} S2 {Q2}  Wir möchten diese zu {P1} S1; S2 {Q2} kombinieren 195 Hoare-Logik: Aussagen kombinieren 196  Wenn zwei Aussagen aufeinander treffen, muss die vorherige Aussage die darauf folgende implizieren {P1} S1; {Q1} {P2} S2; {Q2} {P1}{P2} S; {Q}  Analog  falls P1 ⟹ P2  --- falls Q1 ⟹ Q2 Die Kombination links erfordert, dass 1. Tripel {P1} S1 {Q1} gültig ist 2. Tripel {P2} S2 {Q2} gültig ist 3. Q1 ⟹ P2 gilt {P} S; {Q1}{Q2} Hoare-Logik: Aussagen kombinieren 197 Intuition  Wenn P2 ausreicht, um S2 so auszuführen, dass nachher Q2 gilt …  … und wenn Q1 stärker ist als P2 …  … dann reicht auch Q1 aus, um S2 erfolgreich auszuführen {P1} S1; {Q1} {P2} S2; {Q2} Die Kombination links erfordert, dass 1. Tripel {P1} S1 {Q1} und {P2} S2 {Q2} gültig sind 2. Q1 ⟹ P2 gilt Hoare-Logik-Regel für Anweisungsfolgen 198  Das Tripel {P} S1; S2 {Q} ist gültig, genau dann wenn  Aussage R existiert, so dass 1. {P} S1 {R} gültig ist 2. {R} S2 {Q} gültig ist Beispiel 199 Finde R, so dass gilt 1. {P} S1 {R} 2. {R} S2 {Q} {P} S1; S2 {Q} {x > 0} y = x + 1; z = y * y {z > y} Mit R gleich y > 1 können wir Gültigkeit zeigen: {x > 0} y = x + 1; {y > 1} z = y * y {z > y} 1. Tripel {x > 0} y = x + 1 {y > 1} ist gültig (Zuweisungsregel: x > 0 impliziert x + 1 > 0) 2. Tripel {y > 1} z = y + y {z > y} ist gültig (Zuweisungsregel: y > 1 impliziert y * y > y) Vorgehen für Anweisungsfolgen 200  Situation: Entscheide, ob {P} S1; S2 {Q} gültig ist  Empfohlenes Vorgehen: {P} {R'} S1; {R} S2; {Q} 1. Wende bekannte Regeln an, um Folgendes zu erhalten: 2. Zeige Implikation P ⟹ R' Beispiel 201 {x > 0} {(x + 1) * (x + 1) > (x + 1)} y = x + 1; {y * y > y} z = y * y {z > y} 1. Regeln anwenden: 2. Implikation zeigen: (x > 0) ⟹ (x+1) * (x+1) > (x+1) hält, denn für x ≥ 2 ist x2 > x  Frage: Ist {x > 0} y = x + 1; z = y * y {z > y} gültig?  Antwort daher: Ja Frage  Welche der folgenden Tripel sind gültig? 202 {true} x = y; z = x; {y == z} {x == 7 ∧ y == 5} t = x; y = x; x = t; {y == 7 ∧ x == 5} True als Vorbedingung bedeutet «keinerlei Anforderung» (Anfangs- werte von x, y und z sind irrelevant) Welche Aussagen wollen wir?  Gleicher Code, unterschiedliche (gültige) Tripel  Frage: Gibt es «bessere» und «beste» Aussagen bzw. Tripel?  Welches A-Tripel ist «besser»? Welches B-Tripel? Warum?  Was könnte eine allgemeine Definition von «besser» sein?  Besser für … wen eigentlich? 203 {a > 0 ∧ b > 0} x = a + b; {x > 0} vs. A1 {a + b > 0} x = a + b; {x > 0} A2 {true} x = y + 1; {x > y} {true} x = y + 1; {x == y + 1} vs. B1 B2 Stärkere und schwächere Aussagen  Wir können stärkere und schwächere Aussagen unterscheiden  Wenn P1 ⟹ P2 gilt, dann ist P1 stärker als P2 (und P2 schwächer als P1)  Beispiele 204 {a > 0 ∧ b > 0} x = a / b; {x > 0} vs. A1 {a + b > 0} x = a + b; {x > 0} A2 {true} x = y + 1; {x > y} {true} x = y + 1; {x == y + 1} vs. B1 B2  (a > 0 ∧ b > 0) ⟹ (a + b > 0), d.h. A1 hat die stärkere Vorbedingung  (x == y + 1) ⟹ (x > y), d.h. B2 hat die stärkere Nachbedingung Beste Tripel? Zwei Perspektiven Perspektive 1: Sie möchten existierenden Code nutzen (d.h. wir nehmen an, dass der Code «fixiert» ist) 205 {P?} code {Q?}  Je schwächer die Vorbedingung, desto öfter nutzbar (breiter einsetzbar) ist der Code  Beispiel: {a + b > 0} erlaubt den Einsatz in mehr Situationen (ist weniger «anspruchsvoll») als {a > 0 ∧ b > 0}  Je stärker die Nachbedingung, desto mehr Garantien bekommen Sie (desto mehr wissen Sie) als Code-Nutzer/in  Beispiel: Mit {x == y + 1} wissen Sie, dass der Abstand zwischen x und y genau eins ist, anders als bei {x > y} Beste Tripel? Zwei Perspektiven Perspektive 2: Sie müssen Code für jemanden schreiben (wir nehmen an, dass die Anforderungen/das Tripel «fixiert» sind) 206 {P} code? {Q}  Stärkere Vorbedingung ➜ mehr Garantien für Sie, d.h. Ihre Aufgabe wird einfacher  Intuitives Beispiel: «Entwickeln Sie eine Texterkennung für englische Buchstaben» vs. «… für Buchstaben»  Schwächere Nachbedingung ➜ Potenziell mehr Wahlfreiheit, daher eventuell einfacher, für Sie  Intuitives Beispiel: «Endergebnis ist grösser als n» vs. «Endergebnis ist die nächste Primzahl grösser als n» Automatisierung  Es gibt (semi-)automatische* Algorithmen, um 1. Die schwächste Vorbedingung, für gegebenen Code und Nachbedingung, zu berechnen 2. Die stärkste Nachbedingung, für gegebenen Code und Vorbedingung, zu berechnen  Zum Beispiel berechnet die kennengelernte Regel für Zuweisungen («ersetze Vorkommnisse der zugewiesenen Variablen …») die schwächste Vorbedingung 207 * Für relative einfache Programme; Problem letztendlich unentscheidbar (➜ Theoretische Informatik), daher braucht es * menschliche Hilfe. Details für EProg nicht relevant. {P?} code {Q} {P} code {Q?}","libVersion":"0.5.0","langs":""}