{"path":"sem4/FMFP/PV/FMFP-finals/FMFP-FS16.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Exam August 23, 2016, 9:00 – 12:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 30 pages; the back page of this booklet is page 30. After the exam begins, check that your exam papers are complete (4 assignments for the FP part, 4 assignments and 2 pages of background material for the FM part). 2. You may complete the assignments in any order. We recommend spending roughly half of your time on each of the two parts of the exam. 3. Only write on the exam paper and extra paper sheets which are given by the assis- tants. Do not take any of this paper out of the exam: submit it all. Write your ﬁrst and last name and your student number on every sheet of paper that you write on. 4. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 5. For the FP part of the exam, you may use any functions from the Haskell Prelude and Data.List in your solutions (without giving their deﬁnitions). 6. Write clearly in the sense of logic, language, and readability. Label all rule applica- tions in your derivation trees. The clarity of your arguments and explanations aﬀects your grade. 7. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 8 ∑ Max. points 10 9 8 13 10 12 10 8 80 Your points Formal Methods and Functional Programming, Exam, SS16 2 Part I: Functional Programming Formal Methods and Functional Programming, Exam, SS16 4 Assignment 1: Typing (10 points) (a) Recall the following functions from the Haskell libraries. (4 points) (+) :: Num a => a -> a -> a (.) :: (a -> b) -> (c -> a) -> c -> b (,) :: a -> b -> (a, b) map :: (a -> b) -> [a] -> [b] snd :: (a, b) -> b True :: Bool Determine whether the following expressions are well-typed or not. If so, then state the most general type; otherwise justify informally why the expression is not typable. 1. \\x y z -> (y x, x z) 2. map . map 3. \\x y -> x (map y x) 4. (\\x y -> snd x y) (True, \\y -> 3 + y) Formal Methods and Functional Programming, Exam, SS16 5 Assignment 1 continues on the next page. Formal Methods and Functional Programming, Exam, SS16 6 (b) Formally infer the most general type of the following expression using (6 points) the Mini-Haskell typing rules. Label every proof step with the rule used. Ø (λy. λx. iszero (y x)) (λx. snd x) ∶∶ . . . Recall the proof rules for the Mini-Haskell type system: Var . . . , x ∶ τ, . . . Ø x ∶∶ τ Γ, x ∶ σ Ø t ∶∶ τ Abs Γ Ø λx. t ∶∶ σ → τ Γ Ø t1 ∶∶ σ → τ Γ Ø t2 ∶∶ σ App Γ Ø t1 t2 ∶∶ τ Int Γ Ø n ∶∶ Int True Γ Ø T rue ∶∶ Bool False Γ Ø F alse ∶∶ Bool Γ Ø t ∶∶ Int iszero Γ Ø iszero t ∶∶ Bool Γ Ø t1 ∶∶ Int Γ Ø t2 ∶∶ Int BinOp Γ Ø (t1 op t2) ∶∶ Int for op ∈ {+, ∗} Γ Ø t0 ∶∶ Bool Γ Ø t1 ∶∶ τ Γ Ø t2 ∶∶ τ if Γ Ø if t0 then t1 else t2 ∶∶ τ Γ Ø t1 ∶∶ τ1 Γ Ø t2 ∶∶ τ2 Tuple Γ Ø (t1, t2) ∶∶ (τ1, τ2) Γ Ø t ∶∶ (τ1, τ2) fst Γ Ø fst t ∶∶ τ1 Γ Ø t ∶∶ (τ1, τ2) snd Γ Ø snd t ∶∶ τ2 Formal Methods and Functional Programming, Exam, SS16 7Formal Methods and Functional Programming, Exam, SS16 8 Assignment 2: Proofs about funct. programs (9 points) Consider the following Haskell declarations. length [] = 0 -- length.1 length (x:xs) = 1 + length xs -- length.2 revdup xs = aux [] xs -- revdup where aux ys [] = ys -- aux.1 aux ys (x:xs) = aux (x:x:ys) xs -- aux.2 Prove that for all ﬁnite lists xs :: [a] the equality length (revdup xs) = 2 * length xs holds. Structure your proof clearly and justify every proof step. Hint: You may want to prove a statement about length (aux ys xs) ﬁrst. Formal Methods and Functional Programming, Exam, SS16 9Formal Methods and Functional Programming, Exam, SS16 10 Assignment 3: Lists in Haskell (8 points) (a) Deﬁne a function pairSum :: [Int] -> Int -> [(Int, Int)] (2 points) such that pairSum l n ﬁnds all pairs of elements in the ﬁnite list l that add up to n. Example: pairSum [1,3,5,7,9] 13 = [] pairSum [1,3,5,7,9] 14 = [(5,9),(9,5),(7,7)] (b) Deﬁne a Haskell function interlace :: [a] -> [a] -> [a] that (2 points) interlaces two (possibly inﬁnite) lists. That is, interlace l1 l2 returns the list cre- ated by alternatingly taking elements from l1 and l2 starting with l1. If one of the lists is exhausted in this process, the remainder of the other list is appended to the result. Examples: interlace [1,2,3,4,5] [6,7,8] = [1,6,2,7,3,8,4,5] take 5 $ interlace [1,3..] [2,4..] = [1,2,3,4,5] (c) The inﬁnitely many inmates of the Omega Chain Gang are (4 points) in prison cells numbered 1,2,3,. . . The warden decides to release some of the inmates in the following way: First, guard #1 visits all the cells and turns the key in the lock. Next, guard #2 visits all cells with even numbers and turns the key in the lock. Then, guard #3 visits all cells whose number is a multiple of 3 and turns the key in the lock. In general, guard #n visits all cells whose number is a multiple of n and turns the key in the lock. Turning a key unlocks a locked door and locks an unlocked door. The prisoners whose door remains unlocked after all (inﬁnitely many) guards have passed through are free to go. Initially, all cell doors are locked. Write a Haskell program to compute the inﬁnite list open :: [Integer] of cell num- bers of the released inmates. Formal Methods and Functional Programming, Exam, SS16 11Formal Methods and Functional Programming, Exam, SS16 12 Assignment 4: JSON in Haskell (13 points) In this assignment, we consider a simpliﬁed version of JSON (JavaScript Object Notation), a standardized language-independent data format. A JSON value is either some primitive value containing data of some type a, or an object consisting of a map from keys to JSON values. The Haskell type Json a of JSON values models keys as strings and represents the maps as associative lists. All JSON objects should satisfy the invariant that for every associative list, each key occurs only once in that list. data Json a = Val a | Obj [(String, Json a)] Example: The Json String value address given below is an object with three keys: 1. \"place\" is associated with the primitive value \"London\", and 2. \"street\" maps to a subobject with two keys, \"name\" and \"no\", which in turn are associated to the strings \"Baker\" and \"221b\", respectively, and 3. \"country\" is associated with the primitive value \"UK\". address = Obj [ (\"place\", Val \"London\"), (\"street\", Obj [(\"name\", Val \"Baker\"), (\"no\", Val \"221b\")], (\"country\", Val \"UK\"))] A JSON value can be visualised as an arbitrarily- branching tree with Obj as inner nodes, Val as leaves, and the keys as edge labels. The tree for address is shown on the right. Obj Val \"London\" Obj Val \"UK\" Val \"Baker\" Val \"221b\"\"place\"\"street\"\"country\"\"name\"\"no\" (a) Brieﬂy describe how one can ensure that every value of type Json a (2 points) constructed by some user satisﬁes this invariant. Hint: Your answer should consist of a few sentences. You need not write any code. Formal Methods and Functional Programming, Exam, SS16 13 (b) Implement the canonical fold function foldJson for Json a. (3 points) foldJson :: (a -> b) -> ([(String, b)] -> b) -> Json a -> b (c) Instantiate the type class Eq for Json a. Equality should ignore (4 points) the order of the key-value pairs in the associative lists. Your implementation may assume that all arguments satisfy the invariant. Example: Obj [(\"a\", Val 42), (\"b\", Val 3)] == Obj [(\"b\", Val 3), (\"a\", Val 42)] Hints: You may need to assume that a belongs to certain type classes. The functions elem :: Eq a => a -> [a] -> Bool and all :: (a -> Bool) -> [a] -> Bool from the Prelude may be useful. Formal Methods and Functional Programming, Exam, SS16 14 (d) Write a function values :: Json a -> [(String, a)] which (4 points) ﬂattens the JSON structure into a single key-value list. Diﬀerent keys along a path to a value are combined with a \".\". Example: values address = [ (\"place\", \"London\"), (\"street.name\", \"Baker\"), (\"street.no\", \"221\"), (\"country\", \"UK\")] Formal Methods and Functional Programming, Exam, SS16 15Formal Methods and Functional Programming, Exam, SS16 16 Part II: Formal Methods Formal Methods and Functional Programming, Exam, SS16 18 Assignment 5 (10 points) Consider the following IMP statement s: while x > 0 do x := 3 - 2 * x end (a) (2 points) Let σ be a state such that σ(x) = 1. Prove using the structural operational semantics that there exists k such that k > 0 and `s, σe → k 1 `s, σe. You do not need to show the derivation trees justifying the steps in your k-step execution. (b) (1 point) The statement s terminates for any initial value of x other than 1. Write down a total correctness Hoare triple expressing this fact (you do not need to prove it yet). Formal Methods and Functional Programming, Exam, SS16 19 (c) (7 points) For any initial value of x less than 1, the statement s terminates after zero loop iterations, while for any initial value greater than 1, it terminates after one iteration. We can express a suitable loop variant using a conditional expression (x < 1 ? 0 : 1). Here, as in Java/C, a conditional expression (b ? e1 : e2) has the value of e1 in states where b is true, and the value of e2 in states where b is false, i.e.: A[[(b ? e1 : e2)]]σ = ¢¨¨ ¦ ¨¨¤ A[[e1]]σ if B[[b]]σ = tt A[[e2]]σ otherwise Using the above loop variant, construct a total correctness proof outline to prove your Hoare triple from part (b). (Hint: clearly state your loop invariant and justify any non- trivial entailment steps in your proof outline). Formal Methods and Functional Programming, Exam, SS16 20 Assignment 6 (12 points) (a) (9 points) Prove that (with respect to partial correctness Axiomatic Semantics): ∀s, ∀P, ∀Q⋅ (Ø { P } s { Q } and s contains no assignment or while statements) ⇒ P à Q Formal Methods and Functional Programming, Exam, SS16 21Formal Methods and Functional Programming, Exam, SS16 22 (b) (1 points) Show that the result of part (a) would be false if we allowed the statement s to contain assignment statements (but not while statements). You should do this by giving a speciﬁc counterexample (state a speciﬁc s and predicates P and Q) for which the implication is false. You do not need to justify your choice of counterexample. (c) (2 points) Similarly to part (b), show that the result of part (a) would be false if we allowed the statement s to contain while statements (but not assignment statements). Again, you do not need to justify your choice of counterexample. Formal Methods and Functional Programming, Exam, SS16 23Formal Methods and Functional Programming, Exam, SS16 24 Assignment 7 (10 points) Recall the extension of the small-step semantics of IMP with rules for non-determinism: (ND1SOS) `s s′, σe →1 `s, σe (ND2SOS) `s s′, σe →1 `s′, σe We can use non-determinism to write a while loop which “chooses” an integer value (an idea which we have seen in the context of Promela modelling). For example, consider the following IMP statement s which chooses any integer value for y equal to or higher than its initial value: while x = 0 do y := y + 1 [] x := 1 end Prove, by induction on n, that: ∀n ∶ Nat, ∀σ ⋅ σ(x) = 0 ⇒ `s, σe → ∗ 1 `s, σ[y ( σ(y) + n][x ( 1]e You do not need to provide the derivation trees justifying any k-step reduction (→ k 1) steps used in your proof. You may use any of the following lemmas without proving them - state clearly where you use them in your solution (if you do): Lemma 1: ∀σ, ∀x ⋅ σ[x ( σ(x)] = σ Lemma 2: ∀σ, ∀x, ∀v1, ∀v2 ⋅ σ[x ( v1][x ( v2] = σ[x ( v2] Lemma 3: ∀σ, ∀x, ∀y, ∀v1, ∀v2 ⋅ x ~≡ y ⇒ σ[x ( v1][y ( v2] = σ[y ( v2][x ( v1] Formal Methods and Functional Programming, Exam, SS16 25Formal Methods and Functional Programming, Exam, SS16 26 Assignment 8 (8 points) (a) (3.5 points) Consider the following diagram that depicts a transition system. The extra labels on each state indicate which of two atomic propositions p and q are true in that state. s1 {} s2 {q} s3 {p} For each of the following LTL formulas, state whether or not the formula deﬁnes a property which is valid in the given transition system and justify your answer: if the property is valid then brieﬂy explain why; if it is not valid then provide a counterexample. 1. np 2. j n (p ∨ q) 3. ¬ j (q ∨ [q) 4. (j(q ∨ [q)) ⇒ ¬ n p Formal Methods and Functional Programming, Exam, SS16 27 (b) (2 points) Prove that, for any LTL formulas A and A′, if A describes a liveness property then A ∨ A′ also describes a liveness property. (c) (2.5 points) Does the formula (j(q ∨ [q)) ⇒ ¬ n p describe a safety property, a liveness property, neither, or both? Justify your answer. (Note: this was the last formula used in part (a)). Formal Methods and Functional Programming, Exam, SS16 28Formal Methods and Functional Programming, Exam, SS16 29 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ∶∶= skip T x := e T s; s T if b then s else s end T while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). Natural Semantics (Big-Step Semantics) (SkipNS) `skip, σe → σ (AssNS) `x := e, σe → σ[x ( A[[e]]σ] `s1, σe → σ′ `s2, σ′e → σ′′ (SeqNS) `s1;s2, σe → σ′′ `s1, σe → σ′ (IfTNS) `if b then s1 else s2 end, σe → σ′ if B[[b]]σ = tt `s2, σe → σ′ (IfFNS) `if b then s1 else s2 end, σe → σ′ if B[[b]]σ = ﬀ `s, σe → σ′ `while b do s end, σ′e → σ′′ (WhTNS) `while b do s end, σe → σ′′ if B[[b]]σ = tt (WhFNS) `while b do s end, σe → σ if B[[b]]σ = ﬀ Formal Methods and Functional Programming, Exam, SS16 30 Structural Operational Semantics (Small-Step Semantics) (SkipSOS) `skip, σe →1 σ (AssSOS) `x := e, σe →1 σ[x ( A[[e]]σ] `s1, σe →1 σ′ (Seq1SOS) `s1;s2, σe →1 `s2, σ′e `s1, σe →1 `s′ 1, σ′e (Seq2SOS) `s1;s2, σe →1 `s′ 1;s2, σ′e (IfTSOS) `if b then s1 else s2 end, σe →1 `s1, σe if B[[b]]σ = tt (IfFSOS) `if b then s1 else s2 end, σe →1 `s2, σe if B[[b]]σ = ﬀ (WhileSOS) `while b do s end, σe →1 `if b then s;while b do s end else skip end, σe Axiomatic Semantics (partial correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ( e] } x := e { P } { P } s1 { Q } { Q } s2 { R } (SeqAx) { P } s1;s2 { R } { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P′ } s { Q′ } (ConsAx) { P } s { Q } if P à P′ and Q′ à Q Axiomatic Semantics (total correctness) As for partial correctness above, except for the following rule, which replaces (WhAx) : { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P à 0 ≤ e","libVersion":"0.5.0","langs":""}