{"path":"sem2/PProg/VRL/slides/PProg-L16-mutual-exclusion.pdf","text":"spcl.inf.ethz.ch @spcl_eth TORSTEN HOEFLER Parallel Programming, Spring 2024, Lecture 16: Solving Mutual Exclusion for many processes, Hardware Primitives for mutual exclusion. My brain has about 86 billion neurons! Ok, with a total of 86 trillion synapses. spcl.inf.ethz.ch @spcl_eth 2 … but let’s go really large scale! 900,000 cores! spcl.inf.ethz.ch @spcl_eth ▪ Zoom links for exercise sessions may change! ▪ Please check the webpage and/or Moodle http://spcl.inf.ethz.ch/Teaching/2023-pp/ ▪ Last year’s videos on youtube channel “SPCL Lab” (playlist) ▪ And via ETH recording this year ▪ Head TA for the second section: Timo Schneider ▪ If anything goes wrong during an exercise: call him ☺ ▪ +41764688942 ▪ If anything non-urgent happens, send him email ▪ timos@inf.ethz.ch ▪ For questions – ask your group TA (or me in the break) 3 Administrivia spcl.inf.ethz.ch @spcl_eth So far: • Simple proofs of correctness and unexpected problems with real computers • Memory models as contract between programmer, compiler, runtime, and architecture • Java’s volatile and synchronized Now: ▪ Implementation of a two-thread locks with Atomic Registers Dekker’s algorithm Peterson’s algorithm ▪ Implementation of n-thread locks with Atomic Registers Filter lock Bakery lock ▪ Locks using atomic operations TAS, TATAS, exponential backoff lock ▪ Context: remember you will not use these locks (you will use functions provided by the programming model!) YET: you will learn important principles by “doing” – and watching your (my) mistakes carefully “Tell me and I forget, teach me and I may remember, involve me and I learn.” Learning goals for today 4 spcl.inf.ethz.ch @spcl_eth Behind Locks Implementation of Mutual Exclusion 5 spcl.inf.ethz.ch @spcl_eth In the following we assume 1) atomic reads and writes of variables of primitive type 2) no reordering of read and write sequences (! not true in practice ! here for simplicity !) 3) threads entering a critical section will leave it eventually Otherwise we assume a multithreaded environment where processes can interleave arbitrarily. We make no assumptions for progress outside of critical sections (i.e., threads may stall outside of a CS)! Assumptions 6 You know how to fix this with volatile! Will make «atomic» more precise today. spcl.inf.ethz.ch @spcl_eth Pieces of code with the following conditions 1. Mutual exclusion: statements from critical sections of two or more processes must not be interleaved 2. Freedom from deadlock: if some processes are trying to enter a critical section then one of them must eventually succeed 3. Freedom from starvation: if any process tries to enter its critical section, then that process must eventually succeed Critical sections According to M. Ben Ari, Principles of Concurrent and Distributed Programming 7 spcl.inf.ethz.ch @spcl_eth Process P local variables loop non-critical section preprotocol critical section postprotocol Critical section problem Process Q local variables loop non-critical section preprotocol critical section postprotocol global (shared) variables Easy to implement on a single-core machine. How? 8 spcl.inf.ethz.ch @spcl_eth Process P local variables loop non-critical section ? critical section ? Easy to implement on a single core system ... Process Q local variables loop non-critical section ? critical section ? global (shared) variables Switch off IRQs Switch off IRQs Switch on IRQs Switch on IRQs 9 spcl.inf.ethz.ch @spcl_eth Process P local variables loop p1 non-critical section p2 while(wantq); p3 wantp = true p4 critical section p5 wantp = false Mutual exclusion for 2 processes -- 1st Try Process Q local variables loop q1 non-critical section q2 while(wantp); q3 wantq = true q4 critical section q5 wantq = false volatile boolean wantp=false, wantq=false 10 Do you see the problem? spcl.inf.ethz.ch @spcl_eth State space diagram [p, q, wantp, wantq] p1, q1, false, false p1, q2, false, false p2, q1, false, false p2, q2, false, false p3, q1, false, false p1, q3, false, false p2, q3, false, false p3, q3, false, false p3, q2, false, false p4, q1, true, false p4, q2, true, false p4, q3, true, false p1, q4, false, true p2, q4, false, true p3, q4, false, true p4, q4, true, true no mutual exclusion ! 1 non-critical section 2 while(wantp) 3 wantp = true 4 critical section 5 wantp = false while(wantq) wantq = true wantq = false 11 p1 non-critical section p2 while(wantq); p3 wantp = true p4 critical section p5 wantp = false spcl.inf.ethz.ch @spcl_eth Process P local variables loop p1 non-critical section p2 while(wantq); p3 wantp = true p4 critical section p5 wantp = false Observation: state space diagram too large Process Q local variables loop q1 non-critical section q2 while(wantp); q3 wantq = true q4 critical section q5 wantq = false volatile boolean wantp=false, wantq=falseOnly of interest: state transitions of the protocol. p1/q1 is identical to p2/q2 – call state 2 p4/q4 is identical to p5/q5 – call state 5 Then forbidden: both processes in state 5 12 spcl.inf.ethz.ch @spcl_eth All of interest covered: Reduced state space diagram [p, q, wantp, wantq] – only states 2, 3, and 5 p2, q2, false, false p2, q3, false, false p3, q3, false, false p3, q2, false, false p5, q2, true, false p5, q3, true, false p2, q5, false, true p3, q5, false, true p5, q5, true, true no mutual exclusion ! 1 non-critical section 2 await wantq == false 3 wantp = true 4 critical section 5 wantp = false await wantp == false wantq = true wantq = false 13 p1 non-critical section p2 while(wantq); p3 wantp = true p4 critical section p5 wantp = false spcl.inf.ethz.ch @spcl_eth Process P local variables loop p1 non-critical section p2 wantp = true p3 while(wantq); p4 critical section p5 wantp = false Mutual exclusion for 2 processes -- 2nd Try Process Q local variables loop q1 non-critical section q2 wantq = true q3 while(wantp): q4 critical section q5 wantq = false volatile boolean wantp=false, wantq=false Do you see the problem? 14 spcl.inf.ethz.ch @spcl_eth State space diagram [p, q, wantp, wantq] p2, q2, false, false p2, q3, false, true p3, q3, true, true p3, q2, true, false p5, q2, true, false p5, q3, true, true p2, q5, false, true p3, q5, true, true deadlock ! 15 1 non-critical section 2 wantp = true 3 while(wantp) 4 critical section 5 wantp = false wantq = true while(wantq) wantq = false spcl.inf.ethz.ch @spcl_eth Process P local variables loop p1 non-critical section p2 while(turn != 1); p3 critical section p4 turn = 2 Mutual exclusion for 2 processes -- 3rd Try Process Q local variables loop q1 non-critical section q2 while(turn != 2); q3 critical section q4 turn = 1 volatile int turn = 1; 16 Do you see the problem? spcl.inf.ethz.ch @spcl_eth State space diagram [p, q, turn] p2, q2, 1 p2, q2, 2 p4, q2, 1 p2, q4, 2 starvation! We have not made any assumptions about progress outside of the CS... 17 spcl.inf.ethz.ch @spcl_eth Process P loop non-critical section wantp = true while (wantq) { if (turn == 2) { wantp = false; while(turn != 1); wantp = true; }} critical section turn = 2 wantp = false A combination of the tries 2 and 3: Decker’s Algorithm Process Q loop non-critical section wantq = true while (wantp) { if (turn == 1) { wantq = false while(turn != 2); wantq = true; }} critical section turn = 1 wantq = false volatile boolean wantp=false, wantq=false, integer turn= 1 only when q tries to get lock and q has preference let q proceed and wait and try again 18 spcl.inf.ethz.ch @spcl_eth Process P (1) loop non-critical section flag[P] = true victim = P while(flag[Q] && victim == P); critical section flag[P] = false More concise than Decker: Peterson Lock Process Q (2) loop non-critical section flag[Q] = true victim = Q while(flag[P] && victim == Q); critical section flag[Q] = false let P=1, Q=2; volatile boolean array flag[1..2] = [false, false]; volatile integer victim = 1 I am interested but you go first We both are interested And you go first 19 spcl.inf.ethz.ch @spcl_eth that the Peterson Lock satisfies mutual exclusion and that it is starvation free How? Requires some notation first. We want to prove ... 20 spcl.inf.ethz.ch @spcl_eth Threads produce a sequence of events P produces events 𝒑𝟎, 𝒑𝟏, … e.g., 𝑝1 = \"flag[P] = true\" j-th occurence of event i in thread P: 𝒑𝒊 𝒋 e.g., 𝑝5 3 = \"flag[P] = false\" in the third iteration Precedence relation: we write 𝒂 → 𝒃 when a occurs before b. Note that the precedence relation \"→\" is a total order for intra-thread events. Events and precedence programs usually consist of loops, therefore we might need to count occurences 21 spcl.inf.ethz.ch @spcl_eth 𝑎0, 𝑎1 : interval of events 𝑎0, 𝑎1 with 𝑎0 → 𝑎1 With 𝐼𝐴 = (𝑎0, 𝑎1) and 𝐼𝐵 = (𝑏0, 𝑏1) we write 𝑰𝑨 → 𝑰𝑩 if 𝒂𝟏 → 𝒃𝟎 we say \"𝐼𝐴 precedes 𝐼𝐵\" and \"𝐼𝐵′ and 𝐼𝐴′ are concurrent\" Intervals B time A 𝑎0 𝑎1 𝑏0 𝑏1 𝐼𝐴 𝐼𝐵 𝑎2 𝑎3𝐼𝐴′ 𝑏0 𝑏1𝐼𝐵′ 𝐼𝐴 → 𝐼𝐵 𝐼𝐵 → 𝐼𝐴′ 𝐼𝐵′ ↛ 𝐼𝐴′ 𝐼𝐴′ ↛ 𝐼𝐵′ 22 spcl.inf.ethz.ch @spcl_eth Register: basic memory object, can be shared or not i.e., in this context register ≠ register of a CPU Register r : operations r.read() and r.write(v) Atomic Register: ▪ An invocation J of r.read or r.write takes effect at a single point 𝝉(𝑱) in time ▪ 𝝉(𝑱) always lies between start and end of the operation J ▪ Two operations J and K on the same register always have a different effect time 𝝉(𝑱) ≠ 𝝉(𝑲) ▪ An invocation J of r.read() returns the value v written by the invocation K of r.write(v) with closest preceding effect time 𝝉(𝑲) Atomic register 23 spcl.inf.ethz.ch @spcl_eth Example A r.read() B r.write(4) time r.write(8) r.read() C r.write(1) r.read() 𝝉 𝑱 𝝉 𝑲 𝝉 𝑴 𝝉 𝑵 𝝉 𝑳 𝝉 𝑶 K M J L N O→1 →8 →4 24 spcl.inf.ethz.ch @spcl_eth Assumptions for Atomic Registers justify to treat operations on them as events taking place at a single point in time. We will use this in the following proofs. Note that even with atomic registers there can still be non-determinism of programs because nothing is said about the order of effect times for concurrent operations. Atomic register 25 spcl.inf.ethz.ch @spcl_eth By contradiction: assume concurrent CSP and CSQ [A] Assume without loss of generality: WQ(victim=Q) → WP(victim=P) [B] From the code: WP(flag[P]=true) → WP(victim = P) → RP(flag[Q]) → RP(victim) → CSP WQ(flag[Q]=true) → WQ(victim = Q) → RQ(flag[P]) → RQ(victim) → CSQ Proof: Mutual exclusion (Peterson) B ⇒ must read P [C]A + C ⇒ must read false Thread P writes register P Thread Q reads register P transitivity of \"→ \" ⇒ must read true  26 flag[P] = true victim = P while (flag[Q] && victim == P){} CSP flag[P] = false spcl.inf.ethz.ch @spcl_eth By (exhaustive) contradition Assume without loss of generality that P runs forever in its lock loop, waiting until flag[Q]==false or victim != P. Possibilities for Q: stuck in nonCS ⇒ flag[Q] = false and P can continue. Contradiction. repeatedly entering and leaving its CS ⇒ sets victim to Q when entering. Now victim cannot be changed ⇒ P can continue. Contradiction. stuck in its lock loop waiting until flag[P]==false or victim != Q. But victim == P and victim == Q cannot hold at the same time. Contradiction. Proof: Freedom from starvation flag[P] = true victim = P while (flag[Q] && victim == P){} CSP flag[P] = false 27 spcl.inf.ethz.ch @spcl_eth class PetersonLock { volatile boolean flag[] = new boolean[2]; volatile int victim; public void Acquire(int id) { flag[id] = true; victim = id; while (flag[1-id] && victim == id); } public void Release(int id) { flag[id] = false; } } Peterson in Java Volatile reference to an array and not an array of volatile variables! This example may work in practice. However, for a correct program we need to use to use Java’s AtomicInteger and AtomicIntegerArray. 28 spcl.inf.ethz.ch @spcl_eth Extension of Peterson's lock to n processes Every thread t knows its level in the filter level[t] In order to enter CS, a thread has to go through all levels. For each level, we use Peterson’s mechanism to filter at most one thread, if other threads are at higher level. In other words, for every level l there is one victim victim[l] that has to let others pass in case of conflicts. 29 The Filter Lock spcl.inf.ethz.ch @spcl_eth int[] level(#threads), int[] victim(#threads) lock (me) { for (int i=1; i<n; ++i) { level[me] = i; victim[i] = me; while (∃k ≠ me: level[k] >= i && victim[i] == me) {}; } } unlock(me) { level[me] = 0; } 30 The Filter Lock Other threads are at same or higher level And I have to wait non-CS with n threads n-1 threads n-2 threads 2 threads CS ... 1 2 n 0 spcl.inf.ethz.ch @spcl_eth import java.util.concurrent.atomic.AtomicIntegerArray; class FilterLock{ AtomicIntegerArray level; AtomicIntegerArray victim; volatile int n; FilterLock(int n) { this.n = n; level = new AtomicIntegerArray(n); victim = new AtomicIntegerArray(n); } ... 31 FilterLock in Java spcl.inf.ethz.ch @spcl_eth ... // ∃k ≠ me: level[k] >= i (lev) boolean Others(int me, int lev) { for (int k = 0; k < n; ++k) if (k != me && level.get(k) >= lev) return true; return false; } public void Acquire(int me) { for (int lev = 1; lev < n; ++lev) { level.set(me, lev); victim.set(lev, me); while(me == victim.get(lev) && Others(me,lev)); } } public void Release(int me) { level.set(me, 0); } } 32 FilterLock in Java Again: I (as a thread) can make progress if (a) Another thread wants to enter my level or (b) No more threads are in front of me This works because there are at most n threads in the system. spcl.inf.ethz.ch @spcl_eth Divide lock implementation (preprotocol) into two parts ▪ doorway interval 𝐷: finite number of steps ▪ waiting interval 𝑊: unbounded number of steps A lock algorithm is first-come-first-served when for two processes A and B it holds that If 𝐷𝐴 𝑗 → 𝐷𝐵 𝑘 then 𝐶𝑆𝐴 𝑗 → 𝐶𝑆𝐵 𝑘 33 Fairness spcl.inf.ethz.ch @spcl_eth satisfies mutual exclusion is deadlock free (how to prove?) is starvation free (how to prove?) but: is it also fair? no: the filter lock is not first-come-first-serve What else is bad about this lock? 34 The Filter Lock non-CS with n threads n-1 threads n-2 threads 2 threads CS ... 1 2 n 0 spcl.inf.ethz.ch @spcl_eth Question: ▪ Is it possible to construct mutual exclusion with non-atomic registers? Surprisingly: yes ▪ It is possible with registers fulfilling the weakest possible conditions that appear to be still useful in a concurrent setup. 35 A small detour: Safe and Regular Registers spcl.inf.ethz.ch @spcl_eth Register r: basic memory object, can be shared or not, operations r.read() and r.write(v). SWMR (Single Writer Multiple Reader): only one concurrent write but multiple concurrent reads allowed. Safe Register ▪ any read not concurrent with a write returns the current value of r ▪ any read concurrent with a write can return any value (of the domain of r) if any read concurrent with writes can only return a value of one of the values (previous, new) then the register is called regular 36 Safe Single Writer Multiple Reader Register The notion \"safe\" is historically motivated but actually misleading. spcl.inf.ethz.ch @spcl_eth 37 Example A r.read() B r.write(4) time r.read() C r.write(1) r.read() →1 →any value! →4 r.read() →1 spcl.inf.ethz.ch @spcl_eth A process is required to take a numbered ticket with value greater than all outstanding tickets CS Entry: Wait until ticket number is lowest 38 Mutual Exclusion for n processes: Bakery Algorithm (1974) Lamport, Turing award 2013 spcl.inf.ethz.ch @spcl_eth Process P loop non-critical section np = nq + 1 while (nq != 0 && nq < np); critical section np = 0 39 Bakery algorithm (two processes, simplified) Process Q loop non-critical section nq = np + 1 while (np != 0 && np <= nq); critical section nq = 0 volatile int np = 0, nq = 0 np == nq can happen ➔ global ordering of processes Q also wants access and Q has an earlier ticket spcl.inf.ethz.ch @spcl_eth lock(me): flag[me] = true; label[me] = max(label[0], ... , label[n-1]) + 1; while (∃k ≠ me: flag[k] && (k,label[k]) <l (me,label[me])) {}; unlock(me): flag[me] = false; 40 Bakery algorithm (n processes) integer array[0..n-1] label = [0, ..., 0] boolean array[0..n-1] flag = [false, ..., false] 𝑘, 𝑙𝑘 <l 𝑗, 𝑙𝑗 ⇔ 𝑙𝑘 < 𝑙𝑗 or (𝑙𝑘 = 𝑙𝑗 and 𝑘 < 𝑗) SWMR «I want the lock» SWMR «ticket number» spcl.inf.ethz.ch @spcl_eth class BakeryLock { AtomicIntegerArray flag; // there is no AtomicBooleanArray AtomicIntegerArray label; final int n; BakeryLock(int n) { this.n = n; flag = new AtomicIntegerArray(n); label = new AtomicIntegerArray(n); } int MaxLabel() { int max = label.get(0); for (int i = 1; i<n; ++i) max = Math.max(max, label.get(i)); return max; } ... 41 Bakery Lock in Java boolean Conflict(int me) { for (int i = 0; i < n; ++i) if (i != me && flag.get(i) != 0) { int diff = label.get(i) - label.get(me); if (diff < 0 || diff == 0 && i < me) return true; } return false; } public void Acquire(int me) { flag.set(me,1); label.set(me, MaxLabel() + 1); while(Conflict(me)); } public void Release(int me) { flag.set(me, 0); } }","libVersion":"0.3.2","langs":""}