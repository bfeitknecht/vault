{"path":"sem3/A&D/UE/e/A&D-e-u07.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 4 November 2024 Johannes Lengler, David Steurer Kasper Lindberg, Lucas Slot, Hongjie Chen, Manuel Wiedmer Algorithms & Data Structures Exercise sheet 7 HS 24 The solutions for this sheet are submitted on Moodle until 10 November 2024, 23:59. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. Exercise 7.1 Subset sums with duplicates (1 point). Let A[1 . . . n] be an array containing n positive integers and let b ∈ N. We want to know if we can write b as a subset sum of A where each element of A is allowed to be used once, twice or not at all. If this is possible, we say b is a subset sum of A with duplicates. For example, consider A = [3, 4, 2, 7] and b = 22. Then b is a subset sum of A with duplicates, as we can use 3 not at all, use 4 once, and use 2 and 7 twice. In other words, we can write b as 0 · A[1] + 1 · A[2] + 2 · A[3] + 2 · A[4]. Describe a DP algorithm that, given an array A[1 . . . n] of positive integers and a positive integer b, returns True if and only if b is a subset sum of A with duplicates. Your algorithm should have asymptotic runtime complexity at most O(b · n). In your solution, address the following aspects: 1. Dimensions of the DP table: What are the dimensions of the DP table? 2. Subproblems: What is the meaning of each entry? 3. Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others. 4. Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps? 5. Extracting the solution: How can the solution be extracted once the table has been filled? 6. Running time: What is the running time of your solution? Exercise 7.2 Road trip. You are planning a road trip for your summer holidays. You want to start from city C0, and follow the only road that goes to city Cn from there. On this road from C0 to Cn, there are n − 1 other cities C1, . . . , Cn−1 that you would be interested in visiting (all cities C1, . . . , Cn−1 are on the road from C0 to Cn). For each 0 ≤ i ≤ n, the city Ci is at kilometer ki of the road for some given 0 = k0 < k1 < . . . < kn−1 < kn. You want to decide in which cities among C1, . . . , Cn−1 you will make an additional stop (you will stop in C0 and Cn anyway). However, you do not want to drive more than d kilometers without making a stop in some city, for some given value d > 0 (we assume that ki < ki−1 + d for all i ∈ [n] so that this is satisfiable), and you also don’t want to travel backwards (so from some city Ci you can only go forward to cities Cj with j > i). (a) Provide a dynamic programming algorithm that computes the number of possible routes from C0 to Cn that satisfy these conditions, i.e., the number of allowed subsets of stop-cities. Your algorithm should have O(n2) runtime. In your solution, address the following aspects: 1. Dimensions of the DP table: What are the dimensions of the DP table? 2. Subproblems: What is the meaning of each entry? 3. Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others. 4. Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps? 5. Extracting the solution: How can the solution be extracted once the table has been filled? 6. Running time: What is the running time of your solution? (b) If you know that ki > ki−1 + d/10 for every i ∈ [n], how can you turn the above algorithm into a linear time algorithm (i.e., an algorithm that has O(n) runtime) ? Exercise 7.3 Safe pawn lines. On an N × M chessboard (N being the number of rows and M the number of columns), a safe pawn line is a set of M pawns with exactly one pawn per column of the chessboard, and such that every two pawns from adjacent columns are located diagonally to each other. When a pawn line is not safe, it is called unsafe. The first two chessboards below show safe pawn lines, the latter two unsafe ones. The line on the third chessboard is unsafe because pawns d4 and e4 are located on the same row (rather than diagonally); the line on the fourth chessboard is unsafe because pawn a5 has no diagonal neighbor at all. 6 0Z0Z0Z 5 Z0Z0Z0 4 0Z0o0Z 3 o0o0o0 2 0o0Z0o 1 Z0Z0Z0 a b c d e f 4 pZp 3 ZpZ 2 0Z0 1 Z0Z a b c 4 0Z0opZ 3 Z0o0Zp 2 0o0Z0Z 1 o0Z0Z0 a b c d e f 5 o0Z0Z 4 0Z0o0 3 Z0o0o 2 0o0Z0 1 Z0Z0Z a b c d e Describe a DP algorithm that, given N, M > 0, counts the number of safe pawn lines on an N × M chessboard. Your solution should have complexity at most O(N M ). In your solution, address the following aspects: 2 1. Dimensions of the DP table: What are the dimensions of the DP table? 2. Subproblems: What is the meaning of each entry? 3. Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others. 4. Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps? 5. Extracting the solution: How can the solution be extracted once the table has been filled? 6. Running time: What is the running time of your solution? Exercise 7.4 Weight and volume knapsack (1 point). Consider a knapsack problem with n items with profits being positive integers in the array P [1, . . . , n], and weights being positive integer in the array W [1, . . . , n]. The knapsack has a weight limit Wmax ∈ N. Furthermore, each item has a volume of 1 and the knapsack has a volume limit Vmax. Describe a DP algorithm that, given the arrays P [1, . . . , n], W [1, . . . , n], of positive integers and pos- itive integers Wmax, Vmax, returns the total profit of the largest subset of items such that the items respect both the weight limit and volume limit of Wmax and Vmax. Your algorithm should have asymp- totic runtime complexity at most O(n · Wmax · Vmax). In your solution, address the following aspects: 1. Dimensions of the DP table: What are the dimensions of the DP table? 2. Subproblems: What is the meaning of each entry? 3. Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others. 4. Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps? 5. Extracting the solution: How can the solution be extracted once the table has been filled? 6. Running time: What is the running time of your solution? Exercise 7.5 Zebra arrays (1 point). A square two-dimensional array Z[1 . . . k][1 . . . k] with entries in {0, 1} is called a zebra array if no two adjacent entries of Z are equal. We say two distinct entries Z[i1][j1] and Z[i2][j2] in Z are adjacent if • i1 = i2 and |j1 − j2| ≤ 1; or • |i1 − i2| ≤ 1 and j1 = j2. Describe a DP algorithm that, given a two-dimensional array A[1 . . . n][1 . . . m] with entries in {0, 1}, outputs the size of a largest zebra array contained in A. That is, the largest k such that, for some 1 ≤ i ≤ n − k + 1, 1 ≤ j ≤ m − k + 1, the array A[i . . . i + k − 1][j . . . j + k − 1] is a zebra array. Your algorithm should have asymptotic runtime complexity at most O(nm). 3 In your solution, address the following aspects: 1. Dimensions of the DP table: What are the dimensions of the DP table? 2. Subproblems: What is the meaning of each entry? 3. Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others. 4. Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps? 5. Extracting the solution: How can the solution be extracted once the table has been filled? 6. Running time: What is the running time of your solution? Hint: U se a DP table B[1 . . . n][1 . . . m]. The meaning of entry B[i][j] is B[i][j] = size of the largest zebra array in A whose bottom-right entry is A[i][j]. Hint: Y our recursion to compute B[i][j] should involve the entries B[i][j −1], B[i−1][j], B[i−1][j −1] and also the entries A[i][j], A[i][j − 1], A[i − 1][j], A[i − 1][j − 1]. 4","libVersion":"0.5.0","langs":""}