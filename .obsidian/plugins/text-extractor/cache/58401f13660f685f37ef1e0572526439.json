{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s04-adt.pdf","text":"Algebraic Data Types David Basin Department of Computer Science ETH Z¨urich Functional Programming David Basin 1 The problem • Until now, data modeling with Base types: Int, Bool, Char, Double, . . . Compound types: tuples, lists, functions, . . . Type synonyms: type Complex = (Double,Double) • Example: modeling dates, e.g., months \u0011 Using strings: \"January\", \"February\", . . . , \"December\" \u0011 Using integers: 1, 2, . . . , 12 • Many possibilities (like in assembler). Not particularly abstract. \u0011 Also error-prone. What does 0 represent? Or 1 + 2? \u0011 Analogous to problem of modeling years. Functional Programming Spring Semester, 2025 David Basin 2 Another example: modeling trees 1 10 17 14 20 • Assembler or C: model using pointers • Alternative: model using functions \u0011 Tree addresses (position) as path address [ ], [1], [2, 1, 2], . . . \u0011 Function application produces value associated with node f [ ] = 1, f [1] = 10, f [2] = 17, f [2, 1] = 14, f [2, 2] = 20 • Data type is a derived notion, not first-class \u0011 Low-level coding \u0011 Can be improperly used Functional Programming Spring Semester, 2025 David Basin 3 Solution: algebraic data types • Declare new types tailored to the objects being modeled. • For months, we declare the type Month with elements January, February, ..., December These are new data constructors. • For trees, declare type Tree with elements like Node 1 (Node 10 Leaf Leaf) (Node 17 (Node 14 Leaf Leaf) (Node 20 Leaf Leaf)) 1 10 17 14 20 Functional Programming Spring Semester, 2025 David Basin 4 Enumeration types (disjoint unions) data Season = Spring | Summer | Fall | Winter data Month = January | February | March | April | May | June | July | August | September | October | November | December • Syntax \u0011 Starts with keyword data \u0011 Names different (uniquely named) constructors \u0011 First letter of each constructor must be upper-case • Defines a set: Season = {Spring, Summer, Fall, Winter} • Functions can be written using pattern matching whichSeason :: Month -> Season whichSeason January = Winter whichSeason February = Winter whichSeason March = Spring ... Functional Programming Spring Semester, 2025 David Basin 5 Product types data People = Person Name Age type Name = String type Age = Int • An element of type People consists of a name n and an age a, e.g., Person \"Uncle George\" 85 Person \"Levi Jeans\" 501 -- Nonsense but type correct • Constructors are functions ? :type Person Person :: Name -> Age -> People • Functions may be defined by pattern matching showPerson :: People -> String showPerson (Person n a) = n ++ \" who is \" ++ show a ++ \" years old\" ? showPerson (Person \"Uncle George\" 85) \"Uncle George who is 85 years old\" :: [Char] Functional Programming Spring Semester, 2025 David Basin 6 Product types versus tuples • Alternative to products are tuples data People = Person Name Age type People’ = (Name, Age) • Advantage of product types \u0011 Conceptual: new, self-contained type \u0011 Objects are labeled and hence types are unambiguous • Disadvantages \u0011 Longer definitions \u0011 Many polymorphic functions no longer applicable (fst, zip, . . . ) Functional Programming Spring Semester, 2025 David Basin 7 Enumeration and product types • They can be combined data Shape = Circle Double | Rectangle Double Double • Two kinds of shapes \u0011 Circle with radius, e.g. Circle 3.0 \u0011 Rectangle with two sides, e.g. Rectangle 45.9 87.6 • Functions again definable by pattern matching area :: Shape -> Double area (Circle r) = pi * r * r area (Rectangle h w) = h * w Functional Programming Spring Semester, 2025 David Basin 8 Integration with classes • No default functions like == or show data Foo = D1 | D2 | D3 ? D1 == D2 ERROR: No instance for (Eq Foo) • Class instances can be explicitly created instance Eq Foo where D1 == D1 = True D2 == D2 = True D3 == D3 = True _ == _ = False ? D1 == D2 False :: Bool Functional Programming Spring Semester, 2025 David Basin 9 Integration with classes (cont.) • In some cases, class instances can be automatically derived data Foo = D1 | D2 | D3 deriving (Eq, Ord, Enum, Show) ? D1 D1 :: Foo ? [D1 .. D3] [D1, D2, D3] :: [Foo] ? D2 < D3 True :: Bool See “Haskell Report” for further details Functional Programming Spring Semester, 2025 David Basin 10 General definition • Previous examples: enumeration (or “sum”) of products data Shape = Circle Double | Rectangle Double Double • General case data T = Constr1 T11 . . . T1k1 | Constr2 T21 . . . T2k2 ... | Constrn Tn1 . . . Tnkn \u0011 Tij are types, possibly also containing T (i.e., recursion allowed) \u0011 T can have type variables as arguments (polymorphism) Let’s look more closely at these extensions Functional Programming Spring Semester, 2025 David Basin 11 Recursive types • Sets of objects are often recursively defined Expr ::= Int | Expr + Expr | Expr − Expr • Formalized as a recursive data type data Expr = Lit Int | Add Expr Expr | Sub Expr Expr • Bijection between elements of Expr and data-type elements 2 Lit 2 2 + 3 Add (Lit 2) (Lit 3) 2 + (3 − 1) Add (Lit 2) (Sub (Lit 3) (Lit 1)) • Recursion: Expr is recursive. Hence so are functions over Expr Functional Programming Spring Semester, 2025 David Basin 12 Recursive functions over data types • Example: Interpreter for arithmetic expressions data Expr = Lit Int | Add Expr Expr | Sub Expr Expr deriving (Show, Eq) • Evaluator Lit n: n Add e1 e2: value of e1 + value of e2 Sub e1 e2: value of e1 − value of e2 • Program eval :: Expr -> Int eval (Lit n) = n eval (Add e1 e2) = (eval e1) + (eval e2) eval (Sub e1 e2) = (eval e1) - (eval e2) Functional Programming Spring Semester, 2025 David Basin 13 Arithmetic expressions (cont.) • Other functions are written similarly showExpr (Lit n) = show n showExpr (Add e1 e2) = \"(\"++showExpr e1++\"+\"++showExpr e2 ++\")\" showExpr (Sub e1 e2) = \"(\"++showExpr e1++\"-\"++showExpr e2 ++\")\" ? eval (Add (Lit 2) (Sub (Lit 3) (Lit 1))) -- 2 + (3 - 1) 4 :: Int ? show (Add (Lit 2) (Sub (Lit 3) (Lit 1))) \"Add (Lit 2) (Sub (Lit 3) (Lit 1))\" :: [Char] ? showExpr (Add (Lit 2) (Sub (Lit 3) (Lit 1))) \"(2+(3-1))\" :: [Char] Functional Programming Spring Semester, 2025 David Basin 14 Trees (with internal integer nodes) 1 10 17 14 20 • Grammar ITree ::= Leaf | Node Int ITree ITree • Haskell data type data ITree = Leaf | Node Int ITree ITree deriving (Eq, Show) • Example tree t Node 1 (Node 10 Leaf Leaf) (Node 17 (Node 14 Leaf Leaf) (Node 20 Leaf Leaf)) Functional Programming Spring Semester, 2025 David Basin 15 Functions over trees 1 10 17 14 20 • Sum of values treeSum t = 62 treeSum :: ITree -> Int treeSum Leaf = 0 treeSum (Node n t1 t2) = n + (treeSum t1) + (treeSum t2) • Depth depth t = 3 depth :: ITree -> Int depth Leaf = 0 depth (Node n t1 t2) = 1 + max (depth t1) (depth t2) • How often does an element occur? occurs t 10 = 1 occurs :: ITree -> Int -> Int occurs Leaf p = 0 occurs (Node n t1 t2) p | n == p = 1 + rest | otherwise = rest where rest = occurs t1 p + occurs t2 p Functional Programming Spring Semester, 2025 David Basin 16 Polymorphic algebraic types • Examples have monomorphic types data ITree = Leaf | Node Int ITree ITree In general, types may include type variables • Example: data Pair t = MkPair t t has elements like: MkPair 2 3 :: Pair Int MkPair [] [2,3] :: Pair [Int] MkPair [] [] :: Pair [t] • Functions can now also be polymorphic equalPair :: Eq t => Pair t -> Bool equalPair (MkPair x y) = (x == y) Functional Programming Spring Semester, 2025 David Basin 17 Trees • Definition with type parameters data Tree t = Leaf | Node t (Tree t) (Tree t) deriving (Eq, Ord, Show) ? Node 2 Leaf Leaf Node 2 Leaf Leaf :: Tree Int ? Node True (Node False Leaf Leaf) (Node True Leaf Leaf) Node True (Node False Leaf Leaf) (Node True Leaf Leaf) :: Tree Bool • Same definitions. Now types are more general occurs :: Eq t => Tree t -> t -> Int occurs Leaf p = 0 occurs (Node n t1 t2) p | n == p = 1 + rest | otherwise = rest where rest = occurs t1 p + occurs t2 p Functional Programming Spring Semester, 2025 David Basin 18 Polymorphic algebraic types — questions • Have you seen this type before? data L t = E | C t (L t) deriving (Eq, Ord, Show) • Observe that E :: L t C :: t -> L t -> L t • What is the type of the following function? f y E = False f y (C x l) = x == y || f y l • What is the result? ? f 3 (C 2 (C 3 (C 4 E))) Functional Programming Spring Semester, 2025 David Basin 19 Algebraic data types from the Prelude Standard types are defined as algebraic data types • Booleans are an enumeration data Bool = False | True deriving (Eq, Ord, Enum, Read, Show, Bounded) • Lists data [a] = [] | a : [a] deriving (Eq, Ord) • Optional values data Maybe a = Nothing | Just a deriving (Eq, Ord, Read, Show) • Disjoint union type data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) Functional Programming Spring Semester, 2025 David Basin 20 Higher-order programming with data types • You have done this already! For example, map for lists map f E = E --- E = [] map f (C x xs) = C (f x) (map f xs) --- C = (:) • Analogous program on trees mapTree :: (t -> u) -> Tree t -> Tree u mapTree f Leaf = Leaf mapTree f (Node x t1 t2) = Node (f x) (mapTree f t1) (mapTree f t2) ? mapTree (+2) (Node 7 (Node 20 Leaf Leaf) (Node 1 Leaf Leaf)) Node 9 (Node 22 Leaf Leaf) (Node 3 Leaf Leaf) :: Tree Int ? mapTree not (Node True (Node False Leaf Leaf) (Node True Leaf Leaf)) Node False (Node True Leaf Leaf) (Node False Leaf Leaf) :: Tree Bool Functional Programming Spring Semester, 2025 David Basin 21 From foldr to treeFold • Recall foldr foldr :: (a -> b -> b) -> b -> [a] -> b foldr f e E = e --- E = [] foldr f e (C x xs) = f x (foldr f e xs) --- C = (:) • Procedure for foldr f e l In the list l, C is replaced with f and E with e • Procedure for treeFold f e t In the tree t, Node is replaced with f and Leaf with e • Definition treeFold:: (a -> b -> b -> b) -> b -> Tree a -> b treeFold f e Leaf = e treeFold f e (Node x l r) = f x (treeFold f e l) (treeFold f e r) Functional Programming Spring Semester, 2025 David Basin 22 What is computed? 1 10 17 14 20 t = Node 1 (Node 10 Leaf Leaf) (Node 17 (Node 14 Leaf Leaf) (Node 20 Leaf Leaf)) ? treeFold (\\x l r -> x + l + r) 0 t 62 :: Int ? treeFold (\\_ l r -> 1 + l + r) 0 t 5 :: Int ? treeFold (\\_ l r -> 1 + max l r) 0 t 3 :: Int ? treeFold (\\x l r -> Node x r l) Leaf t Node 1 (Node 17 (Node 20 Leaf Leaf) (Node 14 Leaf Leaf)) (Node 10 Leaf Leaf) :: Tree Int Functional Programming Spring Semester, 2025 David Basin 23 From trees to lists 1 10 17 14 20 t = Node 1 (Node 10 Leaf Leaf) (Node 17 (Node 14 Leaf Leaf) (Node 20 Leaf Leaf)) preorder t = treeFold (\\x l r -> [x] ++ l ++ r) [] t inorder t = treeFold (\\x l r -> l ++ [x] ++ r) [] t postorder t = treeFold (\\x l r -> l ++ r ++ [x]) [] t ? preorder t [1, 10, 17, 14, 20] :: [Int] ? inorder t [10, 1, 14, 17, 20] :: [Int] ? postorder t [10, 14, 20, 17, 1] :: [Int] Functional Programming Spring Semester, 2025 David Basin 24 treeFold is not Foldable • Compare the types! class Foldable t where foldr :: (a -> b -> b) -> b -> t a -> b treeFold :: (a -> b -> b -> b) -> b -> Tree a -> b • treeFold passes the tree structure to its parameter • Foldable hides the internal structure \u0011 foldr is more like iterating over a container instance Foldable Tree where foldr f z t = foldr f z (inorder t) -- also possible with preorder / postorder • Exercise: Define a Foldable Tree instance directly! Functional Programming Spring Semester, 2025 David Basin 25 Case study: editing distance • Motivation: compute the minimal number of changes needed to transform one string into another \u0011 Practical problem, e.g., updating display \u0011 “diff” programs • Goal: find “cheapest” sequence of editing steps using operations Change a character Copy a character without change Delete a character Insert a character Assume unit price for all operations except copy, which is for free. Functional Programming Spring Semester, 2025 David Basin 26 Example: “Help” is not far from “Hello” ? transform \"help\" \"hello\" [Copy, Copy, Copy, Insert ’l’, Change ’o’] ? transform \"hello\" \"help\" [Copy, Copy, Copy, Delete, Change ’p’] In both cases, the cost is 2 Functional Programming Spring Semester, 2025 David Basin 27 Development #1: data types 1. Identify types, e.g., for editing data Edit = ... 2. Identify kinds of data Each corresponds to a constructor data Edit = Change ... | Copy ... | Delete ... | Insert ... 3. Fix the components (arguments) data Edit = Change Char | Copy | Delete | Insert Char deriving (Eq, Show) Functional Programming Spring Semester, 2025 David Basin 28 Development #2: functions • Main function: carry out transformation transform :: String -> String -> [Edit] • Base cases transform [] [] = [] transform xs [] = map (\\_ -> Delete) xs transform [] ys = map Insert ys • General case: choose between the operations transform (x:xs) (y:ys) | x == y = Copy : transform xs ys | otherwise = best [ Delete : transform xs (y:ys) , Insert y : transform (x:xs) ys , Change y : transform xs ys ] Functional Programming Spring Semester, 2025 David Basin 29 Development (cont.) • Define the auxiliary function best best :: [[Edit]] -> [Edit] best [x] = x best (x:xs) | cost x <= cost x’ = x | otherwise = x’ where x’ = best xs • Formalize unit price for all operations except copy cost :: [Edit] -> Int cost = length . filter (/=Copy) Functional Programming Spring Semester, 2025 David Basin 30 The entire program data Edit = Change Char | Copy | Delete | Insert Char deriving (Eq,Show) transform [] [] = [] transform xs [] = map (\\_ -> Delete) xs transform [] ys = map Insert ys transform (x:xs) (y:ys) | x == y = Copy : transform xs ys | otherwise = best [ Delete : transform xs (y:ys) , Insert y : transform (x:xs) ys , Change y : transform xs ys ] best [x] = x best (x:xs) | cost x <= cost x’ = x | otherwise = x’ where x’ = best xs cost = length . filter (/=Copy) Functional Programming Spring Semester, 2025 David Basin 31 Transform — examples ? :set +s ? transform \"fish\" \"chips\" [Insert ’c’, Change ’h’, Copy, Insert ’p’, Copy, Delete] (0.02 secs, 3803456 bytes) ? transform \"1234\" \"4321\" [Delete, Change ’4’, Copy, Insert ’2’, Change ’1’] (0.01 secs, 3051880 bytes) ? transform \"123456\" \"654321\" [Delete, Change ’6’, Change ’5’, Copy, Insert ’3’, Change ’2’, Change ’1’] (0.04 secs, 5990368 bytes) ? transform \"12345678\" \"87654321\" [Delete, Change ’8’, Change ’7’, Change ’6’, Copy, Insert ’4’, Change ’3’, Change ’2’, Change ’1’] (1.00 secs, 84024700 bytes) Does transform always terminate? Run-time complexity? Functional Programming Spring Semester, 2025 David Basin 32 Algebraic types and type classes Goal: define hierarchy of movable objects Support standard objects like points, lines, ... and operations like reflection and (simple 180-degree) rotation. Functional Programming Spring Semester, 2025 David Basin 33 Algebraic types and type classes (cont.) data Vector = Vector Double Double -- x & y offset class Movable t where move :: Vector -> t -> t -- Translation reflectX :: t -> t -- Reflection reflectY :: t -> t rotate180 :: t -> t -- Rotation rotate180 = reflectX . reflectY Instance: point data Point = Pt Double Double deriving Show instance Movable Point where move (Vector v1 v2) (Pt c1 c2) = Pt (c1+v1) (c2+v2) reflectX (Pt c1 c2) = Pt c1 (-c2) reflectY (Pt c1 c2) = Pt (-c1) c2 rotate180 (Pt c1 c2) = Pt (-c1) (-c2) Functional Programming Spring Semester, 2025 David Basin 34 Types and classes (cont.) • Figures are also movable data Figure = Line Point Point | Circle Point Double deriving Show instance Movable Figure where move v (Line p1 p2) = Line (move v p1) (move v p2) move v (Circle p r) = Circle (move v p) r reflectX (Line p1 p2) = Line (reflectX p1) (reflectX p2) reflectX (Circle p r) = Circle (reflectX p) r reflectY (Line p1 p2) = Line (reflectY p1) (reflectY p2) reflectY (Circle p r) = Circle (reflectY p) r • Lists of movable objects are also movable instance Movable t => Movable [t] where move v = map (move v) reflectX = map reflectX reflectY = map reflectY Functional Programming Spring Semester, 2025 David Basin 35 Algebraic types and classes • Algebraic types are “first class” citizens Fully compatible with polymorphism and type classes • Programs are simple to read and understand only move rather than movePoint, etc. • Reusability Instance for Movable [t] is polymorphic with respect to lists of movable objects Functional Programming Spring Semester, 2025 David Basin 36 What actually are algebraic data types? data Tree a = Leaf | Node a (Tree a) (Tree a) • A data type defines a set of terms for each type instance E.g., Tree Int corresponds to {Leaf, Node 0 Leaf Leaf, . . . } • Algebraic here means the smallest set S, where Leaf ∈ S and x ∈ a ∧ t1 ∈ S ∧ t2 ∈ S ⇒ (Node x t1 t2) ∈ S • Intuition: set S is built in steps \u0011 Leaf ∈ S and \u0011 (Node x t1 t2) ∈ S, where t1 and t2 in S in earlier steps • What are sound reasoning principles for such types? Functional Programming Spring Semester, 2025 David Basin 37 Correctness for Algebraic Data Types Let’s start with some old friends Functional Programming Spring Semester, 2025 David Basin 38 Natural numbers • To prove: ∀n ∈ N . P Base case: Show P [n ↦→ 0]. Step case: Let m ∈ N be arbitrary (and not free in P ). Assume P [n ↦→ m]. Show P [n ↦→ m + 1]. • Alternative formulation as natural deduction proof rule Γ ⊢ P [n ↦→ 0] Γ, P [n ↦→ m] ⊢ P [n ↦→ m + 1] Γ ⊢ ∀n ∈ N . P m not free in Γ, P • ∀n ∈ N . P holds as P [n ↦→ 0], P [n ↦→ 1], P [n ↦→ 2], . . . Functional Programming Spring Semester, 2025 David Basin 39 Numbers as a data type data Nat = Zero | Succ Nat deriving (Eq, Ord, Show) plus Zero y = y plus (Succ x) y = Succ (plus x y) --- Normally built-in primitives --- that use machine arithmetic! times Zero _ = Zero times (Succ x) y = plus (times x y) y ? plus (Succ Zero) (Succ Zero) Succ (Succ Zero) ? times (Succ (Succ Zero)) (Succ (Succ Zero)) Succ (Succ (Succ (Succ Zero))) ? Succ Zero < Succ (Succ Zero) --- How does ghc compute this? True Functional Programming Spring Semester, 2025 David Basin 40 Induction over the natural numbers Zero Succ Zero Succ (Succ Zero). . . data Nat = Zero | Succ Nat • Natural numbers are (isomorphic to) the set Nat = {Zero, Succ Zero, Succ (Succ Zero), . . . } • Data type provides two rules for constructing members of Nat \u0011 Zero ∈ Nat \u0011 Succ x ∈ Nat, if x ∈ Nat • Elements added step by step Functional Programming Spring Semester, 2025 David Basin 41 Structural induction Zero Succ Zero Succ (Succ Zero). . . data Nat = Zero | Succ Nat • Induction over the structure of terms Equivalent to induction over the individual steps (also depth of terms) Γ ⊢ P [n ↦→ Zero] Γ, P [n ↦→ m] ⊢ P [n ↦→ Succ m] Γ ⊢ ∀n ∈ Nat. P m not free in Γ, P • Sufficient to show P [n ↦→ Zero], P [n ↦→ Succ Zero], . . . • We can prove theorems like ∀x ∈ Nat. plus x (plus y z) = plus (plus x y) z Functional Programming Spring Semester, 2025 David Basin 42 Lists data L t = Nil | Cons t (L t) • Elements in L t are built in steps 0) L0 = {Nil} 1) L1 = L0 ∪ {Cons a Nil | a ∈ t} ... i ) Li = Li−1 ∪ {Cons a l | a ∈ t ∧ l ∈ Li−1} • l ∈ L t iff l appears in some set Li of the construction • Induction Γ ⊢ P [xs ↦→ Nil] Γ, P [xs ↦→ ys] ⊢ P [xs ↦→ Cons y ys] Γ ⊢ ∀xs ∈ L t. P y, ys not free in Γ, P i.e., we must prove (i) P [xs ↦→ Nil] and (ii) P [xs ↦→ Cons y ys] follows from P [xs ↦→ ys], for arbitrary y ∈ t and ys ∈ L t. Functional Programming Spring Semester, 2025 David Basin 43 Trees data Tree t = Leaf | Node t (Tree t) (Tree t) • Steps for constructing Tree t 0) T0 = {Leaf} 1) T1 = T0 ∪ {Node a Leaf Leaf | a ∈ t} ... i ) Ti = Ti−1 ∪ {Node a l r | a ∈ t ∧ l ∈ Ti−1 ∧ r ∈ Ti−1} • s ∈ Tree t iff s appears in some set Ti of the construction • Induction Γ ⊢ P [x ↦→ Leaf] Γ, P [x ↦→ l], P [x ↦→ r] ⊢ P [x ↦→ Node a l r] Γ ⊢ ∀x ∈ Tree t. P a, l, r not free in Γ, P i.e., we must prove (i) P [x ↦→ Leaf] and (ii) P [x ↦→ Node a l r] follows from P [x ↦→ l] and P [x ↦→ r], for arbitrary a ∈ t and l, r ∈ Tree t. Functional Programming Spring Semester, 2025 David Basin 44 Example of induction on trees [] ++ ys = ys (x:xs) ++ ys = x:(xs ++ ys) map f [] = [] map f (a:l) = f a : map f l mapTree f Leaf = Leaf mapTree f (Node x t1 t2) = Node (f x) (mapTree f t1) (mapTree f t2) treeFold f e Leaf = e treeFold f e (Node x l r) = f x (treeFold f e l) (treeFold f e r) inorder t = treeFold (\\x l r -> l ++ [x] ++ r) [] t Does the following hold? ∀s ∈ Tree t. map f (inorder s) = inorder (mapTree f s) Functional Programming Spring Semester, 2025 David Basin 45 Auxiliary propositions Lemma 1. inorder Leaf = [ ] inorder Leaf = treeFold (λx l r. l ++ [x] ++ r) [ ] Leaf = [ ] Lemma 2. inorder (Node a l r) = inorder l ++ [a] ++ inorder r Let f = λx l r. l ++ [x] ++ r. Then inorder (Node a l r) = treeFold f [ ] (Node a l r) = f a (treeFold f [ ] l) (treeFold f [ ] r) = (treeFold f [ ] l) ++ [a] ++ (treeFold f [ ] r) = inorder l ++ [a] ++ inorder r Functional Programming Spring Semester, 2025 David Basin 46 Auxiliary propositions (cont.) Lemma 3. map f (l ++ r) = (map f l) ++ (map f r) Proof: Let P ≡ map f (l ++ r) = (map f l) ++ (map f r). We show ∀l ∈ [a]. P by induction. Base case: Show P [l ↦→ [ ]]. map f ([ ] ++ r) = map f r = [ ] ++ (map f r) = (map f [ ]) ++ (map f r) Step case: Let y ∈ a and ys ∈ [a] be arbitrary. Assume P [l ↦→ ys]. Show P [l ↦→ y : ys]. map f ((y : ys) ++ r) = map f (y : (ys ++ r)) = f y : map f (ys ++ r) = f y : ((map f ys) ++ (map f r)) = (f y : map f ys) ++ (map f r) = (map f (y : ys)) ++ (map f r) Functional Programming Spring Semester, 2025 David Basin 47 Correctness proof Lemma: ∀s ∈ Tree t. map f (inorder s) = inorder (mapTree f s) Proof: Let P ≡ map f (inorder s) = inorder (mapTree f s). We show ∀s ∈ Tree t. P by induction. Base case: Show P [s ↦→ Leaf]. map f (inorder Leaf) = map f [ ] = [ ] = inorder Leaf = inorder (mapTree f Leaf) Step case: Let a ∈ t and l, r ∈ Tree t be arbitrary. Assume P [s ↦→ l] and P [s ↦→ r]. Show P [s ↦→ Node a l r]. map f (inorder (Node a l r)) = map f (inorder l ++ [a] ++ inorder r) = (map f (inorder l)) ++ (map f [a]) ++ (map f (inorder r)) = (map f (inorder l)) ++ [f a] ++ (map f (inorder r)) = (inorder (mapTree f l)) ++ [f a] ++ (inorder (mapTree f r)) = inorder (Node (f a) (mapTree f l) (mapTree f r)) = inorder (mapTree f (Node a l r)) Functional Programming Spring Semester, 2025 David Basin 48 Structural induction — general idea • Induction based on structure of terms data T t = Leaf t | Node1 (T t) | Node2 t (T t) (T t) • What are the terms in Step 0? T0 = {Leaf a | a ∈ t} • How do we go from step i − 1 to step i? Ti = Ti−1 ∪ {Node1 s | s ∈ Ti−1} ∪ {Node2 a l r | a ∈ t and l, r ∈ Ti−1} • Formalized as induction rule Γ ⊢ P [x ↦→ Leaf a] Γ, P [x ↦→ s] ⊢ P [x ↦→ Node1 s] Γ, P [x ↦→ l], P [x ↦→ r] ⊢ P [x ↦→ Node2 a l r] Γ ⊢ ∀x ∈ T t. P (∗) (*) a, l, r, s not free in Γ, P Functional Programming Spring Semester, 2025 David Basin 49 Conclusion — algebraic types • Algebraic types provide new possibilities for modeling \u0011 No ambiguity: is 11 a number or November? \u0011 Terms directly model objects • General recursive types combine enumeration and product types • Lists as example \u0011 Recursive and polymorphic \u0011 Many specialized functions can be written using general recursive combinators • Integrated with classes. Supports development in the large • Induction is a fundamental reasoning principle Functional Programming Spring Semester, 2025","libVersion":"0.5.0","langs":""}