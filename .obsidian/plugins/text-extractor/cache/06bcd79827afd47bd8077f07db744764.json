{"path":"sem4/DMDB/PV/DMDB-summary-anon.pdf","text":"DMDB - Summary Relational Algebra Operators: R × S\u0000 Cartesi an Product R ⋈ S\u0000 Combi ne all elements i n whi ch all common attri butes have same values, no dupl i cates R ⋊ S\u0000 Same as ⋈ , but only keeps ri ght attri butes R ⋉ S\u0000 Same as ⋈ , but only keeps left attri butes R ⋈θ S\u0000 Does cartesian product × and then fi lters for condi ti on θ R ⋈A S\u0000 Same as ⋈ but only matches column A ( subclass of theta-j oi n ⋈θ) R − S\u0000 Removes all rows, whi ch are also i n S R ÷ S\u0000 Keeps rows ( wi thout the cols of S) , of whi ch there exi sts copi es whose cover all attri butes of S. R ⟖ S\u0000 Same as ⋈, but i ncludes all rows from S and fi lls i n mi ssi ng values from R wi th nulls. R ⟕ S\u0000 Same as ⋈, but i ncludes all rows from R and fi lls i n mi ssi ng values from S wi th nulls. Candidate Key : Set of attri butes, whi ch can uni qu ely determi ne every element only usi ng all attri butes i n the set. E. g. i f one element can be removed from the set and i t sti ll uni qu ely determi nes every set, i t's not a candi date key. Primary Key : Set of attri butes chosen as key ( must be uni qu e) Secondary Key : Set of attri butes not chosen as key Conv erting ER\u0000Diagrams to Relational Model:   Wri te down all enti ti es and thei r attri butes wi th keys as descri bed. Spe ci al Cases: Weak Enti ti es: Include all attri butes of the relati on ( except the relati ons attri bute) and set all of them to the key. Generali sati on: Use the referenced enti ty's key as key for the referenci ng enti ty E. g. B(b–), C(c–), D(c, d)–   Wri te down all relati ons and thei r keys as \"attri butes\" and also thei r own attri bute. If there's a confli ct, e. g. a Weak Enti ty and thus we would end up wi th c twi ce, rename i t to c′ and i nclude both c and c′. As for the keys, for each Enti ty wi th a relati onshi p m arked wi th 1, set all other elements ( except relati on attri bute) as key. If there are multi pl e opt i ons, li st them as extra keys. E. g. R(b, c, c′, d, r), S(c, d, s)––   Merge relati on wi th enti ty A i ff there exi sts another enti ty i n the relati on marked wi th 1 and A contai ns all keys of all other enti ti es except the one marked wi th 1. Exampl e used: Normal Forms: 3NF Synthesi s\u0000 Lossless, keeps FDs but can retai n redundanci es BCNF ( and 4NF\u0000 Decomposi ti on\u0000 Lossless, removes redundanci es, but can lose FDs E. g. B(b–), C(c–), D(c–, d, s), R(b, c, c′, d, r)– 1NF\u0000 No di vi si ble attri butes, e. g. no li sts as attri butes. 2NF\u0000 There exi sts no RHS attri bute, whi ch i s not part a key that depe nds on only part of a candi date key. 3NF\u0000 Each non-tri vi al FD ei ther has a supe rset of a candi date key as LHS or the RHS contai ns pa rt of a candi date key. BCNF\u0000 Each non-tri vi al FD has a sup erset of a candi date key as LHS. 4NF\u0000 Each non-tri vi al MVD has a supe rset of a candi date key as LHS.   Compu te the mi ni mal basi s Fc   For all α → β ∈ Fc, create a new relati on wi th α ∩ β, e. g. Ra∪β(α ∪ β)   If none of the above relati ons contai ns a supe rkey, add a relati on wi th a key   Eli mi nate a relati on, i f i t's subset of another relati on.   Fi nd all evi l FDs \u0000 MVDs) , usually they are gi ven, but note that there are two appr oaches. Ei ther one also consi ders the tri vi al FDs \u0000 MVDs) , e. g. i f A → B and B → C one also consi ders A → C as an FD, or one calculates the closure for every FD, e. g. i n the pr evi ous exampl e one would get A → BC and A → C. The latter i s how i t's expl ai ned i n FS23.   Let α → β ( α →→ β) be the evi l FD \u0000 MVD\u0000 pr esent i nsi de a certai n relati on We wi ll pr oceed to spl i t thi s relati on i nto two relati ons. MVD Intui ti vely\u0000 If we have A →→ B, then i f we fi x A we get a set of values for B ( let's call i t AB) and a set of values for C ( any set of remai ni ng attri butes, call i t AC) . If we now fi x for any value i n AB, we get a set of values X of attri butes C. It must hold, that for any other value we fi x i n AB, we also get thi s same set of values X. The same must also hold i f we fi x a value i n AC ( wi th X as a set of values of B) . A B C a b c a bb cc a bb c a b cc Table: Exampl e from class, wi th A →→ B ( and thus also A →→ C, see rules below) . MVD Rules: Tri vi al MVDs: Does a tuple have to exi st?   Fi rst pa rt i s a relati on wi th α and β, e. g. R1 i = α ∪ β   Second pa rt i s a relati on wi th all remai ni ng elements of that relati on except β, e. g. R2 i = Ri − β   Now that we have spl i t the table, we check agai n i n all tables i f there's an evi l FD ( MVD\u0000 , e. g. i f any evi l α → β ( α →→ β) i s sti ll i n a relati on and α ∪ β i s not the set of attri butes of the whole relati on ( e. g. α i s a key and thus the relati on i s not evi l anymore) . If so, we go back to \u0000 1. ) otherwi se we are done. β ⊆ α ⇒ α →→ β α → β ⇒ α →→ β ( e. g. i f R ⊆ α ∪ β) Compl ement: α →→ β ⇒ α → R − α − β Multi -value Augmentati on: α →→ β ∧ (δ ⊆ γ) ⇒ αγ →→ βδ Multi -value Transi ti vi ty: (α →→ β) ∧ (β →→ γ) ⇒ α →→ γ   For each MVD α →→ β:   If we fi x α and β to the gi ven values i n the tupl e we get set S of po ssi bi li ti es for the remai ni ng attri butes.   Now we search for any other remai ni ng attri bute values not i n S i f we fi x another α or another β. These remai ni ng attri bute values are then \"mi ssi ng\" because of the MVD. Recov erability Classes: Locking and Snapshot Isolation: Serialisability : Query Optimisation:   If one of these \"mi ssi ng\" values i s gi ven i n the tupl e ( for fi x α and β) , the tupl e i s necessary.   If for all MVDs there i s no such mi ssi ng value pr ovi ded i n the tupl e, i t i s not necessary.   Recov erable \u0000 RC\u0000 \u0000 If T1 reads a value wri tten by T2, T2 has to commi t fi rst.   Av oids cascading aborts \u0000 ACA\u0000 \u0000 If T1 reads a value wri tten by T2, T2 has to be commi tted at the poi nt where T1 reads.   Strict \u0000 ST\u0000 \u0000 If T1 reads/wri tes a value wri tten by T2, T2 has to be commi tted at the poi nt where T1 reads/wri tes. Two-Phase Locki ng \u0000 2PL\u0000 \u0000 A thread has two ph ases, fi rst ph ase only acqu i re, second only release. \u0000 Two type s of lock states, shared and exclusi ve for read and wri te respe cti vely) Stri ct Two-Phase Locki ng \u0000 S2PL\u0000 \u0000 A thread acqu i res locks duri ng the transacti on and keeps the lock unti l i t commi ts. \u0000 Two type s of lock states, shared and exclusi ve for read and wri te respe cti vely) Snapshot Isolati on \u0000 SI\u0000 \u0000 Just li ke gi t. Read old versi on unti l commi tted. If someone commi tted after I started, whi ch has wri tten to the same obj ect, abort. Phantom Read\u0000 Happe ns when a transacti on reads a set of rows that sati sfy a condi ti on, another transacti on i nserts/deletes/upd ates rows, and the fi rst transacti on re-reads and gets a di fferent set of rows. Seri ali sable\u0000 Equ i valent to seri al hi story Vi ew Seri ali sable\u0000 Same as seri ali sable, but addi ti onal constrai nt that the fi rst read on each obj ect i s the same i n both hi stori es. Confli ct Seri ali sable\u0000 Equ i valent to a seri al hi story, by swappi ng non-confli cti ng ope rati ons ( e. g. any combi nati on of two di fferent thread ope rati ons on the same obj ect i nvolvi ng a wri te ope rati on) . In terms of strength, i t holds that Conflict Serializability ⊆ View Serializability ⊆ Serializability OLAP \u0000 Analysi s of large data) : Column Storage, Iterator Model OLTP \u0000 Transacti ons, smaller data) : Row Storage, Materi ali sati on Model Iterator Model\u0000 Iterates over ope rators usi ng next() Materi ali sati on Model\u0000 Processes i npu t all at once and then di rectly outpu ts Calculati ng the number of IOs, fi rst fi gure out how many tupl es fi t i nto the two buffers ( usually one pa ge pe r relati on) , then choose thi s as block si ze. Subsequ ently B(R) = |R| block_size . Note that the followi ng mi ght be wrong i f one of the relati ons fully fi t i nto one of the buffers and no i nner or outer relati on i s spe ci fi ed. Logi cal Plan\u0000 An abstract repr esentati on of what ope rati ons need to be p erformed to execute a qu ery, focusi ng on the \"what\" rather than the \"how. \" Physi cal Plan\u0000 A detai led pl an that spe ci fi es how the logi cal ope rati ons wi ll be ph ysi cally executed by the database, focusi ng on the \"how.\" Nested Loop Joi n: B(R) + |R| ⋅ B(S) IOs Block Nested Loop Joi n: B(R) + B(R) ⋅ B(S) IOs Index Nested Loop Joi n ( equ i -j oi n) : B(R) + |R| ⋅ C IOs Nai ve Hash Joi n: B(R) + B(S) IOs Sort Merge Joi n: B(R) + B(S) IOs Grace Hash Joi n: 3 ⋅ (B(R) + B(S)) IOs","libVersion":"0.5.0","langs":""}