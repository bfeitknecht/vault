{"path":"sem3/EProg/UE/e/EProg-e-u06.pdf","text":"252-0027-00: Einführung in die Programmierung Übungsblatt 6 Abgabe: 05. November 2024, 23:59 xkcd: Margin Randall Munroe (CC BY-NC 2.5) Checken Sie mit Eclipse wie bisher die neue Übungs-Vorlage aus. Importieren Sie beide Eclipse- Projekte (das Projekt für den Bonus und das Projekt für die restlichen Aufgaben). Beachten Sie, dass Sie mehrere unabhängige Programme im bonusunabhängigen Eclipse-Projekt haben werden. Bevor Sie ein Programm starten, achten Sie deshalb darauf, dass Sie die richtige Datei im Package Explorer ausgewählt oder im Editor geöffnet haben. Vergessen Sie nicht, Ihren Programmcode zu kommentieren! Aufgabe 1: Dreiecksmatrix Die Klasse Triangle erlaubt die Darstellung von Z × S Dreiecksmatrizen (von int Werten). Z und S sind immer strikt grösser als 1 (d.h., > 1). Eine Z × S Dreiecksmatrize hat Z Zeilen X0, X1, ..., XZ−1, wobei Zeile Xi genau (i ∗ (S − 1)/(Z − 1)) + 1 viele Elemente hat. Dieser Ausdruck wird nach den Regeln für int Ausdrücke in Java ausgewertet. Für eine Dreiecksmatrix D ist Di,j das (j + 1)-te Element in der (i + 1)-ten Zeile. D0,0 ist das erste Element in der ersten Zeile [die immer genau 1 Element hat]. Abbildung 1 zeigt Beispiele von Dreiecksmatrizen. Beachten Sie, dass es möglich ist, dass zwei (aufeinanderfolgende) Zeilen die selbe Anzahl Elemente haben. 0,0 1,0 1,1 2,0 2,1 2,2 3,0 3,1 3,2 3,3 0,0 3,0 3,1 3,2 3,3 2,0 2,1 0,0 1,0 1,1 2,0 2,1 2,2 3,0 3,1 3,2 3,3 2,3 3,4 4,0 4,1 4,2 4,3 4,4 4,5 4,6 1,0 0,0 Abbildung 1: Beispiele von 5 × 7, 4 × 4, 2 × 4 und 3 × 2 Dreiecksmatrizen. 1 In der Datei Triangle.java finden Sie die Klasse Triangle mit einem Konstruktor Triangle(int z, int s), der eine z × s Dreiecksmatrix erstellt. Dieser Konstruktor setzt die Werte aller Ele- mente auf 0. Vervollständigen Sie diese Klasse, so dass die folgenden Methoden unterstützt werden: 1. int get(int i, int j) gibt das Element Di,j zurück. 2. void put(int i, int j, int value) setzt das Element Di,j auf den Wert value. 3. int[] linear() liefert die Elemente in der kanonischen Reihenfolge (die Elemente jeder Zeile mit steigendem Index, und die Zeilen in steigender Reihenfolge). 4. void init(int[] data) ersetzt die Elemente von D durch die Werte in data. Sie dürfen annehmen, dass data genauso viele Elemente hat wie D. Die Methode setzt die Elemente von D, so dass die Folge D.init(data); int[] y = D.linear(); in einen Array y resultiert für den Arrays.equals(y, data) den Wert true ergibt. 5. void add(Triangle t) Ein Aufruf D.add(t) addiert zu jedem Element Di,j den Wert von ti,j, falls ti,j existiert. Falls ti,j nicht existiert, dann bleibt Di,j unverändert. Tests finden Sie in der Datei “TriangleTest.java”. Die Datei “TriangleGradingTest.java” enthält die Tests, welche wir bei der Prüfung für die Korrektur verwendet haben. Wir empfehlen, diese Tests erst zu verwenden, wenn Sie denken, dass Ihre Lösung korrekt ist, damit Sie sehen können, wie Sie bei einer Prüfung abgeschnitten hätten. Aufgabe 2: Hoare Tripel Welche dieser Hoare-Tripel sind (un)gültig? Bitte geben Sie für ungültige Tripel ein Gegenbeispiel an. Die Anweisungen sind Teil einer Java-Methode. Alle Variablen sind vom Typ int und es gibt keinen Overflow. 1. { x >= 0 || y >= 0 } z = x * y; { z > 0 } 2. { x > 10 } z = x % 10; { z > 0 } 3. { x > 0 } y = x * x; z = y / 2; { z > 0 } 4. { x > 0 } y = x * x; sum = y % (x + 1); { sum > 1 } 5. { b > c } if (x > b) { a = x; } else { a = b; } { a > c } 2 6. { x > 10 } if (x % 4 == 0) { y = x / 4; } { y >= 2 } 7. { y > 0 } if (x > y) { x = x - y; y = y * 2; } else { x = x * x; y = y - x; } { y > 0 && x > 0 } 8. { x != 0 } if (x % 2 == 0) { x = x / 2; } else if (x % 3 == -1) { x = x * 3; } else { x = x + 1; } { x != 0 } 3 Aufgabe 3: Weakest Precondition Bitte geben Sie für die folgenden Programmsegmente die schwächste Vorbedingung (weakest precondition) an. Bitte verwenden Sie Java-Syntax. Alle Anweisungen sind Teil einer Java Methode. Alle Variablen sind vom Typ int und es gibt keinen Overflow. 1. P: { ?? } S: if (x < 5) { y = x * x; } else { y = x + 1; } Q: { y >= 9 } 2. P: { ?? } S: if (x != y) { x = y; } else { x = y + 1; } Q: { x != y } 3. P: { ?? } S: if (x > y) { min = y; } else { min = x; } Q: { min <= x && min <= y } 4. P: { ?? } S: if (x != 0) { z = x; } else { z = x + 1; } Q: { z > 0 } 4 Aufgabe 4: Blackbox Testing Im letzten Übungsblatt haben Sie Testautomatisierung mit JUnit kennengelernt. In dieser Aufgabe sollen Sie nun Tests für eine Methode schreiben, deren Implementierung Sie nicht kennen. Dadurch werden Sie weniger durch möglicherweise falsche Annahmen beeinflusst, die bei einer Implementierung getroffen wurden. Sie müssen sich also überlegen, wie sich jede fehlerfreie Implementierung verhalten muss. Diesen Ansatz nennt man auch Black-Box Testing da die Details der Implementation wie in einer blickdichten Box versteckt und daher nicht einsehbar sind. In Ihrem “U06”-Projekt befindet sich eine “blackbox.jar”-Datei, welche eine kompilierte Klasse BlackBox enthält. Den Code dieser Klasse können Sie nicht sehen, aber sie enthält eine Methode void rotateArray(int[] values, int steps), welche Sie aus einer eigenen Klasse oder einem Unit-Test aufrufen können. Diese Methode “rotiert” ein int-Array um eine gegebene Anzahl Schritte. Vereinfacht macht die Methode rotateArray() Folgendes: Eine Rotation mit steps=1 bedeutet, dass alle Elemente des Arrays um eine Position nach rechts verschoben werden. Das letzte Element wird dabei zum ersten. Mit steps=2 wird alles um zwei Positionen nach rechts rotiert, usw. Eine Rotation nach links kann mit einer negativen Zahl für steps erreicht werden. Das folgende Beispiel ist der erste, einfache Test, den Sie in der Datei “BlackBoxTest.java” finden: int[] values = new int[] { 1, 2 }; int[] expected = new int[] { 2, 1 }; BlackBox.rotateArray(values, 1); assertArrayEquals(expected, values); Dieser Test prüft, dass das Array { 1, 2 } nach einer Rotation mit steps=1 aussieht wie { 2, 1 }. Die Methode assertArrayEquals(expected, values) prüft, dass die beiden Arrays expected und values die selben Elemente enthalten. Wenn nicht, schlägt der Test fehl. Die genaue Definition von rotateArray lautet wie folgt: Nach einem Aufruf ist das Element am Index i gleich dem Element, das zuvor am Index (i − steps) mod values.length war, für alle i zwischen 0 und values.length − 1, inklusive. “mod” steht für modulo und bezeichnet den Rest einer Ganzzahl-Division (siehe Wikipedia). Mit diesem Wissen sollen Sie nun weitere Tests schreiben, die möglichst gut prüfen, ob sich eine Implementierung wunschgemäss verhält. Überlegen Sie sich genau, was für die Parameter values und steps angegeben werden kann, und wie values nach dem Aufruf von rotateArray() aussieht. Der gegebene Test prüft beispielsweise nur, dass bei einem Array mit zwei Elementen nach einer Rotation um 1 die Elemente vertauscht sind. Eine Implementierung, die ein Array einfach umkehrt, würde den Test auch bestehen. Um die Stärke Ihrer Tests zu beurteilen, werden wir verschiedene, teilweise fehlerhafte Imple- mentierungen mithilfe Ihrer Tests prüfen. Je mehr Fehler Ihre Tests aufdecken, desto besser. Tests sollten fehlschlagen, falls die Implementierung fehlerhaft ist, und erfolgreich durchlaufen, falls keine Fehler vorhanden sind. 5 Aufgabe 5: Roboterwächterplatzierung (Bonus!) Achtung: Diese Aufgabe gibt Bonuspunkte (siehe “Leistungskontrolle” im www.vvz.ethz.ch). Die Aufgabe muss eigenhändig und alleine gelöst werden. Die Abgabe erfolgt wie gewohnt per Push in Ihr Git-Repository auf dem ETH-Server. Verbindlich ist der letzte Push vor dem Abgabetermin. Auch wenn Sie vor der Deadline committen, aber nach der Deadline pushen, gilt dies als eine zu späte Abgabe. Bitte lesen Sie zusätzlich die allgemeinen Regeln. Wir haben ein quadratisches Gebiet mit Höhe und Breite h. Auf diesem Gebiet befindet sich ein rechteckiges Schatzgebiet, das den Schutz von Roboterwächtern benötigt. Roboterwächter senden Laserlicht aus, um Diebe zu erkennen. Wir können das Gebiet als eine h × h-Matrix betrachten. Jeder Roboter befindet sich in einer Zelle dieser Matrix und sendet Laserlicht vertikal, horizontal und diagonal aus (insgesamt in acht Richtungen, wie in Abbildung 2 (a) gezeigt), wobei jede Zelle, die von Laserlicht getroffen wird, geschützt ist. Das Laserlicht kann das Schatzgebiet durchdringen, aber es dürfen keine Roboter im Schatzgebiet platziert werden. Die Roboter dürfen auch nicht im Laserlicht eines anderen Roboters stehen. Das Ziel ist es, h Roboter so zu platzieren, dass alle Zellen geschützt sind. Abbildung 2: (a) Roboterwächter können Laserlicht in acht Richtungen senden. (b) Das zu schützende Gebiet mit einem Schatz (Treasure). (c) Ein Beispiel für die Platzierung von Robotern zum Schutz des Schatzes. (d) Ein Beispiel für die Platzierung von Robotern, einschliesslich zweier vorinstallierter Roboter. In Java wird die h × h-Matrix durch ein zweidimensionales char-Array repräsentiert. Dabei repräsentiert ’–’ ein leeres Feld, ’T’ ein Feld des Schatzgebiets und ’R’ einen Roboter. Sie können in den folgenden Aufgaben davon ausgehen, dass die übergebene Matrix quadratisch ist mit h ≥ 1 und jede Zelle einen der drei zuvor genannten chars enthält. In den Unteraufgaben 2 und 3 dürfen Sie zusätzlich davon ausgehen, dass das Schatzrechteck mindestens eine Höhe und Länge von 1 hat. Die Matrix aus Abbildung 2 c) wird also wie folgt dargestellt: char[][] example = { {’-’,’-’,’-’,’-’,’R’}, {’-’,’R’,’-’,’-’,’-’}, {’-’,’T’,’T’,’R’,’-’}, {’R’,’T’,’T’,’-’,’-’}, {’-’,’-’,’R’,’-’,’-’} }; 6 1. In dieser Unteraufgabe geht es darum, Roboter zu finden, die sich gegenseitig das Laserlicht blockieren. Implementieren Sie dazu die Methode int[] findConflictingRobot(char[][] area). Finden Sie einen beliebigen Roboter, welcher das Laserlicht eines anderen Roboters blockiert. Geben Sie dessen Position in einem Array mit Länge zwei zurück. Für einen Roboter in Zeile i und Spalte j soll [i,j] zurückgegeben werden (0 ≤ i, j < h). Wenn kein Roboter das Laserlicht eines anderen Roboters blockiert, soll null zurückgegeben werden. Hier sind zwei Beispiele mit fünf Robotern in einem 5 × 5-Gebiet: • findConflictingRobot(areaA) kann z. B. [2,3], [3,2] oder [4,2] zurückgeben. areaA = { {’-’,’-’,’-’,’-’,’R’}, {’-’,’R’,’-’,’-’,’-’}, {’-’,’-’,’-’,’R’,’-’}, {’-’,’-’,’R’,’-’,’-’}, {’-’,’-’,’R’,’-’,’-’} }; • findConflictingRobot(areaB) gibt null zurück, da kein Konflikt besteht. areaB = { {’-’,’-’,’-’,’-’,’R’}, {’-’,’R’,’-’,’-’,’-’}, {’-’,’T’,’T’,’R’,’-’}, {’R’,’T’,’T’,’-’,’-’}, {’-’,’-’,’R’,’-’,’-’} }; 2. Finden Sie die Standorte von genau h Robotern, die das gesamte h × h-Gebiet (inklusive dem Schatzgebiet) mit Laserlicht abdecken können, ohne dass sich ein Roboter im Schatzgebiet befindet und ohne dass sich Roboter gegenseitig das Laserlicht blockieren. Implementieren Sie dazu die Methode char[][] placeRobots(char[][] area). Sie können davon ausge- hen, dass sich in der übergebenen Matrix area kein ’R’ befindet. Ein Roboter an Position [i,j] befindet sich im Schatzgebiet, falls sich in der übergebenen Matrix area in Zeile i und Spalte j bereits ein ’T’ befindet. Geben Sie eine Matrix des Gebiets den h platzierten Rob- totern in der beschriebenen Repräsentation zurück. Wenn eine entsprechende Platzierung von Roboterwächtern nicht möglich ist, soll null zurückgegeben werden. Hier sind zwei Beispiele: • placeRobots(areaC) soll eine mögliche Lösung zurückgeben, z. B. robotsC1 (siehe Abbildung 2 (c)) oder robotsC2. areaC = { {’-’,’-’,’-’,’-’,’-’}, areaD = { {’-’,’-’,’-’,’-’,’-’}, {’-’,’-’,’-’,’-’,’-’}, {’-’,’-’,’-’,’-’,’-’}, {’-’,’T’,’T’,’-’,’-’}, {’T’,’T’,’T’,’T’,’T’}, {’-’,’T’,’T’,’-’,’-’}, {’T’,’T’,’T’,’T’,’T’}, {’-’,’-’,’-’,’-’,’-’} }; {’-’,’-’,’-’,’-’,’-’} }; robotsC1 = { {’-’,’-’,’-’,’-’,’R’}, robotsC2 = { {’-’,’-’,’-’,’-’,’R’}, {’-’,’R’,’-’,’-’,’-’}, {’-’,’-’,’R’,’-’,’-’}, {’-’,’T’,’T’,’R’,’-’}, {’R’,’T’,’T’,’-’,’-’}, {’R’,’T’,’T’,’-’,’-’}, {’-’,’T’,’T’,’R’,’-’}, {’-’,’-’,’R’,’-’,’-’} }; {’-’,’R’,’-’,’-’,’-’} }; 7 • placeRobots(areaD) gibt null zurück, da aufgrund der grossen Schatzfläche keine Lösung existiert. Tipp: Die Lösungen für dieses Problem haben kein einfaches Muster. Versuchen Sie also nicht, selber ein Muster zu finden, sondern schreiben Sie ein Programm, welches verschiedene Kombinationen testet, bis es eine Lösung findet – oder feststellt, dass es keine gibt. Wir empfehlen, diese Aufgabe rekursiv zu lösen. 3. Angenommen, wir haben bereits einen oder mehrere Roboter innerhalb des h × h-Gebiets installiert und ihre Standorte können nicht geändert werden. Finden Sie die Standorte der verbleibenden Robotern (es muss insgesamt genau h Roboter geben), die das gesamte h × h-Gebiet (inklusive dem Schatzgebiet) mit Laserlicht abdecken können, sodass kein Ro- boter das Laserlicht eines anderen berührt. Implementieren Sie dazu die Methode char[][] placeOtherRobots(char[][] area). Die bereits installierten Roboter werden in area eben- falls durch ein ’R’ repräsentiert. Sie dürfen davon ausgehen, dass die bereits installierten Roboter sich ausserhalb des Schatzgebietes befinden und sich gegenseitig nicht blockieren. Geben Sie eine Matrix des Gebiets mit den insgesamt h platzierten Robotern in der beschrie- benen Repräsentation zurück. Wenn eine entsprechende Platzierung von Roboterwächtern nicht möglich ist (ohne die Positionen der vorinstallierten Robotern zu ändern), soll null zurückgeben werden. Ein Beispiel mit vorinstallierten Robotern an den Positionen [2,0] und [3,3] finden Sie in Abbildung 2 (d). Beispiele: • placeOtherRobots(areaE) gibt eine mögliche Lösung zurück, z. B. robotsE areaE = { {’-’,’-’,’-’,’-’,’-’}, robotsE = { {’-’,’-’,’-’,’-’,’R’}, {’-’,’-’,’-’,’-’,’-’}, {’-’,’-’,’R’,’-’,’-’}, {’R’,’T’,’T’,’-’,’-’}, {’R’,’T’,’T’,’-’,’-’}, {’-’,’T’,’T’,’R’,’-’}, {’-’,’T’,’T’,’R’,’-’}, {’-’,’-’,’-’,’-’,’-’} }; {’-’,’R’,’-’,’-’,’-’} }; • placeOtherRobots(areaF) gibt null zurück, da keine Lösung existiert. areaF = { {’-’,’-’,’-’,’-’,’-’}, {’-’,’-’,’-’,’R’,’-’}, {’-’,’T’,’T’,’-’,’-’}, {’-’,’T’,’T’,’-’,’-’}, {’-’,’-’,’-’,’-’,’-’} }; Hinweis: Es kann passieren, dass Sie bei der Ausführung des Codes oder der JUnit-Tests auf folgende Fehlermeldung stossen: Exception in thread ”main” java.lang.OutOfMemoryError: Java heap space Das bedeutet, dass Ihr Programm zu viel Speicher benötigt – wahrscheinlich haben Sie zu viele Roboter-Konfigurationen gleichzeitig im Speicher. Versuchen Sie in diesem Fall zu prüfen, ob die Konfigurationen relevant sind, bevor Sie diese (z. B. in ein Array) speichern. 8","libVersion":"0.3.2","langs":""}