{"path":"var/export/A&D-bf-u10.pdf","text":"10.1 Shortcutting closed Eulerian Walks The connected graph H = (V , F ) on the same n = |V | vertices as the complete graph G = Kn has a closed eulerian walk T = (fi)k, where fi ∈ F and k = |F |. Then, the algorithm presented below iterates through the edges in the given closed eulerian walk and adds the vertices in the order ﬁrst encountered to the hamilton cycle C. Thus it keeps only those that aren't \"detours\". Through the metric property of G and the compatibility of edge weights with H, skipping over previously visited vertices cannot increase the total weight. Additionally this ensures that every vertex is visited exactly once, as H is connected. It follows that C is a hamilton cycle in G and it holds that w(C) ≤ w′(T ). Thus the algorithm is correct and satisﬁes the runtime bounds. □ -- \u0000l\u0000\u0000\u0000i\u0000\u0000m t\u0000 conv\u0000\u0000\u0000 e\u0000ler \u0000\u0000\u0000\u0000\u0000\u0000\u0000 t\u0000 h\u0000\u0000\u0000l\u0000\u0000n cy\u0000le -- @p\u0000r\u0000m: H \u0000 \u0000V, F\u0000, cone\u0000t\u0000d \u0000r\u0000ph w\u0000\u0000r\u0000 n = |V| and k = |F| -- @p\u0000r\u0000m: T = [f] * k, e\u0000ler \u0000\u0000\u0000\u0000\u0000\u0000\u0000 i\u0000 H w\u0000\u0000r\u0000 f = (u, v) i\u0000 F \u0000\u0000\u0000\u0000 u, v i\u0000 V -- @retur\u0000: C = [v] * (n+1), h\u0000\u0000\u0000l\u0000\u0000n cy\u0000l\u0000 i\u0000 G -- @r\u0000\u0000\u0000\u0000\u0000\u0000: O\u0000\u0000F\u0000\u0000 f\u0000n\u0000\u0000\u0000\u0000n e\u0000ler_t\u0000_h\u0000\u0000\u0000l\u0000\u0000n(H, T\u0000 C = {} for edge f = (u, v) i\u0000 T do \u0000\u0000 n\u0000t u.\u0000is\u0000\u0000\u0000d t\u0000en u.\u0000is\u0000\u0000\u0000d = \u0000\u0000\u0000e C.add(u) end \u0000\u0000 n\u0000t v.\u0000is\u0000\u0000\u0000d t\u0000en v.\u0000is\u0000\u0000\u0000d = \u0000\u0000\u0000e C.add(v) end end C.add(s) -- w\u0000\u0000r\u0000 v\u0000\u0000\u0000\u0000x s = \u0000ta\u0000t\u0000\u0000g v\u0000\u0000\u0000\u0000x i\u0000 T retur\u0000 C end 10.2 BFS a) iteration operation queue 0 q.push(A) q = [A] 1 q.pop() -> A q = [] 2 q.push(F) q = [F] 3 q.push(G) q = \u0000F, G\u0000 4 q.pop() -> F q = [G] 5 q.pop() -> G q = [] 6 q.push(B) q = [B] 7 q.push(H) q = \u0000B, H\u0000 8 q.push(I) q = \u0000B, H, I\u0000 9 q.pop() -> B q = \u0000H, I\u0000 10 q.pop() -> H q = [I] 11 q.push(E) q = \u0000I, E\u0000 12 q.pop() -> I q = [E] 13 q.push(C) q = \u0000E, C\u0000 14 q.pop() -> E q = [C] 15 q.push(D) q = \u0000C, D\u0000 16 q.pop() -> C q = [D] 17 q.pop() -> D q = [] b) Let T = (V , ET ) be the shortest path tree for G, rooted at the vertex A ∈ V . A B C D E F G HI c) k 0 1 2 3 4 5 Sk {A} {F , G} {B, H, I} {C, E} {D} ∅ d) The set of critical edges in G are given below. S = {(A, F ), (A, G), (G, B), (G, H), (G, I), (H, E), (I, C)} e) v\u0000\u0000\u0000\u0000x A F G B H I E C D e\u0000ter 0 2 3 6 7 8 11 13 15 l\u0000ave 1 4 5 9 10 12 14 16 17 f) k 0 1 2 3 4 5 tk 1 4 9 14 17 ∞ g) k 0 1 2 3 4 5 Rk {A} {F , G} {B, H, I} {E, C} {D} ∅ 10.4 Number of Minimal Paths To count the number of paths between two distinct vertices v, v′ ∈ V of length k, we modify BFS as follows. For every vertex u ∈ V we keep track of the number of distinct paths reaching it and the distance it has from v. Since we explore every edge and visit every vertex at most once, the given algorithm satisﬁes the runtime constraint of O(n + m). Furthermore, its correctness is given by the fact that all paths of length l are considered before exploring paths of length l + 1. Thus we account for every path from v to v′ that has length k. □ -- \u0000l\u0000\u0000\u0000i\u0000\u0000m t\u0000 cou\u0000t t\u0000e n\u0000m\u0000\u0000r \u0000f p\u0000t\u0000s \u0000f l\u0000n\u0000t\u0000 k \u0000\u0000\u0000m s t\u0000 t -- @p\u0000r\u0000m: k, l\u0000n\u0000t\u0000 \u0000f p\u0000t\u0000s -- @p\u0000r\u0000m: s, \u0000ta\u0000t\u0000\u0000g v\u0000\u0000\u0000\u0000x v -- @p\u0000r\u0000m: t, tar\u0000\u0000t v\u0000\u0000\u0000\u0000x v' -- @p\u0000r\u0000m: G \u0000 \u0000V, E\u0000, \u0000r\u0000ph as a\u0000j\u0000cency \u0000\u0000st -- @retur\u0000: p, n\u0000m\u0000\u0000r \u0000f p\u0000t\u0000s \u0000f l\u0000n\u0000t\u0000 k \u0000\u0000\u0000m s t\u0000 t f\u0000n\u0000\u0000\u0000\u0000n p\u0000t\u0000s_\u0000f_l\u0000n\u0000th(k, s, t, G\u0000 p = {{}} -- m\u0000\u0000r\u0000\u0000 w\u0000\u0000r\u0000 p[v][l]: p\u0000t\u0000s \u0000\u0000\u0000m s t\u0000 v \u0000f l\u0000n\u0000t\u0000 l p[s][0] = 1 -- \u0000ta\u0000t\u0000\u0000g v\u0000\u0000\u0000\u0000x has one p\u0000t\u0000 \u0000f l\u0000n\u0000t\u0000 z\u0000r\u0000 t\u0000 \u0000\u0000\u0000\u0000\u0000f q = {} -- queue w\u0000\u0000r\u0000 (v, d): v\u0000\u0000\u0000\u0000x v \u0000t \u0000ist\u0000nce d \u0000\u0000\u0000m s q.push({s, 0\u0000\u0000 w\u0000\u0000\u0000\u0000 n\u0000t q.\u0000m\u0000ty() do (u, d) = q.pop() i\u0000 n\u0000t d == k t\u0000en for v i\u0000 A\u0000j[u] do p[v][d+1] += p[u][d] i\u0000 d+1 <= k t\u0000en q.push(v, d+1) end end end end retur\u0000 p[t][k] end","libVersion":"0.5.0","langs":""}