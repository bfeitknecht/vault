{"path":"var/export/TI-bf-u07.pdf","text":"19 First, let's recall the deﬁnition of the halting language. LH = {Kod(M)#x ∈ Σ∗ B ∣ x ∈ L(M) ∨ x ∉ L(M)} Now, assume there exists an algorithm (TM that always halts) A that decides LH. Then, we construct an algorithm B that decides the given language L′ diag with the help of A. First, the subprogram C tests, whether or not the input word x = wj is of the correct form, i.e. it has an even index j = 2i for some i ∈ N in the canonical order of words over {0, 1}. If it isn't, B rejects the input word x immediately. Otherwise, C computes the i-th TM Kod(Mi) with the totally recursive function Gen, which exists per lemma 4.3. Then, it constructs a turing machine M from Kod(Mi) that doesn't take any input but simulates Mi on x with the modiﬁcation, that any state in Mi that transitions to the accepting state q✓ instead enters an inﬁnite loop. It's noted, that M halts if and only if Mi halts and rejects x. Then, the algorithm A decides if the TM M described above halts on x. Hence we have the following. x ∈ L′ diag ⟺ M(x) ∈ LH This implies that L′ diag ≤R LH. □ 20 Prove the following statements. (a) Lunion ∈ LRE Per subtask (c), we have constructed a TM B that reduces Lunion to LU. Since LU ∈ LRE we have Lunion ∈ LRE. □ (b) LU ≤EE Lunion We deﬁne a function M(x) for any x ∈ {0, 1, #}∗, that fulﬁlls the below. x ∈ LU ⟹ M(x) ∈ Lunion If x ∉ {M1#w|M1, w ∈ {0, 1}∗} then M(x) = λ else M(x) = {M1#M1#w|M1, w ∈ {0, 1}∗}. (i) x ∈ LU If x ∈ LU then the TM encoded in x accepts the word encoded in x. If we copy this exact TM then both TM's will accept the encoded word therefore x ∈ Lunion. (ii) x ∉ LU If x ∉ LU then: 1. The form of x is wrong, M(x) returns λ therefore λ ∉ Lunion 2. TM is not a valid TM therefore {T M#T M#w} ∉ Lunion 3. The encoded TM rejects the encoded word or doesn't halt therefore x ∉ Lunion □ (c) Lunion ≤EE LU First, recall the deﬁnition of the universal TM language LU. LU = {Kod(M)#w ∈ Σ∗ B ∣ w ∈ L(M)} We assume there exists an algorithm A that decides LU. Then we construct an algorithm B that decides Lunion. It consists of a subprogram C that checks, if x ∈ {0, 1, #}∗ is of the correct form. If x ∉ {M1#M2#w ∈ Σ∗ B ∣ M1 ∈ KodTM ∨ M2 ∈ KodTM}, B rejects. Else, we know that either M1 or M2 is a valid encoding of a TM. Since we can transform any MTM to a TM, we pass to A a TM M(x) = Kod(M ′) that encodes a 2-tape MTM M ′ which takes no input but simulates M1, M2 on the input word w. This M accepts if and only if M ′ accepts, i.e. either M1, M2 on w end in the accepting state q✓. Then the algorithm A decides if M accepts the input x. Hence the following holds. x ∈ Lunion ⟺ M(x) ∈ LU And thus we have Lunion ≤EE LU. □","libVersion":"0.5.0","langs":""}