{"path":"sem4/CN/UE/s/CN-u04-s.pdf","text":"Exercise 4: Transport Protocols Question 1: Reliable transport (exam-style question).[1] [1] Adapted from exercises of Communication Networks (227-0120-00L). Consider a Go-Back-N sender and receiver directly connected by a 10 Mbps (= 10 ∗ 106 bits) link with a propagation delay of 100 milliseconds. The retransmission timer is set to 3 seconds. The retransmission timer restarts on every received ACK (including duplicate ones). The window has a length of 4 segments. An ACK is transmitted as soon as the last bit of the corresponding data segment is received, and the size of the ACK is very small. (The number of an ACK is always RCV.NXT, i.e., +1 of the highest sequence number until it has received everything) You can neglect: • transmission delay for ACK packets • processing delay for all packets • queuing delay for all packets Draw a time-sequence diagram showing the transmission of 10 segments where each segment contains 10 000 bits. Question 1.1 Draw the time-sequence diagram for the case where there are no losses. (You can fill in and complete the following figure which already contains the segment “0”). 1 Time-sequence diagram answer template Solution: (see image below) Transmitting a single segment (“putting it on the wire”) takes 2 transmission delay per segment = packet size bandwidth = 10 000 bits 10 Mbps = 10 000 bits 10 000 000 bps = 1 1 000 s = 1ms From the lecture you know that total delay = propagation delay + transmission delay + queuing delay + processing delay Queuing- and processing delay are negligible in this exercise. Therefore when a segment is transmitted at time t the last bit is send at time t+transmission delay+ propagation delay = t + 101ms Notice that the sender waits for an ACK segment after transmitting 4 packets before sending the next one due to the window size of 4. Solution Question 1.2 Draw the time-sequence diagram for the case where the 3rd (segment “2”) and last segment (segment “9”) are lost once i.e. their first transmission fails but 3 their second succeeds. No ACK’s are lost. Time-sequence diagram answer template Solution: (see image below:) 4 We refer to the explanation above for the transmission delays. Segment “2” gets lost and segments “3”,“4,”5” are transmitted successfully. Notice that all those packets are retransmitted again later as specified in the Go-back-N protocol (In practice one would optimize this). Also notice that the successfully transmitted segments 3-5 cause ACK segments to be returned which reset the retransmission timer. 5 Solution 6 Question 2: TCP [Previous Exam Question (adapted slightly)][2] [2] Operating Systems & Networks (252-0062-00L); Spring Semester 2016 (FS16). Question 9. https://exams.vis.ethz.ch/category/OperatingSystemsandComputerNetworks The Transmission Control Protocol (TCP) uses congestion control in order to moderate the rate at which traffic enters the network. The following figure shows how the size of the congestion window (y-axis) fluctuates as time passes (x-axis). Timeouts are not explicitly shown, but you should be able to determine this based on the plot. Based on the figure, answer the following questions. Congestion window (cwnd) For your convenience you find the simplified TCP congestion control algorithm from the lecture slides below (2022 - lecture 06 - Internet Transport). Note: cwnd = congestion window, ssthresh = slow start threshold: 7 TCP congestion control algorithm Question 2.1 Identify the time intervals when congestion control is operating in slow start. Briefly explain slow start and what triggers it. Solution: Slow start is operating at intervals {[1, 6], [7, 11], [23, 26]}. Slow start is the multiplicative increase of the congestion window, meaning that for every packet is ACK’ed, the size of the congestion window grows by one packet. This leads to a doubling of the window size, every RTT. Slow start operates when the cwnd is lower than the ssthresh. Question 2.2 Identify the time intervals when congestion control is operating in congestion avoidance, i.e., it uses additive increase. Briefly explain additive increase and what triggers congestion avoidance. Solution: Congestion avoidance is operating at intervals {[11, 15], [16, 22], [26, 32]}. Congestion avoidance means that for every RTT, the congestion window size grows with a single packet unless packet losses are inferred, in which case, the congestion window reduces by half. The connection has already experienced congestion before, and as such, it “knows” that exponential growth (slow start algorithm) will be too aggressive. Congestion avoidance is operating when the cwnd is higher than or equal to the ssthresh. 8 Question 2.3 The fast retransmit and fast recovery algorithms usually operate in conjunction. Question 2.3.1 Identify at which point(s) in time there is fast retransmission and explain why. Solution: At t=16, there is fast retransmission. The cwnd is halved, and the ssthresh = cwnd. If it were a timeout, the cwnd would have gone to 1. This is presumably because of three duplicated ACKs being received. Question 2.3.2 Briefly explain how fast retransmission and fast recovery work and the main intuition behind them. Solution: When three duplicate ACKs are received by the sender, it will (fast) retransmit the apparent data packet that got lost. The fast recovery mechanism halves the cwnd and sets ssthresh=cwnd. It does not return to the slow start (by setting cwnd=1 ) as would be done upon a timeout. The main intuition is that a timeout, and the resulting significant reduction in throughput, should only occur if no packets can be transmitted anymore (in the client-server direction, in the server-client direction, or in both directions). Three duplicate ACKs indicate less severe congestion (i.e., some packets still arrive), which can be solved by halving the congestion window. Question 3: Unreliable transport protocol In the lecture, you have learned how a reliable transport protocol can be built on top of a best-effort delivery network. Question 3.1 What are the characteristics of best-effort and reliable transport? Solution: • Best-effort delivery: There is no guarantee for packets to arrive in the correct order, arrive correctly (i.e., no bit corruption), or even arrive at all. • Reliable transport: Reliable transport has the following four goals: correct- ness, timeliness, efficiency, and fairness. Compared to best-effort, it tries to ensure packet arrival, packet integrity, and correct packet order, while not overwhelming the network (i.e., only using a “fair” amount of bandwidth compared to other traffic in the network). While reliable transport cannot guarantee that packets arrive, it can guarantee that if a packet was lost it will always be resent through the use of acknowledgements. Correct packet order and packet integrity cannot be 100% guaranteed by a reliable transport but corruption can often be detected using checksums and the correct order can be reconstructed through the sequence numbers in packet headers. Note that a packet, and thus its content, checksum, and sequence 9 number, could be corrupted in such a way that it still looks like a valid packet. However, in practice, and assuming that there is no malicious entity in the network, this is highly unlikely to happen. Question 3.2 What could be advantages of using an unreliable transport protocol? Solution: • Better performance/less overhead since you don’t have to wait for ACKs to arrive; • Lightweight implementation; • As no connection setup is required (e.g., TCP three-way handshake), you can immediately start sending data. Question 3.3 What type of applications are suitable to use unreliable transport protocols? Solution: Applications for which it is more important to have “live” data than to have “complete” data. E.g., Gaming or Live Streaming. In voice/video-calls, for example, lost packets lead to lower quality, but delayed packets lead to distorted conversations. Question 3.4 The User Datagram Protocol (UDP) only provides unreliable transport. Assume you are forced to use a network which only supports UDP as a transport protocol. You must transmit an important document which eventually should be correctly transmitted. Is it possible to implement reliable transport mechanisms despite using UDP? Solution: Yes, the reliable transport mechanisms could be implemented by the application/in the application layer. Question 4: QUIC Question 4.1 At what layer does QUIC operate? Can, and if so how, does it offer the same functionality as the TCP+TLS stack? Note: TLS is a protocol used to establish an encrypted connection on top of the reliable transport TCP. It is not covered in the lecture in detail. Solution: QUIC operates at both the transport layer, building on top of UDP and the application-layer. It offers TCP-like guarantees (i.e., reliability) (traditionally ‘transport-layer-like functionality’) and also incorporates the TLS handshake (which in the TCP/IP+TLS stack is completely separated from TCP) (traditionally ’application-layer-like functionality). 10 Question 4.2 What are the advantages of QUIC over TCP+TLS? Name at least three. Solution: • QUIC combines the connection and TLS handshake, thus reducing the connection setup time by one RTT • QUIC enables Zero-RTT communication if the hosts have communicated before (through the improved handshake) • Connection hand-over is possible by identifying connection with a con- nection ID instead of the 5(/4)-tuple (even with changing IP addresses e.g. when changing networks with a mobile device) • QUIC resolves head-of-line blocking by the logical abstraction of streams (contrary to TCP, which required you to open multiple parallel TCP connections) Question 4.3 Why did QUIC not design its own custom transport layer header instead of UDP? Solution: Middleboxes and NAT routers are known to drop unfamiliar transport layer protocols. Using UDP gives interoperability with existing hardware. Question 5: Packet Switching In packet-switching networks, the source host segments long application-layer messages (for example images or music files) into smaller packets and sends the packets into the network. The receiver re-assembles the packets back into the original message. This figure illustrates the end-to-end transmission of a message with and without segmentation: 11 Transmission (a) without message segmentation, and (b) with message segmentation Consider a 7.5 * 10ˆ6 bits long message that is to be sent from the source to the destination as shown in the figure. We assume that each link has capacity 1.5 Mbps and ignore propagation, queuing and processing delays. Question 5.1 Consider sending the message from source to destination without message segmentation. Keep in mind that each packet switch uses a store and forward packet switching. i) How long does it take to move the message from the source host to the first packet switch? ii) What is the total time to move the message from the source host to the destination host? Solution: i) 7.5 · 10 6bits 1.5 M bps = 5 s ii) 5 s · 3 hops = 15 s Question 5.2 Now suppose that the message is segmented into 5,000 packets, with each packet being 1500 bits long. How long does it take to move the the first packet from the source host to the first packet switch? 12 Solution: 1500 bits 1.5 M bps = 1 ms Question 5.3 How long does it take to move the file from the source host to the destination host when message segmentation is used? Compare and comment. Solution: 3 ms + 4999 · 1 ms = 5.002 s, faster by a factor of ∼ 1 3 Question 5.4 What are the drawbacks of message segmentation? Solution: • Need to handle out-of-sequence • Additional header necessary Question 6: Timeout Value In the following questions, we want to see how we can calculate a good timeout value. Question 6.1 What happens, if the timeout is larger than the RTT, what if it’s smaller than the RTT? I.e., timeout = a * RTT and timeout = 1/a * RTT respectively, where a > 1. Solution: • If the timeout is larger than the RTT, we will have an inefficient imple- mentation, since we wait too long to resend our packet. • If the timeout is smaller than the RTT, we resend our packet too fast, and thus send duplicate packets for no reason. Question 6.2 • To get a good estimation for the RTT to calculate the timeout, current TCP implementations use a form of averaging over the samples. Do they use exponential or linear averaging of RTT samples? 13 • We calculate the SampleRTT as follows: SampleRT T = AckRcvdT ime − SendP acketT ime Fill in the gaps for the EstimatedRTT formula: EstimatedRT T = α · EstimatedRT T + ................................. where 0 ≤ α ≤ 1 Solution: • We use Exponential averaging of RTT (see RFC793 Section 3.7 and RFC6298 Section 2). • The EstimatedRTT is calculated by EstimatedRT T = α · EstimatedRT T + (1 − α) · SampleRT T Question 6.3 For the following two examples, fill in the gaps for the EstimatedRTT. What role does alpha play? What if SampleRTT always stays the same? For α = 0.5 Smoothed RTT (α = 0.5) For Alpha = 0.3 14 Smoothed RTT (α = 0.3) Solution: Smoothed RTT Solution (α = 0.5) For Alpha = 0.3 15 Smoothed RTT Solution (α = 0.3) Alpha decides how much weight we want to give to new Sample values. For small alpha, we weigh our new samples stronger, as we can see in the second example. If SampleRTT always stays the same, the EstimatedRTT will converge to SampleRTT. 16","libVersion":"0.5.0","langs":""}