{"path":"var/export/A&D-bf-u07.pdf","text":"Basil Feitknecht, 23-922-099 7.1 Subset Sum with Duplicates 1. dimensions of the boolean DP table S are ( b + 1) × ( n + 1) , i.e. matrix 2. entry S[i][j], with i ∈ [b], j ∈ [n] means that i is subset sum with duplicates of ﬁrst j entries in A 3. the correctness of the recurrence relation below is given by the fact, that adding an element solves a new subproblem, whereas not adding it preserves the results of the previous iterations' subproblems, i.e. the solutions of the subproblems together form the solution of the initial problem base case: for j = 0 \u0000\u0000 n do: S\u00000][j] = \u0000\u0000\u0000e \u0000\u0000 no \u0000l\u0000m\u0000\u0000t\u0000 t\u0000ken \u0000iel\u0000s z\u0000ro for i = 1 \u0000\u0000 b do: S[i][0] = fal\u0000e \u0000\u0000 z\u0000r\u0000 \u0000t\u0000ys z\u0000ro 1 2 recurrence relation: for j = 1 \u0000\u0000 n do: for i = 1 \u0000\u0000 b do: a = A[j] S[i][j] = S[i][j-1] \u0000\u0000 \u0000\u0000 don't add n\u0000w \u0000l\u0000m\u0000\u0000t (S[i][j-a] && a < j) \u0000\u0000 \u0000\u0000 add \u0000l\u0000m\u0000\u0000t once (S[i][j-2*a] && 2*a < j) \u0000\u0000 add \u0000l\u0000m\u0000\u0000t \u0000w\u0000\u0000e 1 2 3 4 5 6 4. we iterate j over 1 … n and i over 1 … b, thus we compute bottom up 5. solution can be extracted at S[b][n], since that entry encodes if it's possible to make subset sum with duplicates b of all n entries A[1. . n] 6. running time is dominated by two nested for loops and thus O( b ⋅ n) □ 7.4 Weight and Volume Knapsack 1. dimensions of the 3d DP table are ( n + 1) × Wmax × Vmax 2. the meaning of entry S[i][j][l] is the proﬁt with i items that add up to weight j and volume l 3. the correctness of recursion is given by the fact that solutions to the subproblems solve the initial problem base case: for i = 0 \u0000\u0000 n do: for j = 0 \u0000\u0000 W_m\u0000x do: for l = 0 \u0000\u0000 V_m\u0000x do: S\u00000][j][l] = 0 \u0000\u0000 z\u0000r\u0000 \u0000\u0000\u0000m\u0000 z\u0000r\u0000 \u0000ro\u0000it S[i][0][l] = 0 \u0000\u0000 z\u0000r\u0000 w\u0000i\u0000\u0000t => z\u0000r\u0000 \u0000\u0000\u0000m\u0000 \u0000\u0000 S[i][j][0] = 0 \u0000\u0000 z\u0000r\u0000 v\u0000l\u0000m\u0000 \u0000\u0000 1 2 3 4 5 6 recurrence relation: for i = 1 \u0000\u0000 n do: for j = 1 \u0000\u0000 W_m\u0000x do: for l = 1 \u0000\u0000 V_m\u0000x do: S[i][j][l] = S[i-1][j-1][l] \u0000\u0000 add n\u0000thi\u0000g i\u0000 W[i] < j t\u0000en: S[i][j][l] = S[i-1][j-w[i]][l] + P[i] \u0000\u0000 add \u0000\u0000\u0000m \u0000\u0000 n\u0000t exceed \u0000\u0000m\u0000\u0000s 1 2 3 4 5 6 4. calculation order is increasing i then j then l 5. extracting solution can be done at S[n][Wmax][Vmax] 6. runtime of the algorithm is O( n ⋅ Wmax ⋅ Vmax) □ 7.5 Zebra Arrays Since every zebra array of size l contains zebra arrays of size l − 1, we use a bottom up approach. The base case is given for k = 1, as any single entry A[i][j] is a 1 × 1 zebra array with i ∈ [n], j ∈ [m]. 1. dimensions of the DP table are ( n + 1) × ( m + 1) 2. solution of the subproblems, i.e. meaning of entry S[i][j] is size k of the largest k × k zebra array with lower right corner at A[i][j] 3. correctness of the recursion is given by the aforementioned observation, that every zebra array consists of only smaller sub-zebra arrays, hence the base case and recurrence relation as deﬁned below base case: for i = 0 \u0000\u0000 n do: S\u00000][i] = 1 for j = 0 \u0000\u0000 m do: S[j][0] = 1 1 2 recurrence relation: for i = 1 \u0000\u0000 n do: for j = 1 \u0000\u0000 m do: i\u0000 A[i][j] != A[i-1][j] t\u0000en: S[i-1][j] + 1 i\u0000 A[i][j] != A[i][j-1] t\u0000en: S[i][j-1] + 1 i\u0000 A[i][j] != A[i-1][j-1] t\u0000en: S[i-1][j-1] + 1 1 2 3 4 5 4. the calculation order is to ﬁrst iterate i over 1 … n, within which we loop j over 1 … m 5. solution can be extracted at S[n][m] 6. runtime of the described algorithm is O( nm) , because of the two nested for loops that iterate over n and m □","libVersion":"0.5.0","langs":""}