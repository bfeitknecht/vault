{"path":"sem2/PProg/VRL/slides/PProg-L18-semaphores.pdf","text":"spcl.inf.ethz.ch @spcl_eth Parallel Programming, Spring 2024, Lecture 18: Deadlocks, Semaphores, Barriers TORSTEN HOEFLER spcl.inf.ethz.ch @spcl_eth Deadlock: two or more processes are mutually blocked because each process waits for another of these processes to proceed. 2 Deadlocks spcl.inf.ethz.ch @spcl_eth Graphically: Threads and Resources (Locks) Thread P attempts to acquire resource a: Resource b is held by thread Q: 3 Threads and Resources x P a A b Q spcl.inf.ethz.ch @spcl_eth A deadlock for threads ğ‘‡1 â€¦ ğ‘‡ğ‘› occurs when the directed graph describing the relation of ğ‘‡1 â€¦ ğ‘‡ğ‘› and resources ğ‘…1 â€¦ ğ‘…ğ‘š contains a cycle. 4 Deadlocks â€“ more formally T1 R3 T2 T4 T3 R4 R2R1 T2 has R3T1 wants R3 spcl.inf.ethz.ch @spcl_eth Deadlock detection in systems is implemented by finding cycles in the dependency graph. â€¢ Deadlocks can, in general, not be healed. Releasing locks generally leads to inconsistent state. Deadlock avoidance amounts to techniques to ensure a cycle can never arise â€¢ two-phase locking with retry (release when failed) â€¢ Usually in databases where transactions can be aborted without consequence â€¢ resource ordering â€¢ Usually in parallel programming where global state is modified 5 Techniques spcl.inf.ethz.ch @spcl_eth class BankAccount { ... synchronized void withdraw(int amount) {â€¦} synchronized void deposit(int amount) {â€¦} ... synchronized void transferTo(int amount, BankAccount a) { this.withdraw(amount); a.deposit(amount); } } 6 Back to our example: what can we do? spcl.inf.ethz.ch @spcl_eth class BankAccount { ... synchronized void withdraw(int amount) {â€¦} synchronized void deposit(int amount) {â€¦} ... void transferTo(int amount, BankAccount a) { this.withdraw(amount); a.deposit(amount); } } 7 Option 1: non-overlapping (smaller) critical sections Money disappears for a (very short?) moment! Can we allow such transient inconsistencies? Very often unacceptable! spcl.inf.ethz.ch @spcl_eth class BankAccount { static Object globalLock = new Object(); // withdraw and deposit protected with globalLock! void withdraw(int amount) {â€¦} void deposit(int amount) {â€¦} ... void transferTo(int amount, BankAccount to) { synchronized (globalLock) { withdraw(amount); to.deposit(amount); } } } 8 Option 2: one lock for all deadlock avoided but no concurrent transfer possible, even not when the pairs of accounts are disjoint. Often very inefficient! spcl.inf.ethz.ch @spcl_eth class BankAccount { ... void transferTo(int amount, BankAccount to) { if (to.accountNr < this.accountNr) synchronized(this){ synchronized(to) { withdraw(amount); to.deposit(amount); }} else synchronized(to){ synchronized(this) { withdraw(amount); to.deposit(amount); }} } } 9 Option 3: global ordering of resources Unique global ordering required. Whole program has to obey this order to avoid cycles. Code taking only one lock can ignore it. spcl.inf.ethz.ch @spcl_eth 10 Ordering of resources P a Q b 1 2 spcl.inf.ethz.ch @spcl_eth class BankAccount { private static final AtomicLong counter = new AtomicLong(); private final long index = counter.incrementAndGet(); ... void transferTo(int amount, BankAccount to) { if (to.index < this.index) ... } } 11 Programming trick No globally unique order available? Generate it: spcl.inf.ethz.ch @spcl_eth 12 Another (historic) example: from the Java standard library class StringBuffer { private int count; private char[] value; â€¦ synchronized append(StringBuffer sb) { int len = sb.length(); if(this.count + len > this.value.length) this.expand(â€¦); sb.getChars(0, len, this.value, this.count); } synchronized getChars(int x, int y, char[] a, int z) { â€œcopy this.value[x..y] into a starting at zâ€ } } Do you find the two problems? spcl.inf.ethz.ch @spcl_eth class StringBuffer { private int count; private char[] value; â€¦ synchronized append(StringBuffer sb) { int len = sb.length(); if(this.count + len > this.value.length) this.expand(â€¦); sb.getChars(0, len, this.value, this.count); } synchronized getChars(int x, int y, char[] a, int z) { â€œcopy this.value[x..y] into a starting at zâ€ } } 13 Another (historic) example: from the Java standard library Problem #1: â–ª Lock for sb is not held between calls to sb.length and sb.getChars â–ª sb could get longer â–ª Would cause append to not append whole string â–ª The semantics here can be discussed! Definitely an issue if sb got shorther â˜º Problem #2: â–ª Deadlock potential if two threads try to append â€œcrossingâ€ StringBuffers, just like in the bank-account first example â–ª x.append(y); y.append(x);Do you find the two problems? Amy Williams, William Thies, and Michael D. Ernst: Static Deadlock Detection for Java Libraries, ECOOPâ€™05 (for deadlock) spcl.inf.ethz.ch @spcl_eth â–ª Not easy to fix both problems without extra overheads: â–ª Do not want unique ids on every StringBuffer â–ª Do not want one lock for all StringBuffer objects â–ª Actual Java library: initially fixed neither (left code as is; changed javadoc) â–ª Up to clients to avoid such situations with own protocols â–ª Today: two classes StringBuffer (claimed to be synchronized) and StringBuilder (not synchronized) 14 Fix? spcl.inf.ethz.ch @spcl_eth Code like account-transfer and string-buffer append are difficult to deal with for deadlock 1. Easier case: different types of objects â–ª Can document a fixed order among types â–ª Example: â€œWhen moving an item from the hashtable to the work queue, never try to acquire the queue lock while holding the hashtable lockâ€ 2. Easier case: objects are in an acyclic structure â–ª Can use the data structure to determine a fixed order â–ª Example: â€œIf holding a tree nodeâ€™s lock, do not acquire other tree nodesâ€™ locks unless they are children in the treeâ€ 15 Perspective and tricks for programmability spcl.inf.ethz.ch @spcl_eth Once understood that (and where) race conditions can occur, with following good programming practice and rules they are relatively easy to cope with. But the Deadlock is the dominant problem of reasonably complex concurrent programs or systems and is therefore very important to anticipate! Starvation denotes the repeated but unsuccesful attempt of a recently unblocked process to continue its execution. 16 Significance of deadlocks spcl.inf.ethz.ch @spcl_eth Semaphores 17 spcl.inf.ethz.ch @spcl_eth â€¢ Locks provide means to enforce atomicity via mutual exclusion â€¢ They lack the means for threads to communicate about changes â–ª e.g., changes in the state â€¢ Thus, they provide no order and are hard to use â–ª e.g., if threads A and B lock object X, it is not determined who comes first â€¢ Example: producer / consumer queues 18 Why do we need more than locks? spcl.inf.ethz.ch @spcl_eth Semaphore Edsger W. Dijkstra 1965 Optische Telegrafievorrichtung mit Hilfe von schwenkbaren Signalarmen, Claude Chappe 1792 Se|ma|phor, das od. der; -s, -e [zu griech. ÏƒÎµÎ¼Î± = Zeichen u. Ï†oÏos = tragend]: Signalmast mit beweglichen FlÃ¼geln. 19 spcl.inf.ethz.ch @spcl_eth Semaphore: integer-valued abstract data type S with some initial value sâ‰¥0 and the following operations* acquire(S) { wait until S > 0 dec(S) } release(S) { inc(S) } 20 Semaphore: Semantics * Dijkstra called them P (probeeren), V (vrijgeven), also often used: wait and signal acquire release (protected)atomicatomic spcl.inf.ethz.ch @spcl_eth mutex = Semaphore(1); lock mutex := mutex.acquire() only one thread is allowed into the critical section unlock mutex := mutex.release() one other thread will be let in Semaphore number: 1 â†’ unlocked 0 â†’ locked x>0 â†’ x threads will be let into â€œcritical sectionâ€ 21 Building a lock with a semaphore spcl.inf.ethz.ch @spcl_eth â–ª Execute in parallel: x = (aT * d) * z â–ª a and d are column vectors â–ª x, z are scalar â–ª Assume each vector has 4 elements â–ª x = (a1*d1 + a2*d2 + a3*d3 + a4*d4) * z â–ª Parallelize on two processors (using two threads A and B) â–ª xA = a1*d1 + a2*d2 â–ª xB = a3*d3 + a4*d4 â–ª x = (xA + xB) * z â–ª Which synchronization is needed where? â–ª Using locks? â–ª Using semaphores? 22 Example: scaled dot product Thread A xA=â€¦; lock(); x=x+xA; unlock() Thread B xB=â€¦; lock(); x=x+xB; unlock() Thread A xA=â€¦; x=x+xA; release(S); Thread B xB=â€¦; acquire(S); x=x+xA; When is x ready? spcl.inf.ethz.ch @spcl_eth â–ª Two processes P and Q executing code. â–ª Rendezvouz: locations in code, where P and Q wait for the other to arrive. Synchronize P and Q. 23 Rendezvous with Semaphores P Q P Q How would you implement this using Semaphores? spcl.inf.ethz.ch @spcl_eth Synchronize Processes P and Q at one location (Rendezvous) Semaphores P_Arrived and Q_Arrived 24 Rendezvous with Semaphores P Q init P_Arrived=0 Q_Arrived=0 pre ... ... rendezvous ? ? post ... .. spcl.inf.ethz.ch @spcl_eth Synchronize Processes P and Q at one location (Rendezvous) Semaphores P_Arrived and Q_Arrived 25 Rendezvous with Semaphores P Q init P_Arrived=0 Q_Arrived=0 pre ... ... rendezvous release(P_Arrived) ? acquire(P_Arrived) ? post ... ... spcl.inf.ethz.ch @spcl_eth Synchronize Processes P and Q at one location (Rendezvous) Semaphores P_Arrived and Q_Arrived 26 Rendezvous with Semaphores P Q init P_Arrived=0 Q_Arrived=0 pre ... ... rendezvous acquire(Q_Arrived) release(P_Arrived) acquire(P_Arrived) release(Q_Arrived) post ... ... Do you find the problem? spcl.inf.ethz.ch @spcl_eth 27 Deadlock P Q init P_Arrived=0 Q_Arrived=0 pre ... ... rendezvous acquire(Q_Arrived) release(P_Arrived) acquire(P_Arrived) release(Q_Arrived) post ... ... P_ArrivedQ_Arrived owned byrequires owned by requires P Q spcl.inf.ethz.ch @spcl_eth 28 Rendezvous with Semaphores Wrong solution with Deadlock pre pre acquire P Q release releaseacquire spcl.inf.ethz.ch @spcl_eth Synchronize Processes P and Q at one location (Rendezvous) Assume Semaphores P_Arrived and Q_Arrived 29 Rendezvous with Semaphores P Q init P_Arrived=0 Q_Arrived=0 pre ... ... rendezvous release(P_Arrived) acquire(Q_Arrived) acquire(P_Arrived) release(Q_Arrived) post ... .. spcl.inf.ethz.ch @spcl_eth Consider a process list QS associated with semaphore S acquire(S) {if S > 0 then dec(S) else put(QS, self) block(self) end } release(S) {if QS == Ã˜ then inc(S) else get(QS, p) unblock(p) end } 30 Digression: Implementing Semaphores without Spinning (blocking queues) acquire release (protected) 10000S QSatomicatomic spcl.inf.ethz.ch @spcl_eth P first Q first 31 Scheduling Scenarios releasepre acquire post pre acquire post releasepre acquire post releasepre acquire post P Q P Q time time release release signals (arrow) acquire may wait (filled box) spcl.inf.ethz.ch @spcl_eth Synchronize Processes P and Q at one location (Rendezvous) Assume Semaphores P_Arrived and Q_Arrived 32 Rendezvous with Semaphores P Q init P_Arrived=0 Q_Arrived=0 pre ... ... rendezvous release(P_Arrived) acquire(Q_Arrived) release(Q_Arrived) acquire(P_Arrived) post ... .. spcl.inf.ethz.ch @spcl_eth P first Q first 33 Thatâ€™s even better. releasepre acquire post releasepre acquire post releasepre acquire post releasepre acquire post P Q P Q release signals (arrow) acquire may wait (filled box) spcl.inf.ethz.ch @spcl_eth â–ª Assume now vectors with 1 million entries on 10,000 threads â–ª Very common! (remember the 57 Pflop/s on 27,360 GPUs on Summit) â–ª How would you implement that? â–ª Semaphores, locks? â–ª Time for a higher-level abstraction! â–ª Supporting threads in bulk-mode Move in lock-step â–ª And enabling a â€œbulk-synchronous parallelâ€ (BSP) model The full BSP is more complex (supports distributed memory) 34 Back to our dot-product spcl.inf.ethz.ch @spcl_eth Barriers 35 spcl.inf.ethz.ch @spcl_eth Synchronize a number of processes. 36 Barrier How would you implement this using Semaphores? spcl.inf.ethz.ch @spcl_eth Synchronize a number (n) of processes. Semaphore barrier. Integer count. 37 Barrier â€“ 1st try P1 P2 ... Pn init barrier = 0; volatile count = 0 pre ... ïƒŸ ïƒŸ ïƒŸ barrier count++ if (count==n) release(barrier) acquire(barrier) post ... Race Condition ! Some wait forever! spcl.inf.ethz.ch @spcl_eth Synchronize a number (n) of processes. Semaphore barrier. Integer count. 38 Barrier P1 P1 ... Pn init barrier = 0; volatile count = 0 pre ... ïƒŸ ïƒŸ ïƒŸ barrier count++ if (count==n) release(barrier) acquire(barrier) post ... Race Condition ! Deadlock ! Invariants Â«Each of the processes eventually reaches the acquire statement\" Â«The barrier will be opened if and only if all processes have reached the barrier\" Â«count provides the number of processes that have passed the barrier\" (violated) Â«when all processes have reached the barrier then all waiting processes can continue\" (violated) spcl.inf.ethz.ch @spcl_eth 39 Recap: Race ConditionProcess PProcess Qx read x reg = x reg = reg +1 x = reg write x write x read x Shared Variable Race Condition reg = x reg = reg -1 x = reg x++ x-- spcl.inf.ethz.ch @spcl_eth 40 With Mutual ExclusionProcess PProcess Q x read x write x write x read x Critical Section Critical Section reg = x reg = reg +1 x = reg reg = x reg = reg -1 x = reg x++ x-- Mutual Exclusion spcl.inf.ethz.ch @spcl_eth Synchronize a number (n) of processes. Semaphores barrier, mutex. Integer count. 41 Barrier P1 P2 ... Pn init mutex = 1; barrier = 0; count = 0 pre ... ïƒŸ ïƒŸ ïƒŸ barrier acquire(mutex) count++ release(mutex) if (count==n) release(barrier) acquire(barrier) release(barrier) post ... turnstile spcl.inf.ethz.ch @spcl_eth 42 Reusable Barrier. 1st trial. P1 ... Pn init mutex = 1; barrier = 0; count = 0 pre ... ïƒŸ ïƒŸ barrier acquire(mutex) count++ release(mutex) if (count==n) release(barrier) acquire(barrier) release(barrier) acquire(mutex) count-- release(mutex) if (count==0) acquire(barrier) post ... Race Condition ! Race Condition ! Dou you see the problem? spcl.inf.ethz.ch @spcl_eth 43 Reusable Barrier. 1st trial. P1 ... Pn init mutex = 1; barrier = 0; count = 0 pre ... ïƒŸ ïƒŸ barrier acquire(mutex) count++ release(mutex) if (count==n) release(barrier) acquire(barrier) release(barrier) acquire(mutex) count-- release(mutex) if (count==0) acquire(barrier) post ... Race Condition ! Race Condition ! Invariants Â«Only when all processes have reached the turnstyle it will be opened the first time\" Â«When all processes have run through the barrier then count = 0\" Â«When all processes have run through the barrier then barrier = 0\" (violated) spcl.inf.ethz.ch @spcl_eth 44 Illustration of the problem: scheduling scenario count++ count=3 â†’ release(barrier) count++ count=3 â†’ release(barrier) count++ (count=1) barrier = 0 barrier = 2 barrier = 1 turnstile(barrier) turnstile(barrier) turnstile(barrier) barrier = 2 spcl.inf.ethz.ch @spcl_eth 45 Reusable Barrier. 2nd trial. P1 ... Pn init mutex = 1; barrier = 0; count = 0 pre ... ïƒŸ ïƒŸ barrier acquire(mutex) count++ if (count==n) release(barrier) release(mutex) acquire(barrier) release(barrier) acquire(mutex) count-- if (count==0) acquire(barrier) release(mutex) post ... Process can pass other processes! Dou you see the problem? spcl.inf.ethz.ch @spcl_eth 46 Reusable Barrier. 2nd trial. P1 ... Pn init mutex = 1; barrier = 0; count = 0 pre ... ïƒŸ ïƒŸ barrier acquire(mutex) count++ if (count==n) release(barrier) release(mutex) acquire(barrier) release(barrier) acquire(mutex) count-- if (count==0) acquire(barrier) release(mutex) post ... Invariants Â«When all processes have passed the barrier, it holds that barrier = 0\" Â« Even when a single process has passed the barrier, it holds that barrier = 0Â» (violated) spcl.inf.ethz.ch @spcl_eth 47 Solution: Two-Phase Barrier init mutex=1; barrier1=0; barrier2=1; count=0 barrier acquire(mutex) count++; if (count==n) acquire(barrier2); release(barrier1) release(mutex) acquire(barrier1); release(barrier1); // barrier1 = 1 for all processes, barrier2 = 0 for all processes acquire(mutex) count--; if (count==0) acquire(barrier1); release(barrier2) signal(mutex) acquire(barrier2); release(barrier2) // barrier2 = 1 for all processes, barrier1 = 0 for all processes Of course, this is very slow in practice, see http://www.spiral.net/software/barrier.html for a specialized fast barrier for x86! spcl.inf.ethz.ch @spcl_eth â–ª Semaphore, Rendevouz and Barrier: â–ª Concurrent programming is prone to errors in reasoning. â–ª A naive approach with trial and error is close-to impossible. â–ª Ways out: â–ª Identify invariants in the problem domain, ensure they hold for your implementation â–ª Identify and apply established patterns â–ª Use known good libraries (like in the Java API) 48 Lesson Learned ? spcl.inf.ethz.ch @spcl_eth Locks are not enough: we need methods to wait for events / notifications Semaphores Rendezvous and Barriers Next lecture: Producer-Consumer Problem Monitors and condition variables 49 Summary","libVersion":"0.3.2","langs":""}