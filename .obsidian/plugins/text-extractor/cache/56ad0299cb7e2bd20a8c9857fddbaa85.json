{"path":"sem2a/DDCA/UE/e/slides/DDCA-LAB04-FSM.pdf","text":"Digital Design & Computer Arch. Lab 4 Supplement: Finite-State Machines (Presentation by Aaron Zeller) Frank K. Gürkaynak Seyyedmohammad Sadrosadati ETH Zurich Spring 2024 [09. April 2024] What Will We Learn? ◼ In Lab 4, you will implement a finite-state machine using Verilog. ◼ Design and implement a simple circuit that emulates the blinking lights of a Ford Thunderbird. ◼ Understand how the clock signal is derived in the FPGA board. ◼ Write an FSM that implements the Ford Thunderbird blinking sequence. 2 Tail Lights of a 1965 Ford Thunderbird ◼ In this lab, you will design a finite-state machine to control the tail lights of a 1965 Ford Thunderbird. 3 Tail Lights of a 1965 Ford Thunderbird ◼ There are three lights on each side that operate in sequence to indicate the direction of a turn. 4 Copyright from ClassicLEDs.com Recall: Finite State Machines (FSMs) ◼ Each FSM consists of three parts: ❑ next state logic ❑ state register ❑ output logic 5 At the beginning of the clock cycle, next state is latched into the state register Part 1: FSM Design ◼ An FSM must do three things: ❑ Next State Logic: Determine the next state from the present state and the inputs. ❑ Output Logic: Determine the output signals based on the present state and input signals. ❑ State Register: keeps track of the present state; must be updated at every clock cycle. The manual contains the details of this FSM specifications. 6 Part 1: FSM Design ◼ An FSM must do three things: ❑ Next State Logic: Determine the next state from the present state and the inputs. ❑ Output Logic: Determine the output signals based on the present state and input signals. ❑ State Register: keeps track of the present state; must be updated at every clock cycle. The manual contains the details of this FSM specifications. 7 For more details, please refer to Lecture 7: • Slides 26+: Finite State Machines • Slides 28+: Moore vs. Mealy FSMs Part 2: Verilog Implementation ◼ always blocks are used in sequential circuits and are used to create circuits involving flipflops. 8 always @ (posedge clk, ...) a <= b; ... Sensitivity List: Whenever a signal in the list changes the body of the always block is executed. Part 2: Verilog Implementation ◼ Do not mix assign statements and always blocks. ◼ assign is used to connect wires. ◼ <= and = inside always blocks are meant to set registers to some value. ❑ = (blocking) : assignments are executed in sequential order. ❑ <= (non-blocking) ❑ Do not mix <= and = in the same always block. 9 Part 2: Verilog Implementation ◼ Do not assign the same register in two different always blocks. 10 always @ (*) a = b; always @ (*) a = c; NO! This should be avoided Part 2: Verilog Implementation ◼ Separate three parts of the code: 11 Verilog Implementation: FSM ◼ The next state logic determines how to transition from the current state to the next state. o Current state: state_p o Next state: state_n 12 inputs state_p This is the general idea and not taken from a solution Part 2: Verilog Implementation ◼ Separate three parts of the code: 13 Verilog Implementation: Flip-Flops ◼ We use a rising-clock-edge triggered flip-flop (with reset) as a state register. ◼ In Verilog we use an always block with the clock signal and the reset signal in the sensitivity list. ◼ The rising-clock-edge is given to us in Verilog by posedge. 14 Verilog Implementation: Flip-Flops 15 This is the general idea and not taken from a solution Part 2: Verilog Implementation ◼ Separate three parts of the code: 16 Verilog Implementation: Output Logic 17 This is the general idea and not taken from a solution Part 3: Implementing the Clock (I) ◼ The problem of using push-buttons as clock: ❑ Compared to the speed of the FPGA the change in a push button is very slow (~ 1 million times slower) ❑ During the slow transition, the FPGA will see many fast occurring transitions and would interpret each of them as a clock edge. (Bouncing) 18 Part 3: Implementing the Clock (II) ◼ CLK100Mhz (W5): Your board contains a 100Mhz crystal oscillator circuit. ◼ Problem: The clock is too fast. ◼ Solution: A clock divider: 19 module clk_div(input clk, input rst, output clk_en); reg [24:0] clk_count; always @ (posedge clk) //posedge defines a rising edge (transition from 0 to 1) begin if (rst) clk_count <= 0; else clk_count <= clk_count + 1; end assign clk_en = &clk_count; endmodule Verilog Implementation: Clock Design 20 module clk_div(input clk, input rst, output clk_en); reg [24:0] clk_count; always @ (posedge clk) //posedge defines a rising edge (transition from 0 to 1) begin if (rst) clk_count <= 0; else clk_count <= clk_count + 1; end assign clk_en = &clk_count; endmodule ◼ &clk_count evaluates to 1 exactly when all bits of clk_count are 1 and 0 otherwise. ◼ This is the case when we counted from 0 to 2^25 – 1. o 2^25 – 1 = 25b'11...1 o Overflow handles the transition from 25b'1...1 to 25b'0...0. ◼ The slowed clock hence ticks every ~2^25 clock ticks. Part 4: Defining the Constraints ◼ We must specify constraints for: ❑ Buttons for control ❑ LEDs for output lights ❑ Connections for clock The manual contains more information about the constraints. 21 Last Words ◼ In Lab 4, you will implement a finite-state machine using Verilog. ◼ Design and implement a simple circuit that emulates the blinking lights of a Ford Thunderbird. ◼ Understand how the clock signal is derived in the FPGA board. ◼ Write an FSM that implements the Ford Thunderbird blinking sequence. ◼ In the report you will implement a dimming function, so that the lights are not only on and off, but can have intermediate levels 22 Report Deadline 23 [26. April 2024 23:59] Digital Design & Computer Arch. Lab 4 Supplement: Finite-State Machines Frank K. Gürkaynak Seyyedmohammad Sadrosadati ETH Zurich Spring 2024 [09. April 2024]","libVersion":"0.3.2","langs":""}