{"path":"sem3/TI/PV/midterm/cheatsheets/TI-cheatsheet-kenji.pdf","text":"TI Definition Sheet Kenji Nakano, HS23 2 Alphabete, W¨orter, Sprachen und die Darstellung von Problemen 2.2 Alphabete, W¨orter und Sprachen Definition 2.1 Eine endlicbe nichtleere Menge Σ heisst Alphabet. Die Elemente eines Alphabets werden Buch- staben (Zeichen, Symbole) genannt. Definition 2.2 Sei Σ ein Alphabet. Ein Wort ¨uber Σ ist eine endliche (eventuell leere) Folge von Buchstaben aus Σ. Das leere Wort λ ist die leere Buchstabenfolge. Die L¨ange |w| eines Wortes w ist die L¨ange des Wortes als Folge, d. h. die Anzahl der Vorkommen von Buchstaben in w. Σ∗ ist die Menge aller W¨orter ¨uber Σ. Σ+ = Σ ∗ − {λ} Definition 2.3 Die Verkettung (Konkatenation) f¨ur ein Alphabet Σ ist eine Abbildung Kon : Σ∗ → Σ∗, so dass f¨ur alle x, y ∈ Σ∗ Kon(x, y) = x · y = xy Definition 2.4 F¨ur ein Wort a = a1a2...an, wobei ai ∈ Σ f¨ur i ∈ {1, 2, ..., n}, bezeichnet a R = anan−1...a1 die Umkehrung (Reversal) von a Definition 2.5 Sei Σ ein Alphabet. F¨ur alle x ∈ Σ∗ und alle i ∈ N definieren wir die i-te Iteration xi von x als x0 = λ, x1 = x und xi = xxi−1 Definition 2.6 Seien v, w ∈ Σ∗ f¨ur ein Alphabet Σ. • v heisst ein Teilwort von w ⇔ ∃x, y ∈ Σ∗ : w = xvy • v heisst ein Pr¨afix von w ⇔ ∃y ∈ Σ∗ : w = vy • v heisst ein Suffix von w ⇔ ∃x ∈ Σ∗ : w = xv • v ̸= λ heisst ein echtes Teilwort (Pr¨afix, Suffix) von w genau dann, wenn v ̸= w und v ein Teilwort (Pr¨afix, Suffix) von w ist 1 Definition 2.7 Seien x ∈ Σ∗ und a ∈ Σ. Dann ist |x|a definiert als die Anzahl der Vorkommen von a in x Definition 2.8 Sei Σ = {s1, s2, ..., sm}, m ≥ 1, ein Alphabet und sei s1 < s2 < ... < sm eine Ordnung auf Σ. Wir definieren die kanonische Ordnung auf Σ∗ f¨ur u, v ∈ Σ∗ wie folgt: u < v ⇔|u| < |v| ∨ |u| = |v| ∧ u = x · si · u ′ ∧ v = x · sj · v′ f¨ur irgendwelche x, u ′, v′ ∈ Σ∗ und i < j Definition 2.9 Eine Sprache L ¨uber einem Alphabet Σ ist eine Teilmenge von Σ ∗. Das Komplement L C der Sprache L bez¨uglich Σ ist die Sprache Σ ∗ − L. L∅ = ∅ ist die leere Sprache. Lλ = {λ} ist die einelementige Sprache, die nur aus dem leeren Wort besteht. Sind L1 und L2 Sprachen ¨uber Σ, so ist L1 · L2 = L1L2 = {vw | v ∈ L1 und w ∈ L2} die Konkatenation von L1 und L2. Ist L eine Sprache ¨uber Σ, so definieren wir: L 0 := Lλ und L i+1 = Li · L f¨ur alle i ∈ N L∗ = ⋃ i∈N Li und L + = ⋃ i∈N−{0} L i L ∗ nennt man den Kleene’schen Stern von L Lemma 2.1 & 2.2 Seien L1, L2 und L3 Sprachen ¨uber einem Alphabet Σ. Dann gilt L1L2 ∪ L1L3 = L1(L2 ∪ L3) L1(L2 ∩ L3) ⊆ L1L2 ∩ L1L3 Lemma 2.3 Es existieren U1, U2, U3 ∈ (Σbool) ∗, so dass U1(U2 ∩ U3) ⊊ U1U2 ∩ U1U3 2 Definition 2.10 Seien Σ1 und Σ2 zwei beliebige Alphabete. Ein Homomorphismus von Σ ∗ 1 nach Σ ∗ 2 ist jede Funktion h : Σ ∗ 1 → Σ∗ 2 mit den folgenden Eigenschaften: (i) h(λ) = λ (ii) h(uv) = h(u) · h(v) f¨ur alle u, v ∈ Σ∗ 1 Wir beobachten leicht, dass es zur Spezifikation eines Homomorphismus reicht, h(a) f¨ur alle Buchstaben a ∈ Σ1 festzulegen. 2.3 Algorithmische Probleme Definition 2.11 Das Entscheidungsproblem (Σ, L) f¨ur ein gegebenes Alphabet Σ und eine gegebene Sprache L ⊆ Σ∗ ist, f¨ur jedes x ∈ Σ∗ zu entscheiden, ob x ∈ L oder x /∈ L Definition 2.12 Seien Σ und Γ zwei Alphabete. Wir sagen, dass ein Algorithmus A eine Funktion (Transformation) f : Σ ∗ → Γ∗ berechnet (realisiert), falls A(x) = f (x) f¨ur alle x ∈ Σ∗ Definition 2.13 Seien Σ und Γ zwei Alphabete, und sei R ⊆ Σ∗ × Γ∗ eine Relation in Σ∗ und Γ ∗. Ein Algorithmus A berechnet R (oder l¨ost das Relationsproblem R), falls f¨ur jedes x ∈ Σ∗, f¨ur das ein y ∈ Gamma ∗ mit (x, y) ∈ R existiert, gilt: (x, A(x)) ∈ R Definition 2.14 Ein Optimierungsproblem ist ein 6-Tupel U = (ΣI , Σ=, L, M, cost, goal) wobei: (todo...) Definition 2.15 Sei Σ ein Alphabet, und sei x ∈ Σ∗. Wir sagen, dass ein Algorithmus A das Wort x generiert, falls A f¨ur die Eingabe λ die Ausgabe x liefert. Definition 2.16 Sei Σ ein Alphabet, und sei L ⊆ Σ∗. A ist ein Aufz¨ahlungsalgorithmus f¨ur L, falls A f¨ur jede Eingabe n ∈ N − {0} die Wortfolge x1, x2, ..., xn ausgibt, wobei x1, x2, ..., xn die kanonisch n ersten W¨orter in L sind. 3 2.4 Kolmogorov-Komplexit¨at Definition 2.17 F¨ur jedes Wort x in(Σbool)∗ ist die Kolmogorov-Komplexit¨at K(x) des Wortes x das Minimum der bin¨aren L¨angen der Pascal-Programme die x generieren. Lemma 2.4 Es existiert eine Konstante d, so dass f¨ur jedes x ∈ (Σbool)∗ K(x) ≤ |x| + d Definition 2.18 Die Kolmogorov-Komplexit¨at einer nat¨urlichen Zahl n ist K(n) = K(Bin(n)) Lemma 2.5 F¨ur jede Zahl n ∈ N − {0} existiert ein Wort wn ∈ (Σbool) n, so dass K(wn) ≥ |wn| = n das heisst, es existiert f¨ur jede Zahl n ein nichtkomprimierbares Wort der L¨ange n. Satz 2.1 Seien A und B Programmiersprachen. Es existiert eine Konstante cA,B, die nur von A und B abh¨angt, so dass f¨ur alle x ∈ (Σbool)∗ gilt |KA(x) − KB(x)| ≤ cA,B Definition 2.19 Ein Wort x ∈ (Σbool)∗ heisst zuf¨allig, falls K(x) ≥ |x|. Eine Zahl n heisst zuf¨allig, falls K(n) = K(Bin(n)) ≥ ⌈log2(n + 1)⌉ − 1. Satz 2.2 Sei L eine Sprache ¨uber Σbool. Sei, f¨ur jedes n ∈ N − {0}, zn das n-te Wort in L bez¨uglich der kanonischen Ordnung. Wenn ein Programm AL existiert, das das Entscheidungsproblem (Σbool, L) l¨ost, dann gilt f¨ur alle n ∈ N − {0}, dass K(zn) ≤ ⌈log2(n + 1)⌉ + c wobei c eine von n unabh¨angige Konstante ist. Satz 2.3 (Primzahlsatz) lim n→∞ Prim(n) n/ln(n) = 1 4 Lemma 2.6 Sei n1, n2, n3, ... eine steigende unendliche Folge nat¨urlicher Zahlen mit K(ni) ≥ ⌈log2(ni)⌉ 2 . F¨ur jedes i ∈ N − {0} sei qi die gr¨osste Primzahl, die die Zahl ni teilt. Dann ist die Menge Q = {qi | i ∈ N − {0}} unendlich Satz 2.4∗ F¨ur unendlich viele k ∈ N gilt Prim(k) ≥ k 217log2(k) · (log2(log2(k)))2 5 3 Endliche Automaten 3.2 Die Darstellungen der endlichen Automaten Definition 3.1 Ein (deterministischer) endlicher Automat (EA) ist ein Quintupel M = (Q, Σ, δ, q0, F ), wobei (i) Q eine endliche Menge von Zust¨anden ist, (ii) Σ ein Alphabet, genannt Eingabealphabet, ist, (iii) q0 ∈ Qder Anfangszustand ist, (iv) F ⊆ Q die Menge der akzeptierenden Zust¨ande ist und (v) δ eine Funktion von Q × Σ nach Q ist, die ¨Ubergangsfunktion genannt wird. Eine Konfiguration von M ist ein Element aus Q × Σ∗ Die Konfiguration (q0, x) ∈ {q0} × Σ∗ heisst die Startkonfiguration von M auf x. Jede Konfiguration aus Q × {λ} nennt man eine Endkonfiguration. Ein Schritt von M ist eine Relation (auf Konfigurationen) ⊢M ⊆ (Q × Σ∗) × (Q × Σ∗) definiert durch (q, w) ⊢M (p, x) ⇔ w = ax, a ∈ Σ und δq, a = p Eine Berechnung C von M ist eine endliche Folge C = C0, C1, ..., Cn von Konfigurationen, so dass Ci ⊢M Ci+1 f¨ur alle 0 ≤ i ≤ n − 1. C ist die Berechnung von M auf einer Eingabe x ∈ Σ∗, falls C0 = (q0, x) und Cn ∈ Q × {λ} eine Endkonfiguration ist. Falls Cn ∈ F × {λ}, sagen wir, dass C eine akzeptierende Berechnung von M auf x ist, und dass M das Wort x akzeptiert. Falls Cn ∈ (Q − F ) × {λ}, sagen wir, dass C eine verwerfende Berechnung von M auf x ist, und dass M das Wort x verwirft (nicht akzeptiert). Die von M akzeptierte Sprache L(M ) ist definiert als L(M ) = {w ∈ Σ∗ | die Berechnung von M auf w endet in einer Endkonfiguration (q, λ) mit q ∈ F } LEA = {L(M ) | M ist ein EA} ist die Klasse der Sprachen, die von endlichen Automaten akzeptiert werden. LEA bezeichnet man auch als die Klasse der regul¨aren Sprachen, und jede Sprache L aus LEA wird regul¨ar genannt. 6 Definition 3.2 Sei M = (Q, Σ, δ, q0, F ) ein endlicher Automat. Wir definieren ⊢ ∗ M als die reflexive und transitive H¨ulle der Schrittrelation ⊢M von M ; daher ist (q, w) ⊢ ∗ M (p, u) ⇔ (q = p und w = u) oder ∃k ∈ N − 0, so dass (i) w = a1a2...aku, ai ∈ Σ f¨ur i = 1, 2, ..., k und (ii) ∃r1, r2, ..., rk−1 ∈ Q, so dass (q, w) ⊢M (r1, a2...aku) ⊢M (r2, a3...aku) ⊢M ...(rk−1, aku) ⊢M (p, u) Wir definieren ˆδ : Q × Σ∗ → Q durch: (i) ˆδ(q, λ) = q f¨ur alle q ∈ Q und (ii) ˆδ(q, wa) = δ(ˆδ(q, w), a) f¨ur alle a ∈ Σ, w ∈ Σ∗, q ∈ Q Daraus folgt, dass L(M ) = {w ∈ Σ∗ | (q0, w) ⊢ ∗ M (p, λ) mit p ∈ F } = {w ∈ Σ∗ | ˆδ(q0, w) ∈ F } 3.3 Simulationen Lemma 3.2 Sei Σ ein Alphabet und seien M1 = (Q1, Σ, δ1, q01, F1) und M2 = (Q2, Σ, δ2, q02, F2) zwei EA. F¨ur jede Mengenoperation ⊙ ∈ {∪, ∩, −} existiert ein EA M , so dass L(M ) = L(M1) ⊙ L(M2) Konstruktion von M Sei M = (Q, Σ, δ, q0, F⊙), wobei (i) Q = Q1 × Q2, (ii) q0 = (q01, q02), (iii) f¨ur alle q ∈ Q1, p ∈ Q2 und a ∈ Σ, δ((q, p), a) = (δ1(q, a), δ2(p, a)), (iv) falls ⊙ = ∪, dann ist F = F1 × Q2 ∪ Q1 × F2, falls ⊙ = ∩, dann ist F = F1 × F2 und falls ⊙ = −, dann ist F = F1 × (Q2 − F2) 7 3.4 Beweise der Nichtexistenz Lemma 3.3 Sei A = (Q, Σ, δA, q0, F ) ein EA. Seien x, y ∈ Σ∗, x ̸= y, so dass (q0, x) ⊢ ∗ A (p, λ) und (q0, y) ⊢ ∗ A (p, λ) f¨ur ein p ∈ Q (also ˆδA(q0, x) = ˆδA(q0, y) = p (x, y ∈ Kl[p])). Dann existiert f¨ur jedes z ∈ Σ∗ ein r ∈ Q, so dass xz und yz ∈ Kl[r], also gilt insbesondere: xz ∈ L(A) ⇔ yz ∈ L(A) Lemma 3.4 (Pumping-Lemma f¨ur regul¨are Sprachen) Sei L regul¨ar. Dann existiert eine Konstante n0 ∈ N, so dass sich jedes Wort w ∈ Σ∗ mit |w| ≥ n0 in drei Teile y, x und z zerlegen l¨asst, das heisst w = yxz, wobei (i) |yx| ≤ n0, (ii) |x| ≥ 1 und (iii) entweder {yx kz | k ∈ N} ⊆ L oder {yx k | k ∈ N} ∩ L = ∅ Satz 3.1 Sei L ⊆ (Σbool)∗ eine regul¨are Sprache. Sei Lx = {y ∈ (Σbool) ∗ | xy ∈ L} f¨ur jedes x ∈ (Σbool)∗. Dann existiert eine Konstante c, so dass f¨ur alle x, y ∈ (Σbool) ∗ K(y) ≤ ⌈log2(n + 1)⌉ + c falls y das n-te Wort in der Sprache Lx ist. 3.5 Nichtdeterminismus Definition 3.3 Ein nichtdeterministischer endlicher Automat (NEA) ist ein Quintupel M = (Q, Σ, δ, q0, F ). Dabei ist (i) Q eine endliche Menge, Zustandsmengs genannt, (ii) Σ ein Alphabet, Eingabealphabet genannt, (iii) q0 ∈ Q der Anfangszustand, (iv) F ⊆ Q die Menge der akzeptierenden Zust¨ande und (v) δ eine Funktion von Q × Σ nach P(Q), ¨Ubergangsfunktion genannt. 8 Eine Konfiguration von M ist ein Element aus Q × Σ∗ Die Konfiguration (q0, x) ∈ {q0} × Σ∗ ist die Startkonfiguration f¨ur das Wort x. Jede Konfiguration aus Q × {λ} nennt man eine Endkonfiguration. Ein Schritt von M ist eine Relation ⊢M ⊆ (Q × Σ∗) × (Q × Σ∗) definiert durch (q, w) ⊢M (p, x) ⇔ w = ax f¨ur ein a ∈ Σ und p ∈ δ(q, a) Die Relation ⊢ ∗ M ist die reflexive und transitive H¨ulle von ⊢M , genau wie bei einem EA. Die Sprache L(M ) = {w ∈ Σ∗ | (q0, w) ⊢ ∗ M (p, λ) f¨ur ein p ∈ F } ist die von M akzeptierte Sprache Zu der ¨Ubergangsfunktion δ definieren wir die Funktion ˆδ von Q ∗ in P(Q) wie folgt: (i) ˆδ(q, λ) = {q} f¨ur jedes q ∈ Q, (ii) ˆδ(q, wa) = {p ∈ Q | es existiert ein r ∈ ˆδ(q, w), so dass p ∈ δ(r, a)} = ⋃ r∈ˆδ(q,w) δ(r, a) f¨ur alle q ∈ Q, a ∈ Σ, w ∈ Σ∗ LN EA = {L(M ) | M ist ein NEA} Satz 3.2 Zu jedem NEA M existiert ein EA A, so dass L(M ) = L(A) Sei M = (Q, Σ, δM , q0, F ) ein NEA. Wir konstruieren einen EA A = (QA, ΣA, δA, q0A, FA) wie folgt: (i) QA = {⟨P ⟩ | P ⊆ Q}, (ii) ΣA = Σ, (iii) q0A = ⟨{q0}⟩, (iv) FA = {⟨P ⟩ | P ⊆ Q und P ∩ F ̸= ∅}, (v) δA ist eine Funktion von QA × ΣA nach QA, die wie folgt definiert ist. F¨ur jedes ⟨P ⟩ ∈ Qa und jedes a ∈ ΣA ist δA(⟨P ⟩, a) = ⟨ ⋃ p∈P δM (p, a)⟩ = ⟨{q ∈ Q | ∈ P , so dass q ∈ δM (p, a)}⟩ 9 4 Turingmaschinen 4.3 Das Modell der Turingmaschine Definition 4.1 Eine Turingmaschine (TM) ist ein 7-Tupel M = (Q, Σ, Γ, δ, q0, qaccept, qreject). Dabei ist (i) Q eine endliche Menge, die Zustandsmenge von M genannt wird, (ii) Σ das Eingabealphabet, wobei ¢ und das Blanksymbol nicht in Σ sind, (iii) Γ ein Alphabet, Arbeitsalphabet genannt, wobei Σ ⊆ Γ, ¢, ∈ Γ, Γ ∩ Q = ∅ (iv) δ : (Q − {qaccept, qreject}) × Γ → Q × Γ × {L, R, N} eine Abbildung, ¨Ubergangsfunktion von M genannt, mit der Eigenschaft δ(q, ¢) ∈ Q × {¢} × {R, N} f¨ur alle q ∈ Q, (v) q0 ∈ Q der Anfangszustand, (vi) qaccept ∈ Q der akzeptierende Zustand, (vii) qreject ∈ Q − {qaccept} der verwerfende Zustand. Eine Konfiguration C von M ist ein Element aus Konf(M ) = {¢} · Γ∗ · Q · Γ+ ∪ {¢} · Γ + Eine Startkonfiguration f¨ur ein Eingabewort x ist q0¢x Ein Schritt von M ist eine Relation ⊢M auf der Menge der Konfigurationen (⊢M ⊆ Konf(M )×Konf(M )) definiert durch (i) x1x2...xi−1qxixi+1...xn ⊢M x1x2...xi−1pyxi+1...xn, falls δ(q, xi) = (p, y, N ) (ii) x1x2...xi−1qxixi+1...xn ⊢M x1x2...xi−2pxi−1yxi+1...xn, falls δ(q, xi) = (p, y, L) (iii) x1x2...xi−1qxixi+1...xn ⊢M x1x2...xi−1ypxi+1...xn, falls δ(q, xi) = (p, y, R) f¨ur i < n und (iv) x1x2...xn−1qxn ⊢M x1x2...xn−1yp , falls δ(q, xn) = (p, y, R) 10 Eine Berechnung von M ist eine (potentiell unendliche) Folge von Konfigurationen C0, C1, C2, ..., so dass Ci ⊢M Ci+1 f¨ur alle i = 0, 1, 2, .... Wenn C0 ⊢M C1 ⊢M ... ⊢M Ci f¨ur ein i ∈ N, dann C0 ⊢ ∗ M Ci. Die Berechnung von M auf einer Eingabe x ist eine Berechnung, die mit der Startkonfigura- tion w1qacceptx beginnt und entweder unendlich ist oder in einer Konfiguration w1qw2 endet, wobei q ∈ {qaccept, qreject}. Die Berechnung von M auf x heisst akzeptierend, falls sie in einer akzeptierenden Konfiguration w1qacceptw2 endet. Die Berechnung von M auf x heisst verwerfend, wenn sie in einer verwerfenden Konfiguration w1qrejectw2 endet. Eine nicht-akzeptierende Berechnung von M auf x ist entweder eine verwerfende oder eine unendliche Berechnung von M auf x Die von der Turingmaschine M akzeptierte Sprache ist L(M ) = {w ∈ Σ∗ | q0¢w ⊢ ∗ M yqacceptz, f¨ur irgendwelche y, z ∈ Γ ∗} Wir sagen, dass M eine Funktion F : Σ∗ → Γ∗ berechnet, falls f¨ur alle x ∈ Σ∗: q0¢x ⊢ ∗ M qaccept¢F (x) Eine Sprache L ⊆ Σ∗ heisst rekursiv aufz¨ahlbar, falls eine TM M existiert, so dass L = L(M ). Die Klasse aller rekursiv aufz¨ahlbaren Sprachen ist definiert wie folgt LRE = {L(M ) | M ist eine TM} Eine Sprache L ⊆ Σ∗ heisst rekursiv (entscheidbar), falls L = L(M ) f¨ur eine TM M , f¨ur die f¨ur alle x ∈ Σ∗ gilt: (i) q0¢x ⊢ ∗ M yqacceptz, y, z ∈ Γ∗, falls x ∈ L und (ii) q0¢x ⊢ ∗ M uqrejectv, u, v ∈ Γ∗, falls x /∈ L Wenn (i) und (ii) gelten, sagen wir, dass M auf jeder Eingabe h¨alt oder dass M immer h¨alt. Die Klasse der rekursiven (algorithmisch erkennbaren) Sprachen ist definiert wie folgt LR = {L(M ) | M ist eine TM, die immer h¨alt} Eine Funktion F : Σ ∗ 1 → Σ∗ 2 f¨ur zwei Alphabete Σ1, Σ2 heisst total berechenbar, falls eine TM M existiert, die F berechnet. 11 4.4 Mehrband-Turingmaschinen und Church’sche These Mehrband-Turingmaschinen Konstruktion Wir k¨onnen die Felder aller (k + 1) B¨ander von links nach rechts nummerieren, beginnen mit 0 bei ¢. So kann man eine Konfiguration einer k-Band-TM M wie folgt darstellen. Eine Konfiguration (q, w, i, u1, i1, u2, i2, ..., uk, ik) ist ein Element aus Q × Σ∗ × N × (Γ ∗ × N) k mit folgender Bedeutung: • M ist im Zustand q, • der Inhalt des Eingabebandes ist ¢w$ und der Lesekopf des Eingabebandes zeigt auf das i-te Feld des Eingabebandes (d.h., fall w = a1a2...an, dann liest der Lesekopf das Symbol ai), • f¨ur j ∈ {1, 2, ..., k} ist der Inhalt des j-ten Bandes ¢uj ..., und ij ≤ |uj| ist die Position des Feldes, auf das der Kopf des j-ten Bandes zeigt. Die Berechnungsschritte von M k¨onnen mit einer Transitionsfunktion δ : Q × (Σ ∪ {¢, $}) k → Q × {L, R, N} × (Γ × {L, R, N}) k beschrieben werden. Die Argumente (q, a, b1, ..., bk) ∈ Q × (Σ ∪ {¢, $})k sind der aktuelle Zustand q, das gelesene Symbol a ∈ Σ ∪ {¢, $} auf dem Eingabeband und die k Symbole b1, ..., bk ∈ Γ, auf denen die K¨opfe der Arbeitsb¨ander stehen. Diese k Symbole werden von den K¨opfen der k Arbeitsb¨ander durch andere Symbole ersetzt, und die Position aller k + 1 K¨opfe wird um maximal 1 ge¨andert. Seien A und B zwei Maschinen (TM, MTM), die mit dem gleichen Eingabealphabet Σ arbeite. Im Folgenden sagen wir, dass eine Maschine A ¨aquivalent zu einer Maschine B ist, falls f¨ur jede Eingabe x ∈ (Σbool) ∗ gilt: (i) A akzeptiert x ⇔ B akzeptiert x, (ii) A verwirft x ⇔ B verwirft x, (iii) A arbeitet unendlich lange auf x ⇔ B arbeitet unendlich lange auf x. Es ist klar, dass L(A) = L(B), wenn A und B ¨aquivalent sind. Die Tatsache L(A) = L(B) garantiert aber nicht, dass A und B ¨aquivalent sind. Lemma 4.1 Zu jeder TM A existiert eine zu A ¨aquivalente 1-Band-TM B. Lemma 4.2 F¨ur jede Mehrband-TM A existiert eine zu A ¨aquivalente TM B. 12 Definition 4.2 Zwei Maschinenmodelle (Maschinenklassen) A und B f¨ur Entscheidungsprobleme sind ¨aquivalent, falls (i) f¨ur jede Maschine A ∈ A eine zu A ¨aquivalente Maschine B ∈ B existiert, und (ii) f¨ur jede Maschine C ∈ B eine zu C ¨aquivalente Maschine D ∈ A existiert. Satz 4.1 Die Maschinenmodelle von Turingmaschinen und Mehrband-Turingmaschinen sind ¨aquivalent. Church’sche These Die Turingmaschinen sind die Formalisierung des Begriffes ”Algorithmus”, d.h., die Klasse der rekur- siven Sprachen (der entscheidbaren Entscheidungsprobleme) stimmt mit der Klasse der algorithmisch (automatisch) erkennbaren Sprachen ¨uberein. 13 4.5 Nichtdeterministische Turingmaschinen Definition 4.3 Eine nichtdeterministische Turingmaschine (NTM) ist ein 7-Tupel M = (Q, Σ, Γ, δ, q0, qaccept, qreject), wobei (i) Q, Σ, Γ, q0, qaccept, qreject die gleiche Bedeutung wie bei einer TM haben, und (ii) δ : (Q − {qaccept, qreject}) × Γ → P(Q × Γ × {L, R, N}) die ¨Ubergangsfunktion von M ist und die folgende Eigenschaft hat: δ(p, ¢) ⊆ {(q, ¢, X) | q ∈ Q, X ∈ {R,N}} f¨ur alle p ∈ Q Eine Konfiguration von M ist ein Element aus Konf(M ) = ({¢} · Γ ∗ · Q · Γ∗) ∪ (Q · {¢}Γ ∗) Die Konfiguration q0¢w ist die Anfangskonfiguration f¨ur das Wort w ∈ Σ∗. Eine Konfiguration heisst akzeptierend, falls sie den Zustand qaccept enth¨alt. Eine Konfiguration heisst verwerfend, falls sie den Zustand qreject enth¨alt. Ein Schritt von M ist eine Relation ⊢M , die auf der Menge der Konfigurationen (⊢M ⊆ Konf(M ) × Konf(M )) wie folgt definiert ist. F¨ur alle p, q ∈ Q und alle x1, x2, ..., xn, y ∈ Γ gilt • x1x2...xi−1qxixi+1...xn ⊢M x1x2...xi−1pyxi+1...xn falls (p, y, N ) ∈ δ(q, xi), • x1x2...xi−2xi−1qxixi+1...xn ⊢M x1x2...xi−2pxi−1yxi+1...xn, falls (p, y, L) ∈ δq, xi, • x1x2...xi−1qxixi+1...xn ⊢M x1x2...xi−1ypxi+1...xn, falls (p, y, R) ∈ δ(q, xi) f¨ur i < n und • x1x2...xn−1qxn ⊢M x1x2...xn−1yp , falls (p, y, R) ∈ δ(q, xn) • x1x2...xi−1qxixi+1...xn ⊢M x1x2...xi−1pyxi+1...xn falls Die von der NTM M akzeptierte Sprache ist L(M ) = {w ∈ Σ∗ | q0¢w ⊢ ∗ M yqacceptz f¨ur irgendwelche y, z ∈ Γ∗} 14 Definition 4.4 Sei M = (Q, Σ, Γ, δ, q0, qaccept, qreject) eine NTM und sei x ein Wort ¨uber dem Eingabealphabet Σ von M . Ein Berechnungsbaum TM,x von M auf x ist ein (potentiell unendlicher) gerichteter Baum mit einer Wurzel, der wie folgt definiert wird. • Jeder Knoten von TM,x ist mit einer Konfiguration beschriftet. • Die Wurzel ist der einzige Knoten TM,x mit dem Eingangsgrad 0 und ist mit der Startkonfigura- tion q0¢x beschriftet. • Jeder Knoten des Baumes, der mit einer Konfiguration C beschriftet ist, hat genauso viele Kinder wie C Nachfolgekonfigurationen hat, und diese Kinder sind mit diesen Nachfolgekonfigurationen von C markiert. Satz 4.2 Sei M eine N T M . Dann existiert eine TM A, so dass (i) L(M ) = L(A) und (ii) falls M immer keine unendlichen Berechnungen auf W¨ortern aus (L(M )) C hat, dann h¨alt A immer. 4.6 Kodierung von Turingmaschinen Kodierung Sei M = (Q, Σ, Γ, δ, q0, qaccept, qreject) eine TM, wobei Q = {q0, q1, ..., qm, qaccept, qreject} und Γ = {A1, A2, ..., Ar} Wir definieren zuerst die Kodierung der einzelnen Symbole wie folgt: Code(qi) = 10 i+11 f¨ur i = 0, 1, ..., m, Code(qaccept) = 10m+21, Code(qreject) = 10m+31, Code(Aj) = 110j11 f¨ur j = 1, ..., r, Code(N ) = 1110111, Code(R) = 11102111, Code(L) = 11103111. Diese Kodierung von Symbolen nutzen wir zu folgender Darstellung einzelner Transitionen. Code(δ(p, Al) = (q, Am, α)) = #Code(p)Code(Al)Code(q)Code(Am)Code(α)# f¨ur jede Transition δ(p, Al) = (q, Am, α), p ∈ {q0, q1, ..., qm}, q ∈ Q, l, m ∈ {1, ..., r}, α ∈ {L, R, N}. Die Kodierung der Turingmaschine M gibt zuerst die globalen Daten - die Anzahl der Zust¨ande (|Q|) und die Anzahl der Symbole aus dem Arbeitsalphabet (|Γ|). Danach folgt die Liste aller Transitionen. Daher Code(M ) = #0 m+3#0r##Code(Transition1)#Code(Transition2)... 15 Definition 4.5 F¨ur jede Turingmaschine M wird Kod(M ) = h(Code(M )) die Kodierung der TM M genannt. KodTM = {Kod(M ) | M ist eine TM} bezeichnet die Menge der Kodierungen aller Turingmaschinen. Es ist klar, dass die Abbildung von M auf Kod(M ) injektiv ist und daher bestimmt Kod(M ) eindeutig eine Turingmaschine. Definition 4.6 Sei x ∈ (Σbool)∗. F¨ur jedes i ∈ N − {0} sagen wir, dass x die Koderung der i-ten TM ist, falls (i) x = Kod(M ) f¨ur eine TM M und (ii) die Menge {y ∈ (Σbool) ∗ | y ist vor x in kanonischer Ordnung} enth¨alt genau i − 1 W¨orter, die Kodierungen von Turingmaschinen sind. Falls x = Kod(M ) die Kodierung der i-ten TM ist, dann ist M die i-te Turingmaschine Mi. Die Zahl i ist die Ordnung der TM Mi. Aver bezeichnet ein Programm (eine TM), das f¨ur jedes x ∈ (Σbool)∗ entscheidet, ob x die Kodierung einer TM ist. Sei Gen eine Funktion von N − {0} nach (Σbool) ∗ definiert durch Gen(i) = Kod(Mi). Lemma 4.3 Die Funktion Gen ist total rekursiv, d.h., es existiert eine Turingmaschine (Programm) AGen, die f¨ur eine gegebene Zahl i die Kodierung Kod(Mi) berechnet. 16 5 Berechenbarkeit 5.2 Die Methode der Diagonalisierung Wir wollen zeigen, dass die M¨achtigkeit —KodTM— der Menge aller Turingmaschinen kleiner als die M¨achtigkeit aller Sprachen ¨uber Σbool ist. Definition 5.1 Seien A und B zwei Mengen. Wir sagen, dass |A| ≤ |B|, falls eine injektive Funktion f von A nach B existiert. Wir sagen, dass |A| = |B| , falls |A| ≤ |B| und |B| ≤ |A| (d.h., es existiert eine Bijektion zwischen A und B). Wir sagen, dass |A| < |B|, falls |A| ≤ |B| und keine injektive Abbildung von B nach A existiert. Definition 5.2 Eine Menge A heisst abz¨ahlbar, falls A endlich ist oder |A| = |N|. Lemma 5.1 Sei Σ ein beliebiges Alphabet. Dann ist Σ ∗ abz¨ahlbar. Satz 5.1 Die Menge KodTM der Turingmaschinenkodierungen ist abz¨ahlbar. Lemma 5.2 & Satz 5.2 (N − {0}) × (N − {0}) ist abz¨ahlbar. Q+ ist abz¨ahlbar. Satz 5.3 [0, 1] ⊆ R ist nicht abz¨ahlbar. Satz 5.4 P((Σbool) ∗) ist nicht abz¨ahlbar. 17 Korollar 5.1 |KodTM| < |P((Σbool) ∗)| und somit existieren unendlich viele nicht rekursiv aufz¨ahlbare Sprachen ¨uber Σbool. Satz 5.5 F¨ur die Diagonalsprache Ldiag, mit Ldiag = {w ∈ (Σbool)∗ | w = wi f¨ur ein i ∈ N − {0} und Mi akzeptiert wi nicht} = {w ∈ (Σbool)∗ | w = wi f¨ur ein i ∈ N − {0} und dii = 0} gilt: Ldiag /∈ LRE =⇒ (Ldiag) C = {x ∈ (Σbool)∗ | x = wi f¨ur ein i ∈ N − {0} und Mi akzeptiert das Wort wi} 5.3 Die Methode der Reduktion Definition 5.3 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. Wir sagen, dass L1 auf L2 rekursiv reduzierbar ist, L1 ≤R L2, falls L2 ∈ LR =⇒ L1 ∈ LR Die Bezeichnung L1 ≤R L2 entspricht der intuitiven Bedeutung, dass L2 bez¨uglich der algorithmischen L¨osbarkeit mindestens so schwer wie L1 ist Definition 5.4 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. Wir sagen, dass L1 auf L2 EE-reduzierbar (Eingabe- zu-Eingabe) ist, L1 ≤EE L2, wenn eine TM M existiert, die eine Abbildung fM : Σ ∗ 1 → Σ∗ 2 mit der Eigenschaft: x ∈ L1 ⇔ fM (x) ∈ L2 f¨ur alle x ∈ Σ∗ 1 berechnet. Wir sagen auch, dass die TM M die Sprache L1 auf die Sprache L2 reduziert Lemma 5.3 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. Falls L1 ≤EE L2, dann auch L1 ≤R L2 Lemma 5.4 Sei Σ ein Alphabet. F¨ur jede Sprache L ⊆ Σ∗ gilt: L ≤R L C und LC ≤R L 18 Korollar 5.2 (Ldiag) C /∈ LR Lemma 5.5 (Ldiag) C ∈ LRE Korollar 5.3 (Ldiag)C ∈ LRE − LR, und daher LR ⊊ LRE Definition 5.5 Die universelle Sprache ist die Sprache LU = {Kod(M )#w | w ∈ (Σbool) ∗ und M akzeptiert w} Satz 5.6 Es gibt ein TM U , universelle TM genannt, so dass L(U ) = LU Daher gilt LU ∈ LRE Satz 5.7 LU /∈ LR Definition 5.6 Das Halteproblem ist das Entscheidungsproblem ({0, 1, #}, LH ), wobei LH = {Kod(M )#x | x ∈ {0, 1} ∗ und M h¨alt auf x} Satz 5.8 LH /∈ LR Lempty = {Kod(M ) | L(M ) = ∅} (Lempty) C = {x ∈ (Σbool)∗ | x ̸= Kod( ¯M ) f¨ur alle TM ¯M oder x = Kod(M ) und L(M ) ̸= ∅} Lemma 5.6 (Lempty) C ∈ LRE 19 Lemma 5.7 (Lempty) C /∈ LR Korollar 5.4 Lempty /∈ LR Korollar 5.5 Die Sprache LEQ = {Kod(M )#Kod( ¯M ) | L(M ) = L( ¯M )} ist nicht entscheidbar (das heisst LEQ /∈ LR) 5.4 Der Satz von Rice Definition 5.7 Eine Sprache L ⊆ KodTM heisst semantisch nichttriviales Entscheidungsproblem, falls folgende Bedingungen gelten: (i) Es gibt eine TM M1, so dass Kod(M1) ∈ L (daher L ̸= ∅) (ii) Es gibt eine TM M2, so dass Kod(M2) /∈ L (daher enth¨alt L nicht die Kodierungen aller Turing- maschinen), (iii) f¨ur zwei Turingmaschinen A und B impliziert L(A) = L(B) Kod(A) ∈ L ⇔ Kod(B) ∈ L Lemma 5.8 LH,λ /∈ LR wobei LH,λ = {Kod(M ) | M h¨alt auf λ} Satz 5.9 (Satz von Rice) Jedes semantisch nichttriviale Entscheidungsproblem ¨uber Turingmaschinen ist unentscheidbar. 20 5.5 Das Post’sche Korrespondenzproblem Definition 5.8 Sei Σ ein Alphabet. Eine Instanz des Post’schen Korrespondenzproblems ¨uber Σ ist ein Paar (A, B), wobei A = w1, ..., wk, B = x1, ..., xk f¨ur ein k ∈ N − {0}, wi, xi ∈ Σ+ f¨ur i = 1, ..., k. F¨ur jedes i ∈ {1, ..., k} wird (wi, xi) ein Dominosteintyp genannt. Wir sagen, dass die Instanz (A, B) des Post’schen Korrespondenzproblems eine L¨osung hat, falls m ∈ N − {0} und i1, i2, ...im ∈ {1, ..., k} existieren, so dass wi1wi2 ...wim = xi1xi2...xim Das Post’sche Korrespondenzproblem (PKP) ist zu entscheiden, ob eine gegebene Instanz des PKP eine L¨osung hat oder nicht. Lemma 5.9 Falls eine Instanz (A, B) des PKP eine L¨osung hat, dann hat (A, B) unendlich viele L¨osungen. Definition 5.9 Sei Σ ein Alphabet. Eine Instanz des modifizierten Post’schen Korrespondenzproblems ¨uber Σ ist ein Paar (C, D), wobei C = u1, ..., uk, D = v1, ..., vk f¨ur ein k ∈ N−{0}, ui, vi ∈ Σ+ f¨ur i = 1, ..., k. Wir sagen, dass die Instanz (C, D) des modifizierten Post’schen Korrespondenzproblems eine L¨osung hat, falls m ∈ N und j1, j2, ..., jm ∈ {1, ..., k} existieren, so dass u1uj1uj2...ujm = v1vj1vj2...vjm Das modifizierte Post’sche Korrespondenzproblem (MPKP) ist zu entscheiden, ob eine gegebene Instanz des MPKP ¨uber einem beliebigen Σ eine L¨osung hat. Lemma 5.10 Falls das PKP entscheidbar ist, dann ist auch das MPKP entscheidbar. Lemma 5.11 Die Entscheidbarkeit von MPKP impliziert die Entscheidbarkeit von LU Satz 5.10 Das PKP ist unentscheidbar. 5.6 Die Methode der Kolmogorov-Komplexit¨at Satz 5.11 Das Problem, f¨ur jedes x ∈ (Σbool) ∗ die Kolmogorov-Komplexit¨at K(x) von x zu berechnen, ist algo- rithmisch unl¨osbar. 21 Lemma 5.12 Falls LH ∈ LR, dann existiert ein Algorithmus zur Berechnung der Kolmogorov-Komplexit¨at K(x) f¨ur jedes x ∈ (Σbool) ∗ 22 6 Komplexit¨atstheorie 6.2 Komplexit¨atsmasse Definition 6.1 Sei M eine Merhband-Turingmaschine oder TM, die immer h¨alt. Sei Σ das Eingabealphabet von M . Sei x ∈ Σ∗ und sei D = C1, C2, ..., Ck die Berechnung von M auf x. Dann ist die Zeitkomplexit¨at TimeM(x) der Berechnung von M auf x definiert durch TimeM(x) = k − 1 also durch die Anzahl der Berechnungsschritte in D. Die Zeitkomplexit¨at von M ist die Funktion TimeM : N → N definiert durch TimeM(n) = max{TimeM (x) | x ∈ Σn} Definition 6.2 Sei k ∈ N − {0}. Sei M eine k-Band-Turingmaschine, die immer h¨alt. Sei C =(q, x, i, α1, i1, α2, i2, ..., αk, ik) mit 0 ≤ i ≤ |x| + 1 und 0 ≤ ij ≤ |αj| f¨ur j = 1, ..., k eine Konfiguration von M. Die Speicherplatzkomplexit¨at von C ist SpaceM(C) = max{|αi| | i = 1, ..., k} Sei C1, C2, ..., Cl die Berechnung von M auf x. Die Speicherplatzkomplexit¨at von M auf x ist SpaceM(x) = max{SpaceM (Ci) | i = 1, ..., l} Die Speicherplatzkomplexit¨at von M ist die Funktion SpaceM : N → N, definiert durch SpaceM(n) = max{SpaceM (x) | x ∈ Σn} Lemma 6.1 Sei k eine positive ganze Zahl. F¨ur jede k-Band TM A, die immer h¨alt, existiert eine ¨aquivalente 1-Band-TM B, so dass SpaceB(n) ≤ SpaceA(n) Lemma 6.2 Sei k eine positive ganze Zahl. F¨ur jede k-Band-TM A existiert eine k-Band-TM B so, dass L(A) = L(B) und SpaceB(n) ≤ SpaceA(n) 2 + 2 23 Definition 6.3 F¨ur jede Funktion f : N → R+ definieren wir O(f (n)) = {r : N → R+ | ∃n0 ∈ N, ∃c ∈ N, so dass f¨ur alle n ≥ n0 : r(n) ≤ c · f (n)} F¨ur jede Funktion r ∈ O(f (n)) sagen wir, dass r asymptotisch nicht schneller w¨achst als f . F¨ur jede Funktion g : N → R+ definieren wir Ω(g(n)) = {s : N → R+ | ∃n0 ∈ N, ∃d ∈ N, so dass f¨ur alle n ≥ n0 : s(n) ≥ 1 d · g(n)} F¨ur jede Funktion s ∈ Ω(g(n)) sagen wir, dass s asymptotisch mindestens so schnell w¨achst wie g. F¨ur jede Funktion h : N → R+ definieren wir Θ(h(n)) = {q : N → R+ | ∃c, d, n0 ∈ N, so dass f¨ur alle n ≥ n0 : 1 d · h(n) ≤ q(n) ≤ c · h(n)} = O(h(n)) ∩ Ω(h(n)) Falls g ∈ Θ(h(n)) sagen wir, dass g und h asymptotisch gleich schnell wachsen. Seien f und g zwei Funktionen von N nach R+. Falls lim n→∞ f (n) g(n) = 0 dann sagen wir, dass g asymptotisch schneller w¨achst als f und wir schreiben f (n) = o(g(n)) Satz 6.1 Es existiert ein Entscheidungsproblem (Σbool, L), so dass f¨ur jede MTM A, die (Σbool, L) entscheidet, eine MTM B existiert, die auch (Σbool, L) entscheidet, und f¨ur die gilt TimeB(n) ≤ log2(TimeA(n)) f¨ur unendlich viele n ∈ N 24 Definition 6.4 Sei L eine Sprache. Seien f und g zwei Funktionen von N nach R. Wir sagen, dass O(g(n)) eine obere Schranke f¨ur die Zeitkomplexit¨at von L ist, falls eine MTM A existiert, so dass A die Sprache L entscheidet und TimeA(n) ∈ O(g(n)). Wir sagen, dass Ω(f (n)) eine untere Schranke f¨ur die Zeitkomplexit¨at von L ist, falls f¨ur jede MTM B, die L entscheidet, TimeB(n) ∈ Ω(f (n)). Eine MTM C heisst optimal f¨ur L, falls TimeC(n) ∈ O(f (n)) gilt und Ω(f (n)) eine untere Schranke f¨ur die Zeitkomplexit¨at von L ist. 6.3 Komplexit¨atsklassen und die Klasse P Definition 6.5 F¨ur alle Funktionen f, g von N nach R+ definieren wir TIME(f ) = {L(B) | B ist eine MTM mit TimeB(n) ∈ O(f (n))}, SPACE(g) = {L(A) | A ist eine MTM mit SpaceA(n) ∈ O(g(n))}, DLOG = SPACE(log2n), P = ⋃ c∈N TIME(nc), PSPACE = ⋃ c∈N SPACE(nc) und EXPTIME = ⋃ d∈N TIME(2 nd ). Lemma 6.3 F¨ur jede Funktion t : N → R+ gilt TIME(t(n)) ⊆ SPACE(t(n)) Korollar 6.1 P ⊆ PSPACE 25 Definition 6.6 Eine Funktion s : N → N heisst platzkonstruierbar, falls eine 1-Band-TM M existiert, so dass (i) SpaceM (n) ≤ s(n) f¨ur alle n ∈ N und (ii) f¨ur jede Eingabe 0n, n ∈ N, generiert M das Wort 0s(n) auf ihrem Arbeitsband und h¨alt in qaccept. Eine Funktion t : N → N heisst zeitkonstruierbar, falls eine MTM A existiert, so dass (i) TimeA(n) ∈ O(t(n)) und (ii) f¨ur jede Eingabe 0 n, n ∈ N generiert A das Wort 0 t(n) auf dem ersten Arbeitsband und h¨alt in qaccept. Lemma 6.4 Sei s : N → N eine platzkonstruierbare Funktion. Sei M eine MTM mit SpaceM (x) ≤ s(|x|) f¨ur alle x ∈ L(M ). Dann existiert eine MTM A mit L(A) = L(M ) und SpaceA(n) ≤ s(n) d.h., es gilt SpaceA(y) ≤ s(|y|) f¨ur alle y ¨uber dem Eingabealphabet von M . Lemma 6.5 Sei t : N → N eine zeitkonstruierbare Funktion. Sei M eine MTM mit TimeM (x) ≤ t(|x|) f¨ur alle x ∈ L(M ). Dann existiert eine MTM A mit L(A) = L(M ) und TimeA(n) ∈ O(t(n)) Satz 6.2 F¨ur jede Funktion s mit s(n) ≥ log2(n) gilt SPACE(s(n)) ⊆ ⋃ c∈N TIME(c s(n)) Korollar 6.2 DLOG ⊆ P und PSPACE ⊆ EXPTIME =⇒ DLOG ⊆ P ⊆ PSPACE ⊆ EXPTIME 26 Satz 6.3 (Hierarchies¨atze) Seien s1 und s2 zwei Funktionen von N nach N mit folgenden Eigenschaften: (i) s2(n) ≥ log2n (ii) s2 ist platzkonstruierbar und (iii) s1(n) = o(s2(n)). Dann gilt SPACE(s1) ⊊ SPACE(s2) Satz 6.4 (Hierarchies¨atze) Seien t1 und t2 zwei Funktionen von N nach N mit folgenden Eigenschaften: (i) t2 ist zeitkonstruierbar und (ii) t1(n) · log2(t1(n)) = o(t2(n)). Dann gilt TIME(t1) ⊊ TIME(t2) Ein Algorithmus A wird polynomieller Algorithmus genannt wenn TimeA(n) ∈ O(nc) f¨ur eine Konstante c. Ein Problem ist praktisch l¨osbar genau dann, wenn ein polynomieller Algorithmus zu seiner L¨osung existiert. Die Klasse P ist die Klasse der praktisch entscheidbaren Probleme. 27 6.4 Nichtdeterministische Komplexit¨atsmasse Definition 6.7 Sei M eine NTM oder eine nichtdeterministische MTM. Sei x ∈ L(M ) ⊆ Σ∗. Die Zeitkomplexit¨at von M auf x, TimeM(x), ist die L¨ange einer k¨urzesten akzeptierenden Berechnung von M auf x. Die Zeitkomplexit¨at von M ist die Funktion TimeM : N → N, definiert durch TimeM(n) = max({TimeM (x) | x ∈ L(M ) und |x| = n} ∪ {0}) Sei C = C1, C2, ..., Cm eine akzeptierende Berechnung von M auf x. Sei SpaceM (Ci) die Speicher- platzkomplexit¨at der Konfiguration Ci. Wir definieren SpaceM(C) = max{SpaceM (Ci) | i = 1, 2, ..., m} Die Speicherplatzkomplexit¨at von M auf x ist SpaceM(x) = min{SpaceM (C) | C ist eine akzeptierende Berechnung von M auf x} Die Speicherplatzkomplexit¨at von M ist die Funktion SpaceM : N → N definiert durch SpaceM(n) = max({SpaceM (x) | x ∈ L(M ) und |x| = n} ∪ {0}) Definition 6.8 F¨ur alle Funktionen f, g : N → R+ definieren wir NTIME(f ) = {L(M ) | M ist eine nichtdeterministische MTM mit TimeM (n) ∈ O(f (n))}, NSPACE(g) = {L(M ) | M ist eine nichtdeterministische MTM mit SpaceM (n) ∈ O(g(n))}, NLOG = NSPACE(log2n), NP = ⋃ c∈N NTIME(nc) und NSPACE = ⋃ c∈N NSPACE(nc) Lemma 6.6 F¨ur alle Funktionen t und s mit s(n) ≥ log2n gilt: (i) NTIME(t) ⊆ NSPACE(t), (ii) NSPACE(s) ⊆ ⋃ c∈N NTIME(c s(n)) 28 Satz 6.5 F¨ur jede Funktion t : N → R+ und jede platzkonstruierbare Funktion s : N → N mit s(n) ≥ log2n gilt (i) TIME(t) ⊆ NTIME(t), (ii) SPACE(t) ⊆ NSPACE(t) und (iii) NTIME(s(n)) ⊆ SPACE(s(n)) ⊆ ⋃c∈N TIME(c s(n)) Korollar 6.3 NP ⊆ PSPACE Satz 6.6 F¨ur jede platzkonstruierbare Funktion s, s(n) ≥ log2n, gilt NSPACE(s(n)) ⊆ ⋃ c∈N TIME(c s(n)) Korollar 6.4 NLOG ⊆ P und NPSPACE ⊆ EXPTIME Satz 6.7 (Satz von Savitch) Sei s mit s(n) ≥ log2n eine platzkonstruierbare Funktion. Dann gilt NSPACE(s(n)) ⊆ SPACE(s(n)2) Korollar 6.5 PSPACE = NPSPACE Fundamentale Komplexit¨atsklassenhierarchie der sequentiellen Berechnungen DLOG ⊆ NLOG ⊆ P ⊆ NP ⊆ PSPACE ⊆ EXPTIME 6.5 Die Klasse NP und Beweisverifikation SAT = {x ∈ (Σlogic) ∗ | x kodiert eine erf¨ullbare Formel in KNF} 29 Definition 6.9 Sei L ⊆ Σ∗ eine Sprache und sei p : N → N eine Funktion. Wir sagen, dass eine MTM (ein Algorithmus) A ein p-Verifizierer f¨ur L ist, V(A) = L, falls A mit folgenden Eigenschaften auf allen Eingaben aus Σ∗ × (Σbool) ∗ arbeitet: (i) TimeA(w, x) ≤ p(|w|) f¨ur jede Eingabe (w, x) ∈ Σ∗ × (Σbool) ∗. (ii) F¨ur jedes w ∈ L existiert ein x ∈ (Σbool)∗, so dass |x| ≤ p(|w|) und (w, x) ∈ L(A) (d.h., A akzeptiert (w, x)). Das Wort x nennt man einen Beweis oder einen Zeugen der Behauptung w ∈ L. (iii) F¨ur jedes y /∈ L gilt (y, z) /∈ L(A) f¨ur alle z ∈ (Σbool) ∗ Falls p(n) ∈ O(nk) f¨ur ein k ∈ N, so agen wir, dass A ein Polynomialzeit-Verifizierer ist. Wir definieren die Klasse der in Polynomialzeit verifizierbaren Sprachen als VP = {V (A) | A ist ein Polynomialzeit-Verifizierer} Weiter: V (A) = {w ∈ Σ∗ | es existiert ein x ∈ (Σbool)∗ mit |x| ≤ p(|w|), so dass (w, x) ∈ L(A)} Satz 6.8 VP = NP 6.6 NP-Vollst¨andigkeit Definition 6.10 Seien L1 ⊆ Σ∗ 1 und L2 ⊆ Σ∗ 2 zwei Sprachen. Wir sagen, dass L1 polynomiell auf L2 reduzierbar ist, L1 ≤p L2, falls eine polynomielle TM (ein polynomieller Algorithmus) A existiert, die f¨ur jedes Wort x ∈ Σ∗ 1 ein Wort A(x) ∈ Σ∗ 2 berechnet, so dass x ∈ L1 ⇐⇒ A(x) ∈ L2 A wird eine polynomielle Reduktion von L1 auf L2 genannt. Definition 6.11 Eine Sprache L ist NP-schwer, falls f¨ur alle Sprachen L ′ ∈ NP gilt L ′ ≤p L. Eine Sprache L ist NP-vollst¨andig, falls (i) L ∈ NP und (ii) L ist NP-schwer Lemma 6.7 Falls L ∈ P und L ist NP-schwer, dann gilt P = NP 30 Satz 6.9 (Satz von Cook) SAT ist NP-vollst¨andig Lemma 6.8 Seien L1 und L2 zwei Sprachen. Falls L1 ≤p L2 und L1 ist NP-schwer, dann ist auch L2 NP-Schwer. Von nun an: Von nun an wird direkt mit Objekten anstatt Kodierungen gearbeitet: SAT = {Φ | Φ ist eine erf¨ullbare Formel in KNF} CLIQUE = {(G, k) | G ist ein ungerichteter Graph, der eine k-Clique enth¨alt} VC = {(G, k) | G ist ein ungerichteter Graph mit einer Knoten¨uberdeckung (vertex cover) der M¨achtigkeit h¨ochstens k} Lemma 6.9, 6.10, 6.11 SAT ≤p CLIQUE CLIQUE ≤p VC SAT ≤p 3SAT 31","libVersion":"0.3.2","langs":""}