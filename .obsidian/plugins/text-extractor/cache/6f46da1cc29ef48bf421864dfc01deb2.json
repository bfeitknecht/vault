{"path":"sem5/NumCS/UE/e/NumCS-u00-e.pdf","text":"D-MATH Numerische Methoden HS 2025 Dr. Vasile Gradinaru Serie 1 Besprechung: Mo. 22.9, in den ¨Ubungsgruppen 1. Erste Schritte in Python Diese Serie ist eine Einf¨uhrung ins wissenschaftliche Rechnen in Python. Wir werden lernen effizient, lesbaren Python code zu schreiben. Es gibt auch andere Tutorials. Welches ihr durcharbeitet ist nicht wichtig. Eigentliche Aufgaben gibt es in Aufgabe 4, 5, 7. Wenn ihr diese l¨osen k¨onnt, dann reichen eure Python-Kentnisse f¨urs Erste. • Ein Tutorial f¨ur Studierende mit C++ Vorkenntnisse https://lec.inf.ethz.ch/tutorials/cpp-to-py • Scipy lecture notes: https://lectures.scientific-python.org/ Die Syntax f¨ur eine Funktion ist: def function_name(argument): \"\"\"Dies ist eine 'docstring'. Die docstring beschreibt was die Funktion macht. \"\"\" print(argument) return 42.0 def another_function(): \"\"\"Lest den Abschnitt ueber gute Kommentare.\"\"\" # Gibt -42.0 zurueck. <-- Uhm, ja. Offensichtlich, # aber wiso -42.0?? return -42.0 In Python beginnt ein neuer Codeblock immer mit einem :. Der darauf folgende Block muss einger¨uckt werden. Der Standard sagt man soll mit 4 Leerschl¨agen einzur¨ucken. Der Block endet mit dem Indentlevel. Funktionen k¨onnen und sollten mit einer docstring kommentiert werden. Die erste Zeile der docstring ist ein kurzer pr¨aziser Satz. Falls mehr gesagt werden muss, folgt eine leere Zeile und danach beliebig viel Text. Kommentare sind ¨ausserst wichtig aber nicht alle Kommentare sind n¨utzlich. Man muss trainie- ren gute Kommentare zu schreiben. Nicht immer ist ein Kommentar die beste L¨osung um den Code leserlicher zu machen. Manchmal sollte man den Code umschreiben, damit er leichter zu Bitte wenden! verstehen ist. Eventuell braucht es eine neue Funktion, oder einen besseren Funktionsnamen. Dies wird deutlich beschrieben in Robert C. Martin, Clean Code. Wir wollen den Code ausprobieren. Dazu speichern wir den Code in einer Datei functions.py und testen den code in ipython. $ ipython3 functions.py Nichts geschieht. $ ipython3 -i functions.py Diesmal passiert fast nichts, aber jetzt seid ihr in IPython drin. Ihr k¨onnt direkt Code aupro- bieren In [1]: function_name(\"this is a string, i.e. text\") this is a string, i.e. text Out[1]: 42.0 Modifiziert function_name, z.B. ersetzt 42.0 mit 43.0. In [2]: function_name(3) 3 Out[2]: 42.0 Seltsam, die Funktion gibt immer noch 42.0 zur¨uck. Man kann die Funktionen neuladen indem man das script nochmals ausf¨uhrt: In [3]: run functions.py Beendet IPython mit Ctrl+d oder exit. ¨Uberigens kann ein laufendes Script mit Ctrl+c ab- gebrochen werden. 2. Sequenzen Schreiben Sie ein Programm sequences.py welches k = 2i+1 f¨ur i = 0, 1, . . . , 10 untereinander im Terminal ausgibt. Hinweise: range und f-strings. 3. Wurzel einer positiven Zahl Das Newton-Verfahren zur Berechnung der Wurzel einer positiven Zahl a ist gegeben durch xk = 1 2 ( xk−1 + a xk−1 ) x0 = 2a Schreiben Sie ein Programm newton.py, welches √a bis auf eine gewisse Genauigkeit |xk − xk−1| ≤ τ berechnet, und anschliessend die Approximation von √a und die dazu ben¨otige Anzahl an Iterationen k im Terminal ausgibt. Probieren Sie Ihr Programm mit τ = 10 −5 und a = 7. Tipp: Es kann n¨utzlich sein, eine while-Schleife zu verwenden: while Bedingung : Anweisungsblock Siehe n¨achstes Blatt! und die Funktion abs, die unter numpy verf¨ugbar ist. 4. Arrays erstellen in Python Die wichtigste Datenstruktur f¨ur numerisches Programmieren ist das mehrdimensionale Array. Das Paket daf¨ur heisst numpy. F¨ur diese Aufgabe werden wir Python interaktiv benutzen. Startet ipython3. Kleine strukturlose Arrays erstellt man so: In [1]: import numpy as np In [2]: x = np.array([19.0, 12.0, -3.0]) In [3]: A = np.array([[1.0, 0.0], [1.0, 4.0]]) Arrays mit lauter Nullen In [4]: A = np.zeros((3, 4)) In [5]: A In [6]: A.shape In der ersten Aufgabe haben wir Docstrings gesehen. Wir k¨onnen den Docstring einer beliebigen Funktion aufrufen: In [7]: ?np.empty Ganz praktisch, wenn man keinen Internetzugang hat. Dies erstellt ein eindimensionales Array aufeinander folgenden Zahlen: In [8]: ?np.arange In [9]: x = np.arange(4) In [10]: x = np.arange(3, 10) Beachtet, dass die letzte Zahl nicht mit dabei ist, die erste aber schon. Es sind also 4 Elemente in np.arange(4). In [11]: np.arange(4).size Ein uniformes Gitter in einer Dimension erstellt man am einfachsten mit: In [12]: ?np.linspace In [13]: np.linspace(0.0, 1.0, 5) Die Funktion np.meshgrid eignet sich f¨ur rechteckige Gitter in zwei Dimensionen. Ein 3 × 5 Gitter auf [1, 2] × [3, 4] erstellt man so: In [14]: x = np.linspace(1, 2, 3) In [15]: y = np.linspace(3, 4, 5) In [16]: X, Y = np.meshgrid(x, y) Bitte wenden! 5. Contour Plots. Sei f (x, y) = sin(2π(x2 + y)), (1) mit (x, y) ∈ R2. • Plotten Sie H¨ohenlinien von f . Hinweis: contour aus matplotlib. • Plotten Sie sowohl die H¨ohenlinien also auch eine konstante Farbe zwischen den H¨ohenlinien, ein sogenannter gef¨ullter Contourplot. Hinweis: contourf aus matplotlib. • Plotten Sie einen Colorplot. Hinweis: Verwenden Sie pcolormesh. 6. Die Julia Menge. Sei f (z) = z2 − 0.4 + 0.6i und D = [−1, 1]2 ⊂ C. F¨ur 1000 × 1000 Punkte z ∈ D berechne g(z) = max{n ∈ N : |f n(z)| < 100}. (2) Plotte log g mittels import numpy as np import matplotlib.pyplot as plt ... plt.pcolormesh(np.real(z), np.imag(z), np.log(n_times_finite)) Das Problem ist so gew¨ahlt, dass eine einfache, elegante L¨osung existiert. Falls irgendein Schritt kompliziert oder m¨uhsam wird sollte man in die Referenzl¨osung schauen. Schrittweise Anleitung: (a) Implementiere f . (b) Berechne ein 1D Gitter auf [0, 1]. (c) Berechne ein 2D Gitter auf [0, 1]2 ⊂ R2. (d) Berechne ein Gitter f¨ur D ⊂ C. Verwende die Abbildung z = x + iy. Die imagin¨are Einheit ist in Python 1.0j. (e) F¨ur k < n, berechne f (f k−1(z)) und ¨uberpr¨ufe ob der Wert endlich, d.h im Betrag kleiner als 100, ist. Numpy macht dies leicht: y[np.abs(x) < 100] += 1.0. W¨ahle n = 60 oder so. (f) Plotte log g. Falls es klappt und Ihnen die Bilder gefallen, k¨onnen sie die Aufl¨osung erh¨ohen und n = 600 setzen. Mit Ctrl+C k¨onnen Sie ein Skript abbrechen. Die Farben kann man via einer sogenannten colormap ¨andern. Siehe n¨achstes Blatt! 7. Stencil Operationen in Numpy In vielen Algorithmen findet man yi = f (xi−1, xi, xi+1), i = 1, · · · , n. (3) Hier sind uns die Spezialf¨alle i = 1 und i = n egal. Damit wir eine solche Operation implementieren k¨onnen brauchen wir “slices”. ¨Offnet wieder ein interaktives IPython. In [1]: import numpy as np In [2]: A = np.arange(3*4).reshape((3, 4)) In [3]: A In [4]: A[:,0] In [5]: A[1,:] In [6]: A[1:,:] In [7]: A[1:-1,:] Das reicht um einen 3-Punkte Stencil zu implementieren. # -*- coding: utf-8 -*- import numpy as np def stencil(y, dx): \"\"\"Zeigt wie man einen simplen Stencil implementiert. Berechnet die approximative zweite Ableitung der gegebenen Punktwerte. y : array_like Dies sind die Punktwerte der Funktion von der die zweite Ableitung berechnet wird. dx : double Gitterkonstante, delta x = x[1] - x[0]. \"\"\" # Sehr kurze, logisch ¨ausserst eng verkn¨upfte Zuweisungen # darf man auf eine Zeile schreiben. left, middle, right = y[:-2], y[1:-1], y[2:] return ((right - middle)/dx - (middle - left)/dx)/dx x = np.linspace(0, 1, 1000) y = np.sin(2.0*np.pi*x) stencil(y, x[1] - x[0]) Im oberen Beispiel sind left, middle, right keine Kopien von y sondern eine view. Das heisst, left sieht den gleichen Speicher wie y, jedoch ist das Array k¨urzer. middle zeigt auch wieder auf den gleichen Speicher, aber die Indizes sind verschoben. Bitte wenden! (a) Im Beispiel wird die Operation (b - a)/dx drei mal verwendet. Eigentlich k¨onnte man das mit weniger Wiederholungen schreiben. Implementiert first_derivative(y, dx). Schreibt eine neue Funktion second_derivative, welche first_derivative zweimal auf- ruft. Testet second_derivative in dem ihr die Werte mit stencil vergleicht. Tipp: np.abs, np.all. (b) Z¨ahlt die Anzahl FLoating-point OPerations (FLOP) in stencil und second_derivative und ¨uberlegt ob man dies weiter optimieren k¨onnte. (c) Messt die Laufzeit der drei Implementationen. Tipp: timeit. (d) Explizite Schlaufen seien langsam in Python. Stimmt das ¨uberhaupt? Falls ja, wie viel langsamer? 8. Operation entlang bestimmter Achsen Die Dimension eines Arrays ist die Anzahl Achsen die es besitzt. Ein paar Beispiele: In [1]: x = np.empty(34) # Eine Achse, eindimensional. In [2]: x = np.empty((34,3)) # Zwei Achsen, zwei-dimensional. In [3]: x[:,0] # ist ein slice entlang der ersten Achse. Die Funktionen np.max, np.min, np.sum sind Reduktionen. Als Argument nehmen sie ein Array und geben einen Skalar zur¨uck. Es ist nicht immer gew¨unscht, dass die Reduktion ¨uber das ganze Array geschieht, manmal will man die Reduktion nur entlang einer bestimmen Achse ausf¨uhren. Die meisten Reduktionen in Numpy akzeptieren ein Argument axis. Wir schauen uns ein Beispiel an: In [4]: x = np.random.random((2, 3, 1000)) In [5]: np.max(x, axis=2) In [6]: np.min(x, axis=-1) 9. Broadcasting Das letzte Thema welches besprochen werden muss ist broadcasting. Wer ?np.ndarray.shape und ?np.ndarray.reshape noch nicht durchgelesen und ausprobiert hat, sollte dies nun tun. In [1]: x = np.arange(4*5).reshape((4,-1)) In [2]: y = np.arange(4).reshape((4, 1)) In [3]: x + y Dies ist erstaunlich, weil A und x nicht die gleiche Form (shape) haben. Falls zwei Arrays x und y die gleiche Dimension haben und die gleiche Anzahl Elemente entlang jeder Achse mit mehr als einem Element haben, dann wird broadcasting angewandt. Dies be- deutet, dass entlang Achsen mit einem Element das Array mit Kopien von sich selbst aufgef¨ullt wird, bis die Form zum anderen Array passt. Siehe n¨achstes Blatt! [[1, 2, 3]] + [[1, 2, 3], --> [[1, 2, 3], + [[1, 2, 3], [2, 3, 4]] [1, 2, 3]] [2, 3, 4]] [[1, 2, 3]] + [[1], --> [[1, 2, 3], + [[1, 1, 1], [2]] [1, 2, 3]] [2, 2, 2]] Falls die zwei Arrays eine underschiedliche Dimension haben, dann wird zuerst von links mit Achsen mit einem Element aufgef¨ullt und dann versucht broadcasting anzuwenden. Auch dazu ein Beispiel: [ 1, 2, 3] + [[1], --> [[1, 2, 3]], + [[1], [2]] [2]] --> [[1, 2, 3], + [[1, 1, 1], [1, 2, 3]] [2, 2, 2]] Aufgepasst, die leeren Achsen werden links hinzugef¨ugt: [ 1, 2, 3] + [[1, 2]] --> [[1, 2, 3]] + [[1, 2]] --> Exception Shape: (3,) + (1, 2) --> (1, 3) + (1, 2) Oft wird reshape benutzt um leere Achsen einzuf¨ugen, damit broadcasting klappt. In diesem Fall kann np.newaxis n¨utzlich sein. In [4]: A = np.arange(2*3*4).reshape(2, 3, 4) In [5]: B = np.arange(2*4).reshape(2, 4) In [6]: A + B In [7]: A + B.reshape((A.shape[0], 1, A.shape[2])) In [8]: A + B[:,np.newaxis,:] (a) In Aufgabe 4, ersetzt meshgrid durch geeignetes broadscasting im Schritt (d). 10. PDB der Python Debugger [Optional] Den Debugger muss man nicht gleich am ersten Tag kennen lernen. Wer schon genug gelernt hat f¨ur einen Tag kann dieses Kapitel ein andermal durcharbeiten. PDB ist ein Debugger. Ein Debugger hilft Code zu debuggen. Er erm¨oglicht es Zeile f¨ur Zeile zu verfolgen, wie der Code ausgef¨uhrt wird und welche Werte in beliebigen Variabeln gespeichert sind. Lasst euch nicht vom archaischen Interface abschrecken. PDB ist besser als printf debugging. Ein cheat-sheet ist empfehlenswert. 11. Fortgeschrittenes IPython [Optional] IPython verf¨ugt ¨uber interessante profiling tools. Jupyter erm¨oglicht ein Mathematica ¨ahnliches Interface. Bedenkt, dass ihr an der Pr¨ufung Pythonskripte schreiben m¨usst, ihr werdet Jupyter nicht benutzen k¨onnen. Aber ihr lernt nicht nur f¨ur die Pr¨ufung. Plotten in IPython braucht plt.show(), in Jupyther hat das kein Effekt, in CodeExpert braucht man plt.savefig(\"./cx_out/nameofpic.png\").","libVersion":"0.5.0","langs":""}