{"path":"sem2a/DDCA/VRL/slides/DDCA-L14b-MIPS-prog.pdf","text":"Carnegie Mellon 1 Digital Design and Computer Architecture Mohammad Sadrosadati Frank K. Gürkaynak Adapted from Digital Design and Computer Architecture, David Money Harris & Sarah L. Harris ©2007 Elsevier http://safari.ethz.ch/ddca MIPS Programming Carnegie Mellon 2 In This Lecture ¢ Small review from last week ¢ Programming (continued) ¢ Addressing Modes ¢ Lights, Camera, Action: Compiling, Assembling, and Loading ¢ Odds and Ends Carnegie Mellon 3 Assembly Language ¢ To command a computer, you must understand its language § Instructions: words in a computer’s language § Instruction set: the vocabulary of a computer’s language ¢ Instructions indicate the operation to perform and the operands to use § Assembly language: human-readable format of instructions § Machine language: computer-readable format (1’s and 0’s) ¢ MIPS architecture: § Developed by John Hennessy and colleagues at Stanford in the 1980’s § Used in many commercial systems (Silicon Graphics, Nintendo, Cisco) ¢ Once you’ve learned one architecture, it’s easy to learn others Carnegie Mellon 4 Operands: Registers ¢ Main Memory is slow ¢ Most architectures have a small set of (fast) registers § MIPS has thirty-two 32-bit registers ¢ MIPS is called a 32-bit architecture because it operates on 32-bit data § A 64-bit version of MIPS also exists, but we will consider only the 32- bit version Carnegie Mellon 5 The MIPS Register Set Name Register Number Usage $0 0 the constant value 0 $at 1 assembler temporary $v0-$v1 2-3 procedure return values $a0-$a3 4-7 procedure arguments $t0-$t7 8-15 temporaries $s0-$s7 16-23 saved variables $t8-$t9 24-25 more temporaries $k0-$k1 26-27 OS temporaries $gp 28 global pointer $sp 29 stack pointer $fp 30 frame pointer $ra 31 procedure return address Carnegie Mellon 6 Operands: Memory ¢ Too much data to fit in only 32 registers ¢ Store more data in memory § Memory is large, so it can hold a lot of data § But it’s also slow ¢ Commonly used variables kept in registers ¢ Using a combination of registers and memory, a program can access a large amount of data fairly quickly Carnegie Mellon 7 Machine Language ¢ Computers only understand 1’s and 0’s ¢ Machine language: binary representation of instructions ¢ 32-bit instructions § Again, simplicity favors regularity: 32-bit data, 32-bit instructions, and possibly also 32-bit addresses ¢ Three instruction formats: § R-Type: register operands § I-Type: immediate operand § J-Type: for jumping (we’ll discuss later) Carnegie Mellon 8 R-Type ¢ Register-type, 3 register operands: § rs, rt: source registers § rd: destination register ¢ Other fields: § op: the operation code or opcode (0 for R-type instructions) § funct: the function together, the opcode and function tell the computer what operation to perform § shamt: the shift amount for shift instructions, otherwise it’s 0 op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits R-Type Carnegie Mellon 9 R-Type Examples add $s0, $s1, $s2 sub $t0, $t3, $t5 Assembly Code 0 17 18 16 0 32 Field Values 0 11 13 8 0 34 op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits 000000 10001 10010 10000 00000 100000 op rs rt rd shamt funct 000000 01011 01101 01000 00000 100010 Machine Code 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits (0x02328020) (0x016D4022) Note the order of registers in the assembly code: add rd, rs, rt Carnegie Mellon 10 Review: Instruction Formats op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits R-Type op rs rt imm 6 bits 5 bits 5 bits 16 bits I-Type op addr 6 bits 26 bits J-Type Carnegie Mellon 11 The Power of the Stored Program ¢ 32-bit instructions and data stored in memory ¢ Sequence of instructions: only difference between two applications (for example, a text editor and a video game) ¢ To run a new program: § No rewiring required § Simply store new program in memory ¢ The processor hardware executes the program: § fetches (reads) the instructions from memory in sequence § performs the specified operation Carnegie Mellon 12 Program counter ¢ The processor hardware executes the program: § fetches (reads) the instructions from memory in sequence § performs the specified operation § continues with the next instruction ¢ The program counter (PC) keeps track of the current instruction § In MIPS, programs typically start at memory address 0x00400000 Carnegie Mellon 13 Review: The Stored Program addi $t0, $s3, -12 Machine CodeAssembly Code lw $t2, 32($0) add $s0, $s1, $s2 sub $t0, $t3, $t5 0x8C0A0020 0x02328020 0x2268FFF4 0x016D4022 Address Instructions 0040000C 0 1 6 D 4 0 2 2 2 2 6 8 F F F 4 0 2 3 2 8 0 2 0 8 C 0 A 0 0 2 0 00400008 00400004 00400000 Stored Program Main Memory PC Carnegie Mellon 14 Interpreting Machine Language Code ¢ Start with opcode § Opcode tells how to parse the remaining bits ¢ If opcode is all 0’s § R-type instruction § Function bits tell what instruction it is ¢ Otherwise § opcode tells what instruction it is 001000 10001 10111 1111 1111 1111 0001 op rs rt imm addi $s7, $s1, -15 Machine Code Assembly Code 8 17 23 -15 Field Values (0x2237FFF1) op rs rt imm 2 2 3 7 F F F 1 000000 10111 10011 01000 00000 100010 op rs rt rd shamt funct sub $t0, $s7, $s3 0 23 19 8 0 34(0x02F34022) op rs rt rd shamt funct 0 2 F 3 4 0 2 2 Carnegie Mellon 15 Branching ¢ Allows a program to execute instructions out of sequence ¢ Conditional branches § branch if equal: beq (I-type) § branch if not equal: bne (I-type) ¢ Unconditional branches § jump: j (J-type) § jump register: jr (R-type) § jump and link: jal (J-type) these are the only two J-type instructions Carnegie Mellon 16 Conditional Branching (beq) # MIPS assembly addi $s0, $0, 4 addi $s1, $0, 1 sll $s1, $s1, 2 beq $s0, $s1, target addi $s1, $s1, 1 sub $s1, $s1, $s0 target: add $s1, $s1, $s0 Labels indicate instruction locations in a program. They cannot use reserved words and must be followed by a colon (:). Blackboard Carnegie Mellon 17 Conditional Branching (beq) # MIPS assembly addi $s0, $0, 4 # $s0 = 0 + 4 = 4 addi $s1, $0, 1 # $s1 = 0 + 1 = 1 sll $s1, $s1, 2 # $s1 = 1 << 2 = 4 beq $s0, $s1, target # branch is taken addi $s1, $s1, 1 # not executed sub $s1, $s1, $s0 # not executed target: # label add $s1, $s1, $s0 # $s1 = 4 + 4 = 8 Labels indicate instruction locations in a program. They cannot use reserved words and must be followed by a colon (:). Carnegie Mellon 18 The Branch Not Taken (bne) # MIPS assembly addi $s0, $0, 4 # $s0 = 0 + 4 = 4 addi $s1, $0, 1 # $s1 = 0 + 1 = 1 sll $s1, $s1, 2 # $s1 = 1 << 2 = 4 bne $s0, $s1, target # branch not taken addi $s1, $s1, 1 # $s1 = 4 + 1 = 5 sub $s1, $s1, $s0 # $s1 = 5 – 4 = 1 target: add $s1, $s1, $s0 # $s1 = 1 + 4 = 5 Carnegie Mellon 19 Unconditional Branching / Jumping (j) # MIPS assembly addi $s0, $0, 4 # $s0 = 4 addi $s1, $0, 1 # $s1 = 1 j target # jump to target sra $s1, $s1, 2 # not executed addi $s1, $s1, 1 # not executed sub $s1, $s1, $s0 # not executed target: add $s1, $s1, $s0 # $s1 = 1 + 4 = 5 Carnegie Mellon 20 Unconditional Branching (jr) # MIPS assembly 0x00002000 addi $s0, $0, 0x2010 # load 0x2010 to $s0 0x00002004 jr $s0 # jump to $s0 0x00002008 addi $s1, $0, 1 # not executed 0x0000200C sra $s1, $s1, 2 # not executed 0x00002010 lw $s3, 44($s1) # program continues Carnegie Mellon 21 High-Level Code Constructs ¢ if statements ¢ if/else statements ¢ while loops ¢ for loops Carnegie Mellon 22 If Statement if (i == j) f = g + h; f = f – i; # $s0 = f, $s1 = g, $s2 = h # $s3 = i, $s4 = j High-level code MIPS assembly code Carnegie Mellon 23 If Statement if (i == j) f = g + h; f = f – i; # $s0 = f, $s1 = g, $s2 = h # $s3 = i, $s4 = j bne $s3, $s4, L1 add $s0, $s1, $s2 L1: sub $s0, $s0, $s3 High-level code MIPS assembly code ¢ Notice that the assembly tests for the opposite case (i != j) than the test in the high-level code (i == j) Carnegie Mellon 24 If / Else Statement if (i == j) f = g + h; else f = f – i; # $s0 = f, $s1 = g, $s2 = h # $s3 = i, $s4 = j High-level code MIPS assembly code Carnegie Mellon 25 If / Else Statement if (i == j) f = g + h; else f = f – i; # $s0 = f, $s1 = g, $s2 = h # $s3 = i, $s4 = j bne $s3, $s4, L1 add $s0, $s1, $s2 j done L1: sub $s0, $s0, $s3 done: High-level code MIPS assembly code Carnegie Mellon 26 While Loops // determines the power // of x such that 2x = 128 int pow = 1; int x = 0; while (pow != 128) { pow = pow * 2; x = x + 1; } # $s0 = pow, $s1 = x High-level code MIPS assembly code Carnegie Mellon 27 While Loops // determines the power // of x such that 2x = 128 int pow = 1; int x = 0; while (pow != 128) { pow = pow * 2; x = x + 1; } # $s0 = pow, $s1 = x addi $s0, $0, 1 add $s1, $0, $0 addi $t0, $0, 128 while: beq $s0, $t0, done sll $s0, $s0, 1 addi $s1, $s1, 1 j while done: High-level code MIPS assembly code ¢ Notice that the assembly tests for the opposite case (pow == 128) than the test in the high-level code (pow != 128) Carnegie Mellon 28 For Loops The general form of a for loop is: for (initialization; condition; loop operation) loop body ¢ initialization: executes before the loop begins ¢ condition: is tested at the beginning of each iteration ¢ loop operation: executes at the end of each iteration ¢ loop body: executes each time the condition is met Carnegie Mellon 29 For Loops // add the numbers from 0 to 9 int sum = 0; int i; for (i = 0; i != 10; i = i+1) { sum = sum + i; } # $s0 = i, $s1 = sum High-level code MIPS assembly code Carnegie Mellon 30 For Loops // add the numbers from 0 to 9 int sum = 0; int i; for (i = 0; i != 10; i = i+1) { sum = sum + i; } # $s0 = i, $s1 = sum addi $s1, $0, 0 add $s0, $0, $0 addi $t0, $0, 10 for: beq $s0, $t0, done add $s1, $s1, $s0 addi $s0, $s0, 1 j for done: High-level code MIPS assembly code ¢ Notice that the assembly tests for the opposite case (i == 10) than the test in the high-level code (i != 10) Carnegie Mellon 31 Less Than Comparisons // add the powers of 2 from 1 // to 100 int sum = 0; int i; for (i = 1; i < 101; i = i*2) { sum = sum + i; } # $s0 = i, $s1 = sum High-level code MIPS assembly code Carnegie Mellon 32 Less Than Comparisons // add the powers of 2 from 1 // to 100 int sum = 0; int i; for (i = 1; i < 101; i = i*2) { sum = sum + i; } # $s0 = i, $s1 = sum addi $s1, $0, 0 addi $s0, $0, 1 addi $t0, $0, 101 loop: slt $t1, $s0, $t0 beq $t1, $0, done add $s1, $s1, $s0 sll $s0, $s0, 1 j loop done: High-level code MIPS assembly code ¢ $t1 = 1 if i < 101 Carnegie Mellon 33 Arrays ¢ Useful for accessing large amounts of similar data ¢ Array element: accessed by index ¢ Array size: number of elements in the array Carnegie Mellon 34 Arrays ¢ 5-element array ¢ Base address = 0x12348000 (address of the first array element, array[0]) ¢ First step in accessing an array: § Load base address into a register array[4] array[3] array[2] array[1] array[0]0x12348000 0x12348004 0x12348008 0x1234800C 0x12340010 Carnegie Mellon 35 Arrays // high-level code int array[5]; array[0] = array[0] * 2; array[1] = array[1] * 2; # MIPS assembly code # array base address = $s0 # Initialize $s0 to 0x12348000 High-level code MIPS Assembly code How to get a 32-bit address into register $s0? Carnegie Mellon 36 Arrays // high-level code int array[5]; array[0] = array[0] * 2; array[1] = array[1] * 2; # MIPS assembly code # array base address = $s0 # Initialize $s0 to 0x12348000 lui $s0, 0x1234 # upper $s0 ori $s0, $s0, 0x8000 # lower $s0 High-level code MIPS Assembly code How to load a[0] and a[1] into a register? Carnegie Mellon 37 Arrays // high-level code int array[5]; array[0] = array[0] * 2; array[1] = array[1] * 2; # MIPS assembly code # array base address = $s0 # Initialize $s0 to 0x12348000 lui $s0, 0x1234 # upper $s0 ori $s0, $s0, 0x8000 # lower $s0 lw $t1, 0($s0) # $t1=array[0] sll $t1, $t1, 1 # $t1=$t1*2 sw $t1, 0($s0) # array[0]=$t1 lw $t1, 4($s0) # $t1=array[1] sll $t1, $t1, 1 # $t1=$t1*2 sw $t1, 4($s0) # array[1]=$t1 High-level code MIPS Assembly code Carnegie Mellon 38 Arrays Using For Loops // high-level code int arr[1000]; int i; for (i = 0; i < 1000; i = i + 1) arr[i] = arr[i] * 8; # $s0 = array base, $s1 = i lui $s0, 0x23B8 # upper $s0 ori $s0, $s0, 0xF000 # lower $s0 High-level code MIPS Assembly code Carnegie Mellon 39 Arrays Using For Loops // high-level code int arr[1000]; int i; for (i = 0; i < 1000; i = i + 1) arr[i] = arr[i] * 8; # $s0 = array base, $s1 = i lui $s0, 0x23B8 # upper $s0 ori $s0, $s0, 0xF000 # lower $s0 addi $s1, $0, 0 # i = 0 addi $t2, $0, 1000 # $t2 = 1000 loop: slt $t0, $s1, $t2 # i < 1000? beq $t0, $0, done # if not done sll $t0, $s1, 2 # $t0=i * 4 add $t0, $t0, $s0 # addr of arr[i] lw $t1, 0($t0) # $t1=arr[i] sll $t1, $t1, 3 # $t1=arr[i]*8 sw $t1, 0($t0) # arr[i] = $t1 addi $s1, $s1, 1 # i = i + 1 j loop # repeat done: High-level code MIPS Assembly code Carnegie Mellon 42 Procedures // High level code void main() { int y; y = sum(42, 7); ... } int sum(int a, int b) { return (a + b); } ¢ Definitions § Caller: calling procedure (in this case, main) § Callee: called procedure (in this case, sum) Carnegie Mellon 43 Procedure Calling Conventions ¢ Caller: § passes arguments to callee § jumps to the callee ¢ Callee: § performs the procedure § returns the result to caller § returns to the point of call § must not overwrite registers or memory needed by the caller Carnegie Mellon 44 MIPS Procedure Calling Conventions ¢ Call procedure: § jump and link (jal) ¢ Return from procedure: § jump register (jr) ¢ Argument values: § $a0 - $a3 ¢ Return value: § $v0 Carnegie Mellon 45 Procedure Calls int main() { simple(); a = b + c; } void simple() { return; } 0x00400200 main: jal simple 0x00400204 add $s0,$s1,$s2 ... 0x00401020 simple: jr $ra High-level code MIPS Assembly code ¢ void means that simple doesn’t return a value Carnegie Mellon 46 Procedure Calls int main() { simple(); a = b + c; } void simple() { return; } 0x00400200 main: jal simple 0x00400204 add $s0,$s1,$s2 ... 0x00401020 simple: jr $ra High-level code MIPS Assembly code ¢ jal: jumps to simple and saves PC+4 in the return address register ($ra) § In this case, $ra = 0x00400204 after jal executes ¢ jr $ra: jumps to address in $ra § in this case jump to address 0x00400204 Carnegie Mellon 47 Input Arguments and Return Values ¢ MIPS conventions: § Argument values: $a0 - $a3 § Return value: $v0 Carnegie Mellon 48 Input Arguments and Return Values # MIPS assembly code # $s0 = y main: ... addi $a0, $0, 2 # argument 0 = 2 addi $a1, $0, 3 # argument 1 = 3 addi $a2, $0, 4 # argument 2 = 4 addi $a3, $0, 5 # argument 3 = 5 jal diffofsums # call procedure add $s0, $v0, $0 # y = returned value ... # $s0 = result diffofsums: add $t0, $a0, $a1 # $t0 = f + g add $t1, $a2, $a3 # $t1 = h + i sub $s0, $t0, $t1 # result = (f + g) - (h + i) add $v0, $s0, $0 # put return value in $v0 jr $ra # return to caller // High-level code int main() { int y; ... // 4 arguments y = diffofsums(2, 3, 4, 5); ... } int diffofsums(int f, int g, int h, int i) { int result; result = (f + g) - (h + i); return result; // return value } Carnegie Mellon 49 Input Arguments and Return Values # $s0 = result diffofsums: add $t0, $a0, $a1 # $t0 = f + g add $t1, $a2, $a3 # $t1 = h + i sub $s0, $t0, $t1 # result = (f + g) - (h + i) add $v0, $s0, $0 # put return value in $v0 jr $ra # return to caller ¢ diffofsums overwrote 3 registers: $t0, $t1, and $s0 ¢ diffofsums can use the stack to temporarily store registers (comes next) Carnegie Mellon 50 The Stack ¢ Memory used to temporarily save variables ¢ Like a stack of dishes, last-in-first- out (LIFO) queue ¢ Expands: uses more memory when more space is needed ¢ Contracts: uses less memory when the space is no longer needed Carnegie Mellon 51 The Stack ¢ Grows down (from higher to lower memory addresses) ¢ Stack pointer: $sp, points to top of the stack Data 7FFFFFFC 12345678 7FFFFFF8 7FFFFFF4 7FFFFFF0 Address $sp 7FFFFFFC 7FFFFFF8 7FFFFFF4 7FFFFFF0 Address Data 12345678 $sp AABBCCDD 11223344 Carnegie Mellon 52 How Procedures use the Stack # MIPS assembly # $s0 = result diffofsums: add $t0, $a0, $a1 # $t0 = f + g add $t1, $a2, $a3 # $t1 = h + i sub $s0, $t0, $t1 # result = (f + g) - (h + i) add $v0, $s0, $0 # put return value in $v0 jr $ra # return to caller ¢ Called procedures must have no other unintended side effects ¢ But diffofsums overwrites 3 registers: $t0, $t1, $s0 Carnegie Mellon 53 Storing Register Values on the Stack # $s0 = result diffofsums: addi $sp, $sp, -12 # make space on stack # to store 3 registers sw $s0, 8($sp) # save $s0 on stack sw $t0, 4($sp) # save $t0 on stack sw $t1, 0($sp) # save $t1 on stack add $t0, $a0, $a1 # $t0 = f + g add $t1, $a2, $a3 # $t1 = h + i sub $s0, $t0, $t1 # result = (f + g) - (h + i) add $v0, $s0, $0 # put return value in $v0 lw $t1, 0($sp) # restore $t1 from stack lw $t0, 4($sp) # restore $t0 from stack lw $s0, 8($sp) # restore $s0 from stack addi $sp, $sp, 12 # deallocate stack space jr $ra # return to caller Carnegie Mellon 54 The Stack during diffofsums Call Data FC F8 F4 F0 Address $sp (a) Data FC F8 F4 F0 Address $sp (b) $s0 Data $sp (c) $t0 FC F8 F4 F0 Address ? ??stack frame $t1 Carnegie Mellon 55 Registers Preserved Callee-saved = Callee must preserve Nonpreserved Caller-saved = Callee can overwrite $s0 - $s7 $t0 - $t9 $ra $a0 - $a3 $sp $v0 - $v1 stack above $sp stack below $sp Carnegie Mellon 56 Storing Saved Registers on the Stack # $s0 = result diffofsums: addi $sp, $sp, -4 # make space on stack to # store one register sw $s0, 0($sp) # save $s0 on stack # no need to save $t0 or $t1 add $t0, $a0, $a1 # $t0 = f + g add $t1, $a2, $a3 # $t1 = h + i sub $s0, $t0, $t1 # result = (f + g) - (h + i) add $v0, $s0, $0 # put return value in $v0 lw $s0, 0($sp) # restore $s0 from stack addi $sp, $sp, 4 # deallocate stack space jr $ra # return to caller which of these registers may not be overwritten by diffofsums? Carnegie Mellon 57 Storing Saved Registers on the Stack # $s0 = result diffofsums: addi $sp, $sp, -4 # make space on stack to # store one register sw $s0, 0($sp) # save $s0 on stack # no need to save $t0 or $t1 add $t0, $a0, $a1 # $t0 = f + g add $t1, $a2, $a3 # $t1 = h + i sub $s0, $t0, $t1 # result = (f + g) - (h + i) add $v0, $s0, $0 # put return value in $v0 lw $s0, 0($sp) # restore $s0 from stack addi $sp, $sp, 4 # deallocate stack space jr $ra # return to caller which of these registers may not be overwritten by diffofsums? $s0 – hence it has to be stored on the stack and restored Carnegie Mellon 58 Multiple Procedure Calls proc1: addi $sp, $sp, -4 # make space on stack sw $ra, 0($sp) # save $ra on stack jal proc2 ... lw $ra, 0($sp) # restore $s0 from stack addi $sp, $sp, 4 # deallocate stack space jr $ra # return to caller Carnegie Mellon 59 Recursive Procedure Call // High-level code int factorial(int n) { if (n <= 1) return 1; else return (n * factorial(n-1)); } Carnegie Mellon 60 Recursive Procedure Call # MIPS assembly code 0x90 factorial: addi $sp, $sp, -8 # make room 0x94 sw $a0, 4($sp) # store $a0 0x98 sw $ra, 0($sp) # store $ra 0x9C addi $t0, $0, 2 0xA0 slt $t0, $a0, $t0 # a <= 1 ? 0xA4 beq $t0, $0, else # no: go to else 0xA8 addi $v0, $0, 1 # yes: return 1 0xAC addi $sp, $sp, 8 # restore $sp 0xB0 jr $ra # return 0xB4 else: addi $a0, $a0, -1 # n = n - 1 0xB8 jal factorial # recursive call 0xBC lw $ra, 0($sp) # restore $ra 0xC0 lw $a0, 4($sp) # restore $a0 0xC4 addi $sp, $sp, 8 # restore $sp 0xC8 mul $v0, $a0, $v0 # n * factorial(n-1) 0xCC jr $ra # return Carnegie Mellon 61 Stack during Recursive Call $sp FC F8 F4 F0 $ra EC E8 E4 E0 DC FC F8 F4 F0 EC E8 E4 E0 DC FC F8 F4 F0 EC E8 E4 E0 DC $sp $sp $sp $sp $a0 = 1 $v0 = 1 x 1 $a0 = 2 $v0 = 2 x 1 $a0 = 3 $v0 = 3 x 2 $v0 = 6 $sp $sp $sp $sp DataAddress DataAddress DataAddress $a0 (0x3) $ra (0xBC) $a0 (0x2) $ra (0xBC) $a0 (0x1) $ra $a0 (0x3) $ra (0xBC) $a0 (0x2) $ra (0xBC) $a0 (0x1) Carnegie Mellon 62 Procedure Call Summary ¢ Caller § Put arguments in $a0-$a3 § Save any registers that are needed ($ra, maybe $t0-t9) § jal callee § Restore registers § Look for result in $v0 ¢ Callee § Save registers that might be disturbed ($s0-$s7) § Perform procedure § Put result in $v0 § Restore registers § jr $ra Carnegie Mellon 63 Addressing Modes ¢ How do we address the operands? § Register Only § Immediate § Base Addressing § PC-Relative § Pseudo Direct Carnegie Mellon 64 Register Only Addressing ¢ Operands found in registers § Example: add $s0, $t2, $t3 § Example: sub $t8, $s1, $0 Carnegie Mellon 65 Immediate Addressing ¢ 16-bit immediate used as an operand § Example: addi $s4, $t5, -73 § Example: ori $t3, $t7, 0xFF Carnegie Mellon 66 Base Addressing ¢ Address of operand is: base address + sign-extended immediate § Example: lw $s4, 72($0) Address = $0 + 72 § Example: sw $t2, -24($t1) Address = $t1 - 24 Carnegie Mellon 67 PC-Relative Addressing 0x10 beq $t0, $0, else 0x14 addi $v0, $0, 1 0x18 addi $sp, $sp, i 0x1C jr $ra 0x20 else: addi $a0, $a0, -1 0x24 jal factorial beq $t0, $0, else Assembly Code Field Values 4 8 0 3 op rs rt imm 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits(beq $t0, $0, 3) Carnegie Mellon 68 Pseudo-direct Addressing 0x0040005C jal sum ... 0x004000A0 sum: add $v0, $a0, $a1 0000 0000 0100 0000 0000 0000 1010 0000JTA 26-bit addr (0x0100028) (0x004000A0) 0000 0000 0100 0000 0000 0000 1010 0000 0 1 0 0 0 2 8 000011 00 0001 0000 0000 0000 0010 1000 op addr Machine CodeField Values 3 0x0100028 6 bits 26 bits (0x0C100028) op imm 6 bits 26 bits Carnegie Mellon 69 How Do We Compile & Run an Application? Assembly Code High Level Code Compiler Object File Assembler Executable Linker Memory Loader Object Files Library Files Carnegie Mellon 70 What needs to be stored in memory? ¢ Instructions (also called text) ¢ Data § Global/static: allocated before program begins § Dynamic: allocated within program ¢ How big is memory? § At most 232 = 4 gigabytes (4 GB) § From address 0x00000000 to 0xFFFFFFFF Carnegie Mellon 71 The MIPS Memory Map SegmentAddress 0xFFFFFFFC 0x80000000 0x7FFFFFFC 0x10010000 0x1000FFFC 0x10000000 0x0FFFFFFC 0x00400000 0x003FFFFC 0x00000000 Reserved Stack Heap Static Data Text Reserved Dynamic Data Carnegie Mellon 72 Example Program: C Code int f, g, y; // global variables int main(void) { f = 2; g = 3; y = sum(f, g); return y; } int sum(int a, int b) { return (a + b); } Carnegie Mellon 73 Example Program: Assembly Code int f, g, y; // global int main(void) { f = 2; g = 3; y = sum(f, g); return y; } int sum(int a, int b) { return (a + b); } .data f: g: y: .text main: addi $sp, $sp, -4 # stack sw $ra, 0($sp) # store $ra addi $a0, $0, 2 # $a0 = 2 sw $a0, f # f = 2 addi $a1, $0, 3 # $a1 = 3 sw $a1, g # g = 3 jal sum # call sum sw $v0, y # y = sum() lw $ra, 0($sp) # rest. $ra addi $sp, $sp, 4 # rest. $sp jr $ra # return sum: add $v0, $a0, $a1 # $v0= a+b jr $ra # return Carnegie Mellon 74 Example Program: Symbol Table Symbol Address f 0x10000000 g 0x10000004 y 0x10000008 main 0x00400000 sum 0x0040002C Carnegie Mellon 75 Example Program: Executable Executable file header Text Size Data Size Text segment Data segment Address Instruction Address Data 0x00400000 0x00400004 0x00400008 0x0040000C 0x00400010 0x00400014 0x00400018 0x0040001C 0x00400020 0x00400024 0x00400028 0x0040002C 0x00400030 addi $sp, $sp, -4 sw $ra, 0 ($sp) addi $a0, $0, 2 sw $a0, 0x8000 ($gp) addi $a1, $0, 3 sw $a1, 0x8004 ($gp) jal 0x0040002C sw $v0, 0x8008 ($gp) lw $ra, 0 ($sp) addi $sp, $sp, -4 jr $ra add $v0, $a0, $a1 jr $ra 0x10000000 0x10000004 0x10000008 f g y 0xC (12 bytes)0x34 (52 bytes) 0x23BDFFFC 0xAFBF0000 0x20040002 0xAF848000 0x20050003 0xAF858004 0x0C10000B 0xAF828008 0x8FBF0000 0x23BD0004 0x03E00008 0x00851020 0x03E0008 Carnegie Mellon 76 Example Program: In Memory y g f 0x03E00008 0x00851020 0x03E00008 0x23BD0004 0x8FBF0000 0xAF828008 0x0C10000B 0xAF858004 0x20050003 0xAF848000 0x20040002 0xAFBF0000 0x23BDFFFC MemoryAddress $sp = 0x7FFFFFFC0x7FFFFFFC 0x10010000 0x00400000 Stack Heap $gp = 0x10008000 PC = 0x00400000 0x10000000 Reserved Reserved Carnegie Mellon 77 Odds and Ends ¢ Pseudoinstructions ¢ Exceptions ¢ Signed and unsigned instructions ¢ Floating-point instructions Carnegie Mellon 78 Pseudoinstruction Examples Pseudoinstruction MIPS Instructions li $s0, 0x1234AA77 lui $s0, 0x1234 ori $s0, 0xAA77 mul $s0, $s1, $s2 mult $s1, $s2 mflo $s0 clear $t0 add $t0, $0, $0 move $s1, $s2 add $s2, $s1, $0 nop sll $0, $0, 0 Carnegie Mellon 79 Exceptions ¢ Unscheduled procedure call to the exception handler ¢ Caused by: § Hardware, also called an interrupt, e.g. keyboard § Software, also called traps, e.g. undefined instruction ¢ When exception occurs, the processor: § Records the cause of the exception § Jumps to the exception handler at instruction address 0x80000180 § Returns to program Carnegie Mellon 80 Exception Registers ¢ Not part of the register file. § Cause § Records the cause of the exception § EPC (Exception PC) § Records the PC where the exception occurred ¢ EPC and Cause: part of Coprocessor 0 ¢ Move from Coprocessor 0 § mfc0 $t0, EPC § Moves the contents of EPC into $t0 Carnegie Mellon 81 Exception Causes Exception Cause Hardware Interrupt 0x00000000 System Call 0x00000020 Breakpoint / Divide by 0 0x00000024 Undefined Instruction 0x00000028 Arithmetic Overflow 0x00000030 Carnegie Mellon 82 Exceptions ¢ Processor saves cause and exception PC in Cause and EPC ¢ Processor jumps to exception handler (0x80000180) ¢ Exception handler: § Saves registers on stack § Reads the Cause register § mfc0 $t0, Cause § Handles the exception § Restores registers § Returns to program § mfc0 $k0, EPC § jr $k0 Carnegie Mellon 92 What Did We Learn? ¢ How to translate common programming constructs § Conditons § Loops § Procedure calls ¢ Stack ¢ The compiled program ¢ Odds and Ends § Floating point (F-type) instructions ¢ What Next? § Actually building the MIPS Microprocessor!!","libVersion":"0.3.2","langs":""}