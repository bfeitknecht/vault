{"path":"sem2a/AuW/VRL/extra/nwehrli/AuW-w13-random-mincut.pdf","text":"Aufgabe 1 – Arbeitsgruppen Zu einem Kongress werden Mitarbeiter von m Firmen gesandt. Dabei sendet die i-te Firma ci viele Mitarbeiter. W¨ahrend des Kongresses sollen die anwesenden Personen in bis zu r verschiedene Arbeitsgruppen mit jeweils h¨ochstens 5 Mitgliedern aufgeteilt werden, wobei keine zwei Mitarbeiter derselben Firma in derselben Arbeitsgruppe sein sollen. Wir sollen eine solche Aufteilung mit Hilfe von Fluss-Algorithmen finden. (a) Definieren Sie dazu ein geeignetes Netzwerk N = (V, A, c, s, t) und zeigen Sie, dass es ge- nau dann eine m¨ogliche Aufteilung wie oben gibt, wenn maxflow(N ) eine gewisse (welche?) Eigenschaft hat. (b) Angenommen, wir erhalten als Eingabe die Zahlen m, r, c1, . . . , cm sowie die Listen L1, . . . , Lm mit den Namen aller Teilnehmer des Kongresses. Wir k¨onnen davon ausgehen, dass keine zwei Teilnehmer den gleichen Namen haben. Geben Sie einen Algorithmus an, der dies als Eingabe verwendet, und als Ausgabe entweder r Listen, G1, ..., Gr gibt, wobei Gi die Namen aller Teilnehmer der i:ten Gruppe in einer g¨ultigen Zuordnung enth¨alt, oder antwortet ” Zuordnung nicht m¨oglich“. 1 (a) Die Aufgabe besteht darin, Mitarbeiter von Firmen auf Gruppen aufzuteilen mit den folgenden Kriterien: (i) Jede Firma i hat genau ci Mitarbeiter auf die Gruppen verteilt. (ii) Jede Gruppe hat h¨ochstens 5 Mitarbeiter. (iii) Keine Firma verteilt mehr als einen Mitarbeiter auf eine Gruppe. (iv) Es gibt h¨ochstens r viele Gruppen. Wir modellieren das Problem als Flussproblem auf einem Netzwerk N wie folgt: N hat eine Quelle s und eine Senke t. Dar¨uber hinaus f¨ugen wir f¨ur jede Firma i (1 ≤ i ≤ m) einen Knoten fi und f¨ur jede der r (potentiell leeren) Arbeitsgruppen j einen Knoten aj ein. Die Knoten fi sind durch einer Kante (s, fi) mit der Quelle verbunden, die Kapazit¨at ci hat (intuitiv wird der Fluss entlang dieser Kanten bestimmen, wie viele Mitarbeiter der Firma an Arbeitsgruppen teilnehmen k¨onnen). Des Weiteren verbinden wir jede Firma fi mit jeder Arbeitsgruppe aj durch eine Kante (fi, aj) der Kapazit¨at 1 (diese Kante stellt sicher, dass aus jeder Firma nur ein Mitarbeiter pro Arbeitsgruppe vertreten ist). Schlussendlich verbinden wir jede Arbeitsgruppe durch eine Kante (aj, t) mit Kapazit¨at 5 mit der Senke (diese Kante stellt sicher, dass jede Arbeitsgruppe h¨ochstens 5 Teilnehmer hat). Formal bedeutet dies, dass unser Netzwerk N = (V, A, c, s, t) wie folgt definiert ist: V := {s, f1, . . . , fm, a1, . . . , ar, t} A := {(s, fi) | i ∈ [m]} ∪ {(fi, ak) | i ∈ [m], k ∈ [r]} ∪ {(ak, t) | k ∈ [r]} c(u, v) :=    ci, falls u = s und v = fi, i ∈ [m] 1, falls u = fi und v = ak, i ∈ [m], k ∈ [r] 5, falls u = ak und v = t, k ∈ [r]. Abbildung 1: Die unbeschrifteten Kanten haben Kapazit¨at 1. Wir wollen im Folgenden zeigen, dass es eine zul¨assige Aufteilung gibt genau dann, wenn es in N einen maximalen Fluss mit Wert maxflow(N ) ≥ c := ∑m i=1 ci gibt. Dazu m¨ussen wir einerseits zeigen, wie wir aus einer zul¨assigen Aufteilung einen Fluss der Kapazit¨at c konstruieren k¨onnen und wie wir andererseits aus einem Fluss der Kapazit¨at c eine solche Aufteilung konstruieren konnen. 2 Zun¨achst sehen wir, dass maxflow(N ) ≤ c, da die Summe aller von s ausgehenden Kapazit¨aten genau c ist. Daher gilt maxflow(N ) ≥ c ⇐⇒ maxflow(N ) = c. Aufteilung =⇒ Fluss: Nehmen wir zun¨achst an, dass es eine zul¨assige Aufteilung gibt (und fixieren wir eine solche Aufteilung). Dann konstruieren wir einen Fluss, indem wir entlang jeder Kante (s, fi) den Fluss ci schicken und von jedem Knoten fi Fluss 1 entlang (fi, aj) genau dann, wenn ein Mitarbeiter von fi an der Gruppe aj teilnimmt - und Fluss 0 sonst. Schliesslich schicken wir entlang (aj, t) den Fluss, der der Anzahl der Teilnehmer in Gruppe j entspricht. Man sieht leicht, dass dieser Fluss zul¨assig ist. Die Kapazit¨at enlang der Kanten (fi, aj) wird nicht ¨uberschritten, da in jeder Gruppe h¨ochstens ein Mitarbeiter pro Firma vertreten ist; die Kapazit¨at entlang der Kanten (aj, t) wird respektiert, da es pro Gruppe h¨ochstens 5 Teilnehmer gibt. Aufgrund der Flusserhaltung inflow(aj) = outflow(aj) gilt an jedem Firmen- und Arbeitsgruppenknoten per Konstruktion (inflow(fi) = ci = outflow(fi), da ci Mitarbeiter von fi auf die Gruppen verteilt werden. Schliesslich wollen wir noch zeigen, dass dieser Fluss maximal ist. Daf¨ur gen¨ugt es, zu bemerken, dass val(f ) = outflow(s) = ∑m i=1 ci = c. Fluss =⇒ Aufteilung: Sei nun f ein maximaler Fluss der Kapazit¨at c. Bevor wir die Auftei- lung konstruieren, machen wir zwei Beobachtungen: Aus Satz 3.12 folgt, dass wir annehmen k¨onnen, dass dieser Fluss ganzzahlig ist, da alle Kapazit¨aten ganzzahlig sind. Insbesondere ist der Fluss entlang jeder Kante (fi, aj) entweder 0 oder 1. Des Weiteren wissen wir, dass ent- lang jeder Kante (s, fi) der Fluss ci fliesst, da jede Firma ci Mitarbeiter zur Konferenz schickt. Wir weisen nun einen Mitarbeiter der Firma fi der Gruppe aj zu, genau dann wenn f ((fi, ai)) = 1. Da inflow(fi) = ci gilt auch outflow(fi) = ci und deshalb werden ci Mitarbeiter der Fir- ma auf die Arbeitsgruppen aufgeteilt. Man sieht ebenfalls leicht, dass pro Arbeitsgruppe nur ein Mitarbeiter aus jeder Firma vertreten ist und dass in jeder Arbeitsgruppe h¨ochstens 5 Teilnehmer sind (da inflow(aj) = outflow(aj) ≤ 5). Damit haben wir gezeigt, dass aus der Existenz eines maximalen Flusses mit Wert c folgt, dass es eine zul¨assige Aufteilung gibt und den Beweis abgeschlossen. (b) Wir konstruieren unser Netzwerk wie in a). Die Strategie ist nun, einen maximalen ganzzahli- gen Fluss f zu finden. Da alle Kapazit¨aten ganzzahlig sind, ist dies z.B. mittels Ford-Fulkerson m¨oglich. Dann pr¨ufen wir, ob val(f ) = c. Falls nein, dann geben wir “Zuordnung nicht m¨oglich” aus. Falls ja, dann nutzen wir die Richtung Fluss =⇒ Aufteilung aus a), um eine g¨ultige Auf- teilung zu finden. Durch den aus a) erhaltenen Fluss f k¨onnen wir f¨ur jede Arbeitsgruppe k alle Firmen finden als Fk := {i ∈ [m]|f (fi, ak) = 1}, die Mitarbeiter in die jeweilige Gruppe schicken. Umgekehrt k¨onnen wir f¨ur jede Firma i die zugeh¨origen Arbeitsgruppen finden als Zi := {k ∈ [r]|f (fi, ak) = 1} mit |Zi| = ci. Sei nun ϕi : Zi → [ci] eine beliebige bijektive Abbildung f¨ur jedes i ∈ [m], z.B. die kanonisch kleinste solche Abbildung. ϕi bildet eine Ar- beitsgruppe auf einen Mitarbeiter der Firma i ab. Nun k¨onnen wir die Liste der Teilnehmer der Gruppe definieren als Gk := (Li,ϕi(k))i∈Fk . Die Korrektheit des Algorithmus folgt direkt aus Aufgabe a). Die Laufzeit des Algorithmus ist dominiert duch die Subroutine den maximalen Fluss zu finden, f¨ur Ford-Fulkerson also O(|A| · |V | · U ) wobei |A| ∈ Θ(m · r) die Anzahl der Kanten des konstruierten Netzwerks ist, |V | ∈ Θ(m+r) die Anzahl der Knoten und U := max(c1, ..., cm, 5) die maximale Kapazitat der Kanten. Die restliche “Buchhaltung” des Algorithmus (das Erstellen der Listen Gk) ben¨otigt Zeit O(mr + c). Insgesamt haben wir also Laufzeit O(|A| · |V | · U + mr + c) = O(mr(m + r)U + c) = O(mr(m + r)U ), da c ≤ m · U . 3 ETH Z¨urich Institute of Theoretical Computer Science Prof. Angelika Steger, Prof. Emo Welzl Dr. Johannes Lengler FS 2017 Algorithmen und Wahrscheinlichkeit Pr¨ufung Schlagen Sie die Klausur erst auf Anweisung der Aufsicht auf ! Kandidat/in: Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Vorname: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Ich bezeuge mit meiner Unterschrift, dass ich die Pr¨ufung unter regul¨aren Bedingungen ablegen kann und dass ich die unten stehenden allgemeinen Bemerkungen gelesen und verstanden habe. Unterschrift: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Allgemeine Bemerkungen und Hinweise: • Diese Pr¨ufung besteht neben diesem doppelseitigen Deckblatt aus 6 beidseitig bedruckten Aufgabenbl¨attern mit insgesamt 4 Aufgaben. Am Ende der Klausur ﬁnden Sie leere Bl¨atter f¨ur Notizen. Ausserdem liegt eine Formelsammlung an Ihrem Platz. • Die Pr¨ufung dauert zwei Stunden. Vorzeitige Abgaben sind nicht m¨oglich. • Falls Sie w¨ahrend der Pr¨ufung in irgendeiner Weise gest¨ort oder beeintr¨achtigt werden, melden Sie dies sofort der Aufsichtsperson. Sp¨atere Klagen werden nicht akzeptiert. • Schreiben Sie nicht mit Bleistift und nicht mit roter oder gr¨uner Farbe. • Alle Mobiltelefone und sonstigen elektronischen Ger¨ate m¨ussen vollst¨andig ausgeschaltet sein und im Gep¨ack verstaut werden. • Pro Aufgabe ist h¨ochstens eine g¨ultige Version eines L¨osungsversuchs zul¨assig. Streichen Sie ung¨ultige L¨osungsversuche klar durch. • Abschreiben und sonstige Versuche des Betrugs f¨uhren zum sofortigem Ausschluss von der Pr¨ufung und k¨onnen rechtliche Folgen haben. • Wenn Sie zus¨atzliches Papier (kein eigenes!) verwenden, dann versehen Sie jedes Blatt mit Ihrem Namen. • Vergessen Sie nicht, dieses Deckblatt zu unterschreiben. Viel Erfolg! Aufgabe 1 (16-25 Punkte) 2 (21 Punkte) 3 (7 Punkte) 4 (14 Punkte) Σ (58-67 Punkte) Punkte 1. Korrektur 2. Korrektur Aufgabe 1 – Multiple Choice G = (V, E) bezeichnet immer einen Graphen mit n Knoten und m Kanten. X und Y bezeichnen immer eine Zufallsvariable. Wir nehmen an, dass alle vorkommenden Werte (Erwartungswerte, bedingte Wahrscheinlichkeiten, ...) wohldeﬁniert sind. Welche der folgenden Aussagen sind immer wahr, welche nicht? Sie brauchen Ihre Antworten nicht zu begr¨unden. 1. Man kann in Zeit O(m + n) entscheiden, ob ein Graph G 2-zusammenh¨angend ist, falls G als Adjazenzliste gespeichert ist. (1 Punkte) WAHR □ FALSCH □ 2. Beschreiben Sie mit jeweils einem Schlagwort die drei wesentlichen Schritte des 2-Approximations Algorithmus f¨ur das metrische Travelling Salesman Problem (Problem des Handlungsreisen- den). (3 Punkte) 1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3. Sei X eine Indikator-Zufallsvariable und p := Pr[X = 1]. Geben Sie eine m¨oglichst einfache Formel f¨ur E[X] an. (1 Punkte) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4. Sei X eine Bernoulli-Zufallsvariable, und seien X1 := X, . . . , Xn := X. Dann ist die Summe der Xi binomialverteilt. (1 Punkte) WAHR □ FALSCH □ 5. Ein Las Vegas-Algorithmus terminiert immer. (1 Punkte) WAHR □ FALSCH □ 6. Bestimmt man einen minimalen Schnitt mit zuf¨alligen Kantenkontraktionen, so hat man die h¨ochste Fehlerwahrscheinlichkeit im ersten Schritt. (1 Punkte) WAHR □ FALSCH □ 7. Bis zu welcher L¨ange (in Θ-Notation) lassen sich Pfade in einem Graphen mit dem Bunte- Pfade-Algorithmus in erwartet polynomieller Zeit ﬁnden? (1 Punkte) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Welche der folgenden Aussagen sind immer wahr, welche nicht? Falls nicht, geben Sie ein Gegen- beispiel an. (Falls die Aussage wahr ist, 1 Punkt f¨ur korrekte Antwort. Falls die Aussage falsch ist, 2 Punkte f¨ur korrekte Antwort mit korrektem Gegenbeispiel, 0 Punkte sonst.) 8. Entfernt man eine Kante aus einem Baum T , so zerf¨allt T in genau zwei Zusammenhangs- komponenten. WAHR □ FALSCH □ Gegenbeispiel: 9. Sei e = {u, v} eine Br¨ucke in einem Graph G. Dann ist u ein Artikulationsknoten, falls deg(u) ≥ 2. WAHR □ FALSCH □ Gegenbeispiel: 10. Der Greedy-Algorithmus aus der Vorlesung zur F¨arbung von Graphen f¨arbt jeden Graphen G mit h¨ochstens χ(G) · log n Farben (f¨ur jede Knotenreihenfolge). WAHR □ FALSCH □ Gegenbeispiel: 11. Ein Matching f¨ur das es keinen augmentierenden Pfad gibt ist kardinalit¨atsmaximal. WAHR □ FALSCH □ Gegenbeispiel: 12. F¨ur zwei Ereignisse A, B gilt immer Pr[A | B] ≤ Pr[A]. WAHR □ FALSCH □ Gegenbeispiel: 13. Sind X und Y zwei unabh¨angige Zufallsvariabeln, so sind auch die Zufallsvariabeln X 2 und Y 2 unabh¨angig. WAHR □ FALSCH □ Gegenbeispiel: 14. F¨ur jede Zufallsvariable X gilt E[X 2] = (E[X]) 2. WAHR □ FALSCH □ Gegenbeispiel: 15. Sei X ≥ 0 eine nicht-negative Zufallsvariable mit Erwartungswert E[X] = 10. Dann gilt Pr[X ≤ 1] ≤ 1/10. WAHR □ FALSCH □ Gegenbeispiel: 16. Sei f ein maximaler Fluss auf einem Netzwerk N = (V, A, c, s, t). Dann gibt es keine zwei Knoten u, v in V , sodass sowohl die Kante (u, v) als auch die Kante (v, u) im Residualgraphen vorkommen. WAHR □ FALSCH □ Gegenbeispiel: Aufgabe 2 – Vermischtes Begr¨unden Sie jeweils knapp Ihre Antwort. (a) Geben Sie alle m, n ≥ 2 an, f¨ur welche das m × n-Gitter einen Hamiltonkreis enth¨alt. (5 Punkte) (b) Beschreiben Sie einen m¨oglichst einfachen Algorithmus, der als Input einen Graphen G = (V, E), welcher als Adjazenzliste gespeichert wurde, bekommt, und in Zeit O(|V | + |E|) entscheidet, ob der Graph eine Eulertour besitzt. Hinweis: Ihr Algorithmus braucht keine Eulertour auszugeben. (5 Punkte) (c) Skizzieren Sie das Argument, warum in jeder Phase des Quick-Select-Algorithmus mit Wahr- scheinlichkeit mindestens 1/2 die L¨ange des Arrays auf 3/4 der urspr¨unglichen L¨ange oder weniger reduziert wird. (3 Punkte) (d) Sei f ein nicht-maximaler Fluss auf einem Netzwerk N = (V, A, c, s, t). Zeigen Sie: Dann gibt es keinen s-t-Schnitt (S, T ) mit cap(S, T ) = val(f ). (4 Punkte) (e) Sei n ∈ N, und sei X eine Zufallsvariable mit E[X] = n log n und Var[X] = n2. Zeigen Sie: Es gibt ein C > 0, sodass Pr[X ≥ n log n + C · n] ≤ 0.01. (4 Punkte) Aufgabe 4 – Permutation Betrachten Sie folgenden (ineﬃzienten) Algorithmus zur Ziehung einer zuf¨alligen Permutation. Input: Eine Zahl n ∈ N. Output: Eine gleichverteilte zuf¨allige Permutation von {1, . . . , n}. 1. L := leere Liste. 2. WHILE length(L) < n 3. Ziehe gleichverteilt zuf¨allig ein i ∈ {1, . . . , n}; 4. Falls i nicht in L vorkommt, h¨ange i an L an; 5. END WHILE 6. return L Sei T die Anzahl Schleifendurchl¨aufe der Zeilen 2-5. (a) Berechnen Sie (mit Begr¨undung) E[T ]. (6 Punkte) (b) Berechnen Sie (mit Begr¨undung) Var[T ] in Θ-Notation. (8 Punkte) (a): (b):","libVersion":"0.3.2","langs":""}