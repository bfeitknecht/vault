{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w07.pdf","text":"Schlegel (Wer sich auskennt, sieht hier sofort die Prelude-Funktion ğ‘“ğ‘œğ‘™ğ‘‘ğ‘Ÿ, die selbstverstÃ¤ndlich ein Fold ist) Woche 7 â€“ Ãœbersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder VollstÃ¤ndigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne GewÃ¤hr.) Anmerkungen zu den Code-Expert Abgaben: Anmerkungen zu den Moodle Abgaben: Foldr nach Rezept aber ohne statische oder dynamische Argumente: (Vermeintlicher) special Case, hier ist die ErklÃ¤rung: https://n.ethz.ch/~mschlegel/fmfp22/foldrexerc.pdf Folds Pt.2: Letzte Woche haben wir das Thema â€œFolds fÃ¼r beliebige Algebraic Datatypesâ€ eingefÃ¼hrt. Heute mÃ¶chte ich noch einmal die Intuition fÃ¼r das LÃ¶sen der typischen Aufgaben zu diesem Thema genauer erklÃ¤ren und anschliessend noch einige Beispiele geben. Ein Fold reduziert eine Datenstruktur auf einen einzigen Wert. Sagen wir von nun an ausserdem, dass dieser Wert vom Type ğ‘ sein soll. Also brauchen wir irgendeine Funktion, welche die Elemente der Datenstruktur als Eingabe nimmt und diesen gewÃ¼nschten Wert zurÃ¼ckgibt (so wie wir in Funktionalen Programmiersprachen nun mal denken). Bei Lists kÃ¶nnte ein Fold bspw so aussehen: ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘“ ğ‘§ (ğ‘˜: ğ‘£: []) = ğ‘“ ğ‘˜ (ğ‘“ ğ‘£ (ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘“ ğ‘§ [])) Wenn wir nun unsere eigene Liste definieren, ist das hier eigentlich genau das gleiche: Definition: ğ‘‘ğ‘ğ‘¡ğ‘ ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘ = ğ¶ğ‘œğ‘›ğ‘  ğ‘ (ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘) | ğ¸ğ‘šğ‘ğ‘¡ğ‘¦ ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘“ ğ‘§ (ğ¶ğ‘œğ‘›ğ‘  ğ‘˜ (ğ¶ğ‘œğ‘›ğ‘  ğ‘£ (ğ¸ğ‘šğ‘ğ‘¦))) = ğ‘“ ğ‘˜ (ğ‘“ ğ‘£ (ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘“ ğ‘§ ğ¸ğ‘šğ‘ğ‘¡ğ‘¦)) â€¢ Die Abgaben, die ich bekommen habe, sahen insgesamt sehr gut aus. (50% der Stud.) â€¢ Ich empfehle allen dringend, die Induktionsaufgaben zu lÃ¶sen. â€¢ Viele Abgaben waren sehr gut und fehlerfrei, vereinzelt gab es Probleme, die vermutlich auf FlÃ¼chtigkeitsfehler zurÃ¼ckzufÃ¼hren sind. Falls nicht alles gestimmt hat, guckt auf jeden Fall noch einmal in die MusterlÃ¶sung. Alle anderen, die die Aufgaben nicht abgegeben haben, sollten unbedingt auch in der MusterlÃ¶sung gucken, da solche Evaluation-Strategy Aufgaben auch in vergangenen Jahren immer wieder an Klausuren abgefragt wurden (und da werden euch die Regeln dann Ã¼blicherweise nicht gegeben!) â€¢ Es gab auch diese Woche nur zu wenige (8) Abgaben. LÃ¶st unbedingt die Serien! Wenn wir uns das genau angucken, sehen wir, dass ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ eine Funktion ğ‘“ verwendet, die zwei Argumente nimmt und dann einen Wert vom Type ğ‘ zurÃ¼ckgibt. Wenn wir uns angucken, wie genau ğ’‡ğ’ğ’ğ’…ğ‘³ğ’Šğ’”ğ’• die Funktion auf die gegebene Datenstruktur (Liste) anwendet, erkennen wir folgendes: ğ‘“ nimmt als erstes Argument ein Element der Datenstruktur und als zweites Argument das Ergebnis der rekursiven Bearbeitung des Rests der Liste. So wir es wollen, gibt uns ğ‘“ einen Wert vom Typ ğ‘ zurÃ¼ck. Das heisst, ğ‘“â€™s erstes Argument ist vom Type den die Listenelemente haben, nennen wir ihn ğ‘ und ğ‘“â€™s â€zweites Argumentâ€œ (man erinnere sich an Higher Order Programmingâ€¦) hat Type ğ‘ â€“ denn als zweites Argument nimmt ğ‘“ das Ergebnis des rekursiven Aufrufs â€“ der ein RÃ¼ckgabewert von ğ‘“ ist, und damit vom Type ğ‘ ist. Also hat ğ‘“ insgesamt den Type: ğ‘“ âˆ· ğ‘ â†’ ğ‘ â†’ ğ‘. Dieses ğ‘“ wenden wir nun auf eine Liste an und bekommen dann abschliessend ein ğ‘ zurÃ¼ck. Damit kÃ¶nnen wir nun einfach den Type von ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ bestimmen: ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ âˆ· (ğ‘ â†’ ğ‘ â†’ ğ‘) â†’ ğ‘ â†’ ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘ â†’ ğ‘ Denn ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ nimmt als Argument ğ‘“, dann den â€Base-Case-Wertâ€œ ğ‘§, der natÃ¼rlich auch vom Type ğ‘ sein muss, da er von ğ‘“ als â€zweites Argumentâ€œ genommen wird und eine Liste und gibt dann den gewÃ¼nschten RÃ¼ckgabewert zurÃ¼ck, der vom Type ğ‘ ist. Die definierte Fold-Funktion (ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡) ist nun eine valide LÃ¶sung fÃ¼r einen Fold, da sie Elemente vom Type ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘ auf einen Wert reduziert. Nun mÃ¼ssen nur noch die Definition von ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ bestimmen. Aber das ist eigentlich relativ einfach: Im rekursiven Fall, also wenn die Liste so aussieht: ğ¶ğ‘œğ‘›ğ‘  ğ‘¥ ğ‘¥ğ‘ , dann macht ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ offensichtlich folgendes: ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ ğ’‡ ğ‘§ (ğ¶ğ‘œğ‘›ğ‘  ğ‘¥ ğ‘¥ğ‘ ) = ğ’‡ ğ‘¥ (ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘“ ğ‘§ ğ‘¥ğ‘ ) Also gibt sie das Ergebnis von ğ‘“, angewendet auf ğ‘¥ und das Ergebnis des rekursiven Aufrufs von sich selbst zurÃ¼ck. Im â€Base-Caseâ€œ Fall, also wenn die Liste so aussieht: ğ¸ğ‘šğ‘ğ‘¡ğ‘¦, macht ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ folgendes: ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘“ ğ’› (ğ¸ğ‘šğ‘ğ‘¡ğ‘¦) = ğ’› Also wird im Grunde genommen im Case (ğ¶ğ‘œğ‘›ğ‘  ğ‘¥ ğ‘¥ğ‘ ) die Funktion ğ‘“ angwendet auf irgendwas zurÃ¼ckgegeben und im Case (ğ¸ğ‘šğ‘ğ‘¡ğ‘¦) der Wert ğ‘§ zurÃ¼ckgegeben. Theoretisch kÃ¶nnte ğ‘§ aber natÃ¼rlich auch eine Funktion sein. Zusammengefasst also: Ich benenne nun einmal ğ‘“ und ğ‘§ um, aber Ã¤ndere sonst nichts, hier steht also exakt das gleiche, nur mit anderen Namen: Und wir haben ğ‘“ğ‘œğ‘™ğ‘‘ğ¿ğ‘–ğ‘ ğ‘¡ als Fold fÃ¼r den DataType ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘ definiert. Ihr solltet nun die Intuition fÃ¼r die einzelnen Funktionen und ihren Typen entwickelt haben, nun gucken wir uns noch ein weiteres Beispiel (und eine schnellere Herleitung) an. Anschliessend noch einige weitere Beispiele: Ã„rgerlicherweise ist mir kein Weg eingefallen, die Formatierung so hinzubekommen, dass hier nicht eine riesige LÃ¼cke entsteht, also FMFP-MEMES: (Quelle: der legendÃ¤re eth-memes channel auf discord) Nun, da wir verstanden haben, wie man die Types fÃ¼r Listen definiert, hier noch ein weiteres Beispiel: Credits: Artem, (Discord ETH-Memes Channel) Parser: Ich empfehle stark, die Vorlesungslides genau durchzulesen und dabei immer wieder zu Ã¼berlegen, was genau gerade eigentlich definiert wird. Eigentlich ist die Idee relativ einfach. Um die Ãœbungsaufgaben der Serie 7 zu lÃ¶sen, kann ich ausserdem die Code-Examples unter Code-Expert empfehlen. Lazy / Eager Evaluation â€“ Anmerkungen: Aufgaben aus Alt-Klausuren FP-Part Type Inference Exercise (HS21): Lazy / Eager Evaluation (HS21): Induktion (FS 20): Gegeben: data Direction = L | R, data Path = End | Node Int Direction Path Wir haben hier den Fall, den ich in einer der Vorwochen schon intensiv besprochen habe: Wenn wir den Induktionsbeweis fÃ¼r die gegebene Aussage fÃ¼hren, bekommen wir ein Problem, da sie â€zu spezifischâ€œ ist. Hier wird auf beiden Seiten der Gleichungen anstatt genereller Path Elemente explizit â€Endâ€œ verwendet. Man kann leicht (durch einfaches hinschreiben des Proofs) sehen, dass man den Induktionsschritt so nicht vervollstÃ¤ndigen kann. Wir mÃ¼ssen also generalisieren: Das haben wir bislang immer so gemacht, indem wir das â€spezifische Elementâ€œ, bspw. die â€0â€œ oder die leere Liste, â€[]â€œ, durch ein allgemeines Element, bspw. n::Nat oder ys::[a] ersetzt haben. Dabei habe ich euch jedoch folgendes gezeigt gehabt: Pures Ersetzen durch ein â€allgemeines Elementâ€œ fÃ¼hrt meistens nicht zur korrekten, generalisierten Aussage. Man muss eher auf einer Seite das â€spezifische Elementâ€œ durch ein â€allgemeines Elementâ€œ ersetzen und dann Ã¼berlegen, was dies fÃ¼r die andere Seite bedeutet. Hier wÃ¤re beispielsweise der Ansatz P â‰” âˆ€q âˆ· Path . mirror (invert q p) = invert q (mirror p) falsch, wie man recht schnell sehen kann, wenn man sich die Funktionen genau anguckt. Anstatt dessen gehen wir folgendermaÃŸen vor: Wir ersetzen auf der einen Seite und gucken dann nach, was das fÃ¼r die Gleichung bedeutet: mirror (invert q p) Was genau passiert hier eigentlich? Fangen wir mir invert q p an: Das Argument q wird von der Funktion invert gar nicht verÃ¤ndert. DafÃ¼r werden die Nodes vom Path p in umgedrehter Reihenfolge und mit gewechselten Vorzeichen â€vorneâ€œ an den Path q herangehÃ¤ngt. Die Funktion ğ‘šğ‘–ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ wechselt von diesem erhaltenen Pfad dann noch an jeder Node die Direction. Okay â€“ wie kÃ¶nnen wir das auf der RHS der Gleichung mit invert < hier_muss_was_hin > (mirror p) ausdrÃ¼cken? Eigentlich ist das relativ offensichtlich: invert wird die Nodes von (mirror p) in umgekehrter Reihenfolge (und mit umgekehrtem Vorzeichen an den Labels der Nodes) vorne an < hier_muss_was_hin > ranhÃ¤ngen. Damit das Ã„quivalent zur LHS ist, muss also < hier_muss_was_hin > = (mirror q) sein. Denn dann erhalten wir einen Pfad, bei dem an jeder Node die Direction gewechselt wurde, und die Nodes von p vorne in verkehrter Reihenfolge und mit gewechseltem Vorzeichen an q angehÃ¤ngt werden. Also ist die generalisierte Aussage: P â‰” âˆ€q âˆ· Path . mirror (invert q p) = invert (mirror q) (mirror p) Timed Words (Code Examples):","libVersion":"0.5.0","langs":""}