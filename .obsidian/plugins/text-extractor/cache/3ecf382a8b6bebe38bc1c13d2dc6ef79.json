{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w07.pdf","text":"Schlegel (Wer sich auskennt, sieht hier sofort die Prelude-Funktion 𝑓𝑜𝑙𝑑𝑟, die selbstverständlich ein Fold ist) Woche 7 – Übersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder Vollständigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne Gewähr.) Anmerkungen zu den Code-Expert Abgaben: Anmerkungen zu den Moodle Abgaben: Foldr nach Rezept aber ohne statische oder dynamische Argumente: (Vermeintlicher) special Case, hier ist die Erklärung: https://n.ethz.ch/~mschlegel/fmfp22/foldrexerc.pdf Folds Pt.2: Letzte Woche haben wir das Thema “Folds für beliebige Algebraic Datatypes” eingeführt. Heute möchte ich noch einmal die Intuition für das Lösen der typischen Aufgaben zu diesem Thema genauer erklären und anschliessend noch einige Beispiele geben. Ein Fold reduziert eine Datenstruktur auf einen einzigen Wert. Sagen wir von nun an ausserdem, dass dieser Wert vom Type 𝑐 sein soll. Also brauchen wir irgendeine Funktion, welche die Elemente der Datenstruktur als Eingabe nimmt und diesen gewünschten Wert zurückgibt (so wie wir in Funktionalen Programmiersprachen nun mal denken). Bei Lists könnte ein Fold bspw so aussehen: 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 𝑓 𝑧 (𝑘: 𝑣: []) = 𝑓 𝑘 (𝑓 𝑣 (𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 𝑓 𝑧 [])) Wenn wir nun unsere eigene Liste definieren, ist das hier eigentlich genau das gleiche: Definition: 𝑑𝑎𝑡𝑎 𝐿𝑖𝑠𝑡 𝑎 = 𝐶𝑜𝑛𝑠 𝑎 (𝐿𝑖𝑠𝑡 𝑎) | 𝐸𝑚𝑝𝑡𝑦 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 𝑓 𝑧 (𝐶𝑜𝑛𝑠 𝑘 (𝐶𝑜𝑛𝑠 𝑣 (𝐸𝑚𝑝𝑦))) = 𝑓 𝑘 (𝑓 𝑣 (𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 𝑓 𝑧 𝐸𝑚𝑝𝑡𝑦)) • Die Abgaben, die ich bekommen habe, sahen insgesamt sehr gut aus. (50% der Stud.) • Ich empfehle allen dringend, die Induktionsaufgaben zu lösen. • Viele Abgaben waren sehr gut und fehlerfrei, vereinzelt gab es Probleme, die vermutlich auf Flüchtigkeitsfehler zurückzuführen sind. Falls nicht alles gestimmt hat, guckt auf jeden Fall noch einmal in die Musterlösung. Alle anderen, die die Aufgaben nicht abgegeben haben, sollten unbedingt auch in der Musterlösung gucken, da solche Evaluation-Strategy Aufgaben auch in vergangenen Jahren immer wieder an Klausuren abgefragt wurden (und da werden euch die Regeln dann üblicherweise nicht gegeben!) • Es gab auch diese Woche nur zu wenige (8) Abgaben. Löst unbedingt die Serien! Wenn wir uns das genau angucken, sehen wir, dass 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 eine Funktion 𝑓 verwendet, die zwei Argumente nimmt und dann einen Wert vom Type 𝑐 zurückgibt. Wenn wir uns angucken, wie genau 𝒇𝒐𝒍𝒅𝑳𝒊𝒔𝒕 die Funktion auf die gegebene Datenstruktur (Liste) anwendet, erkennen wir folgendes: 𝑓 nimmt als erstes Argument ein Element der Datenstruktur und als zweites Argument das Ergebnis der rekursiven Bearbeitung des Rests der Liste. So wir es wollen, gibt uns 𝑓 einen Wert vom Typ 𝑐 zurück. Das heisst, 𝑓’s erstes Argument ist vom Type den die Listenelemente haben, nennen wir ihn 𝑎 und 𝑓’s „zweites Argument“ (man erinnere sich an Higher Order Programming…) hat Type 𝑐 – denn als zweites Argument nimmt 𝑓 das Ergebnis des rekursiven Aufrufs – der ein Rückgabewert von 𝑓 ist, und damit vom Type 𝑐 ist. Also hat 𝑓 insgesamt den Type: 𝑓 ∷ 𝑎 → 𝑐 → 𝑐. Dieses 𝑓 wenden wir nun auf eine Liste an und bekommen dann abschliessend ein 𝑐 zurück. Damit können wir nun einfach den Type von 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 bestimmen: 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 ∷ (𝑎 → 𝑐 → 𝑐) → 𝑐 → 𝐿𝑖𝑠𝑡 𝑎 → 𝑐 Denn 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 nimmt als Argument 𝑓, dann den „Base-Case-Wert“ 𝑧, der natürlich auch vom Type 𝑐 sein muss, da er von 𝑓 als „zweites Argument“ genommen wird und eine Liste und gibt dann den gewünschten Rückgabewert zurück, der vom Type 𝑐 ist. Die definierte Fold-Funktion (𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡) ist nun eine valide Lösung für einen Fold, da sie Elemente vom Type 𝐿𝑖𝑠𝑡 𝑎 auf einen Wert reduziert. Nun müssen nur noch die Definition von 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 bestimmen. Aber das ist eigentlich relativ einfach: Im rekursiven Fall, also wenn die Liste so aussieht: 𝐶𝑜𝑛𝑠 𝑥 𝑥𝑠, dann macht 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 offensichtlich folgendes: 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 𝒇 𝑧 (𝐶𝑜𝑛𝑠 𝑥 𝑥𝑠) = 𝒇 𝑥 (𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 𝑓 𝑧 𝑥𝑠) Also gibt sie das Ergebnis von 𝑓, angewendet auf 𝑥 und das Ergebnis des rekursiven Aufrufs von sich selbst zurück. Im „Base-Case“ Fall, also wenn die Liste so aussieht: 𝐸𝑚𝑝𝑡𝑦, macht 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 folgendes: 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 𝑓 𝒛 (𝐸𝑚𝑝𝑡𝑦) = 𝒛 Also wird im Grunde genommen im Case (𝐶𝑜𝑛𝑠 𝑥 𝑥𝑠) die Funktion 𝑓 angwendet auf irgendwas zurückgegeben und im Case (𝐸𝑚𝑝𝑡𝑦) der Wert 𝑧 zurückgegeben. Theoretisch könnte 𝑧 aber natürlich auch eine Funktion sein. Zusammengefasst also: Ich benenne nun einmal 𝑓 und 𝑧 um, aber ändere sonst nichts, hier steht also exakt das gleiche, nur mit anderen Namen: Und wir haben 𝑓𝑜𝑙𝑑𝐿𝑖𝑠𝑡 als Fold für den DataType 𝐿𝑖𝑠𝑡 𝑎 definiert. Ihr solltet nun die Intuition für die einzelnen Funktionen und ihren Typen entwickelt haben, nun gucken wir uns noch ein weiteres Beispiel (und eine schnellere Herleitung) an. Anschliessend noch einige weitere Beispiele: Ärgerlicherweise ist mir kein Weg eingefallen, die Formatierung so hinzubekommen, dass hier nicht eine riesige Lücke entsteht, also FMFP-MEMES: (Quelle: der legendäre eth-memes channel auf discord) Nun, da wir verstanden haben, wie man die Types für Listen definiert, hier noch ein weiteres Beispiel: Credits: Artem, (Discord ETH-Memes Channel) Parser: Ich empfehle stark, die Vorlesungslides genau durchzulesen und dabei immer wieder zu überlegen, was genau gerade eigentlich definiert wird. Eigentlich ist die Idee relativ einfach. Um die Übungsaufgaben der Serie 7 zu lösen, kann ich ausserdem die Code-Examples unter Code-Expert empfehlen. Lazy / Eager Evaluation – Anmerkungen: Aufgaben aus Alt-Klausuren FP-Part Type Inference Exercise (HS21): Lazy / Eager Evaluation (HS21): Induktion (FS 20): Gegeben: data Direction = L | R, data Path = End | Node Int Direction Path Wir haben hier den Fall, den ich in einer der Vorwochen schon intensiv besprochen habe: Wenn wir den Induktionsbeweis für die gegebene Aussage führen, bekommen wir ein Problem, da sie „zu spezifisch“ ist. Hier wird auf beiden Seiten der Gleichungen anstatt genereller Path Elemente explizit „End“ verwendet. Man kann leicht (durch einfaches hinschreiben des Proofs) sehen, dass man den Induktionsschritt so nicht vervollständigen kann. Wir müssen also generalisieren: Das haben wir bislang immer so gemacht, indem wir das „spezifische Element“, bspw. die „0“ oder die leere Liste, „[]“, durch ein allgemeines Element, bspw. n::Nat oder ys::[a] ersetzt haben. Dabei habe ich euch jedoch folgendes gezeigt gehabt: Pures Ersetzen durch ein „allgemeines Element“ führt meistens nicht zur korrekten, generalisierten Aussage. Man muss eher auf einer Seite das „spezifische Element“ durch ein „allgemeines Element“ ersetzen und dann überlegen, was dies für die andere Seite bedeutet. Hier wäre beispielsweise der Ansatz P ≔ ∀q ∷ Path . mirror (invert q p) = invert q (mirror p) falsch, wie man recht schnell sehen kann, wenn man sich die Funktionen genau anguckt. Anstatt dessen gehen wir folgendermaßen vor: Wir ersetzen auf der einen Seite und gucken dann nach, was das für die Gleichung bedeutet: mirror (invert q p) Was genau passiert hier eigentlich? Fangen wir mir invert q p an: Das Argument q wird von der Funktion invert gar nicht verändert. Dafür werden die Nodes vom Path p in umgedrehter Reihenfolge und mit gewechselten Vorzeichen „vorne“ an den Path q herangehängt. Die Funktion 𝑚𝑖𝑟𝑟𝑜𝑟 wechselt von diesem erhaltenen Pfad dann noch an jeder Node die Direction. Okay – wie können wir das auf der RHS der Gleichung mit invert < hier_muss_was_hin > (mirror p) ausdrücken? Eigentlich ist das relativ offensichtlich: invert wird die Nodes von (mirror p) in umgekehrter Reihenfolge (und mit umgekehrtem Vorzeichen an den Labels der Nodes) vorne an < hier_muss_was_hin > ranhängen. Damit das Äquivalent zur LHS ist, muss also < hier_muss_was_hin > = (mirror q) sein. Denn dann erhalten wir einen Pfad, bei dem an jeder Node die Direction gewechselt wurde, und die Nodes von p vorne in verkehrter Reihenfolge und mit gewechseltem Vorzeichen an q angehängt werden. Also ist die generalisierte Aussage: P ≔ ∀q ∷ Path . mirror (invert q p) = invert (mirror q) (mirror p) Timed Words (Code Examples):","libVersion":"0.5.0","langs":""}