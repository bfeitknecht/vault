{"path":"sem2/PProg/UE/s/PProg-u13-s.pdf","text":"Parallel Programming Assignment 13: Linearizability and Sequential Consistency Spring Semester 2024 Assigned on: 20.05.2024 Due by: 27.05.2024 Sequential Consistency For each of the following histories, indicate if they are sequentially consistent or not. In the following the objects r and s are registers (initially zero), q is a FIFO (initially empty). A: --|r.write(1)|------------------------- B: ------|r.read():0|--------------------- C: ---------------------|r.read():1|------ Answer: Yes, this is sequentially consistent, in SC we are allowed to reorder events, as long as the per- thread projections are remaining identical, thus we can move the read of thread B to be the first event, thus the order in which invocations take effect becomes: r.read(0):0, r.write(1), r.read():1 given that our register is initially zero, this is consistent with the sequential specification of a register (we read the last value written to it). A: q.enq(5) B: q.enq(3) A: void B: void A: q.deq() B: q.deq() A: 3 B: 3 Answer: This is not sequentially consistent. We enqueue 3 only once, but dequeue it twice. Given that the queue is initially empty this violates the sequential specification of a queue. A: --|s.write(1)|------------------------- B: ------|r.read():0|--------------------- C: ---------------------|r.read():1|------ Answer: This is not sequentially consistent. We are operating on two different registers in this example, r and s. On s we execute s.write(1), which is sequentially consistent by itself, but on r we execute two read operations which return different values, 0 and 1, without any wite to r. Regardless of the initial value of r, this violates the sequential specification of a register. A: --|s.write(1)|------------------------- B: ------|r.read():1|---|r.read():0|------ Answer: This is not sequentially consistent, the explanation from above applies to this example as well. Linearizability Which of the following histories are linearizable? Infer the object type from the supported operations, registers are initially zero, stacks/queues initially empty. A: s.push(1) A: void B: s.push(2) B: void B: s.pop() A: s.pop() B: 1 A: 2 Answer: This is linarizable. In linearizability we cannot order invocations with preceeding responses, thus we know after the fourth event the state of the stack must be top → 2 → 1. Thus the order in which the elements are returned must be 2, then 1. This is possible since the two pop methods overlap, i.e., the method B:s.pop():2 must show effect first. A: --|s.write(1)|------------------------- B: ------|r.read():1|---|r.read():0|------ Answer: This is not linearizable. We explained above why this history is not sequentially consistent. Since linearizability is a stricter requirement than sequential consistency (less reordering allowed) it thus also cannot be linearizable. Equivalence Give two different well-formed histories H1 and H2, which are equivalent to each other. Answer: A history is well-formed if it is complete (each invocation has a matching response) and per-thread projections are sequential. Two histories are eqivalent, if they have the same per-thread projections. Thus A: r.read() A: 0 C: r.write(1) C: void B: r.read() B: 1 and B: r.read() B: 1 C: r.write(1) C: void A: r.read() A: 0 fulfill these requirements, each thread is performing the same actions in the same order in both histories, yet the histories are different (the first one is linearizable, the second one is not). 2 Incomplete Histories When histories are obtained from a program trace, the history might be incomplete, i.e., if tracing stopped before the program completed. In the lecture you learned that this can be dealt with in two ways. Explain them. Why do we need both ways? Give an example where discarding all pending invocations will lead to a non-linearizable history, but adding a response will lead to a linearizable history. Answer: We can either drop a pending invocation or append a matchig response at the end. We need both, because if no other thread has seen the effect of the pending invocation yet, we can complete the history by removing the invocation, if a thread has already observed he effect we need to add a response at the end. For example in the history B: write(0) B: void A: write(1) <--pending B: read() B: 1 removing the pending invocation will lead to a non-linearizable history (we write 0, then read 1), adding a response, as shown below, will give a linearizable history. We simply choose the linearization point of the write(1) to be before the read by B. B: write(0) B: void A: write(1) B: read() B: 1 A: void Difference between Sequential Consistency and Linearizability Give a history which is sequentially consistent but not linearizable. Answer: Since sequential consistency allows ”shifting” of threads actions, we can exploit this to create a history which is SC but not linearizable: A: write(1) A: void B: read() B: 0 We assume r is initially zero. Thus we can make the history sequentially consistent by having A perform its actions after B. In linearizability such a reordering is not allowed. The write must take effect before the read, since the two methods do not overlap. 3","libVersion":"0.3.2","langs":""}