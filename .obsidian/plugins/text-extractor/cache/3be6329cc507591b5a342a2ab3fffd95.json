{"path":"sem4/DMDB/VRL/extra/slides/DMDB-s08-engine-data-memory.pdf","text":"Data Modeling and Databases Spring Semester 2025 Database Engines 1 – data in memory Data representation in memory Gustavo Alonso Institute of Computing Platforms Department of Computer Science ETH Zürich 1 Database Engines Data representation in memory 2 Storage Management Physical storage Blocks, files, segments Pages in memory Physical records Logical records (tuples) Logical data (tables, schemas) Relations, views Queries, Transactions (SQL) Record Interface Record Access Page access File Access Application Logical view (logical data) Access Paths Physical data in memory Page structure Storage allocation 3Storage - Segments and File storage Database engines • Common assumption: • Standard database architectures based on slow, hard drive disks (HDD) with a high latency for seek operations (random access) • Assuming most of the database is not in memory • Today, some things are different: • More main memory available • Different storage media (SSD, NVM, network attached storage) • Principles remain the same and illustrate the underlying problem rather than a particular implementation Storage - Segments and File storage 4 Explanations using a real system • Many of the explanations that follow are based on Oracle’s database • Cover all the basics • Provide a good example of how a real system works • Demonstrate the many tuning knobs available in a database • Prove why some people consider databases too complicated (more about this later in the course) • Ideas and concepts are nevertheless generic and they are somewhat similar across systems • Logical storage: • https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/logical-storage- structures.html#GUID-4AF2D61A-8675-4D48-97A4-B20F401ADA16 • https://docs.oracle.com/cd/B19306_01/server.102/b14220/logical.htm • Disk storage: • https://docs.oracle.com/cd/B19306_01/server.102/b14220/physical.htm • https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/physical-storage- structures.html#GUID-008A1F08-9C75-4E9F-A70B-41FB942C60B4 Storage - Segments and File storage 5 Problem statement • A database is doing many things at the same time (in the same way an Operating System is managing many different user processes at the same time) • Each “thing” (a query, a system process, a database component) active at any point in time needs its own logical view of the data (and correspondingly, of memory, and disk). This is the same as the OS giving a process the impression it is alone in the machine. • A database engine creates such virtual, logical views of the system using its own mechanisms (and different from the OS) Storage - Segments and File storage 6 From physical to logical storage Data representation in memory 7 Logical and Physical storage in Oracle 19 • Entity-relationship diagram (crow’s foot implies one-to-many) • Logical: • Tablespaces • Segments • Extent • Block • Physical: • Data File • OS block Storage - Segments and File storage 8 https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/logical-storage- structures.html#GUID-13CE5EDA-8C66-4CA0-87B5-4069215A368D Tablespaces • A tablespace is a logical data unit in the database: • Schema related: • A table • An index • Several tables (clustered tables) • Engine related: • Data structures for the database engine (result buffers, undo buffers, etc.) • A tablespace provides a logical representation of the principle of spatial locality (keep together what belongs together) • Does not necessarily mean all data is continuous • It means all the information and all the data of a tablespace is under the same umbrella • Space (memory/disk) is allocated to tablespaces Storage - Segments and File storage 9 Segments, Extents, and Blocks (example) Storage - Segments and File storage 10 https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/logical-storage- structures.html#GUID-13CE5EDA-8C66-4CA0-87B5-4069215A368D Generalizing • A given logical object in a database (a table, an index) is “stored” in a tablespace • A tablespace is organized into segments (each schema object has a segment) • Segments have space allocated to them in the form of extents. A segment can have several extents • Extents are sets of contiguously allocated data blocks. Extents are mapped to one data file (and typically to a file) • Data blocks are the smallest allocation unit of space (not necessarily a page, databases typically use blocks larger than an OS page). The size of the blocks is a tunable parameter. Storage - Segments and File storage 11 Translating • Tablespace = keep together what needs to be kept together • Segment = an object in the schema (or part of an object if it is partitioned) • Extent = groups of continuously allocated pages • Blocks = glorified pages • Why so complicated?: • Tablespaces = logical locality • Segments = allocate (virtual) space to objects • Extents = allocate contiguous physical space • Blocks = the unit of space allocation Storage - Segments and File storage 12 Segments I • A segment allocates the equivalent of virtual memory to a tablespace • Common setup: • Tablespace -> table • Tablespace has one segment • Segment has one or more extents • These structures, like all examples that follow, are created to provide physical data independence. Higher layers only need to know in which tablespace a table is. This allows the engine to change everything below by simply changing the pointers to the segment, to the extents, etc. Storage - Segments and File storage 13 Segments II • The mapping of a segment to a tablespace simplifies the manipulation of database entities: • CREATE TABLE T • DROP TABLE T • CREATE INDEX I ON table_name (attributes) • DROP INDEX I • If we need more space for a table or an index, the table is still referred to by its segment, but the segment indexes as many extents as needed. • If we partition a table, each partition has its own segment but the table is still referred to by its tablespace Storage - Segments and File storage 14 Extents Storage - Segments and File storage 15 • Extents provide optimal access by ensuring logically continuous allocation of blocks (blocks can end up non continuous on disk because of RAID, for instance) • Acts as a form of virtual address space: • Allocate and release blocks to the extent • Easy sequential search • Can be dropped as an unit https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/logical-storage- structures.html#GUID-13CE5EDA-8C66-4CA0-87B5-4069215A368D The big square is a data file! Space available in the data file Dynamic extents • When a segment is created, it is allocated an extent (how big? => tunable parameter) • If more space is needed, another extent is created • The new extent is not contiguous with the previous one and can be on a different data file Storage - Segments and File storage 16 The big square is a data file!Why extents? • Better than the alternatives: Storage - Segments and File storage 17 Static file mapping Segment (starting address, size) Easy to maintain Highly efficient (performance) Poor utilization (space) No flexibility Dynamic extents Dynamic block mapping Difficult to maintain Non contiguous Poor performance Maximum flexibility Why extents? • Databases must optimize along many dimensions. • A static file mapping is very easy to manage but induces fragmentation and provides no flexibility • Dynamic block mapping is extremely flexible but data is not contiguous and is expensive to maintain • Extents are a compromise: • An extent provides a static mapping to a set of blocks (like a static file mapping) • When more space is needed, extents are dynamically allocated (like with dynamic block mapping) Storage - Segments and File storage 18 Blocks vs OS pages • Operating systems deal with pages to implement virtual memory • Databases typically store a lot of data: • A table, an index might span many OS pages • Allocating space page by page at OS granularity is too much overhead • If one OS page belongs to a table, it is likely we will also be interested in the other pages allocated to that table (locality) • Hence, databases use blocks rather than OS pages • This is why, although most databases today use the OS I/O system for writing to disk, they manage their own files and memory representation • Later on we will see the structure of database pages in memory Storage - Segments and File storage 19 Block structure • A block is structured as follows: • Header: address and type of segment (index, table, etc.) • Table directory: schema of the table stored in the block • Row directory: pointers to the actual tuples stored in the block • Free space • Row data (tuples) stored in the block • The directory grows downwards, the space for tuples is used upwards Storage - Segments and File storage 20 Optimizing the use of blocks I • Percentage Free • Determines how much space in each block is reserved for updating tuples instead of using it for storing new tuples • This is needed because an update can result in a bigger tuple than the original one UPDATE T SET Adress = “AStreetWithAVeryLongName” WHERE LegiNr = 12345678 Storage - Segments and File storage 21 Optimizing the use of Blocks II • Percentage used • Determines how much space needs to be free in a block before the free space can be used to insert new tuples • Blocks are unavailable to inserting new tuples until they have the given amount of free space • It is needed because if updates can make tuples smaller (freeing up space), they can also make them bigger (needing space). The combination of both parameters avoids thrashing on the page Storage - Segments and File storage 22Storage - Segments and File storage 23 Fragmentation within blocks • Like any unit of storage, blocks can suffer from fragmentation. However, compaction is a very expensive procedure • Compaction often done only when the block has enough space for an INSERT or UPDATE but the space is not contiguous. Otherwise, the available space is used without reorganizing the tuples in the block. • UPDATE might require to move a tuple from one block to another if the new size does not fit in the block where the tuple is. In such a case, the tuple is inserted into a new block and the original space is used to store a pointer to the new row. The ID of the tuple does not change (which means an indirection is needed to find the tuple). Storage - Segments and File storage 24 Part 2 Part 2 Tables have no order • Recall that tables have no order on the tuples? • A property of the relational model • A consequence of how data is organized • Example with extents Storage - Segments and File storage 25 Table T Extent Part 1 Part 1 Part 3 Part 3 Part 4 Part 4 SELECT * FROM T ORDER BY … Architecture of a database Blocks, files, segments Pages in memory Physical records Logical records (tuples) Logical data (tables, schemas) Relations, views Queries, Transactions (SQL) Record Interface Record Access Page access File Access Application Logical view (logical data) Access Paths Physical data in memory Page structure Storage allocation 26Pages and Blocks Storage In perspective • Data in a database is stored in blocks • Blocks are parts of extents • Extents are part of segments • The notion of pages in a database • Hardware pages (the atomic unit to write to storage, usually 4KB) • OS Page (the unit used by the OS to implement virtual memory, usually 4KB) • Database Page = a block, anywhere between 512B and 32 KB; examples: Oracle 2KB to 32KB (typical 8KB), MS SQL Server 8KB, MySQL 16KB • Trend is towards larger block sizes (incurs less overhead) Pages and Blocks 27 Record Layout Pages and Blocks 28 Structure of a record (tuple) • A tuple contains: • Header (validity flags for deletion, visibility info for concurrency control, bit map of null values, …) • Attributes • Data for each non-null attribute (or a pointer to the data) • Relational engines do not store schema information in the tuple (types of the attributed are known), schema-less systems need to store the structure of the tuple since every one can be different Pages and Blocks 29 ID Name Dept. Sem. 1 John D-INFK 3 2 Mary D-ITET 5 4 6John D-INFK 3 4 6Mary D-ITET 5 STRING STRING INTEGER Schema information length lengthdata data int representation Actual tuples in memory Optimizing the record layout Pages and Blocks 30 4 6John D-INFK 3 34 John D-INFK6 Intuitive serial representation but linear time to access each attribute Instead of length, store offsets. That way the record has a fixed sized part at the beginning and a varied sized part at the tail. Pointers point to tail of attribute. Each attribute can be accessed in constant time 3 4 John D-INFK6 Reorder the attributes, place variable length data at the end. Better performance. Data Types • Integer Numbers • Usually represented the same format as C or C++ (standard in hardware architectures) • Real Numbers • IEEE-754 standard for variable precision • Fixed point representations for fixed precision (e.g., Oracle numbers). Avoids rounding errors, variable length by storing all digits plus where the decimal point is (not stored as a string) • Strings and BLOBS • Length and data • Time, coordinates, points … • System specific Pages and Blocks 31 Corner cases • When tuples are very big or some attribute is very big, instead of storing the whole tuple, one stores the fixed part of the tuple and a pointer to the variable, large size of the tuple (potentially in some other page) • Used for BLOBs (Binary Large Objects) • What is a large object is typically in reference to the page size (larger than some size, a page, half a page, more than one page …) • Usually, those large attributes are not processed by queries, putting them somewhere else speeds up scanning of the page as we do not need to scan the large object • Examples: the attribute is a piece of text (a long string) or a photo • BLOBs can be very large (more than one block!) Pages and Blocks 32Pages and Blocks 33 DLN DOB EXP F. Name L. Name M. Name Photo Street # 99999999 08/04/75 08/05/23 Janice SAMPLE Ann Main Street 123 BLOB Several options • Store as a BLOB on another block(s) • It can be read with the data • It does not affect scans • Accessible from the database • Store the name of a file where the BLOB is • Does not take space on the database • It does not affect scans • Requires to go somewhere else to retrieve Data in blocks and pages Pages and Blocks 34 Finding the page you need • Segment – Extent – Block/Page • The pages allocated to a given object (a table, an index, and captured in a segment) are managed through lists • These lists are stored as part of the segment header • See “Segments and File Storage” slide 28 Pages and Blocks 35 USED FREE Block ID (Extent,Offset) Block ID (Extent,Offset) Space Available Potential bottleneck • The free and used lists of a segment are a potential bottleneck, especially for transactions that will result in modifications • How these lists are implemented affects performance: • Use several free lists so that concurrent transactions can look for free space in parallel rather than conflict on access to the free list • Make the traversal of the free list fast and keep the list small (shorter the larger the pages, sort the free list by available size, cache positions …) • Make sure holes can be efficiently found (store the available space in each page in incremental steps by using a small amount of bits) Pages and Blocks 36 Finding tuples within a page • Slotted pages: • Each page has a header (checksum, version, transaction visibility, compression information, utilization, etc.) • Each tuple gets an id (typically, block ID and offset) • The page maintains a list of the “slots” storing tuples in a page by storing a pointer (offset) to the beginning of each tuple • Needed to store tuples of different sizes Pages and Blocks 37 HEADER Why slotted pages • To support variable length tuples • Tuples get a permanent tuple id (record id) that does not change • When data does not change, it uses the space very efficiently (this is the most common case) • When data changes, it requires careful management: • If a tuple is modified and becomes larger, use the original space to store a pointer to the new location of the tuple (can be in another block) • If a tuple is deleted, just remove the pointer • If a tuple is modified and becomes smaller, just leave the unnecessary space empty • For insertion, look for a page with enough free space and compact the page if needed Pages and Blocks 38 Percentage Free • The use of “Percentage Free” is to avoid the fragmentation that would occur if pages do not have enough space to modify a tuple that becomes larger: • Every modification will result in an indirection to another page • A few of them are acceptable, too many would slow down access • This space is reserved for growing tuples rather than for inserting Pages and Blocks 39 Percentage Used • The use of “Percentage Used” is to avoid having to constantly move a block from the used list to the free list • The block keeps track of how much space it has used and it is free • Only when enough free can it be used for inserting (probably for several inserts) • Otherwise a block can constantly go from FREE to USED to FREE with single tuple deletes and inserts, adding overhead in managing the lists Pages and Blocks 40 INSERT Tuple 1 Tuple 2 Tuple 3 … Space for one tuple Row vs column store Pages and Blocks 41 Row-store (or n-ary storage model) • Row store: • Tuples are stored as described so far, all their attributes together • A tuple can be quickly accessed and retrieved Pages and Blocks 42 ID Name Dept. Sem. 1 John D-INFK 3 2 Mary D-ITET 5 4 6John D-INFK 3 4 6Mary D-ITET 5 TABLE SLOTTED PAGE HEADER HEADER Pages and Blocks 43 “Data page layouts for relational databases on deep memory hierarchies”; The VLDB Journal, November 2002 Row store is for OLTP • OLTP = Online Transaction Processing • Typical of banking applications, shopping carts, etc. • Transactional operations (updates) • Operations mostly on a single tuple Pages and Blocks 44 SELECT balance FROM Accounts WHERE acc-no = 123456789 INDEX Block Row store cumbersome for complex queries Pages and Blocks 45 SELECT SUM(balance) FROM Accounts WHERE Accounts.balance > 1000 GROUP BY (Accounts.nationality) Block 1 Block 2 Block 3 Needs to retrieve all pages for the table Needs to scan all tuples Discards most of the data as it only needs two attributes Problematic for large tables => this is a lot of wasted bandwidth Column store • Instead of storing by tuples, store the data by columns • A block now contains columns (organized as slotted pages) Pages and Blocks 46 Name Dept Sem Age John D-INFK 3 21 Mary D-ITET 5 20 John Mary D-INFK D-ITET 3 5 21 20 Block Row Store John Mary D-INFK D-ITET 3 5 21 20 Block BlockBlockBlock Column Store Pages and Blocks 47 “Data page layouts for relational databases on deep memory hierarchies”; The VLDB Journal, November 2002 Only needs to read the attributes involved in the query Blocks contain only what is needed No extra blocks and no extra data has to be read Processing on row store Pages and Blocks 48 SELECT SUM(balance) FROM Accounts WHERE Accounts.balance > 1000 GROUP BY (Accounts.nationality) Name NameName Blocks Acc_# Acc-# Balance Balance Country Accounts Pages and Blocks 49 The Design and Implementation of Modern Column-Oriented Database Systems Foundations and Trends in Databases Vol. 5, No. 3 (2012) 197–280 https://stratos.seas.harvard.edu/files/stratos/files/columnstoresfntdbs.pdf Column store and vectorized processing • Modern processors heavily use vectorized processing to speed things up • SIMD/AVX allows to perform an operation simultaneously on a vector of values • A column store presents the data exactly in the vectorized representation needed to exploit SIMD • Very useful for numeric values and bit comparisons Pages and Blocks 50 Column stores and memory hierarchy • Column stores started to be heavily used to address the memory wall • Column stores are a more compact representation where a cache line is likely to bring data you want to see • Far better cache utilization than with row stores Pages and Blocks 51 CACHE CACHE ROW STORE COLUMN STORE Historical Overview • Idea is very old and originally applied to data on disks • Horizontal partitioning (sharding) • Vertical partitioning (stores columns or groups of columns on different files) • Today, column store is used in all analytical databases and many main memory databases • Improves bandwidth across memory/caches • Eliminates needs to deal with unwanted attributes • Compresses better • Can exploit SIMD Pages and Blocks 52 When column store is no that good • Column store suffers when: • Most of the attributes are needed anyway • When the tuple or parts of it needs to be reconstructed (as intermediate results or final results) • For updates and modifications • Alternative: PAX (Partition Attributes Across) representation • A block contains several tuples but organized as a column store • Reconstructing the tuple does not require to access several pages • “Data page layouts for relational databases on deep memory hierarchies”; The VLDB Journal, November 2002 Pages and Blocks 53Storage in Context 54https://docs.snowflake.com/en/user-guide/tables-clustering-micropartitions.html","libVersion":"0.5.0","langs":""}