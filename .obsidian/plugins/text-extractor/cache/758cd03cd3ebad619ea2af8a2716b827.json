{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s03-higher-order.pdf","text":"Higher-order Programming and Types David Basin Department of Computer Science ETH Z¨urich Functional Programming David Basin 1 Overview • Review of higher-order functions \u0011 Functions as arguments \u0011 Functions as results • Case study: matrix operations • Haskell’s type system Functional Programming Spring Semester, 2025 David Basin 2 First-order versus higher-order functions • First-order functions fo1 :: Int -> Int fo1 x = x + 3 fo2 :: Int -> Int -> Int fo2 x y = x + y + x * y • Higher-order functions ho1 :: (Int -> Int) -> Int ho1 f = f 2 ho2 :: (Int -> a) -> a ho2 f = f 2 ? ho2 (\\x->x+3) 5 :: Int • Which order is the function: mystery x = x ? Functional Programming Spring Semester, 2025 David Basin 3 Examples: map, filter, and fold map :: (a → b) → [a] → [b] map f [] = [] map f (x:xs) = f x : map f xs filter :: (a → Bool) → [a] → [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs foldr :: (a → b → b) → b → [a] → b foldr f e [] = e foldr f e (x:xs) = f x (foldr f e xs) Functional Programming Spring Semester, 2025 David Basin 4 These abstract general operations Map: iteratively apply a function to each element ? map (2*) [1 .. 5] [2, 4, 6, 8, 10] :: [Int] ? map (>2) [1 .. 5] [False, False, True, True, True] :: [Bool] Filter: selection ? filter (>2) [1 .. 5] [3, 4, 5] :: [Int] ? filter (2>) [1 .. 5] [1] :: [Int] Fold: use function to “combine” elements ? foldr (+) 0 [1 .. 5] 15 :: Int Functional Programming Spring Semester, 2025 David Basin 5 Examples with filter • Remove elements with property p (i.e., select those with ¬p) remove p = filter (not . p) ? remove (>2) [1 .. 5] [1, 2] :: [Int] • Partition lists using p part p xs = (filter p xs, remove p xs) ? part (>2) [1 .. 5] ([3, 4, 5],[1, 2]) :: ([Int],[Int]) • Which partitioning function is better? In what sense? partition p [] = ([],[]) partition p (x:xs) | p x = (x:yesses, nos) | otherwise = (yesses, x:nos) where (yesses, nos) = partition p xs Functional Programming Spring Semester, 2025 David Basin 6 Quick sort (again) • Quick sort with partition quicksort [] = [] quicksort (x:xs) = quicksort left ++ [x] ++ quicksort right where (left,right) = partition (<= x) xs • Which program is better? q [] = [] q (x:xs) = q [y | y<-xs, y <= x] ++ [x] ++ q [y | y<-xs, y > x] r [] = [] r (x:xs) = r left ++ (x : r right) where (left,right) = partition (<= x) xs Functional Programming Spring Semester, 2025 David Basin 7 Map and filter versus list comprehension • map and filter can be implemented using list comprehension map f xs = [f x | x <- xs] filter p xs = [x | x <- xs, p x] • Converse holds too: [expr | p <- s] implemented as1 let fun p = expr in map fun s Example ? [2*x | (x,_) <- [(1,2),(3,4),(5,6)]] [2, 6, 10] :: [Int] ? let fun (x,_) = 2*x in map fun [(1,2),(3,4),(5,6)] [2, 6, 10] :: [Int] 1Equal only when pattern matching with p succeeds on all elements of s. Exercise: generalize to allow for failure. Functional Programming Spring Semester, 2025 David Basin 8 Comprehension (cont.) • Guards require filter: [expr | p <- xs, guard] translated as let fun p = expr pred p = guard in map fun (filter pred xs) • Example ? [2 * x | x <- [1 .. 5], x > 2] [6, 8, 10] :: [Int] becomes ? let fun x = 2 * x pred x = (x>2) in map fun (filter pred [1 .. 5]) [6, 8, 10] :: [Int] Functional Programming Spring Semester, 2025 David Basin 9 An example with fold • foldr: right-associative fold foldr (⊕) e [l1, l2, . . . , ln] = l1 ⊕ (l2 ⊕ · · · ⊕ (ln ⊕ e)) foldr :: (a -> b -> b) -> b -> [a] -> b foldr f e [] = e foldr f e (x:xs) = f x (foldr f e xs) • foldl: left-associative fold foldl (⊕) e [l1, l2, . . . , ln] = ((e ⊕ l1) ⊕ l2) ⊕ · · · ⊕ ln foldl :: (b -> a -> b) -> b -> [a] -> b foldl f e [] = e foldl f e (x:xs) = foldl f (f e x) xs Functional Programming Spring Semester, 2025 David Basin 10 Fold (cont.) • No difference for associative functions (and e is neutral element) ? foldl (+) 0 [1,2,3] -- ((0 + 1) + 2) + 3 6 :: Int ? foldr (+) 0 [1,2,3] -- 1 + (2 + (3 + 0)) 6 :: Int • But not all (binary) functions are associative ? foldl (-) 0 [1,2,3] -- ((0 - 1) - 2) - 3 -6 :: Int ? foldr (-) 0 [1,2,3] -- 1 - (2 - (3 - 0)) 2 :: Int • How does one implement length with foldr and with foldl? Functional Programming Spring Semester, 2025 David Basin 11 Implementing length with foldr foldr (⊕) e [l1, l2, l3] = l1 ⊕ (l2 ⊕ (l3 ⊕ e)) Solution with 1 + (1 + (1 + 0)) length xs = foldr (\\_ y -> 1+y) 0 xs ? length [’a’, ’b’, ’c’] 3 :: Int Compare with the “standard” definition length [] = 0 length (_:xs) = 1 + length xs where length [’a’,’b’,’c’] = 1 + length [’b’,’c’] = ... = 1+(1+(1+0)) Solution with foldl: Exercise! Functional Programming Spring Semester, 2025 David Basin 12 Functions as “first-class objects” • Simple examples (ignoring complications of type classes): ? :type \\x -> x a -> a ? :type \\x -> x + 1 Int -> Int • Composition as example: (.) :: (b -> c) -> (a -> b) -> (a -> c) (f . g) x = f (g x) twice f = f . f ? :type twice (1+) Int -> Int ? twice (1+) 7 9 :: Int Functional Programming Spring Semester, 2025 David Basin 13 Partial application g :: Int -> Int -> Int g x y = x + 2 * y h :: Int -> Int h = g 1 ? h 10 21 :: Int ? map (g 10) [1,2,3,4,5] -- Partial application [12, 14, 16, 18, 20] :: [Int] ? map (10 ‘g‘) [1,2,3,4,5] -- Left section [12, 14, 16, 18, 20] :: [Int] ? map (‘g‘ 10) [1,2,3,4,5] -- Right section [21, 22, 23, 24, 25] :: [Int] ? map (\\x -> g x 10) [1,2,3,4,5] [21, 22, 23, 24, 25] :: [Int] Functional Programming Spring Semester, 2025 David Basin 14 Reminder • Zipper function zip (x:xs) (y:ys) = (x,y) : zip xs ys zip _ _ = [] • Example zip [2, 3, 4] [4, 5, 78] = [(2, 4), (3, 5), (4, 78)] zip [2, 3] [1, 2, 3] = [(2, 1), (3, 2)] • Uncurry uncurry :: (a -> b -> c) -> (a,b) -> c uncurry g = f where f (x,y) = g x y • Example g x y = x * y + 17 ? uncurry g (3,4) 29 :: Int Functional Programming Spring Semester, 2025 David Basin 15 Case study: operations on vectors and matrices • Vectors over Int type Vector = [Int] • Vector addition vecAdd :: Vector -> Vector -> Vector vecAdd (x:xs) (y:ys) = (x + y) : vecAdd xs ys vecAdd _ _ = [] ? vecAdd [1,2,3] [2,2,4] [3, 4, 7] :: [Int]   1 2 3   +   2 2 4   =   3 4 7   Replace recursion with map and zip: vecAdd v1 v2 = map (uncurry (+)) (zip v1 v2) Functional Programming Spring Semester, 2025 David Basin 16 zipWith = map + zip • Combination of zip and binary functions is common zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys zipWith f _ _ = [] • map (uncurry f) (zip ... ...) becomes zipWith f ... ...: vecAdd :: Vector -> Vector -> Vector vecAdd = zipWith (+) • Visualisation of zipWith : 1 : 2 : 3 [ ] : ′a ′ : ′b ′ : ′c ′ : ′d ′ [ ] : f 1 ′a ′ : f 2 ′b ′ : f 3 ′c ′ [ ] + zipWith f Functional Programming Spring Semester, 2025 David Basin 17 Matrix case study (cont.) • n × m matrix     a1,1 a1,2 . . . a1,m a2,1 a2,2 . . . a2,m ... ... ... an,1 an,2 . . . an,m     can be represented column-wise using lists [[a1,1, a2,1, . . . , an,1], [a1,2, a2,2, . . . , an,2], . . . , [a1,m, a2,m, . . . , an,m]] type Matrix = [Vector] • Addition of matrices matAdd :: Matrix -> Matrix -> Matrix matAdd = zipWith vecAdd ? matAdd [[1,2,3],[4,5,6]] [[7,8,9],[10,11,12]] [[8,10,12],[14,16,18]] :: [[Int]]  1 4 2 5 3 6   +  7 10 8 11 9 12   =   8 14 10 16 12 18   Functional Programming Spring Semester, 2025 David Basin 18 Matrix case study (cont.) • Constant vector of size n vconst :: Int -> Int -> Vector vconst 0 _ = [] vconst n x = x : vconst (n - 1) x        x x x ... x        • Unit matrix unit :: Int -> Matrix unit 0 = [] unit n = (1 : vconst (n - 1) 0) : map (0:) (unit (n - 1))        1 0 0 . . . 0 0 1 0 . . . 0 0 0 1 . . . 0 ... ... ... ... 0 0 0 . . . 1        Functional Programming Spring Semester, 2025 David Basin 19 Transposing a matrix A list of columns is converted to a list of rows     a1,1 a1,2 . . . a1,m a2,1 a2,2 . . . a2,m ... ... ... an,1 a2,2 . . . an,m     →     a1,1 a2,1 . . . an,1 a1,2 a2,2 . . . an,2 ... ... ... a1,m a2,m . . . an,m     tr :: Matrix -> Matrix tr [] = [] tr [v] = map (\\x -> [x]) v tr (v:vs) = zipWith (:) v (tr vs) tr [[1,2]] [[1], [2]] :: [[Int]] ? tr [[1,2],[3,4]] [[1, 3], [2, 4]] :: [[Int]] ( ) → ( )     a1,1 a2,1 ... an,1     → ( a1,1 a2,1 . . . an,1 )     a1,1 vs a2,1 ... an,1     →        a1,1 a2,1 . . . an,1 tr vs        Functional Programming Spring Semester, 2025 David Basin 20 Example of transposition tr [] = [] tr [v] = map (\\x -> [x]) v tr (v:vs) = zipWith (:) v (tr vs) tr [[1, 2], [3, 4]] = zipWith (:) [1, 2] (tr [[3, 4]]) = zipWith (:) [1, 2] (map (λx. [x]) [3, 4]) = zipWith (:) [1, 2] [[3], [4]] = (1 : [3]) : zipWith (:) [2] [[4]] = (1 : [3]) : ((2 : [4]) : zipWith (:) [] []) = (1 : [3]) : ((2 : [4]) : []) = [[1, 3], [2, 4]] Functional Programming Spring Semester, 2025 David Basin 21 Scalar (dot) product of two vectors • Sum of product of vectors v and w: v · w = ∑ i viwi • Version 1: Loop / accumulator skProd :: Vector -> Vector -> Int skProd xs ys = loop xs ys 0 where loop [] [] p = p loop (x:xs) (y:ys) p = loop xs ys (x * y + p) • Version 2: Explicit recursion skProd :: Vector -> Vector -> Int skProd (x:xs) (y:ys) = x*y + skProd xs ys skProd _ _ = 0 • Version 3: Using library functions (abstracted control) skProd :: Vector -> Vector -> Int skProd v w = sum (zipWith (*) v w) ? skProd [2,3] [4,5] 23 Functional Programming Spring Semester, 2025 David Basin 22 Matrix multiplication We first multiply an n × m matrix A with a vector b of size m.     a1,1 a1,2 . . . a1,m a2,1 a2,2 . . . a2,m ... ... ... an,1 an,2 . . . an,m     ·     b1 b2 ... bm     =     ∑m i=1 a1,ibi∑m i=1 a2,ibi ... ∑m i=1 an,ibi     ⇒ scalar product of A’s rows (columns of tr A) with b vecMult :: Matrix -> Vector -> Vector vecMult a b = map (‘skProd‘ b) (tr a) ? vecMult [[1,2,3],[4,5,6]] [7,8] [39,54,69] :: [Int] Functional Programming Spring Semester, 2025 David Basin 23 Matrix multiplication (cont.) Matrix multiplication iterates vecMult A over an m × k matrix B.     a1,1 . . . a1,m a2,1 . . . a2,m ... ... an,1 . . . an,m     ·     b1,1 b1,2 . . . b2,1 b2,2 . . . ... ... bm,1 bm,2 . . .     =     ∑m i=1 a1,ibi,1 ∑m i=1 a1,ibi,2 . . . ∑m i=1 a2,ibi,1 ∑m i=1 a2,ibi,2 . . . ... ... ∑m i=1 an,ibi,1 ∑m i=1 an,ibi,2 . . .     matMult :: Matrix -> Matrix -> Matrix matMult a b = map (vecMult a) b ? matMult [[1,2,3],[4,5,6]] [[7,8],[9,10]] [[39,54,69],[49,68,87]] :: [[Int]] Exercise: Scalar multiplication for vectors and matrices. Functional Programming Spring Semester, 2025 David Basin 24 Conclusion • First-order programming \u0011 Programming with elements of base types, like True or 13 \u0011 Close to machine architecture • Higher-order programming \u0011 Functions are first-class objects • Increases abstraction and ways of constructing programs • Other advantages like reusability and rapid prototyping Functional Programming Spring Semester, 2025 David Basin 25 Functional Programming Spring Semester, 2025 David Basin 26 Typing Functional Programming Spring Semester, 2025 David Basin 27 Type checking: an overview • Type checking should prevent “dangerous expressions” 2 + True, [2] : [3], 2 ++ [3, 4], fst 2 • Dangerous expressions =⇒ runtime error • Problem of which expressions are good (= non-dangerous) is undecidable Bad Expressions Expressions Typeable Slack Type systems in practice are conservative: they type only a subset of good expressions (pink), rejecting some good ones (blue). Functional Programming Spring Semester, 2025 David Basin 28 Typing overview (cont.) Bad Expressions Expressions Typeable Slack • Objectives for a type checker \u0011 quick, decidable, static analysis \u0011 permit as much generality/re-usability as possible \u0011 prevent runtime errors: subject reduction If e ↪→ e′ and ⊢ e :: τ , then ⊢ e′ :: τ . • Topic is very rich (theory of programming languages) • We examine here a simplified language: ‘Mini-Haskell’ Functional Programming Spring Semester, 2025 David Basin 29 Mini-Haskell — syntax • Programs are terms (let variables V and integers Z be given) t ::= V ∣ ∣ (λx. t) ∣ ∣ (t1 t2) ∣ ∣ True ∣ ∣ False ∣ ∣ (iszero t) ∣ ∣ Z ∣ ∣ (t1 + t2) ∣ ∣ (t1 ∗ t2) ∣ ∣ (if t0 then t1 else t2) ∣ ∣ (t1, t2) ∣ ∣ (fst t) ∣ ∣ (snd t) • Small but powerful language. Corresponds to fragment of Haskell iszero :: Int -> Bool iszero x = x == 0 ? (if (iszero (2*0)) then (fst (2,3)) else (snd (2,3))) 2 :: Int ? ((\\f x -> (if (iszero x) then (f 2) else (f 3))) ((\\x y -> y + x) 2) 5) 5 :: Int • Not all terms are meaningful, e.g. (iszero (λx. x)) Functional Programming Spring Semester, 2025 David Basin 30 Mini-Haskell — comments • Core is λ-calculus: variables, abstraction, and application (λx. ((x y) (λy. (x y)))) • Additional syntax and types can be easily added, e.g., &&, ||, Strings, . . . • We employ syntactic sugar, like omitting parenthesis x y z instead of ((x y) z) τ1 → τ2 → τ3 instead of (τ1 → (τ2 → τ3)) • A substantial simplification of Haskell — but the central core! Functional Programming Spring Semester, 2025 David Basin 31 Typing • Types (VT is a set of type variables: a, b, . . . ) τ ::= VT ∣ ∣ Bool ∣ ∣ Int ∣ ∣ (τ, τ ) ∣ ∣ (τ → τ ) • Examples: a, Int, (Int, Bool), ((a → Int) → (a, a)), . . . • Type system notation based on typing judgement: Γ ⊢ t :: τ \u0011 Γ is a set of bindings xi : τi, mapping variables to types. Intuitively Γ represents a kind of typing “symbol table”. \u0011 t is a term \u0011 τ is a type • Intuition: given symbol table Γ, then term t has type τ . x : Int ⊢ x + 2 :: Int x : Int, f : Bool → Bool ̸⊢ f x :: Bool Functional Programming Spring Semester, 2025 David Basin 32 Typing — proof system • Proof rules formulated in terms of type judgements J J1 . . . Jn J • Example axiom (n ∈ {. . . , −1, 0, 1, . . . }): Int Γ ⊢ n :: Int • Example rule (op ∈ {+, ∗}): Γ ⊢ t1 :: Int Γ ⊢ t2 :: Int BinOp Γ ⊢ (t1 op t2) :: Int • Proofs built from rules and axioms Int x : Int ⊢ 2 :: Int ... BinOp x : Int ⊢ (x + 1) :: Int BinOp x : Int ⊢ (2 + (x + 1)) :: Int Functional Programming Spring Semester, 2025 David Basin 33 Rules for core λ-calculus Axiom: Var . . . , x : τ , . . . ⊢ x :: τ Abstraction (x /∈ Γ): Γ, x : σ ⊢ t :: τ Abs Γ ⊢ (λx. t) :: σ → τ Application: Γ ⊢ t1 :: σ → τ Γ ⊢ t2 :: σ App Γ ⊢ (t1 t2) :: τ Examples: Var x : a ⊢ x :: a Abs ⊢ (λx. x) :: a → a Var x : a, y : bx : a, y : b ⊢ x :: a Abs x : ax : a ⊢ λy. xλy. x :: b → ab → a Abs ⊢ λx. λy. x :: a → b → a Functional Programming Spring Semester, 2025 David Basin 34 A larger example Var . . . , x : τ, . . . ⊢ x :: τ Γ,x : σ ⊢ t :: τ Abs Γ ⊢ (λx. t) :: σ → τ Γ ⊢ t1 :: σ → τ Γ ⊢ t2 :: σ App Γ ⊢ (t1 t2) :: τ Var Γ ⊢ x :: ??a → (?b → c) Var Γ ⊢ z :: ??a App Γ ⊢ x zx z :: ?b → c Var Γ ⊢ y :: ???a → b Var Γ ⊢ z :: ???a App Γ ⊢ y zy z :: ?b App Γ= ︷ ︸︸ ︷ x : a → (b → c), y : a → b, z : az : a ⊢ (x z) (y z)(x z) (y z) :: c Abs x : a → (b → c), y : a → bx : a → (b → c), y : a → b ⊢ λz. (x z) (y z)λz. (x z) (y z) :: a → ca → c Abs x : a → (b → c)x : a → (b → c) ⊢ λy. λz. (x z) (y z)λy. λz. (x z) (y z) :: (a → b) → (a → c)(a → b) → (a → c) Abs ⊢ λx. λy. λz. (x z) (y z) :: (a → (b → c)) → (a → b) → (a → c) Exercise: ⊢ (λz. z) (λx. λy. x) :: a → b → a Functional Programming Spring Semester, 2025 David Basin 35 Examples in ghc ? :type \\x -> x \\x -> x :: a -> a ? :type \\x y -> x \\x y -> x :: a -> b -> a ? :type \\x y z -> x z (y z) \\x y z -> x z (y z) :: (a -> b -> c) -> (a -> b) -> a -> c ? :type (\\z -> z) (\\x y -> x) (\\z -> z) (\\x y -> x) :: a -> b -> a Functional Programming Spring Semester, 2025 David Basin 36 Further typing rules for mini-Haskell • Base types Int Γ ⊢ n :: Int True Γ ⊢ True :: Bool False Γ ⊢ False :: Bool • Operations (op ∈ {+, ∗}): Γ ⊢ t :: Int iszero Γ ⊢ (iszero t) :: Bool Γ ⊢ t1 :: Int Γ ⊢ t2 :: Int BinOp Γ ⊢ (t1 op t2) :: Int Γ ⊢ t0 :: Bool Γ ⊢ t1 :: τ Γ ⊢ t2 :: τ if Γ ⊢ (if t0 then t1 else t2) :: τ • Tuples Γ ⊢ t1 :: τ1 Γ ⊢ t2 :: τ2 Tuple Γ ⊢ (t1, t2) :: (τ1, τ2) Γ ⊢ t :: (τ1, τ2) fst Γ ⊢ (fst t) :: τ1 Γ ⊢ t :: (τ1, τ2) snd Γ ⊢ (snd t) :: τ2 • Example Var x : Int ⊢ x :: Int Int x : Int ⊢ 2 :: Int BinOp x : Int ⊢ x + 2 :: Int Abs ⊢ λx. x + 2 :: Int → IntFunctional Programming Spring Semester, 2025 David Basin 37 Type inference Var . . . , x : τ , . . . ⊢ x :: τ Γ, x : σ ⊢ t :: τ Abs Γ ⊢ (λx. t) :: σ → τ Γ ⊢ t1 :: σ → τ Γ ⊢ t2 :: σ App Γ ⊢ (t1 t2) :: τ • Syntax-directed typing rules specify algorithm for computing type 1. Start with judgement ⊢ t :: τ0 with type variable τ0. 2. Build derivation tree bottom-up by applying rules. Introduce fresh type variables and collect constraints if needed. 3. Solve constraints (unification) to get possible types. • Example: Var z : τ1 ⊢ z :: τ0 Abs ⊢ λz. z :: τ1 → τ0 Var x : τ2 ⊢ x :: τ3 Abs ⊢ λx. x :: τ1 App ⊢ (λz. z) (λx. x) :: τ0 τ1 = τ0 τ1 = τ2 → τ3 τ2 = τ3 I.e., τ0 = τ3 → τ3 E.g., τ0 = a → a and τ0 = Int → Int are correct types. Functional Programming Spring Semester, 2025 David Basin 38 Type inference example Var Γ ⊢ x :: ((τ3 → Int), τ4) fst Γ ⊢ fst x :: τ3 → Int Int Γ ⊢ 2 :: τ5 True Γ ⊢ True :: τ6 Tuple Γ ⊢ (2, True) :: τ3 App Γ ⊢ (fst x) (2, True) :: Int iszero Γ=︷ ︸︸ ︷ x : τ1 ⊢ iszero ((fst x) (2, True)) :: τ2 Abs ⊢ λx. iszero ((fst x) (2, True)) :: τ0 Constraints: τ0 = τ1 → τ2 τ2 = Bool τ1 = ((τ3 → Int), τ4) τ3 = (τ5, τ6) τ5 = Int τ6 = Bool Most general type: τ0 = (((Int, Bool) → Int), a) → Bool Exercise: Infer the type of λx. λy. (iszero (x y), x 3) Functional Programming Spring Semester, 2025 David Basin 39 When type inference fails • Some terms are untypeable. Type inference fails to build inference tree or solve constraints. • Example: Var x : τ1 ⊢ x :: (τ3, τ5) fst x : τ1 ⊢ fst x :: τ3 Var x : τ1 ⊢ x :: Int iszero x : τ1 ⊢ iszero x :: τ4 Tuple x : τ1 ⊢ (fst x, iszero x) :: τ2 Abs ⊢ λx. (fst x, iszero x) :: τ0 • Constraints: τ0 = τ1 → τ2 τ2 = (τ3, τ4) τ1 = (τ3, τ5) τ4 = Bool τ1 = Int (τ3, τ5) and Int do not unify. Constraints have no solution, so λx. (fst x, iszero x) untypeable. Functional Programming Spring Semester, 2025 David Basin 40 Self application • Self application means “applying a function f to itself”. • Self application λf. f f is not typeable. Var f : τ1 ⊢ f :: τ3 → τ2 Var f : τ1 ⊢ f :: τ3 App f : τ1 ⊢ f f :: τ2 Abs ⊢ λf. f f :: τ0 τ0 = τ1 → τ2 τ1 = τ3 → τ2 τ1 = τ3 • τ3 = τ3 → τ2 requires infinite function type ((. . . (. . . → τ2) → τ2) → τ2, but Haskell types are finite. So, there is no solution to the constraints. • Compare with natural numbers: x = 1 + x has only solution ∞, but ∞ /∈ N. Functional Programming Spring Semester, 2025 David Basin 41 GHC examples ? :t \\x -> iszero ((fst x) (2 :: Int, True)) \\x -> iszero ((fst x) (2 :: Int, True)) :: ((Int, Bool) -> Int, b) -> Bool ? :t (\\n -> if iszero n then 1 else 2*n) ((\\x -> x+2) (fst (2,True))) (\\n -> if iszero n then 1 else 2*n) ((\\x -> x+2) (fst (2,True))) :: Int ? (\\n -> if iszero n then 1 else 2*n) ((\\x -> x+2) (fst (2,True))) 8 :: Int ? :t \\p -> (snd p) (fst p) \\p -> snd p (fst p) :: (a,a -> b) -> b ? :t \\x -> (fst x, iszero x) ERROR: Couldn’t match expected type ‘Int’ with actual type ‘(t0, b0)’ ? :t \\x -> x x ERROR: Occurs check: cannot construct the infinite type: t1 = t1 -> t0 Functional Programming Spring Semester, 2025 David Basin 42 Curry-Howard isomorphism • Propositions as types \u0011 Type constructor “→” corresponds to propositional logic connective “→” \u0011 Atomic types correspond to propositional variables • Rules correspond to those for (minimal) propositional logic axiom . . . , τ, . . . ⊢ τ Γ, σ ⊢ τ →-I Γ ⊢ σ → τ Γ ⊢ σ → τ Γ ⊢ σ →-E Γ ⊢ τ • Example axiom τ, σ ⊢ τ →-I τ ⊢ σ → τ →-I ⊢ τ → σ → τ • Correspondence actually quite deep Functional Programming Spring Semester, 2025 David Basin 43 Summary of Mini-Haskell Typing Rules Var . . . , x : τ, . . . ⊢ x :: τ Γ, x : σ ⊢ t :: τ Abs Γ ⊢ λx. t :: σ → τ Γ ⊢ t1 :: σ → τ Γ ⊢ t2 :: σ App Γ ⊢ t1 t2 :: τ Γ ⊢ t :: Int iszero Γ ⊢ iszero t :: Bool Int Γ ⊢ n :: Int True Γ ⊢ True :: Bool False Γ ⊢ False :: Bool Γ ⊢ t1 :: Int Γ ⊢ t2 :: Int BinOp Γ ⊢ (t1 op t2) :: Int for op ∈ {+, ∗} Γ ⊢ t0 :: Bool Γ ⊢ t1 :: τ Γ ⊢ t2 :: τ if Γ ⊢ if t0 then t1 else t2 :: τ Γ ⊢ t1 :: τ1 Γ ⊢ t2 :: τ2 Tuple Γ ⊢ (t1, t2) :: (τ1, τ2) Γ ⊢ t :: (τ1, τ2) fst Γ ⊢ fst t :: τ1 Γ ⊢ t :: (τ1, τ2) snd Γ ⊢ snd t :: τ2 Functional Programming Spring Semester, 2025 David Basin 44 Type Classes Functional Programming Spring Semester, 2025 David Basin 45 Monomorphic versus polymorphic • Some functions are monomorphic xor x y = (x || y) && (not (x && y)) ? :type xor xor :: Bool -> Bool -> Bool • Others are polymorphic [] ++ ys = ys (x:xs) ++ ys = x : (xs ++ ys) ? :type (++) (++) :: [a] -> [a] -> [a] • Monomorphic or polymorphic? allEqual x y z = (x == y) && (y == z) Functional Programming Spring Semester, 2025 David Basin 46 Example (cont.) • Type of allEqual x y z = (x == y) && (y == z) ? ? allEqual 4 (2 + 2) (1+3) True :: Bool ? allEqual \"hi there\" (\"hi \" ++ \"there\") (’h’:\"i there\") True :: Bool ? allEqual (\\x -> x + 1) (1+) (+1) ERROR: ... • Haskell type allEqual :: Eq a => a -> a -> a -> Bool Functional Programming Spring Semester, 2025 David Basin 47 Type classes — a “middle way” • Polymorphism restricted using class constraints allEqual :: Eq a => a -> a -> a-> Bool allEqual x y z = (x == y) && (y == z) Functions for precisely those types a that belong to the class Eq • A class defines a set of types. E.g., Eq is the equality class \u0011 Int ∈ Eq ? allEqual 3 (2+1) (1+2) True :: Bool \u0011 Int → Int ̸∈ Eq ? allEqual (\\x -> x + 1) (1+) (+1) ERROR: a -> a is not an instance of class \"Eq\" Functional Programming Spring Semester, 2025 David Basin 48 Definition of the Eq class • Definition (from Prelude.hs) class Eq a where (==) :: a -> a -> Bool (/=) :: a -> a -> Bool x /= y = not (x==y) • Definition includes Class name: Eq Signature: List of function names and types Default implementations (optional): can be overwritten later • Elements of the class are called instances Functional Programming Spring Semester, 2025 David Basin 49 Examples of Eq constrained types • Classes allow restricted form of type generalization allEqual :: Int -> Int -> Int -> Bool allEqual n m p = (n == m) && (m == p) • Most general type with class constraint allEqual :: Eq t => t -> t -> t -> Bool • Element of a list elem :: Eq t => t -> [t] -> Bool elem _ [] = False elem a (x:xs) = (a == x) || elem a xs Functional Programming Spring Semester, 2025 David Basin 50 Instances class Eq a where (==), (/=) :: a -> a -> Bool x /= y = not (x==y) • instance builds instances by “interpreting” signature functions instance Eq Bool where True == True = True False == False = True _ == _ = False • Instances of primitive types like Int or Double use built-in (primitive) equalities Functional Programming Spring Semester, 2025 David Basin 51 Example: visible (and measurable) types class Visible t where stringOf :: t -> String size :: t -> Int instance Visible Char where stringOf ch = [ch] size _ = 1 instance Visible Bool where stringOf True = \"Wahr\" stringOf False = \"Falsch\" size b = 1 ? (stringOf ’e’) ++ \"ine \" ++ (stringOf True) ++ \"e Aussage\" \"eine Wahre Aussage\" :: [Char] Functional Programming Spring Semester, 2025 David Basin 52 Example (cont.) • If t is visible, then a list of type [t] is also visible instance Visible t => Visible [t] where stringOf xs = concat (map stringOf xs) size xs = foldr (+) 0 (map size xs) ? size [True,False] 2 :: Int ? stringOf [True,False] \"WahrFalsch\" :: [Char] So class membership can depend on membership for other types • Equality over lists instance Eq a => Eq [a] where [] == [] = True (x:xs) == (y:ys) = x==y && xs==ys _ == _ = False Functional Programming Spring Semester, 2025 David Basin 53 Derived classes • Classes themselves can also depend on type conditions class Eq a => Ord a where (<), (>), (<=), (>=) :: a -> a -> Bool max, min :: a -> a -> a -- implement all operators except (<=) x < y = x <= y && x /= y x >= y = y <= x x > y = y <= x && x /= y max x y | x <= y = y | otherwise = x min x y | x <= y = x | otherwise = y • If a belongs to Ord, then a must also belong to Eq • Functions for Eq are inherited and some new ones must be given. instance Ord Int where (<=) = primLeInt Functional Programming Spring Semester, 2025 David Basin 54 Class hierarchies • Classes can be hierarchically structured class Eq a where ... class Eq a => Ord a where ... class Num a where (+), (-), (*) :: a -> a -> a ... class (Num a, Ord a) => Real a where toRational :: a -> Rational class (Real a, Enum a) => Integral a where quot, rem, div, mod :: a -> a -> a ... • Inheritance hierarchies like in OO-programming • Other similarities, like defaults and overriding Functional Programming Spring Semester, 2025 David Basin 55 Comparison: type classes vs. OO programming Haskell class Visible t where stringOf :: t -> String size :: t -> Int class Eq t => Ord t where ... class Foo t where foo :: t -> t bar :: t -> Bool bar x = True instance Visible Int where stringOf x = ... size x = 0 sort :: Ord t => [t] -> [t] sort xs = ... Java interface Visible { String stringOf(); Integer size(); } interface Ord extends Eq { } abstract class Foo { abstract Foo foo(); Boolean bar() { return True; } } class Integer implements Visible { String stringOf() { ... } Integer size() { return 0 } } static <T extends Ord> List<T> sort(List<T> xs) { ... } Functional Programming Spring Semester, 2025 David Basin 56 Quick sort (again) • Which type? sort [] = [] sort (a:x) = sort [y | y<-x, y<=a] ++ [a] ++ sort [y | y<-x, y>a] • Operations <= and > require Ord a => [a] -> [a] • Ord instances for many Haskell types defined in Haskell Prelude ? sort [5,4,7] [4, 5, 7] :: [Int] ? sort [\"banana\", \"apple\", \"carrot\"] [\"apple\", \"banana\", \"carrot\"] :: [[Char]] ? sort [True, False, True] [False, True, True] :: [Bool] Functional Programming Spring Semester, 2025 David Basin 57 Example (cont.) • Parameterization allows further orders (per type) sort’ ord [] = [] sort’ ord (a:x) = sort’ ord [y | y<-x, ord y a ] ++ [a] ++ sort’ ord [y | y<-x, not(ord y a)] ? sort’ (<) [2,5,3] [2, 3, 5] :: [Int] ? sort’ (>) [2,5,3] [5, 3, 2] :: [Int] ? sort’ (\\x y -> x ‘mod‘ 10 < y ‘mod‘ 10) [21,55,30,8,92,15] [30, 21, 92, 55, 15, 8] :: [Int] ? sort’ (\\x y -> reverse x < reverse y) [\"apple\",\"banana\",\"peach\"] [\"banana\", \"apple\", \"peach\"] :: [[Char]] Functional Programming Spring Semester, 2025 David Basin 58 Type classes and resolution of overloading • Execution of (parametric) polymorphic functions is independent of type of arguments • Classes implement “ad hoc” polymorphism \u0011 Operation depends on argument types • Selection of the actual function: During compilation: if argument types are statically known. Run time: using “look-up” tables. Analogous to method look-up. Functional Programming Spring Semester, 2025 David Basin 59 Type classes Show and Read type ShowS = String -> String -- difference list class Show a where -- simplifying slightly show :: a -> String showList :: [a] -> ShowS show x = ... showList xs s = ... ? :t show show :: Show a => a -> String ? show (-1) \"-1\" ? show [’H’,’e’,’l’,’l’,’o’] \"\\\"Hello\\\"\" Type class Read is more complicated. Usually suffices to know about read. ? :t read read :: Read a => String -> a ? read \"\\\"Hello\\\"\" :: String \"Hello\" Functional Programming Spring Semester, 2025 David Basin 60 Type class Foldable • Abstract folds over data structures (more examples next week) class Foldable t where foldr :: (a -> b -> b) -> b -> t a -> b ... -- more operations with default implementations instance Foldable [] where foldr f z [] = z foldr f z (x:xs) = f x (foldr f z xs) • Type class parameter t is a type constructor, not a type. • Fold-like operations on lists are generic: ? :t length length :: Foldable t => t a -> Int ? :t foldl foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b Functional Programming Spring Semester, 2025 David Basin 61 Conclusion: typing in Haskell • Haskell features a powerful type system \u0011 Parametric polymorphic functions \u0011 Overloading of functions using type classes • Type checking is automatic \u0011 No proofs, but instead type inference • Safe type system \u0011 prevents runtime errors, e.g., 2 + True \u0011 and offers considerable flexibility, e.g., quick sort Functional Programming Spring Semester, 2025","libVersion":"0.5.0","langs":""}