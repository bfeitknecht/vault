{"path":"sem2/PProg/VRL/slides/PProg-L20-granularity.pdf","text":"spcl.inf.ethz.ch @spcl_eth TORSTEN HOEFLER Parallel Programming Interface, RW, and Fine-grained Locks Source: slashdot.com source: eetimes.com https://ainowinstitute.org/publication/policy/compute-and-ai spcl.inf.ethz.ch @spcl_eth ▪ Producer/Consumer queues ▪ Single ▪ Many ▪ Monitors for implementing Producer/Consumer ▪ Making object locks more powerful Simpler for mutual waiting use-cases ▪ Wait/signal Some pitfalls – check elision (always use a while loop!) + waking the wrong thread (signal all if there are different-type waiters) Today: lost signals and sleeping barbers Yesterday 2 spcl.inf.ethz.ch @spcl_eth ▪ Explicit interface locks ▪ More flexibility than monitors ▪ await/signal ▪ Reader/Writer locks ▪ And some more tricks and optimizations ▪ Lock granularity ▪ Fine-grained hand-over-hand ▪ Optimistic ▪ Lazy Learning goals today 3 spcl.inf.ethz.ch @spcl_eth class Queue { int in=0, out=0, size; long buf[]; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); Queue(int s) { size = s; buf = new long[size]; } ... } 4 Producer / Consumer with explicit Lock spcl.inf.ethz.ch @spcl_eth void enqueue(long x) { lock.lock(); while (isFull()) try { notFull.await(); } catch (InterruptedException e){} doEnqueue(x); notEmpty.signal(); lock.unlock(); } long dequeue() { long x; lock.lock(); while (isEmpty()) try { notEmpty.await(); } catch (InterruptedException e){} x = doDequeue(); notFull.signal(); lock.unlock(); return x; } 5 Producer / Consumer with explicit Lock spcl.inf.ethz.ch @spcl_eth Disadvantage of the solution: notFull and notEmpty signal will be sent in any case, even when no threads are waiting. Seemingly simple solution (in barber analogy) 1. Barber cuts hair, when done, check waiting room, if nobody left, sleep 2. Client arrives, either enqueues or wakes sleeping barber What can go wrong (really only in a threaded world)? Sleeping barber requires additional counters for checking if processes are waiting: 𝑚 ≤ 0 ⇔ buffer full & -𝑚 producers (clients) are waiting 𝑛 ≤ 0 ⇔ buffer empty & -𝑛 consumers (barbers) are waiting 6 The Sleeping Barber Variant (E. Dijkstra) spcl.inf.ethz.ch @spcl_eth class Queue { int in=0, out=0, size; long buf[]; final Lock lock = new ReentrantLock(); int n = 0; final Condition notFull = lock.newCondition(); int m; final Condition notEmpty = lock.newCondition(); Queue(int s) { size = s; m = size-1; buf = new long[size]; } ... } 7 Producer Consumer, Sleeping Barber Variant Two variables  sic! (cf. last lecture) spcl.inf.ethz.ch @spcl_eth void enqueue(long x) { lock.lock(); m--; if (m<0) while (isFull()) try { notFull.await(); } catch(InterruptedException e){} doEnqueue(x); n++; if (n<=0) notEmpty.signal(); lock.unlock(); } long dequeue() { long x; lock.lock(); n--; if (n<0) while (isEmpty()) try { notEmpty.await(); } catch(InterruptedException e){} x = doDequeue(); m++; if (m<=0) notFull.signal(); lock.unlock(); return x; } 8 Producer Consumer, Sleeping Barber Variant spcl.inf.ethz.ch @spcl_eth • Always have a condition predicate • Always test the condition predicate: ▪ before calling wait ▪ after returning from wait ➢Always call wait in a loop • Ensure state is protected by lock associated with condition 9 Guidelines for using condition waits spcl.inf.ethz.ch @spcl_eth Java (luckily for us) provides many common synchronization objects: • Semaphores • Barriers (CyclicBarrier) • Producer / Consumer queues • and many more... (Latches, Futures, ...) 10 Check out java.util.concurrent spcl.inf.ethz.ch @spcl_eth Reader / Writer Locks Literature: Herlihy – Chapter 8.3 11 spcl.inf.ethz.ch @spcl_eth Recall: ▪ Multiple concurrent reads of same memory: Not a problem ▪ Multiple concurrent writes of same memory: Problem ▪ Multiple concurrent read & write of same memory: Problem So far: ▪ If concurrent write/write or read/write might occur, use synchronization to ensure one-thread-at-a-time But this is unnecessarily conservative: ▪ Could still allow multiple simultaneous readers! Reading vs. writing 12 spcl.inf.ethz.ch @spcl_eth Consider a hashtable with one coarse-grained lock ▪ So only one thread can perform operations at a time But suppose: ▪ There are many simultaneous lookup operations ▪ insert operations are very rare Note: Important that lookup does not actually mutate shared memory, like a move-to-front list operation would Example 13 Number of edits (2007-04/26/2021): 1,020,000,000 Average views per day: ~200,000,000 → 0.12% write rate spcl.inf.ethz.ch @spcl_eth A new abstract data type for synchronization : The reader/writer lock This lock’s states fall into three categories: ▪ “not held” ▪ “held for writing” by one thread ▪ “held for reading” by one or more threads Reader/writer locks 0  writers  1 0  readers writers*readers == 0 14 spcl.inf.ethz.ch @spcl_eth new: make a new lock, initially “not held” acquire_write: block if currently “held for reading” or “held for writing”, else make “held for writing” release_write: make “not held” acquire_read: block if currently “held for writing”, else make/keep “held for reading” and increment readers count release_read: decrement readers count, if 0, make “not held” Reader/writer locks 15 spcl.inf.ethz.ch @spcl_eth class Hashtable<K,V> { … // coarse-grained, one lock for table RWLock lk = new RWLock(); … Pseudocode example void insert(K key, V val) { int bucket = hashval(key); lk.acquire_write(); … write V to array[bucket] … lk.release_write(); } … } 16 V lookup(K key) { int bucket = hashval(key); lk.acquire_read(); … read array[bucket] … lk.release_read(); } spcl.inf.ethz.ch @spcl_eth class RWLock { int writers = 0; int readers = 0; synchronized void acquire_read() { while (writers > 0) try { wait(); } catch (InterruptedException e) {} readers++; } synchronized void release_read() { readers--; notifyAll(); } A Simple Monitor-based Implementation synchronized void acquire_write() { while (writers > 0 || readers > 0) try { wait(); } catch (InterruptedException e) {} writers++; } synchronized void release_write() { writers--; notifyAll(); } } Exercise: come up with a better performing version using condition variables! 17 Is this lock fair? The simple implementation gives priority to readers: • when a reader reads, other readers can enter • no writer can enter during readers reading spcl.inf.ethz.ch @spcl_eth class RWLock { int writers = 0; int readers = 0; int writersWaiting = 0; synchronized void acquire_read() { while (writers > 0 || writersWaiting > 0) try { wait(); } catch (InterruptedException e) {} readers++; } synchronized void release_read() { readers--; notifyAll(); } Strong priority to the writers synchronized void acquire_write() { writersWaiting++; while (writers > 0 || readers > 0) try { wait(); } catch (InterruptedException e) {} writersWaiting--; writers++; } synchronized void release_write() { writers--; notifyAll(); } } • Writers 18 Is this lock now fair? (this was just to see of you’re awake) spcl.inf.ethz.ch @spcl_eth What is fair in this context? For example ▪ When a writer finishes, a number k of currently waiting readers may pass. ▪ When the k readers have passed, the next writer may enter (if any), otherwise further readers may enter until the next writer enters (who has to wait until current readers finish). A fair(er) model 19 spcl.inf.ethz.ch @spcl_eth class RWLock{ int writers = 0; int readers = 0; int writersWaiting = 0; int readersWaiting = 0; int writersWait = 0; synchronized void acquire_read() { readersWaiting++; while (writers > 0 || (writersWaiting > 0 && writersWait <= 0)) try { wait(); } catch (InterruptedException e) {} readersWaiting--; writersWait--; readers++; } synchronized void release_read() { readers--; notifyAll(); } RW locks - A fair(er) model synchronized void acquire_write() { writersWaiting++; while (writers > 0 || readers > 0 || writersWait > 0) try { wait(); } catch (InterruptedException e) {} writersWaiting--; writers++; } synchronized void release_write() { writers--; writersWait = readersWaiting; notifyAll(); } } When a writer finishes, the number of currently waiting readers may pass. Writers have to wait until the waiting readers have finished. Writers are waiting and the readers don't have priority any more. writers: # writers in CS readers: # readers in CS writersWaiting: # writers trying to enter CS readersWaiting: # readers trying to enter CS writersWait: # readers the writers have to wait Exercise: come up with a better performing version using condition variables! Introduce an upper bound of k readers! 20 spcl.inf.ethz.ch @spcl_eth A reader/writer lock implementation (“not our problem”) usually gives priority to writers: ▪ Once a writer blocks, no readers arriving later will get the lock before the writer ▪ Otherwise an insert could starve Re-entrant? ▪ Mostly an orthogonal issue ▪ But some libraries support upgrading from reader to writer Reader/writer lock details 21 spcl.inf.ethz.ch @spcl_eth Java’s synchronized statement does not support reader/writer Instead, library java.util.concurrent.locks.ReentrantReadWriteLock Different interface: methods readLock and writeLock return objects that themselves have lock and unlock methods Does not have writer priority or reader-to-writer upgrading ▪ Always read the documentation In Java 22 spcl.inf.ethz.ch @spcl_eth LOCK GRANULARITY Literature: Herlihy – Chapter 9 23 spcl.inf.ethz.ch @spcl_eth ▪ Coarse-grained locking ▪ Fine-grained locking ▪ Optimistic synchronization (locking) ▪ Lazy synchronization (locking) ▪ Next up: Lock-free synchronization The Five-Fold Path 24 spcl.inf.ethz.ch @spcl_eth Add, Remove, and Find unique elements in a sorted linked list. ▪ add(c) ▪ remove(c) Running Example: Sequential List Based Set a b d e c a b c d 25 spcl.inf.ethz.ch @spcl_eth public class Set<T> { private class Node { T item; int key; Node next; } private Node head; private Node tail; public boolean add(T x) {...}; public boolean remove(T x) {...}; public boolean contains(T x) {...}; } Set and Node a b c head tail Note that the list is not \"in place\" but provides references to its items 26 spcl.inf.ethz.ch @spcl_eth public synchronized boolean add(T x) {...}; public synchronized boolean remove(T x) {...}; public synchronized boolean contains(T x) {...}; Simple, but a bottleneck for all threads. Coarse Grained Locking a b d e c 27 spcl.inf.ethz.ch @spcl_eth Often more intricate than visible at a first sight • requires careful consideration of special cases Idea: split object into pieces with separate locks • no mutual exclusion for algorithms on disjoint pieces Fine grained Locking 28 spcl.inf.ethz.ch @spcl_eth remove(c) Is this ok? Let's try this a b c d 29 spcl.inf.ethz.ch @spcl_eth Thread A: remove(c) Thread B: remove(b) c not deleted!  Let's try this a b c d AB 30 spcl.inf.ethz.ch @spcl_eth ▪ When deleting, the next field of next is read, i.e., next also has to be protected. ▪ A thread needs to lock both, predecessor and the node to be deleted (hand-over-hand locking). What's the problem? a b d e BB 31 spcl.inf.ethz.ch @spcl_eth public boolean remove(T item) { Node pred = null, curr = null; int key = item.hashCode(); head.lock(); try { pred = head; curr = pred.next; curr.lock(); try { // find and remove } finally { curr.unlock(); } } finally { pred.unlock(); } } Remove method hand over hand 32 while (curr.key < key) { pred.unlock(); pred = curr; // pred still locked curr = curr.next; curr.lock(); // lock hand over hand } if (curr.key == key) { pred.next = curr.next; // delete return true; } return false; remark: sentinel at front and end of list prevents an exception here","libVersion":"0.3.2","langs":""}