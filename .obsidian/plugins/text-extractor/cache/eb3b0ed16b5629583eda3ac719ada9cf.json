{"path":"sem3/A&D/UE/s/A&D-s-u10.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 25 November 2024 Johannes Lengler, David Steurer Kasper Lindberg, Lucas Slot, Hongjie Chen, Manuel Wiedmer Algorithms & Data Structures Exercise sheet 10 HS 24 The solutions for this sheet are submitted on Moodle until 1 December 2024, 23:59. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. The solutions are intended to help you understand how to solve the exercises and are thus more detailed than what would be expected at the exam. All parts that contain explanation that you would not need to include in an exam are in grey. Exercise 10.1 Shortcutting closed Eulerian walks (1 point). Let G = (V, E) be the complete graph meaning we have an edge set E equal to all possible edges between distinct vertices. Furthermore, there is a weight function w : E → R≥0 on the edges which satisfies a ‘metric’ property: for any distinct u, v, w ∈ V we have w({u, w}) ≤ w({u, v}) + w({v, w}). Given a sequence of edges C = (e1, . . . , ek) which form a cycle in G, the weight of this cycle is defined as w(C) = ∑k i=1 w(ei). Now consider another graph H = (V, F ) which has the same vertices as G. Furthermore, we can create a weight function w′ : F → R≥0 compatible with w meaning for each f ∈ F , if f ’s endpoints are u and v then w′(f ) = w({u, v}). Suppose that H is connected and has a closed Eulerian walk denoted by a sequence of edges T = (e1, . . . , ek). The weight of the walk is defined as w′(T ) = ∑k i=1 w′(ei). Describe an algorithm that takes a closed Eulerian walk T of H and produces a Hamiltonian cycle C in G with weight at most that of the closed Eulerian walk, meaning w(C) ≤ w′(T ). Your algorithm should have runtime O(|F |). Argue why your algorithm is correct and why it satisfies the runtime bound. Solution: Algorithm Say our closed Eulerian walk is T = (e1, . . . , ek), then since this is a walk on the vertices of a graph, we can write it as a sequence of the vertices it visits W = (v1, . . . , vk, vk+1) where v1 = vk+1 and ei = {vi, vi+1}. Since our graph is connected, the walk must reach every vertex so W contains every vertex at least once. To convert this walk into a Hamiltonian cycle on the vertices using edges from G, we essentially want to use W until we hit a repeat vertex and then ’shortcut’ to the next new vertex. Formally, your Hamil- tonian cycle C will be a subsequence of W where for each vertex v ∈ V we remove all occurrences of v except for the first one in W . Then re-add v1 to the end of this new subsequence, to get C. Since all edges are available to you in G, this walk C is indeed realizable in G and is a Hamiltonian cycle since we visit each vertex once (except the first one). Runtime Since constructing W from T takes O(|F |) time and constructing C from W also takes O(|F |) time, the algorithm has runtime O(|F |). Correctness proof Say C = (u1, . . . , un, un+1) with u1 = un+1, what we need to prove now is that ∑n i=1 w({ui, ui+1}) ≤ w′(T ). To do this, consider the various intervals of indexes of W which are deleted to get C. We write these as I1, . . . , Iℓ where Ii = {ai, ai + 1, . . . , bi} for ai < bi. For simplicity, fix an interval Ii and let a = ai and b = bi. Then instead of the interval of edges ({va−1, va}, {va, va+1}, . . . , {vb, vb+1}) we have from W , we replace it with (va−1, vb+1) ∈ E, call this a shortcut edge. Using the metric property multiple times we get w({va−1, vb+1}) ≤ w({va−1, va}) + w({va, vb+1}) ≤ w({va−1, va}) + w({va, va+1}) + w({va+1, vb+1}) ≤ . . . ≤ b+1∑ j=a w({vj−1, vj}). By compatibility of w and w′ we can replace the w in the last line with w′ since those are all edges in F . Consider a sum over all shortcut edges, then we get the inequality ℓ∑ i=1 w({vai−1, vbi+1}) ≤ ℓ∑ i=1 bi+1∑ j=ai w′({vj−1, vj}). For edges in T not deleted by any interval, these will remain in C and compatibility of the weights means they are the same. So adding these edges to both sides of the equation we now consider the full walks on both sides meaning w(C) = n∑ i=1 w({ui, ui+1}) ≤ k∑ i=1 w′({vi, vi+1}) = w′(T ). Guidelines for correction: Award 1/2 point for the right general idea of shortcutting but incorrect proof. Award 1 point for right idea and right proof (though there are many ways to describe the process and they don’t all need to be this formal). Exercise 10.2 Breadth-first search (1 point). Execute a breadth-first search (BFS) on the following graph G = (V, E) starting at vertex A using the algorithm you have seen in the lecture, which updates a queue Q. You should always enqueue the neighbours of a vertex in alphabetical order. 2 A B H F G E I C D (a) Write down all operations that are executed on the queue Q during the BFS (in order), and write down the contents of Q after each operation is executed (in order). For example, the first operation is enqueue(A) and after this operation, Q = [A]. The second operation is dequeue(A), and after this operation, Q = [ ]. Solution: 0 enqueue(A) Q = [A] 1 dequeue(A) Q = [] 2 enqueue(F ) Q = [F ] 3 enqueue(G) Q = [F, G] 4 dequeue(F ) Q = [G] 5 dequeue(G) Q = [] 6 enqueue(B) Q = [B] 7 enqueue(H) Q = [B, H] 8 enqueue(I) Q = [B, H, I] 9 dequeue(B) Q = [H, I] 10 dequeue(H) Q = [I] 11 enqueue(E) Q = [I, E] 12 dequeue(I) Q = [E] 13 enqueue(C) Q = [E, C] 14 dequeue(E) Q = [C] 15 enqueue(D) Q = [C, D] 16 dequeue(C) Q = [D] 17 dequeue(D) Q = [] (b) Give a shortest path tree for G (with root A). Solution: An example of a shortest path tree is: 3 A B H F G E I C D (c) Let Sk := {v ∈ V : dist(A, v) = k}. Write down Sk for k = 0, 1, 2, 3, 4, 5. Solution: We have: S0 = {A}, S1 = {F, G}, S2 = {B, H, I}, S3 = {C, E}, S4 = {D}, S5 = ∅. (d) An edge e ∈ E is called critical if there is a vertex v ∈ V to which the distance from A increases after removing e. Write down all critical edges of G. Solution: For an edge to be critical, it must be part of the shortest path tree of part (b). But, not every edge in that tree has to be critical. We check by hand that all edges in the tree except (E, D) are critical. Note that this corresponds to the fact that we could have replaced (E, D) by (C, D) to obtain another shortest path tree. Or, to the fact that all shortest paths in G starting at A are unique, except the one from A to D. (e) Write down the enter-number and leave-number of each vertex of the graph. (These numbers indicate the number of queue-operations that have been executed as a vertex enters (respectively, leaves) the queue. For example, enter(A) = 0 and leave(A) = 1.) Solution: vertex enter leave A 0 1 B 6 9 C 13 16 D 15 17 E 11 14 F 2 4 G 3 5 H 7 10 I 8 12 (f) Let tk := minv∈V {leave(v) : dist(A, v) ≥ k}. Write down tk for k = 0, 1, 2, 3, 4, 5. (We define min ∅ := ∞.) 4 Solution: Using (c) and (e) we find that t0 = 1, t1 = 4, t2 = 9, t3 = 14, t4 = 17, t5 = ∞. (g) Let Rk := {v ∈ V : tk ≤ leave(v) < tk+1}. Write down Rk for k = 0, 1, 2, 3, 4, 5. Solution: We have: R0 = {A}, R1 = {F, G}, R2 = {B, H, I}, R3 = {C, E}, R4 = {D}, R5 = ∅. Note that, as you have seen in the lecture, Si = Ri for all i. Guidelines for correction: Award 1 point if there is at most 1 mistake in all of the parts above. Award 1/2 point if there are at most 3 mistakes in all of the parts above. Exercise 10.3 Driving on highways. In order to encourage the use of train for long-distance traveling, the Swiss government has decided to make all the m highways between the n major cities of Switzerland one-way only. In other words, for any two of these major cities C1 and C2, if there is a highway connecting them it is either from C1 to C2 or from C2 to C1, but not both. The government claims that it is however still possible to drive from any major city to any other major city using highways only, despite these one-way restrictions. (a) Model the problem as a graph problem. Describe the set of vertices V and the set of edges E in words. Reformulate the problem description as a graph problem on the resulting graph. Solution: V is the set of major cities in Switzerland (which is of size |V | = n), and there is a directed edge from u ∈ V to v ∈ V if and only if there is a highway going from city u to city v. The corresponding graph problem is to determine whether for any two vertices u, v ∈ V , there is a (directed) path from u to v in G = (V, E). Note that this is equivalent to checking whether the directed graph is strongly connected. (b) Describe an algorithm that checks the correctness of the government’s claim in time O(n + m). Argue why your algorithm is correct and why it satisfies the runtime bound. Hint: You can make use of an algorithm from the lecture. However, you might need to modify the graph described in part (a) and run the algorithm on some modified graph. Solution: Algorithm description. The algorithm is the following. Let v0 ∈ V be an arbitrary vertex in the graph. We first run DFS starting from vertex v0 on the graph G described in part (a), and denote by V0 the set of vertices that were visited by the DFS during “visit(v0)” (including v0 itself). Then, we define a new graph G′ = (V, E′) with the same vertices, and whose edges are given by the reversed edges of G, i.e. we have E′ = {(v, u) : (u, v) ∈ E}. We run DFS again starting from vertex v0 on the graph G′, and denote by V ′ 0 the set of vertices that were visited by the DFS (again only during “visit(v0)” and including v0). The algorithm outputs that the claim is correct if V0 = V = V ′ 0, and that the claim is false otherwise. The idea of this algorithm is to check whether there is a path from v0 to any other vertex and whether there is a path from any other vertex to v0. If directing the edges preserves the connectivity 5 as claimed by the Swiss government then we can go from any city u to v0 and from v0 to any city u so the algorithm correctly recognizes this. On the other hand, if V = V0 = V ′ 0 then we know that all vertices can be reached from v0 and all vertices can reach v0 so there is a walk (and thus also a path) between any pair of vertices. Correctness is shown formally in the following paragraph. Correctness. For correctness, we have to show the equivalence of the following two statements: (1) For any two vertices u, v ∈ V , there is a (directed) path from u to v in G = (V, E). (2) V0 = V and V ′ 0 = V . (1) =⇒ (2): Note that V0 is the set of vertices v for which there is a directed path from v0 to v in G. By (1), there is a path from v0 to v for all vertices v ∈ V , and thus V0 = V . On the other hand, V ′ 0 is the set of all vertices v for which there is a directed path from v to v0 in G. Indeed, if v ∈ V ′ 0, this means that in the graph G′ with reversed edges there is a path from v0 to v, which corresponds to a path from v to v0 in the original graph G. Again by (1), we conclude that V ′ 0 = V . Together, these show (2). (2) =⇒ (1): Let u, v ∈ V . Since V ′ 0 = V and we have seen that V ′ 0 is the set of vertices from which we can reach v0 in G, we know there is a directed path Pu from u to v0 in G. Since V0 = V and V0 is the set of vertices that we can reach from v0 in G, we know there is a directed path Pv from v0 to v in G. Concatenating the paths Pu and Pv, we obtain a directed walk from u to v in G. Since the existence of a walk from u to v is equivalent to the existence of a path from u to v, this shows (1). Runtime. Note that the first DFS takes time O(|V | + |E|), constructing the graph G′ takes times O(|V | + |E|) and the second DFS also takes time O(|V | + |E′|). Since |V | = n and |E′| = |E| = m the total runtime is indeed O(n + m). Exercise 10.4 Number of minimal paths (1 point). Let G = (V, E) be an undirected graph with n vertices and m edges. Let v, v′ ∈ V be two distinct vertices and suppose that the distance between the two is k. Describe an algorithm which counts the number of paths from v to v′ of length k. The runtime of your algorithm should be at most O(n + m). You are provided with the number of vertices n, and the adjacency list Adj of G. Argue why your algorithm is correct and why it satisfies the runtime bound. Hint: Modify BFS. Solution: Algorithm Consider a BFS procedure starting at v and for each vertex u we have two variables du and pu which we want to, at the end, represent the distance from v to u and the number of paths from v to u of that distance. Initialize dv ← 0 and pv ← 1 and for all other vertices, du ← ∞ and pu ← 0. Initialize all vertices as unexplored. We start from v and mark it as explored. Say in the BFS procedure we are at a vertex u, then we go to all adjacent vertices w. If w is unexplored then we set dw ← du + 1 and pw ← pu and mark w as explored and add it to the queue. Otherwise if w is explored and dw = du + 1 then we update pw ← pw + pu. And finally if dw < du + 1 we do nothing. After completing the BFS procedure we output pv′. 6 Runtime Since the above algorithm only has O(1) additional runtime at each step of a BFS, its run- time is (asymptotically) the same as BFS, i.e. O(n + m). Correctness proof To argue correctness, we first recall that at any point of the algorithm, the queue Q = {v1, . . . , vk} satisfies dv1 ≤ · · · ≤ dvk ≤ dv1 + 1. We can show this formally by induction. The base case is when we just have the starting vertex v so this vacuously holds. Now suppose at timestep t of the algorithm our queue looks like Q = {v1, . . . , vk}. Then we process the vertex v1 at time step t+1 and it adds all its unexplored neighbors u1, . . . , uℓ to the queue and sets du1 = · · · = duℓ = dv1 + 1. Our new queue looks like {v2, . . . , vk, u1, . . . , uℓ}. Since dv1 ≤ dv2 ≤ · · · ≤ dvk ≤ dv1 + 1 by the inductive hypothesis and dv1 + 1 = du1 = · · · = duℓ ≤ dv2 + 1, we get dv2 ≤ · · · ≤ dvk ≤ du1 ≤ · · · ≤ duℓ ≤ dv2 + 1. Now stringing all these large inequalities together for each time step of the queue, we can conclude that dv1 ≤ dv2 ≤ · · · ≤ dvn where vertex vi is the vertex processed at timestep i, and v1 = v. Consider a minimal path from v to a vertex w, P = (w0, w1, . . . , wk) where w0 = v and wk = w. Then for sake of contradiction, let index i be the first index such that dwi > i. But then at index i − 1 we have dwi−1 ≤ i − 1 < dwi and by our previous fact, this means that wi−1 was processed before wi. Since wi−1 and wi are adjacent it must have been that wi had been marked explored by a previous vertex, but this is a contradiction since any node u processed before wi−1 has du ≤ dwi−1 ≤ i − 1 and we have that dwi = du + 1. Since P was a minimal path, we can conclude that these dw do in fact correspond to the distance between v and w. Finally, every minimal path to w, written as P = (w1, . . . , wk−1, wk) where w1 = v and wk = w, is also a minimal path to wk−1 if you delete wk. Thus the total number of minimal paths to w is the sum of the minimal paths ending at u where u is adjacent to w and of distance k − 1. We can see that since the du and dw are always equal to the correct distances once discovered, the algorithm indeed implements this sum. Guidelines for correction: Award 1/2 point for a correct algorithm but incorrect proof. Award 1 point for correct algorithm and correct proof. Proof correctness doesn’t need to be too rigorous but should prove path counter = sum of path counters of vertices adjacent and one less distance. Exercise 10.5 Shortest paths by hand. Dijkstra’s algorithm allows to find shortest paths in a directed graph when all edge costs are nonnega- tive. Here is a pseudo-code for that algorithm: 7 Algorithm 1 Dijkstra(G, s) Input: A starting vertex s and a weighted graph G represented via c(·, ·). Specifically, for two vertices u, v the value c(u, v) represents the cost of the edge from u to v (or ∞ if no such edge exists). Operations: d[s] ← 0 ▷ upper bounds on distances from s d[v] ← ∞ for all v ̸= s S ← ∅ ▷ set of vertices with known distances while S ̸= V do choose v∗ ∈ V \\ S with minimum upper bound d[v∗] add v∗ to S for each v ∈ V \\ S do for each u ∈ S do if c(u, v) < ∞ then d[v] ← min{d[v], d[u] + c(u, v)} We remark that this version of Dijkstra’s algorithm focuses on illustrating how the algorithm explores the graph and why it correctly computes all distances from s. You can use this version of Dijkstra’s algorithm to solve this exercise. In order to achieve the best possible running time, it is important to use an appropriate data structure for efficiently maintaining the upper bounds d[v] with v ∈ V \\ S as you will see in the next lecture. In the other exercises/sheets and in the exam you should use the running time of the efficient version of the algorithm (and not the running time of the pseudocode described above). Consider the following weighted directed graph: s a b c d e 5 3 10 1 8 5 9 3 1 2 (a) Execute the Dijkstra’s algorithm described above by hand to find a shortest path from s to each vertex in the graph. After each iteration of the while-loop, write down: 1) d[u] for all u ∈ V (which are upper bounds on the distances from s to u computed so far), 2) the set S (which contains vertices for which the distance has been correctly computed so far), 3) and the predecessors for each vertex u ∈ S \\ {s}. (A predecessor of a vertex u ∈ S \\ {s} is a vertex v ∈ S which satisfies d[u] = d[v] + c(v, u).) Solution: 8 In the beginning: d[s] = 0, d[a] = d[b] = d[c] = d[d] = d[e] = ∞, S = ∅. After we choose s: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 10, d[d] = d[e] = ∞, S = {s}. After we choose b: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 8, d[d] = d[e] = ∞, S = {s, b}, p(b) = s. After we choose a: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 6, d[d] = 13, d[e] = ∞, S = {s, a, b}, p(a) = p(b) = s. After we choose c: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 6, d[d] = 13, d[e] = 9, S = {s, a, b, c}, p(a) = p(b) = s, p(c) = a. After we choose e: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 6, d[d] = 11, d[e] = 9, S = {s, a, b, c, e}, p(a) = p(b) = s, p(c) = a, p(e) = c. After we choose d: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 6, d[d] = 11, d[e] = 9, S = {s, a, b, c, d, e}, p(a) = p(b) = s, p(c) = a, p(d) = e, p(e) = c. We find the shortest path by backtracking them using the predecessors. In this example, they are given by s, s → a, s → b, s → a → c, s → a → c → e → d and s → a → c → e. (b) Change the weight of the edge (a, c) from 1 to −1 and execute Dijkstra’s algorithm on the new graph. Does the algorithm work correctly (are all distances computed correctly) ? In case it breaks, where does it break? Solution: The algorithm works correctly. In the beginning: d[s] = 0, d[a] = d[b] = d[c] = d[d] = d[e] = ∞. After we choose s: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 10, d[d] = d[e] = ∞. After we choose b: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 8, d[d] = d[e] = ∞. After we choose a: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 4, d[d] = 13, d[e] = ∞. After we choose c: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 4, d[d] = 13, d[e] = 7. After we choose e: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 4, d[d] = 9, d[e] = 7. After we choose d: d[s] = 0, d[a] = 5, d[b] = 3, d[c] = 4, d[d] = 9, d[e] = 7. (c) Now, additionally change the weight of the edge (e, b) from 1 to −6 (so edges (a, c) and (e, b) now have negative weights). Show that in this case the algorithm doesn’t work correctly, i.e. there exists some u ∈ V such that d[u] is not equal to the minimum distance from s to u after the execution of the algorithm. Solution: The algorithm doesn’t work correctly, for example, the distance from s to b is 1 (via the path s-a-c- e-b), but the algorithm computes exactly the same values of d[·] as in part (b), so d[b] = 3. This example shows that Dijkstra’s algorithm stopps working correctly if if we allow negative edge weights, which is generally important to remember. The reason for this is that if we chose v∗ with minimal d[v∗], this value is no longer equal to the distance between s and v∗ because there could be a path going over previously unexplored vertices that is actually shorter than the path the algorithm has found when processing v∗. This cannot happen for non-negative weights. 9 One might further think that adding the absolute value of the most negative edge weight w to all edges and then running Dijkstra would fix this problem, but this is also false. The reason is that we add w to all edges so the length of paths with more edges increases stronger than the length of paths with few edges. So it can happen that after adding w, the previously shortest path P between some pair of vertices is now actually longer than some other path P ′ because P ′ has fewer edges than P and is therefore less affected by adding w. 10","libVersion":"0.5.0","langs":""}