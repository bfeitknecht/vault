{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s14-linear-time-properties.pdf","text":"Formal Methods and Functional Programming Linear Temporal Logic Peter M¨uller Programming Methodology Group ETH Zurich The slides in this section are partly based on the course Automata-based System Analysis by Felix Klaedtke Model Checking(p → q)PropertySpecificationSatisfiedModel SpecificationCheckerpStMdlqpViolated +CounterexampleSystem Model David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 241 Motivation Many interesting properties relate several states Example: all opened files must be closed eventually For a terminating program s ⟨s, σ⟩ →∗ 1 σ′ and σ(o) = 0 then σ′(o) = 0 For a deterministic, non-terminating program s ⟨s, σ⟩ →∗ 1 ⟨s ′, σ′⟩ and σ(o) = 0 and σ′(o) = 1 then there exist s ′′, σ′′ such that ⟨s ′, σ′⟩ →∗ 1 ⟨s ′′, σ′′⟩ and σ′′(o) = 0 For a non-deterministic, non-terminating program s wc ∶ Stm × State × N → Bool wc(s, σ, n) ⇔ σ(o) = 0 ∨ (for all s ′, σ′ ∶ if ⟨s, σ⟩ →1 ⟨s ′, σ′⟩ then there exists m ∈ N such that m < n and wc(s ′, σ′, m)) ⟨s, σ⟩ →∗ 1 ⟨s ′, σ′⟩ and σ(o) = 0 and σ′(o) = 1 then there exists n ∈ N such that wc(s ′, σ′, n) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 242 Motivation Many interesting properties relate several states Example: all opened files must be closed eventually For a terminating program s ⟨s, σ⟩ →∗ 1 σ′ and σ(o) = 0 then σ′(o) = 0 For a deterministic, non-terminating program s ⟨s, σ⟩ →∗ 1 ⟨s ′, σ′⟩ and σ(o) = 0 and σ′(o) = 1 then there exist s ′′, σ′′ such that ⟨s ′, σ′⟩ →∗ 1 ⟨s ′′, σ′′⟩ and σ′′(o) = 0 For a non-deterministic, non-terminating program s wc ∶ Stm × State × N → Bool wc(s, σ, n) ⇔ σ(o) = 0 ∨ (for all s ′, σ′ ∶ if ⟨s, σ⟩ →1 ⟨s ′, σ′⟩ then there exists m ∈ N such that m < n and wc(s ′, σ′, m)) ⟨s, σ⟩ →∗ 1 ⟨s ′, σ′⟩ and σ(o) = 0 and σ′(o) = 1 then there exists n ∈ N such that wc(s ′, σ′, n) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 242 Motivation Many interesting properties relate several states Example: all opened files must be closed eventually For a terminating program s ⟨s, σ⟩ →∗ 1 σ′ and σ(o) = 0 then σ′(o) = 0 For a deterministic, non-terminating program s ⟨s, σ⟩ →∗ 1 ⟨s ′, σ′⟩ and σ(o) = 0 and σ′(o) = 1 then there exist s ′′, σ′′ such that ⟨s ′, σ′⟩ →∗ 1 ⟨s ′′, σ′′⟩ and σ′′(o) = 0 For a non-deterministic, non-terminating program s wc ∶ Stm × State × N → Bool wc(s, σ, n) ⇔ σ(o) = 0 ∨ (for all s ′, σ′ ∶ if ⟨s, σ⟩ →1 ⟨s ′, σ′⟩ then there exists m ∈ N such that m < n and wc(s ′, σ′, m)) ⟨s, σ⟩ →∗ 1 ⟨s ′, σ′⟩ and σ(o) = 0 and σ′(o) = 1 then there exists n ∈ N such that wc(s ′, σ′, n) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 242 Motivation Many interesting properties relate several states Example: all opened files must be closed eventually For a terminating program s ⟨s, σ⟩ →∗ 1 σ′ and σ(o) = 0 then σ′(o) = 0 For a deterministic, non-terminating program s ⟨s, σ⟩ →∗ 1 ⟨s ′, σ′⟩ and σ(o) = 0 and σ′(o) = 1 then there exist s ′′, σ′′ such that ⟨s ′, σ′⟩ →∗ 1 ⟨s ′′, σ′′⟩ and σ′′(o) = 0 For a non-deterministic, non-terminating program s wc ∶ Stm × State × N → Bool wc(s, σ, n) ⇔ σ(o) = 0 ∨ (for all s ′, σ′ ∶ if ⟨s, σ⟩ →1 ⟨s ′, σ′⟩ then there exists m ∈ N such that m < n and wc(s ′, σ′, m)) ⟨s, σ⟩ →∗ 1 ⟨s ′, σ′⟩ and σ(o) = 0 and σ′(o) = 1 then there exists n ∈ N such that wc(s ′, σ′, n) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 242 6. Linear Temporal Logic 6.1 Linear-Time Properties 6.2 Linear Temporal Logic David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 243 Transition Systems Revisited We use a slightly different definition here (than earlier in the course) A finite transition system is a tuple (Γ, σI , →) Γ: a finite set of configurations σI : an initial configuration, σI ∈ Γ →: a transition relation, →⊆ Γ × Γ Difference: we have a fixed initial configuration In this section, transition systems model only one program/system, not all programs of a programming language Difference: we omit terminal configurations from the definition Simplifies theory Termination can be modelled by transition to a special extra sink state (which allows further transitions only back to itself) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 244 Transition System of a Promela Model Configurations: states (see previous section) Global variables, global channels Per active process: local variables, local channels, location counter Initial configuration: initial state (see previous section) Transition relation: defined by operational semantics of statements We keep semantics informal A Promela model has a finite number of states Finite number of active processes (limited to 255) Finite number of variables and channels Finite ranges of variables Finite buffers of channels David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 245 Computations Infinite sequences S ω is the set of infinite sequences of elements of set S s[i] denotes the i-th element of the sequence s ∈ S ω γ ∈ Γ ω is a computation of a transition system if: γ[0] = σI γ[i] → γ[i+1] (for all i ≥ 0) Note: we use σ to range over the states Γ of a transition system Note (notation above): if γ = σ0σ1σ2σ3 . . . then γ[i] = σi C(TS) is the set of all computations of a transition system TS David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 246 Linear-Time Properties Linear-time properties (LT-properties) can be used to specify the permitted computations of a transition system A linear-time property P over Γ is a subset of Γ ω P specifies a particular set of infinite sequences of configurations TS satisfies LT-property P (over Γ) TS ⊧ P if and only if C(TS) ⊆ P All computations of TS belong to the set P By contrast: branching-time properties (not in this course) can also express the existence of a computation Example: “It is always possible to return to the initial state” David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 247 LT-Properties: Example All opened files must be closed eventually P = {γ ∈ Γ ω ∣ ∀i ≥ 0 ∶ γ[i](o) = 1 ⇒ ∃n > 0 ∶ γ[i+n](o) = 0} LT-properties precisely express properties of computations Non-termination is handled by infinite sequences Non-determinism is handled by considering each computation separately However, the explicit representation above (defining the set of sequences) is not convenient Logical formalism needed to simplify specification of LT-properties David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 248 From Configurations to (Sets of) Propositions For a transition system TS, we additionally specify a set AP of atomic propositions (of our choice) An atomic proposition is a proposition containing no logical connectives Example: AP = {open, closed} (for files) Example: AP = {x > 0, y ≤ x} We must provide a labeling function that maps configurations to sets of atomic propositions from AP L ∶ Γ → P(AP) Example: L(σ) = ⎧⎪⎪⎪ ⎨ ⎪⎪⎪⎩ {open} if σ(o) = 1 {closed} if σ(o) = 0 {} otherwise We call L(σ) an abstract state From now on, we consider AP and L to be part of the transition system David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 249 Traces A trace is an abstraction of a computation Observe only the propositions of each state, not the concrete state itself Infinite sequence of abstract states (P(AP)ω) t ∈ P(AP)ω is a trace of a transition system TS if t = L(γ[0])L(γ[1])L(γ[2]), . . . and γ is a computation of TS T (TS) is the set of all traces of a transition system TS LT-properties are typically specified over infinite sequences of abstract states, rather than over sequences of configurations: P = {t ∈ P(AP)ω ∣ ∀i ≥ 0 ∶ open ∈ t[i] ⇒ ∃n > 0 ∶ closed ∈ t[i+n]} David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 250 Safety Properties Intuition “Something bad is never allowed to happen (and can’t be fixed)” An LT-property P is a safety property if for all infinite sequences t ∈ P(AP)ω: if t /∈ P then there is a finite prefix ˆt of t such that for every infinite sequence t′ with prefix ˆt, t′ /∈ P ˆt is called a bad prefix; essentially, this finite sequence of steps already violates the property (whatever happens afterwards) Safety properties are violated in finite time and cannot be repaired Examples State properties, for instance, invariants P = {t ∈ P(AP) ω ∣ ∀i ≥ 0 ∶ open ∈ t[i] ∨ closed ∈ t[i]} “Money can be withdrawn only after correct PIN has been entered” David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 251 Liveness Properties Intuition “Something good will happen eventually” “If the good thing has not happened yet, it could happen in the future” An LT-property P is a liveness property if every finite sequence ˆt ∈ P(AP)∗ is a prefix of an infinite sequence t ∈ P A liveness property does not rule out any prefix Every finite prefix can be extended to an infinite sequence that is in P Liveness properties are violated in infinite time Examples All opened files must be closed eventually P = {t ∈ P(AP)ω ∣ ∀i ≥ 0 ∶ open ∈ t[i] ⇒ ∃n > 0 ∶ closed ∈ t[i+n]} “The program terminates eventually” David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 252 6. Linear Temporal Logic 6.1 Linear-Time Properties 6.2 Linear Temporal Logic David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 253 Linear Temporal Logic Linear Temporal Logic (LTL) allows us to formalize LT-properties of traces in a convenient and succinct way We will see syntax and semantics for LTL (no inference rules, etc.) Whether or not the traces of a finite transition system satisfy an LTL formula is decidable (see next section) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 254 LTL: Basic Operators Syntax ϕ = p ∣ ¬ϕ ∣ ϕ ∧ ϕ ∣ ϕ U ϕ ∣ ◯ϕ where p is a proposition from a chosen set of atomic propositions AP ≠ ∅ Intuitive meaning of temporal logic formulasppU p true “now” ϕ “until” ψ “next” ϕ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 255 LTL: Semantics t ⊧ ϕ expresses that trace t ∈ P(AP)ω satisfies LTL formula ϕ t ⊧ p iff p ∈ t[0] t ⊧ ¬ϕ iff not t ⊧ ϕ t ⊧ ϕ ∧ ψ iff t ⊧ ϕ and t ⊧ ψ t ⊧ ϕ U ψ iff there is a k ≥ 0 with t(≥k) ⊧ ψ and t(≥j) ⊧ ϕ for all j such that 0 ≤ j < k t ⊧ ◯ϕ iff t(≥1) ⊧ ϕ where t(≥i) is the suffix of t starting at tippUp true “now” ϕ “until” ψ “next” ϕ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 256 Derived Operators true, false, ∨, ⇒, ⇔ defined as usual Eventually: ◇ϕ ≡ (true U ϕ) Always (from now): ◻ϕ ≡ ¬ ◇ ¬ϕ “eventually” ϕ “always” ϕ Precedence: unary operators always have highest precedence. So, ◇ϕ ⇒ ψ means (◇ϕ) ⇒ ψ. We will usually use parentheses to explicitly clarify other ambiguities. David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 257 Useful Specification Patterns Strong invariant: ◻ψ ψ always holds A file is always open or closed: ◻(open ∨ closed) Safety property if ψ is a safety property Monotone invariant: ◻(ψ ⇒ ◻ψ) Once ψ is true, then ψ is always true For example, once information is public, it can never become secret again (but it may always stay secret): ◻(public ⇒ ◻public) Safety property if ψ is a safety property Establishing an invariant: ◇ ◻ ψ Eventually ψ will always hold For example, system initialization starts server: ◇ ◻ serverRunning Liveness property if ψ is satisfiable David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 258 Useful Specification Patterns (cont’d) Responsiveness: ◻(ψ ⇒ ◇ϕ) Every time that ψ holds, ϕ will eventually hold For example, all opened files must be closed eventually: ◻(open ⇒ ◇closed) Liveness property if ϕ is satisfiable Fairness: ◻ ◇ ψ ψ holds infinitely often For example, producer does not wait infinitely long before entering the critical section: ◻ ◇ critical Liveness property if ψ is satisfiable David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 259 Needham-Schroeder Protocol If Alice and Bob have completed their protocol runs then Alice should believe her partner to be Bob if and only if Bob believes to talk to Alice ◻(statusA = 1 ∧ statusB = 1 ⇒ (partnerA = agentB ⇔ partnerB = agentA)) If Alice completed the protocol talking with Bob, the intruder will not know Alice’s nonce (and dually, swapping the A’s and B’s): ◻(statusA = 1 ∧ partnerA = agentB ⇒ knows nonceA = 0) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 260","libVersion":"0.3.2","langs":""}