{"path":"sem2/PProg/UE/s/PProg-u04-s.pdf","text":"Parallel Programming Assignment 4: Parallel Models Spring Semester 2024 Assigned on: 13.03.2024 Due by: (Wednesday Exercise) 18.03.2024 (Friday Exercise) 20.03.2024 Task 1 – Pipelining Bob, Mary, John and Alice share a flat. In this flat they share a washing machine, a dryer and an ironing board. The washing machine takes 50 minutes for one wash cycle. The dryer takes 90 minutes. Everyone of them takes roughly 15 minutes to iron their laundry. a) Assuming they would do their laundry in strictly sequential order (one person starts only after the other finished ironing), calculate how long would it take to finish the laundry. Answer: They would take (50 + 90 + 15) ∗ 4 = 620 minutes as illustrated in Figure 1. Figure 1: Pipeline executed strictly in sequential order. b) Are there any better options? If yes, can you describe them and calculate the improved laundry time? Further, determine whether this pipeline is balanced or unbalanced. Answer: (50 + (90 * 4) + 15) minutes = 425 Minutes Assuming that three tasks are going in parallel, the speedup is: S3 = T1/T3 = 620/425 = 1.46 as illustrated in Figure 2. The pipeline is unbalanced as the stages of the pipeline have different length of time. Figure 2: Pipeline executed in parallel. c) Can you devise a better strategy assuming that the four roommates bought another dryer? If yes, calculate the new laundry time. Further, determine whether such an improved pipeline is balanced or unbalanced and calculate the pipeline throughput as well as latency. Answer: With two dryers, the third person in order can start drying as soon as their washing is done as shown in Figure 3. This brings the total time to (50) ∗ 4 + 90 + 15 = 305 minutes. The pipeline is unbalanced as the stages of the pipeline have different length of time. The latency of the pipeline is the sum of the execution times of each stage, that is, 50 + 90 + 15 = 155 min. The throughput of the pipeline is the amount of work that can be done by a system in a given period of time. The throughput can be calculated in two ways: 1) With lead in (takes into account filling the pipeline): The throughput is the total time (305 minutes) divided by the number of persons (four) which leads to a throughput of 1 person per 76.25 min. 2) Without lead in (for an indefinite number of students): The 1st person finished the laundry after 155 min, the 2nd person after 205 min, the 3rd after 255 min and 4th after 305 min. Therefore, the throughput is 1 person per 50 min. Figure 3: Pipeline with two dryers. Task 2 – Pipelining II a) Each loop body has to perform one multiplication instruction before we can move to the next loop iteration. Since the multiplication instruction has a latency of 6 cycles and we need to wait until it fully finishes, the whole loop will require data.length * 6 cycles. In the following, we assume int size = data.length. for (int i = 0; i < size; i++) { data[i] = data[i] * data[i]; } 1 2 3i-1 loop iteration i+1 loop iteration 4 5 6 b) In the first cycle the computation of the addition i + 1 is issued. In the next cycle, the multi- plication data[i] * data[i] can be issued as there is no dependency on the value of j that is still being computed. However, the last multiplication needs to wait until the execution of the addition is finished as it uses the value j to index into the array. The total execution time is data.length * 9 / 2 cycles as illustrated below: for (int i = 0; i < size; i += 2) { j = i + 1; data[i] = data[i] * data[i]; data[j] = data[j] * data[j]; } 1 2 3 4 5 6 7 8 9 i-2 loop iteration i+2 loop iteration c) In the last example we simply execute all instructions, issuing one each cycle. This is possible as unrolling the loop four times provides enough work to hide the dependency between the index com- putation (via addition) and the corresponding multiplication. The total execution time is therefore data.length * 12 / 4 cycles as illustrated below: 2 for (int9i9=90;9i9<9size;9i9+=94)9{ j9=9i + 1; k9= i + 2; l9= i + 3; data[i]9= data[i] * data[i]; data[j]9= data[j] * data[j]; data[k]9= data[k] * data[k]; data[l]9= data[l] * data[l]; } 1 2 3 4 5 6 7 8 9 10 11 12 i-4 loop iteration i+4 loop iteration Task 3 – Identify potential parallelism a) Inspect the code snippets for the two loops below. For each loop explain if it is possible to parallelize the loop, and how would you do it. (a) Loop-1 for (int i=1; i<size; i++) { // for loop: i from 1 to (size-1) if (data[i-1] > 0) // If the previous value is positive data[i] = (-1)*data[i]; // change the sign of this value } // end for loop Answer: This loop can not be parallelized as each iteration depends on the answer of the previous iteration: if (data[i-1] > 0) Here the computation of current data[i] depends on the value of data[i-1] which will be available only after the previous iteration has finished. Due to this dependency, we can’t parallelize the loop. (b) Loop-2 for (int i=0; i<size; i++) { // for loop: i from 0 to (size-1) data[i] = Math.sin(data[i]); // calculate sin() of the value } // end for loop Answer: In this loop, there is no dependency on any previous loop computations, so we can compute each iteration of the loop in parallel. 3","libVersion":"0.3.2","langs":""}