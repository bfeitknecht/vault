{"path":"sem2/PProg/PV/summaries/PProg-summary-fheck.pdf","text":"Exam Preparation Session Julianne Orel & Finn Heckman Parallele Programmierung 09.04.2024 Outline ● Speedup, Amdahl, Gustafson ● Pipelining ● Task Graph ● Break (: ● Threads & Wait/Notify ● Fork/Join Framework Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T \u0000 use Gustafson ○ Given constant Work / Programm \u0000 Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and Tricks Pipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and Tricks Task Graph Task Graph Task Graph 50 + 20 + 100 + 10 = 180 Task Graph Task Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Loading… Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task Graph Task Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/Notify Exam Preparation Session Julianne Orel & Finn Heckman Parallele Programmierung 09.04.2024 Outline ● Speedup, Amdahl, Gustafson ● Pipelining ● Task Graph ● Break (: ● Threads & Wait/Notify ● Fork/Join Framework Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T \u0000 use Gustafson ○ Given constant Work / Programm \u0000 Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and Tricks Pipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and Tricks Task Graph Task Graph Task Graph 50 + 20 + 100 + 10 = 180 Task Graph Task Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Loading… Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task Graph Task Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/Notify Loading… Speedup, Amdahl, Gustafson her e : E = /s p = 11 Fo rm u la s : Va n a b le s : = Si = F + 11/1 - f) Sp = E = frection of = = + 11(z ) = E = g no n-pa ra lleliz a ble wo r k And : Sp , E P = # pr o c es ses P Tp = execu tio n time Gu s : Sp = # + p( 1 - f) On p pr o c es so r s Speedup, Amdahl, Gustafson he r e · f = 1 - 7 = ! 0 Sp = = = E = 2 p = ? & Anda hl : T1 = 4 +p = 2 Sp = 2 = = - 2(3 + p) = 4p = 22 6 (= P2 3 Exam Preparation Session Julianne Orel & Finn Heckman Parallele Programmierung 09.04.2024 Outline ● Speedup, Amdahl, Gustafson ● Pipelining ● Task Graph ● Break (: ● Threads & Wait/Notify ● Fork/Join Framework Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T \u0000 use Gustafson ○ Given constant Work / Programm \u0000 Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and Tricks Pipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and Tricks Task Graph Task Graph Task Graph 50 + 20 + 100 + 10 = 180 Task Graph Task Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Loading… Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task Graph Task Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/Notify Exam Preparation Session Julianne Orel & Finn Heckman Parallele Programmierung 09.04.2024 Outline ● Speedup, Amdahl, Gustafson ● Pipelining ● Task Graph ● Break (: ● Threads & Wait/Notify ● Fork/Join Framework Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T \u0000 use Gustafson ○ Given constant Work / Programm \u0000 Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and Tricks Pipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and Tricks Task Graph Task Graph Task Graph 50 + 20 + 100 + 10 = 180 Task Graph Task Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Loading… Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task Graph Task Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/Notify Exam Preparation Session Julianne Orel & Finn Heckman Parallele Programmierung 09.04.2024 Outline ● Speedup, Amdahl, Gustafson ● Pipelining ● Task Graph ● Break (: ● Threads & Wait/Notify ● Fork/Join Framework Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T \u0000 use Gustafson ○ Given constant Work / Programm \u0000 Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and Tricks Pipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and Tricks Task Graph Task Graph Task Graph 50 + 20 + 100 + 10 = 180 Task Graph Task Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Loading… Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task Graph Task Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/Notify Speedup, Amdahl, Gustafson limit of sp e e d up : eimpio here, unito Spisthosa Exam Preparation Session Julianne Orel & Finn Heckman Parallele Programmierung 09.04.2024 Outline ● Speedup, Amdahl, Gustafson ● Pipelining ● Task Graph ● Break (: ● Threads & Wait/Notify ● Fork/Join Framework Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T \u0000 use Gustafson ○ Given constant Work / Programm \u0000 Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and Tricks Pipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and Tricks Task Graph Task Graph Task Graph 50 + 20 + 100 + 10 = 180 Task Graph Task Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Loading… Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task Graph Task Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/Notify Exam Preparation Session Julianne Orel & Finn Heckman Parallele Programmierung 09.04.2024 Outline ● Speedup, Amdahl, Gustafson ● Pipelining ● Task Graph ● Break (: ● Threads & Wait/Notify ● Fork/Join Framework Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T \u0000 use Gustafson ○ Given constant Work / Programm \u0000 Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and Tricks Pipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and Tricks Task Graph Task Graph Task Graph 50 + 20 + 100 + 10 = 180 Task Graph Task Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Loading… Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task Graph Task Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/Notify Id e al cas e v Sp = 0 0 = + = p -> line a r in te r m s of p => b Exam Preparation Session Julianne Orel & Finn Heckman Parallele Programmierung 09.04.2024 Outline ● Speedup, Amdahl, Gustafson ● Pipelining ● Task Graph ● Break (: ● Threads & Wait/Notify ● Fork/Join Framework Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T \u0000 use Gustafson ○ Given constant Work / Programm \u0000 Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and Tricks Pipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and Tricks Task Graph Task Graph Task Graph 50 + 20 + 100 + 10 = 180 Task Graph Task Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Loading… Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task Graph Task Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/Notify Exam Preparation Session Julianne Orel & Finn Heckman Parallele Programmierung 09.04.2024 Outline ● Speedup, Amdahl, Gustafson ● Pipelining ● Task Graph ● Break (: ● Threads & Wait/Notify ● Fork/Join Framework Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T \u0000 use Gustafson ○ Given constant Work / Programm \u0000 Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and Tricks Pipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and Tricks Task Graph Task Graph Task Graph 50 + 20 + 100 + 10 = 180 Task Graph Task Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Loading… Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task Graph Task Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/Notify Exam Preparation Session Julianne Orel & Finn Heckman Parallele Programmierung 09.04.2024 Outline ● Speedup, Amdahl, Gustafson ● Pipelining ● Task Graph ● Break (: ● Threads & Wait/Notify ● Fork/Join Framework Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Loading… Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Sp = ½ + ½ p Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson Speedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T \u0000 use Gustafson ○ Given constant Work / Programm \u0000 Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and Tricks Pipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and Tricks Task Graph Task Graph Task Graph 50 + 20 + 100 + 10 = 180 Task Graph Task Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Loading… Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task Graph Task Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/Notify Speedup, Amdahl, GustafsonSpeedup, Amdahl, GustafsonSpeedup, Amdahl, Gustafson: Tips and Tricks ● Remember and understand the formulas ● Detect which formula to use (if necessary) ○ keywords constant Time / Work ○ Given constant Time T à use Gustafson ○ Given constant Work / Programm à Amdahl ● Identify what is p, f and Sp ● The rest is basic math Pipelining: Tips and TricksPipelining: Tips and Tricks Assumption: no duplicated stages Latency: if pipeline is balanced: sum of all steps Throughput : 1 / longest step (Full Utilization) #Units/ TimeToProcessUnits (With Lead In / Lead Out) Balanced / Unbalanced Pipeline: Pipeline is balanced if first step >= other steps ● Understand what latency and throughput is ● Understand what makes a pipeline balanced ● Stay organized ○ use drawings if necessary Pipelining: Tips and TricksTask GraphTask GraphTask Graph 50 + 20 + 100 + 10 = 180 Task GraphTask Graph Time: 0 Task Graph Time: 50 Task Graph Time: 70 Task Graph Time: 90 Task Graph Time: 120 Task Graph Time: 120 3 Processors! Task GraphTask Graph: Tips and Tricks ● TSE := Time Sequential Execution = Sum of all Nodes ● MaxSpeedUp = TSE / longest path ● Brute force strategy for finding out longest path ● Keep an overview of which Thread does what when ○ e.g with different colors and having a line through the tree which indicates a certain moment in time Wait/Notify ● Read instructions carefully! ○ You will save time and gain points by doing this. ○ Usually you don’t have to handle exceptions. ○ Usually you will lose points if you synchronize too much. ○ Usually small syntax errors like capitalization don’t deduct points ■ As long as it’s clear what you meant Threads & Wait/NotifyThreads & Wait/NotifyThreads & Wait/NotifyThreads & Wait/Notify dequeue? Threads & Wait/Notify dequeue? Threads & Wait/Notify isEmpty? Threads & Wait/Notify isEmpty? Threads & Wait/Notify enqueue? Threads & Wait/NotifyThreads & Wait/NotifyThreads & Wait/Notify Increase number Wait for customer Serve customer POST OFFICE Wait for my number Inform post office CUSTOMER 2 Wait for my number Inform post office CUSTOMER 1 Threads & Wait/Notify: Concept Wait for my number Inform post office CUSTOMER 0 Increase number Wait for customer Serve customer POST OFFICE Wait for my number Inform post office CUSTOMER 2 Wait for my number Inform post office CUSTOMER 1 Threads & Wait/Notify: Concept Wait for my number Inform post office CUSTOMER 0 Increase number Wait for customer Serve customer POST OFFICE Wait for my number Inform post office CUSTOMER 2 Wait for my number Inform post office CUSTOMER 1 Threads & Wait/Notify: Concept Wait for my number Inform post office CUSTOMER 0 Threads & Wait/NotifyThreads & Wait/Notify Always while, not if for waiting on a condition! Threads & Wait/Notify The object we wait on is also: 1) The object we synchronize on 2) The object that notifies this thread Threads & Wait/Notify The object we wait on is also: 1) The object we synchronize on 2) The object that notifies this thread Threads & Wait/NotifyThreads & Wait/NotifyThreads & Wait/Notify Increase number Wait for customer Serve customer POST OFFICE Wait for my number Inform post office CUSTOMER 2 Wait for my number Inform post office CUSTOMER 1 Threads & Wait/Notify: Concept Wait for my number Inform post office CUSTOMER 0 Threads & Wait/Notify <- notification Threads & Wait/Notify notify also works, no difference because each customer goes to exactly one post office Threads & Wait/Notify wait/notify/All must be called within synchronized!} Increase number Wait for customer Serve customer POST OFFICE Wait for my number Inform post office CUSTOMER 2 Wait for my number Inform post office CUSTOMER 1 Threads & Wait/Notify: Concept Wait for my number Inform post office CUSTOMER 0 Threads & Wait/NotifyThreads & Wait/Notify <- notification Threads & Wait/NotifyThreads & Wait/Notify Increase number Wait for customer Serve customer POST OFFICE Wait for my number Inform post office CUSTOMER 2 Wait for my number Inform post office CUSTOMER 1 Threads & Wait/Notify: Concept Wait for my number Inform post office CUSTOMER 0 Threads & Wait/NotifyThreads & Wait/NotifyThreads & Wait/NotifyThreads & Wait/NotifyThreads & Wait/Notify Increase number Wait for customer Serve customer POST OFFICE Wait for my number Inform post office CUSTOMER 2 Wait for my number Inform post office CUSTOMER 1 Threads & Wait/Notify: Concept Wait for my number Inform post office CUSTOMER 0 Threads & Wait/NotifyThreads & Wait/Notify In customer thread: Threads & Wait/Notify In customer thread: Threads & Wait/NotifyThreads & Wait/Notify In customer thread: Threads & Wait/Notify In customer thread: Increase number Wait for customer Serve customer POST OFFICE Wait for my number Inform post office CUSTOMER 2 Wait for my number Inform post office CUSTOMER 1 Threads & Wait/Notify: Concept Wait for my number Inform post office CUSTOMER 0 Threads & Wait/NotifyThreads & Wait/Notify Threads & Wait/Notify ● Remember the important things to check: ○ what to synchronize on: Mostly on a reference shared by all threads ○ what not to synchronize on: no wrapper types like Integer or Float, no int etc. ○ wait/notify always within a synchronized block ○ notify or notifyAll ○ Notify as soon as you write to something that can change a waiting condition ○ wait in a while loop: check conditions with while, NOT with if ● If you have the time, go through the execution step by step ● Do the coding exercises ● Practice the paper-coding with old exams Fork/Join FrameworkFork/Join FrameworkFork/Join FrameworkFork/Join FrameworkFork Join Skeleton public class ExampleForkJoin extends RecursiveTask/Action<> { protected ____ compute() { if (// work is small (smaller than cutoff)) // do the work directly else { // split work into pieces // fork/compute/join the pieces and wait for the results // return statement if needed } } } might need to be adapted to the situation ! Fork/Join Framework ? Fork/Join FrameworkFork/Join Framework Fork/Join Framework Basic structure? Fork/Join Framework Basic structure? Fork/Join Framework Base case? Fork/Join Framework Base case? Fork/Join Framework Where do we split? Fork/Join Framework Where do we split? Fork/Join Framework How do we split? Fork/Join Framework How do we split? Fork/Join Framework How do we split? Fork/Join Framework How do we split? Fork/Join Framework halfSize); Fork/Join Framework halfSize); Watch out when splitting the array! this.length = 8 halfSize = 4 this.length = 7 halfSize = 3 Fork/Join Framework halfSize); Watch out when splitting the array! this.length = 8 halfSize = 4 this.length = 7 halfSize = 3 Fork/Join Framework halfSize); Watch out when splitting the array! this.length = 8 halfSize = 4 this.length = 7 halfSize = 3 Fork/Join Framework halfSize); Watch out when splitting the array! this.length = 8 halfSize = 4 this.length = 7 halfSize = 3 Fork/Join Framework halfSize); Watch out when splitting the array! this.length = 8 halfSize = 4 this.length = 7 halfSize = 3 Fork/Join Framework halfSize); Watch out when splitting the array! this.length = 8 halfSize = 4 this.length = 7 halfSize = 3 Fork/Join Framework Now do the forking! Fork/Join Framework Now do the forking! 2x fork and 2x join is also okay Fork/Join Framework ● Remember the basic structure ○ Pay attention to correctly ordering fork() and join() ● Don’t make mistakes when splitting the input! ○ Pay attention whether we are using length or indices ○ Use small values for length for figuring out the appropriate parameters ● Understand RecursiveTask and RecursiveAction ● 2x fork and 2x join or 1 fork / join and 1 compute are both correct! (on the java version we are using) ● Do the coding exercises :) General Remarks ● You don’t need to score all points to reach a good (best) grade ● Read the task description carefully ● Know the important formulas by heart! ● Solve the exercises and old examsQuestions?","libVersion":"0.3.2","langs":""}