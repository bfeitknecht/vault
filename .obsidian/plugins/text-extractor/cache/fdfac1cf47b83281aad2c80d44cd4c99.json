{"path":"var/attachments/PProg-recap-0633AFF85B4479238E37E41F35862FF8.pdf","text":"Parallel Programming Session 11 Spring 2024, Sarah Kuhn Schedule Input about Locks etc. Post-Discussion Assignment 10 Theory Recap == Pre-Discussion Assignment 11 ReaderWriter Locks implementing concurrent List using locking methods (hand-over-hand etc) Exam Tasks Kahoot Mutex?Clarification We use: Mutual Exclusion: only 1 thread in the CS, sometimes also call it mutex… Clarification We use: Mutual Exclusion: only 1 thread in the CS, sometimes also call it mutex… Mutual Exclusion protocol/ lock/ “mutex”: something that implements mutual exclusion deadlock-freedom/progress starvation-freedom Clarification We use: Mutual Exclusion: only 1 thread in the CS, sometimes also call it mutex… Mutual Exclusion protocol/ lock/ “mutex”: something that implements mutual exclusion deadlock-freedom/progress starvation-freedom -> We from now on refer to “Mutex” as something that implements all 3 conditions. Clarification We use: Mutual Exclusion ! = Mutual Exclusion Protocol Both are sometimes called Mutex so be precise what you mean. Lock Overview Extended Sascha’s Overview in cooperation with Julianne <3 Post-Discussion Ex.10 Dinning Philosophers Post-Discussion Assignment 10 Theory Recap Quiz Pre-Discussion Assignment 7 Fork Join Framework the semester so far Dinning Philosophers Post-Discussion Assignment 10 Theory Recap Quiz Pre-Discussion Assignment 7 Fork Join Framework the semester so far One philosophers left side is anothers right side! But we take left first, then right. So we hold one fork, then wait – leads to cycle in dependency graph. Exam Tasks Show that the philosopher problem for n=3 deadlocks by providing a dependency graph Exam TasksDinning Philosophers What was your approach ? Dinning Philosophers What was your approach ? To avoid cyclic dependencies: Lock-ordering! Number all forks, take the one with smaller number first. Same principle we saw with bank-account already! Assignment 10 16 F0 F1 F2 F3 F4 Now only one is eating. All others have to wait - Not great, not terrible (no deadlock!) Dinning Philosophers To avoid cyclic dependencies: Lock-ordering! Number all forks, take the one with smaller number first. Same principle we saw with bank-account already! Would a two-phase locking with timeout also solve the problem ? Two phase locking Try to acquire both needed locks, if don’t succeed release both and retry after some time. Dinning Philosophers To avoid cyclic dependencies: Lock-ordering! Number all forks, take the one with smaller number first. Same principle we saw with bank-account already! Would a timeout also solve the problem ? Not always, could Livelock Old Exam Task (FS 2023) 20 Old Exam Task (FS 2023) 21 Dinning Philosophers Maximum amount of concurrently eating : 2 philosophers Assignment 10 23 F0 F1 F2 F3 F4 Take smaller first - success Take bigger next - success Take smaller first - success Take bigger next - success Two can eat at the same time. Three is impossible (would need six forks). Essential (Mean ?)Exam TasksMean Exam TasksMonitors, Conditions, Bridges Implement traffic control using monitors/ lock conditions. Imo one of the best exercise you will get Monitor vs Lock ConditionsAssignment 10 – Bridge with monitor 30 Assignment 10 – Bridge with monitor 31 Assignment 10 – Bridge with monitor 32 Assignment 10 Bridge with monitorAssignment 10 Bridge with monitorAssignment 10 – Bridge with monitor 35 Is this really needed? Assignment 10 – Bridge with monitor 36 Is this really needed? Why notifyAll()? Could also use synchronized keyword Assignment 10 – Bridge with monitor 37 Is this really needed? Why notifyAll()? With notify we maybe would just wake up a truck How to solve this problem ? Monitor vs Lock ConditionsAssignment 10 – Bridge with condition 39 Make two separate groups of “waiters” Assignment 10 – Bridge with condition 40 Assignment 10 – Bridge with condition 41 Assignment 10 – Bridge with condition 42 Choose who to wake up based on conditions. Assignment 10 – Bridge with condition 43 Choose who to wake up based on conditions. Here we see an advantage of external locks in comparison to intrinsic locks Assignment 10 Bridge with conditionAssignment 10 Bridge with conditionExam TasksExam TasksExam TasksExam TasksSemaphores via Monitors Check: What is a Semaphore ? What is the difference to a lock that n threads can hold ? Is it the same ? (easier) Exam TasksSemaphores via Monitors Check: What is the difference to a lock that n threads can hold ? Is it the same ? Assignment 10 – Semaphore implementation 56 Assignment 10 – Semaphore implementation 57 Recap: What is the this object here ? Other options? Assignment 10 – Semaphore implementation 58 Recap: What is the this object here ? Other options? Main(){…. …. MySemaphore.acquire(); ….. this Assignment 10 – Semaphore implementation 59 Recap: What is the this object here ? Other options? Note that we use “this” -> could use other objects as monitor too. (see Bridge monitor) Assignment 10 – Semaphore implementation 60 Why a while loop here and not an if? Assignment 10 – Semaphore implementation 61 Why notifyAll? Would notify also work here ? Exam TasksExam TasksBarrier Rendez-Vous of n Threads. BarriersAssignment 10 – Barrier implementation 66 Assignment 10 – Barrier implementation 67 Why do we distinguish between draining and non- draining?Theory Recap Reader-Writer Lock Reading vs. Writing multiple concurrent reads multiple concurrent writes multiple concurrent reads& writes Reader-Writer Lock Reading vs. Writing multiple concurrent reads multiple concurrent writes multiple concurrent reads& writes BUT: if they might happen, we used synchronization to ensure mutex. Reader-Writer Lock Many simultaneous look ups, insert rather rare. Look-up doesn’t mutate state of the memory location f.eg Wikipedia: 0.12% write accesses ->way more reads & want them to be simulatanious Reader-Writer Lock data type for synchronization : reader/writer lock Reader-Writer Lock data type for synchronization : reader/writer lock 3 states: “not held” “held for writing” by one thread «held for reading» by one/multiple threads Reader-Writer Lock data type for synchronization : reader/writer lock 3 states: “not held” “held for writing” by one thread «held for reading» by one/multiple threads Invariants: Implementation ideas make a new lock, initially “not held” acquire_read: When should we block and not get the lock for reading ? Acquire Read Implementation ideas: Monitors make a new lock, initially “not held” acquire_read: block if currently “held for writing”, else make/keep “held for reading” & increment readers count acquire_write: When should we block and not write ? Acquire Write Implementation ideas make a new lock, initially “not held” acquire_read: block if currently “held for writing”, else make/keep “held for reading” & increment readers count acquire_write: block if currently “held for reading” or “held for writing”, else make “held for writing” release_write: make “not held” Release write Implementation ideas make a new lock, initially “not held” acquire_read: block if currently “held for writing”, else make/keep “held for reading” & increment readers count acquire_write: block if currently “held for reading” or “held for writing”, else make “held for writing” release_write: make “not held” release_read: decrement readers count, if 0, make “not held” Release read Assesment Is the lock fair ? Assesment Is the lock fair ? prioritizes writers… Assesment Is the lock fair ? prioritizes writers… What about its performance, do you have an optimization ? Assesment Is the lock fair ? prioritizes writers… What about its performance, do you have an optimization ? Lock Conditions !!! RW Lock In Java Synchronized doesn’t support reader/writer functionality Use : java.util.concurrent.locks.ReentrantReadWriteLock In Java Synchronized doesn’t support reader/writer functionality Use : java.util.concurrent.locks.ReentrantReadWriteLock methods readLock and writeLock return objects(locks) -> use lock and unlock methods on these Locking GranularityLocking Granularity Anyone remembers granularity types we have seen ? Locking Granularity Anyone remembers granularity types we have seen ? Coarse-grained locking Fine-grained locking Locking Granularity Anyone remembers granularity types we have seen ? Coarse-grained locking Fine-grained locking Optimistic synchronization (locking) Lazy synchronization (locking) Locking Granularity Anyone remembers granularity types we have seen ? Coarse-grained locking Fine-grained locking Optimistic synchronization (locking) Lazy synchronization (locking) now implementing concurrent datastructures List-Based Sets example: Sequential List Based Set Use a linked list to implement a set (no duplicate elements) «sorted linked list» Assumptions General tipp: keep two sentinel nodes head & tail Assumptions General tipp: keep two sentinel nodes head & tail They are never removed, searched for or added Key is min and max value SortedListInterface Add, Remove and Find unique elements in a sorted linked list. add(c) 102 a b d e SortedListInterface Add, Remove and Find unique elements in a sorted linked list. add(c) find b and d b.next=c c.next=d 103 a b d e c SortedListInterface Add, Remove and Find unique elements in a sorted linked list. remove(c) 104 a b c d SortedListInterface Add, Remove and Find unique elements in a sorted linked list. remove(c) find b and c b.next=c.next 105 a b c d List and Node public interface SortedListInterface<T extends Comparable<T>> { } 106 Make sure we can sort the entries in the list! Motivation Implement SortedList with different lock strategies List and Node public interface SortedListInterface<T extends Comparable<T>> { public boolean add (T item); public boolean remove (T item); public boolean contains (T item); } 109 Coarse grained locking Implement SortedList using coarse grained locking, any ideas ? Coarse grained locking Implement SortedList using coarse grained locking, any ideas ? sequential implementation + synchronized/ big external lock Coarse Grained Locking 112 public synchronized boolean add(T x) {...}; public synchronized boolean remove(T x) {...}; public synchronized boolean contains(T x) {...}; add(c) a b d e Coarse Grained Locking 113 public synchronized boolean add(T x) {...}; public synchronized boolean remove(T x) {...}; public synchronized boolean contains(T x) {...}; a b d e Coarse Grained Locking 114 public synchronized boolean add(T x) {...}; public synchronized boolean remove(T x) {...}; public synchronized boolean contains(T x) {...}; a b d e c Coarse grained locking Pros / Cons: Coarse grained locking Pros / Cons: + obviously correct + good if have low contention Coarse grained locking Pros / Cons: + obviously correct + good if have low contention - sequential execution Coarse grained locking Pros / Cons: + obviously correct + good if have low contention - sequential execution Runtime for add delete contains Coarse grained locking Pros / Cons: + obviously correct + good if have low contention - sequential execution Runtime for add O(n) delete O(n) contains O(n) Coarse grained locking sequential implementation + synchronized provided sequential implementation Fine grained locking Idea: independently synchronized pieces no mutual exclusion for operations on disjoint pieces Fine grained locking Idea: independently synchronized pieces no mutual exclusion for operations on disjoint pieces threads can traverse the list in a pipelined manner. Fine grained locking Idea: independently synchronized pieces no mutual exclusion for operations on disjoint pieces threads can traverse the list in a pipelined manner. First attempt : thread acquires lock on the node& after some time releases it -> next thread can acquire it -> works ? Let's try this: lock the current node remove(c) 124 a b c d Let's try this remove(c) Locking the predecessor is enough, issues? 125 a b c d Let's try this A: remove(c) B: remove(b) c not deleted! 126 a b c d AB Let's try this A: remove(c) B: remove(b) c not deleted! -> just locking the current node not enough 127 a b c d AB What's the problem? When deleting, the next field of next is read, i.e. next also has to be protected. remove(b) 128 a b d e BB find a and b a.next=b.next Fine grained locking Solution: Hand-Over-Hand-Locking Fine grained locking Solution: Hand-Over-Hand-Locking invariant: acquire the lock for current only if holding the lock for pred. “lock coupling” Fine grained locking Solution: Hand-Over-Hand-Locking invariant: acquire the lock for current only if holding the lock for pred. “lock coupling” Can this be implemented with synchronized ? A: remove(c) • . 132 a b c d A acquire the lock for current only if holding the lock for pred. A: remove(c) When removing, lock the successor defensively. 133 a b c d A A acquire the lock for current only if holding the lock for pred. A: remove(c) B: remove(b) When removing, lock the successor defensively. 134 a b c d AB A acquire the lock for current only if holding the lock for pred. A: remove(c) B: remove(b) When removing, lock the successor defensively. 135 a b c d AB B A Waiting acquire the lock for current only if holding the lock for pred. Let's try this A: remove(c) B: remove(b) When removing, lock the successor defensively. 136 a b c d B B What about add? add(b’) -> assume just locking the current 137 a b c d b’ What about add? A: add(b’) B: remove(b) • b’ not added! 138 a b c d b’ AB What about add? A: add(b’) B: remove(b) 139 a b c d b’ A A acquire the lock for current only if holding the lock for pred. What about add? A: add(b’) B: remove(b) 140 a b c d b’ AB A What about add? A: add(b’) B: remove(b) 141 a b c d b’ AB B Waiting A What about add? A: add(b’) B: remove(b) 142 a b c d b’ B B What about add? A: add(b’) B: remove(b) 143 a b c d b’ B B Fine grained locking Uses Hand-Over-Hand locking/ lock coupling Always holding current & predecessor Hand-over-hand locking (remove d) 145 a b d e pred=-∞,curr=a check(a<d) a b d e pred=a,curr=b check(b<d) a b d e pred=b,curr=d check(d<d) if(d==d) remove(d) Hand-Over-Hand locking Why don’t we deadlock eventough we work with a lot of locks…? Hand-Over-Hand locking Why don’t we deadlock ? … because multiple locks are acquired in the same order -> Start at the head and follow the .next() to the node Hand-Over-Hand locking: Code add() Hand-over-hand locking Hand-Over-Hand locking Pro: Hand-Over-Hand locking Pro: + multiple reader& writers can actively do work + reader/writers traversing list in the same order won’t pass each other (“fair”) + won’t deadlock because we acquire them in the same order (start at the front) Hand-Over-Hand locking Pro: + multiple reader& writers can actively do work + reader/writers traversing list in the same order won’t pass each other (“fair”) + won’t deadlock because we acquire them in the same order (start at the front) Does someone see any cons of this ? Hand-Over-Hand locking Cons - lots of lock acquire & release - threads accessing disjoint parts can still block each other (f.eg slow first thread sets tempo bc all start from the front) Optimistic locking goal: reduce cost of fine-grained locking Optimistic locking reduces cost of fine-grained locking 1.) Search the components without locking (optimistic) Optimistic locking reduces cost of fine-grained locking 1.) Search the components without locking (optimistic) 2.) If found, lock the component and then check that it wasn’t changed if changed: release lock and start over Doing & then validating reminds us of….? Optimistic locking reduces cost of fine-grained locking 1.) Search the components without locking (optimistic) 2.) If found, lock the component and then check that it wasn’t changed if changed: release lock and start over Doing & then validating reminds us of….? CAS, TAS (optimistic too) -> optimistic bc assume that conflicts are rare (find elem. + taking locks) add(c) Aha! Finding without locking a b d e add(c) add(c) Locking a b d e add(c) a b d e Validation add(c) a b d e Yes. b is still reachable from head. Validation add(c) a b d e Yes. b still points to d. Validation c add(c) a b d e c add(c) a b d e Optimistic locking In detail: when reached the node lock current and predecessor do validation -> what should we check here ? Optimistic locking Need to check that pred still in the list & reference from pred to current node hasn’t changed validate() 1.) is predecessor reachable 2.) is pred.next() == current Validation: what can go wrong? A: add(c) A: find insertion point 170 a b d e Validation: what can go wrong? A: add(c) A: find insertion point B: remove(b) 171 a b d e a b d e B B Validation: what can go wrong? A: add(c) A: find insertion point B: remove(b) A: lock A: validate: rescan A: b not reachable →return false 172 a b d e a b d e A A a b d e B B Validation: what can go wrong? A: add(c) A: find insertion point 173 a b d e Validation: what can go wrong? A: add(c) A: find insertion point B: insert(b') 174 a b d e a b d e B B b' Validation: what can go wrong? A: add(c) A: find insertion point B: insert(b') A: lock A: validate: rescan A: d != succ(b) →return false 175 a b d e a b d e B B b' a b d e A A b' Use Validate() in Code ->validate itself is given to you Input: Common error When implementing add -> be careful with the ordering of our statements While you are adding other could be traversing the list Input: Common error When implementing add -> be careful with the ordering of our statements While you are adding other could be traversing the list This order is important else would throw an exception sometimes Why? Optimistic locking Pros: + less lock acquisitions than hand-over-hand + no contention on traversal Optimistic locking Pros: + less lock acquisitions than hand-over-hand + no contention on traversal (traverses the list twice: good if traversing 2x without locking cheaper than with locking) Optimistic locking Pros: + less lock acquisitions than hand-over-hand + no contention on traversal (traverses the list twice: good if traversing 2x without locking cheaper than with locking) starvation-free? Optimistic locking Cons: - two traversal (find + validate ) - not starvation-free - lot of threads -> validate fails more often : re-iterate - contains needs locks Lazy Synchronization Like optimistic synchronization but here : Lazy Synchronization Like optimistic synchronization but here : scan list only once contains() never locks Lazy synchronization in comparison to optimistic locking -> - 1 traversal but + marked bit Lazy synchronization Goal: optimize such that contains without locks& less traversals of the list Idea: each node has a Boolean “marked” invariant : every unmarked node is in the set and reachable Lazy synchronization Goal: optimize such that contains without locks& less traversals of the list Idea: each node has a Boolean “marked” invariant : every unmarked node is in the set and reachable if marked <-> not reachable/ not in the set Lazy synchronization Goal: optimize such that contains without locks& less traversals of the list Idea: each node has a Boolean “marked” invariant : every unmarked node is in the set and reachable if marked <-> not reachable/ not in the set Lazy synchronization: add adds() needs to traverse the list only once: Find nodes to where to add (as before) Lock predecessor and current (as before) Lazy synchronization: add adds() needs to traverse the list only once: Find nodes to where to add (as before) Lock predecessor and current (as before) Validate (new validation) Physical add: change predecessor's next Lazy synchronization: contains Find nodes to return without locking Return true if node is not marked Lazy synchronization: contains contains() needs to traverse the list only once& doesn’t need any locking !! Find nodes to return without locking Return true if node is not marked Lazy synchronization: remove remove() -> lazy Idea: logically remove and then physically remove Lazy synchronization: remove remove() -> lazy Idea: logically remove and then physically remove Set a tag bit Unlink it from the list Lazy List: Remove Find nodes to remove (as before) Lock predecessor and current (as before) Validate (new validation) Logical delete: mark current node as removed Physical delete: redirect predecessor's next e.g. remove(c) 196 a b c d Lazy synchronization: removeLazy synchronization: removeLazy synchronization: validate Given two locked nodes: Lazy synchronization: validate Given two locked nodes: reachable -> not marked (current & pred) pred.next() == current New Validate 201 b c ? ? ? New Validation: What can go wrong? 202 a b d e A: add(c) A: find insertion point New Validation: What can go wrong? 203 a b d e A: add(c) A: find insertion point B: remove(b) a b d e B B Lazy synchronization: validate Given two locked nodes: reachable -> not marked (current & pred) pred.next() == current Lazy synchronization Pro: + all methods traverse list without locking + traverse only once. + contains doesn’t need locks + separate logical & physical deletion Assignment 11 Implement SortedList with different lock strategies Exercise about effective use of locks Measure the performance impact of your implementation choice List and Node public interface SortedListInterface<T extends Comparable<T>> { public boolean add (T item); public boolean remove (T item); public boolean contains (T item); } 208 Implement those methods in a thread-safe way Assignment 11 Implement SortedList with different lock strategies Exercise about effective use of locks Measure the performance impact of your implementation choice Not super easy: take slides or “The Art Of Multiprocessor Programming” as help -> book covers most of the implementations !!! Coarse Grained Locking 210 public synchronized boolean add(T x) {...}; public synchronized boolean remove(T x) {...}; public synchronized boolean contains(T x) {...}; Simple, but a bottleneck for many threads, why? a b d e c Essential Exam Tasks You do insert( e ) and contains (d) on a linkedList containing head, a, b, c, d and tail. Exam Tasks You do insert( e ) and contains (d) on a linkedList containing head, a, b, c, d and tail. Exam TasksExam TasksLet’s start https://create.kahoot.it/share/pprog11/a53c8ae7-291b-478f-8860-6b183b19fde9 See you next week J","libVersion":"0.3.2","langs":""}