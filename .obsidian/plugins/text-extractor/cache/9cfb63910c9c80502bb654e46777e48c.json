{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w05.pdf","text":"Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Woche 5 â€“ Ãœbersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder VollstÃ¤ndigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne GewÃ¤hr.) Anmerkungen zu den Code-Expert Abgaben: Anmerkungen zu den Theorie Abgaben: â€¢ Die Abgaben die ich zu den Fold-Aufgaben bekommen habe, haben mir alle sehr gut gefallen und zeigen, dass ihr das grundsÃ¤tzliche Prinzip von Folds in Haskell sehr gut versteht. â€¢ Insgesamt gab es aber (insbesondere bei der DFA-Aufgabe) diese Woche deutlich weniger Abgaben (ca. 15 weniger als sonst), weswegen ich euch hier noch einmal eindringlich darauf hinweisen mÃ¶chte, mit dem LÃ¶sen der Aufgaben nicht aufzuhÃ¶ren. Es ist auch okay, wenn ihr die Aufgaben erst mit der LÃ¶sung lÃ¶st, aber versucht es zumindest alleine â€“ und falls das nicht klappt, versucht auf jeden Fall die LÃ¶sung zu verstehen (und bestenfalls auch noch einmal selbst zu implementieren, das hilft erfahrungsgemÃ¤ÃŸ oft). Da die DFA-Aufgabe vermutlich fÃ¼r die meisten an der â€lexiconâ€-Teilaufgabe gescheitert ist, hier noch einmal ein LÃ¶sungsvorschlag von mir (genauere ErklÃ¤rung in der Ãœbungsstunde): â€¢ Alle Abgaben, die ich bekommen habe, haben mir sehr gut gefallen, ihr habt CYP/Induktion offensichtlich sehr gut verstanden :) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Foldr â€“ Fortgeschritten: Wir haben bereits in den letzten beiden Wochen gesehen, dass wir die Ã¼beraus mÃ¤chtige Funktion â€foldrâ€œ nutzen kÃ¶nnen, um andere, rekursive implementierte Funktionen neu zu schreiben. Heute lernen wir einen Formalen Ansatz kennen, der einfach nur Stur befolgt werden muss â€“ und es uns erlaubt, die meisten rekursiven Prelude-Funktionen mit foldr auszudrÃ¼cken: Hier das Rezept und mehrere Beispielaufgaben, auch eine â€ungewÃ¶hnlicheâ€œ (da ohne dynamische Argumente) (Quelle: Slides): Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Das Rezept muss einfach stur befolgt werden (und immer genau erkannt werden, welche Argumente statisch, welche dynamisch und welches das rekursive Argument ist), dann lassen sich entsprechende Aufgaben gewÃ¶hnlich sehr leicht lÃ¶sen. Type-Inference: Nun wollen wir uns noch einmal mit der Type-Inference beschÃ¤ftigen. Bereits in der letzten Stunde hatten wir das Thema grob angeschnitten. Hier noch einmal mein Rezept: Weiter auf der nÃ¤chsten Seite â†’ Am Beispiel bestimme den most general type von map . (,) mit map :: (a->b)->[a]->[b], (.) :: (b->c)->(a->b)->a->c, (,):: a->b->(a,b) Da wir gleich mehrere Male Typen â€matchenâ€œ mÃ¼ssen, sollten wir zunÃ¤chst die ganzen freien Typenvariablen umbenennen: map :: (e->f)->[e]->[f], (.) :: (b->c)->(a->b)->a->c, (,) :: x->y->(x,y) Wie man sehen kann, stimmen die Typen immer noch, da ich die Variablen entsprechend dem vorgegebenen Muster geÃ¤ndert habe. Jetzt kommen wir aber nicht so durcheinander wenn wir Ã¼ber die einzelnen Typen der verschiedenen Funktionen sprechen, daher ist dieser Schritt oft wichtig. Nun suche ich immer die â€Ã¤uÃŸersteâ€œ Funktion, in diesem Fall ist das der â€Punktâ€œ. Wir kennen ja von der Modulo-Funktion â€modâ€œ, dass sie auch â€infixâ€œ geschrieben werden kann, also x `mod` 2 == mod x 2. Genauso ist es mit dem Verknupfungsoperator, dem Punkt, auch: Anstatt Infix-Notation kÃ¶nnen wir die geg. Funktion also auch in PrÃ¤fix-Notation schreiben: ((.) map) (,) Wichtig: Das heisst jetzt nicht, dass map infix steht. Also kÃ¶nnen wir jetzt so denken: (.) nimmt ein Argument map und gibt eine Funktion zurÃ¼ck, die ein Argument (,) nimmt. Wir sehen beim Typen von (.): (.) :: (b->c)->(a->b)->a->c == (b->c) -> ((a->b)->(a-c)) (gem. AssoziativitÃ¤t) Das Argument von (.) muss also vom Typen (b->c) sein. FÃ¼r map gilt: map :: (e->f)->[e]->[f] == (e->f) -> ([e]->[f]) (gem. AssoziativitÃ¤t) Also wissen wir, da hier map als Argument an (.) Ã¼bergeben wird und das Argument von (.) den Typen (b->c) hat, dass: b :: (e->f) und c :: ([e]->[f]) Nun wissen wir, dass (.) einen RÃ¼ckgabewert vom Typen ((a->b)->(a->c)) hat. Wir wissen, dass diesem RÃ¼ckgabewert (der eine Funktion ist, die eine Funktion als Argument nimmt und eine Funktion zurÃ¼ckgibt) die Funktion (,) :: x->y->(x,y) == x -> (y->(x,y)) Ã¼bergeben wird. Also gilt nach dem gleichen Prinzip wie eben bei map: a :: x und b :: y -> (x,y) Wenn wir das nun mit unseren vorherigen Erkentnissen vereinen (wir wussten schon, dass b :: (e->f), aber nichts spezifisches Ã¼ber e,f), erhalten wir dazu: e :: y und f :: (x,y) Nun ist der â€finaleâ€œ RÃ¼ckgabewert dieser Funktion, die der RÃ¼ckgabewert von (.) mit Argument map war, halt nun mit Argument (,): (a->c) Und wir wissen, was a und c fÃ¼r Typen sind, und zwar: a :: x und c :: ([e] -> [f]) == ([y] -> [(x,y)]) also: map . (,) :: x -> ([y] -> [(x,y)]) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Zum VerstÃ¤ndnis hier nun noch weitere einfachere Aufgaben teilweise ausfÃ¼hrlich erklÃ¤rt: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Der (vermeintliche) Type-Inference Endgegner: â€œ(.) . (.)â€: (Wichtige) Anmerkung: Beim Types matchen sollte eigentlich â€œ=â€ stehen, statt â€œ::â€. Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Type-Inference Proofs: Um den letzten Abschnitt fÃ¶rmlich zu ergÃ¤nzen, haben wir Type-Inference Proofs. Denn oftmals ist es schwierig, zu â€sehenâ€œ, ob ein Type wirklich stimmt (oder ob eine Funktion Ã¼berhaupt typeable ist). Dazu haben wir ein Proof-System, das so derart nah an ND-Proofs dran ist, dass euch spÃ¤testens jetzt klar sein sollte, weswegen die ND-Proofs eine sehr gute Ãœbung waren: Hier die Regeln (Quelle: Serie 5): Die Regeln sollten fast alle klar verstÃ¤ndlich sein (falls nein, schreibt mir). Die App-Regel ist die einzige, die eventuell weiterer ErklÃ¤rung bedarf: Wenn aus unseren Annahmen folgt, dass die Funktion ğ‘¡1 vom Type ğœ â†’ ğœ ist und aus unseren Annahmen folgt, dass das Argument ğ‘¡2 vom Type ğœ ist, dann kÃ¶nnen wir herleiten, dass fÃ¼r die â€Function Applicationâ€œ (Deshalb â€Appâ€œ) gilt, dass der RÃ¼ckgabewert dieser Function Application vom Type ğœ ist. Hier nun eine Aufgabe: Man solle verifizieren, ob der gegebene Type korrekt ist. Dabei verwenden wir auch den Unification-Algorithmus (siehe Link auf Website). Weiter auf der nÃ¤chsten Seite â†’ Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch","libVersion":"0.5.0","langs":""}