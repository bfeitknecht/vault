{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w05.pdf","text":"Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Woche 5 – Übersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder Vollständigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne Gewähr.) Anmerkungen zu den Code-Expert Abgaben: Anmerkungen zu den Theorie Abgaben: • Die Abgaben die ich zu den Fold-Aufgaben bekommen habe, haben mir alle sehr gut gefallen und zeigen, dass ihr das grundsätzliche Prinzip von Folds in Haskell sehr gut versteht. • Insgesamt gab es aber (insbesondere bei der DFA-Aufgabe) diese Woche deutlich weniger Abgaben (ca. 15 weniger als sonst), weswegen ich euch hier noch einmal eindringlich darauf hinweisen möchte, mit dem Lösen der Aufgaben nicht aufzuhören. Es ist auch okay, wenn ihr die Aufgaben erst mit der Lösung löst, aber versucht es zumindest alleine – und falls das nicht klappt, versucht auf jeden Fall die Lösung zu verstehen (und bestenfalls auch noch einmal selbst zu implementieren, das hilft erfahrungsgemäß oft). Da die DFA-Aufgabe vermutlich für die meisten an der „lexicon”-Teilaufgabe gescheitert ist, hier noch einmal ein Lösungsvorschlag von mir (genauere Erklärung in der Übungsstunde): • Alle Abgaben, die ich bekommen habe, haben mir sehr gut gefallen, ihr habt CYP/Induktion offensichtlich sehr gut verstanden :) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Foldr – Fortgeschritten: Wir haben bereits in den letzten beiden Wochen gesehen, dass wir die überaus mächtige Funktion „foldr“ nutzen können, um andere, rekursive implementierte Funktionen neu zu schreiben. Heute lernen wir einen Formalen Ansatz kennen, der einfach nur Stur befolgt werden muss – und es uns erlaubt, die meisten rekursiven Prelude-Funktionen mit foldr auszudrücken: Hier das Rezept und mehrere Beispielaufgaben, auch eine „ungewöhnliche“ (da ohne dynamische Argumente) (Quelle: Slides): Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Das Rezept muss einfach stur befolgt werden (und immer genau erkannt werden, welche Argumente statisch, welche dynamisch und welches das rekursive Argument ist), dann lassen sich entsprechende Aufgaben gewöhnlich sehr leicht lösen. Type-Inference: Nun wollen wir uns noch einmal mit der Type-Inference beschäftigen. Bereits in der letzten Stunde hatten wir das Thema grob angeschnitten. Hier noch einmal mein Rezept: Weiter auf der nächsten Seite → Am Beispiel bestimme den most general type von map . (,) mit map :: (a->b)->[a]->[b], (.) :: (b->c)->(a->b)->a->c, (,):: a->b->(a,b) Da wir gleich mehrere Male Typen „matchen“ müssen, sollten wir zunächst die ganzen freien Typenvariablen umbenennen: map :: (e->f)->[e]->[f], (.) :: (b->c)->(a->b)->a->c, (,) :: x->y->(x,y) Wie man sehen kann, stimmen die Typen immer noch, da ich die Variablen entsprechend dem vorgegebenen Muster geändert habe. Jetzt kommen wir aber nicht so durcheinander wenn wir über die einzelnen Typen der verschiedenen Funktionen sprechen, daher ist dieser Schritt oft wichtig. Nun suche ich immer die „äußerste“ Funktion, in diesem Fall ist das der „Punkt“. Wir kennen ja von der Modulo-Funktion „mod“, dass sie auch „infix“ geschrieben werden kann, also x `mod` 2 == mod x 2. Genauso ist es mit dem Verknupfungsoperator, dem Punkt, auch: Anstatt Infix-Notation können wir die geg. Funktion also auch in Präfix-Notation schreiben: ((.) map) (,) Wichtig: Das heisst jetzt nicht, dass map infix steht. Also können wir jetzt so denken: (.) nimmt ein Argument map und gibt eine Funktion zurück, die ein Argument (,) nimmt. Wir sehen beim Typen von (.): (.) :: (b->c)->(a->b)->a->c == (b->c) -> ((a->b)->(a-c)) (gem. Assoziativität) Das Argument von (.) muss also vom Typen (b->c) sein. Für map gilt: map :: (e->f)->[e]->[f] == (e->f) -> ([e]->[f]) (gem. Assoziativität) Also wissen wir, da hier map als Argument an (.) übergeben wird und das Argument von (.) den Typen (b->c) hat, dass: b :: (e->f) und c :: ([e]->[f]) Nun wissen wir, dass (.) einen Rückgabewert vom Typen ((a->b)->(a->c)) hat. Wir wissen, dass diesem Rückgabewert (der eine Funktion ist, die eine Funktion als Argument nimmt und eine Funktion zurückgibt) die Funktion (,) :: x->y->(x,y) == x -> (y->(x,y)) übergeben wird. Also gilt nach dem gleichen Prinzip wie eben bei map: a :: x und b :: y -> (x,y) Wenn wir das nun mit unseren vorherigen Erkentnissen vereinen (wir wussten schon, dass b :: (e->f), aber nichts spezifisches über e,f), erhalten wir dazu: e :: y und f :: (x,y) Nun ist der „finale“ Rückgabewert dieser Funktion, die der Rückgabewert von (.) mit Argument map war, halt nun mit Argument (,): (a->c) Und wir wissen, was a und c für Typen sind, und zwar: a :: x und c :: ([e] -> [f]) == ([y] -> [(x,y)]) also: map . (,) :: x -> ([y] -> [(x,y)]) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Zum Verständnis hier nun noch weitere einfachere Aufgaben teilweise ausführlich erklärt: Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Der (vermeintliche) Type-Inference Endgegner: “(.) . (.)”: (Wichtige) Anmerkung: Beim Types matchen sollte eigentlich “=” stehen, statt “::”. Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Type-Inference Proofs: Um den letzten Abschnitt förmlich zu ergänzen, haben wir Type-Inference Proofs. Denn oftmals ist es schwierig, zu „sehen“, ob ein Type wirklich stimmt (oder ob eine Funktion überhaupt typeable ist). Dazu haben wir ein Proof-System, das so derart nah an ND-Proofs dran ist, dass euch spätestens jetzt klar sein sollte, weswegen die ND-Proofs eine sehr gute Übung waren: Hier die Regeln (Quelle: Serie 5): Die Regeln sollten fast alle klar verständlich sein (falls nein, schreibt mir). Die App-Regel ist die einzige, die eventuell weiterer Erklärung bedarf: Wenn aus unseren Annahmen folgt, dass die Funktion 𝑡1 vom Type 𝜎 → 𝜏 ist und aus unseren Annahmen folgt, dass das Argument 𝑡2 vom Type 𝜎 ist, dann können wir herleiten, dass für die „Function Application“ (Deshalb „App“) gilt, dass der Rückgabewert dieser Function Application vom Type 𝜏 ist. Hier nun eine Aufgabe: Man solle verifizieren, ob der gegebene Type korrekt ist. Dabei verwenden wir auch den Unification-Algorithmus (siehe Link auf Website). Weiter auf der nächsten Seite → Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch","libVersion":"0.5.0","langs":""}