{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s08-monads.pdf","text":"Monads David Basin Department of Computer Science ETH Z¨urich Functional Programming David Basin 1 Monads: What’s it all about? • Model various computational features in a uniform way. E.g. partiality, state, exceptions, non-determinism, I/O, ... • Idea: separate values from computations producing the values: f :: a → b ordinary function, returns value of type b f :: a → M b monadic function, returns computation M b • M is a type constructor satisfying certain properties (monad laws). By varying M, we can model diﬀerent notions of computation. • Every monad supports two basic operations: embedding a value into a computation and the composing computations. • Explains side-eﬀects in a functional context and helps designing controlled side eﬀects. Functional Programming Spring Semester, 2022 David Basin 2 Outline Part I – A gentle introduction to monads by examples • Partial functions • Monad type class and monad laws • Stateful computations • Input/output Part II – Case study: monadic interpreters • Standard and monadic interpreter for mini-Haskell • Variant 1: improved error handling • Variant 2: counting the number of evaluation steps • Variant 3: non-deterministic computation • Variant 4: tracing intermediate results Functional Programming Spring Semester, 2022 David Basin 3 Motivation: partial functions Functional Programming Spring Semester, 2022 David Basin 4 Example: partial functions • Consider integer division: 10 ‘div‘ 2 = 5 -- OK 10 ‘div‘ 0 = .. -- exception *** Exception: divide by zero • This partiality can be captured with the Maybe type: data Maybe a = Nothing | Just a safeDiv :: Int -> Int -> Maybe Int safeDiv n d | d /= 0 = Just (n ‘div‘ d) | otherwise = Nothing • A similar construction makes head safe: safeHead :: [a] -> Maybe a safeHead [] = Nothing safeHead (x:_) = Just x Functional Programming Spring Semester, 2022 David Basin 5 Computing with Maybe’s Suppose we are given two Int lists xs and ys. We would like to safely compute “(head xs) ‘div‘ (head ys) + 1”. Direct implementation Using some Haskell magic foo1 :: [Int] -> [Int] -> Maybe Int foo1 xs ys = case safeHead xs of Just a -> case safeHead ys of Just b -> case safeDiv a b of Just c -> Just (c + 1) Nothing -> Nothing Nothing -> Nothing Nothing -> Nothing foo2 :: ..(same type).. foo2 xs ys = do a <- safeHead xs; b <- safeHead ys; c <- safeDiv a b; return (c + 1) Many case distinctions. To be explained Ugly and scales poorly. here and now! Functional Programming Spring Semester, 2022 David Basin 6 Composition is the magic • Challenge: How to compose computations with partial functions. maybe1; maybe2 ↪→ ? • Possible interpretation: Nothing; maybe2 ↪→ Nothing maybe1; Nothing ↪→ Nothing Just x1; Just x2 ↪→ Just x2 • We deﬁne maybe1; maybe2 by maybe1 ‘semi‘ maybe2 where semi :: Maybe a -> Maybe b -> Maybe b semi Nothing = Nothing semi Nothing = Nothing semi (Just x1) (Just x2) = Just x2 • Problem: the computation of x2 may depend on x1. Functional Programming Spring Semester, 2022 David Basin 7 Composition with value bindings • Second computation needs to bind result of ﬁrst. bind :: Maybe a -> (a -> Maybe b) -> Maybe b bind Nothing _ = Nothing bind (Just x1) f = f x1 • We also deﬁne a function embedding a value in the Maybe type: return :: a -> Maybe a return x = Just x • Thus we can now write foo2 as foo2 :: [Int] -> [Int] -> Maybe Int foo2 xs ys = safeHead xs ‘bind‘ (\\a -> safeHead ys ‘bind‘ (\\b -> safeDiv a b ‘bind‘ (\\c -> return (c + 1)))) Functional Programming Spring Semester, 2022 David Basin 8 The Monad type class • The Monad typeclass abstractly speciﬁes bind and return class Monad m where return :: a -> m a (>>=) :: m a -> (a -> m b) -> m b -- bind • The type constructor Maybe instantiates this class. instance Monad Maybe where return x = Just x Nothing >>= = Nothing (Just x) >>= f = f x • Hence our function foo2 becomes foo2 xs ys = foo2’ xs ys = do safeHead xs >>= (\\a -> a <- safeHead xs safeHead ys >>= (\\b -> b <- safeHead ys safeDiv a b >>= (\\c -> c <- safeDiv a b return (c + 1)))) return (c + 1) The do-notation is just syntactic sugar to improve readability. Functional Programming Spring Semester, 2022 David Basin 9 The monad laws • Monads are mathematical objects with additional properties. • The monad operations must satisfy the following laws. (1) return x >>= f = f x (left unit) (2) m >>= return = m (right unit) (3) (m >>= f) >>= g = m >>= (\\x -> (f x >>= g)) (associativity) These laws enable equational reasoning about monadic programs. • Exercise: check that these laws hold for the Maybe monad. Also check this for all other monads in this lecture. Functional Programming Spring Semester, 2022 David Basin 10 The monad type class — full story part I Two additional ingredients class Monad m where -- return and bind are the mathematical core return :: a -> m a (>>=) :: m a -> (a -> m b) -> m b -- shortcut for convenience; when second computation -- does not dependent on result of first one (>>) :: m a -> m b -> m b m1 >> m2 = m1 >>= (\\ -> m2) -- not part of mathematical concept of a monad -- called on pattern matching errors in do-notation fail :: String -> m a Functional Programming Spring Semester, 2022 David Basin 11 Stateful computation Functional Programming Spring Semester, 2022 David Basin 12 Example: renaming of tree nodes • We want to consistently rename tree nodes in preorder fashion. • New names are given as a list that is assumed to be long enough. • Idea: Use an accumulator to keep track of two things: the list of remaining names and a table of current name translations. 2 3 4 52 1 2 1 5 3 b c d eb a b a e c Before After *) names = [a, b, c, d, e] red indicates first occurrence (in preorder) *) When reaching this node the accumulator contains ([d, e], [(3, c), (2, b), (1, a)]) Functional Programming Spring Semester, 2022 David Basin 13 Implementation of tree node renaming The type of accumulator (names, table) is ([b],[(a,b)]). rename :: Eq a => [b] -> Tree a -> Tree b rename names = fst . go (names, []) go :: Eq a => ([b],[(a,b)]) -> Tree a -> (Tree b, ([b],[(a,b)])) go state Leaf = (Leaf, state) go (names, table) (Node x l r) = case lookup x table of Nothing -> let x’ = head names state’ = (tail names, (x, x’):table) (l’, state’’) = go state’ l (r’, state’’’) = go state’’ r in (Node x’ l’ r’, state’’’) Just x’ -> let (l’, state’) = go (names, table) l (r’, state’’) = go state’ r in (Node x’ l’ r’, state’’) Ugly plumbing needed to thread state through two recursive calls. Functional Programming Spring Semester, 2022 David Basin 14 Constructing the state monad Type constructor for stateful computations data State s a = State (s -> (a, s)) Idea: computation takes a state of type s and transforms it into a result of type a and a successor state of type s. State access read current value of state without changing it get :: State s s get = State (\\s -> (s, s)) State update write a new state value, ignoring the current state put :: s -> State s () put t = State (\\s -> ((), t)) Functional Programming Spring Semester, 2022 David Basin 15 Return and bind Run is an auxiliary function that opens the monad and runs the computation from the initial state s0 runState :: (State s a) -> (s -> (a, s)) runState (State m) s0 = m s0 Return embeds a value into a stateful computation return :: a -> State s a return x = State (\\s -> (x, s)) Bind composes two stateful computations with value binding (>>=) :: State s a -> (a -> State s b) -> State s b m >>= k = State (\\s -> let (x, t) = runState m s in runState (k x) t) Note: The operator (>>) deﬁned as m1 >> m2 = m1 >>= (\\_ -> m2) is essentially the sequential composition (;) in imperative programming languages. Functional Programming Spring Semester, 2022 David Basin 16 Understanding the state monad x := x + 1 in state monad Stepwise (eager) evaluation of tick tick :: State Int () tick = do x <- get put (x + 1) with explicit binding tick :: State Int () tick = get >>= (\\x-> put (x + 1)) tick ↪→ State (\\s -> let (x, t) = runState get s in runState (put (x + 1)) t) ) ↪→ State (\\s -> let (x, t) = (\\s -> (s, s)) s in (\\s -> ((), x + 1)) t) ) ↪→ State (\\s -> ((), s + 1)) • The state monad encapsulates program composition. • To run the program: invoke runState tick s0 where s0 is some initial state. Functional Programming Spring Semester, 2022 David Basin 17 Tree renaming using the state monad rename :: Eq a => [b] -> Tree a -> Tree b rename names t = fst $ runState (renameTree t) (names, []) renameTree :: Eq a => Tree a -> State ([b],[(a,b)]) (Tree b) renameTree Leaf = return Leaf renameTree (Node x l r) = do (names, table) <- get case lookup x table of Nothing -> do let x’ = head names -- ‘in’ omitted in monadic syntax put (tail names, (x, x’):table) l’ <- renameTree l r’ <- renameTree r return (Node x’ l’ r’) Just x’ -> do l’ <- renameTree l r’ <- renameTree r return (Node x’ l’ r’) The state monad takes care of all the plumbing! Functional Programming Spring Semester, 2022 David Basin 18 Tree renaming the way you want it • Renaming can be made a bliss ... renameTree’ :: Eq a => Tree a -> State ([b],[(a,b)]) (Tree b) renameTree’ Leaf = return Leaf renameTree’ (Node x l r) = do x’ <- translate x l’ <- renameTree’ l r’ <- renameTree’ r return (Node x’ l’ r’) • ... by abstracting the pattern of looking up a translation translate :: Eq a => a -> State ([b],[(a,b)]) b translate x = do (names, table) <- get case lookup x table of Nothing -> do let x’ = head names put (tail names, (x, x’):table) return x’ Just x’ -> do return x’ Functional Programming Spring Semester, 2022 David Basin 19 Input/Output Functional Programming Spring Semester, 2022 David Basin 20 Why is IO problematic? • How would we write a program like the following in Haskell? void main () { char name[20]; printf (\"Hi, I am HAL. Who are you?\"); scanf (\"%19s\", name); printf (\"Hello %s!\", name); } • Assume there would be functions like inputInt :: Int in Haskell \u0011 What is the value of inputInt - inputInt? \u0011 Equational reasoning would no longer be sound \u0011 Result depends on order in which the arguments are evaluated • This function is not side-eﬀect free! So which state changes? Functional Programming Spring Semester, 2022 David Basin 21 The IO type constructor • Haskell uses a monad to distinguish between pure expressions and expressions that interact with The World. IO a type of computations performing I/O operations and returning a value of type a • Examples: inputInt :: IO Int inputString :: IO String outputInt :: Int -> IO () -- () is the unit type in Haskell • You can think of IO a as an instance of the state monad (with diﬀerent constructor and special type of state) data IO a = InOut (TheWorld -> (a, TheWorld)) Functional Programming Spring Semester, 2022 David Basin 22 Basic actions • Haskell (see Prelude.hs) provides IO primitives \u0011 getChar :: IO Char The action getChar reads a character from the keyboard, echoes it to the screen, and returns the character as result value. \u0011 putChar :: Char -> IO () The action putChar c writes the character c to the screen and returns no result value. \u0011 return :: a -> IO a The action return v simply returns the value v, without performing any interaction. • . . . and many others (reading & writing ﬁles, etc.) Functional Programming Spring Semester, 2022 David Basin 23 Sequencing • The order of the actions matters read2 = do c1 <- getChar read2’ = do c2 <- getChar c2 <- getChar c1 <- getChar return (c1:c2:[]) return (c1:c2:[]) What is the type of read2? • Previous lecture: order of applying parsers also matters pexpr = do token \"(\" pexpr’ = do token \"(\" e <- expr token \")\" token \")\" e <- expr return e return e • The IO type constructor cannot be “opened”. Hence, any function doing I/O will have range IO a for some type a. • For example, inputInt - inputInt is incorrect. Why? Functional Programming Spring Semester, 2022 David Basin 24 IO examples • Printing a string on the screen: putString :: String -> IO () putString \"\" = return () putString (x:xs) = do putChar x; putString xs • Reading a string from the keyboard: getString :: IO String getString = do c <- getChar if c == ’\\n’ then return \"\" else do cs <- getString return (c:cs) • A “hello world” program in Haskell: main :: IO () main = do putString \"Hi, I am HAL. Who are you?\\n\" name <- getString putString (\"Hello \" ++ name ++ \"!\\n\") Functional Programming Spring Semester, 2022 David Basin 25 Summary (Part I) • Monads are a powerful concept which helps understanding and modeling computations with side eﬀects. • Contrary to imperative languages, where side eﬀects are the rule, monads promote the use of side eﬀects in a controlled way (you usually have a good reason to use a monad). • Construct, combine, and use monads that exactly ﬁt the structure of your problem (ﬁne-grained control of side eﬀects). • New monads can model computational eﬀects that are not present in imperative languages (e.g., non-determinism, continuations) • Monadic computations are ﬁrst-class values that can be composed as needed. Functional Programming Spring Semester, 2022 David Basin 26 The monad type class — full story part II Two superclasses class Functor f where ... class Functor f => Applicative f where ... class Applicative m => Monad m where -- return and bind are the mathematical core return :: a -> m a (>>=) :: m a -> (a -> m b) -> m b -- shortcut for convenience; when second computation -- does not depend on result of first (>>) :: m a -> m b -> m b m1 >> m2 = m1 >>= (\\_ -> m2) -- not part of mathematical concept of a monad -- called on pattern matching errors in do-notation fail :: String -> m a fail s = error s When you instantiate Monad, you must instantiate Functor and Applicative, too. Functional Programming Spring Semester, 2022 David Basin 27 The functor type class The map function transforms all elements in a structure: List map :: (a -> b) -> [a] -> [b] Tree data Tree t = Leaf | Node t (Tree t) (Tree t) mapTree :: (t -> u) -> Tree t -> Tree u mapTree _ Leaf = Leaf mapTree f (Node x l r) = Node (f x) (mapTree f l) (mapTree f r) The type class Functor captures this functionality class Functor f where fmap :: (a -> b) -> f a -> f b instance Functor Tree where fmap _ Leaf = Leaf fmap f (Node x l r) = Node (f x) (fmap f l) (fmap f r) > fmap (*2) [0,1,2] = [0,2,4] > fmap (*2) (Node 5 Leaf Leaf) = Node 10 Leaf Leaf Functional Programming Spring Semester, 2022 David Basin 28 Functor laws class Functor f where fmap :: (a -> b) -> f a -> f b Functor instances must satisfy two functor laws: 1. Identity: fmap id v = v 2. Composition: fmap f (fmap g v) = fmap (f . g) v Exercise: Show that the functor laws hold for lists and trees. Functional Programming Spring Semester, 2022 David Basin 29 Canonical functor implementation for monads A monad has return :: b -> m b (>>=) :: m a -> (a -> m b) -> m b We need fmap :: (a -> b) -> m a -> m b So fmap f v = v >>= (return . f). In a monad, fmap applies a function to the results of a computation. instance Monad Maybe where return x = Just x Nothing >>= _ = Nothing (Just x) >>= f = f x instance Functor Maybe where fmap f v = v >>= (return . f) fmap f Nothing fmap f (Just a) = Nothing >>= (return . f) = Just a >>= (return . f) = Nothing = (return . f) a = Just (f a) Exercise: Derive the functor laws from the monad laws. Functional Programming Spring Semester, 2022 David Basin 30 Applicative functors How can we apply functions to the results of several computations? E.g., apply (<) to Just 2 and Just 3? fmap (<) (Just 2) :: Maybe (Int -> Bool) -- fmap is not enough We could deﬁne fmap2, fmap3, . . . , but this scales badly. In an applicative functor, <*> mimicks function application: fmap (<) (Just 2) <*> (Just 3) = Just True Maybe (Int -> Bool) Maybe Int Maybe Bool class Functor f => Applicative f where pure :: a -> f a (<*>) :: f (a -> b) -> f a -> f b -- associates to the left instance Applicative Maybe where pure x = Just x Just f <*> Just x = Just (f x) _ <*> _ = Nothing Functional Programming Spring Semester, 2022 David Basin 31 Applicative functor example instance Applicative Maybe where pure x = Just x Just f <*> Just x = Just (f x) _ <*> _ = Nothing pure (+) <*> Just 5 <*> Just 7 -- <*> associates to the left = (pure (+) <*> Just 5) <*> Just 7 = (Just (+) <*> Just 5) <*> Just 7 = Just (5+) <*> Just 7 = Just (5 + 7) = Just 12 pure (+) <*> Nothing <*> Just 7 = (Just (+) <*> Nothing) <*> Just 7 = Nothing <*> Just 7 -- Nothing propagates = Nothing Functional Programming Spring Semester, 2022 David Basin 32 Applicative functor laws and monads Applicative functors must satisfy ﬁve laws: 1. Identity: pure id <*> v = v 2. Homomorphism: pure f <*> pure x = pure (f x) 3. Composition: pure (.) <*> u <*> v <*> w = u <*> (v <*> w) 4. Interchange: v <*> pure x = pure (\\f -> f x) <*> v 5. fmap: fmap f v = pure f <*> v Canonical implementation for monads: pure x = return x u <*> v = u >>= \\f -> v >>= \\x -> return (f x) Exercises: 1. Derive the applicative functor laws from the monad laws. 2. Check that the instance for Maybe is the canonical one. Functional Programming Spring Semester, 2022 David Basin 33 Case study: Monadic Interpreters Functional Programming Spring Semester, 2022 David Basin 34 Language: A variant of mini-Haskell • Language we consider here: Term ::= Identiﬁer | Number | λx. Term | Term Term | Term + Term This core language could be extended with other arithmetic operations, predicates, if-then-else, recursion, ... • Data types for syntax: type Name = String data Term = Var Name | Lit Int | Lam Name Term | App Term Term | Add Term Term • Only consider evaluation, for parsing see previous module. Functional Programming Spring Semester, 2022 David Basin 35 Standard and monadic interpreters Standard Interpreters Monadic interpreters Value (:: Value) Read Evaluate Print Text Lexical Analysis Text Value computation (:: M Value) Read Evaluate Print Text Lexical Analysis Text - for calculuator in previous lecture: Value = Int; - for λ-calculus interpreter: Value = Term. Functional Programming Spring Semester, 2022 David Basin 36 Standard interpreter • Comparison with λ-interpreter from previous lecture: \u0011 eager evaluation: evaluate function arguments and under λ’s \u0011 evaluate only closed terms, as is usual in programming \u0011 use Haskell’s substitution instead of implementing it ourselves • Output: structured type of values data Value = Wrong -- error | Num Int -- integer | Fun (Value -> Value) -- closure Error + λ-abstractions evaluate to closures. • An environment binds free variables to values type Environment = [(Name, Value)] Functional Programming Spring Semester, 2022 David Basin 37 Auxiliary functions data Value = Wrong -- error | Num Int -- integer | Fun (Value -> Value) -- closure type Environment = [(Name, Value)] lookup :: Name -> Environment -> Value lookup x [] = Wrong lookup x ((y, v):es) = if x == y then v else lookup x es add :: Value -> Value -> Value add (Num x) (Num y) = Num (x + y) add _ _ = Wrong apply :: Value -> Value -> Value apply (Fun k) a = k a apply _ _ = Wrong Functional Programming Spring Semester, 2022 David Basin 38 Standard evaluation data Value = Wrong -- error | Num Int -- integer | Fun (Value -> Value) -- closure type Environment = [(Name, Value)] eval :: Term -> Environment -> Value eval (Var v) e = lookup v e eval (Lit x) e = Num x eval (Lam x t) e = Fun (\\a -> eval t ((x, a):e)) eval (App t u) e = apply (eval t e) (eval u e) eval (Add t u) e = add (eval t e) (eval u e) run :: Term -> Value run t = eval t [] instance Show Value where show Wrong = \"<wrong>\" show (Num i) = show i show (Fun _) = \"<function>\" Functional Programming Spring Semester, 2022 David Basin 39 Standard interpreter – examples • Consider the terms (in abstract syntax) t0 = (λx. x + x) (10 + 11) ↪→ 42 t1 = (λx. x) + 12 ↪→ error t2 = λx. x + 1 ↪→ function • In concrete syntax: t0 = App (Lam \"x\" (Add (Var \"x\") (Var \"x\"))) (Add (Lit 10) (Lit 11)) t1 = Add (Lam \"x\" (Var \"x\")) (Lit 10) t2 = Lam \"x\" (Add (Var \"x\")) (Lit 1) • Evaluation in ghci: *Main> run t0 42 *Main> run t1 <wrong> *Main> run t2 <function> Functional Programming Spring Semester, 2022 David Basin 40 Example: (λx.x)(1 + 2) run (App (Lam \"x\" (Var \"x\")) (Add (Lit 1) (Lit 2))) = eval (App (Lam \"x\" (Var \"x\")) (Add (Lit 1) (Lit 2))) [] = apply (eval (Lam \"x\" (Var \"x\")) []) (eval (Add (Lit 1) (Lit 2)) []) = apply (Fun (\\a -> eval (Var \"x\") [(\"x\",a)]) (eval (Add (Lit 1) (Lit 2)) [])) = (\\a -> eval (Var \"x\") [(\"x\",a)]) (eval (Add (Lit 1) (Lit 2)) []) = eval (Var \"x\") [(\"x\",(eval (Add (Lit 1) (Lit 2)) []))] = lookup \"x\" [(\"x\",(eval (Add (Lit 1) (Lit 2)) []))] = eval (Add (Lit 1) (Lit 2)) [] = add (Num 1) (Num 2) = Num 3 Result Num 3 is output (with show) as 3. Functional Programming Spring Semester, 2022 David Basin 41 Monadic interpreter – ideas • Replace all functions with result type Value by functions with monadic result type M Value • Values and function signatures: data Value = Wrong -- error | Num Int -- integer | Fun (Value → M Value) -- closure eval :: Term → Environment → M Value run :: Term → M Value lookup :: Name → Environment → M Value apply, add :: Value → Value → M Value • Win: By varying the deﬁnition of the monad M, we obtain diﬀerent computational eﬀects. (Diﬀerent defs. upcoming!) Functional Programming Spring Semester, 2022 David Basin 42 Monadic interpreter – auxiliary functions data Value = Wrong | Num Int | Fun (Value -> M Value) type Environment = [(Name, Value)] lookup :: Name -> Environment -> M Value lookup x [] = return Wrong lookup x ((y, v):es) = if x == y then return v else lookup x es apply :: Value -> Value -> M Value apply (Fun k) a = k a apply = return Wrong add :: Value -> Value -> M Value add (Num x) (Num y) = return (Num (x + y)) add = return Wrong instance Show (M Value) = show m = ... -- depends on monad M Functional Programming Spring Semester, 2022 David Basin 43 Monadic interpreter – evaluation data Value = Wrong | Num Int | Fun (Value -> M Value) type Environment = [(Name, Value)] eval :: Term -> Environment -> M Value eval (Var v) e = lookup v e eval (Lit x) e = return (Num x) eval (Lam x t) e = return (Fun (\\a -> eval t ((x, a):e))) eval (App t u) e = do f <- eval t e a <- eval u e apply f a eval (Add t u) e = do a <- eval t e b <- eval u e add a b run :: Term -> M Value run t = eval t [] Functional Programming Spring Semester, 2022 David Basin 44 Monadic interpreter – instances • Recall: by varying the monad M we obtain interpreters with diﬀerent computational eﬀects. • We consider the following instances of the monad M: \u0011 Identity monad: recover standard interpreter \u0011 Exception monad: improved error handling \u0011 State monad: count number of evaluation steps \u0011 Nondeterministic monad: compute with choices \u0011 Output monad: output intermediate results • Abstraction is main beneﬁt of using monads: Only small changes are necessary in each case, basic structure remains the same. Functional Programming Spring Semester, 2022 David Basin 45 Identity monad: standard interpreter • The identity monad: data Id a = Id a instance Monad Id where return x = Id x -- identity function (Id m) >>= k = k m -- function application • For example, forgetting about the constructor Id, the clauses eval (Lit i) e = return (Num i) eval (App t u) e = eval t e >>= (\\f -> eval u e >>= (\\a -> apply f a)) simplify to eval (Lit i) e = Num i eval (App t u) e = apply (eval t e) (eval u e) Functional Programming Spring Semester, 2022 David Basin 46 Improving error handling • Current solution has a only single error message: <wrong> • First attempt to improve situation (in standard interpreter): data Value = Wrong String | Num Int | Fun (Value -> Value) • Specify source of error as argument to Wrong: lookup x [] = Wrong (\"Unbound variable: \" ++ x) apply v = Wrong (\"Not a function: \" ++ show v) add v w = Wrong (\"Not a number: \" ++ show v ++ \" or \" ++ show w) • Does not behave as intended: *Main> run (App (Var \"x\") (Lit 10)) Not a function: Unbound variable: x Functional Programming Spring Semester, 2022 David Basin 47 Exception monad • Type constructor and basic monad operations: data Exc a = Success a | Exception String instance Monad Exc where return x = Success x (Success a) >>= k = k a -- on success: continue (Exception e) >>= k = Exception e -- on exception: abort • Monad-speciﬁc operations: throw and catch exceptions throw :: String -> Exc a throw e = Exception e -- raise exception catch :: Exc a -> (a -> Exc a) -> Exc a catch (Success a) h = (Success a) -- normal execution catch (Exception e) h = h e -- call exception handler • Straightforward function show shows value or exception. Functional Programming Spring Semester, 2022 David Basin 48 Adapting the interpreter • Modiﬁcation of data structures and interpreter data Value = Num Int -- removed: Wrong | Fun (Value → ExcM Value) lookup x [] = throw (\"Unbound variable: \"++x) apply v = throw (\"Not a function: \"++show v) add v w = throw (\"Not a number: \"++show v++\" or \"++show w) • Examples: (using abstract syntax) *Main> run (λx. x + x) (10 + 11) 42 *Main> run (x 10) Unbound variable: x *Main> run (λx. x) + 10 Not a number: <function> or 10 *Main> run 99 (λx. x) Not a function: 99 Functional Programming Spring Semester, 2022 David Basin 49 State monad: counting evaluation steps • The state monad (as seen before): data State s a = State (s -> (a, s)) instance Monad (State s) where return x = State (\\s -> (x, s)) m >>= k = State (\\s -> let (a, t) = runState m s in runState (k a) t) • Monad-speciﬁc operations for state manipulation: get :: State s s get = State (\\s -> (s, s)) -- read put :: s -> State s () put t = State (\\s -> ((), t)) -- update • Speciﬁc to application: step counting tick :: State Int () tick = do s <- get; put (s + 1) -- increment counter Functional Programming Spring Semester, 2022 David Basin 50 Adapting the interpreter • We add tick’s to addition (and similarly to application): eval (Add t u) e = do a <- eval t e b <- eval u e r <- add a b tick -- count addition return r • The show function runs the monad with counter initialized to 0. instance Show (State Int Value) where show m = let (a, c) = runState m 0 in \"Value: \" ++ show a ++ \"; \" ++ \"Count: \" ++ show c ++ \".\" • Examples: *Main> run (λx. x + x) (10 + 11) Value 42; Count 3. *Main> run (λx. x + 1) ((λx. x + x) (10 + 11)) Value 43; Count 5. Functional Programming Spring Semester, 2022 David Basin 51 Nondeterministic monad: allowing choices • The nondeterministic monad (aka list monad): data Alt a = Alt [a] runAlt :: Alt a -> [a] runAlt (Alt l) = l instance Monad Alt where return a = Alt [a] m >>= k = Alt [b | a <- runAlt m, b <- runAlt (k a)] Idea: computation may produce several possible results. • We also need the following monad-speciﬁc operations. failure :: Alt a failure = Alt [] choice :: Alt a -> Alt a -> Alt a choice xs ys = Alt (runAlt xs ++ runAlt ys) Functional Programming Spring Semester, 2022 David Basin 52 Adapting the interpreter • Extend the term language with failure and choice operations: data Term = ... | Fail -- written ⊥ below | Or Term Term -- (Or t u) written t | u below • The interpreter is extended as follows: eval Fail e = failure eval (Or t u) e = eval t e ‘choice‘ eval u e • Examples: *Main> run ((λx. x + x) (10 + 11)) [42] *Main> run ((λx y. x + x + y) (10 | 20) (1 | 5)) [21,25,41,45] *Main> run ((7 | 10) + ⊥) [] Functional Programming Spring Semester, 2022 David Basin 53 Output monad: tracing intermediate results • Output monad chains computations and concatenates output: data Out a = Out (a, String) runOut :: Out a -> (a, String) runOut (Out x) = x instance Monad Out where return x = (x, \"\") m >>= k = let (a, r) = runOut m; (b, s) = runOut k a in Out (b, r ++ s) • Monad-speciﬁc output function: out :: Show a => a -> Out () out a = ((), show a ++ \"; \") • Show monad value: instance Show a => Show (Out a) where show (Out (a, s)) = \"Output: \" ++ s ++ \"Value: \" ++ show a Functional Programming Spring Semester, 2022 David Basin 54 Adapting the interpreter for output tracing • Extend the term language with a Show operation: Term = ... | Show Term -- Show t written #t below • Extension of the interpreter: eval (Show t) e = do r <- eval t e -- evaluate t out r -- display its value return r -- and return it • Examples: *Main> run ((λx. x + x) #(10 + 11)) Output: 21; Value: 42 *Main> run (#(#(1 + 2) + 3) + 4) Output: 3; 6; Value: 10 *Main> run (1 + #(2 + #(3 + 4))) Output: 7; 9; Value: 10 Functional Programming Spring Semester, 2022 David Basin 55 A zoo of monads Monad Type constructor Partiality Maybe a = Nothing | Just a Exceptions Exc e a = Exception e | Success a State State s a = State (s -> (a, s)) Input/Output IO a = (*) InOut (TheWorld-> (a, TheWorld)) Nondeterminism Alt a = Alt [a] Output Out a = Out (a,String) Parsers Parser a = Parser (String -> [(a, String)]) (*) The deﬁnition of the Haskell IO monad is a conceptual one. Functional Programming Spring Semester, 2022 David Basin 56 Conclusions Summary Using monads we can ... • write functional programs with a variety of controlled side eﬀects in a uniform, abstract, and ﬂexible way • obtain a deeper understanding of the meaning of side eﬀects Combining monads • Q: How can I model language AFX (All Fancy eﬀeXts)? • A: Use monad transformers to modularly combine monads. E.g., the parser monad is a non-deterministic state monad, we can also deﬁne state-exception monads, etc. Reasoning about monads two possibilities: • equational reasoning using deﬁnitions of monadic functions and monad laws (verify these for any monads you may invent), or • pre-/post-condition reasoning using a monadic Hoare logic Functional Programming Spring Semester, 2022 David Basin 57 Bibliography • Monad tutorials recommended at http: //www.haskell.org/haskellwiki/Tutorials#Using_monads • Philip Wadler, The essence of functional programming, POPL 92, 1992. [Nice series of interpreters with monadic eﬀects.] • Sheng Liang, Paul Hudak, and Mark Jones, Monad transformers and modular interpreters, POPL 95, 1995. [Series of interpreters obtained in a modular fashion using monad transformers. This goes beyond this course, but is very readable.] • Nick Benton, John Hughes, and Eugenio Moggi, Monads and Eﬀects, 2002. [Covers both theoretical aspects and programming.] Functional Programming Spring Semester, 2022 David Basin 58 Haskell Outlook Functional Programming Spring Semester, 2022 David Basin 59 Haskell usage • Haskell has a thriving and exceptionally friendly user community Website: www.haskell.org Maling List: haskell-cafe@haskell.org Blogs: planet.haskell.org IRC: #haskell on freenode.net Reddit: www.reddit.com/r/haskell/ Libraries: hackage.haskell.org • Commercial users of functional programming \u0011 Website: cufp.org (includes a job board) \u0011 Credit Suisse: Modeling and analysis of ﬁnancial products \u0011 Standard Chartered: Own (eager) Haskell compiler \u0011 Galois: High-assurance applications (e.g., for the US DoD) \u0011 Bluespec: Hardware design languages and automation Functional Programming Spring Semester, 2022 David Basin 60 Haskell research • Functional programming is an active research topic Conferences: ICFP, IFL, Haskell Symposium, POPL Abstraction: embedded languages, generic programming Concurrency: Data Parallel Haskell, STM Eﬃciency: compilation techniques, data structures Correctness: type and proof systems, testing ⇒ Haskell is likely to become even better in the future Functional Programming Spring Semester, 2022 David Basin 61 Research highlight: the L4.veriﬁed project • A truly trustworthy, high-performance operating system kernel with a machine-checked proof of its functional correctness w.r.t. a high level, formal description of its expected behaviour. http://ertos.nicta.com.au/research/l4.verified/ Functional Programming Spring Semester, 2022 David Basin 62 Mechanized theorem proving • Complex formal proofs are constructed using proof assistants • In our research group, we use the Isabelle/HOL proof assistant • Lab course in the spring semester: Computer-Aided Modelling and Reasoning Chance for an exciting student project, bachelor/master thesis. Functional Programming Spring Semester, 2022 David Basin 63 End of part I • Starting next class: part II on Formal Methods Peter M¨uller takes over. • If you are interested in a student project, bachelors thesis, or masters thesis using functional programming or logic, please contact one of the organizers of this course or visit www.infsec.ethz.ch/education/studentProjects.html Functional Programming Spring Semester, 2022","libVersion":"0.5.0","langs":""}