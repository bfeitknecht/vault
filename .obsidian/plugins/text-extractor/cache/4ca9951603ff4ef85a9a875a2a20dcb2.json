{"path":"sem2/DDCA/VRL/extra/MIPS-cheatsheet.pdf","text":"N J Q T Reference Data £¢¶“⁄_“ﬂ¶•·‚⁄•“–ﬂ_§–·ﬁ¢•¶ ·ƒ¤“¶•ƒ·_ﬂ¢ﬁƒk_ﬂ‚ﬁ£ƒ·k_‚¶ƒk_⁄¢››_⁄–ﬂ„ƒﬂ•“–ﬂ ⁄–·ƒ_“ﬂ¶•·‚⁄•“–ﬂ_¶ƒ• OPCODE NAME, MNEMONIC FOR- MAT OPERATION (in Verilog) / FUNCT (Hex) Add ãèè R R[rd] = R[rs] + R[rt] (1) 0 / 20hex Add Immediate ãèèñ I R[rt] = R[rs] + SignExtImm (1,2) 8hex Add Imm. Unsigned ãèèñ¶ I R[rt] = R[rs] + SignExtImm (2) 9hex Add Unsigned ãèè¶ R R[rd] = R[rs] + R[rt] 0 / 21hex And ãùè R R[rd] = R[rs] & R[rt] 0 / 24hex And Immediate ãùèñ I R[rt] = R[rs] & ZeroExtImm (3) chex Branch On Equal åê° I if(R[rs]==R[rt]) PC=PC+4+BranchAddr (4) 4hex Branch On Not Equal åùê I if(R[rs]!=R[rt]) PC=PC+4+BranchAddr (4) 5hex Jump ò J PC=JumpAddr (5) 2hex Jump And Link òãõ J R[31]=PC+8;PC=JumpAddr (5) 3hex Jump Register ò¢ R PC=R[rs] 0 / 08hex Load Byte Unsigned õå¶ I R[rt]={24’b0,M[R[rs] +SignExtImm](7:0)} (2) 24hex Load Halfword Unsigned õî¶ I R[rt]={16’b0,M[R[rs] +SignExtImm](15:0)} (2) 25hex Load Linked õõ I R[rt] = M[R[rs]+SignExtImm] (2,7) 30hex Load Upper Imm. õ¶ñ I R[rt] = {imm, 16’b0} fhex Load Word õ® I R[rt] = M[R[rs]+SignExtImm] (2) 23hex Nor ùû¢ R R[rd] = ~ (R[rs] | R[rt]) 0 / 27hex Or û¢ R R[rd] = R[rs] | R[rt] 0 / 25hex Or Immediate û¢ñ I R[rt] = R[rs] | ZeroExtImm (3) dhex Set Less Than §õ• R R[rd] = (R[rs] < R[rt]) ? 1 : 0 0 / 2ahex Set Less Than Imm. §õ•ñ I R[rt] = (R[rs] < SignExtImm)? 1 : 0 (2) ahex Set Less Than Imm. Unsigned §õ•ñ¶ I R[rt] = (R[rs] < SignExtImm) ? 1 : 0 (2,6) bhex Set Less Than Unsig. §õ•¶ R R[rd] = (R[rs] < R[rt]) ? 1 : 0 (6) 0 / 2bhex Shift Left Logical §õõ R R[rd] = R[rt] << shamt 0 / 00hex Shift Right Logical §¢õ R R[rd] = R[rt] >> shamt 0 / 02hex Store Byte §å I M[R[rs]+SignExtImm](7:0) = R[rt](7:0) (2) 28hex Store Conditional §ç I M[R[rs]+SignExtImm] = R[rt]; R[rt] = (¾ÏÉÅÁ®) ? 1 : 0 (2,7) 38hex Store Halfword §î I M[R[rs]+SignExtImm](15:0) = R[rt](15:0) (2) 29hex Store Word §® I M[R[rs]+SignExtImm] = R[rt] (2) 2bhex Subtract §¶å R R[rd] = R[rs] - R[rt] (1) 0 / 22hex Subtract Unsigned §¶å¶ R R[rd] = R[rs] - R[rt] 0 / 23hex (1) May cause overflow exception (2) SignExtImm = { 16{immediate[15]}, immediate } (3) ZeroExtImm = { 16{1b’0}, immediate } (5) JumpAddr = { PC+4[31:28], address, 2’b0 } (7) Atomic test&set pair; R[rt] = 1 if pair atomic, 0 if not atomic R opcode rs rt rd shamt funct 31 26 25 21 20 16 15 11 10 6 5 0 I opcode rs rt immediate 31 26 25 21 20 16 15 0 J opcode address 31 26 25 0 ¢·“•'ﬁƒ•“⁄_⁄–·ƒ_“ﬂ¶•·‚⁄•“–ﬂ_¶ƒ• OPCODE NAME, MNEMONIC FOR- MAT OPERATION / FMT /FT / FUNCT (Hex) Branch On FP True åç2• FI if(FPcond)PC=PC+4+BranchAddr (4) 11/8/1/-- Branch On FP False åç2í FI if(!FPcond)PC=PC+4+BranchAddr(4) 11/8/0/-- Divide èñß R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] 0/--/--/1a Divide Unsigned èñß¶ R Lo=R[rs]/R[rt]; Hi=R[rs]%R[rt] (6) 0/--/--/1b FP Add Single ãèè/§ FR F[fd ]= F[fs] + F[ft] 11/10/--/0 FP Add Double ãèè/è FR {F[fd],F[fd+1]} = {F[fs],F[fs+1]} + {F[ft],F[ft+1]} 11/11/--/0 FP Compare Single ç.Ô.§* FR FPcond = (F[fs] ÉÊ F[ft]) ? 1 : 0 11/10/--/Ö FP Compare Double ç.Ô.è* FR FPcond = ({F[fs],F[fs+1]} ÉÊ {F[ft],F[ft+1]}) ? 1 : 0 11/11/--/Ö * (Ô is ê°, õ•, or õê) (ÉÊ is ==, <, or <=) ( Ö is 32, 3c, or 3e) FP Divide Single èñß/§ FR F[fd] = F[fs] / F[ft] 11/10/--/3 FP Divide Double èñß/è FR {F[fd],F[fd+1]} = {F[fs],F[fs+1]} / {F[ft],F[ft+1]} 11/11/--/3 FP Multiply Single ú¶õ/§ FR F[fd] = F[fs] * F[ft] 11/10/--/2 FP Multiply Double ú¶õ/è FR {F[fd],F[fd+1]} = {F[fs],F[fs+1]} * {F[ft],F[ft+1]} 11/11/--/2 FP Subtract Single §¶å/§ FR F[fd]=F[fs] - F[ft] 11/10/--/1 FP Subtract Double §¶å/è FR {F[fd],F[fd+1]} = {F[fs],F[fs+1]} - {F[ft],F[ft+1]} 11/11/--/1 Load FP Single õ®ç2 I F[rt]=M[R[rs]+SignExtImm] (2) 31/--/--/-- Load FP Double õèç2 I F[rt]=M[R[rs]+SignExtImm]; (2) F[rt+1]=M[R[rs]+SignExtImm+4] 35/--/--/-- Move From Hi úíîñ R R[rd] = Hi 0 /--/--/10 Move From Lo úíõû R R[rd] = Lo 0 /--/--/12 Move From Control úíç1 R R[rd] = CR[rs] 10 /0/--/0 Multiply ú¶õ• R {Hi,Lo} = R[rs] * R[rt] 0/--/--/18 Multiply Unsigned ú¶õ•¶ R {Hi,Lo} = R[rs] * R[rt] (6) 0/--/--/19 Shift Right Arith. §¢ã R R[rd] = R[rt] >>> shamt 0/--/--/3 Store FP Single §®ç2 I M[R[rs]+SignExtImm] = F[rt] (2) 39/--/--/-- Store FP Double §èç2 I M[R[rs]+SignExtImm] = F[rt]; (2) M[R[rs]+SignExtImm+4] = F[rt+1] 3d/--/--/-- FR opcode fmt ft fs fd funct 31 26 25 21 20 16 15 11 10 6 5 0 FI opcode fmt ft immediate 31 26 25 21 20 16 15 0 NAME MNEMONIC OPERATION Branch Less Than åõ• if(R[rs]<R[rt]) PC = Label Branch Greater Than åì• if(R[rs]>R[rt]) PC = Label Branch Less Than or Equal åõê if(R[rs]<=R[rt]) PC = Label Branch Greater Than or Equal åìê if(R[rs]>=R[rt]) PC = Label Load Immediate õñ R[rd] = immediate Move úûßê R[rd] = R[rs] NAME NUMBER USE PRESERVED ACROSS A CALL? $zero 0 The Constant Value 0 N.A. $at 1 Assembler Temporary No $v0-$v1 2-3 Values for Function Results and Expression Evaluation No $a0-$a3 4-7 Arguments No $t0-$t7 8-15 Temporaries No $s0-$s7 16-23 Saved Temporaries Yes $t8-$t9 24-25 Temporaries No $k0-$k1 26-27 Reserved for OS Kernel No $gp 28 Global Pointer Yes $sp 29 Stack Pointer Yes $fp 30 Frame Pointer Yes $ra 31 Return Address Yes 1 2ﬁ“†¶__·ð×ðÈðÃ®ð_¥¾Ï¾_⁄¾È−_g“¤ÈððÃ_⁄¾È−”h1. Pull along perforation to separate card2. Fold bottom side (columns 3 and 4) together §›–¢•“ﬂ¤l†–“ﬂ•_“ﬂ¶•·‚⁄•“–ﬂ_§–·ﬁ¢•¶ †¶ƒ‚¥–“ﬂ¶•·‚⁄•“–ﬂ_¶ƒ• Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, ⁄ÉÅÊÌÏðÈ_–È³¾ÃÁÒ¾ÏÁÉÃ_¾Ã−_¥ðÎÁ³Ãk 4th ed. (4) BranchAddr = { 14{immediate[15]}, immediate, 2’b0 } ’(6) Operands considered unsigned numbers (vs. 2 s comp.) ... Argument 6 Argument 5 Saved Registers Local Variables –†⁄–¥ƒ¶k_£¢¶ƒ_⁄–ﬂ„ƒ·¶“–ﬂk_¢¶⁄““_¶…ﬁ£–›¶ (1) opcode(31:26) == 0 (2) opcode(31:26) == 17ten (11hex); if fmt(25:21)==16ten (10hex) × = § (single); if fmt(25:21)==17ten (11hex) × = è (double) ¶•¢ﬂ¥¢·¥ (-1)S × (1 + Fraction) × 2(Exponent - Bias) where Single Precision Bias = 127, Double Precision Bias = 1023. “ƒƒƒ_¶ÁÃ³Àð_†Èð®ÁÎÁÉÃ_¾Ã− ¥ÉÌ²Àð_†Èð®ÁÎÁÉÃ_§ÉÈÅ¾ÏÎy ﬁƒﬁ–·…_¢››–⁄¢•“–ﬂ $sp 7fff fffchex $gp 1000 8000hex 1000 0000hex pc 0040 0000hex 0hex ¥¢•¢_¢›“¤ﬂﬁƒﬂ• ƒ»⁄ƒ†•“–ﬂ_⁄–ﬂ•·–›_·ƒ¤“¶•ƒ·¶y_⁄¢‚¶ƒ_¢ﬂ¥_¶•¢•‚¶ ƒ»⁄ƒ†•“–ﬂ_⁄–¥ƒ¶ ¶“‰ƒ_†·ƒ§“»ƒ¶_gpo Ô_×ÉÈ_¥ÁÎÄk_⁄ÉÅÅÌÃÁ®¾ÏÁÉÃz_q Ô_×ÉÈ_ﬁðÅÉÈÖh The symbol for each prefix is just its first letter, except µ is used for micro. MIPS opcode (31:26) (1) MIPS funct (5:0) (2) MIPS funct (5:0) Binary Deci- mal Hexa- deci- mal ASCII Char- acter Deci- mal Hexa- deci- mal ASCII Char- acter (1) §õõ ãèè.× 00 0000 0 0 NUL 64 40 @ §¶å.× 00 0001 1 1 SOH 65 41 A ò §¢õ ú¶õ.× 00 0010 2 2 STX 66 42 B òãõ §¢ã èñß.× 00 0011 3 3 ETX 67 43 C åê° §õõß §°¢•.× 00 0100 4 4 EOT 68 44 D åùê ãå§.× 00 0101 5 5 ENQ 69 45 E åõê´ §¢õß úûß.× 00 0110 6 6 ACK 70 46 F åì•´ §¢ãß ùêì.× 00 0111 7 7 BEL 71 47 G ãèèñ ò¢ 00 1000 8 8 BS 72 48 H ãèèñ¶ òãõ¢ 00 1001 9 9 HT 73 49 I §õ•ñ úûß´ 00 1010 10 a LF 74 4a J §õ•ñ¶ úûßù 00 1011 11 b VT 75 4b K ãùèñ §™§çãõõ ¢û¶ùè/®.× 00 1100 12 c FF 76 4c L û¢ñ å¢êãô •¢¶ùç/®.× 00 1101 13 d CR 77 4d M ©û¢ñ çêñõ/®.× 00 1110 14 e SO 78 4e N õ¶ñ §™ùç íõûû¢/®.× 00 1111 15 f SI 79 4f O úíîñ 01 0000 16 10 DLE 80 50 P (2) ú•îñ 01 0001 17 11 DC1 81 51 Q úíõû úûß´.× 01 0010 18 12 DC2 82 52 R ú•õû úûßù.× 01 0011 19 13 DC3 83 53 S 01 0100 20 14 DC4 84 54 T 01 0101 21 15 NAK 85 55 U 01 0110 22 16 SYN 86 56 V 01 0111 23 17 ETB 87 57 W ú¶õ• 01 1000 24 18 CAN 88 58 X ú¶õ•¶ 01 1001 25 19 EM 89 59 Y èñß 01 1010 26 1a SUB 90 5a Z èñß¶ 01 1011 27 1b ESC 91 5b [ 01 1100 28 1c FS 92 5c \\ 01 1101 29 1d GS 93 5d ] 01 1110 30 1e RS 94 5e ^ 01 1111 31 1f US 95 5f _ õå ãèè çß•/§.× 10 0000 32 20 Space 96 60 ‘ õî ãèè¶ çß•/è.× 10 0001 33 21 ! 97 61 a õ®õ §¶å 10 0010 34 22 \" 98 62 b õ® §¶å¶ 10 0011 35 23 # 99 63 c õå¶ ãùè çß•/®.× 10 0100 36 24 $ 100 64 d õî¶ û¢ 10 0101 37 25 % 101 65 e õ®¢ ©û¢ 10 0110 38 26 & 102 66 f ùû¢ 10 0111 39 27 ’ 103 67 g §å 10 1000 40 28 ( 104 68 h §î 10 1001 41 29 ) 105 69 i §®õ §õ• 10 1010 42 2a * 106 6a j §® §õ•¶ 10 1011 43 2b + 107 6b k 10 1100 44 2c , 108 6c l 10 1101 45 2d - 109 6d m §®¢ 10 1110 46 2e . 110 6e n çãçîê 10 1111 47 2f / 111 6f o õõ •ìê ç/í.× 11 0000 48 30 0 112 70 p õ®ç2 •ìê¶ ç/¶ù.× 11 0001 49 31 1 113 71 q õ®ç3 •õ• ç/ê°.× 11 0010 50 32 2 114 72 r †¢êí •õ•¶ ç/¶ê°.× 11 0011 51 33 3 115 73 s •ê° ç/ûõ•.× 11 0100 52 34 4 116 74 t õèç2 ç/¶õ•.× 11 0101 53 35 5 117 75 u õèç3 •ùê ç/ûõê.× 11 0110 54 36 6 118 76 v ç/¶õê.× 11 0111 55 37 7 119 77 w §ç ç/§í.× 11 1000 56 38 8 120 78 x §®ç2 ç/ùìõê.× 11 1001 57 39 9 121 79 y §®ç3 ç/§ê°.× 11 1010 58 3a : 122 7a z ç/ùìõ.× 11 1011 59 3b ; 123 7b { ç/õ•.× 11 1100 60 3c < 124 7c | §èç2 ç/ùìê.× 11 1101 61 3d = 125 7d } §èç3 ç/õê.× 11 1110 62 3e > 126 7e ~ ç/ùì•.× 11 1111 63 3f ? 127 7f DEL S Exponent Fraction 31 30 23 22 0 S Exponent Fraction 63 62 52 51 0 Double Word Word Word Byte Byte Byte Byte Byte Byte Byte Byte 0 1 2 3 4 5 6 7 Value of three least significant bits of byte address (Big Endian) B D Interrupt Mask Exception Code 31 15 8 6 2 Pending Interrupt U M E L I E 15 8 4 1 0 Number Name Cause of Exception Number Name Cause of Exception 0 Int Interrupt (hardware) 9 Bp Breakpoint Exception 4 AdEL Address Error Exception (load or instruction fetch) 10 RI Reserved Instruction Exception 5 AdES Address Error Exception (store) 11 CpU Coprocessor Unimplemented 6IBE Bus Error on Instruction Fetch 12 Ov Arithmetic Overflow Exception 7 DBE Bus Error on Load or Store 13 Tr Trap 8 Sys Syscall Exception 15 FPE Floating Point Exception SIZE PRE- FIX SIZE PRE- FIX SIZE PRE- FIX SIZE PRE- FIX 10 3, 210 Kilo- 1015, 250 Peta- 10 -3 milli- 10 -15 femto- 10 6, 220 Mega- 10 18, 260 Exa- 10 -6 micro- 10 -18 atto- 10 9, 230 Giga- 1021, 270 Zetta- 10 -9 nano- 10 -21 zepto- 10 12, 240 Tera- 1024, 280 Yotta- 10 -12 pico- 10 -24 yocto- 3 Stack Dynamic Data Static Data Text Reserved “ƒƒƒ_vts_¶ÖÅ²ÉÀÎ S.P. MAX = 255, D.P. MAX = 2047 Exponent Fraction Object 00 ± 0 0 ≠ 0 ± Denorm 1 to MAX - 1 anything ± Fl. Pt. Num. MAX 0 ±∞ MAX ≠ 0 NaN ¶•¢⁄‹_§·¢ﬁƒ Higher Memory Addresses Lower Memory Addresses Stack Grows $sp $fp 4ﬁ“†¶__·ð×ðÈðÃ®ð_¥¾Ï¾_⁄¾È−_g“¤ÈððÃ_⁄¾È−”h1. Pull along perforation to separate card2. Fold bottom side (columns 3 and 4) together“ƒƒƒ_vts_§›–¢•“ﬂ¤l†–“ﬂ• Halfword Halfword Halfword Halfword BD = Branch Delay, UM = User Mode, EL = Exception Level, IE =Interrupt Enable Copyright 2009 by Elsevier, Inc., All rights reserved. From Patterson and Hennessy, ⁄ÉÅÊÌÏðÈ_–È³¾ÃÁÒ¾ÏÁÉÃ_¾Ã−_¥ðÎÁ³Ãk 4th ed.","libVersion":"0.5.0","langs":""}