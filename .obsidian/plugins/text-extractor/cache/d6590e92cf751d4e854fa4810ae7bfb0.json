{"path":"sem4/DMDB/UE/slides/DMDB-s07-SQL-3.pdf","text":"Data Modeling & Databases Andrei Girjoaba agirjoaba@student.ethz.ch Adapted from: Jonathan Chung & Wenqi Jiang Exercise 7 SQL III Spring 25 ▪ SQL III is new this year (2024) ▪ Pandas no longer exam relevant (but may still help you in other projects) ▪ This session may be a bit unusual… Disclaimer If you found mistakes, please report them on Moodle (or to me directly)! This Session 1. Recap/Introduction of NULLs and Views + some exercises 2. Kahoot like Quiz (may include content from current and previous exercises/lecture) 3. Exercise discussion What is NULL? ▪ NULL stands for incomplete information ▪ NULL is not a value, but rather a state saying „I don‘t know“ ▪ NULL can stand for any value in the domain and thus has special semantics worth a whole lecture „Strange“ semantics of NULL (Question 4) Fill out the three value logic tables (in class exercise, I will ask some of you now)… and true unknown false true true unknown false unknown unknown unknown false false false false false or true unknown false true true true true unknown true unknown unknown false true unknown false not true false unknown unknown false true ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? „Strange“ semantics of NULL (Solution) Fill out the three value logic tables (in class exercise, I will ask some of you now)… and true unknown false true true unknown false unknown unknown unknown false false false false false or true unknown false true true true true unknown true unknown unknown false true unknown false not true false unknown unknown false true Question 4 Table from before… Best solved by intuition: ▪ „IDK“ may or may not be smaller then 10 ▪ IDK + something is still unknown ▪ NULL = NULL is unknown: „=„ compares values, but NULL is not a value: Thus need to check NULL IS NULL. → learn this as fact for the exam NULL in Aggregations ▪ Usually NULLs are ignore in agregate functions like AVG, MAX,… ▪ GROUP BY adds a seperate entry for NULLs ▪ Edge cases like COUNT(*/a) exist! ▪ What‘s the difference between COUNT(a) and COUNT(*)? a NULL NULL NULL NULL a COUNT(*) does not ignore NULL (COUNT(*) counts tuples…) COUNT(a) counts attributes (ignores NULLs) Thus: COUNT(a) → 1 COUNT(*) → 5 Question 5 AVG(b) → (1+3)/2 = 2. NULL is ignored. Since „a“ only has two groups, namely 1 and 3, We can also ignore the tuple with NULL (but be careful here!) ? ? Attention: another „edge case“ (Question 7) NULL in aggregations? If there‘s nothing, we get a NULL output (Question 7, last part): bytes_received NULL NULL NULL NULL NULL 30 30 30 10 10 Now assume that: ▪ there are 5 tuples, where bytes_received IS NULL. ▪ there are 10 tuples in the app table in total ▪ exactly 2 tuples in the app table have bytes_received = 10 ▪ exactly 3 tuples in the app table have bytes_received = 30 ▪ (all other attributes are NULL if possible) What does the following query return? SELECT AVG(bytes_received) FROM app GROUP BY bytes_received. … … Another „edge case“ bytes_received NULL NULL NULL NULL NULL 30 30 30 10 10 AVG(bytes_received) NULL 30 10 SELECT AVG(bytes_received) FROM app GROUP BY bytes_received We ONLY have NULL values for the NULL group. Thus the average yields „unknown“ (10+10)/2 = 10 (30+30+30)/3 = 30 Question 6 – Constraints CREATE TABLE device ( device_id SERIAL, device_name VARCHAR(40) ); CREATE TABLE device_nic ( mac_addr VARCHAR(17), device_id INT, PRIMARY KEY (mac_addr, device_id) ); Can be NULL. There‘s no NOT NULL constraint – neither by a primary key nor directly. Part of primary key. Thus: cannot be NULL Cannot be NULL. SERIAL implicitly adds a NOT NULL constraint. Which of the attributes can be NULL? Views ▪ Views are a way to give queries a name („alias“). ▪ Views are logical constructs: For each time you use the name of the view, think of executing the query again. ▪ More formally: a view never gets materialized: Results of the query are not saved or cached, but can be thought of being re-computed every time the view gets accessed ▪ In contrast, a table „saves“ the content of a query → See Question 9 Question 9 Assume the following queries have been executed on the schema of the networking application. nic is initially empty. 1. CREATE TABLE loc1 AS SELECT * FROM nic; 2. CREATE VIEW loc2 AS SELECT * FROM nic; 3. INSERT INTO loc1 (mac_addr,location) VALUES ('79:0e:48:57:c5:e6',1); 4. INSERT INTO loc2 (mac_addr,location) VALUES ('6b:d0:46:cb:22:ca',2); Now nic only contains ('6b:d0:46:cb:22:ca',2) mac_addr location nic mac_addr location loc1 copy mac_addr location nic mac_addr location alias Many struggled here!Question 9 mac_addr location nic mac_addr location loc1 copy mac_addr location mac_addr location 79:0e:48:57:c5:e6 1 loc1 mac_addr location nic mac_addr location alias INSERT INTO loc1 (mac_addr,location) VALUES ('79:0e:48:57:c5:e6',1); While loc1 is a copy, loc2 is just a view. Thus: inserting into loc1 inserts into loc1 only. Question 9 → True: Now nic only contains ('6b:d0:46:cb:22:ca',2) mac_addr location 79:0e:48:57:c5:e6 1 loc1 mac_addr location nic mac_addr location alias INSERT INTO loc2 (mac_addr,location) VALUES ('6b:d0:46:cb:22:ca',2); mac_addr location 6b:d0:46:cb:22:ca 2 nic mac_addr location 6b:d0:46:cb:22:ca 2 Loc1 got materialized. There is „no“ connection to nic anymore loc2 as view is not materialized, thus the base relation gets ('6b:d0:46:cb:22:ca‘,2). Some more facts about views (Question 8)Question 8 A view in SQL is updatable iff all of the following hold: • The view involves only ONE base relation • The view involves the key of that base relation • The view does NOT involve aggregates, group by or duplicate elimination ▪ Every view in SQL is updatable: False ▪ Already sounds somewhat odd that „every“ view in SQL is updatable („every“ is often wrong). ▪ Indeed: There are rules which make a view updatable (you‘ve seen them in last weeks exercise probably). There are indeed non updatable views in SQL… ▪ An updatable view tries to maintain a one-to-one mapping between view and base relation, thus recall the rules: Question 8 Updatable views in SQL are a subset of all updatable views: True Idea: Find a view which is updatable (in theory), but not updatable in SQL. → We best find an easy way to get rid of updatability! → Go to rules and check what to break (but still make it possible to argue that the view should be updatable) A view in SQL is updatable iff all of the following hold: • The view involves only ONE base relation • The view involves the key of that base relation • The view does NOT involve aggregates, group by or duplicate elimination There may exist other examples, but I thought group by is easiest Question 8 CREATE VIEW updatable AS SELECT * FROM ipv4addr CREATE VIEW not_updatable AS SELECT * FROM ipv4addr GROUP BY ipv4; Idea: Grouping by (primary) key is „useless“, but breaks updatability in SQL… (Aside: we already „group by“ primary key by default, since keys are unique) UPDATE updatable SET ipv4 = '10.0.0.1_' where ipv4 = '10.0.0.1’; succeeds UPDATE non_updatable SET ipv4 = '10.0.0.1_' where ipv4 = '10.0.0.1’; yields an error stating that non_updatable cannot be updated, since views which contain GROUP BY cannot be updated automatically. Question 8 CREATE VIEW allips AS ( SELECT ipv4 AS ip, next_hop FROM ipv4addr UNION SELECT ipv6 AS ip, next_hop FROM ipv6addr ) is updatable? No: There‘s more than one base ralation. This violates updatability rules Question 8 A view is a logical construct and does not get materialized: True. We‘ve seen that already in Question 9 For your benefit („at home“): A view is logical and does not get materialized. This means that assuming you do a change to a view, the base table gets changed too as no data is copied. In contrast, if you copy and then change a seperate table, the changes only occur to that table: Assume ipv4addr only contains the following tuple: (10.0.0.1, 10.2.2.1) If you run \"UPDATE updatable SET ipv4 = '10.0.0.1_' where ipv4 = '10.0.0.1'; \" on the updatable view from above, ipv4addr will contain (10.0.0.1_,10.2.2.1) as the update was applied through the view on the table. Back to SQL ▪ You‘ve seen a lot of SQL queries till now. In the past, there was a focus on reading huge SQL queries. This exercise focusses a bit more on writing them. ▪ Be prepared to jump through multiple tables for joins and come up with a solution quickly. ▪ Be prepared to be able to detect equivalent SQL queries ▪ Be prepared to see edge cases. ▪ There have been multiple different exercise types in the exam. Be sure to solve them also under time preasure. SQL can help you with „real world“ problems …and to overengineer CN projects Being able to use a DBMS is very valuable: Allows you to much more efficiently handle data – and may pop up in some thesis. Past exams didn‘t focus that much on using PostgresSQL, but it seems to become more important. Check Question 10,..., 15 too. DBMS Webserver Internet Social media site Y DMDB CN Setting: New: Database Question 10 CREATE DATABASE y; -- creates a new database called y. CREATE TABLE users ( user_id SERIAL PRIMARY KEY, -- it makes sense to auto increment the key (and have an id as key in the first place) password_hash VARCHAR(255), -- never store a password in plain text. Always use a hash. (usually string type. length depends on hash) email TEXT, creation_dt TIMESTAMP, -- we‘re asked to allow date and time login_date DATE, -- we‘re asked to only allow a date permissions INT ); Question 15 – Application SQL queries and playing to be a DB Schema: Comments(comment_id, comment_text, commenter_id, number_of_spam_reports, comment_time) note that comment_id is SERIAL. Users(user_id, password_hash, email, creation_dt, login_date, permissions, created_by). Extra key: email. Views: admins(user_id, email, creation_dt, created_by) non_admins(user_id, email, creation_dt, created_by, permissions) Application encodes: • Admins have permissions = 255 • permissions = 0 → user cannot login Question 15 – Application SQL queries and playing to be a DB SELECT non_admins.email, non_admins.user_id, comments.comment_text FROM non_admins LEFT JOIN comments ON non_admins.user_id = comments.commenter_id WHERE non_admins.permissions = 0; Write a SQL query consisting of all user emails and user_id who cannot login. If they have a comment your query should return all comments of the user with its user e-mail, else the still output the user, but with the comment field containing NULL. Sounds like a join, but slightly more involved. → SQL also supports LEFT and RIGHT JOINS → Use a LEFT JOIN! We must join on non_admins (or users), since admins never have permissions = 0 (Recall that they always have permissions = 255) Question 15 – Application SQL queries and playing to be a DB The application side checks if a user is allowed to log in, but still needs data from the database. The password_hash match is handled via the application, but permission management is done via SQL. Write a SQL query which retrieves the password hash if the user can log in given a sanitized (= is a syntactically valid E-Mail and not some malicious SQL code) email in %1. You can assume that %1 is replaced with the correct email in your SQL query. SELECT password_hash FROM users WHERE email='%1' AND permissions <> 0; Do not use someting in terms of email LIKE ' %@% ‘! → This would give back the password_hash of EVERY user who can login and has a somewhat valid email with an @ in it. → You want to get an exact match. Thus an “=” is needed. Sanitization is done within the application! Question 15 – Application SQL queries and playing to be a DB SELECT password_hash FROM users WHERE email='%1' AND permissions <> 0; %1 Sanitized?! What would happen if %1 wasn’t sanitized and contained: “noad@sth.local' OR TRUE; --”? → Query is now: SELECT password_hash FROM users WHERE email=‘noad@sth.local' OR TRUE; --' AND permissions <> 0; → SQL injection (“little bobby tables”). Even if the user had permissions = 0, they could log in (or do other bad stuff). → Sanitization is crucial for security (but probably not covered in this lecture) https://xkcd.com/327 Question 15 – Application SQL queries and playing to be a DB comment_id comment_text commenter_id Number_of_spam_reports comment_time 1 GET (5) FREE QUERY'Z AT totallylegitquerzfee.local/legit 2 200 2000-01-02 00:03 2 Cute dog! 1 1 2019-09-08 17:22 3 N0W oN SALE: FrEE SQL queryz: totallegzit.local/legit 3 49 2024-04-03 00:03 4 GET fr11 SQL queri now at lezit.local/legit 3 2 2024-04-03 00:04 user_id password_hash email creation_dt login_date permissions created_by 0 ddaf… me@user.local 2022-01-01 08:01 2024-02-01 255 0 1 8630… someone@me.local 2000-01-02 00:04 2020-01-07 1 1 2 0316… hacker@hackercorp.l ocal 1999-04-02 00:04 2024-04-01 255 0 3 2528… your@user.local 2024-04-02 23:55 2024-04-03 16 3 4 2824… noad@sth.local 2024-04-03 22:22 2024-05-03 0 4 Open the schema/database PDF seperately during exam. Avoid jumping, since this is an unnecessary source of errors. Question 15 – Application SQL queries and playing to be a DB You want to get rid of spam users. Spam users are users, who are not admins and in total have more than 50 spam reports on their comments. Furthermore, they haven't been created by an administrator and have been created less than 3 days ago. First, you get the users e-mail and user_id in question. need to select from non_admins view sum up number_of_spam reports: SUM(number_of_spam_reports) and constrain result with spams.total_number_of_spam_reports > 50 created_by doesn’t have an user id of an admin → created_by NOT IN (SELECT user_id FROM admins) creation_dt > NOW() – INTERVAL ‘3 days’ Question 15 – Application SQL queries and playing to be a DB You want to get rid of spam users. Spam users are users, who are not admins and in total have more than 50 spam reports on their comments. Furthermore, they haven't been created by an administrator and have been created less than 3 days ago. First, you get the users e-mail and user_id in question. This gives e.g.: <spamusers> = SELECT user_id, email FROM non_admins, ( SELECT commenter_id, SUM(number_of_spam_reports) AS total_number_of_spam_reports FROM comments GROUP BY commenter_id ) AS spams WHERE commenter_id = user_id AND spams.total_number_of_spam_reports > 50 AND created_by NOT IN (SELECT user_id FROM admins) AND creation_dt > NOW() – INTERVAL ‘3 days’); Now create a table from it: CREATE TABLE spam_users AS (<spamusers>); Question 15 – Application SQL queries and playing to be a DB comment_id comment_text commenter_id Number_of_spam_reports comment_time 1 GET (5) FREE QUERY'Z AT totallylegitquerzfee.local/legit 2 200 2000-01-02 00:03 2 Cute dog! 1 1 2019-09-08 17:22 3 N0W oN SALE: FrEE SQL queryz: totallegzit.local/legit 3 49 2024-04-03 00:03 4 GET fr11 SQL queri now at lezit.local/legit 3 2 2024-04-03 00:04 user_id password_hash email creation_dt login_date permissions created_by 0 ddaf… me@user.local 2022-01-01 08:01 2024-02-01 255 0 1 8630… someone@me.local 2000-01-02 00:04 2020-01-07 1 1 2 0316… hacker@hackercorp.l ocal 1999-04-02 00:04 2024-04-01 255 0 3 2528… your@user.local 2024-04-02 23:55 2024-04-03 16 3 4 2824… noad@sth.local 2024-04-03 22:22 2024-05-03 0 4 How large is the spam_users table assuming NOW() - INTERVAL '3 days' yields \"2024-04-02 20:00“? Satisfy creation_date > NOW() – INTERVAL ‚3 days‘ Only user 3 has commented, and 49+2 = 51 > 50 spam reports. They haven‘t been created by an admin (created_by userid 3 which has permissions 16, not 255) → 1, only user_id 3. Question 15 – Application SQL queries and playing to be a DB Now you delete the comments as described above with the following query using the table you just created: 1. Described above = Delete all comments from spam_users having more than 5 spam reports. 2. more than 5 spam reports → number_of_spam_reports > 5 3. How to check if a commenter is a spam user? → commenter_id IN (SELECT user_id FROM spam_users). Better don’t type the whole SQL query from above in here… DELETE FROM comments WHERE number_of_spam_reports > 5 AND commenter_id IN (SELECT user_id FROM spam_users); Question 15 – Application SQL queries and playing to be a DB comment_id comment_text commenter_id Number_of_spam_reports comment_time 1 GET (5) FREE QUERY'Z AT totallylegitquerzfee.local/legit 2 200 2000-01-02 00:03 2 Cute dog! 1 1 2019-09-08 17:22 3 N0W oN SALE: FrEE SQL queryz: totallegzit.local/legit 3 49 2024-04-03 00:03 4 GET fr11 SQL queri now at lezit.local/legit 3 2 2024-04-03 00:04 user_id password_hash email creation_dt login_date permissions created_by 0 ddaf… me@user.local 2022-01-01 08:01 2024-02-01 255 0 1 8630… someone@me.local 2000-01-02 00:04 2020-01-07 1 1 2 0316… hacker@hackercorp.l ocal 1999-04-02 00:04 2024-04-01 255 0 3 2528… your@user.local 2024-04-02 23:55 2024-04-03 16 3 4 2824… noad@sth.local 2024-04-03 22:22 2024-05-03 0 4 We know: user_id 3 is spam user. How many comments have been deleted? Only comment_id 3 comes from a spam user and has more than 5 spam reports → 1 comment, namely comment_id 3 is deleted Question 15 – Application SQL queries and playing to be a DB Now you delete all spam users: 1. Delete all → DELETE FROM users 2. Need to get all spam users → SELECT user_id FROM spam_users. DELETE FROM users WHERE user_id IN (SELECT user_id FROM spam_users); In general, after Query 5, is the content of spam_users the same if we replaced TABLE with VIEW? No. We deleted all spam_users after query 5. Therefore, the base relation (users) won‘t have any spam users anymore → if we had a view, we wouldn‘t have any spam users anymore, but in the table we do have – since we saved the spam users at the start. VIEW is not materialized, but TABLE is. SQL and Relational Algebra Attention: SQL (usually) uses Bag semantics, but RA set semantics How do we get that this follows bag semantics? → UNION ALL Quiz Feel free to self study the questions here: https://quizizz.com/embed/quiz/65e6e8bd0eb9fe568e7f6e0cIt might make sense to open the exercises now (at latest)! Question 1, 2 – Reading bigger SQL queries Question 1: Consider the following relations, from the database of an online streaming service. Primary keys are underlined Artist (artistId, artistName, artistCountry) Releases (releaseId, releaseName, releaseDate, genreName) ReleasedBy (artistId, releaseId) Track (releaseId, trackNumber, trackName, genreName) Genre (genreName, parentGenreName) Users (userId, userName) UserLikesArtist (userId, artistId) UserLikesTrack (userId, releaseId, trackNumber) We assume a SQL database with these relations, where all attributes are specified to be NOT NULL. Consider the following queries. Now multiple (larger) queries follow… → Try to roughly make sense of the schema first. Then go through the questions. (You could also go through the queries first, but that takes time) Question 1 Artist (artistId, artistName, artistCountry) Releases (releaseId, releaseName, releaseDate, genreName) ReleasedBy (artistId, releaseId) Track (releaseId, trackNumber, trackName, genreName) Genre (genreName, parentGenreName) Users (userId, userName) UserLikesArtist (userId, artistId) UserLikesTrack (userId, releaseId, trackNumber) We are looking for the most unknown artists. Return all artists that are liked by less than 5 users, sorted by the number of fans in increasing order. Increasing order → ORDER BY <something> [ASC] → ASC may not be there, as by default, PostgresSQL orders by ASC. Question 1 Artist (artistId, artistName, artistCountry) Releases (releaseId, releaseName, releaseDate, genreName) ReleasedBy (artistId, releaseId) Track (releaseId, trackNumber, trackName, genreName) Genre (genreName, parentGenreName) Users (userId, userName) UserLikesArtist (userId, artistId) UserLikesTrack (userId, releaseId, trackNumber)Increasing order → ORDER BY <something> [ASC] → ASC may not be there, as by default, PostgresSQL orders by ASC. → There are two queries (Q4, Q6) which could fit, as it orders by column2 ASC; → Need to check if it actually does what the question asks Q4: SELECT column1, column2 FROM ( SELECT a.artistId AS column1, COUNT(*) AS column2 FROM Artist a, UserLikesArtist ua, Users u WHERE a.artistId = ua.artistId AND u.userId = ua.userId GROUP BY a.artistId ) AS sub1 UNION SELECT column1, column2 FROM ( SELECT a.artistId as column1, 0 as column2 FROM Artist a WHERE a.artistId NOT IN (SELECT artistID FROMUserLikesArtist) ) AS sub2 WHERE column2 < 5 ORDER BY column2 ASC; Q6: SELECT column1, column2 FROM ( SELECT a.artistId AS column1, COUNT(*) AS column2 FROM Artist a, UserLikesArtist ua, Users u WHERE a.artistId = ua.artistId AND u.userId = ua.userId GROUP BY a.artistId ) AS sub1 UNION SELECT column1, column2 FROM ( SELECT a.artistId as column1, 0 as column2 FROM Artist a WHERE a.artistId NOT IN (SELECT artistID FROM UserLikesArtist ul, Track t WHERE ul.artistId = t.artistId) ) AS sub2 WHERE column2 < 5 ORDER BY column2 ASC; Question 1 Q4: SELECT column1, column2 FROM ( SELECT a.artistId AS column1, COUNT(*) AS column2 FROM Artist a, UserLikesArtist ua, Users u WHERE a.artistId = ua.artistId AND u.userId = ua.userId GROUP BY a.artistId ) AS sub1 UNION SELECT column1, column2 FROM ( SELECT a.artistId as column1, 0 as column2 FROM Artist a WHERE a.artistId NOT IN (SELECT artistID FROM UserLikesArtist) ) AS sub2 WHERE column2 < 5 ORDER BY column2 ASC; Query is a union of two things Selects all artistIDs (renamed as column 1), and counts the number of users (as column2) who like this artist. However: a.artistID=ua.artistId AND u.userId=ua.userId is only true, if there‘s actually a user liking this artist Selects all artistIds, which aren‘t liked by any user (NOT IN subquery ensures that) Only show artists which are liked by less than 5 users Question 1 Q6: SELECT column1, column2 FROM ( SELECT a.artistId AS column1, COUNT(*) AS column2 FROM Artist a, UserLikesArtist ua, Users u WHERE a.artistId = ua.artistId AND u.userId = ua.userId GROUP BY a.artistId ) AS sub1 UNION SELECT column1, column2 FROM ( SELECT a.artistId as column1, 0 as column2 FROM Artist a WHERE a.artistId NOT IN (SELECT artistID FROM UserLikesArtist ul, Track t WHERE ul.artistId = t.artistId) ) AS sub2 WHERE column2 < 5 ORDER BY column2 ASC; Query is a union of two things Selects all artistIDs (renamed as column 1), and counts the number of users (as column2) who like this artist. However: a.artistID=ua.artistId AND u.userId=ua.userId is only true, if there‘s actually a user liking this artist Selection of artists who are not liked by any user is not correct: There‘s no artistId in Tracks! Schema is tricky…Question 1 – Another option (from the mentioned exam) SELECT * FROM (SELECT ua.artistId, COUNT(*) as likedBy FROM Artist a, UserLikesArtist ua, Users u, Track t WHERE a.artistId = ua.artistId AND u.userId = ua.userId GROUP BY ua.artistId ORDER BY count(*) ASC) as tmp WHERE tmp.likedBy < 5 We are looking for the most unknown artists. Return all artists that are liked by less than 5 users, sorted by the number of fans in increasing order. Unnecessary relation which is not constrained by any equality „=“ multiplies to the final relation! Also: Doesn‘t include artists with 0 fans. Increasing order is sensible. Constraining on likedBy < 5 Question 2 Artist (artistId, artistName, artistCountry) Releases (releaseId, releaseName, releaseDate, genreName) ReleasedBy (artistId, releaseId) Track (releaseId, trackNumber, trackName, genreName) Genre (genreName, parentGenreName) Users (userId, userName) UserLikesArtist (userId, artistId) UserLikesTrack (userId, releaseId, trackNumber) We are looking for Artists having tracks ordered decreasingly by their number of tracks. We sketch: 1. We must have an ORDER BY DESC 2. The relation must include Artists and Tracks at least (by intuition). However, from the schema we must also include ReleasedBy and Releases to link artists and releases and tracks and releases 3. Since we order by the number of tracks, we most likely need an aggregate function COUNT(…) and a GROUP BY. 4. Since we’re looking at artists (not just one), there cannot be a LIMIT. 5. Thus: Queries 1 and 3 seem to be valid. Question 2 Q1: SELECT a.artistId, COUNT(*) FROM Artist a, ReleasedBy rb, Releases r, Track t WHERE a.artistId = rb.artistId AND rb.releaseId = r.releaseId AND r.releaseId = t.releaseId GROUP BY a.artistId ORDER BY COUNT(*) DESC; Join is sensible Grouping and ordering is sensible Artist (artistId, artistName, artistCountry) Releases (releaseId, releaseName, releaseDate, genreName) ReleasedBy (artistId, releaseId) Track (releaseId, trackNumber, trackName, genreName) Genre (genreName, parentGenreName) Users (userId, userName) UserLikesArtist (userId, artistId) UserLikesTrack (userId, releaseId, trackNumber) Relation and attribute selection is sensible Correct! – Probably the way I would have written the query myself Question 2 – Another option? Q3: SELECT a.artistId, COUNT(t.trackName) FROM Artist a, ReleasedBy rb, Releases r, Track t WHERE a.artistId = rb.artistId AND rb.releaseId = r.releaseId AND r.releaseId = t.releaseId GROUP BY a.artistId ORDER BY COUNT(t.trackName) DESC; Artist (artistId, artistName, artistCountry) Releases (releaseId, releaseName, releaseDate, genreName) ReleasedBy (artistId, releaseId) Track (releaseId, trackNumber, trackName, genreName) Genre (genreName, parentGenreName) Users (userId, userName) UserLikesArtist (userId, artistId) UserLikesTrack (userId, releaseId, trackNumber) Q1: SELECT a.artistId, COUNT(*) FROM Artist a, ReleasedBy rb, Releases r, Track t WHERE a.artistId = rb.artistId AND rb.releaseId = r.releaseId AND r.releaseId = t.releaseId GROUP BY a.artistId ORDER BY COUNT(*) DESC; Almost identical. Just COUNT(*) replaced with COUNT(t.trackName). We know that in general COUNT(a) != COUNT(*). Is that a problem here? → NO. Exercise specified that all attributes are NOT NULL. – otherwise Q3 wouldn‘t count NULL values. → Q3 is also correct Question 3 – Equivalent queries Note that any entry (except for the primary key or specified) can be NULL. Some of the later queries are equivalent, i.e., they solve the same task and always return identical results. For each of the queries, drag and drop all equivalent query numbers next to the corresponding Query. If none of the other queries is equivalent to a particular query Qi, choose “None”. You may assume that WITH isn AS (SELECT ipv4 as ip FROM ipv4addr INTERSECT SELECT ipv6 as ip FROM ipv6addr) SELECT COUNT(*) FROM isn; returns 0. Question 3 – Equivalent queries WITH isn AS (SELECT ipv4 as ip FROM ipv4addr INTERSECT SELECT ipv6 as ip FROM ipv6addr) SELECT COUNT(*) FROM isn; What does that query express? → SELECT COUNT(*) FROM isn; counts the number of tuples returned by the named query isn. → Need to check isn → Subquery calculates intersection between ipv4 and ipv6 addresses → Fancy way to say that the ipv4 and ipv6 values are also distinct (don‘t share data) between ipv6addr and ipv4addr. Question 3 Here it might make sense to read throught the queries directly and cluster them. Q1: SELECT DISTINCT location FROM nic; Q7: SELECT location FROM nic WHERE location <2 OR location >= 2; Q8: SELECT location FROM nic; They all select the location attribute. Thus: check schema if there are any constraints on location: CREATE TABLE nic ( mac_addr VARCHAR(17) PRIMARY KEY, location INT ); NULL is neither < nor >= 2, since NULL is unknown. This filters NULL values! There’s no constraint on location. Thus, it can be NULL, we can have duplicates. → They all aren’t equivalent → Select None Question 3 Q2: WITH interm AS (SELECT ipv6 AS ip from ipv6addr UNION ALL SELECT ipv4 AS ip from ipv4addr) SELECT DISTINCT proto FROM flow INNER JOIN interm ON ip = source_ip; Q3: SELECT DISTINCT proto FROM flow, ipv4addr, ipv6addr WHERE flow.source_ip = ipv4addr.ipv4 OR flow.source_ip = ipv6addr.ipv6; Q4: SELECT DISTINCT proto FROM flow, ipv4addr, ipv6addr WHERE flow.dest_ip = ipv4addr.ipv4 OR flow.dest_ip = ipv6addr.ipv6; Q3 and Q4 join on different attributes: Q3 joins on source_ip while Q4 joins on dest_ip → cannot be equivalent Q2 and Q3 need to be checked for equivalence. • INNER JOIN interm ON ip = source_ip means the same as flow.source_ip = ipv4addr.ipv4 OR flow.source_ip = ipv6addr.ipv6 • UNION ALL = UNION, since the IPs of both relations are distinct. • A union B is defined by including all items of A and B. Thus: interm selects all available ipv4 and ipv6 addresses. → Q2 and Q3 are equivalent. → Best to intuitively think about that Question 3 Q5, Q6, Q9 look similar… Q5: WITH interm AS ( SELECT source_ip, dest_ip, source_port, dest_port, proto, CASE WHEN length(source_ip) < 15 AND length(dest_ip) < 15 THEN 'probably ipv4' WHEN length(source_ip) > 15 AND length(dest_ip) > 15 AND (NOT flow_label IS NULL) THEN 'probably ipv6' ELSE 'check src and dest ip manually' END AS ip_check FROM flow GROUP BY source_ip, dest_ip, source_port, dest_port, proto ) SELECT ip_check, COUNT(*) AS num_checks FROM interm GROUP BY ip_check; Q6 is almost the same as Q5, But Q6 uses „>“ instead of < → they aren‘t equivalent. Q6 > Question 3 Q9: WITH sq AS ( SELECT source_ip, dest_ip, source_port, dest_port, proto, CASE WHEN length(source_ip) < 15 AND length(dest_ip) < 15 THEN 'probably ipv4' WHEN length(source_ip) > 15 AND length(dest_ip) > 15 AND (NOT flow_label IS NULL) THEN 'probably ipv6' ELSE 'check src and dest ip manually' END AS ip_check FROM flow ) SELECT ip_check, COUNT(*) AS num_checks FROM sq GROUP BY ip_check; Q5: WITH interm AS ( SELECT source_ip, dest_ip, source_port, dest_port, proto, CASE WHEN length(source_ip) < 15 AND length(dest_ip) < 15 THEN 'probably ipv4' WHEN length(source_ip) > 15 AND length(dest_ip) > 15 AND (NOT flow_label IS NULL) THEN 'probably ipv6' ELSE 'check src and dest ip manually' END AS ip_check FROM flow GROUP BY source_ip, dest_ip, source_port, dest_port, proto ) SELECT ip_check, COUNT(*) AS num_checks FROM interm GROUP BY ip_check; Groups by primary key → Not needed. Q5 and Q9 are equivalent Question 6 – NULLs again Assume device contains 20 tuples and device_nic contains 20 tuples, then • SELECT COUNT(*) FROM (SELECT device_name FROM device) as dev_count can only output 20 tuples. • Even though device_name can be NULL, COUNT(*) counts every tuple. Since there are 20 Tuples, we must output 20 and can never output 15. Also 21 is impossible, since there are only 20 tuples in the first place. • SELECT COUNT(device_name) FROM (SELECT device_name FROM device) AS dev_count can output any value from 0 to 20 • COUNT(device_name) in contrast to COUNT(*) ignores NULL values. • SELECT COUNT(device_id) FROM (SELECT device_id FROM device_nic) AS dev_id_count must return the same value as SELECT COUNT(*) FROM (SELECT device_id FROM device_nic) AS dev_id_count: • device_id in the device_nic relation is part of the primay key and cannot be NULL. Thus COUNT(*) and COUNT(device_id) must return the same result. CREATE TABLE device ( device_id SERIAL, device_name VARCHAR(40) ); CREATE TABLE device_nic ( mac_addr VARCHAR(17), device_id INT, PRIMARY KEY (mac_addr, device_id) ); Question 7, 10: View/Table creation Q7: Now we add another table which links a (IPv6) flow_label to an application. Each application has an ID (app_id) which fits into an integer and stores the number of bytes received and sent by a flow as INT. Complete the following code to create this table: Creating a view/table works by using the CREATE keyword: CREATE [VIEW/TABLE] [view_name/table_name] AS ([SQL]) Complete the following SQL code to create a view containing only users who are admins: CREATE VIEW admins AS ( SELECT user_id, password_hash, email, creation_dt, created_by FROM users WHERE permissions = 255 ); CREATE TABLE app ( flow_label INT, app_id INT, bytes_received INT, bytes_sent INT, PRIMARY KEY (flow_label, app_id) ); Question 11 – Bulk load Manual inserts are tedious and slow. • There‘s overhead of parsing the huge query and checking (key) constraints for each query • Using bulk load is much more convinient • Concept of bulk load should be known. Syntax isn‘t too difficult, but sometimes clumsy and may be OS dependent. Still know the concept in the exam. Importing users.csv into the users table works as follows: COPY users FROM '/tmp/users.csv' WITH FORMAT csv; Knowing about bulk load helps in practice. Question 12 – SQL as Data definition language (DDL) You may forget an attribute from time to time – or add constraints to an existing table In order to add the column created_by, execute: ALTER TABLE users ADD COLUMN created_by INT; “For now, he checks that the user ID he gives to you will be in the users table and ensures to you that it will remain consistent. In future, you plan to get rid of this as you don't trust in his programming skills too much. You will then use foreign key constraints (which you may not have covered in the lecture yet).” → The database itself can check validity of the content in more advanced ways. But for now, it’s the applications’ turn! In future you could use e.g.: ALTER TABLE users ADD CONSTRAINT fk_created_by_const FOREIGN KEY (created_by) REFERENCES users(user_id); Question 7,13 – More advanced SQL reading and writing Now we add another table which links a (IPv6) flow_label to an application. Each application has an ID (app_id) which fits into an integer and stores the number of bytes received and sent by a flow as INT. The app relation now looks like this: app(flow_label, app_id, bytes_received, bytes_sent) while every attribute is an int. We are now interested in getting the three highest flow_label, app_id pairs which have the most bytes_received and sent. Complete the following query. Choose --nothing, if the entry does not exist: 1. Three highest flow_label, app_id pairs → need a LIMIT 3. 2. Since we’re interested in the highest values → need an ORDER BY … DESC. 3. Need to „somehow“ calculate the number of bytes_received and sent → sum it up Question 7,13 – More advanced SQL reading and writing 1. Three highest flow label, app_ids → need a LIMIT 3. 2. Since we’re interested in the highest values → need an ORDER BY … DESC. 3. Need to „somehow“ calculate the number of bytes_received and sent → sum it up This leads to this rather bulky nested query: SELECT flow_label, app_id FROM (SELECT flow_label, app_id, bytes_received + bytes_sent AS bytes_total FROM app GROUP BY flow_label, app_id, bytes_total ORDER BY bytes_total DESC LIMIT 3) AS flow_in_question Postgres GROUP BY SELECT flow_label, app_id FROM (SELECT flow_label, app_id, bytes_received + bytes_sent AS bytes_total FROM app GROUP BY flow_label, app_id, bytes_total ORDER BY bytes_total DESC LIMIT 3) AS flow_in_question Need to mention all attributes: In general, you need to group by everything mentioned in the selection, unless you have an aggregate function: there can be more than one value in a group and the DBMS would not know what to show. Postgres gives an error, but other DBMS (MySQL) might not… Question 13 You now want to get rid of inactive or invalid users. Users are inactive iff the last login date was longer than ten years ago. Users are invalid iff the password entry is null or the password is empty. However, you cannot remove users with permission 255, since they are admins. Which of the following queries satisfies this definition? • DELETE FROM users WHERE (((login_date < NOW() - INTERVAL '10 years') AND password_hash IS NULL AND password_hash = '') OR permissions <> 255); • False. password_hash can never be NULL and ‘’ (empty) at the same time. Thus, the first part of the or is unsatisfiable. Permissions <> 255 targets every non admin user resulting in deleting every non admin user… • DELETE FROM users WHERE (((login_date < NOW() - 10) OR password_hash IS NULL OR password_hash = '') AND permissions <> 255); • False. This is invalid SQL due to the type mismatch: NOW() is a timestamp, but 10 an int, meaning it fails to execute Question 13 You now want to get rid of inactive or invalid users. Users are inactive iff the last login date was longer than ten years ago. Users are invalid iff the password entry is null or the password is empty. However, you cannot remove users with permission 255, since they are admins. Which of the following queries satisfies this definition? • DELETE FROM users WHERE (((login_date < NOW() - INTERVAL '10 years') OR password_hash IS NULL OR password_hash = '') OR permissions <> 255); • Gets closer, but still wrong. This handles admins wrongly. Admins where the left hand side of the OR holds will still get deleted. We want an AND instead of an OR. Question 13 You now want to get rid of inactive or invalid users. Users are inactive iff the last login date was longer than ten years ago. Users are invalid iff the password entry is null or the password is empty. However, you cannot remove users with permission 255, since they are admins. Which of the following queries satisfies this definition? • DELETE FROM users WHERE (((login_date < NOW() - INTERVAL '10 years') OR password_hash IS NULL OR password_hash = '') AND permissions <> 255); • Correct! • First part evaluates to true if login_date was more then “NOW() - INTERVAL '10 years‘“ = 10 years ago or the password_hash is NULL/empty. • Second part evaluates to true, if the person is not an admin (meaning permissions <> 255) Question 13 • Recall: DELETE FROM users WHERE (((login_date < NOW() - INTERVAL '10 years') OR password_hash IS NULL OR password_hash = '') AND permissions <> 255); is correct. If you’re “lazy” and like logic, you can just use double negation and de morgan to derive that … • DELETE FROM users WHERE NOT (((login_date >= NOW() - INTERVAL '10 years') AND password_hash IS NOT NULL AND password_hash <> '') OR permissions = 255); • Is also correct. • Otherwise, you can think of which users shouldn’t be deleted: • Admin? → permission = 255 cannot be deleted • Active and valid? → (login_date >= NOW() – INTERVAL ‘10 years’) AND <valid> • Valid user is not invalid. Invalid user has password_hash IS NULL OR password_hash = ‘’ → valid user has neither a NULL nor an empty password: password_hash IS NOT NULL AND password_hash <> ‘’ Question 14 – Why views? You now create two views. One only containing users who are admins, another one containing only users who are not admins. Tick the following reason(s) why this may be beneficial: Both: Privacy and Usability are valid reasons. Privacy: Not showing all attributes e.g. hiding the permissions doesn’t give users a way to access those attributes while still being able to interact with the base relation. Usability: Having a view for admins and non admins can facilitate query writing. In this case, you can omit checking for permissions in every query. Question 16 - Exam 2024 Pair the SQL queries with their matching query descriptions. SELECT s.Name FROM ( SELECT s.SupplierID, s.SupplierName AS Name, AVG (p.Price) AS A FROM Suppliers s INNER JOIN Products p ON s.SupplierID = p.SupplierID GROUP BY s.SupplierID ) AS s INNER JOIN ( SELECT AVG (od.PriceAtTimeOfPurchase) AS B FROM OrderDetails od ) o ON s.A > o.B ; G) Finds all suppliers that produce products whose average price is larger than the average price of the non-unique products in all the orders. Question 16 - Exam 2024 WITH a AS ( SELECT s.SupplierID, AVG (p.Price) AS A FROM Suppliers s JOIN Products p ON s.SupplierID = p.SupplierID GROUP BY s.SupplierID ) SELECT o.OrderID, o.TotalAmount FROM Orders AS o CROSS JOIN ( SELECT SUM(A) AS B FROM a ) AS b WHERE o.TotalAmount > b.B ; B) Finds all orders where the total order amount is greater than the sum of the average product price of each supplier. Question 16 - Exam 2024 SELECT o.OrderID, o.TotalAmount FROM Orders o JOIN ( SELECT od.OrderID, MAX(p.Price) AS A FROM OrderDetails od JOIN Products p ON od.ProductID = p.ProductID GROUP BY od.OrderID ) a ON o.OrderID = a.OrderID CROSS JOIN ( SELECT AVG(Price) AS B FROM Products ) b WHERE a.A > b.B; H) Finds all orders that have at least one product whose price is greater than the average product prices. Question 16 - Exam 2024 WITH a AS ( SELECT s.SupplierID, AVG(p.Price) AS A FROM Suppliers s JOIN Products p ON s.SupplierID = p.SupplierID GROUP BY s.SupplierID ) SELECT o.OrderID, o.TotalAmount FROM Orders AS o CROSS JOIN ( SELECT SUM(A) AS B FROM a ) AS b WHERE o.TotalAmount > b.B; D) Finds all orders that have at least one product that is greater than the average of the average per supplier product prices. Question 17 - Exam 2024 Query: Retrieve all unique customers who have made at least one order in the last two weeks containing at least one product from the top 10 most sold products of all time. WITH Temp AS ( SELECT ProductID FROM ( SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM OrderDetails WHERE OrderID IN ( SELECT OrderID FROM Orders WHERE OrderDate >= CURRENT_DATE - INTERVAL '14 days' ) GROUP BY ProductID ORDER BY TotalQuantity DESC LIMIT 10 ) AS top_products ) SELECT DISTINCT c.CustomerID, c.FirstName, c.LastName FROM Customers c JOIN Orders o ON c.CustomerID = o.CustomerID JOIN OrderDetails od ON o.OrderID = od.OrderID WHERE od.ProductID IN (SELECT ProductID FROM Temp); C) Does NOT match the description: the query retrieves the unique customers that have at least one order that contains a top 10 most sold product over the last two weeks. Question 17 - Exam 2024 Query: Retrieve all unique customers who have made at least one order in the last two weeks containing at least one product from the top 10 most sold products of all time. WITH Temp1 AS ( SELECT ProductID FROM ( SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM OrderDetails GROUP BY ProductID ORDER BY TotalQuantity ASC LIMIT 10 ) AS top_products ), Temp2 AS ( SELECT DISTINCT c.CustomerID FROM Customers c JOIN Orders o ON c.CustomerID = o.CustomerID WHERE o.OrderDate >= CURRENT_DATE - INTERVAL '14 days' ) SELECT DISTINCT c.CustomerID, c.FirstName, c.LastName FROM Customers c JOIN Orders o ON c.CustomerID = o.CustomerID JOIN OrderDetails od ON o.OrderID = od.OrderID JOIN Temp1 tp ON od.ProductID = tp.ProductID WHERE c.CustomerID IN (SELECT CustomerID FROM Temp2); e) Does NOT match the description: the query retrieves the unique customers with at least one order in the last two weeks that contains at least one of the top 10 least sold products of all time. Question 17 - Exam 2024 Query: Retrieve all unique customers who have made at least one order in the last two weeks containing at least one product from the top 10 most sold products of all time. WITH Temp1 AS ( SELECT ProductID FROM ( SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM OrderDetails GROUP BY ProductID ORDER BY TotalQuantity DESC LIMIT 10 ) AS top_products ), Temp2 AS ( SELECT DISTINCT o.CustomerID FROM Orders o WHERE o.OrderDate >= CURRENT_DATE - INTERVAL '14 days' AND EXISTS ( SELECT 1 FROM OrderDetails od WHERE od.OrderID = o.OrderID AND od.ProductID IN (SELECT ProductID FROM Temp1) ) ) SELECT c.CustomerID, c.FirstName, c.LastName FROM Customers c WHERE c.CustomerID IN (SELECT CustomerID FROM Temp2); a) Matches the query description. Question 17 - Exam 2024 Query: Retrieve all unique customers who have made at least one order in the last two weeks containing at least one product from the top 10 most sold products of all time. SELECT c.CustomerID, c.FirstName, c.LastName FROM Customers c WHERE c.CustomerID IN ( SELECT o.CustomerID FROM Orders o JOIN OrderDetails od ON o.OrderID = od.OrderID WHERE o.OrderDate >= CURRENT_DATE - INTERVAL '14 days' AND od.ProductID IN ( SELECT ProductID FROM ( SELECT ProductID, SUM(Quantity) AS TotalQuantity FROM OrderDetails GROUP BY ProductID ORDER BY TotalQuantity DESC LIMIT 10 ) AS Temp ) ); a) Matches the query description. Thank you and happy easter!","libVersion":"0.5.0","langs":""}