{"path":"sem2/AuW/VRL/slides/AuW-L16-random-algorithms.pdf","text":"Al gor i thm e n und Wa h r s c h e i n l i c h k e i t A n g e l i ka S t e g e r E m o W e l zl I n st i t u t f ü r T h e o r e t i sch e I n f o r m a t i k Wahrscheinlichkeit Kapitel 2.8 Randomisierte Algorithmen Randomisierte Algorithmen Algorithmus A Eingabe I Ausgabe A(I,R) Zufallszahlengenerator Wir beweisen: (1) Korrektheit: für alle Eingaben I gilt: Pr[A(I,R) ist korrekt] ≥ … (2) Laufzeit: für alle Eingaben I mit Länge |I|=n: [Laufzeit] = O(f(n)) und/oder Pr[Laufzeit ≦ O(f(n))] ≥ … 𝔼 Idealer Weise: W’keit „praktisch“ Eins Anfragen der Form: liefere einen Wert für X, wobei X verteilt ist wie … Annahme: alle Werte, die der Zufallszahlengenerator erzeugt sind unabhängig Las-Vegas und Monte-Carlo Algorithmen Las-Vegas Algorithmen: - geben nie eine falsche Antwort, aber - Laufzeit ist eine Zufallsvariable Monte-Carlo Algorithmen: - Laufzeit immer polynomiell, aber - geben zuweilen eine falsche Antwort Ziel: [Laufzeit] = „polynomiell“ (in Eingabelänge) 𝔼 Ziel: Pr[Antwort falsch] = „winzig“ Las-Vegas Algorithmen Las-Vegas Algorithmen: - geben nie eine falsche Antwort, aber - Laufzeit ist eine Zufallsvariable T - Laufzeit immer polynomiell, aber - zuweilen Antwort „???“ mit: [T] = „polynomiell (in Eingabelänge) “ 𝔼⟹ stoppe Alg nach Schritten 2𝔼[T ] Pr[Antwort „???“] ≤ 1/2 (wg Markov Ungleichung) … wdh 100 Mal ( ) 100 Las-Vegas Algorithmen Las-Vegas Algorithmen: - geben nie eine falsche Antwort, aber - Laufzeit ist eine Zufallsvariable T - Laufzeit immer polynomiell, aber - zuweilen Antwort „???“⟹ while Antwort „???“: repeat mit: Pr[Antwort „???“] = δ poly 𝔼[T] = 1 1 − δ ⋅ (Anzahl Versuche: Geo(1- )) δ Fehlerkorrektur Einseitiger Fehler: Zweiseitiger Fehler: ε -1 ln δ -1 Wiederholungen reduzieren Fehler auf Pr[Antwort falsch] ≦ δ Pr[Antwort falsch] ≦ 1/2-ε Instanzen 4 ε -2 ln δ -1 Wiederholungen reduzieren Fehler Pr[Antwort falsch] ≦ δ ∀ (Antwort: Mehrheit der gesehenen Antworten) Monte-Carlo Algorithmen für Entscheidungsprobleme Pr[Alg antwortet „nein“] = 0 Ja-Instanzen Pr[Alg antwortet „ja“ ] ≦ 1-ε Nein-Instanzen ∀ ∀ (Antwort „nein“: wenn mind. ein Aufruf „nein“ ausgibt, Antwort „ja“: wenn alle Wdh “ja“ ausgeben) Target-Shooting Gegeben: zwei Mengen S ⊆ U Aufgabe: bestimme |S| / |U| Annahmen: - wir können ein Element aus U efﬁzient zufällig gleichverteilt wählen - es gibt eine efﬁzient berechenbare Funktion I S (u):= (1fallsu2S 0sonst Target-Shooting Beweis: Chernoff-Schranke … Primzahltest Kapitel 2.85 Hashing und Zuordnungsverfahren Hashing Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natürliche Zahl ab f : Daten ➝ {0,…,m-1} Hashing - Beispiel Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natürliche Zahl ab Freunde Adressbuch Hashing - Beispiel Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natürliche Zahl ab Freunde Adressbuch Hashing - Beispiel Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natürliche Zahl ab Freunde Adressbuch f : ➝ Hashing - Beispiel Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natürliche Zahl ab f : ➝ Freunde Adressbuch Hashing Idee: eine Hashfunktion bildet (potentiell sehr grosse) Datenmenge auf eine (kleine) natürliche Zahl ab f : Daten ➝ {0,…,m-1} Gewünschte Eigenschaften: - alle Hashwerte sollen „gleich oft“ vorkommen - „geringe“ Wahrscheinlichkeit von Kollisionen - ähnliche Eingaben sollen zu verschieden Ergebnissen führen - f soll efﬁzient berechenbar sein - [in der Kryptographie] f -1 soll nicht efﬁzient berechenbar sein Hashing Anwendungen: - Datenbanken - Prüfsummen - Kryptographie - Algorithmen für grosse Datenmengen Hashing Theorie: In der Analyse von Algorithmen geht man meist davon, dass Hashfunktionen die gegebenen Daten zufällig und unabhängig von einander auf {0,…,m-1} abbilden. Praxis: Man wählt eine Hashfunktion f aus einer vorgegeben Menge von Funktionen (universelle Hashklasse) zufällig. m Körbe n Bälle (balls) zufällig f : Man geht davon aus, dass die Funktion f die in der theoretischen Analyse gemachten Annahmen erfüllt. (deterministisch) Hashing Probleme die es zu lösen gilt: - Konstruktion einer Hashfunktion - Umgang mit Kollisionen (mod m) notwendig: theoretisches Verständnis „was ist überhaupt möglich“ Balls and Bins m Körbe (bins) n Bälle (balls) zufällig X i := Anzahl Bälle im i-ten Korb Frage: Wie gross ist ? max 1in X i","libVersion":"0.3.1","langs":""}