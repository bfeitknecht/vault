{"path":"sem2/PProg/PV/extra/PProg-kahoot.pdf","text":"PProg Final Kahoot FS24 Those are the questions that were used for the final Kahoot. The solutions can be found in the second half of this document. The questions have been created by Benjamin Gruzman, Gamal Hassan, Sarah Kuhn, Raphaël Larisch and Julianne Orel. • On a machine with a single core, multiple processes can run… o concurrently and in parallel o none of the above o concurrently o in parallel • Different processes (not threads) share the same address space. o False o True • Let Thread Ti have ki instructions. How many interleavings are there for n Threads? o ∏ 𝑘𝑖! 𝑛 𝑖=1 o (∑ 𝑘𝑖 𝑛 𝑖=1 )! ∏ 𝑘𝑖! 𝑛 𝑖=1 o ∑ 𝑘𝑖 𝑛𝑛 𝑖=1 o (∑ 𝑘𝑖 𝑛 𝑖=1 !)∏ 𝑘𝑖 𝑛 𝑖=1 • A new thread in Java can be created by calling the _ method. o start() o run() o sprint() o begin() • On which granularity does the JVM schedule threads? o Line of code o Machine code o Block of code (method) o Bytecode • The main thread in Java is… o Non-Daemon o Daemon • A thread is in a synchronized block of an object. What cannot be happening at the same time? o Another thread calls notify on that object without getting an exception. o A synchronized static method of the object’s class can be executed. o A lock on the object’s class can be obtained by another thread. o Another method of that object can be executed. • Which of the following is not a valid state of a Java thread? o Joining o Waiting o Runnable o Terminated • In a pipeline, latency ... o always stays constant o can decrease as instances go through o can increase or decrease as instances go through o can increase as instances go through • True or false : This pipeline is balanced ? o True o False • What is the throughput of this pipeline (in rounds/hours) ? o 0.6 rounds/hour o 0.8 rounds/hour o 1.0 rounds/hour o 1.2 rounds/hour • Which of the following statement is true ? o Amdahl's law works with a constant workload, and varies the time needed o Amdahl's law works with a constant time, and varies the workload o Gustavson's law works with a constant workload, and varies the time needed o Gustavson's law works with a constant amount of time, and varies the workload • Considering Amdahl's law, what limits the maximal possible speedup ? o The sequential parts of the program o It states that there is no limit o The maximum number of processors in a machine o The energy consumption of a machine • What is the span of this task graph ? o 70 o 75 o 80 o 85 • What is the difference between .fork() and .invoke() ? o invoke waits for the result, fork doesn't o fork waits for the result, invoke doesn't o invoke can only be called from within fork/join computations • Let A be an array of ints. Which of the following are map operations (select all that applies) ? o Taking the max element of an array o Multiplying every element of an array of ints by 2 o for (int i=0; i < A.length; i++) {A[i] = (A[i]/6)*5+1} o for (int i=0; i < A.length; i++) {A[i] = (A[i-1]/6)*5+1} • What is the difference between RecursiveTask and RecursiveAction ? o RecursiveTask returns a void, RecursiveAction returns a void o RecursiveTask returns a void, RecursiveAction returns a value o RecursiveTask returns a value, RecursiveAction returns a void o RecursiveTask returns a value, RecursiveAction returns a value • If we write out the synchronized blocks (lhs) they correspond to the rhs. o True o False • A bad interleaving is a data race. o True o False • Declaring a variable as volatile ensures that threads read the most recent value written to it. o True o False • Happens-before order is... o the intersection of program order & volatile variables o a synonym for program order o the union of synchronization order & program order o the transitive closure of synchronization order & program order • This program deadlocks o True o False • This program does not provide mutual exclusion. (Java program and no variable is volatile) o True o False • \"ready\" is a volatile variable. How many synchronization actions does this code have? o 1 o 2 o 3 o 4 • This is a n-thread lock for n > 2 o Peterson Lock o Bakery Lock • Given a deadlock-free and fair lock, it is also starvation free. o True o False • The filter lock is fair. o True o False • The bakery and filter lock need O(1) memory. o True o False • A semaphore with 1 permit behaves exactly like a lock. o True o False • This implementation of a Producer-Consumer Buffer is correct. o True o False • What is the main idea of Coarse Grained Locking (Linked List) o Lock the whole linked list. o Lock only the target node. o Lock only the target node and its predecessor. o Traverse the list using hand-over-hand locking Info: With the term \"window\" we mean a target node together with its predecessor. The target node should be clear from the context. • What is the main idea of remove() in optimistic locking? o Find target window, lock both nodes, physically remove target node. o Find target window, physically remove target node. o Find target window, traverse list to ensure reachability, physically remove o None of the above. • Lazy Synchronization doesn’t work if we don’t have… o ... “helpers” that clean up marked but not removed nodes o …a “logically removed” marker/flag for each node o …locks o code to ”redirect” the next pointer of the predecessor • Which of the following approaches prevent the ABA Problem from occuring? (Stack) o Not reusing nodes o Pointer Tagging o Hazard Pointers o Not using Java • What's the minimum number of Threads needed so that the ABA Problem can occcur? o 1 o 2 o 3 o 4+ • The history in the image is... o linearizable & sequentially consistent o linearizable & not sequentially consistent o not linearizable & sequentially consistent o not linearizable & not sequentially consistent • Which of these combinations can never be true for any history? o linearizable & sequentially consistent o linearizable & not sequentially consistent o not linearizable & sequentially consistent o not linearizable & not sequentially consistent • Which one of these object - consensus number pairs is FALSE: o TAS – infinity o CAS – infinity o Queue – 2 o Atomic register – 1 • Locks are not composable. That means, there is no easy way to: o change the synchronization scheme but not the entire program o nest several locks while avoiding deadlocks o lower the locking overhead when there is little contention o use two n-thread locks to create a 2n-thread lock • Transactional Memory is a _____ approach to parallel programming. o Declarative o Decriptive o Destructive o Definitive • If transaction A begins BEFORE B, but neither is committed yet, then A is aborted if ... o B writes to a value in A's read-set o B reads a value in A's write-set o B writes to a value in A's write-set o B reads a value in A's read-set • Asynchronous messaging means, the ... o receiver gets the message before it was sent o sender waits for the receiver to be ready o message is buffered, the receiver reads it on demand o sender-reciever communication failed, data may be lost PProg Final Kahoot FS24 Solutions • On a machine with a single core, multiple processes can run… o concurrently and in parallel o none of the above o concurrently o in parallel • Different processes (not threads) share the same address space. o False o True • Let Thread Ti have ki instructions. How many interleavings are there for n Threads? o ∏ 𝑘𝑖! 𝑛 𝑖=1 o (∑ 𝑘𝑖 𝑛 𝑖=1 )! ∏ 𝑘𝑖! 𝑛 𝑖=1 o ∑ 𝑘𝑖 𝑛𝑛 𝑖=1 o (∑ 𝑘𝑖 𝑛 𝑖=1 !)∏ 𝑘𝑖 𝑛 𝑖=1 • A new thread in Java can be created by calling the _ method. o start() o run() o sprint() o begin() • On which granularity does the JVM schedule threads? o Line of code o Machine code o Block of code (method) o Bytecode • The main thread in Java is… o Non-Daemon o Daemon • A thread is in a synchronized block of an object. What cannot be happening at the same time? o Another thread calls notify on that object without getting an exception. o A synchronized static method of the object’s class can be executed. o A lock on the object’s class can be obtained by another thread. o Another method of that object can be executed. • Which of the following is not a valid state of a Java thread? o Joining o Waiting o Runnable o Terminated • In a pipeline, latency ... o always stays constant o can decrease as instances go through o can increase or decrease as instances go through o can increase as instances go through • True or false : This pipeline is balanced ? o True o False • What is the throughput of this pipeline (in rounds/hours) ? o 0.6 rounds/hour o 0.8 rounds/hour o 1.0 rounds/hour o 1.2 rounds/hour • Which of the following statement is true ? o Amdahl's law works with a constant workload, and varies the time needed o Amdahl's law works with a constant time, and varies the workload o Gustavson's law works with a constant workload, and varies the time needed o Gustavson's law works with a constant amount of time, and varies the workload • Considering Amdahl's law, what limits the maximal possible speedup ? o The sequential parts of the program o It states that there is no limit o The maximum number of processors in a machine o The energy consumption of a machine • What is the span of this task graph ? o 70 o 75 o 80 o 85 • What is the difference between .fork() and .invoke() ? o invoke waits for the result, fork doesn't o fork waits for the result, invoke doesn't o invoke can only be called from within fork/join computations • Let A be an array of ints. Which of the following are map operations (select all that applies) ? o Taking the max element of an array o Multiplying every element of an array of ints by 2 o for (int i=0; i < A.length; i++) {A[i] = (A[i]/6)*5+1} o for (int i=0; i < A.length; i++) {A[i] = (A[i-1]/6)*5+1} • What is the difference between RecursiveTask and RecursiveAction ? o RecursiveTask returns a void, RecursiveAction returns a void o RecursiveTask returns a void, RecursiveAction returns a value o RecursiveTask returns a value, RecursiveAction returns a void o RecursiveTask returns a value, RecursiveAction returns a value • If we write out the synchronized blocks (lhs) they correspond to the rhs. o True o False • A bad interleaving is a data race. o True o False • Declaring a variable as volatile ensures that threads read the most recent value written to it. o True o False • Happens-before order is... o the intersection of program order & volatile variables o a synonym for program order o the union of synchronization order & program order o the transitive closure of synchronization order & program order • This program deadlocks o True o False • This program does not provide mutual exclusion. (Java program and no variable is volatile) o True o False • \"ready\" is a volatile variable. How many synchronization actions does this code have? o 1 o 2 o 3 o 4 • This is a n-thread lock for n > 2 o Peterson Lock o Bakery Lock • Given a deadlock-free and fair lock, it is also starvation free. o True o False • The filter lock is fair. o True o False • The bakery and filter lock need O(1) memory. o True o False • A semaphore with 1 permit behaves exactly like a lock. o True o False • This implementation of a Producer-Consumer Buffer is correct. o True o False • What is the main idea of Coarse Grained Locking (Linked List) o Lock the whole linked list. o Lock only the target node. o Lock only the target node and its predecessor. o Traverse the list using hand-over-hand locking Info: With the term \"window\" we mean a target node together with its predecessor. The target node should be clear from the context. • What is the main idea of remove() in optimistic locking? o Find target window, lock both nodes, physically remove target node. o Find target window, physically remove target node. o Find target window, traverse list to ensure reachability, physically remove o None of the above. • Lazy Synchronization doesn’t work if we don’t have… o ... “helpers” that clean up marked but not removed nodes o …a “logically removed” marker/flag for each node o …locks o code to ”redirect” the next pointer of the predecessor • Which of the following approaches prevent the ABA Problem from occuring? (Stack) o Not reusing nodes o Pointer Tagging o Hazard Pointers o Not using Java • What's the minimum number of Threads needed so that the ABA Problem can occcur? o 1 o 2 o 3 o 4+ • The history in the image is... o linearizable & sequentially consistent o linearizable & not sequentially consistent o not linearizable & sequentially consistent o not linearizable & not sequentially consistent • Which of these combinations can never be true for any history? o linearizable & sequentially consistent o linearizable & not sequentially consistent o not linearizable & sequentially consistent o not linearizable & not sequentially consistent • Which one of these object - consensus number pairs is FALSE: o TAS – infinity o CAS – infinity o Queue – 2 o Atomic register – 1 • Locks are not composable. That means, there is no easy way to: o change the synchronization scheme but not the entire program o nest several locks while avoiding deadlocks o lower the locking overhead when there is little contention o use two n-thread locks to create a 2n-thread lock • Transactional Memory is a _____ approach to parallel programming. o Declarative o Decriptive o Destructive o Definitive • If transaction A begins BEFORE B, but neither is committed yet, then A is aborted if ... o B writes to a value in A's read-set o B reads a value in A's write-set o B writes to a value in A's write-set o B reads a value in A's read-set • Asynchronous messaging means, the ... o receiver gets the message before it was sent o sender waits for the receiver to be ready o message is buffered, the receiver reads it on demand o sender-reciever communication failed, data may be lost","libVersion":"0.3.2","langs":""}