{"path":"sem2/PProg/VRL/slides/PProg-L21-concurrency-theory.pdf","text":"spcl.inf.ethz.ch @spcl_eth TORSTEN HOEFLER Parallel Programming More on fine-grained locking source: xkcd Elon Musk: “Any part of this could fail and the car will keep driving” (no locks!) spcl.inf.ethz.ch @spcl_eth ▪ Explicit/interface locks ▪ More powerful – more error prone ☺ ▪ Sleeping barber example ▪ Avoiding excessive (useless) notifications Keep counts of active threads ▪ Reader/writer locks ▪ Fairness / various versions Last week’s lecture 2 spcl.inf.ethz.ch @spcl_eth ▪ Lock granularity in practice ▪ Fun with lists ☺ ▪ Stacks ▪ Various locking modes ▪ All those above as examples! Learning goals today 3 spcl.inf.ethz.ch @spcl_eth Often more intricate than visible at a first sight • requires careful consideration of special cases Idea: split object into pieces with separate locks • no mutual exclusion for algorithms on disjoint pieces Fine grained Locking 4 spcl.inf.ethz.ch @spcl_eth remove(c) Is this ok? Let's try this a b c d 5 spcl.inf.ethz.ch @spcl_eth Thread A: remove(c) Thread B: remove(b) c not deleted!  Let's try this a b c d AB 6 spcl.inf.ethz.ch @spcl_eth ▪ When deleting, the next field of next is read, i.e., next also has to be protected. ▪ A thread needs to lock both, predecessor and the node to be deleted (hand-over-hand locking). What's the problem? a b d e BB 7 spcl.inf.ethz.ch @spcl_eth public boolean remove(T item) { Node pred = null, curr = null; int key = item.hashCode(); head.lock(); try { pred = head; curr = pred.next; curr.lock(); try { // find and remove } finally { curr.unlock(); } } finally { pred.unlock(); } } Remove method hand over hand 8 while (curr.key < key) { pred.unlock(); pred = curr; // pred still locked curr = curr.next; curr.lock(); // lock hand over hand } if (curr.key == key) { pred.next = curr.next; // delete return true; } return false; remark: sentinel at front and end of list prevents an exception here spcl.inf.ethz.ch @spcl_eth ▪ Potentially long sequence of acquire / release before the intended action can take place ▪ One (slow) thread locking \"early nodes\" can block another thread wanting to acquire \"late nodes\" Disadvantages? 9 spcl.inf.ethz.ch @spcl_eth OPTIMISTIC SYNCHRONIZATION 10 spcl.inf.ethz.ch @spcl_eth Find nodes without locking, • then lock nodes and • check that everything is ok (validation) e.g., add(c) Idea a b d e 11 What do we need to “validate”? spcl.inf.ethz.ch @spcl_eth Thread A: add(c) A: find insertion point Thread B: remove(b) A: lock A: validate: rescan A: b not reachable →return false Validation: what could go wrong? a b d e a b d e B B a b d e A A 12 spcl.inf.ethz.ch @spcl_eth Thread A: add(c) A: find insertion point Thread B: insert(b') A: lock A: validate: rescan A: d != succ(b) →return false Validation: what else could go wrong? a b d e a b d e B B a b d e A A b' b' 13 spcl.inf.ethz.ch @spcl_eth private Boolean validate(Node pred, Node curr) { Node node = head; while (node.key <= pred.key) { // reachable? if (node == pred) return pred.next == curr; // connected? node = node.next; } return false; } Validate - summary pred curr A A 14 spcl.inf.ethz.ch @spcl_eth If • nodes b and c both locked • node b still reachable from head • node c still successor to b then • neither is in the process of being deleted ➔ ok to delete and return true Correctness (remove existing c) b c 15 spcl.inf.ethz.ch @spcl_eth If • nodes b and d both locked • node b still reachable from head • node d still successor to b then • neither is in the process of being deleted, therefore a new element c must appear between b and d • no thread can add between b and d: c cannot have appeared after our locking ➔ ok to return false Correctness (remove nonexisting c) b d 16 spcl.inf.ethz.ch @spcl_eth Good: ▪ No contention on traversals. ▪ Traversals are wait-free. ▪ Less lock acquisitions. Bad: ▪ Need to traverse list twice ▪ The contains() method needs to acquire locks ▪ Not starvation-free Optimistic List Wait-Free: Every call finishes in a finite number of steps (NEVER waits for other threads). 17 Is the optimistic list starvation-free? Why/why not? spcl.inf.ethz.ch @spcl_eth LAZY SYNCHRONISATION 18 spcl.inf.ethz.ch @spcl_eth Like optimistic list but • Scan only once • Contains() never locks How? • Removing nodes causes trouble • Use deleted-markers → semantics: every unmarked node is reachable! • Remove nodes «lazily» after marking Lazy List 19 spcl.inf.ethz.ch @spcl_eth Scan list (as before) Lock predecessor and current (as before) Logical delete: mark current node as removed Physical delete: redirect predecessor's next e.g., remove(c) Lazy List: Remove a b c d 20 spcl.inf.ethz.ch @spcl_eth If a node is not marked then • It is reachable from head • And reachable from its predecessor A: remove(c) lock check if b or c are marked not marked? ok to delete: mark c delete c Key invariant a b c d 21 spcl.inf.ethz.ch @spcl_eth public boolean remove(T item) { int key = item.hashCode(); while (true) { // optimistic, retry Node pred = this.head; Node curr = head.next; while (curr.key < key) { pred = curr; curr = curr.next; } pred.lock(); try { curr.lock(); try { // remove or not } finally { curr.unlock(); } } finally { pred.unlock(); } } } Remove method 22 if (!pred.marked && !curr.marked && pred.next == curr) { if (curr.key != key) return false; else { curr.marked = true; // logically remove pred.next = curr.next; // physically remove return true; } } spcl.inf.ethz.ch @spcl_eth public boolean contains(T item) { int key = item.hashCode(); Node curr = this.head; while (curr.key < key) { curr = curr.next; } return curr.key == key && !curr.marked; } Wait-Free Contains 23 This set data structure is again for demonstration only. Do not use this to implement a list! Now on to something more practical. spcl.inf.ethz.ch @spcl_eth More practical: Lazy Skip Lists 24 Bill Pugh spcl.inf.ethz.ch @spcl_eth ▪ Collection of elements (without duplicates) ▪ Interface: ▪ add // add an element ▪ remove // remove an element ▪ find // search an element ▪ Assumptions: • Many calls to find() • Fewer calls to add() and much fewer calls to remove() Skip list – a practical representation for sets! 25 spcl.inf.ethz.ch @spcl_eth ▪ AVL trees, red-black trees, treaps, ... ▪ rebalancing after add and remove expensive ▪ rebalancing is a global operation (potentially changing the whole tree) ▪ particularly hard to implement in a lock-free way. ▪ → Skip lists solve challenges probabilistically (Las Vegas style) How about balanced trees? 26 spcl.inf.ethz.ch @spcl_eth ▪ Sorted multi-level list ▪ Node height probabilistic, e.g., ℙ ℎ𝑒𝑖𝑔ℎ𝑡 = 𝑛 = 0.5𝑛, no rebalancing Skip lists 27 −∞ +∞𝟐 𝟒 𝟓 𝟕 𝟖 𝟗 spcl.inf.ethz.ch @spcl_eth ▪ Sublist relationship between levels: higher level lists are always contained in lower-level lists. Lowest level is entire list. Skip list property −∞ +∞𝟐 𝟒 𝟓 𝟕 𝟖 𝟗 28 spcl.inf.ethz.ch @spcl_eth ▪ Logarithmic search (with high probability) ▪ Example: Search for 8 Searching > > > > < < < < < < < = −∞ +∞𝟐 𝟒 𝟓 𝟕 𝟖 𝟗 29 spcl.inf.ethz.ch @spcl_eth ▪ // find node with value x ▪ // return -1 if not found, node level, succ, and pre otherwise ▪ // pre = array of predecessor node for all levels ▪ // succ = array of successor node for all levels ▪ int find(T x, Node<T>[] pre, Node<T>[] succ) ▪ e.g., x = 8 ▪ returns 0, <9>, <7> Sequential find > > > > < < < < < < < = > −∞ +∞𝟐 𝟒 𝟓 𝟕 𝟖 𝟗 30 spcl.inf.ethz.ch @spcl_eth ▪ // find node with value x ▪ // return -1 if not found, node level, succ, and pre otherwise ▪ // pre = array of predecessor node for all levels ▪ // succ = array of successor node for all levels ▪ int find(T x, Node<T>[] pre, Node<T>[] succ) ▪ e.g., x = 6 ▪ returns -1 Sequential find > > > > < < < < < < > −∞ +∞𝟐 𝟒 𝟓 𝟕 𝟖 𝟗 31 spcl.inf.ethz.ch @spcl_eth 𝟓−∞ ▪ Find predecessors (lock-free) ▪ Lock predecessors ▪ Validate (cf. Lazy synchronisation) add (6) – with four levels! < < < < +∞𝟐 𝟒 𝟕 𝟖 𝟗 32 spcl.inf.ethz.ch @spcl_eth −∞ +∞𝟐 𝟒 𝟓 𝟕 𝟖 𝟗𝟔 ▪ Find predecessors (lock-free) ▪ Lock predecessors ▪ Validate (cf. Lazy synchronisation) add (6) ▪ Splice ▪ mark fully linked ▪ Unlock < < < < < 33 spcl.inf.ethz.ch @spcl_eth −∞ +∞𝟐 𝟒 𝟓 𝟕 𝟖 𝟗 ▪ find predecessors ▪ lock victim ▪ logically remove victim (mark) remove(5) ▪ Lock predecessors and validate < < < < 34 spcl.inf.ethz.ch @spcl_eth −∞ +∞𝟐 𝟒 𝟓 𝟕 𝟖 𝟗 ▪ find predecessors ▪ lock victim ▪ logically remove victim (mark) remove(5) ▪ Lock predecessors and validate ▪ physically remove ▪ unlock < < < < 35 spcl.inf.ethz.ch @spcl_eth ▪ sequential find() & not logically removed & fully linked ▪ even if other nodes are removed, it stays reachable ▪ contains is wait-free (while add and remove are not) contains(8) > > > > < < < < < < < = −∞ +∞𝟐 𝟒 𝟓 𝟕 𝟖 𝟗 36 spcl.inf.ethz.ch @spcl_eth ▪ Practical parallel datastructure ▪ Code in book (latest revision!) – 139 lines ▪ Too much to discuss in detail here ▪ Review and implement as exercise 37 Skip list spcl.inf.ethz.ch @spcl_eth ▪ Spinlocks vs scheduled locks ▪ Lock-free programming ▪ Lock-free data structures: stack and list set Now back to locks to motivate lock-free Literature: -Herlihy Chapter 11.1 – 11.3 -Herlihy Chapter 9.8 38 spcl.inf.ethz.ch @spcl_eth • Scheduling fairness / missing FIFO behavior. • Solved with queue locks – not presented in class but very nice! • Computing resources wasted, overall performance degraded, particularly for long-lived contention. • No notification mechanism. Reminder: problems with spinlocks 39 spcl.inf.ethz.ch @spcl_eth ▪ Waiting locks suspend the execution of threads while they wait. Semaphores, mutexes, and monitors are typically implemented using a waiting lock. Locks with waiting/scheduling wait waiting entry monitor waiting condition method call notification Waiting queues require protection: spinlocks! 40 spcl.inf.ethz.ch @spcl_eth ▪ Require support from the runtime system (OS, scheduler). ▪ Data structures for waiting locks need to be protected against concurrent access, again using spinlocks, if not implemented lock-free (→ this lecture). ▪ Such locks have a higher wakeup latency (need to involve some scheduler). ▪ Hybrid solutions: try access with spinlock for a certain duration before rescheduling. ▪ Cf. “competitive spinning” (much later) Locks with waiting/scheduling 41 spcl.inf.ethz.ch @spcl_eth ▪ Uncontended case • when threads do not compete for the lock • lock implementations try to have minimal overhead • typically \"just\" the cost of an atomic operation ▪ Contended case • when threads do compete for the lock • can lead to significant performance degradation • also, starvation • there exist lock implementations that try to address these issues Locks performance ☺ ☺ 42 spcl.inf.ethz.ch @spcl_eth Locks are pessimistic by design • Assume the worst and enforce mutual exclusion Performance issues • Overhead for each lock taken even in uncontended case • Contended case leads to significant performance degradation • Amdahl's law! Blocking semantics (wait until acquire lock) • If a thread is delayed (e.g., scheduler) when in a critical section → all threads suffer • What if a thread dies in the critical section • Prone to deadlocks (and also livelocks) • Without precautions, locks cannot be used in interrupt handlers Disadvantages of locking 43 spcl.inf.ethz.ch @spcl_eth Lock-Free Programming 44 spcl.inf.ethz.ch @spcl_eth ▪ Deadlock: group of two or more competing processes are mutually blocked because each process waits for another blocked process in the group to proceed ▪ Livelock: competing processes are able to detect a potential deadlock condition but make no observable progress while trying to resolve it ▪ Starvation: repeated but unsuccessful attempt of a recently unblocked process to continue its execution Recap: Definitions for blocking synchronization 45 spcl.inf.ethz.ch @spcl_eth ▪ Lock-freedom: at least one thread always makes progress even if other threads run concurrently. Implies system-wide progress but not freedom from starvation. ▪ Wait-freedom: all threads eventually make progress. Implies freedom from starvation. Definitions for Lock-free Synchronisation implies 46 spcl.inf.ethz.ch @spcl_eth Non-blocking (no locks) Blocking (locks) Everyone makes progress Wait-free Starvation-free Someone make progress Lock-free Deadlock-free Progress conditions with and without locks 47 spcl.inf.ethz.ch @spcl_eth Locks/blocking: a thread can indefinitely delay another thread Non-blocking: failure or suspension of one thread cannot cause failure or suspension of another thread ! Non-blocking algorithms 48","libVersion":"0.3.2","langs":""}