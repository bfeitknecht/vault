{"path":"sem2/PProg/VRL/slides/PProg-L21-concurrency-theory.pdf","text":"spcl.inf.ethz.ch @spcl_eth TORSTEN HOEFLER Parallel Programming More on fine-grained locking source: xkcd Elon Musk: â€œAny part of this could fail and the car will keep drivingâ€ (no locks!) spcl.inf.ethz.ch @spcl_eth â–ª Explicit/interface locks â–ª More powerful â€“ more error prone â˜º â–ª Sleeping barber example â–ª Avoiding excessive (useless) notifications Keep counts of active threads â–ª Reader/writer locks â–ª Fairness / various versions Last weekâ€™s lecture 2 spcl.inf.ethz.ch @spcl_eth â–ª Lock granularity in practice â–ª Fun with lists â˜º â–ª Stacks â–ª Various locking modes â–ª All those above as examples! Learning goals today 3 spcl.inf.ethz.ch @spcl_eth Often more intricate than visible at a first sight â€¢ requires careful consideration of special cases Idea: split object into pieces with separate locks â€¢ no mutual exclusion for algorithms on disjoint pieces Fine grained Locking 4 spcl.inf.ethz.ch @spcl_eth remove(c) Is this ok? Let's try this a b c d 5 spcl.inf.ethz.ch @spcl_eth Thread A: remove(c) Thread B: remove(b) c not deleted! ïŒ Let's try this a b c d AB 6 spcl.inf.ethz.ch @spcl_eth â–ª When deleting, the next field of next is read, i.e., next also has to be protected. â–ª A thread needs to lock both, predecessor and the node to be deleted (hand-over-hand locking). What's the problem? a b d e BB 7 spcl.inf.ethz.ch @spcl_eth public boolean remove(T item) { Node pred = null, curr = null; int key = item.hashCode(); head.lock(); try { pred = head; curr = pred.next; curr.lock(); try { // find and remove } finally { curr.unlock(); } } finally { pred.unlock(); } } Remove method hand over hand 8 while (curr.key < key) { pred.unlock(); pred = curr; // pred still locked curr = curr.next; curr.lock(); // lock hand over hand } if (curr.key == key) { pred.next = curr.next; // delete return true; } return false; remark: sentinel at front and end of list prevents an exception here spcl.inf.ethz.ch @spcl_eth â–ª Potentially long sequence of acquire / release before the intended action can take place â–ª One (slow) thread locking \"early nodes\" can block another thread wanting to acquire \"late nodes\" Disadvantages? 9 spcl.inf.ethz.ch @spcl_eth OPTIMISTIC SYNCHRONIZATION 10 spcl.inf.ethz.ch @spcl_eth Find nodes without locking, â€¢ then lock nodes and â€¢ check that everything is ok (validation) e.g., add(c) Idea a b d e 11 What do we need to â€œvalidateâ€? spcl.inf.ethz.ch @spcl_eth Thread A: add(c) A: find insertion point Thread B: remove(b) A: lock A: validate: rescan A: b not reachable â†’return false Validation: what could go wrong? a b d e a b d e B B a b d e A A 12 spcl.inf.ethz.ch @spcl_eth Thread A: add(c) A: find insertion point Thread B: insert(b') A: lock A: validate: rescan A: d != succ(b) â†’return false Validation: what else could go wrong? a b d e a b d e B B a b d e A A b' b' 13 spcl.inf.ethz.ch @spcl_eth private Boolean validate(Node pred, Node curr) { Node node = head; while (node.key <= pred.key) { // reachable? if (node == pred) return pred.next == curr; // connected? node = node.next; } return false; } Validate - summary pred curr A A 14 spcl.inf.ethz.ch @spcl_eth If â€¢ nodes b and c both locked â€¢ node b still reachable from head â€¢ node c still successor to b then â€¢ neither is in the process of being deleted â” ok to delete and return true Correctness (remove existing c) b c 15 spcl.inf.ethz.ch @spcl_eth If â€¢ nodes b and d both locked â€¢ node b still reachable from head â€¢ node d still successor to b then â€¢ neither is in the process of being deleted, therefore a new element c must appear between b and d â€¢ no thread can add between b and d: c cannot have appeared after our locking â” ok to return false Correctness (remove nonexisting c) b d 16 spcl.inf.ethz.ch @spcl_eth Good: â–ª No contention on traversals. â–ª Traversals are wait-free. â–ª Less lock acquisitions. Bad: â–ª Need to traverse list twice â–ª The contains() method needs to acquire locks â–ª Not starvation-free Optimistic List Wait-Free: Every call finishes in a finite number of steps (NEVER waits for other threads). 17 Is the optimistic list starvation-free? Why/why not? spcl.inf.ethz.ch @spcl_eth LAZY SYNCHRONISATION 18 spcl.inf.ethz.ch @spcl_eth Like optimistic list but â€¢ Scan only once â€¢ Contains() never locks How? â€¢ Removing nodes causes trouble â€¢ Use deleted-markers â†’ semantics: every unmarked node is reachable! â€¢ Remove nodes Â«lazilyÂ» after marking Lazy List 19 spcl.inf.ethz.ch @spcl_eth Scan list (as before) Lock predecessor and current (as before) Logical delete: mark current node as removed Physical delete: redirect predecessor's next e.g., remove(c) Lazy List: Remove a b c d 20 spcl.inf.ethz.ch @spcl_eth If a node is not marked then â€¢ It is reachable from head â€¢ And reachable from its predecessor A: remove(c) lock check if b or c are marked not marked? ok to delete: mark c delete c Key invariant a b c d 21 spcl.inf.ethz.ch @spcl_eth public boolean remove(T item) { int key = item.hashCode(); while (true) { // optimistic, retry Node pred = this.head; Node curr = head.next; while (curr.key < key) { pred = curr; curr = curr.next; } pred.lock(); try { curr.lock(); try { // remove or not } finally { curr.unlock(); } } finally { pred.unlock(); } } } Remove method 22 if (!pred.marked && !curr.marked && pred.next == curr) { if (curr.key != key) return false; else { curr.marked = true; // logically remove pred.next = curr.next; // physically remove return true; } } spcl.inf.ethz.ch @spcl_eth public boolean contains(T item) { int key = item.hashCode(); Node curr = this.head; while (curr.key < key) { curr = curr.next; } return curr.key == key && !curr.marked; } Wait-Free Contains 23 This set data structure is again for demonstration only. Do not use this to implement a list! Now on to something more practical. spcl.inf.ethz.ch @spcl_eth More practical: Lazy Skip Lists 24 Bill Pugh spcl.inf.ethz.ch @spcl_eth â–ª Collection of elements (without duplicates) â–ª Interface: â–ª add // add an element â–ª remove // remove an element â–ª find // search an element â–ª Assumptions: â€¢ Many calls to find() â€¢ Fewer calls to add() and much fewer calls to remove() Skip list â€“ a practical representation for sets! 25 spcl.inf.ethz.ch @spcl_eth â–ª AVL trees, red-black trees, treaps, ... â–ª rebalancing after add and remove expensive â–ª rebalancing is a global operation (potentially changing the whole tree) â–ª particularly hard to implement in a lock-free way. â–ª â†’ Skip lists solve challenges probabilistically (Las Vegas style) How about balanced trees? 26 spcl.inf.ethz.ch @spcl_eth â–ª Sorted multi-level list â–ª Node height probabilistic, e.g., â„™ â„ğ‘’ğ‘–ğ‘”â„ğ‘¡ = ğ‘› = 0.5ğ‘›, no rebalancing Skip lists 27 âˆ’âˆ +âˆğŸ ğŸ’ ğŸ“ ğŸ• ğŸ– ğŸ— spcl.inf.ethz.ch @spcl_eth â–ª Sublist relationship between levels: higher level lists are always contained in lower-level lists. Lowest level is entire list. Skip list property âˆ’âˆ +âˆğŸ ğŸ’ ğŸ“ ğŸ• ğŸ– ğŸ— 28 spcl.inf.ethz.ch @spcl_eth â–ª Logarithmic search (with high probability) â–ª Example: Search for 8 Searching > > > > < < < < < < < = âˆ’âˆ +âˆğŸ ğŸ’ ğŸ“ ğŸ• ğŸ– ğŸ— 29 spcl.inf.ethz.ch @spcl_eth â–ª // find node with value x â–ª // return -1 if not found, node level, succ, and pre otherwise â–ª // pre = array of predecessor node for all levels â–ª // succ = array of successor node for all levels â–ª int find(T x, Node<T>[] pre, Node<T>[] succ) â–ª e.g., x = 8 â–ª returns 0, <9>, <7> Sequential find > > > > < < < < < < < = > âˆ’âˆ +âˆğŸ ğŸ’ ğŸ“ ğŸ• ğŸ– ğŸ— 30 spcl.inf.ethz.ch @spcl_eth â–ª // find node with value x â–ª // return -1 if not found, node level, succ, and pre otherwise â–ª // pre = array of predecessor node for all levels â–ª // succ = array of successor node for all levels â–ª int find(T x, Node<T>[] pre, Node<T>[] succ) â–ª e.g., x = 6 â–ª returns -1 Sequential find > > > > < < < < < < > âˆ’âˆ +âˆğŸ ğŸ’ ğŸ“ ğŸ• ğŸ– ğŸ— 31 spcl.inf.ethz.ch @spcl_eth ğŸ“âˆ’âˆ â–ª Find predecessors (lock-free) â–ª Lock predecessors â–ª Validate (cf. Lazy synchronisation) add (6) â€“ with four levels! < < < < +âˆğŸ ğŸ’ ğŸ• ğŸ– ğŸ— 32 spcl.inf.ethz.ch @spcl_eth âˆ’âˆ +âˆğŸ ğŸ’ ğŸ“ ğŸ• ğŸ– ğŸ—ğŸ” â–ª Find predecessors (lock-free) â–ª Lock predecessors â–ª Validate (cf. Lazy synchronisation) add (6) â–ª Splice â–ª mark fully linked â–ª Unlock < < < < < 33 spcl.inf.ethz.ch @spcl_eth âˆ’âˆ +âˆğŸ ğŸ’ ğŸ“ ğŸ• ğŸ– ğŸ— â–ª find predecessors â–ª lock victim â–ª logically remove victim (mark) remove(5) â–ª Lock predecessors and validate < < < < 34 spcl.inf.ethz.ch @spcl_eth âˆ’âˆ +âˆğŸ ğŸ’ ğŸ“ ğŸ• ğŸ– ğŸ— â–ª find predecessors â–ª lock victim â–ª logically remove victim (mark) remove(5) â–ª Lock predecessors and validate â–ª physically remove â–ª unlock < < < < 35 spcl.inf.ethz.ch @spcl_eth â–ª sequential find() & not logically removed & fully linked â–ª even if other nodes are removed, it stays reachable â–ª contains is wait-free (while add and remove are not) contains(8) > > > > < < < < < < < = âˆ’âˆ +âˆğŸ ğŸ’ ğŸ“ ğŸ• ğŸ– ğŸ— 36 spcl.inf.ethz.ch @spcl_eth â–ª Practical parallel datastructure â–ª Code in book (latest revision!) â€“ 139 lines â–ª Too much to discuss in detail here â–ª Review and implement as exercise 37 Skip list spcl.inf.ethz.ch @spcl_eth â–ª Spinlocks vs scheduled locks â–ª Lock-free programming â–ª Lock-free data structures: stack and list set Now back to locks to motivate lock-free Literature: -Herlihy Chapter 11.1 â€“ 11.3 -Herlihy Chapter 9.8 38 spcl.inf.ethz.ch @spcl_eth â€¢ Scheduling fairness / missing FIFO behavior. â€¢ Solved with queue locks â€“ not presented in class but very nice! â€¢ Computing resources wasted, overall performance degraded, particularly for long-lived contention. â€¢ No notification mechanism. Reminder: problems with spinlocks 39 spcl.inf.ethz.ch @spcl_eth â–ª Waiting locks suspend the execution of threads while they wait. Semaphores, mutexes, and monitors are typically implemented using a waiting lock. Locks with waiting/scheduling wait waiting entry monitor waiting condition method call notification Waiting queues require protection: spinlocks! 40 spcl.inf.ethz.ch @spcl_eth â–ª Require support from the runtime system (OS, scheduler). â–ª Data structures for waiting locks need to be protected against concurrent access, again using spinlocks, if not implemented lock-free (â†’ this lecture). â–ª Such locks have a higher wakeup latency (need to involve some scheduler). â–ª Hybrid solutions: try access with spinlock for a certain duration before rescheduling. â–ª Cf. â€œcompetitive spinningâ€ (much later) Locks with waiting/scheduling 41 spcl.inf.ethz.ch @spcl_eth â–ª Uncontended case â€¢ when threads do not compete for the lock â€¢ lock implementations try to have minimal overhead â€¢ typically \"just\" the cost of an atomic operation â–ª Contended case â€¢ when threads do compete for the lock â€¢ can lead to significant performance degradation â€¢ also, starvation â€¢ there exist lock implementations that try to address these issues Locks performance â˜º â˜º 42 spcl.inf.ethz.ch @spcl_eth Locks are pessimistic by design â€¢ Assume the worst and enforce mutual exclusion Performance issues â€¢ Overhead for each lock taken even in uncontended case â€¢ Contended case leads to significant performance degradation â€¢ Amdahl's law! Blocking semantics (wait until acquire lock) â€¢ If a thread is delayed (e.g., scheduler) when in a critical section â†’ all threads suffer â€¢ What if a thread dies in the critical section â€¢ Prone to deadlocks (and also livelocks) â€¢ Without precautions, locks cannot be used in interrupt handlers Disadvantages of locking 43 spcl.inf.ethz.ch @spcl_eth Lock-Free Programming 44 spcl.inf.ethz.ch @spcl_eth â–ª Deadlock: group of two or more competing processes are mutually blocked because each process waits for another blocked process in the group to proceed â–ª Livelock: competing processes are able to detect a potential deadlock condition but make no observable progress while trying to resolve it â–ª Starvation: repeated but unsuccessful attempt of a recently unblocked process to continue its execution Recap: Definitions for blocking synchronization 45 spcl.inf.ethz.ch @spcl_eth â–ª Lock-freedom: at least one thread always makes progress even if other threads run concurrently. Implies system-wide progress but not freedom from starvation. â–ª Wait-freedom: all threads eventually make progress. Implies freedom from starvation. Definitions for Lock-free Synchronisation implies 46 spcl.inf.ethz.ch @spcl_eth Non-blocking (no locks) Blocking (locks) Everyone makes progress Wait-free Starvation-free Someone make progress Lock-free Deadlock-free Progress conditions with and without locks 47 spcl.inf.ethz.ch @spcl_eth Locks/blocking: a thread can indefinitely delay another thread Non-blocking: failure or suspension of one thread cannot cause failure or suspension of another thread ! Non-blocking algorithms 48","libVersion":"0.3.2","langs":""}