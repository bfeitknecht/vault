{"path":"sem3/TI/VRL/extra/nwehrl/TI-nwehrl-w07.pdf","text":"Theoretische Informatik HS24 Nicolas Wehrli ¨Ubungsstunde 07 5. November 2024 ETH Z ¨urich nwehrl@ethz.ch 1 Heute 1 Feedback zur Serie 2 Repetition - Aufgabenschema How To Kolmogorov Nichtregul¨arit¨atsbeweise Mindestanzahl Zust¨ande 3 Midterm Prep - Aufgaben HS18 4 Appendix - Theory Recap 2 Feedback zur Serie Feedback - Aufgabe 16: Typos, n0 war frei w¨ahlbar (und musste auf > 0 eingeschr¨ankt werden), Quantoren - Aufgabe 17: Transitionen innerhalb von A1, A2 f ¨ur c mussten definiert werden (sowohl bei NEAs als auch bei EAs). - Bei EA: δ : Q × Σ → Q Bei NEA: δ : Q × Σ → P(Q) 3 Repetition - Aufgabenschema Aufgabentyp 1 Sei wn = (010)32n3 ∈ {0, 1}∗ f ¨ur alle n ∈ N \\ {0}. Gib eine m ¨oglichst gute obere Schranke f ¨ur die Kolmogorov-Komplexit¨at von wn an, gemessen in der L¨ange von wn. 4 Aufgabentyp 1 Wir zeigen ein Programm, dass n als Eingabe nimmt und wn druckt: Wn : begin M := n ; M := 2 × M × M × M ; J := 1 ; f o r I = 1 t o M J : = J × 3 ; f o r I = 1 t o J ; w r i t e ( 0 1 0 ) ; end 5 Aufgabentyp 1 Der einzige variable Teil dieses Algorithmus ist n. Der restliche Code ist von konstanter L¨ange. Die bin¨are L¨ange dieses Programms kann von oben durch ⌈log2(n + 1)⌉ + c beschr¨ankt werden, f ¨ur eine Konstante c. Somit folgt K(wn) ≤ log2(n) + c ′ Wir berechnen die L¨ange von wn als |wn| = |010| · 32n3 = 32n3+1. 6 Aufgabentyp 1 Mit ein wenig umrechnen erhalten wir n = 3 √ log3 |wn| − 1 2 und die obere Schranke K(wn) ≤ log2 ( 3 √ log3 |wn| − 1 2 ) + c ′ ≤ log2 log3 |wn| + c ′′ 7 Aufgabentyp 2 Geben Sie eine unendliche Folge von W ¨ortern y1 < y2 < ... an, so dass eine Konstante c ∈ N existiert, so dass f ¨ur alle i ≥ 1 K(yi) ≤ log2 log4 log3 log2(|yi|) + c Wir definieren die Folge y1, y2, ... mit yi = 0234i f ¨ur alle i ∈ N. Da |yi| < |yi+1| folgt die geforderte Ordnung. Es gilt i = log4 log3 log2 |yi| f ¨ur i ≥ 1 Wir zeigen ein Programm, dass i als Eingabe nimmt und yi druckt: 8 Aufgabentyp 2 begin M := i ; M := 2 ˆ ( 3 ˆ ( 4 ˆ M ) ) ; f o r I = 1 t o M ; w r i t e ( 0 ) ; end Das ˆ f ¨ur die Exponentiation ist nicht Teil der originalen Pascal Syntax, aber wir verwenden es um unser Programm lesbarer zu machen. 9 Aufgabentyp 2 Der einzige variable Teil dieses Programms ist das i. Der Rest hat konstante L¨ange. Demnach kann die L¨ange diese Programms f ¨ur eine Konstante c′ durch ⌈log2(i + 1)⌉ + c ′ von oben beschr¨ankt werden. Somit folgt K(yi) ≤ log2(i) + c ≤ log2 log4 log3 log2 |yi| + c f ¨ur eine Konstante c. 10 Aufgabentyp 3 Sei M = {7i | i ∈ N, i ≤ 2n − 1}. Beweisen Sie, dass mindestens sieben Achtel der Zahlen in M Kolmogorov-Komplexit¨at von mindestens n − 3 haben. Wir zeigen, dass h ¨ochstens 1 8 der Zahlen x ∈ M eine Kolmogorov-Komplexit¨at K(x) ≤ n − 4 haben. Nehmen wir zum Widerspruch an, dass M mehr als 1 8 |M| Zahlen x enth¨alt, mit K(x) ≤ n − 4. 11 Aufgabentyp 3 Die Programme, die diese W ¨orter generieren, m ¨ussen paarweise verschieden sein, da die W ¨orter paarweise verschieden sind. Es gibt aber h ¨ochstens n−4∑ k=0 2 k = 2n−3 − 1 < 1 8 |M| Bitstrings mit L¨ange ≤ n − 4. Widerspruch. 12 Beispielaufgabe - Lemma 3.3 Nehmen wir zum Widerspruch an L = {0n1n | n ∈ N} sei regul¨ar. Dann existiert ein EA A = (Q, Σ, δ, q0, F) mit L(A) = L. Wir betrachten die W ¨orter 01, . . . , 0|Q|+1. Per Pigeonhole-Principle existiert O.B.d.A. i < j, so dass ˆδ(q0, 0i) = ˆδ(q0, 0j) Nach Lemma 3.3 gilt 0 iz ∈ L ⇐⇒ 0jz ∈ L f ¨ur alle z ∈ (Σbool)∗. Dies f ¨uhrt aber zu einem Widerspruch, weil f ¨ur z = 1i das Wort 0i1i ∈ L aber 0j1i /∈ L. 13 Schema Lemma 3.3 Hier ist der markierte Teil, der einzige Teil der je nach Aufgabe anders ausgef ¨ullt werden muss. Wahl der W ¨orter Wahl des Suffixes Argumentation zum Widerspruch. Die Argumentation kann more involved sein, wenn nicht offensichtlich. 14 Beispielaufgabe - Pumping Lemma Versuchen wir zu beweisen, dass L2 = {wabw R | w ∈ {a, b} ∗} nicht regul¨ar ist. 15 Beispielaufgabe - Pumping Lemma Wir nehmen zum Widerspruch an, dass L2 regul¨ar ist. Das Pumping-Lemma (Lemma 3.4) besagt, dass dann eine Konstante n0 ∈ N existiert, so dass sich jedes Wort w ∈ Σ∗ mit |w| ≥ n0 in drei Teile y, x, und z zerlegen l¨asst. ( =⇒ w = yxz). Wobei folgendes gelten muss: (i) |yx| ≤ n0 (ii) |x| ≥ 1 (iii) entweder {yxkz | k ∈ N} ⊆ L2 oder {yxkz | k ∈ N} ∩ L2 = ∅ 16 Beispielaufgabe - Pumping Lemma Wir w¨ahlen w = an0aban0. Da |w| = 2n0 + 2 ≥ n0 gilt das PL. Sei y, x, z die Zerlegung die (i)-(iii) nach dem PL erf ¨ullt. Da nach (i), |yx| ≤ n0 gelten muss, haben wir y = al und x = am f ¨ur beliebige l, m ∈ N, l + m ≤ n0. Somit gilt z = an0−(l+m)aban0. Nach (ii) ist m ≥ 1. F ¨ur k = 1 haben wir yx1z = an0aban0 ∈ L2. 17 Beispielaufgabe - Pumping Lemma F ¨ur k = 0: ⇒ yx 0z = yz = an0−maba n0 /∈ L2 da m ≥ 1. Dies ist ein Widerspruch zu (iii). Somit ist L2 nicht regul¨ar. 18 Schema - Pumping Lemma Der markierte Teil ¨andert sich je nach Aufgabe. Wahl des Wortes Anwendung von (i) und (ii) (kann eine Case-Distinction sein) Wahl des k f ¨ur den Widerspruch Widerspruch herleiten (braucht manchmal ausf ¨uhrliche Argumente) 19 Beispielaufgabe - Kolmogorov Methode Verwenden Sie die Methode der Kolmogorov-Komplexit¨at, um zu zeigen, dass die Sprache L1 = {0 n2·2n | n ∈ N} nicht regul¨ar ist. 20 Beispielaufgabe - Kolmogorov Methode Angenommen L1 sei regul¨ar. Wir betrachten L 0m2·2m+1 = {y | 0 m2·2m+1y ∈ L1} f ¨ur m ∈ N beliebig. Da (m + 1) 2 · 2m+1 − (m 2 · 2 m + 1)= (m 2 + 2m + 1) · 2m+1 − m 2 · 2m − 1 = m2 · 2m + m 2 · 2m + (2m + 1) · 2 m+1 − m 2 · 2m − 1 = (m 2 + 4m + 2) · 2m − 1 ist y1 = 0(m2+4m+2)·2m−1 das kanonisch erste Wort der Sprache L0m2·2m+1 21 Beispielaufgabe - Kolmogorov Methode Nach Satz 3.1 existiert eine Konstante c, unabh¨angig von m, so dass K(y1) ≤ ⌈log2(1 + 1)⌉ + c = 1 + c. Die Anzahl aller Programme, deren L¨ange kleiner oder gleich 1 + c sind, ist endlich. Da es aber unendlich unterschiedliche W ¨orter der Form 0(m2+4m+2)·2m−1 gibt, ist dies ein Widerspruch. Demzufolge ist L1 nicht regul¨ar. ■ 22 Kolmogorov Methode - Schema Der markierte Teil ¨andert sich je nach Aufgabe. Wahl der Pr¨afixsprache Richtiges erstes/zweites Wort Beweis dass es unendlich viele unterschiedliche y1 gibt, f ¨ur Widerspruch 23 Mindestanzahl Zust¨ande n - Beweisschema Die Grundidee ist es n W ¨orter anzugeben und zu beweisen, dass jedes von diesen n W ¨ortern in einem eigenen Zustand enden muss. Seien w1, ..., wn diese W ¨orter. Dann geben wir f ¨ur jedes Paar von W ¨ortern wi ̸= wj einen Suffix zi,j an, so dass folgendes gilt: wizi,j ∈ L ̸⇐⇒ wjzi,j ∈ L Dann folgt aus Lemma 3.3 ˆδ(q0, wi) ̸= ˆδ(q0, wj) Es eignet sich die Suffixe als Tabelle anzugeben. Um die W ¨orter und Suffixe zu finden, kann es sich als n ¨utzlich erweisen, den Endlichen Automaten zu konstruieren. 24 Mindestanzahl Zust¨ande n - Beweisschema Wir nehmen zum Widerspruch an, dass es einen EA f ¨ur L gibt mit weniger als n Zust¨anden. Betrachten wir w1, ..., wn. Per Pigeonhole-Principle existiert i < j, so dass ˆδ(q0, wi) = ˆδ(q0, wj) Per Lemma 3.3 folgt daraus, dass ∀z ∈ Σ ∗ : wiz ∈ L ⇐⇒ wjz ∈ L F ¨ur z = zi,j gilt aber per Tabelle wizi,j ∈ L ̸⇐⇒ wjzi,j ∈ L (1) f ¨ur alle i < j. Da keines der n W ¨orter im gleichen Zustand enden kann: Widerspruch. 25 Mindestanzahl Zust¨ande n - Beweisschema Dann noch Angabe der Tabelle f ¨ur (1) w2 ... wn w1 z1,2 ... z1,n ... ... ... wn−1 zn−1,n - Wenn es offensichtlich ist, muss (1) nicht bei jedem Suffix begr ¨undet werden. - Ein minimaler endlicher Automat ist nicht notwendig f ¨ur den Beweis. Hilft aber f ¨urs i. Finden der wi ii. Finden der zi,j iii. Beweis von wizi,j ∈ L ̸⇐⇒ wjzi,j ∈ L (Leicht ¨uberpr ¨ufbar) 26 Klassische Aufgabe - HS19 Aufgabe 3.a Wir betrachten die Sprache L = {x00y | x ∈ {0, 1}∗ und y ∈ {0, 1}} Konstruieren Sie einen nichtdeterminstischen endlichen Automaten mit h ¨ochstens 4 Zust¨anden, der L akzeptiert. q0start q1 q2 q3 0, 1 0 0 0, 1 27 Klassische Aufgabe - HS19 Aufgabe 3.b Zeigen Sie, dass jeder deterministische endliche Automat, der L akzeptiert, mindestens 5 Zust¨ande braucht. Wir zeichnen den zugeh ¨origen EA zuerst. q0start q1 q2 q3 q4 1 0 0 1 0 1 0 1 0 1 28 Klassische Aufgabe - HS19 Aufgabe 3.b Nehmen wir zum Widerspruch an, dass es einen endlichen Automaten gibt, der L akzeptiert und weniger als 5 Zust¨ande hat. Wir w¨ahlen die W ¨orter B = {λ, 0, 00, 000, 001}. Nach dem Pigeonhole-Principle existieren zwei W ¨orter wi, wj ∈ B, wi ̸= wj, so dass ˆδ(q0, wi) = ˆδ(q0, wj) Per Lemma 3.3 folgt daraus, dass ∀z ∈ Σ∗ : wiz ∈ L ⇐⇒ wjz ∈ L 29 Klassische Aufgabe - HS19 Aufgabe 3.b Wir betrachten folgende Tabelle mit Suffixen. 0 00 000 001 λ 01 1 λ λ 0 1 λ λ 00 λ λ 000 1 Der zeigt f ¨ur jedes Wortpaar x, y ∈ B, x ̸= y die Existenz eines Suffixes z, so dass (xz ∈ L ∧ yz /∈ L) ∨ (xz /∈ L ∧ yz ∈ L) Dies kann man mit den angegebenen Suffixen und dem angegebenen EA einfach ¨uberpr ¨ufen. 30 Klassische Aufgabe - HS19 Aufgabe 3.b Dies widerspricht der vorigen Aussage, dass ein Wortpaar wi, wj ∈ B, wi ̸= wj existiert, so dass ∀z ∈ Σ ∗ : wiz ∈ L ⇐⇒ wjz ∈ L Somit ist unsere Annahme falsch und es existiert kein EA mit < 5 Zust¨anden f ¨ur L. ■ 31 Mindestanzahl Zust¨ande n - Bemerkung Manchmal ist es zu schwierig einen minimalen EA zu finden und es funktioniert einfacher die W ¨orter durch Trial and Error zu finden. (Siehe Midterm HS22) 32 Midterm Prep - Aufgaben HS18 Aufgabe 1.a - HS18 Wir betrachten die Sprache L = {1x | x = y1 f ¨ur ein y ∈ {0, 1}∗ oder x = z00 f ¨ur ein z ∈ {0, 1} ∗} Konstruieren Sie einen NEA (in graphischer Darstellung) mit h ¨ochstens 4 Zust¨anden, der L akzeptiert, und beschreiben Sie informell die Idee Ihrer Kon- struktion. 33 Aufgabe 1.b - HS18 Wir betrachten die Sprache L = {1x | x = y1 f ¨ur ein y ∈ {0, 1}∗ oder x = z00 f ¨ur ein z ∈ {0, 1} ∗} Konstruieren Sie einen (det.) EA (in graphischer Darstellung) mit h ¨ochstens 6 Zust¨anden, der L akzeptiert. Sie d ¨urfen hierf ¨ur entweder die Potenzmengenkonstruktion auf Ihren NEA aus (a) anwenden oder den Automaten direkt konstruieren und informell die Idee Ihrer Konstruktion beschreiben. 34 Aufgabe 2a - HS18 Zeigen Sie, dass die Sprache L = {u#v | u, v ∈ {0, 1} ∗ und Nummer(v) = 2 · Nummer(u)} nicht regul¨ar ist, mit einer der 3 Methoden der Vorlesung. 35 Aufgabe 2a HS18 - Lemma 3.3 Nehmen wir zum Widerspruch an L sei regul¨ar. Dann existiert ein EA A = (Q, Σ, δ, q0, F) mit L(A) = L. Wir betrachten die W ¨orter 101, . . . , 10|Q|+1. Per Pigeonhole-Principle existiert O.B.d.A. i < j, so dass ˆδ(q0, 10 i) = ˆδ(q0, 10 j) Nach Lemma 3.3 gilt 10 iz ∈ L ⇐⇒ 10 jz ∈ L f ¨ur alle z ∈ (Σbool)∗. Dies f ¨uhrt aber zu einem Widerspruch, weil f ¨ur z = #10i+1 das Wort 10i#10i+1 ∈ L aber 10j#10i+1 /∈ L, da 2· Nummer(10i) =Nummer(10i+1) = 2i+1 < 2 · 2j = 2 · Nummer(10j). 36 Aufgabe 2a HS18 - Pumping Lemma Wir nehmen zum Widerspruch an, dass L regul¨ar ist. Wir w¨ahlen w = 1n0#1n0+1. Da |w| = 2n0 + 3 ≥ n0 gilt das Pumping Lemma. Sei y, x, z die Zerlegung die (i)-(iii) nach dem PL erf ¨ullt. Da nach (i), |yx| ≤ n0 gelten muss, haben wir y = 1l und x = 1m f ¨ur l, m ∈ N, l + m ≤ n0. Somit gilt z = 1n0−(l+m)#1n0+1. Nach (ii) ist m ≥ 1. Wir haben f ¨ur k = 1 , yxz = w ∈ L. Aber f ¨ur k = 3 gilt yx3z = 1n0+2m#1n0+1 /∈ L, da Nummer(1n0+1) = 2n0+1 − 1 < 2n0+2m − 1 < 2 · (2n0+2m − 1) = 2 · Nummer(1n0+2m). Dies ist ein Widerspruch zu (iii) und somit ist L nicht regul¨ar. 37 Aufgabe 2b - HS18 Zeigen Sie, dass die Sprache L = {0n3 | n ∈ N} nicht regul¨ar ist, mit einer anderen der 3 Methoden der Vorlesung. 38 Aufgabe 3a - HS18 Sei f ¨ur alle n ∈ N \\ {0} die Sprache Ln definiert durch Ln = {x ∈ {0, 1}∗ | |x|1 ≥ n} Geben Sie einen (det.) EA (in graphischer Darstellung) f ¨ur L4 an, der h ¨ochstens 5 Zust¨ande hat, und geben Sie f ¨ur jeden Zustand q Ihres Automaten die Klasse Kl[q] an. 39 Aufgabe 3b - HS18 Zeigen Sie, dass jeder (det.) EA, der Ln akzeptiert, mindestens n + 1 Zust¨ande hat. 40 Appendix - Theory Recap Entscheidungsproblem Das Entscheidungsproblem (Σ, L) f ¨ur ein gegebenes Alphabet Σ und eine ge- gebene Sprache L ⊆ Σ∗ ist, f ¨ur jedes x ∈ Σ∗ zu entscheiden, ob x ∈ L oder x /∈ L. Ein Algorithmus A l ¨ost das Entscheidungsproblem (Σ, L), falls f ¨ur alle x ∈ Σ∗ gilt: A(x) =    1, falls x ∈ L, 0, falls x /∈ L. Wir sagen auch, dass A die Sprache L erkennt. 41 Kolmogorov Sei Σ ein Alphabet und x ∈ Σ∗. Wir sagen, dass ein Algorithmus A das Wort x generiert, falls A f ¨ur die Eingabe λ die Ausgabe x liefert. Kolmogorov-Komplexit¨at F ¨ur jedes Wort x ∈ (Σbool)∗ ist die Kolmogorov-Komplexit¨at K(x) des Wortes x das Minimum der bin¨aren L¨angen, der Pascal-Programme, die x generieren. =⇒ Kolmogorov Komplexit¨at eines Wortes ist die L¨ange des k ¨urzesten Programms, dass keinen Input nimmt und das Wort ausgibt! 42 Grundlegende Resultate Es existiert eine Konstante d, so dass f ¨ur jedes x ∈ (Σbool)∗ K(x) ≤ |x| + d Definition! Die Kolmogorov-Komplexit¨at einer nat ¨urlichen Zahl n ist K(n) = K(Bin(n)). 43 Lemma 2.5 - Nichtkomprimierbar F ¨ur jede Zahl n ∈ N \\ {0} existiert ein Wort wn ∈ (Σbool)n, so dass K(wn) ≥ |wn| = n 44 Lemma 2.5 - Beweis Es gibt 2n W ¨orter x1, ..., x2n ¨uber Σbool der L¨ange n. Wir bezeichnen C(xi) als den Bitstring des k ¨urzesten Programms, der xi generieren kann. Es ist klar, dass f ¨ur i ̸= j : C(xi) ̸= C(xj). Die Anzahl der nichtleeren Bitstrings, i.e. der W ¨orter der L¨ange < n ¨uber Σbool ist: n−1∑ i=1 2i = 2 n − 2 < 2n Also muss es unter den W ¨ortern x1, ..., x2n mindestens ein Wort xk mit K(xk) ≥ n geben. ■ 45 Ein zuf¨alliges Wort Definition Ein Wort x ∈ (Σbool)∗ heisst zuf¨allig, falls K(x) ≥ |x|. Eine Zahl n heisst zuf¨allig, falls K(n) = K(Bin(n)) ≥ ⌈log2(n + 1)⌉ − 1. 46 Satz 2.2 Sei L eine Sprache ¨uber Σbool. Sei f ¨ur jedes n ∈ N \\ {0}, zn das n-te Wort in L bez ¨uglich der kanonischen Ordnung. Wenn ein Programm AL existiert, das das Entscheidungsproblem (Σbool, L) l ¨ost, dann gilt f ¨ur alle n ∈ N \\ {0}, dass K(zn) ≤ ⌈log2(n + 1)⌉ + c wobei c eine von n unabh¨angige Konstante ist. Gehe W ¨orter zi in kanonischer Reihenfolge durch, verwende AL um zu entscheiden, ob zi in L ist. 47 Primzahlsatz F ¨ur jede positive ganz Zahl n sei Prim(n) die Anzahl der Primzahlen kleiner gleich n. lim n→∞ Prim(n) n/ ln n = 1 N ¨utzliche Ungleichung ln n − 3 2 < n Prim(n) < ln n − 1 2 f ¨ur alle n ≥ 67. 48 Lemma 2.6 - schwache Version des Primzahlsatzes Sei n1, n2, n3, ... eine steigende unendliche Folge nat ¨urlicher Zahlen mit K(ni) ≥ ⌈log2 ni⌉/2. F ¨ur jedes i ∈ N \\ {0} sei qi die gr ¨osste Primzahl, die die Zahl ni teilt. Dann ist die Menge Q = {qi | i ∈ N \\ {0}} unendlich. 49 Lemma 2.6 - Beweis Beweis: Wir beweisen diese Aussage per Widerspruch: Nehmen wir zum Widerspruch an, dass die Menge Q = {qi | i ∈ N \\ {0}} sei endlich. Sei pm die gr ¨osste Primzahl in Q. Dann k ¨onnen wir jede Zahl ni eindeutig als ni = pri,1 1 · p ri,2 2 · · · · · pri,m m f ¨ur irgendwelche ri,1, ri,2, ..., ri,m ∈ N darstellen. Bemerke das die pi ausser pm nicht notwendigerweise in Q sein m ¨ussen, wir verwenden nur den Fakt, dass es endlich viele davon hat. 50 Lemma 2.6 - Beweis continued Sei c die bin¨are L¨ange eines Programms, dass diese ri,j als Eingaben nimmt und ni erzeugt (A ist f ¨ur alle i ∈ N bis auf die Eingaben ri,1, ..., ri,m gleich). Dann gilt: K(ni) ≤ c + 8 · (⌈log2(ri,1 + 1)⌉ + ⌈log2(ri,2 + 1)⌉ + ... + ⌈log2(ri,m + 1)⌉) Die multiplikative Konstante 8 kommt daher, dass wir f ¨ur die Zahlen ri,1, ri,2, ..., ri,m dieselbe Kodierung, wie f ¨ur den Rest des Programmes verwenden (z.B. ASCII-Kodierung), damit ihre Darstellungen eindeutig voneinander getrennt werden k ¨onnen. Weil ri,j ≤ log2 ni, ∀j ∈ {1, ..., m} erhalten wir K(ni) ≤ c + 8m · ⌈log2(log2 ni + 1)⌉, ∀i ∈ N \\ {0} 51 Lemma 2.6 - Beweis continued 2 Weil m und c Konstanten unabh¨angig von i sind, kann ⌈log2 ni⌉/2 ≤ K(ni) ≤ c + 8m · ⌈log2(log2 ni + 1)⌉ ⌈log2 ni⌉/2 ≤ c + 8m · ⌈log2(log2 ni + 1)⌉ nur f ¨ur endlich viele i ∈ N \\ {0} gelten. Dies ist ein Widerspruch! Folglich ist die Menge Q unendlich. ■ 52 EA Konstruktion - Beispielaufgabe Entwerfen sie f ¨ur folgende Sprache einen Endlichen Automat und geben Sie eine Beschreibung von Kl[q] f ¨ur jeden Zustand q ∈ Q. L1 = {xbbya ∈ {a, b} ∗ | x, y ∈ {a, b}∗} 53 EA Konstruktion - Beispielaufgabe q0start q1 q2 q3 a b b a b a a b 54 EA Konstruktion - Beispielaufgabe Wir beschreiben nun die Klassen f ¨ur die Zust¨ande q0, q1, q2, q3: Kl[q0] = {wa ∈ {a, b}∗ | Das Wort w enth¨alt nicht die Teilfolge bb} ∪ {λ} Kl[q1] = {wb ∈ {a, b}∗ | Das Wort w enth¨alt nicht die Teilfolge bb} Kl[q3] = {wa ∈ {a, b}∗ | Das Wort w enth¨alt die Teilfolge bb} = L1 Kl[q2] = {a, b}∗ − (Kl[q0] ∪ Kl[q1] ∪ Kl[q3]) 55 Produktautomaten - Lemma 3.2 Sei Σ ein Alphabet und seien M1 = (Q1, Σ, δ1, q01, F1) und M2 = (Q2, Σ, δ2, q02, F2) zwei EA. F ¨ur jede Mengenoperation ⊙ ∈ {∪, ∩, −} existiert ein EA M, so dass L(M) = L(M1) ⊙ L(M2). Sei M = (Q, Σ, δ, q0, F⊙), wobei (i) Q = Q1 × Q2 (ii) q0 = (q01, q02) (iii) f ¨ur alle q ∈ Q1, p ∈ Q2 und a ∈ Σ, δ((q, p), a) = (δ1(q, a), δ2(p, a)), (iv) falls ⊙ = ∪, dann ist F = F1 × Q2 ∪ Q1 × F2 falls ⊙ = ∩, dann ist F = F1 × F2, und falls ⊙ = −, dann ist F = F1 × (Q2 − F2). 56 Produktautomat - Beispielaufgabe Verwenden Sie die Methode des modularen Entwurfs (Konstruktion eines Produktautomaten), um einen endlichen Automaten (in Diagrammdarstellung) f ¨ur die Sprache L = {w ∈ {a, b} ∗ | |w|a = 2 oder w = ya} zu entwerfen. Zeichnen Sie auch jeden der Teilautomaten und geben Sie f ¨ur die Teilautomaten f ¨ur jeden Zustand q die Klasse Kl[q] an. 57 Produktautomat - Beispielaufgabe Wir teilen L wie folgt auf: L = L1 ∪ L2 wobei gilt: L1 = {w ∈ {a, b}∗ | w = ya} L2 = {w ∈ {a, b}∗ | |w|a = 2} Zuerst zeichnen wir die 2 einzelnen Teilautomaten und geben f ¨ur jeden Zustand q bzw. p die Klasse Kl[q] respektive Kl[p] an: 58 Produktautomat - Beispielaufgabe erster Teilautomat: L1 = {w ∈ {a, b}∗ | w = ya} q0start q1 b a b a Kl[q0] = {yb | y ∈ {a, b}∗} ∪ {λ} Kl[q1] = {ya | y ∈ {a, b}∗} 59 Produktautomat - Beispielaufgabe zweiter Teilautomat: L2 = {w ∈ {a, b}∗ | |w|a = 2} p0start p1 p2 ptrash b a a b a b a b 60 Produktautomat - Beispielaufgabe Wir beschreiben nun die Zust¨ande f ¨ur die Klassen p0, p1, p2, ptrash: Kl[p0] = {w ∈ {a, b}∗ | |w|a = 0} Kl[p1] = {w ∈ {a, b}∗ | |w|a = 1} Kl[p2] = {w ∈ {a, b}∗ | |w|a = 2} Kl[ptrash] = {w ∈ {a, b}∗ | |w|a > 2} 61 Produktautomat - Beispielaufgabe Zum Schluss kombinieren wir diese Teilautomaten zu einem Produktautomaten: Produktautomat: L = L1 ∪ L2 (q0, p0)start (q0, p1) (q0, p2) (q0, ptrash) (q1, p0) (q1, p1) (q1, p2) (q1, ptrash) b a b a b a b ab a b a b a b a 62 Theorie f ¨ur Nichtregularit¨atsbeweise - Lemma 3.3 Sei A = (Q, Σ, δA, q0, F) ein EA. Seien x, y ∈ Σ∗, x ̸= y, so dass ˆδA(q0, x) = p = ˆδA(q0, y) f ¨ur ein p ∈ Q (also x, y ∈ Kl[p]). Dann existiert f ¨ur jedes z ∈ Σ∗ ein r ∈ Q, so dass xz und yz ∈ Kl[r], also gilt insbesondere xz ∈ L(A) ⇐⇒ yz ∈ L(A) 63 Theorie f ¨ur Nichtregularit¨atsbeweise - Lemma 3.3 Beweis: Aus der Existenz der Berechnungen (q0, x) A ∗ (p, λ) und (q0, y) A ∗ (p, λ) von A folgt die Existenz der Berechnungen auf xz und yz: (q0, xz) A ∗ (p, z) und (q0, yz) A ∗ (p, z) f ¨ur alle z ∈ Σ∗. Wenn r = ˆδA(p, z) ist, dann ist die Berechnung von A auf xz und yz: (q0, xz) A ∗ (p, z) A ∗ (r, λ) und (q0, yz) A ∗ (p, z) A ∗ (r, λ). Wenn r ∈ F, dann sind beide W ¨orter xz und yz in L(A). Falls r /∈ F, dann sind xz, yz /∈ L(A). ■ 64 Theorie f ¨ur Nichtregularit¨atsbeweise - Lemma 3.3 Bemerkungen - Von den 3 vorgestellten Methoden, ist diese Methode die einzige, die (unter der richtigen Anwendung) garantiert f ¨ur jede nichtregul¨are Sprache funktioniert. - Um die Nichtregularit¨at von L zu beweisen, verwenden wir die Endlichkeit von Q und das Pigeonhole-Principle. Betrachten wir mal eine Beispielaufgabe mit dieser Methode am Paradebeispiel L = {0 n1 n | n ∈ N} 65 Theorie f ¨ur Nichtregul¨arit¨atsbeweise - Pumping Lemma Sei L regul¨ar. Dann existiert eine Konstante n0 ∈ N, so dass jedes Wort w ∈ Σ∗ mit |w| ≥ n0 in drei Teile x, y und z zerlegen l¨asst, das heisst w = yxz, wobei (i) |yx| ≤ n0 (ii) |x| ≥ 1 (iii) entweder {yxkz | k ∈ N} ⊆ L oder {yxkz | k ∈ N} ∩ L = ∅. 66 Theorie f ¨ur Nichtregul¨arit¨atsbeweise - Pumping Lemma Beweis Sei L ∈ Σ∗ regul¨ar. Dann existiert ein EA A = (Q, Σ, δA, q0, F), so dass L(A) = L. Sei n0 = |Q| und w ∈ Σ∗ mit |w| ≥ n0. Dann ist w = w1w2...wn0u, wobei wi ∈ Σ f ¨ur i = 1, ..., n0 und u ∈ Σ∗. Betrachten wir die Berechnung auf w1w2...wn0: (q0, w1w2w3...wn0) A (q1, w2w3...wn0) A ... A (qn0−1, wn0) A (qn0, λ) 67 Theorie f ¨ur Nichtregul¨arit¨atsbeweise - Pumping Lemma In dieser Berechnung kommen n0 + 1 Zust¨ande q0, q1, ..., qn0 vor. Da |Q| = n0, existieren i, j ∈ {0, 1, ..., n0}, i < j, so dass qi = qj. Daher haben wir in der Berechnung die Konfigurationen (q0, w1w2w3...wn0) A ∗ (qi, wi+1wi+2...wn0) A ∗ (qi, wj+1...wn0) A ∗ (qn0, λ) Dies impliziert (qi, wi+1wi+2...wj) A ∗ (qi, λ) (1) Wir setzen nun y = w1...wi, x = wi+1...wj und z = wj+1...wn0u, so dass w = yxz. 68 Theorie f ¨ur Nichtregul¨arit¨atsbeweise - Pumping Lemma Wir ¨uberpr ¨ufen nun die Eigenschaften (i),(ii) und (iii): (i) yx = w1...wiwi+1...wj und daher |yx| = j ≤ n0. (ii) Da |x| ≥ j − i und i < j, ist |x| ≥ 1. (iii) (1) impliziert (qi, xk) A ∗ (qi, λ) f ¨ur alle k ∈ N. Folglich gilt f ¨ur alle k ∈ N: (q0, yx kz) A ∗ (qi, x kz) A ∗ (qi, z) A ∗ (ˆδA(qi, z), λ) Wir sehen, dass f ¨ur alle k ∈ N die Berechnungen im gleichen Zustand qend = ˆδA(qi, z) enden. Falls also qend ∈ F, akzeptiert A alle W ¨orter aus {yxkz | k ∈ N}. Falls qend /∈ F, dann akzeptiert A kein Wort aus {yxkz | k ∈ N}. ■ 69 Theorie f ¨ur Nichtregularit¨atsbeweise - Satz 3.1 (Kolmogorov) Sei L ⊆ (Σbool)∗ eine regul¨are Sprache. Sei Lx = {y ∈ (Σbool)∗ | xy ∈ L} f ¨ur jedes x ∈ (Σbool)∗. Dann existiert eine Konstante const, so dass f ¨ur alle x, y ∈ (Σbool)∗ K(y) ≤ ⌈log2(n + 1)⌉ + const, falls y das n-te Wort in der Sprache Lx ist. Beweis TODO. Der Beweis find ich auch relevant, auch wenn nicht aufgeschrieben. Wie wir sehen werden, beruht der Nichtregularit¨atsbeweis darauf, dass die Differenz von |wn+1| − |wn| f ¨ur kanonische W ¨orter (wi)i∈N beliebig gross werden kann. 70 Definition NEA Ein nichtdeterministischer endlicher Automat (NEA) ist ein Quintupel M = (Q, Σ, δ, q0, F). Dabei ist (i) Q eine endliche Menge, Zustandsmenge genannt, (ii) Σ ein Alphabet, Eingabealphabet genannt, (iii) q0 ∈ Q der Anfangszustand, (iv) F ⊆ Q die Menge der akzeptierenden Zust¨ande und (v) δ eine Funktion von Q × Σ nach P(Q), ¨Ubergangsfunktion genannt. Ein NEA kann zu einem Zustand q und einem gelesenen Zeichen a mehrere oder gar keinen Nachfolgezustand haben. 71 Potenzmengenkonstruktion Sei M = (Q, Σ, δM, q0, F) ein NEA. Wir konstrurieren einen ¨aquivalenten End- lichen Automaten A = (QA, ΣA, δA, q0A, FA). (i) QA = {⟨P⟩ | P ⊆ Q} (ii) ΣA = Σ (iii) q0A = ⟨{q0}⟩ (iv) FA = {⟨P⟩ | P ⊆ Q und P ∩ F ̸= ∅} (v) δA : (QA × ΣA) → QA ist eine Funktion, definiert wie folgt. F ¨ur jedes ⟨P⟩ ∈ QA und jedes a ∈ ΣA ist δA(⟨P⟩, a) = 〈 ⋃ p∈P δM(p, a) 〉 = ⟨{q ∈ Q | ∃p ∈ P, so dass q ∈ δM(p, a)}⟩ 72 Exponentiell mehr Zust¨ande - manchmal Sei Lk = {x1y | x ∈ (Σbool) ∗, y ∈ (Σbool)k−1} Folgender NEA Ak mit k + 1 Zust¨anden akzeptiert Lk. Abbildung 1: Abb. 3.19 im Buch 73 Exponentiell mehr Zust¨ande - manchmal Lemma 3.6 F ¨ur alle k ∈ N \\ {0} muss jeder EA, der Lk akzeptiert, mindestens 2k Zust¨ande haben. Beweis Sei Bk = (Qk, Σbool, δk, q0k, Fk) ein EA mit L(Bk) = Lk. Nach Lemma 3.3 gilt f ¨ur x, y ∈ (Σbool)∗: Wenn ˆδk(q0k, x) = ˆδk(q0k, y), dann gilt f ¨ur alle z ∈ (Σbool)∗: xz ∈ L(Bk) ⇐⇒ yz ∈ L(Bk) 74 Exponentiell mehr Zust¨ande - manchmal Die Idee des Beweises ist es, eine Menge Sk von W ¨ortern zu finden, so dass f ¨ur keine zwei unterschiedlichen W ¨orter x, y ∈ Sk die Gleichung ˆδk(q0k, x) = ˆδk(q0k, y) gelten darf. Dann m ¨usste Bk mindestens |Sk| viele Zust¨ande haben. Wir w¨ahlen Sk = (Σbool)k und zeigen, dass ˆδk(q0k, u) paarweise unterschiedliche Zust¨ande f ¨ur alle u ∈ Sk sind. Wir beweisen dies per Widerspruch. 75 Exponentiell mehr Zust¨ande - manchmal Seien x = x1x2...xk und y = y1y2...yk f ¨ur xi, yi ∈ Σbool, i ∈ {1, ..., k} zwei unterschiedliche W ¨orter aus Sk. Nehmen wir zum Widerspruch an, dass ˆδk(q0k, x) = ˆδk(q0k, y). Weil x ̸= y, existiert ein j ∈ {1, ..., k}, so dass xj ̸= yj. O.B.d.A. setzen wir xj = 1 und yj = 0. Betrachten wir nun z = 0j−1. Dann ist xz = x1...xj−11xj+1...xk0j−1 und yz = y1...yj−10yj+1...yk0j−1 und daher xz ∈ Lk und yz /∈ Lk. Dies ist ein Widerspruch! Folglich gilt ˆδk(q0k, x) ̸= ˆδk(q0k, y) f ¨ur alle paarweise unterschiedliche x, y ∈ Sk = (Σbool)k. Daher hat Bk mindestens |Sk| = 2k viele Zust¨ande. ■ 76 Turing Maschinen - Formalisierung von Algorithmen Informell Eine Turingmaschine besteht aus (i) einer endlichen Kontrolle, die das Programm enth¨alt, (ii) einem unendlichen Band, das als Eingabeband, aber auch als Speicher (Arbeitsband) zur Verf ¨ugung steht, und (iii) einem Lese-/Schreibkopf, der sich in beiden Richtungen auf dem Band bewegen kann. F ¨ur formale Beschreibung siehe Buch. 77 Turing Maschinen - Formalisierung von Algorithmen Elementare Operation einer TM - Informell Input - Zustand der Maschine (der Kontrolle) - Symbol auf dem Feld unter dem Lese-/Schreibkopf Aktion (i) ¨andert Zustand (ii) schreibt auf das Feld unter dem Lese-/Schreibkopf (iii) bewegt den Lese-/Schreibkopf nach links, rechts oder gar nicht. Ausser wenn g , dann ist links nicht m ¨oglich. 78 Mehrband-Turingmaschine Mehrband-TM - Informelle Beschreibung F ¨ur k ∈ N \\ {0} hat eine k-Band Turingmaschine - eine endliche Kontrolle - ein endliches Band mit einem Lesekopf (Eingabeband) - k Arbeitsb¨ander, jedes mit eigenem Lese-/Schreibkopf (nach rechts un- endlich) Insbesondere gilt 1-Band TM ̸= ”normale” TM Am Anfang der Berechnung einer MTM M auf w - Arbeitsb¨ander ”leer” und die k Lese-/Schreibk ¨opfe auf Position 0. - Inhalt des Eingabebands g w$ und Lesekopf auf Position 0. - Endliche Kontrolle im Zustand q0. 79 ¨Aquivalenz von Maschinen (TM, MTM) Seien A und B zwei Maschinen mit gleichem Σ. Wir sagen, dass A ¨aquivalent zu B ist, wenn f ¨ur jede Eingabe x ∈ Σ∗ (i) A akzeptiert x ⇐⇒ B akzeptiert x (ii) A verwirft x ⇐⇒ B verwirft x (iii) A arbeitet unendlich lange auf x ⇐⇒ B arbeitet unendlich lange auf x Wir haben A und B ¨aquivalent =⇒ L(A) = L(B) aber L(A) = L(B) ̸=⇒ A und B ¨aquivalent da A auf x unendlich lange arbeiten k ¨onnte, w¨ahrend B x verwirft. 80 ¨Aquivalenz von TM zu k-Band-TM Lemma 4.2 Zu jeder Mehrband-TM A existiert eine zu A ¨aquivalente TM B Beweisidee Vergr ¨osserung des Alphabets, jedes Zeichen enth¨alt jetzt 2(k + 1) Zeichen. B simuliert A einen Schritt von A indem es den ganzen Inhalt liest und dann durch die endliche Kontrolle von A jede Schreib und Bewegungsoperation einzeln ausf ¨uhrt. Dies verwendet immer nur endlich viele Schritte um einen Schritt von A zu simulieren. 81 Definition von NTM Eine nichtdeterministische Turingmaschine (NTM) ist ein 7-Tupel M = (Q, Σ, Γ, δ, q0, qaccept, qreject), wobei (i) Q, Σ, Γ, qaccept, qreject die gleiche Bedeutung wie bei einer TM haben, und (ii) δ : (Q\\{qaccept, qreject})×Γ → P(Q×Γ×{L, R, N}) die ¨Ubergangsfunktion von M ist und die folgende Eigenschaft hat: δ(p, g ) ⊆ {(q, g , X) | q ∈ Q, X ∈ {R, N}} f ¨ur alle p ∈ Q Konfiguration ¨ahnlich wie bei TMs. Konfiguration akzeptierend ⇐⇒ enth¨alt qaccept Konfiguration verwerfend ⇐⇒ enth¨alt qreject 82 Berechnungsbaum Sei M = (Q, Σ, Γ, δ, q0, qaccept, qreject) eine NTM und sei x ein Wort ¨uber dem Eingabealphabet Σ von M. Ein Berechnungsbaum TM,x von M auf x ist ein (potentiell unendlicher) gerichteter Baum mit einer Wurzel, der wie folgt defi- niert wird. (i) Jeder Knoten von TM,x ist mit einer Konfiguration beschriftet. (ii) Die Wurzel ist der einzige Knoten von TM,x mit dem Eingangsgrad 0 und ist mit der Startkonfiguration q0g x beschriftet. (iii) Jeder Knoten des Baumes, der mit einer Konfiguration C beschriftet ist, hat genauso viele Kinder wie C Nachfolgekonfigurationen hat, und diese Kinder sind mit diesen Nachfolgekonfigurationen C markiert. 83 ¨Aquivalenz NTM und TM Satz 4.2 Sei M eine NTM. Dann existiert eine TM A, so dass (i) L(M) = L(A) und (ii) falls M keine unendlichen Berechnungen auf W ¨ortern aus L(M)∁ hat, dann h¨alt A immer. Beweisidee: ”BFS im Berechnungsbaum”, i.e. wir simulieren einzelne Schritte der verschiedenen Berechnungsstr¨ange mit zwei B¨andern, wobei das erste Band alle Konfigurationen der besuchten Schicht speichert und das zweite alle Konfigurationen der n¨achsten Schicht. Wenn eine akzeptierende Konfiguration erreicht wird, dann akzeptiert A. Wenn keine weitere Konfiguration erreichbar ist, dann verwirft A (eine verwerfende Konfiguration wird ohne weiteres normal behandelt). 84 Abz¨ahlbarkeit Lemma 5.2 (N \\ {0}) × (N \\ {0}) ist abz¨ahlbar. Beweisidee Unendliche 2-dimensionale Tabelle, so dass an der i-ten Zeile und j-ten Spalte, sich das Element (i, j) ∈ (N \\ {0}) × (N \\ {0}) befindet. Formal definiert man dabei die lineare Ordnung (a, b) < (c, d) ⇐⇒ a + b < c + d oder (a + b = c + d und b < d) 85 Abz¨ahlbarkeit Abbildung 2: Abbildung 5.3 im Buch 86 Abz¨ahlbarkeit Die i-te Diagonale hat i Elemente. Ein beliebiges Element (a, b) ∈ (N \\ {0}) × (N \\ {0}) ist das b-te Element auf der (a + b − 1)-ten Diagonale. Auf den ersten a + b − 2 Diagonalen gibt es a+b−2∑ i=1 i = (a + b − 2) · ((a + b − 2) + 1) 2 = (a + b − 1 2 ) Elemente. Folglich ist f ((a, b)) = (a + b − 1 2 ) + b eine Bijektion von (N \\ {0}) × (N \\ {0}) nach N \\ {0}. 87 ¨Uberabz¨ahlbarkeit Satz 5.3 [0, 1] ist nicht abz¨ahlbar. Beweisidee Klassisches Diagonalisierungsargument. Aufpassen auf 0 und 9. I.e. 1 = 0.99. 88 ¨Uberabz¨ahlbarkeit 89 ¨Uberabz¨ahlbarkeit Satz 5.4 P((Σbool)∗) ist nicht abz¨ahlbar. Beweis: Wir definieren eine injektive Funktion von f : [0, 1] → P((Σbool)∗) und beweisen so |P((Σbool)∗)| ≥ |[0, 1]|. Sei a ∈ [0, 1] beliebig. Wir k ¨onnen a wie folgt bin¨ar darstellen: Nummer(a) = 0.a1a2a3a4... mit a = ∞∑ i=1 ai · 2−i. Hier ist zu beachten, dass wir f ¨ur eine Zahl a immer die lexikographisch letzte Darstellung w¨ahlen. 90 ¨Uberabz¨ahlbarkeit Dies tun wir, weil eine reelle Zahl 2 verschiedene Bin¨ardarstellungen haben kann. Beispiel: 1 2 = 0.10 = 0.01. F ¨ur jedes a definieren wir: f (a) = {a1, a2a3, a4a5a6, ..., a(n 2)+1a( n 2)+2...a(n+1 2 ), ...} Da f (a) ⊆ (Σbool)∗ gilt f (a) ∈ P((Σbool)∗). Wir haben f ¨ur alle n ∈ N \\ {0}, dass f (a) genau ein Wort dieser L¨ange enth¨alt. Nun k ¨onnen wir daraus folgendes schliessen: Weil die Bin¨ardarstellung zweier unterschiedlichen reellen Zahlen an mindestens einer Stelle unterschiedlich ist, gilt b ̸= c =⇒ f (b) ̸= f (c), ∀b, c ∈ [0, 1]. 91 ¨Uberabz¨ahlbarkeit Folglich ist f injektiv und wir haben |P((Σbool)∗)| ≥ |[0, 1]|. Da [0, 1] nicht abz¨ahlbar ist, folgt daraus: P((Σbool)∗) ist nicht abz¨ahlbar. ■ 92 Diagonalsprache Ldiag Zur Erinnerung: Rekursiv aufz¨ahlbare Sprachen Eien Sprache L ⊆ Σ∗ heisst rekursiv aufz¨ahlbar, falls eine TM M existiert, so dass L = L(M). LRE = {L(M) | M ist eine TM} ist die Klasse aller rekursiv aufz¨ahlbaren Sprachen. Wir zeigen jetzt per Diagonalisierung, die Existenz einer Sprache die nicht rekursiv aufz¨ahlbar ist. 93 Diagonalsprache Ldiag Sei w1, w2, ... die kanonische Ordnung aller W ¨orter ¨uber Σbool und sei M1, M2, M3, ... die Folge aller Turingmaschinen. Wir definieren eine unendliche (bool’sche) Matrix A = [dij]i,j=1,2,... mit dij = 1 ⇐⇒ Mi akzeptiert wj. Wir definieren Ldiag = {w | w = wi und Mi akzeptiert wi nicht f ¨ur ein i ∈ N \\ {0}} 94 Diagonalsprache Ldiag Satz 5.5 Ldiag /∈ LRE Beweis: Wir haben Ldiag = {w | w = wi und Mi akzeptiert wi nicht f ¨ur ein i ∈ N \\ {0}} Widerspruchsbeweis: Sei Ldiag ∈ LRE. Dann existiert eine TM M, so dass L(M) = Ldiag. Da diese TM eine TM in der Nummerierung aller TM ist, existiert ein i ∈ N, so dass Mi = M. 95 Diagonalsprache Ldiag Wir betrachten nun das Wort wi f ¨ur diese i ∈ N. Per Definition von Ldiag, gilt: wi ∈ Ldiag ⇐⇒ wi /∈ L(Mi) Da aber L(Mi) = Ldiag, haben wir folgenden Widerspruch: wi ∈ Ldiag ⇐⇒ wi /∈ Ldiag Folglich gilt Ldiag /∈ LRE. ■ 96","libVersion":"0.3.2","langs":""}