{"path":"sem4/FMFP/VRL/extra/wiley.pdf","text":"SEMANTICS WITH APPLICATIONS A Formal Introduction c⃝Hanne Riis Nielson c⃝Flemming Nielson c⃝The webpage http://www.daimi.au.dk/∼hrn contains information about how to download a copy of this book (sub- ject to the conditions listed below). The book may be downloaded and printed free of charge for personal study; it may be downloaded and printed free of charge by instructors for immediate photocopying to stu- dents provided that no fee is charged for the course; these permissions explicitly exclude the right to any other distri- bution of the book (be it electronically or by making physical copies). All other distribution should be agreed with the authors. This is a revised edition completed in July 1999; the original edition from 1992 was published by John Wiley & Sons; this should be acknowledged in all references to the book. i Contents List of Tables vii Preface ix 1 Introduction 1 1.1 Semantic description methods . . . . . . . . . . . . . . . . . . . . . 1 1.2 The example language While . . . . . . . . . . . . . . . . . . . . . 7 1.3 Semantics of expressions . . . . . . . . . . . . . . . . . . . . . . . . 9 1.4 Properties of the semantics . . . . . . . . . . . . . . . . . . . . . . . 15 2 Operational Semantics 19 2.1 Natural semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 2.2 Structural operational semantics . . . . . . . . . . . . . . . . . . . . 32 2.3 An equivalence result . . . . . . . . . . . . . . . . . . . . . . . . . . 40 2.4 Extensions of While . . . . . . . . . . . . . . . . . . . . . . . . . . 44 2.5 Blocks and procedures . . . . . . . . . . . . . . . . . . . . . . . . . 50 3 Provably Correct Implementation 63 3.1 The abstract machine . . . . . . . . . . . . . . . . . . . . . . . . . . 63 3.2 Speciﬁcation of the translation . . . . . . . . . . . . . . . . . . . . . 69 3.3 Correctness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 3.4 An alternative proof technique . . . . . . . . . . . . . . . . . . . . . 81 4 Denotational Semantics 85 4.1 Direct style semantics: speciﬁcation . . . . . . . . . . . . . . . . . . 85 4.2 Fixed point theory . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 4.3 Direct style semantics: existence . . . . . . . . . . . . . . . . . . . . 107 4.4 An equivalence result . . . . . . . . . . . . . . . . . . . . . . . . . . 112 4.5 Extensions of While . . . . . . . . . . . . . . . . . . . . . . . . . . 117 5 Static Program Analysis 133 5.1 Properties and property states . . . . . . . . . . . . . . . . . . . . . 135 5.2 The analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142 v vi Contents List of Tables 1.1 The semantics of arithmetic expressions . . . . . . . . . . . . . . . . 13 1.2 The semantics of boolean expressions . . . . . . . . . . . . . . . . . 14 2.1 Natural semantics for While . . . . . . . . . . . . . . . . . . . . . . 20 2.2 Structural operational semantics for While . . . . . . . . . . . . . 33 2.3 Natural semantics for statements of Block . . . . . . . . . . . . . . 52 2.4 Natural semantics for variable declarations . . . . . . . . . . . . . . 52 2.5 Natural semantics for Proc with dynamic scope rules . . . . . . . . 54 2.6 Procedure calls in case of mixed scope rules (choose one) . . . . . . 56 2.7 Natural semantics for variable declarations using locations . . . . . 58 2.8 Natural semantics for Proc with static scope rules . . . . . . . . . 59 3.1 Operational semantics for AM . . . . . . . . . . . . . . . . . . . . 65 3.2 Translation of expressions . . . . . . . . . . . . . . . . . . . . . . . 70 3.3 Translation of statements in While . . . . . . . . . . . . . . . . . . 71 4.1 Denotational semantics for While . . . . . . . . . . . . . . . . . . . 86 4.2 Denotational semantics for While using locations . . . . . . . . . . 119 4.3 Denotational semantics for variable declarations . . . . . . . . . . . 121 4.4 Denotational semantics for non-recursive procedure declarations . . 122 4.5 Denotational semantics for Proc . . . . . . . . . . . . . . . . . . . 123 4.6 Denotational semantics for recursive procedure declarations . . . . . 125 4.7 Continuation style semantics for While . . . . . . . . . . . . . . . . 128 4.8 Continuation style semantics for Exc . . . . . . . . . . . . . . . . . 130 5.1 Analysis of expressions . . . . . . . . . . . . . . . . . . . . . . . . . 143 5.2 Analysis of statements in While . . . . . . . . . . . . . . . . . . . 144 6.1 Axiomatic system for partial correctness . . . . . . . . . . . . . . . 178 6.2 Axiomatic system for total correctness . . . . . . . . . . . . . . . . 192 6.3 Exact execution times for expressions . . . . . . . . . . . . . . . . . 202 6.4 Natural semantics for While with exact execution times . . . . . . 203 6.5 Axiomatic system for order of magnitude of execution time . . . . . 204 vii viii List of Tables Preface Many books on formal semantics begin by explaining that there are three major approaches to semantics, that is • operational semantics, • denotational semantics, and • axiomatic semantics; but then they go on to study just one of these in greater detail. The purpose of this book is to • present the fundamental ideas behind all of these approaches, • to stress their relationship by formulating and proving the relevant theorems, and • to illustrate the applicability of formal semantics as a tool in computer science. This is an ambitious goal and to achieve it, the bulk of the development con- centrates on a rather small core language of while-programs for which the three approaches are developed to roughly the same level of sophistication. To demon- strate the applicability of formal semantics we show • how to use semantics for validating prototype implementations of program- ming languages, • how to use semantics for verifying analyses used in more advanced imple- mentations of programming languages, and • how to use semantics for verifying useful program properties including infor- mation about execution time. The development is introductory as is already reﬂected in the title. For this rea- son very many advanced concepts within operational, denotational and axiomatic semantics have had to be omitted. Also we have had to omit treatment of other approaches to semantics, for example Petri-nets and temporal logic. Some pointers to further reading are given in Chapter 7. ix x PrefacePreface xixii Preface Chapter 1 Introduction The purpose of this book is • to describe some of the main ideas and methods used in semantics, • to illustrate these on interesting applications, and • to investigate the relationship between the various methods. Formal semantics is concerned with rigorously specifying the meaning, or be- haviour, of programs, pieces of hardware etc. The need for rigour arises because • it can reveal ambiguities and subtle complexities in apparently crystal clear deﬁning documents (for example programming language manuals), and • it can form the basis for implementation, analysis and veriﬁcation (in par- ticular proofs of correctness). We will use informal set theoretic notation (reviewed in Appendix A) to represent semantic concepts. This will suﬃce in this book but for other purposes greater notational precision (that is, formality) may be needed, for example when process- ing semantic descriptions by machine as in semantics directed compiler-compilers or machine assisted proof checkers. 1.1 Semantic description methods It is customary to distinguish between the syntax and the semantics of a pro- gramming language. The syntax is concerned with the grammatical structure of programs. So a syntactic analysis of the program z:=x; x:=y; y:=z 1 2 1 Introduction1.1 Semantic description methods 34 1 Introduction1.1 Semantic description methods 56 1 Introduction1.2 The example language While 78 1 Introduction1.3 Semantics of expressions 910 1 Introduction1.3 Semantics of expressions 1112 1 Introduction1.3 Semantics of expressions 1314 1 Introduction1.4 Properties of the semantics 1516 1 Introduction1.4 Properties of the semantics 1718 1 Introduction Chapter 2 Operational Semantics The role of a statement in While is to change the state. For example, if x is bound to 3 in s and we execute the statement x := x + 1 then we get a new state where x is bound to 4. So while the semantics of arithmetic and boolean expressions only inspect the state in order to determine the value of the expression, the semantics of statements will modify the state as well. In an operational semantics we are concerned with how to execute programs and not merely what the results of execution are. More precisely, we are interested in how the states are modiﬁed during the execution of the statement. We shall consider two diﬀerent approaches to operational semantics: • Natural semantics: its purpose is to describe how the overall results of exe- cutions are obtained. • Structural operational semantics: its purpose is to describe how the individual steps of the computations take place. We shall see that for the language While we can easily specify both kinds of semantics and that they will be “equivalent” in a sense to be made clear later. However, we shall also give examples of programming constructs where one of the approaches is superior to the other. For both kinds of operational semantics, the meaning of statements will be speciﬁed by a transition system. It will have two types of conﬁgurations: ⟨S , s⟩ representing that the statement S is to be executed from the state s, and s representing a terminal (that is ﬁnal) state. The terminal conﬁgurations will be those of the latter form. The transition relation will then describe how the execution takes place. The diﬀerence between the two approaches to operational semantics amounts to diﬀerent ways of specifying the transition relation. 19 20 2 Operational Semantics2.1 Natural semantics 2122 2 Operational Semantics2.1 Natural semantics 2324 2 Operational Semantics2.1 Natural semantics 2526 2 Operational Semantics2.1 Natural semantics 2728 2 Operational Semantics2.1 Natural semantics 2930 2 Operational Semantics2.1 Natural semantics 3132 2 Operational Semantics2.2 Structural operational semantics 3334 2 Operational Semantics2.2 Structural operational semantics 3536 2 Operational Semantics2.2 Structural operational semantics 3738 2 Operational Semantics2.2 Structural operational semantics 3940 2 Operational Semantics2.3 An equivalence result 4142 2 Operational Semantics2.3 An equivalence result 4344 2 Operational Semantics2.4 Extensions of While 4546 2 Operational Semantics2.4 Extensions of While 4748 2 Operational Semantics2.4 Extensions of While 4950 2 Operational Semantics2.5 Blocks and procedures 5152 2 Operational Semantics2.5 Blocks and procedures 5354 2 Operational Semantics2.5 Blocks and procedures 5556 2 Operational Semantics2.5 Blocks and procedures 5758 2 Operational Semantics2.5 Blocks and procedures 5960 2 Operational Semantics2.5 Blocks and procedures 6162 2 Operational Semantics Chapter 3 Provably Correct Implementation A formal speciﬁcation of the semantics of a programming language is useful when implementing it. In particular, it becomes possible to argue about the correctness of the implementation. We shall illustrate this by showing how to translate the language While into a structured form of assembler code for an abstract machine and we shall then prove that the translation is correct. The idea is that we ﬁrst de- ﬁne the meaning of the abstract machine instructions by an operational semantics. Then we deﬁne translation functions that will map expressions and statements in the While language into sequences of such instructions. The correctness result will then state that if we • translate a program into code, and • execute the code on the abstract machine, then we get the same result as was speciﬁed by the semantic functions S ns and S sos of the previous chapter. 3.1 The abstract machine When specifying the abstract machine it is convenient ﬁrst to present its conﬁgu- rations and next its instructions and their meanings. The abstract machine AM has conﬁgurations of the form ⟨c, e, s⟩ where • c is the sequence of instructions (or code) to be executed, • e is the evaluation stack, and • s is the storage. We use the evaluation stack to evaluate arithmetic and boolean expressions. For- mally, it is a list of values, so writing 63 64 3 Provably Correct Implementation3.1 The abstract machine 6566 3 Provably Correct Implementation3.1 The abstract machine 6768 3 Provably Correct Implementation3.2 Speciﬁcation of the translation 6970 3 Provably Correct Implementation3.2 Speciﬁcation of the translation 7172 3 Provably Correct Implementation3.3 Correctness 7374 3 Provably Correct Implementation3.3 Correctness 7576 3 Provably Correct Implementation3.3 Correctness 7778 3 Provably Correct Implementation3.3 Correctness 7980 3 Provably Correct Implementation3.4 An alternative proof technique 8182 3 Provably Correct Implementation3.4 An alternative proof technique 8384 3 Provably Correct Implementation Chapter 4 Denotational Semantics In the operational approach we were interested in how a program is executed. This is contrary to the denotational approach where we are merely interested in the eﬀect of executing a program. By eﬀect we here mean an association between initial states and ﬁnal states. The idea then is to deﬁne a semantic function for each syntactic category. It maps each syntactic construct to a mathematical object, often a function, that describes the eﬀect of executing that construct. The hallmark of denotational semantics is that semantic functions are deﬁned compositionally, that is • there is a semantic clause for each of the basis elements of the syntactic category, and • for each method of constructing a composite element (in the syntactic cate- gory) there is a semantic clause deﬁned in terms of the semantic function applied to the immediate constituents of the composite element. The functions A and B deﬁned in Chapter 1 are examples of denotational deﬁni- tions: the mathematical objects associated with arithmetic expressions are func- tions in State → Z and those associated with boolean expressions are functions in State → T. The functions S ns and S sos associate mathematical objects with each statement, namely partial functions in State ֒→ State. However, they are not examples of denotational deﬁnitions because they are not deﬁned compositionally. 4.1 Direct style semantics: speciﬁcation The eﬀect of executing a statement S is to change the state so we shall deﬁne the meaning of S to be a partial function on states: S ds: Stm → (State ֒→ State) 85 86 4 Denotational Semantics4.1 Direct style semantics: speciﬁcation 8788 4 Denotational Semantics4.1 Direct style semantics: speciﬁcation 8990 4 Denotational Semantics4.1 Direct style semantics: speciﬁcation 9192 4 Denotational Semantics4.2 Fixed point theory 9394 4 Denotational Semantics4.2 Fixed point theory 9596 4 Denotational Semantics4.2 Fixed point theory 9798 4 Denotational Semantics4.2 Fixed point theory 99100 4 Denotational Semantics4.2 Fixed point theory 101102 4 Denotational Semantics4.2 Fixed point theory 103104 4 Denotational Semantics4.2 Fixed point theory 105106 4 Denotational Semantics4.3 Direct style semantics: existence 107108 4 Denotational Semantics4.3 Direct style semantics: existence 109110 4 Denotational Semantics4.3 Direct style semantics: existence 111112 4 Denotational Semantics4.4 An equivalence result 113114 4 Denotational Semantics4.4 An equivalence result 115116 4 Denotational Semantics4.5 Extensions of While 117118 4 Denotational Semantics4.5 Extensions of While 119120 4 Denotational Semantics4.5 Extensions of While 121122 4 Denotational Semantics4.5 Extensions of While 123124 4 Denotational Semantics4.5 Extensions of While 125126 4 Denotational Semantics4.5 Extensions of While 127128 4 Denotational Semantics4.5 Extensions of While 129130 4 Denotational Semantics4.5 Extensions of While 131132 4 Denotational Semantics Chapter 5 Static Program Analysis When implementing a programming language it is crucial that the implementa- tion is faithful to the semantics of the language and in Chapter 3 we saw how the operational semantics could be used to prove this formally. However, it is also im- portant that the implementation is reasonably eﬃcient and it is therefore common to combine the code generation with various analyses collecting information about the programs. In this chapter we shall develop one such analysis in detail but let us ﬁrst consider a couple of example analyses. Constant propagation is an analysis that determines whether an expression always evaluates to a constant value and if so determines that value. The analysis is the basis for an optimization called constant folding where the expression is replaced by the constant. As an example the analysis will detect that the value of y in the statement x := 5; y := x ⋆ x + 25 will always be 50. It is therefore safe to replace the statement by x := 5; y := 50 and more eﬃcient code can be generated. Another example is the detection of signs analysis where the idea is to deter- mine the sign of expressions. So it will for example determine that the value of y in y := x ⋆ x + 25 always will be positive (independently of the value assigned to x). This information will be useful for an optimization known as code elimination: in a statement as y := x ⋆ x + 25; while y ≤ 0 do · · · 133 134 5 Static Program Analysis5.1 Properties and property states 135136 5 Static Program Analysis5.1 Properties and property states 137138 5 Static Program Analysis5.1 Properties and property states 139140 5 Static Program Analysis5.1 Properties and property states 141142 5 Static Program Analysis5.2 The analysis 143144 5 Static Program Analysis5.2 The analysis 145146 5 Static Program Analysis5.2 The analysis 147148 5 Static Program Analysis5.2 The analysis 149150 5 Static Program Analysis5.2 The analysis 151152 5 Static Program Analysis5.3 Safety of the analysis 153154 5 Static Program Analysis5.3 Safety of the analysis 155156 5 Static Program Analysis5.3 Safety of the analysis 157158 5 Static Program Analysis5.3 Safety of the analysis 159160 5 Static Program Analysis5.4 Bounded iteration 161162 5 Static Program Analysis5.4 Bounded iteration 163164 5 Static Program Analysis5.4 Bounded iteration 165166 5 Static Program Analysis5.4 Bounded iteration 167168 5 Static Program Analysis Chapter 6 Axiomatic Program Veriﬁcation The kinds of semantics we have seen so far specify the meaning of programs al- though they may also be used to prove that given programs possess certain proper- ties. We may distinguish between several classes of properties: partial correctness properties are properties expressing that if a given program terminates then there will be a certain relationship between the initial and the ﬁnal values of the vari- ables. Thus a partial correctness property of a program need not ensure that it terminates. This is contrary to total correctness properties which express that the program will terminate and that there will be a certain relationship between the initial and the ﬁnal values of the variables. Thus we have partial correctness + termination = total correctness Yet another class of properties is concerned with the resources used when executing the program. An example is the time used to execute the program on a particular machine. 6.1 Direct proofs of program correctness In this section we shall give some examples that prove partial correctness of state- ments based directly on the operational and denotational semantics. We shall prove that the factorial statement y := 1; while ¬(x=1) do (y := y⋆x; x := x−1) is partially correct, that is if the statement terminates then the ﬁnal value of y will be the factorial of the initial value of x. Natural semantics Using natural semantics the partial correctness of the factorial statement can be formalized as follows: 169 170 6 Axiomatic Program Veriﬁcation6.1 Direct proofs of program correctness 171172 6 Axiomatic Program Veriﬁcation6.1 Direct proofs of program correctness 173174 6 Axiomatic Program Veriﬁcation6.2 Partial correctness assertions 175176 6 Axiomatic Program Veriﬁcation6.2 Partial correctness assertions 177178 6 Axiomatic Program Veriﬁcation6.2 Partial correctness assertions 179180 6 Axiomatic Program Veriﬁcation6.2 Partial correctness assertions 181182 6 Axiomatic Program Veriﬁcation6.3 Soundness and completeness 183184 6 Axiomatic Program Veriﬁcation6.3 Soundness and completeness 185186 6 Axiomatic Program Veriﬁcation6.3 Soundness and completeness 187188 6 Axiomatic Program Veriﬁcation6.3 Soundness and completeness 189190 6 Axiomatic Program Veriﬁcation6.4 Extensions of the axiomatic system 191192 6 Axiomatic Program Veriﬁcation6.4 Extensions of the axiomatic system 193194 6 Axiomatic Program Veriﬁcation6.4 Extensions of the axiomatic system 195196 6 Axiomatic Program Veriﬁcation6.4 Extensions of the axiomatic system 197198 6 Axiomatic Program Veriﬁcation6.4 Extensions of the axiomatic system 199200 6 Axiomatic Program Veriﬁcation6.5 Assertions for execution time 201202 6 Axiomatic Program Veriﬁcation6.5 Assertions for execution time 203204 6 Axiomatic Program Veriﬁcation6.5 Assertions for execution time 205206 6 Axiomatic Program Veriﬁcation6.5 Assertions for execution time 207208 6 Axiomatic Program Veriﬁcation Chapter 7 Further Reading In this book we have covered the basic ingredients in three approaches to semantics: • operational semantics, • denotational semantics, and • axiomatic semantics. We have concentrated on a rather simple language of while-programs and have studied the underlying theories and the formal relationships between the various approaches. The power of the three approaches have been illustrated by vari- ous extensions of While: non-determinism, parallelism, recursive procedures and exceptions. We believe that formal semantics is an important tool for reasoning about many aspects of the behaviour of programs and programming languages. To support this belief we have given three examples, one for each approach to semantics: • a simple compiler, • a static program analysis, and • an inference system for execution time. In conclusion we shall provide a few pointers to the literature (mainly textbooks) where a more comprehensive treatment of language features or theoretical aspects may be found. We do not reference the vast number of research publications in the area but rely on the references in the books mentioned. Operational semantics Structural operational semantics was introduced by Gordon Plotkin in [14]. This is a standard reference and covers a number of features from imperative and func- tional languages whereas features from parallel languages are covered in [15]. A 209 210 7 Further Reading211212 7 Further Reading Appendix A Review of Notation We use the following notation: ∃ there exists ∀ for all { x | . . .x . . . } the set of those x such that . . .x . . . holds x ∈ X x is a member of the set X X ⊆ Y set X is contained in set Y X ∪ Y { z | z ∈X or z ∈Y } (union) X ∩ Y { z | z ∈X and z ∈Y } (intersection) X \\ Y { z | z ∈X and z ̸∈Y } (set diﬀerence) X × Y { ⟨x , y⟩ | x ∈X and y∈Y } (Cartesian product) P(X ) { Z | Z ⊆ X } (powerset) ⋃ Y { y | ∃Y ∈Y: y∈Y } (so that ⋃ { Y 1, Y 2 } = Y 1∪Y 2) ∅ the empty set T { tt, ﬀ } (truth values tt (true) and ﬀ (false)) N { 0, 1, 2, . . . } (natural numbers) Z { . . ., –2, –1, 0, 1, 2, . . . } (integers) f :X →Y f is a total function from X to Y X →Y { f | f :X →Y } f :X ֒→Y f is a partial function from X to Y X ֒→Y { f | f :X ֒→Y } In addition to this we have special notations for functions, relations, predicates 213 214 A Review of Notation215216 A Review of Notation Appendix B Introduction to Miranda Implementations In this appendix we give the basic deﬁnitions needed to implement the various semantic deﬁnitions in Miranda. Essentially, this amounts to an implementation of the material of Chapter 1. B.1 Abstract syntax For Num we choose the primitive type num of Miranda. For Var we choose strings of characters and so deﬁne the type synonym: > var == [char] For each of the syntactic categories Aexp, Bexp and Stm we deﬁne an algebraic data type taking into account the various possibilities mentioned by the BNF syntax of Section 1.2: > aexp ::= N num | V var | Add aexp aexp | > Mult aexp aexp | Sub aexp aexp > bexp ::= TRUE | FALSE | Eq aexp aexp | Le aexp aexp | > Neg bexp | And bexp bexp > stm ::= Ass var aexp | Skip | Comp stm stm | > If bexp stm stm | While bexp stm Example B.1 The factorial statement of Exercise 1.1 is represented by 217 218 B Introduction to Miranda ImplementationsB.2 Evaluation of expressions 219220 B Introduction to Miranda Implementations Appendix C Operational Semantics in Miranda In this appendix we implement the natural semantics and the structural opera- tional semantics of Chapter 2 in Miranda and show how similar techniques can be used to implement an interpreter for the abstract machine and the code generation of Chapter 3. We shall need the deﬁnitions from Appendix B so we begin by including these: > %include 222 C Operational Semantics in MirandaC.2 Structural operational semantics 223224 C Operational Semantics in MirandaC.3 Extensions of While 225226 C Operational Semantics in MirandaC.4 Provably correct implementation 227228 C Operational Semantics in Miranda Appendix D Denotational Semantics in Miranda In this appendix we implement the denotational semantics of Chapter 4 in Mi- randa and show how similar techniques can be used to implement the static program analysis of Chapter 5. We shall need the deﬁnitions from Appendix B so we begin by including these: > %include 230 D Denotational Semantics in MirandaD.3 Static program analysis 231232 D Denotational Semantics in Miranda Bibliography [1] S. Abramsky, C. Hankin: Abstract Interpretation of Declarative Languages, Ellis Horwood (1987). [2] A. V. Aho, J. E. Hopcroft, J. D. Ullman: Data Structures and Algorithms, Addison–Wesley (1982). [3] A. V. Aho, R. Sethi, J. D. Ullman: Compilers: Principles, Techniques and Tools, Addison–Wesley (1986). [4] K. R. Apt: Ten Years of Hoare’s Logic: A Survey — Part 1, ACM Toplas 3 4 (1981). [5] J. W. de Bakker: Mathematical Theory of Program Correctness, Prentice-Hall (1980). [6] D. Cl´ement, J. Despeyroux, T. Despeyroux, G. Kahn: A simple applicative language: Mini-ML, Proceedings of the 1986 ACM Conference on Lisp and Functional Programming (1986). [7] J. Despeyroux: Proof of translation in natural semantics, Proceedings of Symposium on Logic in Computer Science, Cambridge, Massachusetts, USA (1986). [8] M. J. C. Gordon: The Denotational Description of Programming Languages, An Introduction, Springer-Verlag (1979). [9] M. Hennessy: The Semantics of Programming Languages: An Elementary Introduction using Structural Operational Semantics, Wiley (1991). [10] C. B. Jones: Software Development: A Rigorous Approach, Prentice-Hall (1980). [11] J. Loeckx, K. Sieber: The Foundations of Program Veriﬁcation, Wiley– Teubner Series in Computer Science (1984). [12] H. R. Nielson: A Hoare-like proof system for run-time analysis of programs, Science of Computer Programming, vol 9 (1987). 233 234 Bibliography Index of Symbols (P, ⊑P), 136 (PState, ⊑PS), 140 (PState → PState, ⊑), 148 (State ֒→ State, ⊑), 93 (D, ⊑D), 95 · · ·[· · ·↦−→· · ·], 51 · · ·[· · ·↦→· · ·], 16, 17, 177, 214 · · ·≡ · · ·rel 236 Index of Symbols Index abort-construct, 44 abstract machine, 63 abstract syntax, 7 additive function, 163 admissible predicate, 173 anti-symmetric relation, 95 arithmetic expression, 7 analysis, 142 execution time, 201 semantics, 12 translation, 70 assert-construct, 46 assertion, 175 axiom, 20 axiomatic semantics, 178 basis element, 7 begin-construct, 51, 117, 126 bisimulation relation, 81 boolean expression, 7 analysis, 142 execution time, 201 semantics, 14 translation, 70 call-construct, 53, 117, 197 call-by-value parameter, 60, 126 ccpo, 99 chain, 97 chain complete partially ordered set, 99 code generation, 69 complete lattice, 99 completeness, 183 of partial correctness inference sys- tem, 187 of total correctness inference sys- tem, 196 composite element, 7 compositional deﬁnition, 11 computation sequence, 66 concrete syntax, 7 conﬁguration, 216 ﬁnal, 216 stuck, 216 terminal, 216 constant propagation, 133 continuation, 127 continuation style semantics, 127 continuous function, 103 correct implementation, 73 declared variable, 51 denotational semantics, 85 continuation style, 127 direct style, 85 dependency analysis, 134 derivation sequence, 33 derivation tree, 22 detection of signs analysis, 133 deterministic semantics, 28, 38, 68 direct style semantics, 85 dubious, 135 dynamic scope, 53 equivalence relation, 141 evaluation stack, 64 exception, 126 exception environment, 130 237 238 IndexIndex 239240 Index","libVersion":"0.3.2","langs":""}