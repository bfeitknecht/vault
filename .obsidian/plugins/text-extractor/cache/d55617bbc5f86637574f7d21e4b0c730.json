{"path":"sem2a/AuW/UE/u/c/AuW-u02-bf-c.pdf","text":"AuW-u02-bf a) For the purpose of simplicity, let be the mapping of numerical values corresponding to the card values. Note, that this mapping is arbitrarily chosen and does not inﬂuence the outcome. Let be a function returning every cards numerical value. Let be some auxiliary deﬁnitions and the deﬁnition of the bipartite Graph , representing the stacks of playing cards and the values they contain. Let be the bipartite graph representing the exclusive union of the partition of stacks of cards and let an edge between a stack of cards and a value denote, that there exists (at least) a card of said value in the aforementioned stack. Construction of the graph takes time. The algorithm is Which is again, . ö return true (Ban · quakes W b) A straightforward approach is to iterate over all possible combinations, which, given the constant number of cards, takes : A more eﬃcient approach is to use the fact, that is bipartite (let the two partitions be the stacks and card values). We can use the Hopcroft-Karp algorithm to ﬁnd a perfect matching (which exists, since is bipartite). We pick all cards in the perfect matching's vertex set. Runtime analysis Graph construction: Hopcroft-Karp algorithm: Thus the algorithm has constant runtime. // pick-cards(stack S1, S2, ... S9) picked = {} for stack Si do card ci_fmax = {} for card cj in stack Si if f(cj) > f(ci_fmax) do if !picked.contains(val(cj)) do picked.add(cj) elseif !picked.contains(val(ci_fmax)) do picked.add(ci_fmax) else backtrack() end end end end function backtrack() picked.remove(#picked) // remove card last added go back to last decision if !pick-different-possible do backtrack() else pick-different end end function pick different() pick a different card and continue end print(picked) - v It doesn't follow fra being bipartite , unfortunately V Orealyo usubmission wa s eremely clean , definitely on the levelofe Unfortunately , I ca onlygive you 1 Pt ., sinc e the graph having a perfect matching isn't a trivial condition an d therefore your Algorithm in a) lacks a proof of correctness . (Which in this cas e is the most important part because the algo is so simple) . See the master solution for how to do that . Keep up the good work !","libVersion":"0.3.2","langs":""}