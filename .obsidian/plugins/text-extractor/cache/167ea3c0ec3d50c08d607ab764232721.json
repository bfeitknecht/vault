{"path":"HS23/AuD/UE/s/AuD-u07-s.pdf","text":"Eidgen¨ossische Technische Hochschule Z¨urich Ecole polytechnique f´ed´erale de Zurich Politecnico federale di Zurigo Federal Institute of Technology at Zurich Departement of Computer Science 6 November 2023 Johannes Lengler, David Steurer Lucas Slot, Manuel Wiedmer, Hongjie Chen, Ding Jingqiu Algorithms & Data Structures Exercise sheet 7 HS 23 The solutions for this sheet are submitted at the beginning of the exercise class on 13 November 2023. Exercises that are marked by ∗ are challenge exercises. They do not count towards bonus points. You can use results from previous parts without solving those parts. Exercise 7.1 1-3 subset sums (1 point). Let A[1, . . . , n] be an array containing n positive integers, and let b ∈ N. We want to know if there exists a subset I ⊆ {1, 2, . . . , n}, together with multipliers ci ∈ {1, 3}, i ∈ I such that: b = ∑ i∈I ci · A[i]. If this is possible, we say b is a 1-3 subset sum of A. For example, if A = [16, 4, 2, 7, 11, 1] and b = 61, we could write b = 3 · 16 + 4 + 3 · 2 + 3 · 1. Describe a DP algorithm that, given an array A[1, . . . , n] of positive integers, and a positive integer b ∈ N returns True if and only if b is a 1-3 subset sum of A. Your algorithm should have asymptotic runtime complexity at most O(b · n). In your solution, address the following aspects: 1. Dimensions of the DP table: What are the dimensions of the DP table? 2. Subproblems: What is the meaning of each entry? 3. Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others. 4. Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps? 5. Extracting the solution: How can the solution be extracted once the table has been filled? 6. Running time: What is the running time of your solution? Solution: 1. Dimensions of the DP table: DP [0 . . . n][0 . . . b] 2. Subproblems: DP [a][s] is True if, and only if, s can be written as a sum ∑ i∈I ci · A[i] where I ⊆ {i : 1 ≤ i ≤ a}, and ci ∈ {1, 3} for each i ∈ I. 3. Recursion: DP can be computed recursively as follows: DP [0][s] = False 1 ≤ s ≤ b (1) DP [a][0] = True 0 ≤ a ≤ b (2) DP [a][s] = DP [a − 1][s] or DP [a − 1][s − A[a]] or DP [a − 1][s − 3 · A[a]] 1 ≤ a ≤ n, (3) 1 ≤ s ≤ b. Note that in equation (3), the entries ‘DP [a − 1][s − A[a]]’ and ‘DP [a − 1][s − 3 · A[a]]’ might fall outside the range of the table, in which case we treat them as False. Equation (1) expresses that positive values cannot be equal to an empty sum (which equals 0). Equa- tion (2) says 0 can always be written as an (empty) subset sum of A[1], . . . , A[a]. Equation (3) pro- vides the recurrence relation. Namely, it expresses that an integer s can be written as a 1-3 subset sum of A[1], . . . , A[a] if and only if at least one of the following is true: • s can be written as a 1-3 sum of elements A[1], . . . A[a − 1]. • s − A[a] can be written as a 1-3 subset sum of A[1], . . . , A[a − 1] (in which case we should use ca = 1). • s − 3 · A[a] can be written as a 1-3 subset sum of A[1], . . . A[a − 1] (in which case we should use ca = 3). 4. Calculation order: Following the recurrence relations above, we compute first by order of increas- ing a, and then by increasing order of s. 5. Extracting the solution: The solution can be found in DP [n][b], by part 2. 6. Running time: The running time of the solution is O(nb) as there are (n + 1) · (b + 1) = O(nb) entries in the table, each entry requires O(1) time to compute, and we extract the solution in O(1) time. Guidelines for correction: This exercise is very close to regular subset sum, and so the emphasis should be on correctly defining the meaning of a table entry and its computation (part 2 and part 3). Award 1 point if these are both correct (with proper justification for the recurrence), and 1/2 if the definition/recursion are correct, but the justification is not. Do not subtract points for missing edge-cases (where the index is out of range) in part 3. Exercise 7.2 Road trip. You are planning a road trip for your summer holidays. You want to start from city C0, and follow the only road that goes to city Cn from there. On this road from C0 to Cn, there are n − 1 other cities C1, . . . , Cn−1 that you would be interested in visiting (all cities C1, . . . , Cn−1 are on the road from C0 to Cn). For each 0 ≤ i ≤ n, the city Ci is at kilometer ki of the road for some given 0 = k0 < k1 < . . . < kn−1 < kn. You want to decide in which cities among C1, . . . , Cn−1 you will make an additional stop (you will stop in C0 and Cn anyway). However, you do not want to drive more than d kilometers without making a stop in some city, for some given value d > 0 (we assume that ki < ki−1 + d for all i ∈ [n] so that this is satisfiable), and you also don’t want to travel backwards (so from some city Ci you can only go forward to cities Cj with j > i). 2 (a) Provide a dynamic programming algorithm that computes the number of possible routes from C0 to Cn that satisfy these conditions, i.e., the number of allowed subsets of stop-cities. Your algorithm should have O(n2) runtime. Address the same six aspects as in Exercise 7.1 in your solution. Solution: 1. Dimensions of the DP table: The DP table is linear, and its size is n + 1. 2. Subproblems: DP [i] is the number of possible routes from C0 to Ci (which stop at Ci). 3. Recursion: Initialize DP [0] = 1. For every i > 0, we can compute DP [i] using the formula DP [i] = ∑ 0≤j<i ki≤kj +d DP [j]. (4) 4. Calculation order: We can calculate the entries of DP from the smallest index to the largest index. 5. Extracting the solution: All we have to do is read the value at DP [n]. 6. Running time: For i = 0, DP [0] is computed in O(1) time. For i ≥ 1, the entry DP [i] is computed in O(i) time (as we potentially need to take the sum of i entries). Therefore, the total runtime is O(1) + ∑n i=1 O(i) = O(n2). (b) If you know that ki > ki−1 + d/10 for every i ∈ [n], how can you turn the above algorithm into a linear time algorithm (i.e., an algorithm that has O(n) runtime) ? Solution: Assuming that ki > ki−1 + d/10 for all i, we know that ki > ki−10 + d, and hence ki > kj + d for all j ≤ i − 10. Therefore, the sum in formula (4) contains at most 10 terms DP [j] (and for each of them we can check in constant time whether we should include it or not, i.e., whether ki ≤ kj + d). So in this case the computation of the entry DP [i] takes time O(1) for all 0 ≤ i ≤ n, and hence the total runtime is O(n). Exercise 7.3 Safe pawn lines. On an N × M chessboard (N being the number of rows and M the number of columns), a safe pawn line is a set of M pawns with exactly one pawn per column of the chessboard, and such that every two pawns from adjacent columns are located diagonally to each other. When a pawn line is not safe, it is called unsafe. The first two chessboards below show safe pawn lines, the latter two unsafe ones. The line on the third chessboard is unsafe because pawns d4 and e4 are located on the same row (rather than diagonally); the line on the fourth chessboard is unsafe because pawn a5 has no diagonal neighbor at all. 3 6 0Z0Z0Z 5 Z0Z0Z0 4 0Z0o0Z 3 o0o0o0 2 0o0Z0o 1 Z0Z0Z0 a b c d e f 4 pZp 3 ZpZ 2 0Z0 1 Z0Z a b c 4 0Z0opZ 3 Z0o0Zp 2 0o0Z0Z 1 o0Z0Z0 a b c d e f 5 o0Z0Z 4 0Z0o0 3 Z0o0o 2 0o0Z0 1 Z0Z0Z a b c d e Describe a DP algorithm that, given N, M > 0, counts the number of safe pawn lines on an N × M chessboard. In your solution, address the same six aspects as in Exercise 7.1. Your solution should have complexity at most O(N M ). Solution: 1. Dimensions of the DP table: DP [1 . . . N ][1 . . . M ] 2. Subproblems: DP [i][j] counts the number of distinct safe pawn lines on an N × j chessboard with the pawn in the last column located in row i. For example, for N = 4, we have DP [3][3] = 3, since 3 safe pawn lines on a 4 × 3 chessboard have their last pawn in row 3, namely: 4 0Z0 3 Z0o 2 0o0 1 o0Z a b c 4 0Z0 3 o0o 2 0o0 1 Z0Z a b c 4 0o0 3 o0o 2 0Z0 1 Z0Z a b c 3. Recursion: DP can be computed recursively as follows: DP [i][1] = 1 1 ≤ i ≤ N (5) DP [1][j] = DP [2][j − 1] 1 < j ≤ M (6) DP [N ][j] = DP [N − 1][j − 1] 1 < j ≤ M (7) DP [i][j] = DP [i − 1][j − 1] + DP [i + 1][j − 1] 1 < i < N, 1 < j ≤ M (8) Equation (5) solves the base case where the chessboard has only one column. In that case, there exists exactly one safe pawn line with the pawn in the last column located in row i. Equation (8) provides the general recurrence formula. The rationale behind this formula it is as follows: a pawn line on an N × j chessboard with its last pawn in row i is obtained by adding a single pawn located at (j, i) (the black pawn on the board below) to a pawn line on a N × (j − 1) chessboard (the red pawns on first board below). Clearly, the last pawn of the smaller line must be on row i + 1 or i − 1. Hence, we have DP [i][j] = DP [i − 1][j − 1] + DP [i + 1][j − 1]. However, this is not true when we have the edge cases i = 1 or i = N . In these cases, only one position is available for the last pawn of the smaller line, yielding formulae (6) and (7). 5 Z0Z0Z0 4 0o0Z0Z 3 o0o0Z0 2 0Z0o0o 1 Z0Z0o0 a b c d e f 4 4. Calculation order: We first compute by order of increasing j, and then in an arbitrary order for i (for example, in increasing order). 5. Extracting the solution: The solution is ∑N i=1 DP [i][M ]. 6. Running time: The running time of the solution is O(M N ), as there are N M entries in the table which are processed in O(1) time, and extracting the solution takes O(N ) ≤ O(M N ) time. Exercise 7.4 String counting (1 point). Given a binary string S ∈ {0, 1}n of length n, let f (S) be the number of times “11” occurs in the string, i.e. the number of times a 1 is followed by another 1. In particular, the occurrences do not need to be disjoint. For example f (“111011”) = 3 because the string contains three 1 that are followed by another 1 (underlined). Given n and k, the goal is to count the number of binary strings S of length n with f (S) = k. Describe a DP algorithm that, given positive integers n and k with k < n, reports the required number. In your solution, address the same six aspects as in Exercise 7.1. Your solution should have complexity at most O(nk). Hint: Define a three dimensional DP table DP [1 . . . n][0 . . . k][0 . . . 1]. Hint: The entry DP [i][j][l] counts the number of strings of length i with j occurrences of “11” that end in l (where 1 ≤ i ≤ n, 0 ≤ j ≤ k and 0 ≤ l ≤ 1). Solution: 1. Dimensions of the DP table: DP [1 . . . n][0 . . . k][0 . . . 1]. 2. Subproblems: The entry DP [i][j][l] describes the number of strings of length i with j occurrences of “11” that end in l. 3. Recursion: The base cases for i = 1 are given by DP [1][0][0] = 1 (the string “0”), DP [1][0][1] = 1 (the string “1”), DP [1][j][0] = 0 and DP [1][j][1] = 0 for 1 ≤ j ≤ k. The update rule is as follows: For 1 < i ≤ n and 0 ≤ j ≤ k, to get a string of length i with j occurrences of “11” ending in 0, we can append “0” to a string of length i − 1 with j occurrences of “11” ending in 0 or 1, which gives DP [i][j][0] = DP [i − 1][j][0] + DP [i − 1][j][1]. To get a string of length i with j occurrences of “11” ending in 1, we can append “1” to a string of length i−1 with j occurrences of “11” ending in 0 or to a string of length i−1 with j −1 occurrences of “11” ending in 1 (if j > 0). Thus, DP [i][j][1] = { DP [i − 1][j][0], if j = 0 DP [i − 1][j][0] + DP [i − 1][j − 1][1], if j > 0. 4. Calculation order: The entries can be calculated in order of increasing i. There is no interaction between entries with the same i, hence the order within the same value of i can be arbitrary (e.g. increasing in j and l). 5. Extracting the solution: The solution is DP [n][k][0] + DP [n][k][1]. 6. Running time: The running time of the solution is O(nk) as there are O(nk) entries in the table, each of which is processed in O(1) time, and the solution is extracted in O(1). 5 Guidelines for correction: Since the answers to questions 1. and 2. are given in the hints, only the answers to questions 3.-6. need to be considered for awarding the points. Question 3. should be split into two parts, one for the base cases and one for the update rule. Award 1/2 point if at least 3 of the questions 3.-6. are answered correctly (with 3. being counted as two), award 1 point if all questions are answered correctly. Exercise 7.5 Approximately solving knapsack (1 point). Consider a knapsack problem with n items with values vi ∈ N and weights wi ∈ N for i ∈ {1, 2, . . . , n}, and weight limit W ∈ N. Assume1 that wmax := max1≤i≤n wi ≤ W and also that W ≤ ∑n i=1 wi. For a set of items I ⊆ {1, 2, . . . , n}, we write v(I) = ∑ i∈I vi and w(I) = ∑ i∈I wi for the total value (resp. weight) of I. So, the solution to a knapsack problem is given by opt := max {v(I) : I ⊆ {1, 2, . . . , n}, w(I) ≤ W } . Let ε > 0. We say a set of items I ⊆ {1, 2, . . . , n} is ε-feasible if it violates the weight limit by at most a factor 1 + ε, that is, if w(I) ≤ (1 + ε) · W. In this exercise, we construct an algorithm that finds an ε-feasible set I with v(I) ≥ opt in polynomial time in n and 1/ε. (a) Let k ∈ N. Consider a ‘rounded version’ of the knapsack problem above obtained by replacing the weights wi by: ̃wi := k · ⌊ wi k ⌋ . Recall the dynamical programming algorithm you have seen in the lecture which solves the knapsack problem in time O(n · W ). Explain how to modify this algorithm to solve the ‘rounded version’ in time O((W/k) · n). For simplicity, you may assume that W is an integer multiple of k for this part. Hint: After rounding, all the ̃wi are integer multiples of k. Use this to reduce the number of table entries you have to compute in the dynamical programming algorithm. Solution: The dynamical programming algorithm from the lecture fills out a table MW[0, . . . , n][0, . . . , W ] with entries given by MW(i, w) := ‘largest value v(I) one can obtain with I ⊆ {1, 2, . . . , i} and w(I) ≤ w’. This table is filled using the recursion: MW(i, w) = max {MW(i − 1, w), vi + MW(i − 1, w − wi)} Note that after rounding, all the ̃wi are integer multiples of k. Therefore, in the rounded problem, it suffices to only compute the table entries where the index w is an integer multiple of k. This leads to (W/k + 1) · (n + 1) table entries in total, each of which takes constant time to compute, meaning runtime O((W/k) · n) in total. We write optk for the optimum solution value of the rounded problem in part (a). From now on, you may assume that your modified algorithm also returns a set Ik with v(Ik) = optk and ∑ i∈Ik ̃wi ≤ W . 1Why are these assumptions reasonable? 6 (b) Explain why optk ≥ opt. Solution: We have ̃wi ≤ wi for each i ∈ {1, 2 . . . , n}. Therefore, any set I of items with w(I) ≤ W also satisfies ∑ i∈I ̃wi ≤ W . Since the values of each item are the same in the rounded problem, this implies that optk ≥ opt. (c) Set ε := (nk)/wmax. Show that w(Ik) ≤ (1 + ε) · W , that is, show that Ik is ε-feasible. Hint: Show that wi ≤ ̃wi + k for each i ∈ {1, 2, . . . , n}. We know that ∑ i∈Ik ̃wi ≤ W . Combine these facts to show that w(Ik) := ∑ i∈Ik wi ≤ W + n · k. Finally, use the fact that W/wmax ≥ 1 to conclude your proof. Solution: By definition, ⌊wi/k⌋ ≥ (wi/k) − 1. Therefore, ̃wi ≥ k · ((wi/k) − 1) = wi − k for all i ∈ {1, 2, . . . , n}. We compute w(Ik) := ∑ i∈Ik wi ≤ ∑ i∈Ik(̃wi + k) = ∑ i∈Ik ̃wi + ∑ i∈Ik k ≤ W + n · k ≤ W + W wmax · (nk) = W · (1 + nk wmax ) (d) Now let ε > 0 be arbitrary. Describe an algorithm that finds an ε-feasible set I of items with v(I) ≥ opt in time O(n3/ε). Prove the runtime guarantee and correctness of your algorithm. Hint: Apply the algorithm of part (a) to the rounded problem with k = (wmax · ε)/n. For simplicity, you may assume that this k is an integer in your proof. Then, use the assumption that W ≤ ∑n i=1 wi (≤ n · wmax) to bound the runtime of the algorithm in terms of n and 1/ε. Finally, use part (b) and part (c) to show correctness. Solution: For the runtime, we note that applying the algorithm of part (a) takes time: (W/k) · n = n · W wmax · ε · n = n2 ε · W wmax ≤ n2 ε · n · wmax wmax ≤ n3 ε . For correctness, let Ik be the set returned be the algorithm of part (a). By part (b), we have v(Ik) ≥ opt. As k = (wmax · ε)/n implies that ε = (nk)/wmax, we have w(Ik) ≤ (1 + ε) · W by part (c). (e)* Let ε = 1/100. Give an example of a knapsack problem which has an ε-feasible solution I with value v(I) = 2 · opt, Your example should satisfy wmax ≤ W and W ≤ ∑n i=1 wi. Solution: Consider the knapsack problem with two items, v1 = v2 = w1 = w2 = 101 and W = 200. Then, opt = 101 as we can only take one item. However, taking both items yields a solution which violates the weight limit by only a factor 1/100 (as (202 − 200)/200 = 1/100). Thus there is an ε-feasible solution with value 202 = 2 · opt. 7 Guidelines for correction: The important elements in the solution are: • In part (a), note that we only have to compute a 1/k-fraction of the table entries, indexed by integer multiples of k. • In part (b), note that any set of items which is feasible for the original problem is still feasible after rounding the weights down. • In part (c), correctly explain why wi ≤ ̃wi + k. • In part (c), correctly derive that w(Ik) ≤ W + n · k. • In part (c), correctly derive that W + n · k ≤ W · (1 + nk wmax ). • In part (d), correctly derive the runtime bound • In part (d), note why part (b) and (c) imply correctness of the algorithm. If at least 5 of these elements are present, award 1 point. If at least 2 elements are present, award 1/2 point. 8","libVersion":"0.3.2","langs":""}