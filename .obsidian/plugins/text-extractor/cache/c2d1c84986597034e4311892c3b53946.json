{"path":"sem4/CN/UE/s/CN-u02-s.pdf","text":"Exercise 2: DNS, HTTP/Web Pre-Note: This week contains lots of exercises about DNS and some about HTTP & Web. We still encourage you to try the “Hands-On” exercise (exercise 6) and experiment with DNS on your own. If you have questions, you can ask them on gitlab. You can find a visual explanation of the DNS systems here: https://howdns.works/ Question 1: DNS warmup a) Name one problem that DNS solves and name one advantage of the DNS system. b) Why should we always use trusted DNS servers? Solution: a) First, it is much easier for users to remember domain names than IP addresses. Second, the same service can have different IP-addresses, which means a service can easily be relocated or accessed using different addresses (enabling simple load-balancing without BGP anycast). b) A malicious DNS server could send you an IP address of a completely different server than you had in mind. Imagine you want to go to eth- webshop.ch to buy a present. If you’re using an untrusted DNS server, it can redirect you to an attacker’s IP address instead of ETH’s. The attacker might then imitate ETH, and will serve you a “fake” ETH Webshop page, which will record and steal any information you enter (e.g. credit card information). Question 2: DNS vs static “hosts.txt” file Before the DNS existed people used a static “hosts.txt” file to translate from domain names to IP addresses. This one-file-approach is luckily no longer used. Give 3 reasons why this is the case. Briefly explain your answers. Solution: • Scalability in structure: It is not possible to incrementally update a non- indexed file. Updates would entail copying over the entire file again. A load-balanced hierarchical structure to issue updates is needed. • Scalability in size: The file at the current size of the Internet would unnecessarily take too much space because users only visit a fraction of hostnames, which would be especially problematic in low-space machines such as Internet of Things (IoT) devices. • Management: Who is assigned which hostname becomes a management issue at a world-wide scale. For example, governments want to control their respective own top level domains. 1 • Consistency/availability: It is desired to have a stronger guarantee of prop- agation than “hoping that everyone will adopt my change by downloading an enormous file”. Question 3: DNS Caching Given the DNS (caching) architecture explained during the lecture, assume a record change is issued. 1. To which address is an Internet user (who regularly browses the web) directed after the record changes? • The old address • The new address • Both are possible 2. Assume now a record removal (instead of record change). To which address is the user directed? • The old address • Timeout/translation error/no record found • Both are possible Solution: 1. Both are possible. DNS servers & the OS/browser are able to cache DNS records for translation. Before the TTL expires, users will still be directed to the original IP when typing in the hostname since the DNS system translates the name based on the cached records. Once the TTL expires, the cached records are deleted and the users are directed to the “new address” that are fetched from the corresponding DNS server. 2. Both are possible. The answer is similiar to 1. The only difference is that when the TTL expires the user observes that the name can not be resolved * http://kb.mozillazine.org/Network.dnsCacheExpiration (retrieved March 4th 2021) Question 4: DNS address translation In order to translate the domain name “netsec.ethz.ch” to an IP address you use the DNS system. 1. You, as the requesting host, contact your local DNS server for the transla- tion which then takes care of all further communication with other name servers to finally deliver you the result. Which answer is correct? Your request to the local DNS server can be considered a: • recursive query, or a • iterative query 2. Now consider the query from the perspective of your local DNS server. The table below lists the relevant authoritative name servers for the query. We here refer to the servers by their canonical hostname. Reminder 2 about canonical hostnames: Every server has a canonical hostname and optionally multiple aliases. For example, a hostname such as relay1.west- coast.enterprise.com (canonical hostname) could have, say, two aliases such as enterprise.com and www.enterprise.com. Alias hostnames, when present, are typically more mnemonic than canonical hostnames. server information a.root-servers.net authoritative root server a.nic.ch authoritative name server for all .ch domains ns1.ethz.ch authoritative name server for the domain netsec.ethz.ch Assume there are no cached records, no additional information and the local DNS server only knows the IP of a single root server. a) How many messages are “handled” (sent or received) by the local DNS server when translating “netsec.ethz.ch” assuming an iterative query? Do not include the messages sent from or to the requesting host. b) How many messages are “handled” by the local DNS server assuming a recursive query instead? Solution: Recursive queries directly return the requested record and offload the work to the queried server. With an iterative query the host only receives the name of the next DNS server to query until it reaches the authoritative NS for the requested resource. 1. recursive. An explanation with an example can be found at Chapter 2.4.2 of “James Kurose, Keith Ross Computer Networking - A top down approach”. There it says “The query sent from <the requesting host> to <the local DNS server> is a recursive query, since the query asks <the local DNS server> to obtain the mapping on its behalf.” 2. a) Six messages are sent or received. The local DNS server will contact the root server and get the IP of a.nic.ch. Then the local DNS server will contact a.nic.ch and receive the IP of ns1.ethz.ch , will further contact ns1.ethz.ch and finally get the IP of netsec.ethz.ch. The local DNS server will therefore send and receive 3 messages respectively, resulting in a total of 6 messages. Notice that knowing the IP of ns1.ethz.ch does not require to know the IP of ethz.ch. This might be counterintuitive since to lookup the ip of ns1.ethz.ch one might be tempted to think that one would need the IP of ethz.ch first. In the standard case a high level DNS server (like ch) has a NS record (e.g. [ethz.ch, ns1.ethz.ch, NS]) which refers the domain name to its dns server and an additional A record for the DNS server (e.g. [ns1.ethz.ch, 212.212.212.1, A]). This additional A record is attached 3 to the response as a “glue record” which allows to directly contact the dns server. This exercise is based on existing domains. Run some commands on your own to verify: command effect dig netsec.ethz.ch iteratively resolve domain name to IP dig @server netsec.ethz.ch query only one name server, e.g. dig @a.root-servers.net netsec.ethz.ch b) Two messages are sent or received. A recursive query offloads the work of translation to the next server. In our example the local DNS resolver would query the root server. Then the root server would query the a.nic.ch server which would itself query the ns1.ethz.ch server. The local DNS server only sends a message to the root server and receives a single answer. Note that recursive queries like this would be infeasible in the current internet due to scalability issues. Question 5: DNS root servers In order to perform any iterative DNS query from scratch, one needs to contact a root DNS server. 1. How many root DNS servers are there? Are there more machines answering root DNS queries as there are root DNS servers? 2. Which mechanisms are in place for root DNS servers to deal with the traffic and to prevent future unnecessary traffic? Solution: 1. There are 13 root servers that have knowledge of all TLD servers. 2. • Each of these root servers is replicated multiple times across the globe using the same IP address and leveraging BGP anycast. Importantly it is not true that there are just 13 physical machines answering root queries but instead there are 13 IP addresses that can be used for root queries where each IP address is shared by many machines. This is possible due to BGP anycast (see later in the course). The name “root-server” might be misleading and refers to a service (behind a single IP address) provided by a whole bunch of machines instead of a single computer. • If the root server to query is chosen at random from the 13 servers, traffic should be balanced between root servers. • Due to caching, most queries don’t need to start at the root server since computers or your local DNS server often have a lot of TLD servers already cached. 4 Question 6: Hands on DNS Dig is a command line utility that allows you make DNS requests using the command line. You can install it through any package manager under linux. We strongly recommend to experiment with dig commands to solve the question and deepen your understanding of the topic. If you don’t have access to a linux machine or are unable to install it you can also use the online tool/gui: https://www.diggui.com. Hint: The section of a DNS response that is interesting for you is the “Answer” section (and maybe the “Additional Information” section). You might want to quickly read up on the answer format here: (https://phoenixnap.com/kb/linux- dig-command-examples). Question 6.1 To start with, make a simple query to find the IP address of the domain www.ethz.ch using the command dig www.ethz.ch. • What is the result of the command? • What type of record is it and what is this type of record used for? • What is the TTL of this record and what does it indicate? You can write your answer in short bulletpoints. Solution: We get back the DNS A record for the domain www.ethz.ch which gives us the IP address for the given domain name. The record has a TTL of about 5 min (300 sec), but can be lower depending on the time that you requested the DNS entry. It indicates that the DNS record of www.ethz.ch has to get reloaded/requested again every 300 sec, which is how long the local cached copy is considered valid. One might find that the TTL changes when redoing the query after waiting some seconds. Question 6.2 There are recursive and iterative DNS queries. What kind of query do you expect in the current internet? Try out using +trace before the domain name. What kind of query type does this show? Solution: There are recursive and iterative lookups. In recursive lookups you ask the DNS server to look up the rest of the domain (again recursively), if it doesn’t have it cached. While in the iterative lookup, the DNS server returns the IP of a DNS server responsible for the next part of the domain. An example of this would be that a DNS server for the TLD ch would return the IP address of the ethz DNS server (dns.ethz.ch) for a lookup of www.ethz.ch. Recursive DNS queries are often blocked by the servers because they put additional load on them. 5 The query returned by adding +trace is a iterative query, where the result to each of the servers is output. Question 6.3 We can now send a query to a specific DNS server by using the @dns.server flag. 1. If we create our simple query (dig @a.root-servers.net www.ethz.ch) and send it to the first root-server, we don’t get an www.ethz.ch IP in return. Why is this? 2. Create a query for netsec.ethz.ch, what kind of result do you expect? (you can check for yourself) 3. One DNS server of eth is called ns1.ethz.ch. Which result do you get when you query this server? (You may want to try this yourself) 4. Can you find out about the DNS name server “ns1.ethz.ch” on your own using dig? Do you find the IP of ethz.ch? 5. Does dig ethz.ch give the same result? Solution: 1. If we request the domain from a root server (which will not support recursive resolution), we don’t get back a result because of the hierarchical structure of the DNS system. The root server just refers us to the next lower level DNS server, the one for the ch TLD. Note that the “dig @server name” command just sends a query to this single stated server while the “dig name” command issues multiple requests down in the DNS hierarchy in order to iteratively resolve the domain name. This would be the first step of an iterative resolution. 2. edit Students seems to have tried a query with an @root server so they got a result for a lower down DNs server. Sol netsec.ethz.ch is actually an alias for perrig.inf.ethz.ch, so this query returns both a CNAME record as well as an A record for perrig.inf.ethz.ch 3. We can directly request the IP from the responsible DNS server, in this case the ETH DNS server. In order to achieve this we use the flag @ns1.ethz.ch instead. The total query is: dig @ns1.ethz.ch www.ethz.ch. We get an A record for the domain name ethz.ch which contains the IP address 129.132.19.216 (valid as of 28.02.23) 4. First we’d query a root nameserver dig @a.root-servers.net www.ethz.ch and get information about ch. nameservers. From there we query a.nic.ch and find ns1.ethz.ch. At last, we query the eth nameserver to get the result for www.ethz.ch. 5. Yes it gives the same result. In a sense we did the iterative query ourself by iterating down the DNS hierarchy. The dig command will automatically do this for when used without any flags. 6 Question 6.4 Dig can also be used to request the inverse query, requesting the domain name from an IP-address, which is called reverse IP lookup and is achieved with the -x flag. Which domains do the IP 1.1.1.1 and 8.8.8.8 belong to? Solution: They belong to the Cloudflare DNS Service One.One.One.One (1.1.1.1 or 1.0.0.1) and the Google Public DNS (8.8.8.8 or 8.4.4.8) respectively. Question 7: Browsing: TRUE or FALSE? 1. HTTP headers are usually human readable. 2. The critical path in the context of (web page element dependencies) is the shortest path in the dependency graph. 3. Having more compute power cannot speed up the page load time. Solution: 1. TRUE. 2. FALSE. The critical path is the longest. It describes th time we have to wait for all/the last dependency to load. 3. FALSE. More computing power can speed up the rendering, and so the page load time. Question 8: Fetching Web Content Bob and Alice are trying to fetch the same n (with n being large) web page elements from different servers. In particular, Bob tries to fetch the contents from a server with RT TB = rtt, while Alice from one with RT TA = 3 * rtt. Bob uses a single non-persistent TCP connection for each object sequentially (one after the other), while Alice uses at most M parallel non-persistent TCP connections. Non-persistent means that for each object a new TCP connection is opened. Both Bob and Alice do not use pipelining. Assume infinite bandwidth and that each object is small enough that it can be transmitted in one go (without multiple rounds of packets and ACKs). Assume also there are no dependencies across the n objects. Question 8.1 How much time does Bob take to fetch the n web page elements? Solution: Bob requires 2 · n · rtt. Per element 1 RT TB is required for establishing the connection, and 1 RT TB for the HTTP request. Since each element is requested sequentially we add up the latencies for all elements and get the indicated result 7 Question 8.2 What is the minimum number of parallel connections that Alice needs in order to be faster than Bob in downloading the objects? Solution: As Bob uses independent sequential TCP connection, his download time will be: T dBob ∼ 2 · n · RT TB = 2 · n · rtt. Alice, instead, uses M parallel independent connections, so her download time will be (assuming n is a multiple of M). Intuitively the term n/M indicates how often one has to reissue a new batch of M parallel connection until all n elements are requested: T dAlice ∼ 2 · n M · RT TA = 2 · n M · 3 · rtt = 6 · n M rtt. Alice is faster when T dAlice < T dBob: 6 · n M rtt < 2 · n · rtt 6 M < 2 M > 3 So Alice needs 4 or more parallel connections to be faster than Bob. Question 8.3 If Bob would have used a persistent (kept-alive) TCP connection instead of opening a new connection for each object, what would his completion time have been? And if Alice would have used persistent kept-alive TCP connections? For n = 100, would Bob have been faster than Alice assuming Alice kept the same strategy of M non-persistent connections? Solution: If Bob would utilize a single persistent TCP connection he would only need 1 RT TB for establishing the connection and then n RT TB’s for the n sequential element requests, Bob’s download time would be: T dBob,new ∼ (n + 1) · RT TB 8 Similarly, if Alice would utilize persistent TCP connections, her download time would become: T dAlice ∼ (1 + n M ) · RT TA Thanks to the utilization of a single persistent TCP connection, Bob’s download time becomes: T dBob,new ∼ (n + 1) · rtt = 101 · rtt As Alice decided to keep the previous strategy, her download time is: T dAlice ∼ 2 · n 4 · RT TA = n 2 · 3 · rtt = 150 · rtt. Being 150 · rtt > 101 · rtt, Alice now is slower than Bob. Good job Bob! Question 9: Critical path in a dependency graph Below you are given a dependency graph containing various tasks to be processed when loading a website. The nodes represent tasks that are processed and the edges are annotated with the processing time of the dependencies between these two tasks in milliseconds. For example, Task H depends on Task A and the processing time for this dependency is 50ms. 9 Dependency graph Recall that within a dependency graph, the critical path determines the minimum amount of time it takes to fully load all dependencies. Question 9.1 Calculate the final overall page-load time. In which order would the browser process the tasks in the dependency graph? Solution: The overall page-load time is given by 255ms. This corresponds to the longest path through G, H, D, E, B, C and F, i.e. 20 + 40 + 100 + 65 + 10 + 15 + 5 = 255ms. The browser processes the tasks in topological order. There are multiple options, one of which is: F, C, B, A, E, D, H, G, FIN. Topological sort can be used to obtain the order of the tasks. Any topological order is valid. Since the topological order is not unique, other orderings are also possible. 10 Question 9.2 In the dependency graph above, can we reduce the total webpage load time by reducing the load time of any dependency on the Task A? If so, by how much can we reduce it before the final overall load time no longer decreases? Solution: No, Task A is not part of the critical path, hence reducing the processing time of A (i.e. any dependency on A) will not affect the total webpage load time. 11","libVersion":"0.5.0","langs":""}