{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w06.pdf","text":"Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Woche 6 â€“ Ãœbersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder VollstÃ¤ndigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne GewÃ¤hr.) Anmerkungen zu den Code-Expert Abgaben: Weiteres: â€¢ Die Abgaben, die ich bekommen habe, sahen insgesamt sehr gut aus. â€¢ Der VollstÃ¤ndigkeit halber hier nun noch meine Implementation der BFS-Funktion (es geht eleganter ğŸ˜‰): â€¢ Wichtig: Ich habe auf meiner letzten Zusammenfassung den Fehler gemacht, Type- Variablen (wenn man â€œmehr Ã¼ber sie herausfindetâ€) so zu schreiben: â€a :: b -> câ€œ etc. bitte verwendet an dieser Stelle ein â€=â€œ und den Doppel-Doppelpunkt nur wenn die ihr die Types von konkreten Funktionen bestimmt, bspw. â€f :: b -> câ€œ. Weiter auf der nÃ¤chsten Seite â†’ Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Haskell-Type Inference und Higher Order Programming Beispiel 1: Da ich sehe, dass ihr euch insgesamt immer noch ein wenig mit dem Konzept Higher Order Programming im Kontext Haskell-Type Inference schwer tut, versuche ich hier nun noch einmal in eigenen Worten das Wichtigste zu erklÃ¤ren: Betrachten wir dazu das folgende konkrete Beispiel: (\\ğ’™ â†’ ğ’™ (<)) geg.: (<) âˆ· ğ‘‚ğ‘Ÿğ‘‘ ğ‘ â‡’ ğ‘ â†’ ğ‘ â†’ ğµğ‘œğ‘œğ‘™ Betrachten wir erst einmal die Grobe Struktur der gegebenen Funktion: (\\ğ’™ â†’ ğ’™ (<)) nimmt als â€Inputâ€œ (was â€links vom Pfeil stehtâ€œ) ein ğ’™ und gibt als â€Outputâ€œ (was â€rechts vom Pfeil stehtâ€œ) die Expression ğ’™ (<) zurÃ¼ck. Das heisst, der Typ von (\\ğ’™ â†’ ğ’™ (<)) muss irgendwie so aussehen: (\\ğ’™ â†’ ğ’™ (<)) âˆ· ğ‘‡ğ‘¦ğ‘ğ‘’ğ¼ğ‘›ğ‘ğ‘¢ğ‘¡ â†’ ğ‘‡ğ‘¦ğ‘ğ‘’ğ‘‚ğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡ Jetzt mÃ¼ssen wir bestimmen, was genau ğ‘‡ğ‘¦ğ‘ğ‘’ğ¼ğ‘›ğ‘ğ‘¢ğ‘¡, ğ‘‡ğ‘¦ğ‘ğ‘’ğ‘‚ğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡ sind. DafÃ¼r gucken wir uns an, was in der Funktion passiert (also die â€rechte Seite vom Pfeilâ€œ): ğ’™(<) Es liegt also eine Function-Application vor: ğ’™ bekommt das Argument (<). Wir wissen von der Function-Application, dass sie diese Form hat: ğ‘¡1ğ‘¡2 wobei ğ‘¡1 eine Funktion ist, die ğ‘¡2 als ihr Argument in der Function-Application nimmt (Bspw. ist bei â€(2+) 4â€œ die Funktion â€(2+)â€œ die das Argument â€4â€œ nimmt). Also muss ğ’™ eine Funktion sein, die irgendeinen Input nimmt und irgendeinen Output zurÃ¼ckgibt. Also: ğ’™ âˆ· ğ’‚ â†’ ğ’ƒ Wir wissen aber sogar schon ein wenig mehr! Wir wissen, was fÃ¼r einen â€Inputâ€œ ğ’™ nehmen kann: In der Function-Application â€auf der rechten Seite vom Pfeilâ€œ wird der Funktion ğ’™ das Argument (<) Ã¼bergeben, also nimm ğ’™ Argumente wie (<) als Input. Also ist ğ’™ eine Funktion, die â€Inputs die so sind wie â€(<)â€œ als Argument nimmt und irgendwas zurÃ¼ckgibtâ€œ. Weil wir uns schon ein bisschen besser mit Haskell auskennen, kÃ¶nnen den roten Satz jetzt aber schon relativ gut formal ausdrÃ¼cken: ğ’™ ist eine Funktion, die Argumente vom Typen von der Funktion (<) nimmt und irgendwelche RÃ¼ckgabewerte zurÃ¼ckgibt. So â€“ und was ist der Typ von der Funktion (<) ? Den kennen wir schon: (<) âˆ· ğ‘‚ğ‘Ÿğ‘‘ ğ‘ â‡’ ğ‘ â†’ ğ‘ â†’ ğµğ‘œğ‘œğ‘™ Also nimmt ğ’™ Argumente vom Type ğ‘‚ğ‘Ÿğ‘‘ ğ‘ => ğ‘ â†’ ğ‘ â†’ ğµğ‘œğ‘œğ‘™ und gibt RÃ¼ckgabewerte von irgendeinem â€“ uns nicht nÃ¤her bekannten â€“ Wert zurÃ¼ck. Gucken wir uns noch einmal kurz an, wie wir eingangs den Typen von ğ’™ definiert haben: ğ’™ âˆ· ğ’‚ â†’ ğ’ƒ. Nun wissen wir also, was ğ’‚ ist, da wir herausgefunden haben, welchen Typ die Argumente von ğ’™ haben: ğ’‚ = ğ‘¶ğ’“ğ’… ğ’„ â‡’ ğ’„ â†’ ğ’„ â†’ ğ‘©ğ’ğ’ğ’ Also kÃ¶nnen wir jetzt genauer definieren, welchen Type ğ’™ hat: ğ’™ âˆ· ğ’‚ â†’ ğ’ƒ = ğ‘¶ğ’“ğ’… ğ’„ â‡’ (ğ’„ â†’ ğ’„ â†’ ğ‘©ğ’ğ’ğ’) â†’ ğ’ƒ Gucken wir uns nun abschlieÃŸend noch einmal (\\ğ’™ â†’ ğ’™ (<)) an: Wir haben eingangs festgestellt, dass: (\\ğ’™ â†’ ğ’™ (<)) âˆ· ğ‘‡ğ‘¦ğ‘ğ‘’ğ¼ğ‘›ğ‘ğ‘¢ğ‘¡ â†’ ğ‘‡ğ‘¦ğ‘ğ‘’ğ‘‚ğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡. Wir wissen, dass ğ’™ der Input und ğ’™(<) der Output sind. Den Type vom Input kennen wir jetzt schon: ğ’™ âˆ· ğ‘¶ğ’“ğ’… ğ’„ â‡’ (ğ’„ â†’ ğ’„ â†’ ğ‘©ğ’ğ’ğ’) â†’ ğ’ƒ. Jetzt mÃ¼ssen wir nur noch den Type vom Output, also von ğ’™ (<) bestimmen: Dazu gucken wir uns noch einmal ğ’™ an: Die Funktion ğ’™ nimmt Argumente vom Typ ğ‘¶ğ’“ğ’… ğ’„ â‡’ (ğ’„ â†’ ğ’„ â†’ ğ‘©ğ’ğ’ğ’) und gibt Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Argumente vom Type ğ’ƒ zurÃ¼ck. Hier, auf der â€rechten Seite vom Pfeilâ€œ bei unserer Funktion (\\ğ’™ â†’ ğ’™ (<)) Ã¼bergeben wir an ğ’™ die Funktion (<) â€“ die den Typen ğ‘¶ğ’“ğ’… ğ’„ â‡’ (ğ’„ â†’ ğ’„ â†’ ğ‘©ğ’ğ’ğ’) hat! Da ein Argument gegeben wurde, gibt es eine RÃ¼ckgabe vom Type ğ’ƒ, also hat die Funktion Application ğ‘¥ (<) den Type ğ’ƒ. Also gilt fÃ¼r unsere Funktion: (\\ğ’™ â†’ ğ’™ (<)) âˆ· ğ‘‡ğ‘¦ğ‘ğ‘’ğ¼ğ‘›ğ‘ğ‘¢ğ‘¡ â†’ ğ‘‡ğ‘¦ğ‘ğ‘’ğ‘‚ğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡ = ğ‘‡ğ‘¦ğ‘ğ‘’_ğ‘£ğ‘œğ‘›_ğ‘¥ â†’ ğ‘‡ğ‘¦ğ‘ğ‘’_ğ‘£ğ‘œğ‘›_ğ‘¥(<) = ğ‘¶ğ’“ğ’… ğ’„ â‡’ ((ğ’„ â†’ ğ’„ â†’ ğ‘©ğ’ğ’ğ’) â†’ ğ’ƒ) â†’ ğ’ƒ Also, schÃ¶n in einer Zeile: (\\ğ’™ â†’ ğ’™ (<)) âˆ· ğ‘¶ğ’“ğ’… ğ’„ â‡’ ((ğ’„ â†’ ğ’„ â†’ ğ‘©ğ’ğ’ğ’) â†’ ğ’ƒ) â†’ ğ’ƒ Haskell-Type Inference und Higher Order Programming Beispiel 2: Hier noch ein weiteres Beispiel, das auf WhatsApp/Discord Fragen aufgeworfen hat: Was ist der Unterschied zwischen: (\\ğ‘¥ ğ‘¦ ğ‘§ â†’ (ğ‘¥ ğ‘¦) ğ‘§) und (\\ğ‘¥ ğ‘¦ ğ‘§ â†’ ğ‘¥ (ğ‘¦ ğ‘§)) Dazu mÃ¼ssen wir uns zunÃ¤chst noch einmal das altbekannte Mantra ins GedÃ¤chtnis rufen: â€Function Application associates to the leftâ€œ. Also, wenn ğ‘ eine Funktion ist, dann: ğ‘ ğ‘ ğ‘ = (ğ‘ ğ‘) ğ‘. Beispielsweise: ğ‘ğ‘‘ğ‘‘ 2 4 = (ğ‘ğ‘‘ğ‘‘ 2) 4. Warum ist das wichtig? Weil Haskell Funktionen immer nur ein Argument nehmen kÃ¶nnen. Bislang haben wir immer so getan, als wÃ¤re ğ‘ğ‘‘ğ‘‘ ğ‘¥ ğ‘¦ = ğ‘¥ + ğ‘¦ eine Funktion, die zwei Argumente ğ‘¥, ğ‘¦ nimmt und dann deren Summe zurÃ¼ckgibt. TatsÃ¤chlich ist ğ‘ğ‘‘ğ‘‘ ğ‘¥ ğ‘¦ = ğ‘¥ + ğ‘¦ aber eine Funktion, die ein Argument ğ‘¥ nimmt und dann eine Funktion (ğ‘¥ +) zurÃ¼ckgibt, die wiederum ein Argument ğ‘¦ nimmt und einen Wert (hier konkret: Die Summe) zurÃ¼ckgibt. Wenn wir so etwas: â€ğ‘“ğ‘¢ğ‘›ğ‘ ğ‘¥ ğ‘¦â€œ sehen, dann wissen wir, dass ğ‘“ğ‘¢ğ‘›ğ‘ eine Funktion ist, die nach unserem â€alten VerstÃ¤ndnisâ€œ zwei Argumente nimmt und irgendeinen Wert zurÃ¼ckgibt. Genauer wissen wir nun, dass ğ‘“ğ‘¢ğ‘›ğ‘ ein Argument ğ‘¥ nimmt und eine Funktion (ğ‘“ğ‘¢ğ‘›ğ‘ ğ‘¥) zurÃ¼ckgibt. Also kÃ¶nnten wir ğ‘“ğ‘¢ğ‘›ğ‘ ğ‘¥ ğ‘¦ auch gleich so schreiben: (ğ‘“ğ‘¢ğ‘›ğ‘ ğ‘¥) ğ‘¦. Das heisst genauer fÃ¼r uns: Wenn wir so etwas sehen: (ğ‘“ ğ‘¥) ğ‘¦ dann kÃ¶nnen wir es uns im Kopf Ã¼bersetzen zu ğ‘“ ğ‘¥ ğ‘¦ â€“ und sehen dann, dass ğ‘“ eine Funktion ist und ğ‘¥, ğ‘¦ Argumente, die wir â€StÃ¼ck fÃ¼r StÃ¼ckâ€œ ğ‘“ Ã¼bergeben. Also gucken wir uns doch die beiden Funktionen von oben noch einmal genauer an. Zuerst die linke: (\\ğ‘¥ ğ‘¦ ğ‘§ â†’ (ğ‘¥ ğ‘¦) ğ‘§) Auf der â€rechten Seite vom Pfeilâ€œ sehen wir (ğ‘¥ ğ‘¦) ğ‘§ â€“ und wir haben jetzt gelernt, wie man das Ã¼bersetzen kann! ğ‘¥ ist eine Funktion und y und z sind Argumente die an ğ‘¥, bzw. ğ‘§ an (ğ‘¥ ğ‘¦) Ã¼bergeben werden. Also muss ğ‘¥ vom Type ğ‘¥ âˆ· ğ‘ â†’ ğ‘ â†’ ğ‘ sein, da es ein Argument ğ‘¦ vom (uns nicht genauer bekannten) Typ ğ‘ nimmt und eine Funktion (ğ‘¥ ğ‘¦) zurÃ¼ckgibt, die ein Argument ğ‘§ vom (uns nicht genauer bekannten) Typ ğ‘ nimmt und dann irgendeinen (uns nicht genauer bekannten) RÃ¼ckgabewert von (uns nicht genauer bekannten) Type ğ‘ zurÃ¼ckgibt. Also wissen wir jetzt: (\\ğ‘¥ ğ‘¦ ğ‘§ â†’ (ğ‘¥ ğ‘¦) ğ‘§) âˆ· (ğ‘ â†’ ğ‘ â†’ ğ‘) â†’ ğ‘ â†’ ğ‘ â†’ ğ‘ Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Betrachten wir nun die andere Funktion: (\\ğ‘¥ ğ‘¦ ğ‘§ â†’ ğ‘¥ (ğ‘¦ ğ‘§)). Was ist hier anders? Wir haben Klammern um (ğ‘¦ ğ‘§). Das heisst, wir haben hier nicht eine Funktion ğ‘¥ die â€nacheinanderâ€œ zwei Argumente ğ‘¦, ğ‘§ â€konsumiertâ€œ, sondern eine Funktion ğ‘¥, die nur ein Argument â€“ undzwar (ğ‘¦ ğ‘§) â€“ konsumiert. Und aus dem Argument (ğ‘¦ ğ‘§) kÃ¶nnen wir folgern, da es sich dabei um eine Function- Application handelt, dass ğ‘¦ eine Funktion sein muss, die Argumente vom Type von ğ‘§ nimmt und irgendwelche RÃ¼ckgabewerte von einem Type zurÃ¼ckgibt, die ğ‘¥ als Input nimmt. Also: ğ‘¥ hat den Type: ğ‘¥ âˆ· ğ‘ â†’ ğ‘ (wobei wir noch nicht genau wissen, was ğ‘, ğ‘ sind). Jetzt gucken wir uns das Argument fÃ¼r ğ‘¥ an: (ğ‘¦ ğ‘§). Dabei handelt es sich um eine Function-Application, also muss ğ‘¦ eine Funktion sein, und irgendeinen Type ğ‘¦ âˆ· ğ‘ â†’ ğ‘ haben (da der RÃ¼ckgabewert von ğ‘¦ als Argument an ğ‘¥ Ã¼bergeben wird â€“ und ğ‘¥ Argumente vom Type ğ‘ nimmt). Da ğ‘¦ als Argument ein ğ‘§ bekommt, muss ğ‘§ also vom Type ğ‘§ âˆ· ğ‘ sein. Also: ğ‘¥ âˆ· ğ‘ â†’ ğ‘, ğ‘¦ âˆ· ğ‘ â†’ ğ‘, ğ‘§ âˆ· ğ‘ Also: (\\ğ‘¥ ğ‘¦ ğ‘§ â†’ ğ‘¥ (ğ‘¦ ğ‘§)) = (\\ğ‘¥ â†’ \\ğ‘¦ â†’ \\ğ‘§ â†’ ğ‘¥ (ğ‘¦ ğ‘§)) âˆ· (ğ‘ â†’ ğ‘) â†’ (ğ‘ â†’ ğ‘) â†’ ğ‘ â†’ ğ‘ (Man kann aufgrund der RechtsassoziativitÃ¤t von Abstractions (\\ğ‘¥ ğ‘¦ â†’. . ) immer zu (\\ğ‘¥ â†’\\ğ‘¦ â†’. . ) umschreiben. Dadurch wird es dann oft einfacher, spÃ¤ter die Types ordentlich aufzuschreiben â€“ ohne dabei Fehler bei den Klammern zu machen). ________________ Also zusammengefasst: Einmal haben wir eine Funktion, die als Input eine Funktion ğ‘¥ nimmt, die wiederum zwei weitere Argumente ğ‘¦, ğ‘§ nacheinander nimmt und irgendwas zurÃ¼ckgibt â€“ und das andere Mal haben wir eine Funktion, die zwei Funktionen ğ‘¥, ğ‘¦ und ein weiteres Argument ğ‘§ als Input nimmt, wobei die Funktion ğ‘¥ als Input den RÃ¼ckgabewert der Application (ğ‘¦ ğ‘§) nimmt. Type-Inference Proofs: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Hier nun eine Aufgabe aus einer (relativ aktuellen) Klausur (FS20): Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch __________________________________________________________________________________ Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Folds: Kurz zu Algebraic Data Types (alles weitere kÃ¶nnt ihr entweder in den VL-Slides oder bspw. hier: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types selbst nachlesen und durch selbst ausprobieren viel besser lernen, als ich es je erklÃ¤ren kÃ¶nnte): Wir definieren einen Algebraic Data Type in Haskell folgendermassen: ğ‘‘ğ‘ğ‘¡ğ‘ ğ·ğ‘¡ğ‘¦ğ‘ğ‘’ = ğ¶1 â€¦ | ğ¶2 â€¦ | â€¦ | ğ¶ğ‘ â€¦ Wobei wir das Ganze als â€datatype definitionâ€œ bezeichnen. Den Namen unseres datatypes (hier â€Dtypeâ€œ) nennt man â€type constructorâ€œ. Die einzelnen ğ¶ğ‘– nennt man â€data constructorâ€œ (oder manchmal auch â€value constructorsâ€œ oder â€tagâ€œ, je nachdem, wo ihr lest). Auf jeden data constructor ğ¶ğ‘– folgen â‰¥ 0 types, beispielsweise: ğ‘‘ğ‘ğ‘¡ğ‘ ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡ = ğ‘ƒ ğ’Šğ’ğ’• ğ’Šğ’ğ’•. Wenn wir nun eine konkrete Instanz des datatypes Dtype erstellen wollen, verwenden wir einen der data constructors. Hier mal ein konkretes Beispiel: Wir haben den datatype â€Pointâ€œ definiert: Entweder als Punkt in kartesischen Koordinaten oder als Punkt in Polarkoordinaten. Die data constructors sind also Pkart und Ppolar. MÃ¶chte ich nun einen konkreten Punkt erstellen, verwende ich einen der data constructors. Das kÃ¶nnte bspw. so aussehen: Als kleines extra habe ich noch eine Funktion â€distanceâ€œ geschrieben, die die Distanz zwischen zwei Punkten berechnet, sofern beide im gleichen Koordinatensystem gegeben sind und sonst 0 zurÃ¼ckgibt (das hat keine mathematischen GrÃ¼nde ich bin einfach zu faul). Wenn wir uns den Type von distance ansehen, bemerken wir, dass dort nicht von Pkart oder Ppolar die Rede ist, sondern von dem allgemeinen type constructor, â€Pointâ€œ. Die Funktion distance nimmt also ein Point Argument und gibt eine Funktion zurÃ¼ck, die ein Argument vom Type Point nimmt und einen Float zurÃ¼ckgibt (die Distanz). Wenn wir in Funktionen bestimmte Instanzen von datatypes als Parameter behandeln wollen, ist es ganz wichtig, dass wir sie in Klammern schreiben! Also bspw. (Ppolar r1 ang1). Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Das gleiche gilt auch, falls wir bei einem data constructor nicht bloss einen gewÃ¶hnlichen Type (Int, Float, â€¦) Ã¼bergeben wollen, sondern eine Application eines type constructors, bspw.: Hier soll eine Liste definiert werden, die entweder ein â€Emptyâ€œ ist, oder ein â€Consâ€œ, wobei Cons ein data constructor ist, der ein â€aâ€œ nimmt und eine Liste aus â€aâ€œ. Damit wir diese type constructor application (â€MyList aâ€œ) hier anwenden kÃ¶nnen, sind die Klammern wichtig. Abschliessend lÃ¤sst sich noch erwÃ¤hnen, dass wir auch Polymorphic Datatypes definieren kÃ¶nnen: Wenn wir beispielsweise wollen, dass nicht sofort klar ist, was die Typen bei den data constructors sind, kÃ¶nnen wir dem type constructor dafÃ¼r Argumente geben, hier ein Beispiel: Jetzt haben wir einen Punkt, der Beispielsweise als Koordinaten auch Strings erlaubt. (Mir fÃ¤llt jetzt aber keine sinnvolle Verwenden fÃ¼r dieses konkrete Beispiel ein lol). __________________________________________________________________________________ So kommen wir nun zu Folds: Wir haben bereits die Funktion â€foldrâ€œ kennengelernt, die eine Liste nimmt und sie auf einen Wert â€kollabiertâ€œ. Dieser Wert kann selbst auch eine Liste oder eine Funktion oder sonst irgendetwas sein â€“ aber wir wissen, dass foldr einmal durch die Liste geht und dabei die Listenelemente alle auf irgendeine (durch uns spezifizierte) Weise auf etwas reduziert. TatsÃ¤chlich ist per Definition von â€foldingâ€œ (eine Datenstruktur auf einen Wert reduzieren) nicht nur foldr eine Funktion, die einen â€foldâ€œ durchfÃ¼hren kann, die Funktion hier tut das bspw. auch: Wir haben bislang eigentlich aber nur mit Listen gearbeitet, das heiÃŸt, alle Folds, die wir bislang kennengelernt haben, haben Listen auf einen Wert reduziert. Nun wollen wir Folds betrachten, die mit anderen Datentypen, bspw. Trees arbeiten kÃ¶nnen. Es ist eine hÃ¤ufige Klausuraufgabe, zu einem Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch bestimmten Datentypen die zugehÃ¶rigen Fold-Funktion anzugeben. DafÃ¼r gibt es glÃ¼cklicherweise ein konkretes Schema. (Hier von den Slides): Um das genauer zu verstehen, betrachten wir das folgende Beispiel: Wir haben einfach das bekannte Schema angewandt. DafÃ¼r betrachten wir mal bspw. â€foldVarTypeâ€œ, fÃ¼r das ich den Type â€(a -> b)â€œ bei foldProp hingeschrieben habe: Der data constructor Var nimmt ein â€aâ€œ und gibt ein (Prop a) zurÃ¼ck (konkret: ein Var, aber der allg. Type ist ja trotzdem Prop a). GemÃ¤ss dem Schema ersetzen wir alle Vorkomnisse des type constructors (â€Prop aâ€œ) durch den return type der Funktion, also â€œbâ€ und erhalten damit dann fÃ¼r die Funktion, die Varâ€™s folded den Type (a -> b). Wenn man das dann alles zusammensetzt bekommt man den Type der oben dasteht. Nun Ã¼berlegen wir uns noch, wie man foldProp wirklich konkret implementieren kann â€“ aber das sollte mit einer einfachen Ãœberlegung und dem genauen Betrachten des Types von foldProp relative einfach sein: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Auch hier bedienen wir uns wieder eines einfachen Schemas (das immer funktioniert): Die Funktion foldProp nimmt als Argumente die Funktionen, die zu den einzelnen data constructors korrespondieren, hier also fVar (die ein â€œProp aâ€ folded, falls dieses â€œProp aâ€ konkret eine â€œVar aâ€ ist), fNot, etc.. Um das vertiefend zu Ã¼ben, hier noch einige weitere Beispiele: Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Lazy vs. Eager Evaluation: Eigentlich muss man nur folgendes genau befolgen: Nehmen wir an, wir wollen (t1 t2) evaluieren. Lazy Evaluation: 1. Evaluiere t1 2. Substituiere t2 in t1 â€“ ohne t2 zu evaluieren 3. No Evaluation under Abstraction Eager Evaluation: 1. Evaluiere t1 2. Evaluiere t2, substituiere dann t2 in t1 3. Evaluation is carried out under Abstraction Hier ein konkretes Beispiel zum VerstÃ¤ndnis. Achtung: Um die Binding Structure nicht zu verletzen muss man manchmal (durch eine lambda-abstraction) gebundene Variablen umbenennen: Weiter auf der nÃ¤chsten Seite â†’ Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Induction on Trees: Gleiches Prinzip wie â€normaleâ€œ Induktionsproofs mit Listen, bloss ist der Base Case hier ein Leaf und der Step Case benÃ¶tigt oft 2 oder sogar 3 Induktionshypothesen. Falls der Tree irgendwie so definiert ist: ğ‘‘ğ‘ğ‘¡ğ‘ ğ‘‡ğ‘Ÿğ‘’ğ‘’ = ğ¿ğ‘’ğ‘ğ‘“ | ğ‘ğ‘œğ‘‘ğ‘’ ğ‘ (ğ‘‡ğ‘Ÿğ‘’ğ‘’ ğ‘) (ğ‘‡ğ‘Ÿğ‘’ğ‘’ ğ‘) Material zur Ãœbungsstunde von Maximilian Schlegel â€“ mschlegel@student.ethz.ch Arbeitet ihr im Step Case Ã¼blicherweise mit dem Case â€Node x l râ€œ und formuliert eure Induktionshypothesen fÃ¼r die Subtrees â€lâ€œ und â€râ€œ und zeigt dann, dass die zu beweisende Aussage auch fÃ¼r (Node x l r) gilt, wenn sie per Annahme fÃ¼r die Subtrees l,r gilt. Falls es hierzu Fragen gibt, schreibt mir einfach. Guckt bei Syntax-Fragen in die Zusammenfassungen der Vorwochen.","libVersion":"0.5.0","langs":""}