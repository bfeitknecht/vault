{"path":"sem4/FMFP/VRL/extra/mschlegel/FMFP-mschlegel-w06.pdf","text":"Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Woche 6 – Übersicht, Tricks & Aufgaben (Disclaimer: Die hier vorzufindenden Notizen haben keinerlei Anspruch auf Korrektheit oder Vollständigkeit und sind nicht Teil des offiziellen Vorlesungsmaterials. Alle Angaben sind ohne Gewähr.) Anmerkungen zu den Code-Expert Abgaben: Weiteres: • Die Abgaben, die ich bekommen habe, sahen insgesamt sehr gut aus. • Der Vollständigkeit halber hier nun noch meine Implementation der BFS-Funktion (es geht eleganter 😉): • Wichtig: Ich habe auf meiner letzten Zusammenfassung den Fehler gemacht, Type- Variablen (wenn man “mehr über sie herausfindet”) so zu schreiben: „a :: b -> c“ etc. bitte verwendet an dieser Stelle ein „=“ und den Doppel-Doppelpunkt nur wenn die ihr die Types von konkreten Funktionen bestimmt, bspw. „f :: b -> c“. Weiter auf der nächsten Seite → Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Haskell-Type Inference und Higher Order Programming Beispiel 1: Da ich sehe, dass ihr euch insgesamt immer noch ein wenig mit dem Konzept Higher Order Programming im Kontext Haskell-Type Inference schwer tut, versuche ich hier nun noch einmal in eigenen Worten das Wichtigste zu erklären: Betrachten wir dazu das folgende konkrete Beispiel: (\\𝒙 → 𝒙 (<)) geg.: (<) ∷ 𝑂𝑟𝑑 𝑐 ⇒ 𝑐 → 𝑐 → 𝐵𝑜𝑜𝑙 Betrachten wir erst einmal die Grobe Struktur der gegebenen Funktion: (\\𝒙 → 𝒙 (<)) nimmt als „Input“ (was „links vom Pfeil steht“) ein 𝒙 und gibt als „Output“ (was „rechts vom Pfeil steht“) die Expression 𝒙 (<) zurück. Das heisst, der Typ von (\\𝒙 → 𝒙 (<)) muss irgendwie so aussehen: (\\𝒙 → 𝒙 (<)) ∷ 𝑇𝑦𝑝𝑒𝐼𝑛𝑝𝑢𝑡 → 𝑇𝑦𝑝𝑒𝑂𝑢𝑡𝑝𝑢𝑡 Jetzt müssen wir bestimmen, was genau 𝑇𝑦𝑝𝑒𝐼𝑛𝑝𝑢𝑡, 𝑇𝑦𝑝𝑒𝑂𝑢𝑡𝑝𝑢𝑡 sind. Dafür gucken wir uns an, was in der Funktion passiert (also die „rechte Seite vom Pfeil“): 𝒙(<) Es liegt also eine Function-Application vor: 𝒙 bekommt das Argument (<). Wir wissen von der Function-Application, dass sie diese Form hat: 𝑡1𝑡2 wobei 𝑡1 eine Funktion ist, die 𝑡2 als ihr Argument in der Function-Application nimmt (Bspw. ist bei „(2+) 4“ die Funktion „(2+)“ die das Argument „4“ nimmt). Also muss 𝒙 eine Funktion sein, die irgendeinen Input nimmt und irgendeinen Output zurückgibt. Also: 𝒙 ∷ 𝒂 → 𝒃 Wir wissen aber sogar schon ein wenig mehr! Wir wissen, was für einen „Input“ 𝒙 nehmen kann: In der Function-Application „auf der rechten Seite vom Pfeil“ wird der Funktion 𝒙 das Argument (<) übergeben, also nimm 𝒙 Argumente wie (<) als Input. Also ist 𝒙 eine Funktion, die „Inputs die so sind wie „(<)“ als Argument nimmt und irgendwas zurückgibt“. Weil wir uns schon ein bisschen besser mit Haskell auskennen, können den roten Satz jetzt aber schon relativ gut formal ausdrücken: 𝒙 ist eine Funktion, die Argumente vom Typen von der Funktion (<) nimmt und irgendwelche Rückgabewerte zurückgibt. So – und was ist der Typ von der Funktion (<) ? Den kennen wir schon: (<) ∷ 𝑂𝑟𝑑 𝑐 ⇒ 𝑐 → 𝑐 → 𝐵𝑜𝑜𝑙 Also nimmt 𝒙 Argumente vom Type 𝑂𝑟𝑑 𝑐 => 𝑐 → 𝑐 → 𝐵𝑜𝑜𝑙 und gibt Rückgabewerte von irgendeinem – uns nicht näher bekannten – Wert zurück. Gucken wir uns noch einmal kurz an, wie wir eingangs den Typen von 𝒙 definiert haben: 𝒙 ∷ 𝒂 → 𝒃. Nun wissen wir also, was 𝒂 ist, da wir herausgefunden haben, welchen Typ die Argumente von 𝒙 haben: 𝒂 = 𝑶𝒓𝒅 𝒄 ⇒ 𝒄 → 𝒄 → 𝑩𝒐𝒐𝒍 Also können wir jetzt genauer definieren, welchen Type 𝒙 hat: 𝒙 ∷ 𝒂 → 𝒃 = 𝑶𝒓𝒅 𝒄 ⇒ (𝒄 → 𝒄 → 𝑩𝒐𝒐𝒍) → 𝒃 Gucken wir uns nun abschließend noch einmal (\\𝒙 → 𝒙 (<)) an: Wir haben eingangs festgestellt, dass: (\\𝒙 → 𝒙 (<)) ∷ 𝑇𝑦𝑝𝑒𝐼𝑛𝑝𝑢𝑡 → 𝑇𝑦𝑝𝑒𝑂𝑢𝑡𝑝𝑢𝑡. Wir wissen, dass 𝒙 der Input und 𝒙(<) der Output sind. Den Type vom Input kennen wir jetzt schon: 𝒙 ∷ 𝑶𝒓𝒅 𝒄 ⇒ (𝒄 → 𝒄 → 𝑩𝒐𝒐𝒍) → 𝒃. Jetzt müssen wir nur noch den Type vom Output, also von 𝒙 (<) bestimmen: Dazu gucken wir uns noch einmal 𝒙 an: Die Funktion 𝒙 nimmt Argumente vom Typ 𝑶𝒓𝒅 𝒄 ⇒ (𝒄 → 𝒄 → 𝑩𝒐𝒐𝒍) und gibt Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Argumente vom Type 𝒃 zurück. Hier, auf der „rechten Seite vom Pfeil“ bei unserer Funktion (\\𝒙 → 𝒙 (<)) übergeben wir an 𝒙 die Funktion (<) – die den Typen 𝑶𝒓𝒅 𝒄 ⇒ (𝒄 → 𝒄 → 𝑩𝒐𝒐𝒍) hat! Da ein Argument gegeben wurde, gibt es eine Rückgabe vom Type 𝒃, also hat die Funktion Application 𝑥 (<) den Type 𝒃. Also gilt für unsere Funktion: (\\𝒙 → 𝒙 (<)) ∷ 𝑇𝑦𝑝𝑒𝐼𝑛𝑝𝑢𝑡 → 𝑇𝑦𝑝𝑒𝑂𝑢𝑡𝑝𝑢𝑡 = 𝑇𝑦𝑝𝑒_𝑣𝑜𝑛_𝑥 → 𝑇𝑦𝑝𝑒_𝑣𝑜𝑛_𝑥(<) = 𝑶𝒓𝒅 𝒄 ⇒ ((𝒄 → 𝒄 → 𝑩𝒐𝒐𝒍) → 𝒃) → 𝒃 Also, schön in einer Zeile: (\\𝒙 → 𝒙 (<)) ∷ 𝑶𝒓𝒅 𝒄 ⇒ ((𝒄 → 𝒄 → 𝑩𝒐𝒐𝒍) → 𝒃) → 𝒃 Haskell-Type Inference und Higher Order Programming Beispiel 2: Hier noch ein weiteres Beispiel, das auf WhatsApp/Discord Fragen aufgeworfen hat: Was ist der Unterschied zwischen: (\\𝑥 𝑦 𝑧 → (𝑥 𝑦) 𝑧) und (\\𝑥 𝑦 𝑧 → 𝑥 (𝑦 𝑧)) Dazu müssen wir uns zunächst noch einmal das altbekannte Mantra ins Gedächtnis rufen: „Function Application associates to the left“. Also, wenn 𝑎 eine Funktion ist, dann: 𝑎 𝑏 𝑐 = (𝑎 𝑏) 𝑐. Beispielsweise: 𝑎𝑑𝑑 2 4 = (𝑎𝑑𝑑 2) 4. Warum ist das wichtig? Weil Haskell Funktionen immer nur ein Argument nehmen können. Bislang haben wir immer so getan, als wäre 𝑎𝑑𝑑 𝑥 𝑦 = 𝑥 + 𝑦 eine Funktion, die zwei Argumente 𝑥, 𝑦 nimmt und dann deren Summe zurückgibt. Tatsächlich ist 𝑎𝑑𝑑 𝑥 𝑦 = 𝑥 + 𝑦 aber eine Funktion, die ein Argument 𝑥 nimmt und dann eine Funktion (𝑥 +) zurückgibt, die wiederum ein Argument 𝑦 nimmt und einen Wert (hier konkret: Die Summe) zurückgibt. Wenn wir so etwas: „𝑓𝑢𝑛𝑐 𝑥 𝑦“ sehen, dann wissen wir, dass 𝑓𝑢𝑛𝑐 eine Funktion ist, die nach unserem „alten Verständnis“ zwei Argumente nimmt und irgendeinen Wert zurückgibt. Genauer wissen wir nun, dass 𝑓𝑢𝑛𝑐 ein Argument 𝑥 nimmt und eine Funktion (𝑓𝑢𝑛𝑐 𝑥) zurückgibt. Also könnten wir 𝑓𝑢𝑛𝑐 𝑥 𝑦 auch gleich so schreiben: (𝑓𝑢𝑛𝑐 𝑥) 𝑦. Das heisst genauer für uns: Wenn wir so etwas sehen: (𝑓 𝑥) 𝑦 dann können wir es uns im Kopf übersetzen zu 𝑓 𝑥 𝑦 – und sehen dann, dass 𝑓 eine Funktion ist und 𝑥, 𝑦 Argumente, die wir „Stück für Stück“ 𝑓 übergeben. Also gucken wir uns doch die beiden Funktionen von oben noch einmal genauer an. Zuerst die linke: (\\𝑥 𝑦 𝑧 → (𝑥 𝑦) 𝑧) Auf der „rechten Seite vom Pfeil“ sehen wir (𝑥 𝑦) 𝑧 – und wir haben jetzt gelernt, wie man das übersetzen kann! 𝑥 ist eine Funktion und y und z sind Argumente die an 𝑥, bzw. 𝑧 an (𝑥 𝑦) übergeben werden. Also muss 𝑥 vom Type 𝑥 ∷ 𝑎 → 𝑏 → 𝑐 sein, da es ein Argument 𝑦 vom (uns nicht genauer bekannten) Typ 𝑎 nimmt und eine Funktion (𝑥 𝑦) zurückgibt, die ein Argument 𝑧 vom (uns nicht genauer bekannten) Typ 𝑏 nimmt und dann irgendeinen (uns nicht genauer bekannten) Rückgabewert von (uns nicht genauer bekannten) Type 𝑐 zurückgibt. Also wissen wir jetzt: (\\𝑥 𝑦 𝑧 → (𝑥 𝑦) 𝑧) ∷ (𝑎 → 𝑏 → 𝑐) → 𝑎 → 𝑏 → 𝑐 Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Betrachten wir nun die andere Funktion: (\\𝑥 𝑦 𝑧 → 𝑥 (𝑦 𝑧)). Was ist hier anders? Wir haben Klammern um (𝑦 𝑧). Das heisst, wir haben hier nicht eine Funktion 𝑥 die „nacheinander“ zwei Argumente 𝑦, 𝑧 „konsumiert“, sondern eine Funktion 𝑥, die nur ein Argument – undzwar (𝑦 𝑧) – konsumiert. Und aus dem Argument (𝑦 𝑧) können wir folgern, da es sich dabei um eine Function- Application handelt, dass 𝑦 eine Funktion sein muss, die Argumente vom Type von 𝑧 nimmt und irgendwelche Rückgabewerte von einem Type zurückgibt, die 𝑥 als Input nimmt. Also: 𝑥 hat den Type: 𝑥 ∷ 𝑎 → 𝑏 (wobei wir noch nicht genau wissen, was 𝑎, 𝑏 sind). Jetzt gucken wir uns das Argument für 𝑥 an: (𝑦 𝑧). Dabei handelt es sich um eine Function-Application, also muss 𝑦 eine Funktion sein, und irgendeinen Type 𝑦 ∷ 𝑐 → 𝑎 haben (da der Rückgabewert von 𝑦 als Argument an 𝑥 übergeben wird – und 𝑥 Argumente vom Type 𝑎 nimmt). Da 𝑦 als Argument ein 𝑧 bekommt, muss 𝑧 also vom Type 𝑧 ∷ 𝑐 sein. Also: 𝑥 ∷ 𝑎 → 𝑏, 𝑦 ∷ 𝑐 → 𝑎, 𝑧 ∷ 𝑐 Also: (\\𝑥 𝑦 𝑧 → 𝑥 (𝑦 𝑧)) = (\\𝑥 → \\𝑦 → \\𝑧 → 𝑥 (𝑦 𝑧)) ∷ (𝑎 → 𝑏) → (𝑐 → 𝑎) → 𝑐 → 𝑏 (Man kann aufgrund der Rechtsassoziativität von Abstractions (\\𝑥 𝑦 →. . ) immer zu (\\𝑥 →\\𝑦 →. . ) umschreiben. Dadurch wird es dann oft einfacher, später die Types ordentlich aufzuschreiben – ohne dabei Fehler bei den Klammern zu machen). ________________ Also zusammengefasst: Einmal haben wir eine Funktion, die als Input eine Funktion 𝑥 nimmt, die wiederum zwei weitere Argumente 𝑦, 𝑧 nacheinander nimmt und irgendwas zurückgibt – und das andere Mal haben wir eine Funktion, die zwei Funktionen 𝑥, 𝑦 und ein weiteres Argument 𝑧 als Input nimmt, wobei die Funktion 𝑥 als Input den Rückgabewert der Application (𝑦 𝑧) nimmt. Type-Inference Proofs: Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Hier nun eine Aufgabe aus einer (relativ aktuellen) Klausur (FS20): Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch __________________________________________________________________________________ Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Folds: Kurz zu Algebraic Data Types (alles weitere könnt ihr entweder in den VL-Slides oder bspw. hier: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types selbst nachlesen und durch selbst ausprobieren viel besser lernen, als ich es je erklären könnte): Wir definieren einen Algebraic Data Type in Haskell folgendermassen: 𝑑𝑎𝑡𝑎 𝐷𝑡𝑦𝑝𝑒 = 𝐶1 … | 𝐶2 … | … | 𝐶𝑁 … Wobei wir das Ganze als „datatype definition“ bezeichnen. Den Namen unseres datatypes (hier „Dtype“) nennt man „type constructor“. Die einzelnen 𝐶𝑖 nennt man „data constructor“ (oder manchmal auch „value constructors“ oder „tag“, je nachdem, wo ihr lest). Auf jeden data constructor 𝐶𝑖 folgen ≥ 0 types, beispielsweise: 𝑑𝑎𝑡𝑎 𝑃𝑜𝑖𝑛𝑡 = 𝑃 𝒊𝒏𝒕 𝒊𝒏𝒕. Wenn wir nun eine konkrete Instanz des datatypes Dtype erstellen wollen, verwenden wir einen der data constructors. Hier mal ein konkretes Beispiel: Wir haben den datatype „Point“ definiert: Entweder als Punkt in kartesischen Koordinaten oder als Punkt in Polarkoordinaten. Die data constructors sind also Pkart und Ppolar. Möchte ich nun einen konkreten Punkt erstellen, verwende ich einen der data constructors. Das könnte bspw. so aussehen: Als kleines extra habe ich noch eine Funktion „distance“ geschrieben, die die Distanz zwischen zwei Punkten berechnet, sofern beide im gleichen Koordinatensystem gegeben sind und sonst 0 zurückgibt (das hat keine mathematischen Gründe ich bin einfach zu faul). Wenn wir uns den Type von distance ansehen, bemerken wir, dass dort nicht von Pkart oder Ppolar die Rede ist, sondern von dem allgemeinen type constructor, „Point“. Die Funktion distance nimmt also ein Point Argument und gibt eine Funktion zurück, die ein Argument vom Type Point nimmt und einen Float zurückgibt (die Distanz). Wenn wir in Funktionen bestimmte Instanzen von datatypes als Parameter behandeln wollen, ist es ganz wichtig, dass wir sie in Klammern schreiben! Also bspw. (Ppolar r1 ang1). Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Das gleiche gilt auch, falls wir bei einem data constructor nicht bloss einen gewöhnlichen Type (Int, Float, …) übergeben wollen, sondern eine Application eines type constructors, bspw.: Hier soll eine Liste definiert werden, die entweder ein „Empty“ ist, oder ein „Cons“, wobei Cons ein data constructor ist, der ein „a“ nimmt und eine Liste aus „a“. Damit wir diese type constructor application („MyList a“) hier anwenden können, sind die Klammern wichtig. Abschliessend lässt sich noch erwähnen, dass wir auch Polymorphic Datatypes definieren können: Wenn wir beispielsweise wollen, dass nicht sofort klar ist, was die Typen bei den data constructors sind, können wir dem type constructor dafür Argumente geben, hier ein Beispiel: Jetzt haben wir einen Punkt, der Beispielsweise als Koordinaten auch Strings erlaubt. (Mir fällt jetzt aber keine sinnvolle Verwenden für dieses konkrete Beispiel ein lol). __________________________________________________________________________________ So kommen wir nun zu Folds: Wir haben bereits die Funktion „foldr“ kennengelernt, die eine Liste nimmt und sie auf einen Wert „kollabiert“. Dieser Wert kann selbst auch eine Liste oder eine Funktion oder sonst irgendetwas sein – aber wir wissen, dass foldr einmal durch die Liste geht und dabei die Listenelemente alle auf irgendeine (durch uns spezifizierte) Weise auf etwas reduziert. Tatsächlich ist per Definition von „folding“ (eine Datenstruktur auf einen Wert reduzieren) nicht nur foldr eine Funktion, die einen „fold“ durchführen kann, die Funktion hier tut das bspw. auch: Wir haben bislang eigentlich aber nur mit Listen gearbeitet, das heißt, alle Folds, die wir bislang kennengelernt haben, haben Listen auf einen Wert reduziert. Nun wollen wir Folds betrachten, die mit anderen Datentypen, bspw. Trees arbeiten können. Es ist eine häufige Klausuraufgabe, zu einem Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch bestimmten Datentypen die zugehörigen Fold-Funktion anzugeben. Dafür gibt es glücklicherweise ein konkretes Schema. (Hier von den Slides): Um das genauer zu verstehen, betrachten wir das folgende Beispiel: Wir haben einfach das bekannte Schema angewandt. Dafür betrachten wir mal bspw. „foldVarType“, für das ich den Type „(a -> b)“ bei foldProp hingeschrieben habe: Der data constructor Var nimmt ein „a“ und gibt ein (Prop a) zurück (konkret: ein Var, aber der allg. Type ist ja trotzdem Prop a). Gemäss dem Schema ersetzen wir alle Vorkomnisse des type constructors („Prop a“) durch den return type der Funktion, also “b” und erhalten damit dann für die Funktion, die Var’s folded den Type (a -> b). Wenn man das dann alles zusammensetzt bekommt man den Type der oben dasteht. Nun überlegen wir uns noch, wie man foldProp wirklich konkret implementieren kann – aber das sollte mit einer einfachen Überlegung und dem genauen Betrachten des Types von foldProp relative einfach sein: Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Auch hier bedienen wir uns wieder eines einfachen Schemas (das immer funktioniert): Die Funktion foldProp nimmt als Argumente die Funktionen, die zu den einzelnen data constructors korrespondieren, hier also fVar (die ein “Prop a” folded, falls dieses “Prop a” konkret eine “Var a” ist), fNot, etc.. Um das vertiefend zu üben, hier noch einige weitere Beispiele: Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Lazy vs. Eager Evaluation: Eigentlich muss man nur folgendes genau befolgen: Nehmen wir an, wir wollen (t1 t2) evaluieren. Lazy Evaluation: 1. Evaluiere t1 2. Substituiere t2 in t1 – ohne t2 zu evaluieren 3. No Evaluation under Abstraction Eager Evaluation: 1. Evaluiere t1 2. Evaluiere t2, substituiere dann t2 in t1 3. Evaluation is carried out under Abstraction Hier ein konkretes Beispiel zum Verständnis. Achtung: Um die Binding Structure nicht zu verletzen muss man manchmal (durch eine lambda-abstraction) gebundene Variablen umbenennen: Weiter auf der nächsten Seite → Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Induction on Trees: Gleiches Prinzip wie „normale“ Induktionsproofs mit Listen, bloss ist der Base Case hier ein Leaf und der Step Case benötigt oft 2 oder sogar 3 Induktionshypothesen. Falls der Tree irgendwie so definiert ist: 𝑑𝑎𝑡𝑎 𝑇𝑟𝑒𝑒 = 𝐿𝑒𝑎𝑓 | 𝑁𝑜𝑑𝑒 𝑎 (𝑇𝑟𝑒𝑒 𝑎) (𝑇𝑟𝑒𝑒 𝑎) Material zur Übungsstunde von Maximilian Schlegel – mschlegel@student.ethz.ch Arbeitet ihr im Step Case üblicherweise mit dem Case „Node x l r“ und formuliert eure Induktionshypothesen für die Subtrees „l“ und „r“ und zeigt dann, dass die zu beweisende Aussage auch für (Node x l r) gilt, wenn sie per Annahme für die Subtrees l,r gilt. Falls es hierzu Fragen gibt, schreibt mir einfach. Guckt bei Syntax-Fragen in die Zusammenfassungen der Vorwochen.","libVersion":"0.5.0","langs":""}