{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s02a-correctness.pdf","text":"Correctness David Basin Department of Computer Science ETH Z¨urich Functional Programming David Basin 1 Correctness • Correctness is important! What does your program do? • What does this mean? What properties should hold? \u0011 Termination: Important for many, but not all, programs. Examples? \u0011 Functional behavior: Function should return “correct” value. Can be defined by another (mathematically defined) function or an input-output relation. • Correctness is rarely obvious. It must be proven! Functional Programming Spring Semester, 2025 David Basin 2 Correctness (example) • The factorial function can be written as fac 0 = 1 fac n = n * fac (n-1) or as fac2 (0,a) = a fac2 (n,a) = fac2 (n-1,n*a) • Do these functions terminate? fac 3 ; 3 ∗ fac 2 ; 3 ∗ 2 ∗ fac 1 ; 3 ∗ 2 ∗ 1 ∗ fac 0 ; 3 ∗ 2 ∗ 1 ∗ 1 ; 6 fac2 (3, 1) ; fac2 (2, 3 ∗ 1) ; fac2 (1, 2 ∗ 3 ∗ 1) ; fac2 (0, 1 ∗ 2 ∗ 3 ∗ 1) ; 1 ∗ 2 ∗ 3 ∗ 1 ; 6 • Are fac n and fac2 (n, 1) equivalent? Functional Programming Spring Semester, 2025 David Basin 3 Termination • If f is defined in terms of functions g1, . . . , gk (gi ̸= f ), and each gi terminates, then so does f . g x = x * x + 15 f x = (g x + x + 2) / 13 • Problem is recursion, when some gi = f , e.g., fac n. • Sufficient condition for termination: Arguments are smaller along a well-founded order on function’s domain. \u0011 An order > on a set S is well-founded iff there is no infinite decreasing chain x1 > x2 > x3 > . . . , for xi ∈ S. \u0011 Example: >N . Counter examples: >Z, >R. Here we write >S to indicate the domain S, i.e., >S ⊆ S × S Functional Programming Spring Semester, 2025 David Basin 4 An aside on constructing well-founded relations • We can construct new well-founded relations from existing ones • Let R1 and R2 be binary relations on a set S. The composition of R1 and R2 is defined as R2 ◦ R1 ≡ {(a, c) ∈ S × S | ∃b ∈ S. a R1 b ∧ b R2 c} N.B. for binary relation R, we write a R b for (a, b) ∈ R. • Let R ⊆ S × S. Define: R1 ≡ R Rn+1 ≡ R ◦ Rn, for n ≥ 1 R+ ≡ ⋃ n≥1 Rn • So a R+b iff a Ri b for some i ≥ 1 Functional Programming Spring Semester, 2025 David Basin 5 Well-founded relations (cont.) • Lemma: Let R ⊆ S × S. Let s0, si ∈ S and i ≥ 1. Then s0Risi iff there are s1, . . . , si−1 ∈ S such that s0 R s1 R . . . R si−1 R si. \u0011 Proof: induction on i (easy exercise). • Theorem: If > is a well-founded order on the set S, then > + is also well-founded on S. Proof. Assume that a1 > + a2 > + a3 > + . . . is an infinite descending chain. Then, there exist ij ≥ 1 such that aj > ij aj+1, for all j ≥ 1. By the above lemma, the sequence a1 > i1 a2 > i2 a3 > i3 . . . contradicts the well-foundedness of >. Functional Programming Spring Semester, 2025 David Basin 6 Termination: examples fac 0 = 1 fac2 (0,a) = a fac n = n * fac (n-1) fac2 (n,a) = fac2 (n-1,n*a) • Factorial function fac \u0011 fac n has only fac (n − 1) as a recursive call and n > n − 1. \u0011 Here > is the standard ordering over the natural numbers. • Function fac2 \u0011 fac2 (n, a) has only fac2 (n − 1, n ∗ a) as a recursive call. \u0011 The first argument is always smaller under >. • Do fac and fac2 terminate when n < 0? Functional Programming Spring Semester, 2025 David Basin 7 Termination (cont.) Do the following functions terminate? f 0 = 0 f 1 = 1 f n = f (n-1) + f (n-2) g 0 = 1 g 1 = 1 g n = g (n+1) + g (n-2) h (0,y) = y h (x,y) = h (x-1, y+1) What is the well-founded order? What do they actually compute? Functional Programming Spring Semester, 2025 David Basin 8 Correctness — behavior fac 0 = 1 fac2 (0,a) = a fac n = n * fac (n-1) fac2 (n,a) = fac2 (n-1,n*a) • Do fac and fac2 compute the same function in following sense? ∀n ∈ N . fac n = fac2 (n, 1) • Testing can be used to find errors fac 0 = 1 = fac2 (0, 1) fac 1 = 1 = fac2 (1, 1) fac 2 = 2 = fac2 (2, 1) • Correctness requires a formal proof! Functional Programming Spring Semester, 2025 David Basin 9 Correctness — equational reasoning • Proofs based on a simple idea: functions are equations swap :: (Int,Int) -> (Int,Int) swap (a,b) = (b,a) Meaning: For all possible values of a and b: swap (a, b) = (b, a) More formally: ∀a ∈ Z. ∀b ∈ Z. swap(a, b) = (b, a) • Some properties can be shown through equational reasoning. E.g., swap (swap (a, b)) = (a, b). Proof? • More generally: proofs in first-order logic with equality. Functional Programming Spring Semester, 2025 David Basin 10 Correctness — reasoning by cases maxi :: Int -> Int -> Int maxi n m | n >= m = n | otherwise = m Can we prove that maxi n m ≥ n? We have n ≥ m ∨ ¬(n ≥ m) Now show maxi n m ≥ n for both cases Case 1: n ≥ m, then maxi n m = n and n ≥ n Case 2: ¬(n ≥ m), then maxi n m = m. But m > n, so maxi n m ≥ n Functional Programming Spring Semester, 2025 David Basin 11 Correctness (cont.) The previous proof used two inference rules: Excluded Middle (TND): For all propositions P : P ∨ ¬P Case split (∨-E): Given Q ∨ R, to prove any P , we must prove: 1. P follows from Q and 2. P follows from R Functional Programming Spring Semester, 2025 David Basin 12 Proof by induction • How to prove a formula P (with free variable n), for all n ∈ N ? ∀n ∈ N . 0 + 1 + 2 + ... + n = n · (n + 1)/2︸ ︷︷ ︸ P • Proof by cases not possible here: P [n ↦→ 0], P [n ↦→ 1], P [n ↦→ 2], . . . • Use domino principle formulated by Induction proof rule • To prove ∀n ∈ N . P Base case: Prove P [n ↦→ 0] Step case: For an arbitrary m not free in P , prove P [n ↦→ m + 1] under the assumption P [n ↦→ m]. • Exercise: formulate rule ND style and prove example in FOL. Functional Programming Spring Semester, 2025 David Basin 13 Induction as the dual of recursion fac 0 = 1 fac n = n * fac (n-1) 1. Base case, like in induction 2. Step case • States how to compute fac m, given value for fac (m − 1). • Corresponds to proving P [n ↦→ m] from P [n ↦→ m − 1] for m > 0, or, equivalently, proving P [n ↦→ m + 1] from P [n ↦→ m] for m ≥ 0. 3. Correspondence can be precisely formulated Induction is not more complicated or more circular than (terminating) recursive definitions! Functional Programming Spring Semester, 2025 David Basin 14 Example: powers power2 :: Int -> Int -- computes 2^r as 2 * 2 * ... * 1 power2 0 = 1 power2 r = 2 * power2 (r-1) sumPowers :: Int -> Int -- computes 1 + 2 + 4 + ... + 2^r sumPowers 0 = 1 sumPowers r = sumPowers (r-1) + power2 r Examples: sumPowers 3 = 15 power2 4 = 2 4 = 16 sumPowers 5 = 63 power2 6 = 2 6 = 64 How are these functions related? Functional Programming Spring Semester, 2025 David Basin 15 Powers • Conjecture: ∀n ∈ N . (sumPowers n) + 1 = power2 (n + 1) • Proof: Let P ≡ (sumPowers n) + 1 = power2 (n + 1). We show ∀n ∈ N . P by induction on n. Base case: Show P [n ↦→ 0]: (sumPowers 0) + 1 = 1 + 1 = 2 power2 (0 + 1) = 2 · power2 0 = 2 · 1 = 2 Step case: Assume P [n ↦→ m] for an arbitrary m (not in P ), i.e., (sumPowers m) + 1 = power2 (m + 1) and prove P [n ↦→ m + 1], i.e., (sumPowers (m + 1)) + 1 = power2 ((m + 1) + 1). Functional Programming Spring Semester, 2025 David Basin 16 Powers proof (cont.) (sumPowers (m + 1)) + 1 = sumPowers ((m + 1) − 1) + power2 (m + 1) + 1 (def.) = sumPowers (m) + 1 + power2 (m + 1) (arithmetic) = power2 (m + 1) + power2 (m + 1) (ind. hypothesis) = 2 · power2 (m + 1) (arithmetic) = power2 (m + 2) (def.) • We have proven (sumPowers n) + 1 = power2 (n + 1) Equivalently: sumPowers n = (power2 (n + 1)) − 1 • Equation above yields a better definition of sumPowers: \u0011 power2: O(n) iterations \u0011 sumPowers = O(n) iterations + with each iteration a call to power2. Overall: O(n2) calls of power2. Functional Programming Spring Semester, 2025 David Basin 17 Well-founded induction • Induction schema To prove: ∀n ∈ N . P Fix: an arbitrary m not free in P . Assume: ∀l ∈ N . l < m → P [n ↦→ l] (induction hypothesis) Prove: P [n ↦→ m] • Same principle applies to any well-founded domain (S, <S), not just (N , <), the natural numbers with the “smaller than” relation. Functional Programming Spring Semester, 2025 David Basin 18 Deriving 1-step (structural, weak) induction from well-founded induction We show that P holds for all n ∈ N , assuming P [n ↦→ 0] (1) ∀m ∈ N . P [n ↦→ m] → P [n ↦→ m + 1] (2) Proof. By well-founded induction, we fix an arbitrary m ∈ N and establish P [n ↦→ m] assuming ∀l ∈ N . l < m → P [n ↦→ l] (3) We proceed by a case split on m = 0 ∨ m > 0. Case 1: m = 0, and P [n ↦→ 0] follows from (1). Case 2: m > 0, so m = l + 1 for some l ∈ N , i.e., we must prove P [n ↦→ l + 1]. Since l < m, we have P [n ↦→ l] by (3). Hence, P [n ↦→ l + 1] follows from (2). Functional Programming Spring Semester, 2025","libVersion":"0.5.0","langs":""}