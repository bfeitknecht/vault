{"path":"sem4/CN/VRL/extra/slides/CN-s05-transport-layer.pdf","text":"Computer Networks: Transport Simon Scherrer Slides adapted from Ankit Singla, Jennifer Rexford, Scott Shenker, Laurent Vanbever Photo: ETH Zürich / Gian Marco Castelberg Who am I? • Lead Network Engineer at NetFabric.ai (ETH networking spin-off) • Former PhD student in the Network Security Group • ETHZ graduate (BSc'16, MSc'19, PhD’23) • Research in network-sharing strategies, e.g., congestion control • Lecturer for next three lectures about the transport layer Where we are in the course … Part 1: Overview & Principles Part 2: Applications Part 3: Transport Part 4: Algorithms 3 Computer Networks What should the transport layer provide? How do we build reliable transport? How does the Internet’s transport work? Sockets: the application ⟷ transport interface #1 #2 #3 #4 Part 3: Transport 4 Computer Networks What should the transport layer provide? How do we build reliable transport? How does the Internet’s transport work? Sockets: the application ⟷ transport interface #1 #2 #3 #4 Part 3: Transport 5 What should the transport layer provide? 6 Application Layer Applications • Keep minimal (easy to write) • Restricted to app-specific functionality • Want convenient way of using network Network • Keep minimal (easy to build, broadly applicable) • Preoccupied with \"getting from A to B\" (routing) • Global best-effort packet delivery Network Layer Transport Layer Transport layer • Tasked with providing interface for (reliable) transport over a potentially unreliable medium • This relieves burden from both app and network • Key component of \"host networking stack\", i.e., networking code on host, shared by applications What should the transport layer provide? 7 Data delivery to the correct application • Multiple applications on a host may use a network interface • Transport needs to demultiplex incoming data (ports) Files or byte-streams abstractions for applications • Network deals with packets • Transport layer needs to translate between them Reliable transfer (if needed) Not overloading the receiver (flow control) Not overloading the network (congestion control) What should the transport layer provide? 8 systems/ coding issues protocol/ algorithm issues Data delivery to the correct application • Multiple applications on a host may use a network interface • Transport needs to demultiplex incoming data (ports) Files or byte-streams abstractions for applications • Network deals with packets • Transport layer needs to translate between them Reliable transfer (if needed) Not overloading the receiver (flow control) Not overloading the network (congestion control) Computer Networks What should the transport layer provide? How do we build reliable transport? How does the Internet’s transport work? Sockets: the application ⟷ transport interface #1 #2 #3 #4 Part 3: Transport 9 Alice once upon a BobInternet once upon a Alice wants to transmit a text word-by-word to Bob via the Internet 11 The Internet is an unreliable environment though Alice BobInternet 12 Data packets can get lost once upon a upon Alice BobInternet 13 Data packets can get corrupted once upon a twice upon @!#%^*] Alice BobInternet 14 Data packets can get reordered Internet once upon a once upon a Alice Bob 15 Data packets can get duplicated Internet once upon a once upon a once once Alice Bob 16 Bob should receive the complete text as fast as possible minimize time until data is transferred Bob should read exactly what Alice typed in the same order, and without any gap Minimize the use of bandwidth don’t send too many packets correctness timeliness efficiency Our job is to build a reliable way to communicate with Bob 17 Design a protocol that can deal with packet loss, corruption, reordering, and duplication what fields do we add to the packets? what code do we run on the end-points? We send multiple packets, and all packets have to arrive in correct order (receiver has no ability to make sense of incomplete or reordered packets) 19 send_packet(packet); set_timer(); upon timeout: if no ACK received: send_packet(packet); reset_timer(); receive_packet(packet); send_ack(); if packet not delivered to application: deliver_packet(packet); for packet in list: upon ACK: pass; Bob if check(packet.payload) == packet.checksum: else: pass; 21 Alice send_packet(packet); set_timer(); upon timeout: if no ACK received: send_packet(packet); reset_timer(); for packet in list: upon ACK: pass; A lot of practical questions to consider … 22 How to split total data into packets? How long should the timer wait? Is this the right ACK? Alice receive_packet(packet); send_ack(); if packet not delivered to application: deliver_packet(packet); if check(packet.payload) == packet.checksum: else: pass; A lot of practical questions to consider … 23 How to keep track of packets already delivered to the application? What if data contains repetition of identical packets? Bob minimize time until data is transferred ensure data is delivered, in order, and unmodified use bandwidth optimally correctness timeliness efficiency fairness play well with concurrent communications The four goals of reliable transport 2435 ensure data is delivered, in order, and unmodifiedcorrectness We want a crisp, formal translation of this correctness goal attempt #1 Consider that the network is partitioned We cannot say a transport design is incorrect if it doesn’t work in a partitioned network, where delivery is fundamentally impossible… packets are delivered to the receiver A reliable transport design is correct if… 37 Wrong packets are delivered to receiver if and only ifattempt #2 Wrong If the network is only available one instant in time, We cannot say a transport design is incorrect if it doesn’t know the unknowable only an oracle would know when to send it was possible to deliver them A reliable transport design is correct if… 38 It resends a packet if and only if the previous packet was lost or corrupted • packet made it to the receiver and all acknowledgements from receiver were dropped • packet is dropped on the way and all acknowledgements from receiver were dropped A reliable transport design is correct if… 39 attempt #3 Wrong Consider two casesIn both cases, the sender has no feedback at all, although the first case had no loss/corruption and the second case did Does it resend or not? A reliable transport design is correct if… 40 It resends a packet if and only if the previous packet was lost or corrupted attempt #3 Wrong but better as it refers to what the design does (which it can control) not whether it always succeeds (which it can’t) A reliable transport design is correct if… 41 It resends a packet if and only if the previous packet was lost or corrupted attempt #3 Wrong A packet is always resent if [A packet may unnecessarily be resent at other times] A reliable transport design is correct if… 42 attempt #4 Correct! the previous packet was lost or corrupted Sufficient If an algorithm always keeps trying to deliver undelivered packets, it is considered reliable Necessary “if” “only if” if it ever let a packet go undelivered without resending it, it isn’t reliable Note Strictly speaking, that means a transport mechanism is only reliable if it keeps retransmitting forever even in case of a permanent network breakdown In practice, the mechanism can give up at some point. A reliable transport mechanism is correct if and only if it resends all dropped or corrupted packets 43 The four goals of reliable transport 46 minimize time until data is transferred ensure data is delivered, in order, and untouched use bandwidth optimally correctness timeliness efficiency fairness play well with concurrent communications 47 minimize time until data is transferred use bandwidth optimally timeliness efficiency BobAlice Our protocol is extremely slow and wasteful: One packet per Round-Trip Time (RTT) 48 Example: • 100 Mbps network path • 20ms delay to destination • 1500 B packet size • ~3x transmission-time inflation (low timeliness) • Actual time: 60 ms • Optimal time: 20 ms • 0.004% utilization (low efficiency) • Actual rate: 3000 B / 60 ms = 0.4 Mbps • Optimal rate: 100 Mbps add sequence number inside each packet store packets sent & not acknowledged store out-of-sequence packets received sender receiver add buffers to the sender and receiver approach An obvious solution to improve timeliness is to send multiple packets at the same time 49 BobAlice 4 packets sent w/o ACKs 50 supercomputer sends 1000 packet/s can process 10 packet/s overwhelmed smartphone Sending multiple packets improves timeliness, but it can also overwhelm the receiver 51 To not overload the receiver, we need a mechanism for flow control 52 Using a sliding window is one way to do that Receiver also keeps a list of the acceptable sequence # known as the receiving window Sender keeps a list of the sequence # it can send known as the sending window Sender and receiver negotiate the window size sending window <= receiving window 53 Example with a window composed of 4 packets 1 2 3 4 5 6 7 8 9 10 1 1 ...0 ACKed packets unACK’ed packets available packets forbidden packets 54 Window after sender receives ACK 4 1 2 3 4 5 6 7 8 9 10 1 1 ...0 ACKed packets unACK’ed packets available packets forbidden packets 55 The size of the sending window influences the timeliness and the efficiency of the window protocol 56 Sending-window size 1: Our naive packet-by-packet protocol (very untimely and inefficient) Sending-window size ∞: Blast out all data at once (very timely and efficient - if no retransmissions are needed, i.e., if receiver can absorb everything… → need to take receiver capacity into account … and no loss occurs in network... → need to take network capacity into account ) 100 Mbps, 10 ms (one-way) What should be the value of W? (in bytes) Assuming infinite receiver buffers, how big should the sending window be to maximize timeliness and efficiency? 57 Bandwidth-delay product (BDP) = (2 × 10ms) × 100Mbps = 250 KB BobAlice 100 Mbps, 10 ms (one-way) Assuming infinite receiver buffers, how big should the sending window be to maximize timeliness and efficiency? 58 Bandwidth-delay product (BDP) = (2 × 10ms) × 100Mbps = 250 KB BobAlice t = 0 ms Segments in B fill the pipe ACK for first segment in A . triggers window shift into C . just when no segments in B left to send Forward path to receiver is fully used while ACKs travel back to still fully use forward path while ACKs travel back on backward path BDP t = 20 ms C:125 KB AB BDP/2 Link pipe BDP/2 Timeliness and efficiency are aligned when it comes to dimensioning the sending window… 59 … but what about handling loss and delays during transmission? Let’s return to our initial protocol with a 1-packet window send_packet(packet); set_timer(); upon timeout: if no ACK received: send_packet(packet); reset_timer(); receive_packet(packet); send_ack(); if packet not delivered to application: deliver_ packet(packet); for packet in list: upon ACK: pass; if check(packet.payload) == packet.checksum: else: pass; There is a clear tradeoff between timeliness and efficiency in the selection of the timeout value 60 Optimize efficiency small timers unnecessary retransmissions → reduced efficiency large timers Optimize timeliness slow transmission → reduced timeliness risk risk Timeliness argues for small timers, efficiency for large ones: 61 Retransmitting quickly (1) speeds up transmission if packet was really lost (timeliness ↑) (2) wastes bandwidth if packet was not lost, (efficiency ↓) but ACK has not arrived yet Timeliness and efficiency of our protocol depends on receiver feedback and how the sender reacts to it 62 ACKs are also feedback Receiver ACK-ed packets 1, 2, 3, and 5. Maybe 4 is lost? What about letting ACKs drive retransmission, i.e., resend packet 4 if ACK 5 is received before ACK 4? Zero feedback implies relying entirely on timers Very slow: Timer ≥ RTT Retransmission based on missing ACKs: High timeliness (quick recovery from loss if missing ACKs indicate true packet loss) Low efficiency (unnecessary retransmissions if missing ACKs are only delayed) ACKs can be helpful, but how exactly should they look? How should we encode / decode feedback in ACKs? 63 Individual ACKs received 1 … received 2 … received 3 … received 5 Cumulative ACKs received up to 3 Full information ACKs received up to 3 and received 5 Say packet 5 is lost 1ACK stream 2 3 4 6 7 … but no other With individual ACKs, missing packets (gaps) are implicit 64 Advantages know fate of each packet simple window algorithm W single-packet algorithms Disadvantages loss of an ACK packet causes unnecessary retransmission Individual ACKs provide detailed feedback, but trigger unnecessary retransmission on ACK losses 65 1 2 3 4 4 4 … Say packet 5 is lost ACK stream but no other Cumulative ACKs are more robust to ACK loss, but which packets are missing is harder to know 66 when 7 arrives: when 6 arrives: but what do you resend? only 5? 5 and everything after? Stream of ACKs means that (some) packets are delivered Lack of ACK progress means that 5 hasn’t made it Sender could trigger resend situation upon receiving k duplicates ACKs Duplicated ACKs are a sign of isolated losses. Dealing with them is trickier though. 67 Say packet 5 is lost up to 1ACK stream up to 2 up to 3 up to 4 up to 4, plus 6 up to 4, plus 6—7 … but no other Full information ACKs make missing packets (gaps) explicit 68 complete information overhead List all packets that have been received highest cumulative ACK, plus any additional packets approach resilient form of individual ACKs advantages disadvantages e.g., when large gaps between received packets (hence lowering efficiency) Full Information ACKs prevent unnecessary retransmissions, but incur a sizable overhead 69 individual ACKs full feedback cumulative ACKs out-of-order ACKs gapped ACKs duplicate ACKs How do the ACKing strategies perform under reordering of packets? 70 1 2 3 ACK 1 ACK 1 ACK 3 2 1 2 3 ACK 1 ACK 1, 3 ACK 3 2 1 2 3 ACK 1 ACK 3 ACK 2 2 In all designs, reordering can be confused for loss and cause unnecessary retransmission if retransmission is triggered by unexpected acknowledgement How do the ACKing strategies perform under duplication of packets? 71 1 2 3 ACK 1 ACK 1 ACK 2 4 2 individual ACKs full feedback cumulative ACKs no problem no problem problematic duplicate ACKs can be confused for loss and cause unnecessary retransmission Long delays can create useless timeouts, for all designs How do the ACKing strategies perform under delay of packets? 72 Dealing with corruption is easy: Rely on a checksum, treat corrupted packets as lost How do the ACKing strategies perform under corruption of packets? 73 Choosing an ACK strategy is about balancing tradeoffs (as always in the Internet) ACKing strategies describe how the receiver should provide feedback. 75 Another question: How should the sender react to this feedback? → Retransmission algorithms: Go-Back-N: Upon inferred loss, retransmit everything not acknowledged yet Selective Repeat: Upon inferred loss, retransmit only packet considered lost TCP retransmission algorithm: see next lecture receiver should be as simple as possibleprinciple receiver For each received segment, ACK the last in-order packet delivered (cumulative) Go-Back-N (GBN) is a simple sliding window protocol using cumulative ACKs 76 upon timeout, resend all W packets starting with the lost one sender use a single timer to detect loss, reset at each ACK no reaction to duplicate ACKs avoids unnecessary retransmissionsprinciple acknowledge each packet, in-order or not (individual ACKs)receiver buffer out-of-order packets Selective Repeat (SR) avoid unnecessary retransmissions by using per-packet ACKs (see Book 3.4.4) 77 upon loss, only resend the lost packet sender use per-packet timer to detect loss no reaction to ACK gaps http://www.ccs-labs.org/teaching/rn/animations/gbn_sr/ Let’s see how it works in practice visually 78 minimize time until data is transferred ensure data is delivered, in order, and untouched use bandwidth optimally correctness timeliness efficiency fairness play well with concurrent communications The four goals of reliable transport 8081 fairness play well with concurrent communications 83 When n entities are using our transport mechanism, we want a fair allocation of the available bandwidth A B 1Gbps C 1Gbps What is a fair allocation for the 3 flows? flow 1 flow 2 flow 3 Consider this simple network in which three hosts are sharing two links 84 A B 1Gbps C 1Gbps flow 1 flow 2 flow 3 500 Mbps 500 Mbps 500 Mbps Total traffic is 1.5 Gbps An equal allocation is certainly “fair”, but what about the effective use of the network? 85 A B 1Gbps C 1Gbps flow 1 flow 2 flow 3 1 Gbps 1 Gbps 0 Mbps Total traffic is 2 Gbps! Fairness and effective use don’t always play along, here an unfair allocation allows more effective use 86 What is fair anyway? A B 1Gbps C 1Gbps flow 1 flow 2 flow 3 500 Mbps 500 Mbps 500 Mbps Equal-per-flow isn’t really fair as (A,C) crosses two links: it uses more resources (network view instead of link view) 88 Is it fair? With equal-per-flow, A ends up with 1 Gbps because it sends 2 flows, while B ends up with 500 Mbps 89 equal per flow is good enough for this Exact notions of fairness are debatable. A universally shared minimal goal is to avoid starvation. 90 A B 1Gbps C 10 Gbps flow 1 flow 2 flow 3 (A,B) (B,C) (A,B) bottleneck link Simply dividing the available bandwidth doesn’t work in practice since flows can see different bottlenecks 91 Max-min fair allocation is such that the lowest demand is maximized after the lowest demand has been satisfied, the second lowest demand is maximized after the second lowest demand has been satisfied, the third lowest demand is maximized and so on… Intuitively, we want to give users with \"small\" demands what they want, and evenly distribute the rest 92 Max-min fair allocation can easily be computed Start with all flows at rate 0 Done! step 1 Increase the flows simultaneously until there is a new bottleneck in the network Hold the fixed rate of the flows that are bottlenecked step 2 step 3 Go to step 2 for the remaining flowsstep 4 93 Let’s try on this network A B 1Gbps C 10 Gbps flow 1 flow 2 flow 3 What’s the max-min fair allocation? 94 0.5 Gbps 0.5 Gbps 9.5 Gbps Progressively increase the sending window size Intuition Whenever a loss is detected, decrease the window size Repeat signal of congestion max=receiving window Max-min fair allocation can be approximated by slowly increasing W until a loss is detected 95 minimize time until data is transferred ensure data is delivered, in order, and untouched use bandwidth optimally correctness timeliness efficiency fairness play well with concurrent communications The four goals of reliable transport 97 retransmission full information ACK after timeout ACKing after k subsequent ACKs window management additive increase upon successful delivery multiplicative decrease when timeouts We'll come back to this when we see TCP Here is one correct, timely, efficient and fair transport mechanism 98","libVersion":"0.3.2","langs":""}