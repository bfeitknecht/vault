{"path":"sem4/FMFP/UE/s/FMFP-u03-s.pdf","text":"Formal Methods and Functional Programming Solutions Sheet 3 252-0058-00L March 3, 2025 1. Induction (a) Solution Γ ⊢ P [n ↦→ 0] Γ ⊢ ∀m : Nat. P [n ↦→ m] → P [n ↦→ m + 1] Γ ⊢ ∀n : Nat. P (m not free in P ) (b) Solution First we state and prove a lemma that relates the function aux to fibLouis: Lemma 1. ∀ n:Nat. aux n = (fibLouis n, fibLouis (n+1)) Proof. Let P := (aux n = (fibLouis n, fibLouis (n+1))). We show ∀ n:Nat. P by induction. Base case. Show P[n↦→ 0]. aux 0 = (0, 1) -- aux.1 = (fibLouis 0, fibLouis 1) -- fibLouis.1, fibLouis.2 = (fibLouis 0, fibLouis (0+1)) -- arithmetic Step case. Let m:Nat be arbitrary. (Note that m is not free in Let P.) Show that P[n↦→m] implies P[n↦→m+1]. So, assume aux m = (fibLouis m, fibLouis (m+1)) and show P[n↦→m+1]: aux (m+1) = next (aux m) -- aux.2 = next (fibLouis m, fibLouis (m+1)) -- P[n/m] = (fibLouis (m+1), fibLouis m + fibLouis (m+1)) -- next.1 = (fibLouis (m+1), fibLouis (m+2-1) + fibLouis (m+2-2)) -- arithmetic = (fibLouis (m+1), fibLouis (m+2)) -- fibLouis.3 = (fibLouis (m+1), fibLouis ((m+1)+1)) -- arithmetic Note that in the first step, we actually have to check the condition that the argument of aux (m+1) really isn’t equal to 0, because otherwise the case aux.1 would apply. Since m+1 > 0, this holds. Furthermore, for the last step we have to check that the argument of fibLouis is neither 0 nor 1. This is the case, as m+2 > 1. With the help of Lemma 1, the proof of the proposition is simple. Proposition ∀ n:Nat. fibEva n = fibLouis n 1 Formal Methods and Functional Programming Solutions Sheet 3 252-0058-00L March 3, 2025 Proof. Let n:Nat be arbitrary. fibEva n = fst (aux n) -- fibEva.1 = fst (fibLouis n, fibLouis (n+1)) -- Lemma 1 = fibLouis n -- def. of fst 2. Foldr (a) Solution Recall that the function foldr is defined as foldr :: (a -> b -> b) -> b -> [a] -> b foldr f z [] = z -- foldr.1 foldr f z (x:xs) = f x (foldr f z xs) -- foldr.2 The evaluation steps are as follows: foldr g 0 [1,2,3] g 1 (foldr g 0 [2,3]) 1 + (foldr g 0 [2,3]) 1 + (g 2 (foldr g 0 [3])) 1 + (1 + (foldr g 0 [3])) 1 + (1 + (g 3 (foldr g 0 []))) 1 + (1 + (1 + (foldr g 0 []))) 1 + (1 + (1 + 0)) 1 + (1 + 1) 1 + 2 3 The function foldr g 0 has type [a] -> Int and returns the length of the given list. (b) Solution foldr (:) [] is the identity function on lists. Proof. Let P := (foldr (:) [] xs = xs). We prove by induction over lists that ∀ xs::[a].P holds. Base case: Show P[xs/[]]. foldr (:) [] [] = [] -- foldr.1 Step case: Let a and ys::[a] be arbitrary. Show that P[xs/ys] implies P[xs/y:ys]. Assume foldr (:) [] ys = ys and we show that foldr (:) [] (y:ys) = y:ys. 2 Formal Methods and Functional Programming Solutions Sheet 3 252-0058-00L March 3, 2025 foldr (:) [] (y:ys) = (:) y (foldr (:) [] ys) -- foldr.2 = (:) y ys -- P[xs/ys] = (y:ys) -- syntax change (c) Solution filterMap1 :: (b -> Bool) -> (a -> b) -> [a] -> [b] filterMap1 p f = foldr aux e where aux x y | p ( f x) = (f x) : y | otherwise = y e = [] Alternatively, the function can be written as a lambda expression: filterMap2 :: (b -> Bool) -> (a -> b) -> [a] -> [b] filterMap2 p f = foldr (\\x y -> if p (f x) then (f x) : y else y) [] 3","libVersion":"0.5.0","langs":""}