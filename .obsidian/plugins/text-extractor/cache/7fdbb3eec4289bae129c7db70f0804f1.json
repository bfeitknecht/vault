{"path":"sem1/AuD/VRL/other/lbehric/A&D-lbehric-w05.pdf","text":"Exercise sheet 5 Exercise 5 .1 ↓ - Y ↓- - - Insertion sort Bubblesort 1/() -I FL I I - Merge sort Selection sort Exercise 5 .2 Alice : a, b = (1, . . ., 2003 a) Bob a, b'e 90, ..., 2013 Ko = 1 kn = 2kn -e + 2 k = 0 O ~ L k = 1 O G- * 2 O kn = 3 . 2\" - 2 ↓ k = 1 O O O Alice 200. 199 = 19 . 900 L L O G · Of k+ = 12 . 288 <19 . 308- * 2 * 2 b) ( = 1 (n++ = 2(n + 1 1 k = 8 O k = T I 3· 9 O ↑k = 2 · I 7o O· (n = 2\" - 1(y = 16 . 383 19 . 900 Exercise 5 .3 - (a) O(log n) Elt WE T+e-Iteration = O(logn) (3) #I Key (N) >- Key (P) < key (c) => Key(P) > key (1) T catEX (c) Ein Key(D) 2 Key (C) Theorie : AVL-Bäume = Av((u): (h , (4) - hr(u)) = T - E 1 . Case left-left E ma 2 . right-right 1/0, left-rotations 1 B 3 . left-right I * left-rotation % 4 . Fa ll : right-left am ,! Exercise 5 . 5 (a) 1 . ③ 2 . ④ 3 . B Eben 4 . - 5. O I , 8 O yo % /0 (b) Yo , Le s ④3 7 , del(4) option Option 2 . · - % > ④ T Dynamic Programming Jump Game Array A (1, . . . , n3 vo n po s i max . Ali] sprünge nach vorne Teilproblem M(t] : = maximaler Index, den wir in ksprüngen erreichen können M(k) = max [itAlis /M(k-23 <i M(k - 1)) M(k - 2) U(k - 1) M(k) ↓ ↓ ↓=> braucht =kx-2 braucht genau Sprünge k- 1 Sprünge Längste Gemeinsame Teilfolge m ,n DP (m + 1)(n+) - T 1 G E R ((iij) : Länge (GT von A(1, ... i] und B(1 , .. -ij)- - O O o 0 O & Z g O Y O 0 0 O 1 . Benutze Asi3 und Alj) falls gle T-10 8 1 IL E 0 2 . /3.. Alil /A lj nicht benutzen a 10 I E O Falls B( j), dann ((isj) = max(1+((i-1,-1), ((i - 1 ,5) , ((iyj - 13- \"Code\" : sonst ((iis) = max [L(i-1,j), ((s,j-1)) (Zuerst Base Cases for (i=1, ..., n) for(j=1, ..., m) if (A(i) = = B(s]) DP(i](j) \" max { ... ) else DP (i) (j) = ... Editier distan Z ED(iij) : = Editierdistanz A(, . . . , i) zu B(c, . . . ,j) - T1GE R Was passiert mit A(i) in optimaler Lösung? ~ o 12345 Z 1 1 ↓ 2 Fall 1 : Ali) wird gelöscht I 2e 1 ED(i ,j) = 1 + EDli-1, i) E 3 G Fall 2 : A(i) wird am Ende auf etwas in B(1, . ..,j-1] gematched - E 3 = > Dann ED(i ,j) = 1 + ED(i , j - 1) Fall 3 : A(i) auf B( j) gemateht ED(i ,j) = S O+ ED (i-1 , j-1) falls Alis = B(s) 1 + ED(i-1, j-a) falls A (i) + B(j) w A(i] wird in B(j) geändert für i ,j0 ED(is) = min{ ED(i ,j)+ 1, A(i) öscher ED(i, j - 1) + 11 B(j3 einfügen ED(i - 1, j - 1) + 50 Falls A() = BG ) 3 ↑ fa lls A(i) + B(j] Longest Snake Input : · Menge an Hexagon-Feldern F = Er, . .., n) · Jedes Feld feF hat einen Wert v = N · N(+) = 4919 is t an f benachbart) in 0(t) . De f. Schlange der Längek : Sequenz von K Feldern s = (fe, fa, . . . . fx),1 sodass Vje(1, ...,k-13 : fjtEN(ts) , also dass fjt Nachbar von fi is t UND Vit = V j + 1 . Gesucht : Länge der längsten Schlange in F.. Rekursiv : Menge an Feldern max Snake( il : Länge der längsten Schlange, die bei Feld i endet .I Schlange Elhat in max Snake (F ,i) = max (maxSnake (F((, 3 ,j) + 1(jeN(i) -v , = vi + 1) return max maxsuake (F, i) 1 ein ~ exponential runtime Dynamic - Programming Dimensions of ta ble :- x n Meaning of an entry : dp(i): = length of lougest snake ending at field . Calculation of an entry : dp(i) = max[dp(j](jew(i)a vi = + + 1) + 1 Calculation order : jeW(i) -Vi = muss dp(j schon berechnet sein ! Lösung : Sortiere F nach V aufsteigend . Runtime: O(nlogn) Wegen sortieren . Extracting the solution : max dp(i) Ein DP-Marathon M X > M 2 V Dimensions of DP -Tab le : 2x n meaning of an entry : DP ( i] ( j] : = kürzeste Zeit benötigt um Feld (i ,j) zu erreichen Cij * Kosten des Fudes (i ij) Calculation of an entry : DP(1 ,j] = (n, j + min[1+DP(2,-1 + (2,, DP (11 j - 1) DP(2 ,j) = G, j + min {1s , DP(2 , j - 13) DP (1, j]# lit Calculation order : Base Case : DP(1 , 1) = 0 DP (2 , 1) = C2,1 + 1 von Links nach rechts, unter nach oben . Extracting the solution : return DP (2) (n) Runtime : 8(n) P .G . Ex . 5 .2","libVersion":"0.3.2","langs":""}