{"path":"sem4/FMFP/PV/exams/30-finals/FMFP-FS15.pdf","text":"Computer Science Department D. Basin P. M¨uller Formal Methods and Functional Programming Exam August 18th, 2015, 9:00 – 12:00 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 32 pages; the back page of this booklet is page 32. After the exam begins, check that your exam papers are complete (6 assignments for the FP part, 5 assignments and 2 pages of background material for the FM part). 2. Only write on the exam paper and extra paper sheets which are given by the assis- tants. Do not take any of this paper out of the exam: submit it all. Write your ﬁrst and last name and your student number on every sheet of paper that you write on. 3. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 4. For the FP part of the exam, you may use any functions from the Haskell Prelude and Data.List in your solutions (without giving their deﬁnitions). 5. Write clearly in the sense of logic, language, and readability. Label all rule applica- tions in your derivation trees. The clarity of your arguments and explanations a↵ects your grade. 6. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 8 9 10 11 ∑ Max. points 6 6 9 5 7 12 5 8 15 6 11 90 Your points Part I: Functional Programming Formal Methods and Functional Programming, Exam, SS15 4 Assignment 1: Typing (6 points) Recall the types of the following functions and constants deﬁned in the Haskell Prelude: (:) :: a -> [a] -> [a] [] :: [a] (==) :: Eq a => a -> a -> Bool (<) :: Ord a => a -> a -> Bool (.) :: (b -> c) -> (a -> b) -> a -> c map :: (a -> b) -> [a] -> [b] filter :: (a -> Bool) -> [a] -> [a] Give the most general type for the following expressions. You do not need to provide a formal derivation. (a) \\x y z -> z y x (b) \\x y -> (==) (map x y) (c) \\x -> filter x ((<) : []) (d) \\x y -> map x (y ( . x)) Hint: The section (. x) in Haskell is equivalent to \\z -> z . x. Formal Methods and Functional Programming, Exam, SS15 6 Assignment 2: Natural Deduction (6 points) We recall the following rules from natural deduction for ﬁrst order intuitionistic logic: \u0000,A ￿ A Ax \u0000,A ￿ B \u0000 ￿ A → B → I \u0000 ￿ A → B \u0000 ￿ A \u0000 ￿ B → E \u0000 ￿ ￿ \u0000 ￿ A ￿E \u0000,A ￿ ￿ \u0000 ￿ ¬A ¬I \u0000 ￿ ¬A \u0000 ￿ A \u0000 ￿ B ¬E \u0000 ￿ A \u0000 ￿ B \u0000 ￿ A ∧ B ∧I \u0000 ￿ A ∧ B \u0000 ￿ A ∧EL \u0000 ￿ A ∧ B \u0000 ￿ B ∧ER \u0000 ￿ A \u0000 ￿ A ∨ B ∨IL \u0000 ￿ B \u0000 ￿ A ∨ B ∨IR \u0000 ￿ A ∨ B \u0000,A ￿ C \u0000,B ￿ C \u0000 ￿ C ∨E \u0000 ￿ A(x) \u0000 ￿ ∀x. A(x) ∀I∗ \u0000 ￿ ∀x. A(x) \u0000 ￿ A(t) ∀E \u0000 ￿ A(t) \u0000 ￿ ∃x. A(x) ∃I \u0000 ￿ ∃x. A(x) \u0000,A(x) ￿ B \u0000 ￿ B ∃E∗∗ Side conditions: (*) x does not occur free in any formula in \u0000 and (**) x does not occur free in any formula in \u0000 or B. Prove using the above rules that (∃x. P (x)) → ¬ (∀x. ¬ P (x) ∧ Q) holds. Label each inference step with the name of the corresponding rule. Formal Methods and Functional Programming, Exam, SS15 8 Assignment 3: Induction (9 points) Consider the following declarations. data Tree = Node Tree Tree | Leaf Int addSum (Leaf x) n = x + n -- addSum.1 addSum (Node l r) n = addSum l (addSum r n) -- addSum.2 toList (Leaf x) = [x] -- toList.1 toList (Node l r) = toList l ++ toList r -- toList.2 sum [] = 0 -- sum.1 sum (x:xs) = x + sum xs -- sum.2 [] ++ ys = ys -- ++.1 (x:xs) ++ ys = x : (xs ++ ys) -- ++.2 Prove that for all ﬁnite trees t:: Tree the equality sum (toList t) = addSum t 0 holds. Structure your proof clearly and justify every proof step. You may use the following lemma without proof: Lemma 1: ∀xs, ys :: [Int]. sum (xs ++ ys) = sum xs + sum ys Hint: You may want to generalize the statement before using induction. Formal Methods and Functional Programming, Exam, SS15 10 Assignment 4: Partial sums (5 points) Deﬁne a function psum :: [Integer] -> [Integer] that takes a list and returns the list of all partial sums. That is, the i-th element of the computed list is the sum of the ﬁrst i − 1elementsof thegivenlist. Your function should inspect each element of the given list only a constant number of times and also work for inﬁnite lists. Examples: psum [5,2,6] = [0,5,7,13] take 5 (psum [1..]) = [0,1,3,6,10] Formal Methods and Functional Programming, Exam, SS15 12 Assignment 5: Skew heaps in Haskell (7 points) In this assignment, we consider binary trees with Int labels at the inner nodes and unla- belled leaves. A binary tree is a skew heap if for every node in the tree, every label in its two subtrees is at least as large as the label at the node. (a) Deﬁne a datatype Heap of binary trees with Int labels at the nodes. (b) Write a function getMin :: Heap -> Maybe Int that returns the least label in a skew heap. It should return Nothing if and only if the given skew heap does not contain any labels. The function may assume that the argument is a skew heap. (c) Write a recursive function merge :: Heap -> Heap -> Heap which merges two skew heaps p and q.The resulting tree should be a new skew heap whose labels are exactly all the labels of p and q respecting their multiplicity. Hint: Heap merges usually balance the tree. Your solution does not need to do this. (d) Deﬁne a function delMin :: Heap -> Heap that removes the least label from a skew heap (if there is any label). Hint: Use merge. Formal Methods and Functional Programming, Exam, SS15 14 Assignment 6: Model checking (12 points) Propositional modal logic (PML) extends propositional logic (Aussagenlogik) with a modal operator E.Formally, the syntax of a formula ' in PML is deﬁned by the following grammar (in BNF notation) where p ranges over a given set AP of atomic propositions: ' ∶∶= p ￿ ¬' ￿ ' ∧ ' ￿ E' We model formulas in PML with atomic propositions of type a as a datatype Fa. data F a = AP a | Not (F a) | And (F a) (F a) | E (F a) (a) Deﬁne the canonical fold operation foldF for PML formulas in Haskell. foldF :: (a -> b) -> (b -> b) -> (b -> b -> b) -> (b -> b) -> F a -> b (b) Instantiate the Show type class for PML formulas. Atomic propositions should be printed without AP and And be displayed inﬁx as &&.Enclose all non-atomic sub- formulas in parentheses. Example: show (Not (And (AP ’a’) (E (AP ’b’)))) = \"(Not (’a’ && (E ’b’)))\" Formal Methods and Functional Programming, Exam, SS15 15 PML formulas are interpreted over transition systems. Recall from the FM part of the course that a transition system consists of a transition relation → ⊆ S × S between states S,and a labelling function lab ∶ S → P(AP) which labels each state with a set of atomic propositions from the set AP.Satisfaction ￿ is deﬁned recursively as follows where K = ￿S, →, lab￿ is a transition system and s is a state: K,s ￿ p i↵ p ∈ lab(s) ￿￿￿￿ ￿ ￿￿￿￿ like in propositional logicK,s ￿ ¬' i↵ not K,s ￿ ' K,s ￿ ' ∧ i↵ K,s ￿ ' and K,s ￿ K,s ￿ E' i↵ K,s′ ￿ ' for some s′ ∈ S with (s, s′) ∈ →, i.e., s → s′ Intuitively, a formula E' holds in a state s of a transition system K if there exists a successor state s′ of s where ' holds. The following Haskell type TS s a models a transition system over states of type s and atomic propositions of type a with two functions: the successor function returns the list of successor states and the labelling function tests whether an atomic proposition holds in a given state. type TS s a = (s -> [s], s -> a -> Bool) (c) Write a function mc :: TS s a -> s -> F a -> Bool that determines whether a transistion system K with initial state s satisﬁes a PML formula ',i.e.,whether K,s ￿ ' holds. Bonus: If you implement mc correctly using foldF without explicit recursion, you get two additional points to compensate for points you might have lost in the FP part. Part II: Formal Methods Formal Methods and Functional Programming, Exam, SS15 19 Assignment 7 (5 points) Consider the following IMP statement s: (x := 3; y := 4); while x - y < 0 do x:= x+ 1 end Prove using the structural operational semantics that there is a state \u0000′ with \u0000′(x) = 4suchthat ￿s, \u0000zero￿ → ∗ 1 \u0000′.Provide the complete derivation sequence, and show the derivation tree justifying the ﬁrst step in your derivation sequence. Formal Methods and Functional Programming, Exam, SS15 20 Assignment 8 (8 points) Consider the following IMP program s: i:= 0; r:= 1; while i < k do i:= i+ 1; r:= r* n end We give below an incorrect total correctness proof outline for the following Hoare triple: { k ≥ 1 ∧ k = K ∧ n ≥ 1 ∧ n = N } s { ⇓ r = N K }. The proof outline contains errors, which you need to identify and explain. {k ≥ 1 ∧ k = K ∧ n ≥ 1 ∧ n = N } i:= 0; {k ≥ 1 ∧ k = K ∧ n ≥ 1 ∧ n = N ∧ i = 0} ￿ {1 = ni ∧ n = N ∧ k = K} r:= 1; {r = ni ∧ n = N ∧ k = K} while i < k do {i < k ∧ r = ni ∧ k − i = V } ￿ {r = ni} i:= i+ 1; {r = ni−1} ￿ {r ∗ n = ni} r:= r* n {⇓ r = ni} end {⇓ ¬(i < k) ∧ r = ni ∧ k = K ∧ n = N } ￿ {⇓ r = N K} Formal Methods and Functional Programming, Exam, SS15 21 (a) Find the errors in the above proof outline. For each error, include a short explanation of what is missing or incorrect. Your explanation should include the name of the rule which is wrongly applied. You do not need to correct the mistakes. (b) Which of the errors that you identiﬁed in part (a) would also be errors in a partial correctness proof outline? Formal Methods and Functional Programming, Exam, SS15 22 Assignment 9 (15 points) Programming languages with parallelism sometimes support constructs that force a thread to wait for a certain condition to hold before they can continue execution. In this question, we consider extending IMP with such a construct, but we start from only basic IMP (without any extensions such as parallelism). We add a new statement of the form: once b do x := e end. Informally, its meaning is that execution is blocked if b is not true. If b is true, then execution continues by executing the nested assignment, as the next step. We can easily deﬁne appropriate extensions of the big- and small-step operational se- mantics for IMP; in each case we add just one derivation rule, as follows: (OnceNS) ￿once b do x := e end, \u0000￿ → \u0000[x ￿ A[[e]]\u0000] if B[[b]]\u0000 = tt (OnceSOS) ￿once b do x := e end, \u0000￿ →1 \u0000[x ￿ A[[e]]\u0000] if B[[b]]\u0000 = tt (a) Consider the big-step semantics for IMP, including the extra rule above. Is it true that (for all b, x and e), the statement once b do x := e end is semantically equivalent to the statement while not b do skip end;x := e ?Brieﬂy justify your answer (you do not need to provide a formal proof). (b) Consider the small-step semantics for IMP, including the extra rule above. Is it true that (for all b, x and e), the statement once b do x := e end is semantically equivalent to the statement while not b do skip end;x := e ?Brieﬂy justify your answer (you do not need to provide a formal proof). Formal Methods and Functional Programming, Exam, SS15 23 (c) We now consider extending the partial correctness rules for axiomatic semantics,to support this construct. We add the following rule to the partial correctness Hoare Logic rules: (OnceAx) { P [x￿e] ∨ ¬b } once b do x := e end { P } Prove that: ∀Q, R, b, x, e. ￿ { Q } once b do x := e end { R } ⇒￿ { Q } while not b do skip end;x := e { R } Formal Methods and Functional Programming, Exam, SS15 25 Assignment 10 (6 points) (a) Consider the following graph that depicts a transition system. The extra labels on each state indicate which of three atomic propositions p, q and r are true in that state. s1 {} s2 {p} s3 {r} s4 {q} For each of the following LTL formulas, state whether or not the formula deﬁnes a property which is valid in the given transition system and justify your answer: if the property is valid then brieﬂy explain why; if it is not valid then provide a counterexample. 1. ￿p 2. ￿p ∨￿q 3. ￿￿ r 4. (￿q) ⇒ ￿¬p Formal Methods and Functional Programming, Exam, SS15 26 (b) Consider the LTL formula (￿(p′ ⇒ ￿￿ ¬p′)) (in which p′ is an atomic proposition). Does this formula deﬁne a safety or a liveness property? Justify your answer (a clear explanation is enough; you do not need to provide a formal proof). Formal Methods and Functional Programming, Exam, SS15 27 Assignment 11 (11 points) Introduction Figure 1 shows a row of seven stones,six of which are occupied by a frog. There are three female frogs, located on the leftmost three stones, and three male frogs, located on the rightmost three stones. The stone in the centre is empty. Figure 1: Initial conﬁguration Each frog only moves in one direction: female frogs can only move to the right, and male frogs can only move to the left. A frog can either (i) move to an empty, adjacent stone, or (ii) move to an empty stone two stones away if the stone in between is occupied by another frog (i.e. jump over the frog). See Figure 2 for an illustration. Figure 2: Illustrating possible moves Task Write a Promela model that can be used to answer the following question: is there asequenceofmovesthatwillexchangethepositionsofthefemaleandmalefrogs? See Figure 3 for an illustration of the desired ﬁnal conﬁguration of the frogs (the order of the individual male and female frogs does not matter). You should make sure (adding short comments if necessary) that it is clear how your solution can be used to check for the answer to this question. If you use any macros or procedures in your solution, you should include their deﬁnitions. Figure 3: Desired ﬁnal conﬁguration Formal Methods and Functional Programming, Exam, SS15 31 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ∶∶= skip ￿ x := e ￿ s; s ￿ if b then s else s end ￿ while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). Natural Semantics (Big-Step Semantics) (SkipNS) ￿skip, \u0000￿ → \u0000 (AssNS) ￿x := e, \u0000￿ → \u0000[x ￿ A[[e]]\u0000] ￿s1, \u0000￿ → \u0000′ ￿s2, \u0000′￿ → \u0000′′ (SeqNS) ￿s1;s2, \u0000￿ → \u0000′′ ￿s1, \u0000￿ → \u0000′ (IfTNS) ￿if b then s1 else s2 end, \u0000￿ → \u0000′ if B[[b]]\u0000 = tt ￿s2, \u0000￿ → \u0000′ (IfFNS) ￿if b then s1 else s2 end, \u0000￿ → \u0000′ if B[[b]]\u0000 = ↵ ￿s, \u0000￿ → \u0000′ ￿while b do s end, \u0000′￿ → \u0000′′ (WhTNS) ￿while b do s end, \u0000￿ → \u0000′′ if B[[b]]\u0000 = tt (WhFNS) ￿while b do s end, \u0000￿ → \u0000 if B[[b]]\u0000 = ↵ Formal Methods and Functional Programming, Exam, SS15 32 Structural Operational Semantics (Small-Step Semantics) (SkipSOS) ￿skip, \u0000￿ →1 \u0000 (AssSOS) ￿x := e, \u0000￿ →1 \u0000[x ￿ A[[e]]\u0000] ￿s1, \u0000￿ →1 \u0000′ (Seq1SOS) ￿s1;s2, \u0000￿ →1 ￿s2, \u0000′￿ ￿s1, \u0000￿ →1 ￿s′ 1, \u0000′￿ (Seq2SOS) ￿s1;s2, \u0000￿ →1 ￿s′ 1;s2, \u0000′￿ (IfTSOS) ￿if b then s1 else s2 end, \u0000￿ →1 ￿s1, \u0000￿ if B[[b]]\u0000 = tt (IfFSOS) ￿if b then s1 else s2 end, \u0000￿ →1 ￿s2, \u0000￿ if B[[b]]\u0000 = ↵ (WhileSOS) ￿while b do s end, \u0000￿ →1 ￿if b then s;while b do s end else skip end, \u0000￿ Axiomatic Semantics (partial correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ￿ e]} x := e { P } { P } s1 { Q }{ Q } s2 { R } (SeqAx) { P } s1;s2 { R } { b ∧ P } s1 { Q }{ ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P′ } s { Q′ } (ConsAx) { P } s { Q } if P ￿ P′ and Q′ ￿ Q Axiomatic Semantics (total correctness) As for partial correctness above, except for the following rule, which replaces (WhAx) : { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ￿ 0 ≤ e","libVersion":"0.5.0","langs":""}