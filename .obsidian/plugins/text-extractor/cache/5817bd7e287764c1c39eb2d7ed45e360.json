{"path":"sem4/FMFP/UE/e/FMFP-u06-e.pdf","text":"Formal Methods and Functional Programming Exercise Sheet 6 252-0058-00L March 24, 2025 For the first part of the course, there will be both pen-and-paper exercises and programming exercises. The programming exercises are uploaded on Code Expert: https://expert.ethz.ch/enrolled/SS25/fmfp/exercises Happy coding! As for the pen-and paper exercises, each week you may hand in your solution to the exercise marked with a (⋆) and receive feedback from your TA. You are encouraged to do so. Of course, if you have any questions about the solutions of the other exercises, please also reach out to your TA! Exercises marked as weekly headaches are challenging bonus problems. They are just meant as supplements to test your FMFP skills. 1. Induction on Trees Recall the algebraic data type Tree a and the function mapTree from the lecture: data Tree a = Leaf | Node a (Tree a) (Tree a) mapTree f Leaf = Leaf mapTree f (Node x t1 t2) = Node (f x) (mapTree f t1) (mapTree f t2) Prove that for arbitrary f :: a -> b and g :: b -> c ∀t :: Tree a. mapTree g (mapTree f t) = mapTree (g . f) t structural induction over Tree. Remark: You will also find this exercise on CodeExpert if you wish to have it checked by CYP. 2(⋆). Evaluation In the lecture you have seen that Haskell evaluates terms lazily. The lazy evaluation strategy for an application t1 t2 works as follows. 1. Evaluate t1. 2. The argument t2 is substituted in t1 without being evaluated. 3. No evaluation inside lambda abstractions. In other words, in an abstraction (\\t -> f t), (where f is some arbitrary term), then f t is not evaluated. The eager evaluation strategy for an application t1 t2 works as follows. 1. Evaluate t1. 1 Formal Methods and Functional Programming Exercise Sheet 6 252-0058-00L March 24, 2025 2. t2 is evaluated prior to substitution in t1. 3. Evaluation is carried out inside lambda abstractions. Consider the term: (\\x -> x (\\y -> x y)) (\\x -> (\\y -> y) x) Evaluate it using (a) the lazy evaluation strategy, and (b) the eager evaluation strategy. Show all intermediate steps during the evaluation. 3. More Induction Consider the following declarations. data Tree = Node Tree Tree | Leaf Int addSum (Leaf x) n = x + n -- addSum.1 addSum (Node l r) n = addSum l (addSum r n) -- addSum.2 toList (Leaf x) = [x] -- toList.1 toList (Node l r) = toList l ++ toList r -- toList.2 sum [] = 0 -- sum.1 sum (x:xs) = x + sum xs -- sum.2 [] ++ ys = ys -- ++.1 (x:xs) ++ ys = x : (xs ++ ys) -- ++.2 Prove that for all finite trees t :: Tree the equality: sum (toList t) = addSum t 0 holds. You may use the axiom arith: n + 0 = n You may also use the following lemma without proof: Lemma sumAppend : ∀xs, ys :: [Int]. sum (xs ++ ys) = sum xs + sum ys Hint: You may want to generalize the statement before using induction. Remark: You will also find this exercise on CodeExpert if you wish to have it checked by CYP. 2","libVersion":"0.5.0","langs":""}