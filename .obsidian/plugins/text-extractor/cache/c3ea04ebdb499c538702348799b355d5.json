{"path":"sem3/AlgoData/VRL/extra/summaries/AuD-summary-lbehric.pdf","text":"Algorithmen und Datenstrukturen Exam Prep Sheet Lejs Behrić HS23 This document has been designed to give students of the Algorithms and Data Structures course an overview of all exam-relevant topics and to provide specific tips on how to best solve typical exam tasks. If any mistakes are found, please contact me at lbehric@inf.ethz.ch. This document does not claim to be complete and correct and I do not guarantee that other topics are not also relevant to the exam. Contents 1 Asymptotic Notation 2 1.1 Important Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.2 Order of asymptotic growth of different functions . . . . . . . . . . . . . . . . . . . . 2 1.3 Useful upper/lower bounds for sums . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.4 Useful formulas for resolving sums . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.5 Methods for solving common asymptotic notation tasks . . . . . . . . . . . . . . . . 3 2 Induction proofs and recurrence relations 3 2.1 Induction proofs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2.2 Recurrence relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 3 Search Trees 4 3.1 Heaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 3.2 Binary Search Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 3.3 AVL Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 4 Searching and Sorting Algorithms 5 4.1 Searching Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 4.2 Sorting Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 4.3 Comparison of Sorting Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 5 Dynamic Programming 5 6 Graphs 5 6.1 Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 6.2 BFS / DFS and Topological Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 6.3 Shortest Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 6.4 Minimum Spanning Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1 1 Asymptotic Notation 1.1 Important Definitions Let N be an infinite subset of N and f, g : N → R+. • If lim n→∞ f(n) g(n) = 0, then f ≤ O(g), but f ̸= Θ(g). • If lim n→∞ f(n) g(n) = C ∈ R+, then f = Θ(g). • If lim n→∞ f(n) g(n) = ∞, then f ≥ Ω(g), but f ̸= Θ(g). 1.2 Order of asymptotic growth of different functions Here f < g means that f grows asymptotically slower than g =⇒ f ≤ O(g) ∧ f ̸= Θ(g) · · · < log (log (n)) < log (n) < √n < n 0.9 < n < n log n < n √n < n 2 < 2 n < e n < n! < n n < . . . Remember that for arbitrary constants a, b, c, d ∈ R+: log a(n b) = Θ(log c(n d)). 1.3 Useful upper/lower bounds for sums Bounds for sums, where f is monotonically increasing: i ≤ j =⇒ f(i) ≤ f(j) n∑ i=1 f(i) ≤ n∑ i=1 f(n) = n · f(n) ≤ O(n · f(n)) n∑ i=1 f(i) ≥ n∑ i=⌈n/2⌉ f(i) ≥ n∑ i=⌈n/2⌉ f(⌈n/2⌉) = (n − ⌈n/2⌉ + 1) · f(⌈n/2⌉) ≥ Ω(n · f(n/2)) 1.4 Useful formulas for resolving sums Sum of integers and Geometric sum formula n∑ i=1 i = n(n + 1) 2 = Θ(n2) n∑ i=0 qi = q n+1 − 1 q − 1 = Θ(q n) 2 1.5 Methods for solving common asymptotic notation tasks 1. By intuition: For this you should memorize 1.2 E.g.: n 3 + √n ? ≤ O(n 2) → False 2. Rearrange fraction: g h ≤ O(f) ⇐⇒ g ≤ O(f · h) (h ̸= 0) E.g.: n log (n) ? ≤ O( √n · log (n)) ⇐⇒ n ? ≤ O(√n · log (n)2) → False 3. Find upper/lower bound: Use bounds in 1.3 E.g.: ∑⌈√n⌉ i=1 i 3 ? ≥ Ω(n 2) ⇐⇒ ⌈ √n 2 ⌉(⌈ √n 2 ⌉)3 ≥ n 2 16 ? ≥ Ω(n 2) → True 4. Resolve sum with one of the formulas: Use formulas in 1.4 E.g.: n2 2 − ∑n−1 i=1 i ? ≤ O(n) ⇐⇒ n 2 2 − ( n 2 2 − n 2 ) ? ≤ O(n) → True 5. Deal with recurrences: Try to find upper/lower bound of recurrence E.g.: Let a1 = 1 and an+1 = 3ai + 1 ∀i ≥ 2 Then an ? ≤ O(4 n). Notice that an is monotonically increasing, and an+1 ≤ 4an. Therefore an ≤ 4an−1 ≤ 4 · 4an−2 ≤ ... ≤ O(4 n) → True 2 Induction proofs and recurrence relations 2.1 Induction proofs The classical proof by induction is concerned with showing that a statement is valid for all natural numbers n ∈ N . This statement does not have to be a mathematical formula directly, but can also be much more general, such as an invariant for example. An induction proof consists of the following components: 1. Induction Start: Show that the statement holds for n = 1. 2. Induction Hypothesis: We assume that the statement holds for some arbitrary n ∈ N. 3. Induction Step: Show that the validity of the statement for n (induction hypothesis) implies the validity of the statement for n + 1. A generalised variant of induction allows a stronger induction hypothesis, namely that the statement is valid for all k ≤ n (from which, of course, the validity of the statement for n + 1 must then also be concluded in the induction step). Induction can also begin for a number n0 > 1 (but then the statement is no longer valid for all n ∈ N, but only for all n ∈ N with n ≥ n0). 2.2 Recurrence relations To recognise a pattern in recurrences, it often helps to write out the first few terms. For recurrences of the form an = can−1 + d and a0 = b, a general closed formula exists: an = {b + nd if c = 1 c nb + c n−1 c−1 · d if c ̸= 1 If you have to prove an equation with a recurrence by induction, then use the definition of a0 in the base case and the definition of an+1 in the induction step to conclude the proof. 3 3 Search Trees 3.1 Heaps 3.2 Binary Search Trees A binary tree is • either a leaf, i.e. the tree is empty, • or it consists of an inner node v with two trees Tl(v) and Tr(v) as left and right successors respectively. The tree Tl(v) is called the left subtree of v, Tr(v) is called the right subtree of v. Each tree has exactly one node without an operator, the so-called root, which is called root in the following algorithm descriptions. In each inner node v, we store • a key v.Key, • a pointer v.Left to the left successor node (i.e. to the root of the left subtree Tl(v) and not to the subtree as a whole), • a pointer v.Right to the right successor node (i.e. to the root of the right subtree Tr(v)) • and a pointer v.Right to the right successor node (i.e. to the root of the right subtree Tr(v)). If the left (or right) successor of an inner node is a leaf, then we set v.Left (or v.Right) to null. A pointer to the root is then sufficient to represent the entire tree. The tree is thus fully represented by pointers to the corresponding successors, and not, for example, as an array (as with heaps), although it is not yet clear how this helps in the search for a given key. A heap, for example, could also be represented by corresponding pointers, but it is unclear how to search there efficiently. Therefore, we now introduce another criterion: A binary search tree is a binary tree that fulfils the search tree property: Each inner node v stores a key k, all keys stored in the left subtree Tl(v) of v are smaller than k and all keys stored in the right subtree Tr(v) of v are larger than k. 3.3 AVL Trees AVL Property Rotations Heap Condition Heap Operations 4 4 Searching and Sorting Algorithms 4.1 Searching Algorithms 4.2 Sorting Algorithms 4.3 Comparison of Sorting Algorithms 5 Dynamic Programming 6 Graphs 6.1 Definitions 6.2 BFS / DFS and Topological Sorting 6.3 Shortest Paths 6.4 Minimum Spanning Trees 5","libVersion":"0.3.2","langs":""}