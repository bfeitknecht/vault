{"path":"sem2a/PProg/PV/exams/PProg-HS23-exam.pdf","text":"Vor und Nachname (Druckbuchstaben): Legi Nummer: 252-0029-00L Parallele Programmierung ETH/CS: FS 2023 Semesterpr¨ufung (Rep.) Friday, 16.2.2024 10:00 HCI J 7 120 Minuten Diese Pr¨ufung enth¨alt 26 Seiten (inklusive Deckblatt) und 9 Aufgaben. ¨Uberpr¨ufen Sie nach Beginn der Pr¨ufung, dass keine Seiten fehlen. Die Aufgaben 1-4 behandeln den von Prof. Solenthaler unterrichteten Teil der Vorlesung, Aufgaben 5-9 den Teil von Prof. Hoefler. Sie haben 120 Minuten Zeit f¨ur die L¨osung der Pr¨ufung und erhalten 120 Punkte. Wir empfehlen eine Uhr mitzubringen. Sie ben¨otigen nicht alle Punkte um die Bestnote zu erreichen. Um eine gen¨ugende Note zu erreichen reichen ca. die H¨alfte der Punkte (kann je nach Schwierigkeitsgrad der Pr¨ufung angepasst werden). Falls Sie sich durch irgendjemanden oder irgendetwas gest¨ort f¨uhlen, melden Sie dies einer Auf- sichtsperson. Wir sammeln die Pr¨ufung zum Schluss ein, stellen Sie sicher, dass Ihre Pr¨ufung von einem Assistenten eingezogen wird. Wenn Sie fr¨uher abgeben wollen melden Sie sich und wir holen die Pr¨ufung ab. Vorzeitige Abgaben sind nur bis 15 Minuten vor Pr¨ufungsende m¨oglich. Wenn Sie zur Toilette m¨ussen, melden Sie dies einer Aufsichtsperson durch Handzeichen. Es darf zur gleichen Zeit immer nur eine Person zur Toilette. • L¨osungen m¨ussen lesbar sein. L¨osungen mit unklarer Reihenfolge oder anderweitig un- verst¨andlicher Pr¨asentation k¨onnen zu Punktabz¨ugen f¨uhren. Verwenden Sie keinen Blei- stift und keine rot oder orange-farbenen Stifte. • Falls mehr Platz ben¨otigt wird, schreiben Sie auf die leeren Seiten am Ende der Pr¨ufungsunterlagen. Versehen Sie die Aufgabe mit einem klaren Hinweis, falls das der Fall ist. • Multiple-choice Fragen werden minimal mit 0 Punkten bewertet, es werden keine negativen Punkte erteilt. • Die Aufgabenstellungen sind in Deutsch und Englisch gegeben. Die Aufgaben k¨onnen auf Deutsch oder Englisch beantwortet werden. • Legen Sie ihre ETH Karte zur Identit¨ats¨uberpr¨ufung gut sichtbar vor sich auf den Tisch. • In dieser Pr¨ufung sind keine Hilfsmittel oder mitgebrachte Unterlagen erlaubt, ausser ein W¨orterbuch f¨ur fremdsprachige Studierende. Insbesondere alle kommunikationsf¨ahigen, pro- grammierbaren und/oder speicherf¨ahigen Ger¨ate wie bspw. Smartphones, Smartwatches, etc. sind nicht erlaubt. Bei unehrlichem Handeln gelten die Strafnormen der Disziplinarordnung der ETH. • Eine pl¨otzlich auftretende Erkrankung muss bei der Pr¨ufungsaufsicht explizit angezeigt wer- den. Ebenso zwingend erforderlich ist eine Mitteilung, die Pr¨ufung aus medizinischen Gr¨unden nicht beenden zu k¨onnen. Question: 1 2 3 4 5 6 7 8 9 Total Points: 11 15 16 18 13 12 19 8 8 120 Score: Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 2 von 26 Friday, 16.2.2024 Parallel Patterns and Task Graphs (11 points) 1. Geben Sie f¨ur jeden der folgenden Codeaus- schnitte an, ob es sich bei der Operation um eine Map, Reduce, Prefix oder Pack handelt, und berechnen Sie die Ausgabe der Funktion. For each of the code snippets below, state whether the operation is a Map, Reduce, Prefix, or Pack and calculate the output of the function. (a) (2)double method_a(){ double[] vec1 = {10.0, 0.0, 2.0}; double[] vec2 = {4.0, 4.0, 1.0}; double sum = 0.0; for(int i = 0; i < vec1.length; i++){ sum += vec1[i] * vec2[i]; } return sum; } (b) (2)String[] method_b(){ String[] vec = {\"Apple\", \"Bean\", \"Banana\", \"Pear\"}; boolean[] keepElem = new bool[vec.length]; int[] numKept = new int[vec.length + 1]; numKept[0] = 0; for(int i = 0; i < vec.length; i++){ if(vec[i].length() > 4){ keepElem[i] = true; numKept[i+1] = numKept[i] + 1; } else { keepElem[i] = false; numKept[i+1] = numKept[i]; } } String[] out = new String[numKept[numKept.length-1]]; int j = 0; for(int i = 0; i < vec.length; i++){ if(keepElem[i] == true){ out[j] = vec[i]; j++; } } return out; } Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 3 von 26 Friday, 16.2.2024 (c) (2)int[] method_c(){ int[] vec = {0, 3, -3, 0, 1}; for(int i = 0; i < vec.length; i++){ if(vec[i] < 0){ vec[i] = -vec[i]; } } return vec; } (d) (2)int[] method_d(){ int[] vec = {1, 2, 3, 4, 5}; int[] out = new int[vec.length]; out[0] = vec[0]; for(int i = 1; i < vec.length; i++){ out[i] = vec[i] * out[i-1]; } return out; } (e) Kreisen Sie in den folgenden Fragen die rich- tige Antwort ein. In the questions below, circle the correct answer. i. (1)Welcher der folgenden Task Graphen ist kein g¨ultiger Task Graph? Which of the following task graphs is not a valid task graph? (A) (B) (C) (D) (E) None of the above Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 4 von 26 Friday, 16.2.2024 ii. (1)Was ist die L¨ange des kritischen Pfades des folgenden Task Graphen? What is the length of the critical path of the following task graph? (A) 3 (B) 6 (C) 8 (D) 10 (E) 13 iii. (1)Welcher Ausdruck gibt eine Untergrenze f¨ur Tp an, die Zeit, die zum Ausf¨uhren eines Task Graphen auf p Prozessoren ben¨otigt wird? Which expression gives an lower bound on Tp, the time it takes to execute a task graph on p processors? (A) T1 p (B) T1 · p (C) T1·(p−1) p (D) p−1 T1 (E) 2 · T1 Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 5 von 26 Friday, 16.2.2024 Pipelines and Speedup (15 points) 2. (a) i. (3)Welcher Speedup kann bei einem Task mit einem sequentiellen Anteil von 0.16 er- reicht werden, wenn der Task gem¨ass dem Amdahl-Gesetz auf p = 126 Prozessoren ausgef¨uhrt wird? Hinweis: 126 × 16 = 2016 Given a task with a sequential fraction of 0.16, what speedup can be achieved when running the task on p = 126 processors according to Amdahl’s law? Hint: 126 × 16 = 2016 ii. (3)Kann eine solcher Speedup in der Praxis auf einem realen System erreicht werden? Wenn nicht, was verhindert den optima- len Speedup und unter welchen Umst¨anden kann ein Speedup erreicht werden, der na- he am theoretischen Wert liegt? Can such a speedup be obtained in practice on a real system? If not, what hinders the optimal speedup and under what circumstances can a speedup be achieved that is close to the theoretical value? iii. (4)Ist Amdahl’s Gesetz oder Gustafson’s Ge- setz in der folgenden Abbildung darge- stellt? Benennen Sie das Gesetz, definieren Sie den seriellen Anteil f anhand der seriel- len und parallelen Anteil der Arbeit, Wser und Wpar, und leiten Sie daraus die Formel f¨ur den Speedup Sp ab. Is Amdahl’s Law or Gustafson’s Law demonstrated in the illustration be- low? Name the law, define the serial fraction f in terms of the serial and parallelizable fractions of the work, Wser and Wpar, and use it to derive the formula for speed up Sp. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 6 von 26 Friday, 16.2.2024 (b) Betrachten Sie die unten gezeigte Pipeline. Es gibt mehrere parallele Eing¨ange und A, B, C und D sind unterschiedliche Funktions- einheiten. Consider the pipeline shown below. There are multiple parallel inputs and A, B, C, and D are different functional units. A 20 s B 100 s C 10 s D 70 s i. (2)Ist die Pipeline balanced? Begr¨unden Sie Ihre Antwort. Sie m¨ussen keine Zahl oder Berechnung angeben. Is the pipeline balanced? Justify your answer. You do not need to provide a number or calculation. ii. (3)Wie lange wird es dauern, die gesamte Pi- peline (d.h. die Stufen A-B-C-D) 15 Mal auszuf¨uhren? Gehen Sie davon aus, dass wir die Pipeline so parallelisieren, dass jede Stufe parallel zu den anderen Stufen laufen kann, jedoch nicht zu sich selbst. Achten Sie darauf, Ihre Antwort in den entspre- chenden Einheiten anzugeben. How long will it take to run the whole pipeline (i.e., stages A-B-C-D) 15 times? Assume that we parallelize the pipeline such that each stage can run in parallel with the other stages, but not with itself. Make sure to leave your answer in the appropriate units. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 7 von 26 Friday, 16.2.2024 Fork/Join Framework (16 points) 3. Der folgende Code zielt darauf ab, ein Bild zu negieren, indem es mithilfe des Fork/Join- Frameworks rekursiv in mehrere Unterfenster (vier pro Rekursionsschritt) unterteilt wird. Die Unterfenster k¨onnen dann parallel negiert wer- den. Das folgende Beispiel verdeutlicht die Un- terteilung des Bildes und die Negierung der ein- zelnen Unterfenster. The following code aims to negate an im- age by recursively subdividing it into mul- tiple subwindows (four per recursion step) using the Fork/Join framework. The sub- windows can then be negated in parallel. The example below illustrates the subdivi- sion of the image and negation of the indi- vidual subwindows. Negate Bitte lesen Sie den Code sorgf¨altig durch und beantworten Sie dann die Fragen zum Code: Please read the code carefully and then an- swer the questions regarding the code: public class ImageNegationFJ extends RecursiveAction { // Maximum window length to be processed sequentially. // Maximale Fensterl¨ange, die sequentiell verarbeitet werden soll. final static int CUTOFF = 32; /* The original input image and the inverted image which is filled in with the negated pixels of the input image. */ /* Das urspr¨ungliche Eingabebild und das invertierte Bild, welches mit den negierten Pixeln des Eingabebildes aufgef¨ullt wird. */ double[][] image, invertedImage; // startx/y define the coordinates of the first pixel to be negated. // startx/y definieren die Koordinaten des ersten Pixels, // welcher negiert werden soll. int startx, start; // length defines how many pixels should be corrected in // positive x- and y-direction. // length definiert, wie viele Pixel in positiver // x- und y-Richtung korrigiert werden sollen. int length; Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 8 von 26 Friday, 16.2.2024 public ImageNegationFJ(double[][] image, double[][] invertedImage, int startx, int starty, int length) { this.image = image; this.invertedImage = invertedImage; this.startx = startx; this.starty = starty; this.length = length; } @Override protected void compute() { if (this.length <= CUTOFF) { /* The small square of the image is negated sequentially by * looping over the individual pixels. */ /* Das kleine Quadrat des Bildes wird sequentiell negiert, indem die einzelnen Pixel durchlaufen werden. */ for (int offsetX = 0; offsetX < this.length; offsetX++) { for (int offsetY = 0; offsetY < this.length; offsetY++) { this.invertedImage[this.startx+offsetX][this.starty+offsetY] = 1 - this.image[this.startx+offsetX][this.starty+offsetY]; } } } else { /* The image is split into four parts. The image negation is computed on the four splits in parallel. */ /* Das Bild wird in vier Teile aufgeteilt. Die Bildnegierung wird f¨ur die vier Teile parallel berechnet. */ int halfSize = (this.length) / 2; ImageNegationFJ upperLeft = new ImageNegationFJ(this.image, this.invertedImage, this.startx, this.starty, halfSize); ImageNegationFJ upperRight = new ImageNegationFJ(this.image, this.invertedImage, this.startx + halfSize, this.starty, halfSize); ImageNegationFJ lowerLeft = new ImageNegationFJ(this.image, this.invertedImage, this.startx, this.starty + halfSize, halfSize); ImageNegationFJ lowerRight = new ImageNegationFJ(this.image, this.invertedImage, this.startx + halfSize, this.starty + halfSize, halfSize); // Fork and Join the four window splits // Fork und Join der vier Fensteraufteilungen upperLeft.fork(); upperLeft.join(); upperRight.fork(); upperRight.join(); lowerLeft.fork(); lowerLeft.join(); lowerRight.compute(); } } } Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 9 von 26 Friday, 16.2.2024 (a) (2)Welche Annahme trifft der Code bez¨uglich der Abmessungen des Arrays, das das Einga- bebild darstellt? What assumption does the code make concerning the dimensions of the array representing the input image? (b) (4)Parallelisiert der Code die beabsichtigte Auf- gabe korrekt oder gibt es weitere Optimie- rungsm¨oglichkeiten? Wenn ja, welche Opti- mierung w¨urden Sie vorschlagen und warum? Does the code correctly parallelize the intended task or is there further opti- mization that could be done? If so, which optimization would you propose and why? (c) (4)Vervollst¨andigen Sie das folgende Code- ger¨ust, indem Sie die oben implemen- tierte ImageNegationFJ Klasse und die ForkJoinPool Klasse verwenden, um die Va- riable negatedImage mit den negierten Wer- ten zu f¨ullen. Complete the following code skeleton by using the above implemented ImageNegationFJ class and the ForkJoinPool class to fill the vari- able negatedImage with the negated values. double[][] image = {{0, 1}, {1, 0}}; int imageSize = image.length; double[][] negatedImage = new double[imageSize][imageSize]; .................................................... .................................................... .................................................... .................................................... .................................................... .................................................... (d) (2)Unter der Annahme, dass die Klasse ImageNegationFJ korrekt parallelisiert ist, wie viele Threads verwendet der ForkJoin- Pool effektiv, um das 2 × 2 negatedImage Array aus Aufgabe 3c) zu f¨ullen? Assuming that the ImageNegationFJ class is correctly parallelized, how many threads does the ForkJoinPool effec- tively use to fill the 2 × 2 negatedImage array from task 3c)? Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 10 von 26 Friday, 16.2.2024 (e) (4)Gehen Sie von einem konstanten Overhead von 16 MB = 24 MB pro Thread aus und dass pro Split immer vier neue Threads er- stellt werden. Dies bedeutet, dass die Anzahl der Threads nicht durch den ForkJoinPool festgelegt wird, sodass kein Thread wieder- verwendet wird und es zu keinem Work Ste- aling zwischen den Threads kommt. Was ist der niedrigste Wert f¨ur CUTOFF, wenn Sie ein Bild der Gr¨oße 4000 × 4000 eingeben, bevor Ihnen bei einem RAM der Gr¨oße 10 GB der Speicher ausgeht? Hinweis: 1 GB = 210 MB. Assume a fixed overhead of 16 MB = 24 MB per thread and that there are al- ways four new threads created per split. This means that the number of threads is not fixed by the ForkJoinPool, so no thread is re-used and there is no work stealing among the threads. What is the lowest value for CUTOFF if you input an image of size 4000 × 4000 before you run out of memory using a RAM of size 10 GB? Hint: 1 GB = 210 MB. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 11 von 26 Friday, 16.2.2024 Threads & Wait/Notify (18 points) 4. (a) (2)Kreuzen Sie alle korrekten Aussagen ¨uber das Erstellen von Java Threads an. Mark all correct statements regarding the creation of Java Threads. ⃝ Beim Aufteilen eines Workloads sollte man soviele Threads erstellen wie m¨oglich, bis nur noch elementare Operationen pro Thread ausgef¨uhrt werden. When splitting a workload, as many threads as possible should be created until only elementary operations are performed per thread. ⃝ Um eine eigene Thread-Klasse in Java zu definieren kann man das Runnable- Interface implementieren. To define a custom thread class in Java, one can implement the Runnable inter- face. ⃝ Um eine eigene Thread-Klasse in Java zu definieren kann man die Thread-Klasse er- weitern. To define a custom thread class in Java, one can extend the Thread class. ⃝ Threads werden fast ausschliesslich genutzt um eine rekursive Implementation zu be- schleunigen. Threads are used almost exclusively to speed up a recursive implementation. (b) (2)Kreuzen Sie alle korrekten Aussagen ¨uber die Ausf¨uhrung von Java Threads an. Mark all correct statements regarding the execution of Java Threads. ⃝ Die start() Methode in t = new Thread(); t.start() ruft automatisch auch die run() methode auf. The start() method in t = new Thread(); t.start() automatically also calls the run() method. ⃝ Die run() Methode in t = new Thread(); t.run() erzeugt einen neuen Thread und f¨uhrt diesen aus. The run() method in t = new Thread(); t.run() cre- ates a new thread and executes the thread. ⃝ Ein Codeblock mit mehreren Threads wird immer deterministisch ausgef¨uhrt. D.h. der Output ist immer exakt der gleiche. A codeblock with several threads is al- ways executed deterministically. That means the output is always the same. ⃝ Ein komplett serieller Codeblock kann zur Beschleunigung auf mehreren Prozessoren ausgef¨uhrt werden. A fully serial block of code can be run on multiple processors to speedup exe- cution. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 12 von 26 Friday, 16.2.2024 (c) (2)Wozu dient die join() Methode in Java Threads? What is the purpose of the join() method in Java Threads?. ⃝ Um eine Priorit¨atenreihenfolge zwischen mehreren Threads zu erzwingen. To enforce a priority order among mul- tiple threads. ⃝ Um das von dem aktuellen Thread gehalte- ne Lock freizugeben. To release the lock held by the current thread. ⃝ Um die Ausf¨uhrung des aktuellen Threads anzuhalten, bis der Thread, den er joined, abgeschlossen ist. To pause the current thread’s execution until the thread it joins completes. ⃝ Um die Kontrolle an einen anderen Thread zu ¨ubergeben, ohne auf dessen Abschluss zu warten. To transfer control to another thread without waiting for its completion. (d) (4)Der folgende Codeauschnitt erstellt und star- tet zwei Threads, welche gerade und ungera- de Zahlen auf der Konsole ausgeben. Consider the following piece of code that creates and starts two threads that out- put even and odd numbers on the con- sole. 1 public class Main { 2 public static Thread CreateThread(int start) { 3 return new Thread(new Runnable() { 4 5 @Override 6 public void run() { 7 for (int i = start; i < 7; i+=2) { 8 System.out.println(\"Number \" + i); 9 } 10 } 11 }); 12 } 13 14 public static void main(String[] args) throws InterruptedException { 15 CreateThread(1).start(); 16 CreateThread(2).start(); 17 } 18 } Markieren Sie alle Ausgaben, welche durch den Codeausschnitt ausgegeben werden k¨onnen. Mark all the print sequences that can be produced by running the program shown above. 2 1 Number 1 2 Number 2 3 Number 3 4 Number 4 5 Number 5 6 Number 6 2 1 Number 1 2 Number 6 3 Number 3 4 Number 4 5 Number 5 6 Number 2 2 1 Number 6 2 Number 5 3 Number 4 4 Number 3 5 Number 2 6 Number 1 2 1 Number 2 2 Number 4 3 Number 6 4 Number 1 5 Number 3 6 Number 5 Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 13 von 26 Friday, 16.2.2024 (e) Betrachten Sie den folgenden Codeaus- schnitt. Consider the following code snippet. public class Agent implements Runnable { private int id; private final Counter counter; public Agent(int i, Counter counter) { id = i; this.counter = counter; } public void run() { synchronized (counter) { while (counter.value != id) { counter.wait(); } System.out.print(id + \" \"); counter.set(counter.get() + 1); counter.notify(); } } } // In main: Counter counter = new Counter(0); ArrayList<Thread> agents = new ArrayList<>(); for (int i = 0; i < 20; ++i) { agents.add(new Thread(new Agent(i, counter))); agents.get(agents.size() - 1).start(); } for (int i = 0; i < 20; ++i) { agents.get(i).join(); } System.out.println(\"Done!\"); // Desired output: // Gew¨unschte Ausgabe: // 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Done! Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 14 von 26 Friday, 16.2.2024 i. (4)Ist es m¨oglich, die Ausgabe 1 3 5 2 4 zu erhalten? Is it possible to get the output 1 3 5 2 4? True False ii. (4)Erkl¨aren Sie das Problem der Implemen- tierung und schlagen Sie eine L¨osung vor, damit die gew¨unschte Ausgabe zuverl¨assig erzeugt wird. Explain the problem with the imple- mentation and propose a solution such that the desired output is reliably pro- duced. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 15 von 26 Friday, 16.2.2024 Locks (13 points) 5. (a) (4)Definieren Sie was es bedeutet, wenn ein Lock starvation-free ist. Erkl¨aren Sie den Unter- schied zwischen wait-free und starvation-free. Define what it means for a lock to be starvation-free. Explain the difference between wait-free and starvation free. (b) (3)In einem typischen spin-lock versuchen alle Threads die das Lock erhalten m¨ochten, die selbe geteilte Variable zu schreiben. Warum kann das ein Problem darstellen? Beschrei- ben Sie ein Lock welches dieses Problem nicht hat. In a typical spin-lock all threads which try to access the lock attempt to write to a single shared variable. Why can this be a problem? Describe a lock which does not have this problem. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 16 von 26 Friday, 16.2.2024 Der folgende Code implementiert eine Producer-Consumer Queue. Der Code enth¨alt einen Fehler welcher zu einem Deadlock f¨uhren kann. The following code implements a producer-consumer queue. The code contains a concurrency issue which can cause a deadlock to occur. 1 public class MyProdConsQ{ 2 private int MAX_SIZE=10; 3 private Vector<int> buf=new Vector<int>(MAX_SIZE); 4 public synchronized void put(int o) throws InterruptedException { 5 while (buf.size()==MAX_SIZE) { 6 // spin here until there is space 7 } 8 buf.add(o); 9 } 10 public synchronized int get() throws InterruptedException { 11 while (buf.size()==0) { 12 // spin here until something is in the queue 13 } 14 int obj = buf.remove(0); 15 return obj; 16 } 17 } (c) (2)Finden und erkl¨aren Sie den Fehler im obigen Code. Find and explain the issue in the above code. (d) (4)¨Andern Sie die obige Implementierung so ab, dass kein Deadlock mehr auftreten kann. Re- ferenzieren Sie die zu ¨andernden Codezeilen und geben Sie ¨Anderungen unten an. Change the implementation above to eliminate the possibility of a deadlock. Reference the lines in the source code above and provide your changes below. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 17 von 26 Friday, 16.2.2024 Linearizability (12 points) 6. (a) (6)Nehmen Sie f¨ur jede der folgenden Historien an, r ist ein atomares Register, welches zu Beginn den Wert 0 enth¨alt. Geben Sie alle m¨oglichen Werte an welche X haben kann, so dass die Historie linearisierbar ist. For each of the following three histories, assume r is an atomic register which is initialized with 0. List all possible values of X such that the history is linearizale. 1 H1: A r.write(1) 2 B r.write(0) 3 B r:void 4 A r:void 5 A r.read() 6 B r.read() 7 B r:X 8 A r:0 1 H2: B r.write(1) 2 A r.read() 3 C r.write(X) 4 C r:void 5 A r:0 6 C r.read() 7 C r:1 8 B r:void 9 B r:read() 10 B r:0 1 H3: A r.write(1) 2 B r:read() 3 A void 4 B r:X Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 18 von 26 Friday, 16.2.2024 (b) (3)Ist Java Code immer linearisierbar? Erkl¨aren Sie warum oder geben Sie ein Gegenbeispiel an. Is Java code always linearizable? Expain why or provide a counter-example. (c) (3)Sind Java Objekte, welche nur synchronized Funktionen enthalten ohne Funktionspara- meter oder globale Variablen, immer lineari- sierbar? Erkl¨aren Sie warum oder geben Sie ein Gegenbesipiel an. Are Java objects which only use synchro- nized functions without parameters and does not contain global variables always linearizable? Explain why or provide a counter-example. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 19 von 26 Friday, 16.2.2024 Advanced Synchronization Primitives (19 points) 7. (a) (6)Unten sehen Sie fehlerhafte Versuche wait- free consensus Protokolle f¨ur zwei Threads zu implementieren. Erkl¨aren Sie f¨ur jede Im- plementierung weshalb diese fehlerhaft ist, indem Sie aufzeigen welche der Eigenschaf- ten von wait-free consensus die Implemen- tierung nicht erf¨ullt (sollte eine Implementie- rung mehrere Eigenschaften nicht erf¨ullen so w¨ahlen Sie eine davon aus). Below you see incorrect attempts to im- plement a wait-free consensus protocol for two threads. For each of them briefly explain why it is incorrect by explain- ing which property of wait-free consen- sus the implementation does not fulfill (if it violates multiple properties pick one). 1 int decide(int val) { 2 return val; 3 } 1 int decided = 0; //shared variable 2 int proposed[2]; //shared variable 3 4 int decide(int val, int thread_id /* either 0 or 1*/) { 5 decided += 1; 6 proposed[thread_id] = val; 7 while (decided < 2) {} 8 decided = 0 9 return proposed[1]; 10 } 1 int decide(int val) { 2 return 0; 3 } Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 20 von 26 Friday, 16.2.2024 (b) (7)Geben Sie jeweils ein Beispiel f¨ur ein Objekt mit der Konsensuszahl 1, 2 und unendlich. Begr¨unden Sie warum das angegebene Ob- jekt mindestens diese Konsensuszahl haben muss. Give an example of an object (one each) which has consensus number 1, 2, and infinity. Argue why the given object has at least that consensus number. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 21 von 26 Friday, 16.2.2024 Die folgende Implementierung von Zeichen- kettenverkettung birgt ein Problem bei der Verwendung von mehreren Threads. The following implementation of String concatenation contains a concurrency is- sue. 1 import java.util.concurrent.locks.ReentrantLock; 2 3 public class MyString { 4 ReentrantLock lock = new ReentrantLock(); 5 String data = \"\"; 6 7 public void append(MyString a) { 8 lock.lock(); a.lock.lock(); 9 data = data + a.data; 10 a.lock.unlock(); lock.unlock(); 11 } 12 } (c) (4)Erkl¨aren Sie was das Problem ist, geben Sie ein Beispiel an in dem zwei oder mehr Threads die Implementierung verwenden und es zu einem Deadlock kommt. Explain what the problem is, give an ex- ample where two or more threads use the implementation and a deadlock happens. (d) (2)Reparieren Sie den Fehler, beschreiben Sie al- le Modifikationen welche Sie am obigen Code vornehmen m¨ussen. Fix the problem. Describe all modifica- tions that you would need to make on the above code. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 22 von 26 Friday, 16.2.2024 MPI (8 points) 8. (a) (2)Welche zwei MPI kollektiven Operationen k¨onnen kombiniert werden um zusammen die Allgather operation zu implementieren? Which two collective operations can be combined to imlement the Allgather op- eration? (b) (6)Nutzen Sie MPI Punkt-zu-Punkt Kommuni- kationsoperationen um die Gather kollektive Operation zu implementieren. Die Signatu- ren aller f¨ur diese Aufgabe relevanten Funk- tionen sind unten angegeben. Nutzen Sie den Kommunikator MPI.COMM WORLD. Use MPI Point-to-point communication to implement the Gather collective op- eration. The signatures of all relevant functions for this task are given below. Use MPI.COMM WORLD as communi- cator. 1 int Comm.Size() 2 int Comm.Rank() 3 void Comm.Send(buf, offset, count, datatype, dest, tag) 4 void Comm.Recv(buf, offset, count, datatype, source, tag) Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 23 von 26 Friday, 16.2.2024 Mixer (8 points) 9. (a) (3)Worin besteht der Unterschied zwischen flat- tened nesting und closed nesting im Kontext von transaktionellem Speicher? What is the difference between flattened nesting and closed nesting in the context of transactional memory (b) (2)Beschreiben Sie je eine Compiler- und eine Hardware-Optimierung welche f¨ur sequenti- ellen Code korrekt ist, aber sequentielle Kon- sistenz verletzt (f¨ur mehrere Threads). Describe one compiler- and one hard- ware optimization which is correct for se- quential code but breaks sequential con- sistency (for multiple threads). (c) (3)Transaktionen in transaktionellem Speicher garantieren Atomizit¨at, Kompositionierbar- keit sowie Isolation. Erkl¨aren Sie die Konzep- te Kompositionierbarkeit und Isolation so- wie den Unterschied zwischen den beiden Konzepten. Vergleichen Sie die Eigenschaf- ten von transaktionellem Speicher mit Linea- risierbarkeit. Transactions in a transactional memory system guarantee atomicity, composabil- ity and isolation. Explain composability, isolation and the difference between the two concepts. Compare the properties of transactional memory to linearizability. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 24 von 26 Friday, 16.2.2024 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu finden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 25 von 26 Friday, 16.2.2024 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu finden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found. Parallele Programmierung - Semesterpr¨ufung (Rep.) - Seite 26 von 26 Friday, 16.2.2024 Zusatzseite / Extra Page Falls Sie Zusatzseiten nutzen, machen Sie bei jeder Aufgabe deutlich, auf welcher Seite weitere Teile Ihrer Antwort zu finden sind. If you use extra pages, please clearly point out at each exercise on which page the additional answers can be found.","libVersion":"0.3.2","langs":""}