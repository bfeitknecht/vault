{"path":"sem2/PProg/VRL/extra/kuhn/PProg-w08-kuhn.pdf","text":"Parallel Programming Session 8 Spring 2024, Sarah Kuhn Email: kuhnsa@ethz.ch Interested in Bachelor/Semester project? http://spcl.inf.ethz.ch/SeMa The slides are a mix out of the official slides and my personal additions Schedule Inputs/materials for the 2nd part Assignment 07 Recap Theory Recap JMM, program order etc., often confusing but important to understand State Space Diagram Exam Tasks Pre-Discussion Assignment 8 Quiz Materials unfortunalty the unofficial script only covers the first part pvw script, added some other resources to my polybox. The book is a very very good resource Materials unfortunalty the unofficial script only covers the first part pvw script, added some other resources to my polybox. The book is a very very good resource \"The Art of Multiprocessor Programming»: ch.2/p.21 :: mutex with proof ch. 7.1-4/p.141 :: TAS, TATAS, backoff locks ch. 8/p.177 :: monitors, semaphores, locks ch.9/p.195 :: lock granularity ch.10.5-6/p.230 :: lock-free unbounded queue, ABA problem ch.3.1-6/p.45 :: sequential consistency, linearizability ch.5/p.99 :: consensus ch. 18/ p.417 :: transcational memory Post-Discussion 07 Feedback for Assignment 7 public synchronized boolean transferMoney(Account from, Account to, int amount) { … … return true; } 7 • What is wrong with the following code snippet? Is it actually wrong or not ? Feedback for Assignment 7 public class Account … { … private final Lock lock = new ReentrantLock(); … } 8 • What we should have done for avoiding deadlocks Feedback for Assignment 7 9 • What we should have done for avoiding deadlocks public class BankingSystem { … public boolean transferMoney(Account from, Account to, aint amount) { Account first, second; // Introduce lock ordering: if (to.getId() > from.getId()) { first = from; second = to; } else { first = to; second = from; } … } Feedback for Assignment 7 10 • Acquire locks public class BankingSystem { … public boolean transferMoney(Account from, Account to, int amount) { … first.getLock().lock(); second.getLock().lock(); why? try { … } finally { first.getLock().unlock(); second.getLock().unlock(); } Feedback for Assignment 7 11 • Acquire locks, use finally to always release the locks public class BankingSystem { … public boolean transferMoney(Account from, Account to, int amount) { … first.getLock().lock(); second.getLock().lock(); try { … } finally { first.getLock().unlock(); second.getLock().unlock(); } Feedback for Assignment 7 12 • Summing up: How to do it safe Lock each account before reading out its balance, but don’t release the lock until all accounts are summed up. ➔ Two-phase locking Feedback for Assignment 7 13 • Summing up: How to do it safe Lock each account before reading out its balance, but don’t release the lock until all accounts are summed up. ➔ Two-phase locking In the first phase locks will be acquired without releasing, in the second phase locks will be released. ➔ Deadlocks still a problem ➔ Ordered locking required Theory Recap Orientation So far: Getting parallelism in Java (Thread library) Organizing parallelism in Java (join, locks, wait/notify...) Analyze performance of parallel algos (speedup, amdahl/gustafson, span, work...) Design parallel algorithms (fork/join, map/reduce, parallel prefix, pack...) Orientation Now: Deep dive into correctness of parallel programs (in Java) How are locks actually implemented Quick Input see students often struggle with this topic Focus on: What is a memory model Different guarantees (synch. order, program order etc.) What is the impact of the memory model for us programmers Volatile keyword in Java Quick Input see students often struggle with this topic Focus on: What is a memory model Different guarantees (synch. order, program order etc.) What is the impact of the memory model for us programmers Volatile keyword in Java Look at different orders and what they imply and if a memory model should enforce this orders. Lecture recap: Program Order 19 • The code in a program is executed in a certain order Lecture recap: Program Order 20 • The code in a program is executed in a certain order • Executing a line of code means some “action” is happening → we can look at the code and define a partial order of these actions! Lecture recap: Program Order 21 • The code in a program is executed in a certain order • Executing a line of code means some “action” is happening → we can look at the code and define a partial order of these actions! “execution of a program” => particular path through the state space State space = all possible states of a program Lecture recap: Program Order 22 • The code in a program is executed in a certain order • Executing a line of code means some “action” is happening → we can look at the code and define a partial order of these actions! Give me an example not in program order ? Lecture recap: Program Order 23 • The code in a program is executed in a certain order • Executing a line of code means some “action” is happening → we can look at the code and define a partial order of these actions! not in program order Lecture recap: Program Order 24 • PO: Transitive closure of “Action from statement S1 happens before that of S2 (if they both happen)” Lecture recap: Program Order 25 • PO: Transitive closure of “Action from statement S1 happens before that of S2 (if they both happen)” I think of it as what would/can happen “sequentially” if the statements are executed instantly Lecture recap: Program Order 26 • PO: Transitive closure of “Action from statement S1 happens before that of S2 (if they both happen)” I think of it as what would/can happen “sequentially” if the statements are executed instantly Lecture recap: Program Order 27 • PO: Transitive closure of “Action from statement S1 happens before that of S2 (if they both happen)” • This is a partial order because the relation is not total, i.e. not all statements are part of every execution! Program Order Do you think forcing our compiler to execute everything in program order is a good idea ? Do we want the Java Memory Model to guarantee Program Order? Why? Why not? Lecture recap: Program Order 29 • We want to allow the compiler / hardware to optimize our code, i.e. remove useless code: Lecture recap: Program Order 30 • We want to allow the compiler / hardware to optimize our code, i.e. remove useless code: • int a=0; • for (int i=0; i<10 i++) {a++;} Lecture recap: Program Order 31 • We want to allow the compiler / hardware to optimize our code, i.e. remove useless code: • int a=0; • for (int i=0; i<10 i++) {a++;} • In sequential code we would expect this to be “rewritten” to a=10 since anyway nobody sees the intermediate values. Lecture recap: Program Order 32 • We want to allow the compiler / hardware to optimize our code, i.e. remove useless code: • int a=0; • for (int i=0; i<10 i++) {a++;} • In sequential code we would expect this to be “rewritten” to a=10 since anyway nobody sees the intermediate values. • But what if a is shared? OptimizationOptimizationOptimizationOptimizations Why do these things not always work in multi-threaded environments? :( • Optimizations! • Reorderings ! Conclusion We cannot work like this!!! How our code runs depends on the compiler, Jit- compiler and the hardware. All of them can reorder and change how the code is executed. Conclusion We cannot work like this!!! How our code runs depends on the compiler, Jit- compiler and the hardware. All of them can reorder and change how the code is executed. We need GUARANTEES on what we can assume about the order of execution and visibility of writes. Thankfully, Java provides us a set of guarantees about the (perceived) order of executions called the Java Memory Model. JMM Set of guarantees we get from Java “guarantees about the (perceived) order of executions is called the Java Memory Model.” What could a MM guarantee here?Application JMM How can we easily fix this code such that the main thread can see the write of Thread t? Application JMM How can we easily fix this code such that the main thread can see the write of Thread t? Gets written here by thread t Gets read here by main thread Optimizations Convert this: To this: Why do these things not always work? :( • Optimizations! • Reorderings ! Application JMM How can we easily fix this code such that the main thread can see the write of Thread t? Gets written here by thread t Gets read here by main thread What we want: To this: But we want to “val” value to get read more often aka not optimized away Problem :: per default we won’t read the val valued again Synchronization order Look at a new order that gives us visibility guarantees for certain actions. We as programmers can include certain things in our code, to have certain ”memory” guarantees. https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html Synchronization order Intra-thread (within a thread) everything appears sequentially (program order) Inter-thread, actions can be ordered by the synchronization order https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html I think of it as: “Action that makes something visible/ is visible for all the other threads” Volatile Keyword With volatile What does that mean ???! Volatile Keyword With volatile ensures that thread accessing the variable sees most recent value written to it Volatile Keyword With volatile ensures that thread accessing the variable sees most recent value written to it when you read a volatile variable from one thread, all writes up to and including the write to that volatile variable from other threads are now visible to that one thread. Volatile Keyword With volatile ensures that thread accessing the variable sees most recent value written to it when you read a volatile variable from one thread, all writes up to and including the write to that volatile variable from other threads are now visible to that one thread. volatile : directly read from memory and not from the cache, don’t optimize it away, == “writeback & flush the cache” Volatile Keyword \"When a field is declared volatile, the compiler and runtime are put on notice that this variable is shared and that operations on it should not be reordered with other memory operations. Volatile variables are not cached in registers or in caches where they are hidden from other processors, so a read of a volatile variable always returns the most recent write by any thread.\" Bloch, Joshua; Goetz, Brian; Peierls, Tim; Bowbeer, Joseph; Holmes, David; Lea, Doug (2006-05-09). Java Concurrency in Practice (Kindle Locations 1194-1197). Pearson Education (US). Kindle Edition. Application JMM How can we easily fix this code such that the main thread can see the write of Thread t? Application JMM How can we easily fix this code such that the main thread can see the write of Thread t? Gets written here by thread t Gets read here by main thread M A K E FL A G V O L A T I L E Read +write from/to memory, don’t optimize it away Lecture recap: Synchronization Actions (SAs) 58 • Java defines synchronization actions (read/write of volatile variable, lock/unlock, etc.) Lecture recap: Synchronization Actions (SAs) 59 • Java defines synchronization actions (read/write of volatile variable, lock/unlock, etc.) • SAs within thread obeys PO Lecture recap: Synchronization Actions (SAs) 60 • Java defines synchronization actions (read/write of volatile variable, lock/unlock, etc.) • SAs within thread obeys PO • All threads see SAs in the same order (synchronization order SO) Lecture recap: Synchronization Actions (SAs) 61 • Java defines synchronization actions (read/write of volatile variable, lock/unlock, etc.) • SAs within thread obeys PO • All threads see SAs in the same order (synchronization order SO) • Reads are consistent in SO (see the last written value) Terminology https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html Terminology Synchronization Order consists of Synchronization Actions https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html f.eg volatile Terminology Synchronization Order consists of Synchronization Action https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html Synchronizes-With SA synchronize with each other aka ”see” each other, SA is seen by the other threads f.eg volatile Lecture recap: Synchronizes With 65 • SAs across threads synchronize with each other, i.e., a volatile read sees the last value written by another thread Terminology Synchronization Order vs. Synchronization Action https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html Synchronizes-With Happens-Before = Program Order (PO) + Synchronization Order (SO) SA synchronize with each other aka ”see” each other, SA is seen by the other threads f.eg volatile Lecture recap: Happens Before 67 • Transitive closure of PO and SW forms happens before order Lecture recap: Happens Before 68 • Transitive closure of PO and SW forms happens before order • All values we observe must obey this happens before order! Example Blackboard Btw: I added some hand-written nodes on how to prove it etc. in an extra folder in the polybox. ExampleWhy do we need all of this? needed to make a proof about the code Prove or disprove whether a certain outcome can happen Why do we need all of this? Use: program order synchronization order Example We know: Example We know: What can we get ? (0,0) , (1,1), (0,1) or/and (1,0) ? Btw: I added some hand-written nodes on how to prove it etc. in an extra folder in the polybox. Overview Different orders/ guarantees https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html Program order Synchronization Order: 1.) Synchronization Actions 2.) draw Synchronizes-With Edges (how the actions between threads depend on each other, are seen) Overview Different orders/ guarantees https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html Program order Synchronization Order: 1.) Synchronization Actions 2.) draw Synchronizes-With Edges (how the actions between threads depend on eachother, are seen) Transitive closure of PO & SO = Happens Before Java Guarantees What do you think Java guarantees us ? Java Guarantees Intra-thread (within a thread) everything appears sequentially (program order) Java Guarantees Intra-thread (within a thread) everything appears sequentially (program order) Inter-thread, actions can be ordered by the synchronization order Correctness Now that we know more about the JMM and why we need keywords like volatile Correctness Now that we know more about the JMM and why we need keywords like volatile How do we proof our program f.eg implements mutex correctly ? Correctness of CS 1.) If we want to argue that our parallel program is correct: have to show that the critical section of our code is correctly implemented Correctness of CS 1.) If we want to argue that our parallel program is correct: have to show that the critical section of our code is correctly implemented 2.) When is a CS implemented correctly ? Correctness of CSCorrectness of CS Later we will distinguish between blocking/ non-blocking, for now we just worked with blocking: threads can be in a blocked state at some point f.eg waiting for a lock Correctness of CS Later we will distinguish between blocking/ non-blocking, for now we just worked with blocking: threads can be in a blocked state at some point f.eg waiting for a lock Correct CS Assume blocking algorithm Three conditions for a correct CS: Mutual exclusion :: Deadlock freedom :: Starvation freedom :: Correct CS Assume blocking algorithm Three conditions for a correct CS: Mutual exclusion :: at most one thread in CS Deadlock freedom :: Starvation freedom :: Correct CS Assume blocking algorithm Three conditions for a correct CS: Mutual exclusion :: at most one thread in CS Deadlock freedom :: at least one thread is guaranteed to proceed into CS at some point Starvation freedom :: Correct CS Assume blocking algorithm Three conditions for a correct CS: Mutual exclusion :: at most one thread in CS Deadlock freedom :: at least one thread is guaranteed to proceed into CS at some point Starvation freedom :: if a thread wants to enter the CS he is guaranteed to do so at some point Correct CS Assume blocking algorithm Three conditions for a correct CS: Mutual exclusion :: at most one thread in CS Deadlock freedom :: at least one thread is guaranteed to proceed into CS at some point Starvation freedom :: if a thread wants to enter the CS he is guaranteed to do so at some point How can we show that a code satisfies this conditions ? Lecture recap: State Space Diagram 94 • When dealing with mutual exclusion problems, we should focus on: • the structure of the underlying state space, and • the state transitions that occur Lecture recap: State Space Diagram 95 • When dealing with mutual exclusion problems, we should focus on: • the structure of the underlying state space, and • the state transitions that occur • Remember the state diagram captures the entire state space and all possible computations (execution paths a program may take) Lecture recap: State Space Diagram 96 • When dealing with mutual exclusion problems, we should focus on: • the structure of the underlying state space, and • the state transitions that occur • Remember the state diagram captures the entire state space and all possible computations (execution paths a program may take) • A good solution will have a state space with no bad states State diagram Represents different states and state transitions a program might go through State :: (Thread X instruction, Thread Y instruction , ….., Value of Var1, Value of Var2) State diagram Represents different states and state transitions a program might go through State :: (Thread X instruction, Thread Y instruction , ….., Value of Var1, Value of Var2) (P1, Q1, 0) // Thread1 at instr1, Thread2 at instr1, shared var.=0 State diagram Represents different states and state transitions a program might go through State :: (Thread X instruction, Thread Y instruction , ….., Value of Var1, Value of Var2) (P1, Q1, 0) // Thread1 at instr1, Thread2 at instr1, shared var.=0 Edge :: state transition P p1: Non-critical section P p2: while turn != 1 p3: Critical section p4: turn = 2 Q q1: Non-critical section Q q2: while turn != 2 q3: Critical section q4: turn = 1 P p1: Non-critical section P p2: while turn != 1 p3: Critical section p4: turn = 2 Q q1: Non-critical section Q q2: while turn != 2 q3: Critical section q4: turn = 1 “is about to execute that statement, hasn’t executed it yet.” Correctness of Mutex How can we recognize mutual exclusion in the state space diagram? Correctness of Mutex How can we recognize mutual exclusion in the state space diagram? Mutual exclusion in state space diagram <=> there exists no state where multiple threads are in critical section => Mutual exclusion holds! P p1: Non-critical section P p2: while turn != 1 p3: Critical section p4: turn = 2 Q q1: Non-critical section Q q2: while turn != 2 q3: Critical section q4: turn = 1 How would we do that here ? P p1: Non-critical section P p2: while turn != 1 p3: Critical section p4: turn = 2 Q q1: Non-critical section Q q2: while turn != 2 q3: Critical section q4: turn = 1 Freedom of deadlock How can we recognize a deadlock in the state space diagram? Freedom of deadlock How can we recognize a deadlock in the state space diagram? “If some processes are trying to enter their critical sections then one of them must eventually succeed.” Freedom of deadlock How can we recognize a deadlock in the state space diagram? “If some processes are trying to enter their critical sections then one of them must eventually succeed.” Deadlock freedom in state space diagram <=> from every reachable state, a critical section state is reachable P p1: Non-critical section P p2: while turn != 1 p3: Critical section p4: turn = 2 Q q1: Non-critical section Q q2: while turn != 2 q3: Critical section q4: turn = 1 Freedom of starvation “If any process tries to enter its critical section then that process must eventually succeed.” Freedom of starvation “If any process tries to enter its critical section then that process must eventually succeed.” If a process is wishing to enter its CS (awaiting its turn) and another process refuses to set the turn, the first process is said to be starved. Freedom of starvation “If any process tries to enter its critical section then that process must eventually succeed.” If a process is wishing to enter its CS (awaiting its turn) and another process refuses to set the turn, the first process is said to be starved. Any ideas on how starvation looks like in the state space diagram ? P p1: Non-critical section P p2: while turn != 1 p3: Critical section p4: turn = 2 Q q1: Non-critical section Q q2: while turn != 2 q3: Critical section q4: turn = 1 Thread could be stuck here and never come back -> If the other threads wait for him = starves Freedom of starvation “If any process tries to enter its critical section then that process must eventually succeed.” If a process is wishing to enter its CS (awaiting its turn) and another process refuses to set the turn, the first process is said to be starved. Possible starvation reveals itself as cycles in the state diagram. If\ta\tprocess\tdoes\tnot\tmake\tprogress\t from\tits\tNon-critical\tsection,\tstarvation\t is\tpossible\tin\tthis\texample Exam task Exam task CS = statement 2 (q2 and p2) Exam task CS = statement 2 (q2 and p2) Exam task CS = statement 2 (q2 and p2) Exam task Opt1 Exam task Opt1 Exam task Opt 2 Exam task Opt 2 Exam task Opt 2 First intuition ? Correct CS or not ? Exam task Opt 2 Exam task Opt 2 Exam task Opt 2 Pre-Discussion Ex.8 Assignment 8: Overview - Why do we need a memory model? - Why don’t we simply tell the compiler “execute everything exactly as I wrote it”? - How can we use Java’s memory model to reason about executions? Take-aways Volatile memory model Java memory model Intra- & Inter-Thread guarantees in Java Synchronization order program order state diagramm 3 correctness conditions Detect conditions in state diagram Let’s start We didn’t get an official quiz, so actually there would have been no quiz. But we did a selfmade kahoot: https://create.kahoot.it/share/week-8-pprog/5b7ec10a-737f-48e0-bcb3-414c49776637 See you next week J","libVersion":"0.3.2","langs":""}