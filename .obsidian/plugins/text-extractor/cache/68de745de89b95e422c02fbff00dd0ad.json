{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s05-lazy-evaluation.pdf","text":"Lazy Evaluation David Basin Department of Computer Science ETH Z¨urich Functional Programming David Basin 1 Evaluation Strategy • Evaluation strategy has, until now, been unimportant • Example: map (\\x -> x * x) ([1,2,3] ++ [2*2]) [1, 4, 9, 16] • Haskell is lazy: expressions evaluated only when necessary loop x = (loop x) + 1 ? f (*2) (loop 0) 14 divZero = 1 ‘div‘ 0 ? divZero *** Exception: divide by zero f g x = g 7 ? f (+1) divZero 8 • Subtle consequences such as data-driven computation Functional Programming Spring Semester, 2025 David Basin 2 Lazy evaluation • Evaluation based on function application and substitution f x = . . . x . . . x . . . ⇒ f a = . . . a . . . a . . . • Example for f x y = x + y f (9 − 3) (f 34 3) = (9 − 3) + (f 34 3) \u0011 In Haskell, substitution occurs without argument evaluation \u0011 Evaluation of arguments is postponed · · · = 6 + (f 34 3) = 6 + (34 + 3) = 6 + 37 = 43 • Some expressions may never be evaluated This can save arbitrarily large amounts of time Functional Programming Spring Semester, 2025 David Basin 3 Example in ghc g :: Int -> Int -> Int g x y = x + 12 switch :: Bool -> Int -> Int -> Int switch True x _ = x switch False _ y = y ? g 7 (loop 0) 19 :: Int ? switch True 8 (loop 0) 8 :: Int ? switch False 8 (loop 0) *** Exception: stack overflow ? switch False 0 divZero *** Exception: divide by zero Functional Programming Spring Semester, 2025 David Basin 4 Lazy evaluation (cont.) • Potential problem: duplicated computation, e.g., square x = x * x square (9-3) = (9-3) * (9-3) = 6 * (9-3) = 6 * 6 = 36 The same expression 9 − 3 is evaluated twice here • Duplication avoided by simultaneously reducing both occurrences Implementation based on sharing: terms represented as directed graphs square = \\ -> • * • square (9-3) (\\ -> • * •) (9-3) • * • 9-3 • * • 6 36 • Summary: function arguments are evaluated only when needed and at most once Functional Programming Spring Semester, 2025 David Basin 5 Evaluation — further details Typical function f p1 p2 ... pk | g1 = e1 | g2 = e2 : | otherwise = en where v1 ... = r1 : Built using patterns, guards, and local definitions Functional Programming Spring Semester, 2025 David Basin 6 Evaluation — pattern matching • Arguments evaluated as far as needed to determine pattern match f [] _ = 0 -- (f.1) f _ [] = 0 -- (f.2) f (a:_) (b:_) = a + b -- (f.3) • Haskell notation: [n .. m] == enumFromTo n m ? enumFromTo 1 10 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] :: [Int] • f [1 .. 3] [4 .. 6] executes as follows: f [1 .. 3] [4 .. 6] -- Does (f.1) match? = f (1 : [2 .. 3]) [4 .. 6] -- No. Does (f.2) match? = f (1 : [2 .. 3]) (4 : [5 .. 6]) -- No. Does (f.3) match? = 1 + 4 -- Yes! = 5 Functional Programming Spring Semester, 2025 David Basin 7 Evaluation — guards Execution proceeds sequentially, until success f a b c | a >= b && a >= c = a | b >= a && a >= c = b | otherwise = c Example f (2+3) (4-1) (3+9) ?? (2+3) >= (4-1) && (2+3) >= (3+9) -- try 1st guard ?? = 5 >= 3 && 5 >= (3+9) ?? = True && 5 >= (3+9) ?? = 5 >= (3+9) ?? = 5 >= 12 ?? = False ?? 3 >= 5 && 5 >= 12 -- try 2nd guard, already partially evaluated ?? = False && 5 >= 12 ?? = False ?? otherwise -- try final guard (= True) = 12 Functional Programming Spring Semester, 2025 David Basin 8 Evaluation — local definitions Local definitions (with where) are also lazily evaluated f a b f 3 6 | notNil l = front l ?? notNil l | otherwise = b ?? where l = [3 .. 6] where ?? = notNil ([3 .. 6]) l = [a .. b] ?? = notNil (3:[4 .. 6]) ?? = True front (c:d:_) = c+d = front l front [c] = c where l = 3:[4 .. 6] notNil [] = False = 3:4:[5 .. 6] notNil _ = True = 3+4 = 7 Functional Programming Spring Semester, 2025 David Basin 9 Evaluation — misc. • Functions are evaluated top-down (outermost operator first) f e1 (f e2 17) • and otherwise usually from left to right, depending on operator precedence f e1 + f e2 f e1 + f e2 ∗ f e3 • This kind of evaluation is as natural as “eager evaluation” But the consequences (and possibilities) are surprising Functional Programming Spring Semester, 2025 David Basin 10 Application 1: data-driven programming • Data can be generated lazily (on demand) The result is improved runtime complexity • Example: compute the minimal element of a list of elements • Data-driven solution \u0011 Sort the list \u0011 Take the sorted list’s head • Resulting program: lmin = head . sort Complexity? Functional Programming Spring Semester, 2025 David Basin 11 Example (cont.) • Data-driven list minimum isort [] = [] ins a [] = [a] isort (x:xs) = ins x (isort xs) ins a (x:xs) | a <= x = a : (x:xs) lmin = head . isort | otherwise = x : ins a xs • lmin [8,1,7,6] executes as follows (focusing on isort) isort [8,1,7,6] = ins 8 (isort [1,7,6]) = ins 8 (ins 1 (isort [7,6])) = ins 8 (ins 1 (ins 7 (isort [6]))) = ins 8 (ins 1 (ins 7 (ins 6 (isort [])))) = ins 8 (ins 1 (ins 7 (ins 6 []))) = ins 8 (ins 1 (ins 7 [6])) = ins 8 (ins 1 (6 : ins 7 [])) -- next evaluation step = ins 8 (1 : (6 : ins 7 [])) -- suspended evaluation = 1 : ins 8 (6 : ins 7 []) -- remains unevaluated • Thus lmin l executes in linear time! Functional Programming Spring Semester, 2025 David Basin 12 Application 2: infinite data • Lazy evaluation enables finite representation of infinite data • Example: infinite lists (streams) ones = 1 : ones from n = n : from (n+1) ? ones [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ^C{Interrupted!} ? from 1 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, ^C{Interrupted!} • Example: infinite trees data Tree a = Leaf | Node a (Tree a) (Tree a) deriving (Show, Eq) t = Node 1 t t ? t Node 1 (Node 1 (Node 1 (Node 1 ^C{Interrupted!} Functional Programming Spring Semester, 2025 David Basin 13 Infinite data (cont.) • One can compute with infinite data in finite time addFirstTwo (a:b:_) = a + b ? addFirstTwo ones 2 :: Int • Executes as follows addFirstTwo ones -- ones = 1 : ones = addFirstTwo (1:ones) = addFirstTwo (1:1:ones) = 1 + 1 = 2 • Conceptually elegant: we describe an infinite stream (tree, etc.) and compute with arbitrarily large finite prefixes of it Functional Programming Spring Semester, 2025 David Basin 14 Example: prime numbers • One of the oldest algorithms: the Sieve of Eratosthenes. 1. Generate the list of all natural numbers, starting with 2 2. Mark the first unmarked number 3. Cross out all multiples of the last marked number 4. Go to step 2 • N.B. \u0011 Infinitely many prime numbers: but each is eventually marked \u0011 Strictly speaking, this is not an algorithm since the steps cannot be carried out to completion in finite time Functional Programming Spring Semester, 2025 David Basin 15 Implementing the Sieve of Eratosthenes 1 1. Generate list: [2 .. ] 2. Marking: function head :: [a] -> a determines first element 3. Cross out all multiples: dropMults dropMults x ys = filter (\\y -> y ‘mod‘ x /= 0) ys 4. Repetition via recursion: sieve xs = head xs : sieve (dropMults (head xs) (tail xs)) The result primes = sieve [2 ..] ? take 15 primes [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] :: [Int] 1Some subtleties exist about whether this is a faithful description of Eratosthenes’ algorithm vs. “trial division”. See Melissa E. O’Neill The Genuine Sieve of Eratosthenes, J. Funct. Program. 19(1): 95-106 (2009). Functional Programming Spring Semester, 2025 David Basin 16 Example: Newton’s algorithm Problem: compute square roots Input: The radicand r ∈ R, with r ≥ 0, and the first approximation a0 ∈ R, where a0 > 0 Output: √r ∈ R Procedure: The sequence of approximations is defined by ai+1 = ai + r ai 2 If the sequence of ai converges to a, then a = (a + r/a)/2. I.e., a = √r. Numerical test: If ∣ ∣ ∣ai+1−ai ai ∣ ∣ ∣ < ϵ, then ai+1 is the result. Functional Programming Spring Semester, 2025 David Basin 17 Newton (cont.) • Example: a0 = 5, r = 2, √r = 1.4142135623 . . . • Iterative search for root of f (x) = x2 − 2 32 1 x f(x) Sequence of approximations is [5.0, 2.7, 1.72037, 1.44146, 1.41447, 1.41421, . . . ] • For correctness, convergence criteria, etc. see other courses. Functional Programming Spring Semester, 2025 David Basin 18 Traditional implementations Imperative static double EPS = 0.001; double root(double r, double a0) { double a, a’; a’ = a0; do { a = a’; a’ = (a + r / a) / 2.0; } while (!(abs((a’-a)/a)<EPS)); return a’; } Functional (cf. exercise sheet 2) eps :: Double eps = 0.001 root :: Double -> Double -> Double root r a0 = iter a0 where iter a | goodEnough a’ a = a’ | otherwise = iter a’ where a’ = (a + r / a) / 2.0 goodEnough a’ a = abs ((a’ - a) / a) < eps Correct implementation, but as a monolithic unit! Functional Programming Spring Semester, 2025 David Basin 19 Implementation — Haskell eps = 0.001 improve r x = (x + r / x) / 2 --- a[i+1] = (a[i] + r/a[i]) / 2 iterate f x = x : iterate f (f x) --- [x, f x, f (f x), ...] within (x:(x’:xs)) | goodEnough x’ x = x’ | otherwise = within (x’:xs) where goodEnough x’ x = abs ((x’ - x) / x) < eps root x0 r = within (iterate (improve r) x0) Direct implementation: generate and test Program simpler to understand and modify (e.g. with other convergence tests) Functional Programming Spring Semester, 2025 David Basin 20 Correctness • Lazy evaluation is powerful. But it complicates analyzing program complexity and correctness • Types like [Int] actually include 1. Finite, everywhere defined lists like [1, 3, 5] 2. Finite lists with “undefined” elements undef :: t undef = undef ? [1,2,undef] [1,2,^C{Interrupted!}] 3. Infinite lists with defined or undefined elements e.g. [1..] or [1, undef, 2, undef, 3, undef, . . . ] Functional Programming Spring Semester, 2025 David Basin 21 Correctness of lazy programs • Induction is only sound for (1): finite, everywhere defined data. \u0011 When we show by induction that ∀xs ys :: [t]. map f (xs ++ ys) = map f xs ++ map f ys we have proven the equality only for all finite lists! \u0011 But data of kind (2) and (3) also belong to [t] • We will not consider this correctness question further in this class. Thus, when we prove a proposition by induction, we mean only for all data of kind (1). Functional Programming Spring Semester, 2025 David Basin 22 Summary • Lazy evaluation enables new ways of writing programs Data is created or further evaluated only on demand! • We can describe algorithms that (potentially) produce and operate on infinite data \u0011 Infinite data of course is never generated \u0011 But arbitrarily large quantities can be produced on demand • Lazy evaluation is simple but exciting and has wide scope \u0011 Many real programs are not algorithms in the strict sense \u0011 E.g. reactive systems, operating systems, . . . shouldn’t terminate \u0011 Such systems can be implemented as (lazy) stream processors! \u0011 Establishing correctness requires, however, other techniques Functional Programming Spring Semester, 2025","libVersion":"0.5.0","langs":""}