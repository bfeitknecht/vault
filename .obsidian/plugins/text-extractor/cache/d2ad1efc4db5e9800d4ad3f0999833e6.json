{"path":"sem2/PProg/VRL/extra/kuhn/PProg-w07-kuhn.pdf","text":"Parallel Programming Session 7 Spring 2024, Sarah Kuhn Schedule Post-Discussion Assignment 6 / aka we solve a similar exercise together Theory Recap Pre-Discussion Assignment 7 Fork Join Framework the semester so farPost-Discussion Ex.6 General Not that many did it it -> If I would recommend a task then it’s this one We will look at mistakes that happened, they are really helpful for understanding the concepts Remember: we want to parallelize mergeSort given a sequential implementation of it we want to parallelize LongestSequence given a correct sequential version of it How to go RecursiveAction or RecursiveTask<T> How to go RecursiveAction or RecursiveTask<T> Constructor & fields :: what data do we need for the task? How to go RecursiveAction or RecursiveTask<T> Constructor & fields :: what data do we need for the task? Function call / “aka main thread” --> think of it as the source node create ForkJoinPool invoke main task ++++++++ ++++ ++ + How to go RecursiveAction or RecursiveTask<T> Constructor & fields :: what data do we need for the task? Function call / “aka main thread” --> think of it as the source node create ForkJoinPool invoke main task Override compute method --> Divide and Conquer span the new tasks ++++++++ ++++ ++ + Mistakes What is wrong with this code ? What is not optimal ? Mistakes What is wrong with this code ? What is not optimal ? ✅ (could add length) Mistakes 1 What is wrong with this code ? What is not optimal ? ✅ (could add length) ❌ Mistakes 1 What is wrong with this code ? What is not optimal ? Let’s correct it together ->in class in VS Code ++++++++ ++++ ++ + Mistakes 2 What is wrong with this code ? What is not optimal ? ❌ ❌ Mistakes 2 What is wrong with this code ? What is not optimal ? ❌ Read the assignment (also at the exam)& work with references instead of copies ❌ How to go: Longest Sequence RecursiveAction or RecursiveTask<T> Constructor & fields :: what data do we need for the task? Function call / “aka main thread” --> think of it as the source node create ForkJoinPool invoke main task Override compute method --> Divide and Conquer span the new tasks ++++++++ ++++ ++ + How to go: Longest Sequence RecursiveAction or RecursiveTask<T> How to go: Longest Sequence Constructor & fields :: what data do we need for the task? How to go: Longest Sequence Function call / “aka main thread” --> think of it as the source node create ForkJoinPool invoke main task ++++++++ ++++ ++ + How to go: Longest Sequence Override compute method --> Divide and Conquer span the new tasks Exam Task:Exam Task:Exam Task: At the exam you have to fill in gaps, but let’s rather code it together in class, because if you can code, you can fill the gaps at the exam. Let’s code it together in class ->code will be on the polybox Exam Task: Theory Recap What’s the plan? What we did the last weeks: fork/join à divide and conquer didn’t have to worry about shared memory and cs because of divide& conquer structure divide work for different threads and schedule the task but not really about overlapping data ++++++++ ++++ ++ + base case no further split Divide and ConquerWhat’s the plan? What we did the last weeks: fork/join à divide and conquer didn’t have to worry about shared memory and cs because of divide& conquer structure Critical section? What’s the plan? What we did the last weeks: fork/join à divide and conquer didn’t have to worry about shared memory and cs because of divide& conquer structure Critical section? What’s the plan? What we did the last weeks: fork/join à divide and conquer didn’t have to worry about shared memory and cs because of divide& conquer structure Critical section? Performance was what we focused on NOW : CORRECTNESS OF PARALLEL PROGRAMMS Concurrent data structures How the deal with data accessed by multiple threads ? Ideas ? Concurrent data structures How the deal with data accessed by multiple threads ? Immutable aka not changeable data Concurrent data structures How the deal with data accessed by multiple threads ? Immutable aka not changeable data concurrent read ? write ? synchronization? immutable: Concurrent data structures How the deal with data accessed by multiple threads ? Immutable aka not changeable data concurrent read ? write ? synchronization? immutable: yes Concurrent data structures How the deal with data accessed by multiple threads ? Immutable aka not changeable data concurrent read ? write ? synchronization? immutable: yes no writes at all Concurrent data structures How the deal with data accessed by multiple threads ? Immutable aka not changeable data concurrent read ? write ? synchronization? immutable: yes no writes at all no, not needed Concurrent data structures How the deal with data accessed by multiple threads ? Each thread gets its own part of the data (each independent) Can be changed but each thread has own part Concurrent data structures How the deal with data accessed by multiple threads ? Each thread gets its own part of the data (each independent) Can be changed but each thread has own part concurrent read ? write ? synchronization? isolated mutability: Concurrent data structures How the deal with data accessed by multiple threads ? Each thread gets its own part of the data (each independent) Can be changed but each thread has own part concurrent read ? write ? synchronization? isolated mutability: yes, but often threads don’t want to read the same f.eg divide and conquer or each thread gets part of an array Concurrent data structures How the deal with data accessed by multiple threads ? Each thread gets its own part of the data (each independent) Can be changed but each thread has own part concurrent read ? write ? synchronization? isolated mutability: yes, but no yes threads want to read the same Concurrent data structures How the deal with data accessed by multiple threads ? Each thread gets its own part of the data (each independent) Can be changed but each thread has own part concurrent read ? write ? synchronization? isolated mutability: yes, but no yes not needed threads want to read the same Concurrent data structures How the deal with data accessed by multiple threads ? Shared data: data can be freely changed, multiple threads could access it, memory location needed by multiple threads Concurrent data structures How the deal with data accessed by multiple threads ? Shared data: data can be freely changed, multiple threads could access it, memory location needed by multiple threads concurrent read ? write ? synchronization? shared data: Concurrent data structures How the deal with data accessed by multiple threads ? Shared data: data can be freely changed, multiple threads could access it, memory location needed by multiple threads concurrent read ? write ? synchronization? shared data: yes, but synchr. Concurrent data structures How the deal with data accessed by multiple threads ? Shared data: data can be freely changed, multiple threads could access it, memory location needed by multiple threads concurrent read ? write ? synchronization? shared data: yes, but synchr. yes, but synchr. Concurrent data structures How the deal with data accessed by multiple threads ? Shared data: data can be freely changed, multiple threads could access it, memory location needed by multiple threads concurrent read ? write ? synchronization? shared data: yes, but synchr. yes, but synchr. YES!!!!!!! Concurrent data structures How the deal with data accessed by multiple threads ? Shared data: data can be freely changed, multiple threads could access it, memory location needed by multiple threads concurrent read ? write ? synchronization? shared data: yes, but synchr. yes, but synchr. YES!!!!!!! Did we also see other methods than synchronized ? Concurrent data structures How the deal with data accessed by multiple threads ? Shared data: data can be freely changed, multiple threads could access it, memory location needed by multiple threads concurrent read ? write ? synchronization? shared data: yes, but synchr. yes, but synchr. YES!!!!!!! atomic operations Did we also see other methods than synchronized ? public class Counter { private int value; // returns a unique value public int getNext() { return value++; } } Thread Safe CounterThread Safe Counter public class AtomicCounter { private AtomicInteger value; public int getNext() { return value.incrementAndGet(); } } public class SyncCounter { private int value; public synchronized int getNext() { return value++; } } Thread Safe Counter public class AtomicCounter { private AtomicInteger value; public int getNext() { return value.incrementAndGet(); } } public class SyncCounter { private int value; public synchronized int getNext() { return value++; } } public class LockCounter { private int value; private Lock = new ReentrantLock(); public int getNext() { lock.lock(); try { return value++; } finally { lock.unlock() } } } Why all of this? extended bad interleaving: interleaving/ execution order that yields a wrong result, unexpected interleaving of instructions from different threads in program order. “improper scheduling” but doesn’t necessarily involve concurrent access to data structure Why all of this? bad interleaving: interleaving/ execution order that yields a wrong result, unexpected interleaving of instructions from different threads in program order. Why all of this? bad interleaving: Why all of this? bad interleaving: Why all of this? bad interleaving: or THREAD 1 THREAD 2 Why all of this? bad interleaving: THREAD 1 THREAD 2 Why all of this? bad interleaving: or THREAD 1 THREAD 2 Why all of this? bad interleaving: interleaving/ execution order that yields a wrong result, unexpected interleaving of instructions from different threads in program order. data race: less intuitive “access error” :: didn’t synchronize well one threads reads, other writes. or two threads write no synchronization to coordinate the accesses happen bc we didn’t synchronize well and results in behavior allowed by the memory model, but unexpected for the programmer Data race *shoutout to Andreas for the code snippets J Data race Not a bad interleaving but a data race if we print B =0 Under program order this couldn’t happen *shoutout to Andreas for the code snippets J Why all of this?Data race Not a bad interleaving but a data race if we print B =0 Under program order this couldn’t happen *shoutout to Andreas for the code snippets J Things in memory/compiler happen if we don’t synchronize :: data race Data race Not a bad interleaving but a data race if we print B =0 Under program order this couldn’t happen *shoutout to Andreas for the code snippets J Things in memory/compiler happen if we don’t synchronize :: data race Bad Things from the scheduler if we don’t synchronize :: bad interleaving Data race depends on memory model *shoutout to Andreas for the code snippets J Who really guarantees us this order ?? Data race depends on memory model Core problem: not the fact that multiple threads write and read from it but the assumption that the memory operations from the other thread before the write have already happened and are visible !! *shoutout to Andreas for the code snippets J Who really guarantees us this order ?? Data race vs. Bad interleaving Because of the scheduling /reordering of instructions the code is wrong but instructions are still in program order . (BAD INTERLEAVING) vs. we didn’t synchronize properly, then all memory model behavior is possible. Race condition Lecture 13-14 from first part Race condition is the same as bad interleaving Data race isn’t a race condition then Umbrella term for both Lecture 19 from second part Race condition: common bug in pprog, don’t exist in sequential programming Take Away Bad Interleaving != Data Race Why all of this? deadlock: Circular waiting/blocking (no instructions are executed/CPU time is used) between threads, so that the system (union of all threads) cannot make any progress anymore. Why all of this? deadlock: Circular waiting/blocking (no instructions are executed/CPU time is used) between threads, so that the system (union of all threads) cannot make any progress anymore. livelock: Livelocks are similar to deadlocks, but in a livelock, the threads are not blocked—they are still executing and consuming resources. However, they are unable to make progress towards completing their tasks due to their interactions with each other. all of them change state but no ones makes it into CS Locks Goal: mutual exclusion Locks in Java provide mutex Locks Goal: mutual exclusion Locks in Java provide mutex We know: synchronized keyword: uses intrinsic lock of objects aka monitor lock Locks Goal: mutual exclusion Locks in Java provide mutex We know: synchronized keyword: uses intrinsic lock of objects aka monitor lock Locks Goal: mutual exclusion Locks in Java provide mutex We know: synchronized keyword: uses intrinsic lock of objects aka monitor lock Get lock Lock.unlock() Lock. lock() External Locks Synchronized: “syntactic sugar on top of (intrinsic) locks” External Locks Synchronized: “syntactic sugar on top of (intrinsic) locks” Want more flexibility : external locks External Locks Synchronized: “syntactic sugar on top of (intrinsic) locks” Want more flexibility : external locks Actually maybe more intuitive External Locks Synchronized: “syntactic sugar on top of (intrinsic) locks” Want more flexibility : external locks Actually maybe more intuitive Allows mutex: one thread at a time can have “the talking box” External Locks Synchronized: “syntactic sugar on top of (intrinsic) locks” Want more flexibility : external locks Actually maybe more intuitive Allows mutex: one thread at a time can have “the talking box” For now: we can trust java locks that the only let one thread hold it later: look at actual implementation Why is synchronized not enough? Think of a scenario where we want shared data access but synchronized may not be the best option Why do we like locks? have a list of locks that you should acquire public int getNext(List<Lock> locks) { // acquire all locks // critical section // release all locks } How can we do this with synchronized ? Not (or very complicated) L but with locks J flexibility Why do we like locks? with synchronized: acquisition& release in a block structured way. A.lock(); B.lock(); B.unlock(); A.unlock(); synchronized (A) { synchronized (B) { } } A.lock(); B.lock(); A.unlock(); B.unlock(); What if we want this ? Why do we like locks? with synchronized: acquisition& release in a block structured way. A.lock(); B.lock(); B.unlock(); A.unlock(); synchronized (A) { synchronized (B) { } } A.lock(); B.lock(); A.unlock(); B.unlock(); What if we want this ? concurred data structures so called “hand-over-hand” locking we will see this later J Quiz: What is wrong with this code? void exchangeSecret(Person a, Person b) { a.getLock().lock(); b.getLock().lock(); Secret s = a.getSecret(); b.setSecret(s); a.getLock().unlock(); b.getLock().unlock() } public class Person { private ReentrantLock mLock = new ReentrantLock(); private String mName; public ReentrantLock getLock() { return mLock; } ... } Quiz: What is wrong with this code? void exchangeSecret(Person a, Person b) { a.getLock().lock(); b.getLock().lock(); Secret s = a.getSecret(); b.setSecret(s); a.getLock().unlock(); b.getLock().unlock() } public class Person { private ReentrantLock mLock = new ReentrantLock(); private String mName; public ReentrantLock getLock() { return mLock; } ... } Thread 1: exchangeSecret(p1, p2) Thread 2: exchangeSecret(p2, p1) Deadlock Possible solution void exchangeSecret(Person a, Person b) { ReentrantLock first, second; if (a.getName().compareTo(b.getName()) < 0) { first = a.getLock(); second = b.getLock(); } else if (a.getName().compareTo(b.getName()) > 0) { first = b.getLock(); second = a.getLock(); } else { throw new UnsupportedOperationException(); } first.lock(); second.lock(); Secret s = a.getSecret(); b.setSecret(s); first.unlock(); second.unlock(); } Always acquire and release the Locks in the same order Java locks Lock Java locks But this actually doesn’t compile, lock is just an interface. Java lock classes Reentrant Lock Reentrant ReadWriteLock.ReadLock Reentrant ReadWriteLock.WriteLock as always: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html we will see this in detail in a few weeks aka implement it Java lock classes Reentrant Lock Reentrant ReadWriteLock.ReadLock Reentrant ReadWriteLock.WriteLock as always: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html we will see this in detail in a few weeks aka implement it If you acquire it twice, you also have to release it twice. Now have to do it manually, synchronized block did it automatically. Lock has internal counter. Reentrant Locksconclusion Synchronized in Java: External locks in Java Acquire/release conclusion Synchronized in Java: External locks in Java Acquire/release Automatic(start/end block) Lock.lock(), lock.unlock() conclusion Synchronized in Java: External locks in Java Acquire/release Automatic(start/end block) Lock.lock(), lock.unlock() Scope aka “from -> to” conclusion Synchronized in Java: External locks in Java Acquire/release Automatic(start/end block) Lock.lock(), lock.unlock() Scope aka “from -> to” Just inside the block From .lock() to .unlock() conclusion Synchronized in Java: External locks in Java Acquire/release Automatic(start/end block) Lock.lock(), lock.unlock() Scope aka “from -> to” Just inside the block From .lock() to .unlock() Reentrant conclusion Synchronized in Java: External locks in Java Acquire/release Automatic(start/end block) Lock.lock(), lock.unlock() Scope aka “from -> to” Just inside the block From .lock() to .unlock() Reentrant yes Only if use ReentrantLock class conclusion Synchronized in Java: External locks in Java Acquire/release Automatic(start/end block) Lock.lock(), lock.unlock() Scope aka “from -> to” Just inside the block From .lock() to .unlock() Reentrant yes Only if use ReentrantLock class More flexible aka stronger Granularity how much of «our work is protected by each lock» Granularity how much of «our work is protected by each lock» Coarse-grained vs. Fine-grained Granularity how much of «our work is protected by each lock» Coarse-grained vs. Fine-grained Entire function vs. Less of the function behind one lock Granularity how much of «our work is protected by each lock» Coarse-grained vs. Fine-grained Entire function vs. Less of the function behind one lock banking example from lecture: one lock to protect the whole bank :: only one transaction one lock per account :: other acc. can do transactions in parallel Locking How would we implement this using coarse-grained locking ? Locking for the whole system Lock the whole system at once Global lockLocking Fine grained locking: More locks Each account has a lock add lock attribute in account class Locking Problems with this code ? Is correctness guaranteed ? Locking Thread 1: transferMoney(A, B) Thread 2: transferMoney(B, A)DEADLOCK But is it still a correct lock ? When is a lock correct? Locks should implement mutex -> for that we define the cs of our code Rather talk about correct implementation of cs Progress conditions are the requirements for a correct cs deadlock-free, starvation-free etc. à will see this in a few weeks. Old Exam Task (FS 2023) 109 Old Exam Task (FS 2023) 110 essentials Pre-Discussion Ex.7 Exercise 7 Banking System – Multi-Threaded Implementation – Coding exercise: Use synchronized and/or Locks − Might have to make additions to existing classes – Reason about Performance – Reason about Deadlocks – Run Tests ThreadSafe - sumAccounts() Task 4 – Summing Up With a fine-grained synchronization on the transfer method, the method sumAccounts() may return incorrect results when a transaction takes place at the same time. ● Explain why the current implementation of the sumAccounts() method is not thread-safe any more. ● You should provide a thread-safe implementation. ● Is there any way to parallelize this method? Let’s recap Pprog first half usually very predictable exam task Last year changed it up a bit… had 1 big true/false exercise Common exam topics (most often them always appear !): Wait& Notify Thread Basics (format varies) Pipelining Fork/Join Task graphs Amdahl/Gustafson Feedback https://forms.gle/7ju7LRL61Vrdiy4o8 Feedback to my exercise class & slides, I would appreciate it a lot if you would leave me some feedback ! I know everyone at home will skip this but still please do it, it takes legit 3min and it helps us a lot :** !!! Important !!!! Most probably you skipped the feedback Go back and do it :** Does not take long and it really helps us as TA’s It’s anonymous even though you have to sign in. Evaluation • Please fill in the evaluation (~5min) • It is anonymous • (you don’t need to be logged in, no PII is stored) • It helps us improving the exercise sessions • https://forms.gle/rL2pSEywCHZQMH5M9 Let’s start https://quizizz.com/admin/quiz/62266270c25f5d001e458 bb5?source=quiz_share See you next week J","libVersion":"0.3.2","langs":""}