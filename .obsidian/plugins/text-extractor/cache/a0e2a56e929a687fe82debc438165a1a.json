{"path":"sem3/A&D/VRL/script/A&D-script-w01-algorithms.pdf","text":"Skript zur Vorlesung Algorithmen und Datenstrukturen Woche 1: Algorithmenbegriff, Schnelle Multiplikation, Pasture-break Problem, Vollst¨andige Induktion Herbstsemester 2024 Stand: 16. Oktober 2024 Johannes Lengler David Steurer Inhaltsverzeichnis 1 Algorithmen 1 2 Schriftliche Multiplikation 3 3 Karatsubas Algorithmus 5 4 Pasture-break Problem 9 5 Vollst¨andige Induktion 13 i ii Kapitel 1 Algorithmen Algorithmen spielen eine wichtige Rolle, sobald wir Computer verwenden wollen, um grosse Datenmengen zu verarbeiten. Unsere F¨ahigkeit grosse Datenmengen zu verarbeiten erschliesst uns erstaunliche M¨oglichkeiten. So k¨onnen bestimmte Al- gorithmen moderne Sprachmodelle wie ChatGPT erstellen, indem sie unglaublich grosse Datenmengen verarbeiten. N¨aherungsweise k¨onnen wir uns vorstellen, dass diese Algorithmen die gesammelten Texte der Menschheit verarbeiten, insbesondere alle B¨ucher und Zeitungsartikel, die jemals verfasst wurden. Algorithmen erstellen interessante Verbindungen zu vielen anderen Themen des Informatikstudiums. Zum Beispiel, befasst sich die Programmierung mit der Frage, wie wir Aufgaben so beschreiben, dass Computer sie korrekt erledigen k¨onnen. Im Bereich der Algorithmen geht es auch darum, Aufgaben mithilfe von Computern zu erledigen, allerdings haben wir neben der Korrektheit zus¨atzlich zum Ziel, dass der Aufwand m¨oglichst gering ist. Wenn wir Wege finden, dieselbe Aufgabe mit weniger Aufwand zu erledigen, bedeutet dies, dass Computer dieselbe Datenmenge in k¨urzerer Zeit verarbeiten k¨onnen. Ebenso bedeutet dies, dass Computer in derselben Zeit gr¨ossere Datenmengen verarbeiten k¨onnen. Es liegt nahe zu vermuten, dass wir zum Verarbeiten grosser Datenmengen le- diglich besonders schnelle Computer ben¨otigen. Allerdings ist dies ein Trugschluss. Es ist sicherlich zutr¨aglich, besonders schnelle Computer zu verwenden, allerdings haben Algorithmen einen mindestens genauso grossen Einfluss auf die Menge der Da- ten, die wir zeitnah verarbeiten k¨onnen. Zum Beispiel ist es m¨oglich, dass geeignete Algorithmen eine grosse Datenmenge in wenigen Minuten auf einem handels¨ublichen Laptop verarbeiten k¨onnen, wohingegen weniger geeignete Algorithmen f¨ur dieselbe Datenmenge selbst auf dem weltweit schnellsten Supercomputer mindestens solange br¨auchte, bis unsere Sonne erlischt. Was sind Algorithmen? Wir k¨onnen Algorithmen zweckm¨assig und informell de- finieren als systematische Zerlegungen eines vermeintlich schwierigen Problems in einfache Schritte. Diese Definition scheint zun¨achst banal, da jede L¨osung eines Pro- blems wohl beinhaltet, es in machbare Schritte zu zerlegen. Tats¨achlich weist diese scheinbare Banalit¨at bereits auf die grundlegende Bedeutung des Algorithmenbe- griffs hin. Unsere informelle Definition beinhaltet, dass die Zerlegung systematisch sein soll. Wir meinen damit, dass die Zerlegung verallgemeinerbar ist und nicht spezialisiert ist auf eine bestimmte Instanz des Problems. Um diese Verallgemeinerbarkeit zu gew¨ahrleisten, verlangen wir f¨ur einen Algorithmus eine eindeutige, vollst¨andige und allgemeing¨ultige Beschreibung der Abfolge von Schritten zur L¨osung des Problems. 1 2 Algorithmen Ein gutes Beispiel ist die aus der Schule bekannte schriftliche Multiplikation. Dieser Algorithmus erlaubt uns, zwei beliebige Zahlen miteinander zu multiplizieren, indem wir eine Reihe von Additionen und einstelligen Multiplikationen durchf¨uhren. In diesem Sinn zerlegen wir das Problem der mehrstelligen Multiplikation in einfache Schritte. Die Zerlegung ist verallgemeinerbar in dem Sinn, dass sie nicht f¨ur jedes Paar von Zahlen neu ermittelt werden muss, sondern dass wir die Zerlegung f¨ur ein beliebiges Paar von Zahlen beschreiben k¨onnen. In der Informatik spielen Algorithmen eine zentrale Rolle: Computer k¨onnen beliebige Algorithmen auf Daten unvorstellbar schnell ausf¨uhren mit Milliarden von Schritten pro Sekunde. (Wir bezeichnen die m¨oglichen Schritte eines Computers als elementare Operationen.) In diesem Sinn werden alle F¨ahigkeiten von Computern erst durch Algorithmen erm¨oglicht. Aus diesem Grund wird die Informatik oft als Wissenschaft der Algorithmen definiert. In der Vorlesung werden wir verschiedene Algorithmen entwerfen und ihre Ei- genschaften analysieren. Allerdings ist das eigentliche Ziel der Vorlesung nicht die Funktionsweise oder die Eigenschaften dieser konkreten Algorithmen zu erlernen. Vielmehr ist das Ziel Ihnen eine algorithmische Denkweise zu vermitteln. Ein wich- tiger Teil dieser Denkweise ist die Art von Fragen, die wir zu Algorithmen untersu- chen: ‹ Welche verschiedenen Algorithmen gibt es f¨ur dasselbe Problem? ‹ Wie k¨onnen wir diese Algorithmen miteinander vergleichen? K¨onnen wir Algo- rithmen ein Qualit¨atsmass zuordnen und quantitativ bemessen, wie viel besser ein Algorithmus ist als ein anderer? ‹ K¨onnen wir den bestm¨oglichen Algorithmus f¨ur ein Problem bestimmen bez¨uglich dieses Qualit¨atsmasses? Kapitel 2 Schriftliche Multiplikation Die schriftliche Multiplikation erlaubt uns, zwei beliebige Zahlen zu multiplizieren. Da dieser Algorithmus schon aus der Schule bekannt ist, nennen wir ihn oft Schulal- gorithmus. Schriftliche Multiplikation 2-stelliger Zahlen Am Beispiel der Zahlen a = 87 und b = 43 l¨asst sich der Algorithmus wie folgt darstellen: a1 a0 · b1 b0 8 7 · 4 3 2 1 a0 · b0 2 4 a1 · b0 2 8 a0 · b1 3 2 a1 · b1 3 7 4 1 Zun¨achst wird die Einerziffer der ersten Zahl a0 = 7 mit der Einerziffer der zwei- ten Zahl b0 = 3 multipliziert. Wir notieren das Ergebnis a0 · b0 = 21. Anschliessend wird die Zehnerziffer der ersten Zahl a1 = 8) mit der Einerziffer der zweiten Zahl b0 = 3 multipliziert. Wir schreiben das Ergebnis a1 · b0 = 24 um eine Stelle nach links versetzt unter das vorherige Ergebnis. Im n¨achsten Schritt wird die Einerziffer der ersten Zahl a0 = 7 mit der Zehnerziffer der zweiten Zahl b1 = 4 multipliziert. Wir schreiben das Ergebnis a0 · b1 = 28 um eine Stelle nach links versetzt unter das vorherige Ergebnis. Schliesslich wird die Zehnerziffer der ersten Zahl a1 = 8 mit der Zehnerziffer der zweiten Zahl b1 = 4 multipliziert. Wir schreiben das Ergebnis a1 · b1 = 32 um zwei Stellen nach links versetzt unter das vorherige Ergebnis. Zum Schluss addieren wir die vier berechneten Zahlen und erhalten das Ergebnis 3741. F¨ur den konkreten Fall a = 87 und b = 43 k¨onnten wir uns mithilfe eines Taschenrechners versichern, dass dieses Ergebnis korrekt ist. F¨ur den allgemeinen Fall k¨onnen wir uns von der Korrektheit wie folgt ¨uberzeugen: F¨ur die Stellen der Zahlen a und b im Dezimalsystem gilt a = 10a1 + a0 und b = 10b1 + b0, wobei a0, b0 die Einerziffern und a1, b1 die Zehnerziffern von a und b sind. Laut seiner Beschreibung berechnet der Algorithmus die Zahl a0 · b0 + 10 · a1 · b0 + 10 · a0 · b1 + 100 · a1 · b1. Unter Verwendung des Distributivgesetzes der Addition und Multiplikation zeigt die folgende Rechnung, dass dieses Ergebnis immer mit dem L¨osungswert a · b ¨ubereinstimmt, a · b = (10 · a1 + a0) · (10 · b1 + b0) = a0 · b0 + 10 · a1 · b0 + 10 · a0 · b1 + 100 · a1 · b1 . 3 4 Schriftliche Multiplikation Schriftliche Multiplikation n-stelliger Zahlen Seien a und b zwei beliebige n- stellige Zahlen mit a = 10 n−1 · an−1 + 10n−2 · an−2 + · · · + 10 · a1 + a0, b = 10 n−1 · bn−1 + 10n−2 · bn−2 + · · · + 10 · b1 + b0, wobei an−1, . . . , a0 ∈ {0, . . . , 9} und bn−1, . . . , b0 ∈ {0, . . . , 9} die Stellen von a und b im Dezimalsystem sind. Der Algorithmus berechnet alle Teilprodukte ai · bj f¨ur i, j ∈ {0, 1, . . . , n − 1}. Es gibt insgesamt n2 solcher Teilprodukte. Anschliessend werden die Teilprodukte addiert, wobei sie ihrem Stellenwert entsprechend verschoben werden. Geht es besser? Es stellt sich die Frage, ob ein besserer Algorithmus f¨ur die Mul- tiplikation existiert, der mit wesentlich weniger einstelligen Multiplikationen aus- kommt. Der ber¨uhmte russische Mathematiker Kolmogorov hatte vermutet, dass die An- zahl der einstelligen Multiplikationen im Schulalgorithmus, bis auf konstante Fak- toren, bestm¨oglich ist. Diese Vermutung wurde jedoch im Jahr 1960 von Anatoli Karatsuba, einem seiner Studenten, widerlegt. Kapitel 3 Karatsubas Algorithmus Im vorherigen Abschnitt haben wir gesehen, dass der Schulalgorithmus n2 einstellige Multiplikationen ben¨otigt, um zwei n-stellige Zahlen zu multiplizieren. In diesem Abschnitt untersuchen wir, ob wir solche Zahlen mit wesentlich weniger einstelligen Multiplikationen berechnen k¨onnen. Karatsubas Algorithmus f¨ur 2-stellige Zahlen Wir betrachten zun¨achst wieder das Beispiel der Zahlen a = 87 und b = 43. Der Schulalgorithmus ben¨otigt f¨ur diesen Fall 4 einstellige Multiplikationen. Karatsuba entdeckte einen Algorithmus, der dieses Problem mit nur 3 einstelligen Multiplikationen l¨ost. a1 a0 · b1 b0 8 7 · 4 3 2 1 a0 · b0 3 2 a1 · b1 −1 −(a1 − a0) · (b1 − b0) 5 3 a0 · b0 + a1 · b1 3 7 4 1 Zun¨achst berechnen wir die Produkte a0 · b0 und a1 · b1, wie im Schulalgorithmus. Danach berechnen wir noch ein zus¨atzliches Produkt (a1 − a0) · (b1 − b0). Im Beispiel ist a1 − a0 = 1 und b1 − b0 = 1, also ist das Produkt (a1 − a0) · (b1 − b0) = 1. Wir notieren dieses Ergebnis mit negativem Vorzeichen versehen und um eine Stelle nach links versetzt. Anschliessen verwenden wir die zuvor berechneten Produkte a0 · b0 und a1 · b1 wieder und notieren ihre Summe um eine Stelle nach links versetzt. Anschliessend addieren wir die alle Zahlen und erhalten das gew¨unschte Ergebnis 3741. Korrektheit f¨ur 2-stellige Zahlen F¨ur die Zahlen a = 10a1 + a0 und b = 10b1 + b0 berechnet Karatsubas Algorithmus als Ergebnis a0 · b0 + 10 · (a0 · b0 + a1 · b1 − (a1 − a0) · (b1 − b0)) + 100 · a1 · b1. F¨ur den mittleren Term mit Koeffizienten 10 gilt a0 · b0 + a1 · b1 − (a1 − a0) · (b1 − b0) = a1 · b0 + a0 · b1 . Also berechnet Karatsubas Algorithmus dasselbe Ergebnis wie der Schulalgorithmus. Somit ist Karatsubas Algorithmus f¨ur zweistellige Zahlen korrekt. Wir sehen, dass Karatsubas Algorithmus f¨ur zweistellige Zahlen nur 3 Teilpro- dukte (anstatt 4 Teilprodukte wie beim Schulalgorithmus). Allerdings ist zun¨achst 5 6 Karatsubas Algorithmus unklar, inwiefern Karatsubas Algorithmus wirklich besser ist als die Schulmethode. (Unter anderem f¨uhrt Karatsubas einige zus¨atzliche Subtraktionen aus, die so im Schulalgorithmus nicht vorkommen.) Karatsubas Algorithmus f¨ur 4-stellige Zahlen Wir wollen nun Karatsubas Idee verallgemeinern auf die Multiplikation von zwei 4-stelligen Zahlen. Als Beispiel w¨ahlen wir die Zahlen a = 8765 und b = 4321. Wir spalten die vierstellige Zahlen a und b auf in jeweils zwei zweistellige Zahlen, so dass a = 102a1 + a0 und b = 102b1 + b0, wobei a1 = 87, a0 = 65, b1 = 43, und b0 = 21. Wir verwenden nun dieselbe Idee wie zuvor um eine 4-stellige Multiplikation auf drei 2-stellige Multiplikationen zur¨uckzuf¨uhren. a1 a0 · b1 b0 87 65 · 43 21 13 65 a0 · b0 37 41 a1 · b1 46 22 a0 · b0 + a1 · b1 − (a1 − a0) · (b1 − b0) 37 87 35 65 Wir k¨onnen die drei 2-stelligen Multiplikationen berechnen mit jeweils drei 1- stelligen Multiplikationen, indem wir Karatsubas Algorithmus f¨ur 2-stellige Zahlen verwenden. Insgesamt f¨uhrt Karatsubas Algorithmus f¨ur 4-stellige Zahlen also 3 · 3 = 9 einstellige Multiplikationen aus. Der Schulalgorithmus braucht f¨ur diesen Fall 42 = 16 einstellige Multiplikationen. Veranschaulichung Mithilfe eines Baumdiagramms k¨onnen wir den Ablauf von Karatsubas Algorithmus veranschaulichen. Der Knoten ganz oben im Diagramm entspricht der urspr¨unglichen Multiplikation. Die Kinder eines Knotens entsprechen den Multiplikationen, in die die Multiplikation des Elternknotens zerlegt wird. a · b a0 · b0 a1 · b1 (a1 − a0) · (b1 − b0) Die Knoten in der zweiten Ebene des Diagramms entsprechen 2-stelligen Multi- plikationen. Die Knoten in der dritten Ebene entsprechen 1-stelligen Multiplikatio- nen. Karatsubas Algorithmus f¨ur n-stellige Zahlen Sei k eine nat¨urliche Zahl und n = 2k. Seien a und b zwei beliebige n-stellige Zahlen. Wir schreiben die Zahlen a und b in der Form a = 10n/2a1 + a0 und b = 10n/2b1 + b0, wobei a1 und b1 die n/2 h¨ochstwertigsten Stellen von a und b sind und a0 und b0 die n/2 niedrigstwertigsten Stellen von a und b sind. Mit derselben Idee wie zuvor k¨onnen wir eine 2k-stellige 3.0 Karatsubas Algorithmus 7 Multiplikationen zur¨uckf¨uhren auf drei 2k−1-stellige Multiplikationen. Diese 2k−1- stellige Multiplikationen f¨uhren wir zur¨uck auf jeweils drei 2k−2-stellige Multiplika- tionen. Wir fahren fort bis wir alles auf 1-stellige Multiplikationen zur¨uckgef¨uhrt haben. Wie zuvor k¨onnen wir den Ablauf des Algorithmus mithilfe eines Baumdia- gramms veranschaulichen. a · b a0 · b0 . . . . . . . . . a1 · b1 . . . . . . . . . (a1 − a0) · (b1 − b0) . . . . . . . . . Der Baum hat k+1 Ebenen. In der i-ten Ebene befinden sich 3i−1 Knoten, die je- weils der Multiplikation zweier 2k−i+1-stelliger Zahlen entsprechen. In der vorletzten Ebene (i = k) befinden sich 3k−1 Knoten, die jeweils einer 2-stelligen Multiplikation entsprechen. Jeder dieser Knoten f¨uhrt zu drei einstelligen Multiplikationen. Insge- samt f¨uhrt der Algorithmus also 3k einstellige Multiplikationen aus. Dabei ist zu beachten, dass die Subtraktionen, die der Algorithmus ausf¨uhrt, nicht zu zus¨atzli- chen einstelligen Multiplikation f¨uhren. Analyse F¨ur zwei n = 2k-stellige Zahlen ben¨otigt Karatsubas Algorithmus 3k ein- stellige Multiplikationen. Die Schulmethode hingegen verwendet n2 = (2k)2 = 4k einstellige Multiplikationen. F¨ur grosse Werte k ist 3k wesentlich kleiner als 4k. F¨ur k = 9 gilt (4/3)k ≈ 13.32 und damit ist Karatsubas Algorithmus mehr als zehnmal g¨unstiger als der Schulalgorithmus im Bezug auf die Anzahl einstelliger Multiplikationen. F¨ur k = 18 gilt (4/3)k ≈ (13.32)2 > 177 und damit ist Karatsubas Algorithmus mehr als 177-mal g¨unstiger. Geht es noch besser? Tats¨achlich ist es m¨oglich, zwei n-stellige Zahlen mit noch weniger als 3k einstelligen Multiplikationen zu multiplizieren, falls n = 2k. Es gibt einen Algorithmus, der h¨ochstens C · 2k · k einstellige Multiplikationen ben¨otigt, f¨ur eine sehr grosse Konstante C. Dieser Algorithmus wurde erst im Jahr 2019 entdeckt. Leider ist der Algorithmus sehr kompliziert. Deshalb werden wir diesen Algorithmus in der Vorlesung nicht weiter besprechen. Zudem stellt sich der Vorteil gegen¨uber Karatsubas Algorithmus erst f¨ur astronomisch grosse Zahlen ein. Im Gegensatz zu Karatsubas Algorithmus hat dieser Algorithmus (noch) keine praktische Relevanz. Fazit In dieser Vorlesung geht es nicht darum, besser multiplizieren zu lernen, son- dern darum, eine algorithmische Denkweise zu entwickeln. Ein wichtiger Teil dieser Denkweise ist die Bereitschaft, naheliegende L¨osungsverfahren zu hinterfragen und zu untersuchen, ob es bessere L¨osungsverfahren gibt. Oftmals lassen sich dramatische Verbesserungen erzielen. Karatsubas Algorithmus ist ein gutes Beispiel daf¨ur. 8 Karatsubas Algorithmus Die Grundidee von Karatsubas Algorithmus ist ein Problem (wie n-stellige Multi- plikation) auf ein leichteres Teilproblem derselben Art zur¨uckzuf¨uhren. Diese Strate- gie ist erstaunlich vielseitig anwendbar und heisst Rekursion. Falls die Teilprobleme entstehen, indem wir die urspr¨ungliche Eingabe in mehrere ungef¨ahr gleichgrosse Teile aufspalten, sprechen wir oft von “divide-and-conquer”. Kapitel 4 Pasture-break Problem In diesem Abschnitt diskutieren wir das Pasture-break Problem. Dieses Problem ist etwas ungew¨ohnlich, da es nicht direkt darum geht, Eingabedaten zu verarbeiten. Dennoch ist es ein interessantes Problem und illustriert einige wichtige Konzepte der Entwicklung und Analyse von Algorithmen. Problemstellung Wir stellen uns vor, dass eine kurzsichtige Kuh auf einer unend- lich grossen Weide steht. Die Weide ist begrenzt durch einen Zaun. Es gibt genau eine L¨ucke im Zaun. Die Kuh m¨ochte die Weide verlassen (wohl weil das Gras auf der anderen Seite des Zauns gr¨uner ist). Allerdings weiss sie nicht, wo sich die L¨ucke befindet. Zaun Kuh k Schritte Wir nehmen an, dass die Kuh sich nur in Schritten parallel zum Zaun bewegen kann. In einem Schritt kann sie nur feststellen, ob sich an ihrer Position die L¨ucke befindet. Unser Ziel ist es, die Kuh so zu steuern, dass sie mit m¨oglichst wenigen Schritten die L¨ucke findet und die Weide verlassen kann. Distanz bekannt Nehmen wir zun¨achst an, dass die Kuh die Distanz k zur L¨ucke kennt. In diesem Fall kann sie die L¨ucke finden, indem sie k Schritte nach links l¨auft und anschliessend 2k Schritte nach rechts. Dieser Algorithmus findet die L¨ucke in jedem Fall. Falls sich die L¨ucke links vom Startpunkt befindet, dann findet sie die Kuh schon nach k Schritten. Falls sich die L¨ucke rechts vom Startpunkt befindet, dann findet sie die Kuh nach 3k Schritten. Der worst case des Algorithmus betr¨agt also 3k Schritte. Start L¨ucke L¨ucke! k k k 9 10 Pasture-break Problem Distanz unbekannt In der Praxis ist es nat¨urlich unrealistisch anzunehmen, dass die Kuh die Distanz zur L¨ucke kennt. Wir wollen deshalb einen Algorithmus finden, der auch ohne dieses Wissen auskommt. Eine naheliegende Idee ist es, die Distanz vom Startpunkt in jeder Iteration allm¨ahlich zu erh¨ohen, solange bis wir die L¨ucke finden. Algorithmus 1 Zun¨achst betrachten wir den Algorithmus, der die Distanz zum Startpunkt bei jedem Richtungswechsel um jeweils 1 erh¨oht. Die Kuh l¨auft zuerst einen Schritt nach links, dann zur¨uck zum Startpunkt. Anschliessend l¨auft die Kuh zwei Schritte nach rechts, dann zur¨uck zum Startpunkt. Danach drei Schritte nach links, und so weiter. Wir analysieren nun den worst case dieses Algorithmus. In diesem Fall l¨auft die Kuh zun¨achst k − 1 Schritte in die richtige Richtung (also in Richtung der L¨ucke). Einen Schritt vor der L¨ucke kehrt sie um und l¨auft k − 1 Schritte zur¨uck zum Startpunkt. Dann l¨auft die Kuh k Schritte in die falsche Richtung (also entgegen der Richtung der L¨ucke). Die Kuh kehrt um und l¨auft k Schritt zur¨uck zum Startpunkt. Schliesslich macht sich die Kuh wieder in die richtige Richtung auf und findet die L¨ucke nach k weiteren Schritten. Start L¨ucke 1 1 2 23 3 k-1 k-1k k k . . . L¨ucke! Insgesamt betr¨agt die Anzahl der Schritte in diesem Fall, 2 · 1 + 2 · 2 + 2 · 3 + · · · + 2 · (k − 1) + 2 · k + k Nach der Gaussschen Formel (m¨oglicherweise aus der Schule bekannt) betr¨agt die Summe der ersten k nat¨urlichen Zahlen k · (k + 1)/2. Also l¨asst sich die worst-case Schrittzahl wie folgt vereinfachen, 2 · k · (k + 1) 2 + k = k · (k + 2) . Algorithmus 2 Im vorherigen Algorithmus haben wir die Distanz vom Startpunkt in jeder Iteration nur um 1 erh¨oht. Das heisst in jeder Iteration untersucht die Kuh nur 1-2 neue Positionen, wohingegen der Aufwand in jeder Iteration um einen 4.0 Pasture-break Problem 11 Schritt w¨achst. In diesem Sinn ist der Aufwand pro Iteration nicht verh¨altnism¨assig zum Informationsgewinn pro Iteration. Es liegt damit nahe, den Algorithmus so abzu¨andern, dass pro Iteration die Anzahl der schon bekannten Positionen ungef¨ahr gleich gross ist wie die Anzahl der neuen Positionen. Dieser Algorithmus verdoppelt also die Distanz in jeder Iteration. Konkret l¨auft die Kuh zuerst einen Schritt nach links, dann zur¨uck zum Start- punkt. Anschliessend l¨auft sie zwei Schritte nach rechts, dann zur¨uck zum Start- punkt. Danach vier Schritte nach links, dann zur¨uck zum Startpunkt. Und so weiter. Wir bestimmen wieder die Anzahl Schritte im worst case. W¨ahle eine nat¨urliche Zahl i so, dass 2i−1 < k ⩽ 2i. (Diese Wahl von i ist f¨ur jedes k eindeutig!) Im worst case l¨auft die Kuh zun¨achst 2i−1 Schritte in die richtige Richtung, dann kehrt sie um und l¨auft 2i−1 Schritte zur¨uck zum Startpunkt. Danach l¨auft sie 2i Schritte in die falsche Richtung und 2i Schritte zur¨uck zum Startpunkt. Anschliessend macht sich die Kuh auf, um 2i+1 Schritte in die richtige Richtung zu laufen, aber sie findet schon nach k Schritte die L¨ucke. Start L¨ucke 1 1 2 24 4 2i−1 2i−12i 2i k . . . L¨ucke! Insgesamt ben¨otigt die Kuh im worst case also 2 · (2 0 + 21 + · · · + 2i−1 + 2i) + k Schritte. Die Summe der ersten i + 1 Zweierpotenzen ist gleich 2i+1 − 1. (Siehe Abschnitt ¨uber vollst¨andige Induktion.) Also l¨asst sich die worst-case Anzahl der Schritte folgendermassen beschr¨anken, 2 · (2 i+1 − 1) + k < 2 · 2 i+1 + k ⩽ 8k + k = 9k , wobei wir 2i+1 = 4 · 2i−1 < 4k verwenden. Vergleich F¨ur grosse Werte von k ist die worst-case Schranke 9k von Algorithmus 2 wesentlich kleiner als der worst case k ·(k +2) von Algorithmus 1. Zum Beispiel, f¨ur k = 100 ben¨otigt Algorithmus 1 mehr als 10000 Schritte im worst case, wohingegen Algorithmus 2 stets weniger als 900 Schritte ben¨otigt. 12 Pasture-break Problem Geht es besser? Es liegt nahe zu vermuten, dass wir den worst case verbessern k¨onnten, indem wir die Distanzen vom Startpunkt noch schneller mit jeder Itera- tion wachsen lassen. Es stellt sich aber heraus, dass sich dadurch der worst case verschlechtert! Tats¨achlich ist die worst-case Schranke 9k bestm¨oglich. F¨ur jeden Algorithmus und f¨ur jedes ε > 0 gibt es ein k, so dass der Algorithmus im worst case mindes- tens (9 − ε) · k Schritte ben¨otigt. (An dieser Stelle lassen wir diese Behauptung unbewiesen.) Kapitel 5 Vollst¨andige Induktion Um die Effizienz und Korrektheit eines Algorithmus zu ermitteln, k¨onnten wir ei- ne pragmatische Sichtweise einnehmen und den Algorithmus auf m¨oglichst vielen interessanten Eingaben testen. Solche Tests sind wertvoll, erlauben uns aber keine R¨uckschl¨usse darauf, wie sich der Algorithmus auf anderen Eingaben verh¨alt. In vielen Bereichen des t¨aglichen Lebens stehen Ursache und Wirkung miteinander im Verh¨altnis. Aber bei Algorithmen k¨onnen schon kleine Ver¨anderungen der Eingabe verheerende Folgen f¨ur die Ausgabe haben. Deshalb haben wir in dieser Vorlesung den Anspruch, unsere Algorithmen f¨ur alle Eingaben zu analysieren. Solche univer- sellen Aussagen k¨onnen wir nur mittels mathematischen Beweisen treffen. Obwohl es kein einfaches Rezept daf¨ur gibt, mathematische Beweise zu finden, k¨onnen Beweisprinzipien die Suche nach Beweisen erheblich erleichtern. Ein beson- ders wichtiges und vielseitiges Beweisprinzip ist die vollst¨andige Induktion. Beispiel eines Induktionsbeweises Sei Sk = 1 + 2 + 4 + · · · + 2k−1 die Summe der ersten k Zweierpotenzen. F¨ur kleine Werte von k k¨onnen wir diese Summe leicht berechnen: S1 = 1 , S2 = 1 + 2 = 3 , S3 = 1 + 2 + 4 = 7 , S4 = 1 + 2 + 4 + 8 = 15 . Anhand dieser Werte sehen wir, dass f¨ur alle k ⩽ 4 die Summe Sk genau eins weniger ist als die n¨achste Zweierpotenz 2k. Es liegt nahe zu vermuten, dass diese Eigenschaft verallgemeinert werden kann und dass Sk = 2k − 1 f¨ur alle nat¨urlichen Zahlen k gilt. Um diese Aussage f¨ur alle nat¨urlichen Zahlen k zu beweisen, verwenden wir das Beweisprinzip der vollst¨andigen Induktion. Dazu m¨ussen wir zun¨achst den Indukti- onsanfang ausf¨uhren und zeigen, dass die Aussage f¨ur k = 1 gilt. Tats¨achlich sind die beiden Werte S1 = 1 und 21 − 1 = 1 gleich. Im Anschluss m¨ussen wir den Induk- tionsschritt ausf¨uhren und f¨ur alle nat¨urlichen Zahlen k zeigen, dass Sk+1 = 2k+1 −1 gilt unter der Annahme, dass Sk = 2k − 1 gilt. Tats¨achlich k¨onnen wir diesen Induk- tionsschritt hier ausf¨uhren, indem wir Sk+1 und Sk wie folgt zueinander in Bezug setzen: Sk+1 = Sk + 2k (per Definition) = 2 k − 1 + 2k (Induktionshypothese) = 2 k+1 − 1 . (Rechenregel) 13 14 Vollst¨andige Induktion Wir konnten hier also sowohl den Induktionsanfang als auch den Induktionsschritt erfolgreich ausf¨uhren. Das Beweisprinzip der vollst¨andigen Induktion besagt, dass wir dadurch die Identit¨at Sk = 2k − 1 f¨ur alle nat¨urlichen Zahlen k bewiesen haben. Allgemeine Form Sei A(k) eine Aussage ¨uber eine nat¨urliche Zahl k, z.B. die Aus- sage, dass die Summe der ersten k Zweierpotenzen 2k − 1 betr¨agt. Unser Ziel ist es, zu beweisen, dass diese Aussage f¨ur alle nat¨urlichen Zahlen k ∈ N gilt. Ein Induktionsbeweis besteht aus zwei Teilen, dem Induktionsanfang und dem Induktionsschritt. ‹ F¨ur den Induktionsanfang m¨ussen wir zeigen, dass die Aussage A(1) gilt. Dieser Teil eines Induktionsbeweises ist oft leichter als der Induktionsschritt. ‹ Beim Induktionsschritt m¨ussen wir f¨ur alle nat¨urlichen Zahlen k ∈ N zeigen, dass aus der Aussage A(k) die Aussage A(k + 1) folgt. Wir m¨ussen also die Aussage A(k + 1) beweisen, d¨urfen dabei aber verwenden, dass die Aussage A(k) gilt. Beim Induktionsschritt ist es wichtig, wirklich alle nat¨urlichen Zahlen k ∈ N abzudecken.","libVersion":"0.5.0","langs":""}