{"path":"var/export/A&D-bf-u09.pdf","text":"9.2      Short Statements about Directed Graphs (a) True. Proof by contradiction. Assume G has no sources, ∀v ∈ V : degin(v) ≥ 1. Then we ﬁnd a topological sorting. Contradiction. This topological sorting has to start from a source but by assumption there are none. Furthermore, a topological sorting is possible if and only if the graph is a directed acyclic cycle. Contraposition of the fact that it doesn't implies that G contains a cycle. □ (b) False. Consider the following counter example. Observe that every vertex has even in-degree and out-degree, ∀v ∈ V : degin(v) ≡ 2 degout(v) ≡ 2 0. However, G does not contain a directed eulerian walk. 1 2 3 4 5 6 □ (c) True. A, B, C, F , D, H, I, E, G is a topological sorting. □ 9.4      Longest Path in DAG (a) Assume for some path P = (vij)j∈ [k] of length k there exists two indices j1, j2 ∈ [k] such that ij1 > ij2. It's given that the lexicographic order of vertices forms a sequence T = (vi)n of topological sorting. Then it follows that for s = ij1, t = ij2 the edge (vs, vt) = e ∈ E forms a directed cycle C = e ∪ (vt)s. Contradiction. By assumption the given graph G is acyclic. Through contraposition the implication is proven. □ (b) 1. dimension of integers memoization table is n, formally dp = int[n] 2. subproblems consist of the length of longest path up to vertex i, formally dp[v] = m\u0000x l\u0000n\u0000t\u0000 p\u0000t\u0000 t\u0000 v 3. recursion, base cases and calculation order is given below, the correctness follows from the fact that traversing a path always increases its length and we always store the maximum of reaching a vertex from the current path and the one traversed before that # in\u0000t\u0000a\u0000\u0000\u0000e dp t\u0000\u0000le l = [0] * n # \u0000\u0000erat\u0000 ov\u0000r v\u0000\u0000t\u0000\u0000es i\u0000 t\u0000p\u0000l\u0000\u0000i\u0000\u0000l \u0000r\u0000\u0000r for v i\u0000 r\u0000nge(n): # v1, v2, \u0000.\u0000, vn for w i\u0000 A\u0000j[v]: # v\u0000\u0000t\u0000\u0000es a\u0000j\u0000ce\u0000t t\u0000 v l[w] = m\u0000x(l[w], l[v] + 1\u0000 # e\u0000t\u0000nd p\u0000t\u0000 \u0000\u0000\u0000m v \u0000r l\u0000ave unchanged # retur\u0000 m\u0000\u0000\u0000\u0000um l\u0000n\u0000t\u0000 p\u0000t\u0000 i\u0000 dp t\u0000\u0000le retur\u0000 m\u0000x(dp) 1 2 3 4 5 6 7 8 9 4. computation order is given above, iterate over the n vertices 5. extracting the solution is done by ﬁnding the maximum of the memo array, m\u0000x{dp} 6. runtime is O(|V | + |E|), recursion iterates over every edge e ∈ E and extraction iterates over every vertex v ∈ V exactly once 9.5      DFS doesn't solve Eulerian Cycle (a) The pre-order generated by DFS is P = (a, b, d, c, e). The DFS tree is given below. a b c d e The generated walk is W = (a, e, c, a, d, b, a). This is an eulerian cycle, since it contains every edge e ∈ E exactly once and the ending vertex is identical to the starting vertex. □ (b) For starting vertex a ∈ V we have the pre-order P = (a, c, b, d, f, g, h, i, e) and the following DFS tree. a b c d e f g h i The generated walk is W = (a, d, f, g, e, c, b, d, c, a) which is missing the edges {g, h}, {h, i}, {g, i} ∈ E. Thus it isn't eulerian and the algorithm produces a false output. □","libVersion":"0.5.0","langs":""}