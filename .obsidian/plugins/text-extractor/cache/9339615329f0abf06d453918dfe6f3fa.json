{"path":"sem2/PProg/VRL/extra/benji/PProg-w10.pdf","text":"Parallel Programming Exercise Session 10 Outline 2 1. Feedback: Assignment 9 2. Lecture Recap: Semaphores 3. Lecture Recap: Monitors 4. Lecture Recap: Conditional locks 5. Assignment 10 Feedback: Assignment 9 3 Recap: Critical Section Properties 4 • Mutual exclusion: No more then one process executing in the critical section • Progress: When no process is in the critical section, any process that requests entry must be permitted without delay • No starvation (bounded wait): If any process tries to enter its critical section then that process must eventually succeed. P p1: Non-critical section P p2: while turn != 1 p3: Critical section p4: turn = 2 Q q1: Non-critical section Q q2: while turn != 2 q3: Critical section q4: turn = 1 turn = 1P p1: Non-critical section P p2: while turn != 1 p3: Critical section p4: turn = 2 Q q1: Non-critical section Q q2: while turn != 2 q3: Critical section q4: turn = 1 • Mutual exclusion: E.g. State (p3,q3,_) is not reachable • Progress: E.g. There exists a path for P such that state (P3, _ , _) is reachable from (P2,_,_). Typical counterexamples: deadlocks and livelocks • No starvation (bounded wait): Possible starvation reveals itself as cycles in the state diagram. turn = 1 Feedback for Assignment 9 7 Feedback for Assignment 9 8 • One way to solve the livelock problem is to impose an ordering when acquiring the lock on the shared resource. • Or one of the spouses can actually take the spoon after certain number of retries Feedback for Assignment 9 9 Optimistic vs Pessimistic concurrency control Lecture Recap 10 Lecture Recap: Bakery Lock 11 Filter Lock is not fair. The Bakery Lock fixes this issue. Lecture Recap: Bakery Lock 12 Filter Lock is not fair. The Bakery Lock fixes this issue. Remember fairness? Lecture Recap: Bakery Lock 13 Filter Lock is not fair. The Bakery Lock fixes this issue. Remember fairness Lecture Recap: Bakery Lock 14 Filter Lock is not fair. The Bakery Lock fixes this issue. Remember fairness What is the doorway section and the waiting section? Lecture Recap: Bakery Lock 15 Filter Lock is not fair. The Bakery Lock fixes this issue. Remember fairness What is the doorway section and the waiting section? Lecture Recap: Bakery Lock 16 Filter Lock is not fair. The Bakery Lock fixes this issue. Remember fairness What is the doorway section and the waiting section? How would you prove fairness? Lecture Recap: Bakery Lock 17 Filter Lock is not fair. The Bakery Lock fixes this issue. Remember fairness What is the doorway section and the waiting section? How would you prove deadlock-freedom? Lecture Recap: Bakery Lock 18 Filter Lock is not fair. The Bakery Lock fixes this issue. Remember fairness What is the doorway section and the waiting section? Deadlock-freedom + “first-come-first-serve” implies Starvation-freedom Lecture Recap: Semaphores 19 Used to restrict the number of threads that can access a specific resource. • acquire() gets a permit, if no permit available block • release() gives up permit, releases a blocking acquirer Lecture Recap: Semaphores 20 Semaphore N Threads have permit to a semaphore, others will wait (blocked) until someone leaves the semaphore 21 2 Semaphore Thread 1 Thread 2 Thread 3 22 1 Thread 1 Thread 2 Thread 3 acquire CS Semaphore 23 0 Thread 1 Thread 2 Thread 3 acquire CS acquire CS Semaphore 24 0 Thread 1 Thread 2 Thread 3 Semaphore acquire acquire CS acquire CS 25 0 Thread 1 Thread 2 Thread 3 Semaphore acquire acquire CS release acquire CS release 26 2 Thread 1 Thread 2 Thread 3 Semaphore acquire 27 1 Thread 1 Thread 2 Thread 3 Semaphore acquire CS Think of semaphores as bike rentals Semaphores: Implementation 28 Semaphore: integer-valued abstract data type S with some initial value s≥0 and the following atomic operations: acquire(S) { wait until S > 0 dec(S) } release(S) { inc(S) } Semaphores: Implementation 29 Semaphore: integer-valued abstract data type S with some initial value s≥0 and the following atomic operations: acquire(S) { wait until S > 0 dec(S) } release(S) { inc(S) } What is the difference between a Lock and a Semaphore? Semaphores: Implementation 30 Semaphore: integer-valued abstract data type S with some initial value s≥0 and the following atomic operations: acquire(S) { wait until S > 0 dec(S) } release(S) { inc(S) } When would you use a semaphore? Semaphores: Usage example 31 Semaphores: Usage example 32 Lecture Recap: Monitors 33 Monitors provide two kinds of thread synchronization: mutual exclusion and cooperation using a lock • higher level mechanism than semaphores and more powerful • instance of a class that can be used safely by several threads • all methods of a monitor are executed with mutual exclusion Lecture Recap: Monitors 34 Monitors provide two kinds of thread synchronization: mutual exclusion and cooperation using a lock When thread is sent to wait we release the lock! Can a monitor induce a deadlock? • the possibility to make a thread waiting for a condition • signal one or more threads that a condition has been met Monitors in Java 35 Uses intrinsic lock (synchronized) of an object wait() – the current thread waits until it is signaled notify() – wakes up one waiting thread notifyAll() – wakes up all waiting threads Monitors in Java 36 Uses intrinsic lock (synchronized) of an object wait() – the current thread waits until it is signaled notify() – wakes up one waiting thread notifyAll() – wakes up all waiting threads When do you use notify, when notifyAll? Monitors in Java: Signal & Continue 37 • signalling process continues running • signalling process moves signalled process to entry queue More theory: • Signal & Continue (SC) : The process who signal keep the mutual exclusion and the signaled will be awaken but need to acquire the mutual exclusion before going. (Java’s option) • Signal & Wait (SW) : The signaler is blocked and must wait for mutual exclusion to continue and the signaled thread is directly awaken and can start continue its operations. • Signal & Urgent Wait (SU) : Like SW but the signaler thread has the guarantee that it would go just after the signaled thread • Signal & Exit (SX) : The signaler exits from the method directly after the signal and the signaled thread can start directly. Monitors in Java: Example P/C Queue 38 Monitors in Java: Example P/C Queue 39 synchronized long dequeue() { long x; if (isEmpty()){ try { wait(); } catch (InterruptedException e) {} } x = doDequeue(); notifyAll(); return x; } synchronized void enqueue(long x) { if (isFull()){ try { wait(); } catch (InterruptedException e) {} } doEnqueue(x); notifyAll(); } Monitors in Java: Example P/C Queue 40 synchronized long dequeue() { long x; if (isEmpty()){ try { wait(); } catch (InterruptedException e) {} } x = doDequeue(); notifyAll(); return x; } synchronized void enqueue(long x) { if (isFull()){ try { wait(); } catch (InterruptedException e) {} } doEnqueue(x); notifyAll(); } Exercise: What can go wrong? Monitors in Java: Example P/C Queue 41 1. Queue is full 2. Process Q enters enqueue(), sees isFull(), and goes to the waiting list. 3. Process P enters dequeue() 4. In this moment process R wants to enter enqueue() and blocks 5. P signals Q and thus moves it into the ready queue, P then exits dequeue() 6. R enters the monitor before Q and sees ! isFull(), fills the queue, and exits the monitor 7. Q resumes execution assuming isFull() is false => Inconsistency! synchronized void enqueue(long x) { if (isFull()){ try { wait(); } catch (InterruptedException e) {} } doEnqueue(x); notifyAll(); } Monitors in Java: Example P/C Queue 42 synchronized void enqueue(long x) { while (isFull()){ try { wait(); } catch (InterruptedException e) {} } doEnqueue(x); notifyAll(); } synchronized long dequeue() { long x; while (isEmpty()){ try { wait(); } catch (InterruptedException e) {} } x = doDequeue(); notifyAll(); return x; } Lecture Recap: Lock Conditions 43 Can be used to implement monitors! Java Locks provide conditions that can be instantiated Condition notFull = lock.newCondition(); Java conditions offer .await() – the current thread waits until condition is signaled .signal() – wakes up one thread waiting on this condition .signalAll() – wakes up all threads waiting on this condition What is the difference to a Monitor? Lock Conditions 44 AwaitCondition 1 Condition 2 Condition 3 Lock Conditions: Example P/C Queue 45 Lock Conditions: Example P/C Queue 46 Assignment 9 47 Task 1 - Dining Philosophers 48 Originally proposed by E. W. Dijkstra Imagine five philosophers who spend their lives thinking and eating. They sit around a circular table with five chairs with a big plate of spaghetti. However, there are only five chopsticks available. Task 1 - Dining Philosophers 49 Each philosopher thinks and when he gets hungry picks up the two chopsticks closest to him. • If a philosopher can pick up BOTH chopsticks, he eats for a while. • After a philosopher finishes eating, he puts down the chopsticks and starts to think again. Find a solution that… 50 • Makes deadlocks impossible • Has no starvation • More than one parallel eating philosopher is possible Task 2 – Monitors, Conditions and Bridges 51 Only either 3 cars or one truck may be on the bridge at each moment. Implement Classes BridgeMonitor and BridgeCondition How to Test my Implementation? Implement method invariant() to check if the state is valid: at the end of a method there are never too many cars or trucks on the bridge Task 3 – Semaphores and Databases 52 Use semaphores to implement login and logout database functionality that supports up to 10 concurrent users Use barrier to implement 2-phase backup functionality. Task 3 – Semaphores and Databases 53 Implement Classes MySemaphore and MyBarrier Use monitors for both to avoid busy loop • Put processes to sleep, when there is no entry into semaphore • Wake up a waiting process when releasing a semaphore acquire(S) { wait until S > 0 dec(S) } release(S) { inc(S) } Try to understand the existing DatabaseJava implementation before implementing your own semaphore and barrier.","libVersion":"0.3.1","langs":""}