{"path":"sem4/FMFP/PV/FMFP-finals/FMFP-FS23.pdf","text":"Formal Methods and Functional Programming Final Exam, 2023 August 7, 2023, 8:30 – 11:30 Student: Last Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . First Name: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Stud.-Nr.: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . General Comments: 1. This booklet consists of 28 pages; the back page of this booklet is page 28. 2. After the exam begins: check that your exam papers are complete (7 assignments and 2 pages of background material for the FM part) and you may detach the background material from the rest of the exam. 3. You may complete the assignments in any order. 4. Only write on the exam paper and extra paper sheets which are given by the assistants. Do not take any of this paper out of the exam: submit it all. Write your first and last name and your student number on every sheet of paper that you write on. 5. This is a closed book exam: the only resources allowed are pen and paper. No laptops, no cell phones, no smart watches, no prepared notes. Do not use pencil and do not use red. 6. You may use any functions from the Haskell Prelude in your solutions (without giving their definitions), unless specified otherwise. You also may use any function from one subproblem to solve the subsequent subproblems, even if you have not provided a definition for the function itself. 7. Write clearly in the sense of logic, language, and readability. Label all rule applications in your derivation trees. The clarity of your arguments and explanations affects your grade. 8. You have 180 minutes to complete the exam. Assignment 1 2 3 4 5 6 7 ∑ Max 16 30 12 42 44 18 18 180 Points Formal Methods and Functional Programming, Final Exam, 2023 2 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2023 3 Assignment 1: Typing (16 Points) Task 1.A (6 Points) Recall the following functions from the Haskell Prelude library. zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] (.) :: (b -> c) -> (a -> b) -> a -> c Determine whether the following expressions are well-typed or not, and if they are, state the most general type. No other justification is needed. i) \\x y -> x (y, y) ii) (.) zipWith (\\x y -> x y) Assignment 1 continues on the next page. Formal Methods and Functional Programming, Final Exam, 2023 4 Task 1.B (10 Points) Recall the proof rules for the Mini-Haskell type system: Var . . . , x : τ, . . . ⊢ x :: τ Γ, x : σ ⊢ t :: τ Abs Γ ⊢ λx. t :: σ → τ Γ ⊢ t1 :: σ → τ Γ ⊢ t2 :: σ App Γ ⊢ t1 t2 :: τ Int Γ ⊢ n :: Int True Γ ⊢ True :: Bool False Γ ⊢ False :: Bool Γ ⊢ t :: Int iszero Γ ⊢ iszero t :: Bool Γ ⊢ t1 :: Int Γ ⊢ t2 :: Int BinOp Γ ⊢ (t1 op t2) :: Int for op ∈ {+, ∗} Γ ⊢ t0 :: Bool Γ ⊢ t1 :: τ Γ ⊢ t2 :: τ if Γ ⊢ if t0 then t1 else t2 :: τ Γ ⊢ t1 :: τ1 Γ ⊢ t2 :: τ2 Tuple Γ ⊢ (t1, t2) :: (τ1, τ2) Γ ⊢ t :: (τ1, τ2) fst Γ ⊢ fst t :: τ1 Γ ⊢ t :: (τ1, τ2) snd Γ ⊢ snd t :: τ2 We extend Mini-Haskell with show and while do where show casts any type to String and while do represents a while loop. We add the following two rules to our Mini-Haskell type system: Γ ⊢ t :: τ show Γ ⊢ show t :: String Γ ⊢ t1 :: Bool Γ ⊢ t2 :: τ while Γ ⊢ while t1 do t2 :: τ Formally infer the most general type of the following Mini-Haskell expression. Label every step of the proof with the name of the used rule and list all the encountered type constraints explicitly. ⊢ λx. while (iszero (fst x)) do (show ((snd x)(fst x))) :: ... Formal Methods and Functional Programming, Final Exam, 2023 5 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2023 6 Assignment 2: Axiomatic Semantics (30 Points) Consider the following statement s: b := 0; while i < n do if b = 0 then i := i + 1 else r := r + 1 end; b := 1 - b end Construct a proof outline that proves the following Hoare triple: {i = 0 ∧ r = 0 ∧ n > 0 ∧ n = N } s {r = N − 1} Clearly state below the loop invariant you use in your proof outline. You must justify any entailments in your proof. The next page is left blank for your proof. You may find the Hoare logic rules provided in the background material at the end of the exam useful. Invariant: Formal Methods and Functional Programming, Final Exam, 2023 7 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2023 8 Assignment 3: Logic (12 Points) Task 3.A (6 Points) For each formula below, determine whether it is valid (satisfied with respect to all structures), contradictory (does not admit any models), or satisfiable but not valid (satisfied with respect to some but not all structures). Use the semantics of first-order logic with equality. valid contrad. satisfiable but not valid EXAMPLE (∀x. x = x) ××× 1. (∀x.p(x)) ∧ (∃y.¬p(y)) 2. ∀x.(∀y.(p(x, y) ∧ p(y, x) → r(x, y))) 3. ¬a → (a → b) There is exactly one correct choice for each formula. Mark your answer with a cross in the appropriate box. You do not need to justify your answer. Task 3.B (6 Points) Recall the following rules of natural deduction: axiom Γ, A ⊢ A Γ, A ⊢ B → -I Γ ⊢ A → B Γ ⊢ A[x/t] ∃-I Γ ⊢ ∃x.A Γ ⊢ ∃x.A Γ, A ⊢ B ∃-E ∗∗ Γ ⊢ B Side condition: (**) x does not occur freely in any formula in Γ or B. Consider the following trees, which are attempts to prove the formulas (∃x. ∀z. p(z) ∧ R) → ∀y. p(y) ∧ R and (p(z, z) ∧ R) → ∃x. p(x, y) ∧ R, where R is an arbitrary first-order formula, using the rules of natural deduction. There must be a mistake in both trees because the formulas are clearly not valid. For each tree, which is the wrong proof step? Provide the number (1 to 7) of the wrong steps and briefly explain the problem. Formal Methods and Functional Programming, Final Exam, 2023 9 Incorrect proof tree 1 axiom (3) ∃x. ∀z. p(z) ∧ R ⊢ ∃x. ∀z. p(z) ∧ R axiom (4) ∃x. ∀z. p(z) ∧ R, ∀z. p(z) ∧ R ⊢ ∀y. p(y) ∧ R ∃-E∗∗ (2) ∃x. ∀z. p(z) ∧ R ⊢ ∀y. p(y) ∧ R →-I (1) ⊢ (∃x. ∀z. p(z) ∧ R) → ∀y. p(y) ∧ R ** z does not occur freely in ∃x. ∀z. p(z) ∧ R or ∀y. p(y) ∧ R. Incorrect proof tree 2 axiom (7) p(z, z) ∧ R ⊢ p(y, y) ∧ R ∃-I (6) p(z, z) ∧ R ⊢ ∃x. p(x, y) ∧ R →-I (5) ⊢ (p(z, z) ∧ R) → ∃x. p(x, y) ∧ R Formal Methods and Functional Programming, Final Exam, 2023 10 Assignment 4: Small-Step Semantics (42 Points) In this exercise, we present an attempt at extending the IMP language with the notion of a bounded command, i.e., a command for which at most a given number of steps is executed. This is accomplished by introducing a statement of the form bounded s by e, where s is an arbitrary statement and e is an integer expression denoting how many steps can be executed. Formally, the semantics of bounded s by e is captured by the following derivation rules: ⟨s, σ⟩ →1 σ′ (Bounded1SOS) ⟨bounded s by e, σ⟩ →1 σ′ if B[[0 < e]]σ = tt ⟨s, σ⟩ →1 ⟨s′, σ′⟩ (Bounded2SOS) ⟨bounded s by e, σ⟩ →1 ⟨bounded s′ by e - 1, σ′⟩ if B[[0 < e]]σ = tt (Bounded3SOS) ⟨bounded s by e, σ⟩ →1 σ if B[[0 < e]]σ = ff Task 4.A (8 Points) Consider the following IMP statement s: bounded while 0 < b do (bounded b := b - 1; a := a * 2 by 3) end by 3 Let σ be a state such that σ(a) = 1 and σ(b) = 3. Prove using structural operational semantics that there is a state σ′ such that ⟨s, σ⟩ → ∗ 1 σ′. Provide the complete derivation sequence, as well as the derivation tree for the first step. You may find the Small-Step rules provided in the background material at the end of the exam useful. We define the following shorthands for your convenience: sb ≡ bounded b := b - 1; a := a * 2 by 3 sw ≡ while 0 < b do sb end Formal Methods and Functional Programming, Final Exam, 2023 11 Task 4.B (10 Points) The semantics provided for the new statement does not completely match its informal description. Specifically, it is possible for a bounded statement to run forever. a) Provide a statement s and an expression e for which there does not exist a σ′ such that ⟨bounded s by e, σzero⟩ → ∗ 1 σ′. Statement s: Expression e: b) How could you change the provided rules such that for any arbitrary statement s, expression e and state σ the configuration ⟨bounded s by e, σ⟩ always terminates? Your new semantics should better match the informal description from the start of this assignment. Hint: Introducing a new internal statement may be useful in this exercise. Formal Methods and Functional Programming, Final Exam, 2023 12 Task 4.C (24 Points) Consider the original set of rules given in the problem statement. Prove that for any arbitrary statement s, integer k, expression e, and states σ and σ′, if F V (e) ∩ F V (s) = ∅ ∧ k ≤ A[[e]]σ ∧ ⟨s, σ⟩ → k 1 σ′, then ⟨bounded s by e, σ⟩ → k 1 σ′. To simplify, assume that s contains only assignment and sequential composition statements (i.e. no skip, if, while, or bounded statements). The next page is left blank to give you more space. You can assume the following lemmas without having to prove them: • L1: ∀e, s, σ, σ′. (⟨s, σ⟩ →1 σ′ ∧ F V (e) ∩ F V (s) = ∅) ⇒ A[[e]]σ = A[[e]]σ′ • L2: ∀e, s, s′, σ, σ′. (⟨s, σ⟩ →1 ⟨s′, σ′⟩ ∧ F V (e) ∩ F V (s) = ∅) ⇒ A[[e]]σ = A[[e]]σ′ • L3: ∀e, s, s′, σ, σ′. (⟨s, σ⟩ →1 ⟨s′, σ′⟩ ∧ F V (e) ∩ F V (s) = ∅) ⇒ F V (e) ∩ F V (s′) = ∅ Formal Methods and Functional Programming, Final Exam, 2023 13 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2023 14 Assignment 5: Programming (44 Points) In this exercise, we consider a simplified version of the IMP language from the FM lecture, called IMP−−. IMP−− is represented in Haskell using the following abstract syntax: data Stm = Skip -- skip | Assign String Aexp -- v := e | Seq Stm Stm -- s; s’ | If Bexp Stm Stm -- if e then s else s’ | While Bexp Stm -- while e do s end data Aexp = Add Aexp Aexp -- e + e’ | Mul Aexp Aexp -- e * e’ | Var String -- v | Num Integer -- i data Bexp = Eq Aexp Aexp -- e = e’ | Le Aexp Aexp -- e < e’ In this exercise, you will write a small interpreter for IMP −−in Haskell, and use it to perform some testing on IMP −−programs. In every subtask, you must ensure that each IMP −− statement or expression has the same (intuitive!) semantics as its IMP counterpart from the lecture. While writing your code, you can assume that Data.List has been imported. Formal Methods and Functional Programming, Final Exam, 2023 15 Task 5.A (6 Points) Fill in the gaps in the following functions, which compute the set of all variables that appear in Aexps, Bexps, and IMP −− statements, respectively. Sample Output. > vars_bool (Eq (Add (Var \"x\") (Num 1)) (Var \"y\")) [\"x\", \"y\"] > vars_statement (Assign \"y\" (Var \"z\")) [\"y\", \"z\"] -- vars_integer computes the list of all variables in an Aexp vars_integer :: Aexp -> [String] vars_integer (Add e1 e2) = vars_integer e1 ++ vars_integer e2 vars_integer (Mul e1 e2) = vars_integer e1 ++ vars_integer e2 vars_integer (Var v) = [v] vars_integer (Num i) = [] -- vars_bool computes the list of all variables in a Bexp vars_bool :: Bexp -> [String] vars_bool (Eq e1 e2) = _____________________________________________ vars_bool (Le e1 e2) = _____________________________________________ -- vars_statement computes the list of all variables in an Stm vars_statement :: Stm -> [String] vars_statement Skip = [] vars_statement (Seq s1 s2) = vars_statement s1 ++ vars_statement s2 vars_statement (While e s1) = vars_bool e ++ vars_statement s1 vars_statement (Assign s e) = ______________________________________ vars_statement (If e s1 s2) = ______________________________________ vars :: Stm -> [String] vars = nub . vars_statement -- nub from Data.List removes duplicates Formal Methods and Functional Programming, Final Exam, 2023 16 Task 5.B (8 Points) In the rest of this exercise, we consider a type State whose elements map variable names (encoded as Strings) to variable values (here Integers). We suppose that this type provides the following functions: -- \"empty\" is an empty state empty :: State -- \"m ! v\" is the value of variable v according to state m (!) :: State -> String -> Integer -- \"insert v d m\" is the state m(v := d) insert :: String -> Integer -> State -> State -- \"fromList [(v1, d1), ..., (vk, dk)]\" is the state {v1 → d1, ..., vk → dk} fromList :: [(String, Integer)] -> State Fill in the gaps in the following functions, which evaluate Aexps and Bexps with respect to a given state: Sample Output. > eval_integer (fromList [(\"x\", 1), (\"y\", 2)]) (Add (Var \"x\") (Var \"y\")) 3 > eval_bool (fromList [(\"x\", 1), (\"y\", 2)]) (Le (Var \"x\") (Num 42)) true -- eval_integer evaluates an Aexp w.r.t. a state eval_integer :: State -> Aexp -> Integer eval_integer s (Add e1 e2) = _______________________________________ eval_integer s (Mul e1 e2) = _______________________________________ eval_integer s (Var v) = _______________________________________ eval_integer s (Num i) = _______________________________________ -- eval_bool evaluates a Bexp w.r.t. a state eval_bool :: State -> Bexp -> Bool eval_bool s (Eq e1 e2) = (eval_integer s e1) == (eval_integer s e2) eval_bool s (Le e1 e2) = (eval_integer s e1) < (eval_integer s e2) Formal Methods and Functional Programming, Final Exam, 2023 17 Task 5.C (12 Points) Fill in the gaps in the code of the following function eval_statement :: State -> Stm -> State that, given a state σ and a statement s, returns the state σ′ obtained after executing s on σ. You can assume that undefined variables are never accessed. If the program does not terminate, your implementation should also not terminate. You can reuse the functions eval_integer and eval_bool from the previous subtask even if you did not solve that subtask. Sample Output. > eval_statement (fromList [(\"x\", 1)]) (Assign \"y\" (Var \"x\")) {\"x\" → 1, \"y\" → 1} > eval_statement (fromList [(\"x\", 18)]) (While (Le (Num 0) (Var \"x\")) (Assign \"x\" (Add (Var \"x\") (Num (-1))))) {\"x\" → 0} -- eval_statement evaluates an Stm w.r.t. a state eval_statement :: State -> Stm -> State eval_statement s Skip = _____________________________________ eval_statement s (Assign v a) = _____________________________________ eval_statement s (Seq s1 s2) = _____________________________________ eval_statement s (If e s1 s2) = if (eval_bool s e) then eval_statement s s1 else eval_statement s s2 eval_statement s (While e s1) = _____________________________________ _____________________________________ _____________________________________ Formal Methods and Functional Programming, Final Exam, 2023 18 Task 5.D (8 Points) Fill in the gaps in the code of the following function all_states :: [String] -> Integer -> [State] that, when passed a list of variables [v1, . . . , vk] and an integer b, outputs all possible states with variable names v1, . . . , vk and variable values in {0, ..., b}. Sample Output. > all_states [\"x\"] 4 [{\"x\" → 0}, {\"x\" → 1}, {\"x\" → 2}, {\"x\" → 3}, {\"x\" → 4}] > all_states [\"x\", \"y\"] 2 [{\"x\" → 0, \"y\" → 0}, {\"x\" → 1, \"y\" → 0}, {\"x\" → 2, \"y\" → 0}, {\"x\" → 0, \"y\" → 1}, {\"x\" → 1, \"y\" → 1}, {\"x\" → 2, \"y\" → 1}, {\"x\" → 0, \"y\" → 2}, {\"x\" → 1, \"y\" → 2}, {\"x\" → 2, \"y\" → 2}] -- returns [s(v := 0), ..., s(v := b)] insert_all :: String -> Integer -> State -> [State] insert_all v b s = map (\\i -> insert v i s) [0..b] all_states :: [String] -> Integer -> [State] all_states [] b = _______________________________________________ all_states (h:t) b = _______________________________________________ _______________________________________________ _______________________________________________ Formal Methods and Functional Programming, Final Exam, 2023 19 Task 5.E (10 Points) We now want to use our interpreter to perform some testing. Concretely, given a claim about the behavior of a program s defined by a Hoare triple {P}s{Q}, we want to try out multiple values of the input variables of the program to see if we find any counterexamples to the claim. For example, consider the following program π: if (x < 1) then z := 1 else z := x The claim {x > 0}π{z > 1} is incorrect, because for x = 1, executing π produces z = 1, and 1 ̸> 1. Hence, we can find out that the claim is incorrect via testing by executing the program with the initial state {x ↦→ 1}. Write a function test: Integer -> (Bexp, Stm, Bexp) -> Bool that given an integer b and a Hoare triple {P}s{Q}, returns true iff running the program with all possible values of variables in {0, . . . , b} did not discover any counterexample, and false iff any counterexample was found. The function should not terminate if s does not terminate. You may reuse any function from a previous subtask even if you did not solve this subtask. You can assume that all variables used in P and Q appear in s. Sample Output. > test 1 (Eq (Var \"x\") (Num 1), Assign \"y\" (Var \"x\"), Eq (Var \"y\") (Num 1)) true > test 1 (Eq (Var \"x\") (Num 1), Assign \"y\" (Var \"x\"), Eq (Var \"y\") (Num 2)) false Formal Methods and Functional Programming, Final Exam, 2023 20 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2023 21 Assignment 6: Linear Temporal Logic (18 Points) Consider the transition system depicted below, which models an elevator traveling between three floors: E, F, and G. To travel to a different floor the user has to press the button for that floor. We use the uppercase atomic propositions E, F , and G to indicate that the elevator is at the respective floor, and the lowercase atomic propositions e, f , and g to indicate that the button for the respective floor is active. The system starts in state s0 at floor E where the user can press either the f button (to request floor F ) or the g button (to request floor G ). The button for the current floor can never become active. The transition system has been simplified such that not all buttons can be pressed in all states (e.g. no button can be pressed at floor G ). Note that in states s2 and s6 two buttons are active simultaneously. s0 {E } s1 {E, f } s2 {E, f, g} s3 {E, g} s4 { F } s5 { F, g} s6 {e, F, g} s7 { G} Task 6.A (6 Points) For each of the following LTL formulas, state whether or not the property holds in the given transition system. Justify your answer by either briefly explaining why it holds or providing a counterexample if it does not. i) ⃝□¬E Formal Methods and Functional Programming, Final Exam, 2023 22 ii) ♢(g U G) iii) (♢□G) ∨ (□¬G) Task 6.B (6 Points) The landlord wants to check some properties about their elevator using LTL and the transition system above. Concretely, they ask you to write down an LTL formula for each of the following properties. i) The elevator can never get stuck between floors. ii) If the g button is ever pressed then it will not turn off unless floor G is reached. iii) The elevator starts at floor E and if the elevator never stops at floor F it will reach floor G in two steps. Formal Methods and Functional Programming, Final Exam, 2023 23 Task 6.C (6 Points) Impressed, the landlord now wants to learn more about LTL. She asks you to provide three LTL formulas. The formulas must hold for the transition system above. The first should be a safety property, the second a liveness property and the third neither of the two. You do not need to justify your answer. Hint: You may use the formulas from the previous tasks. i) Safety property: ii) Liveness property: iii) Neither safety nor liveness property: Formal Methods and Functional Programming, Final Exam, 2023 24 Assignment 7: Peano numbers (18 Points) Peano numbers are a unary encoding of natural numbers that uses only two symbols Zero, meaning zero, and Suc (“successor”), meaning the natural number immediately following another natural number. The Peano number for 1 is Suc Zero, the Peano number for 2 is Suc Suc Zero, the Peano number for 3 is Suc Suc Suc Zero, etc. In Haskell, the type of Peano numbers can be defined as data Nat = Zero | Suc Nat Consider the following function, which implements a minimum function for Peano numbers: pmin :: Nat -> Nat -> Nat pmin Zero _ = Zero -- pmin.1 pmin _ Zero = Zero -- pmin.2 pmin (Suc p) (Suc q) = Suc (pmin p q) -- pmin.3 Task 7.A (10 Points) Show that the pmin function is commutative, i.e., ∀p, q : Nat. pmin p q = pmin q p. Hint: By induction on p. Distinguish cases q = Zero and q = Suc q′. For each rewrite step, mention the equation you are using. Formal Methods and Functional Programming, Final Exam, 2023 25 This page is intentionally left blank. Formal Methods and Functional Programming, Final Exam, 2023 26 Task 7.B (8 Points) Alice defines the following functions, where min is the standard Haskell minimum function: nat_of_int :: Integer -> Nat nat_of_int 0 = Zero nat_of_int i = Suc (nat_of_int (i-1)) int_of_int :: Integer -> Integer int_of_int i | i <= 0 = i | otherwise = 1 + (int_of_int (i-1)) f i = pmin (nat_of_int i) (nat_of_int 42) g i = min (int_of_int i) (int_of_int 42) She observes that f is much faster than g when i becomes large. What feature of Haskell causes this? Briefly explain what happens by writing down a few steps of the evaluation. Provide a short textual explanation (a few sentences). Formal Methods and Functional Programming, Final Exam, 2023 27 Syntax and Semantics of IMP Syntax The statements (Stm) of the programming language IMP are given by the grammar s ::= skip | x := e | s;s | if b then s else s end | while b do s end where x ranges over variables (Var), e ranges over arithmetic expressions (Aexp), and b ranges over boolean expressions (Bexp). The free variables FV(e) of an arithmetic expression e are defined as FV(e1 op e2) = FV(e1) ∪ FV(e2) FV(n) = ∅ FV(x) = {x} The free variables FV(s) of a statement s are defined as FV(skip) = ∅ FV(x:=e) = {x} ∪ FV(e) FV(s1;s2) = FV(s1) ∪ FV(s2) FV(if b then s1 else s2 end) = FV(b) ∪ FV(s1) ∪ FV(s2) FV(while b do s end) = FV(b) ∪ FV(s) Big-Step Semantics (SkipN S) ⟨skip, σ⟩ → σ (AssN S) ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ → σ′ ⟨s2, σ′⟩ → σ′′ (SeqN S) ⟨s1;s2, σ⟩ → σ′′ ⟨s1, σ⟩ → σ′ (IfTN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = tt ⟨s2, σ⟩ → σ′ (IfFN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ if B[[b]]σ = ff ⟨s, σ⟩ → σ′ ⟨while b do s end, σ′⟩ → σ′′ (WhTN S) ⟨while b do s end, σ⟩ → σ′′ if B[[b]]σ = tt (WhFN S) ⟨while b do s end, σ⟩ → σ if B[[b]]σ = ff Formal Methods and Functional Programming, Final Exam, 2023 28 Small-Step Semantics (SkipSOS) ⟨skip, σ⟩ →1 σ (AssSOS) ⟨x := e, σ⟩ →1 σ[x ↦→ A[[e]]σ] ⟨s1, σ⟩ →1 σ′ (Seq1SOS) ⟨s1;s2, σ⟩ →1 ⟨s2, σ′⟩ ⟨s1, σ⟩ →1 ⟨s′ 1, σ′⟩ (Seq2SOS) ⟨s1;s2, σ⟩ →1 ⟨s′ 1;s2, σ′⟩ (IfTSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s1, σ⟩ if B[[b]]σ = tt (IfFSOS) ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s2, σ⟩ if B[[b]]σ = ff (WhileSOS) ⟨while b do s end, σ⟩ →1 ⟨if b then s; while b do s end else skip end, σ⟩ Axiomatic Semantics (Partial Correctness) (SkipAx) { P } skip { P } (AssAx) { P[x ↦→ e] } x := e { P } { P } s1 { R } { R } s2 { Q } (SeqAx) { P } s1;s2 { Q } { b ∧ P } s1 { Q } { ¬b ∧ P } s2 { Q } (IfAx) { P } if b then s1 else s2 end { Q } { b ∧ P } s { P } (WhAx) { P } while b do s end { ¬b ∧ P } { P ′ } s { Q′ } (ConsAx) { P } s { Q } if P ⊨ P′ and Q′ ⊨ Q Axiomatic Semantics (Total Correctness) Rules are as for partial correctness above, except for the following rule, which replaces WhAx: { b ∧ P ∧ e = Z } s { ⇓ P ∧ e < Z } (WhTotAx) { P } while b do s end { ⇓ ¬b ∧ P } if b ∧ P ⊨ 0 ≤ e where Z is a fresh logical variable (not used in P).","libVersion":"0.5.0","langs":""}