{"path":"sem4/FMFP/UE/s/FMFP-u11-s.pdf","text":"P. M¨uller, D. Basin and R. Jung Formal Methods and Functional Programming Exercise Sheet 11: Small-Step Semantics Submission deadline: May 13th/14th, 2025 Assignment 1 (Applying Small-Step Semantics) Consider the following IMP statement s: while n # 0 do a := a+n; (b := b*n; n := n-1) end Task. Let σ be a state such that σ(a) = 0, σ(b) = 1, and σ(n) = 2. Prove using the structural operational semantics that there is a state σ′ with σ′(a) = 3, σ′(b) = 2, and σ′(n) = 0 such that ⟨s, σ⟩ → ∗ 1 σ′. Provide the complete derivation sequence, and show the derivation trees of the first three single- step transitions. 1 Solution. Let s’ be the body of the loop. ⟨s, σ⟩ →1 1 ⟨if n # 0 then s’; s else skip end, σ⟩ →1 1 ⟨(a := a+n; (b := b*n; n := n-1)); s, σ⟩ →1 1 ⟨(b := b*n; n := n-1); s, σ[a ↦→ 2]⟩ →1 1 ⟨n := n-1; s, σ[a, b ↦→ 2, 2]⟩ →1 1 ⟨s, σ[a, b, n ↦→ 2, 2, 1]⟩ →1 1 ⟨if n # 0 then s’; s else skip end, σ[a, b, n ↦→ 2, 2, 1]⟩ →1 1 ⟨(a := a+n; (b := b*n; n := n-1)); s, σ[a, b, n ↦→ 2, 2, 1]⟩ →1 1 ⟨(b := b*n; n := n-1); s, σ[a, b, n ↦→ 3, 2, 1]⟩ →1 1 ⟨n := n-1; s, σ[a, b, n ↦→ 3, 2, 1]⟩ → 1 1 ⟨s, σ[a, b, n ↦→ 3, 2, 0]⟩ → 1 1 ⟨if n # 0 then s’; s else skip end, σ[a, b, n ↦→ 3, 2, 0]⟩ →1 1 ⟨skip, σ[a, b, n ↦→ 3, 2, 0]⟩ →1 1 σ[a, b, n ↦→ 3, 2, 0] The first three single-step transitions are justified by the following three derivation trees: (WhileSOS) ⟨s, σ⟩ →1 ⟨if n # 0 then s’;s else skip end, σ⟩ (IfTSOS) ⟨if n # 0 then s’;s else skip end, σ⟩ →1 ⟨(a := a + n;(b := b ∗ n;n := n − 1));s, σ⟩ Where the side condition for IfTSOS namely B[[n # 0]]σ = tt holds. (AssSOS) ⟨a := a + n, σ⟩ →1 σ[a ↦→ 2] (Seq1SOS) ⟨a := a + n;(b := b ∗ n;n := n − 1), σ⟩ →1 ⟨(b := b ∗ n;n := n − 1), σ[a ↦→ 2]⟩ (Seq2SOS) ⟨(a := a + n;(b := b ∗ n;n := n − 1));s, σ⟩ →1 ⟨(b := b ∗ n;n := n − 1);s, σ[a ↦→ 2]⟩ Assignment 2 (Equivalence Lemmas) In this exercise, we prove the two lemmas from the lecture that formalize the equivalence of small-step and big-step semantics. Hint: You might want to consider using results from the lecture. Task 2.1 Prove the first equivalence lemma (cf. slide 138): ∀σ, σ′, s· ⊢ ⟨s, σ⟩ → σ′ =⇒ ⟨s, σ⟩ → ∗ 1 σ′ 2 Solution. We define P (T ) ≡ ∀σ, σ′, s · (root(T ) ≡ (⟨s, σ⟩ → σ′) =⇒ ⟨s, σ⟩ → ∗ 1 σ′) and prove ∀T · P (T ) by strong induction on the shape of the derivation tree T. Thus, for some arbitrary T, we get as induction hypothesis ∀T ′ ⊏ T · P (T ′), and need to prove P (T ). Let σ, σ′, s be arbitrary. We assume root(T ) ≡ (⟨s, σ⟩ → σ′) and prove ⟨s, σ⟩ → ∗ 1 σ′. The proof proceeds by case splitting on the last rule applied in T . • Case AssNS: Then T is of the form: ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] (AssN S) for some x, e such that s ≡ x := e and σ′ = σ[x ↦→ A[[e]]σ]. Now we can construct a derivation tree to justify ⟨s, σ⟩ → 1 1 σ′: ⟨x := e, σ⟩ →1 σ[x ↦→ A[[e]]σ] (AssSOS) • Case SkipNS: Analogous to AssNS. • Case WhFNS: Then T is of the form ⟨while b do s′ end, σ⟩ → σ (WhFN S) for some b, s′ such that s ≡ while b do s′ end, σ′ = σ and B[[b]]σ = ff . We conclude with the following derivation sequence: ⟨while b do s′ end, σ⟩ → 1 1 ⟨if b then s′;while b do s′ end else skip end, σ⟩ → 1 1 ⟨skip, σ⟩ → 1 1 σ The second transition is justified by IfFSOS, since B[[b]]σ = ff . • Case SeqNS: Then T is of the form AA AA \u0001 \u0001 \u0001\u0001 T1 ⟨s1, σ⟩ → σ′′ A A AA \u0001 \u0001 \u0001\u0001 T2 ⟨s2, σ′′⟩ → σ′(SeqN S) ⟨s1; s2, σ⟩ → σ′ for some s1, s2, σ′′, T1, T2, such that s ≡ s1; s2. We apply the IH twice. From P (T1) we learn ⟨s1, σ⟩ →∗ 1 σ′′ and from P (T2) we learn ⟨s2, σ′′⟩ → ∗ 1 σ′. ⟨s1, σ⟩ → ∗ 1 σ′′ gives us ⟨s1, σ⟩ → k 1 σ′′ for some k. We can apply the results from Assignment 3 (optional exercises) on ⟨s1, σ⟩ → k 1 σ′′ to get ⟨s1; s2, σ⟩ → k 1 ⟨s2, σ′′⟩. We conclude this case with the following derivation sequence: ⟨s1; s2, σ⟩ → ∗ 1 ⟨s2, σ′′⟩ → ∗ 1 σ′ 3 • Case IfTNS: Then T is of the form AA AA \u0001 \u0001 \u0001\u0001 T3 ⟨s1, σ⟩ → σ′ (IfTN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ for some b, s1, s2, T3, such that s ≡ if b then s1 else s2 end and B[[b]]σ = tt. From P (T3) we learn ⟨s1, σ⟩ → ∗ 1 σ′. We conclude this case with the following derivation sequence: ⟨if b then s1 else s2 end, σ⟩ → 1 1 ⟨s1, σ⟩ → ∗ 1 σ′ The first transition is justified by IfTSOS, since B[[b]]σ = tt. • Case IfFNS: Analogous to IfTNS. • Case WhTNS: Then T is of the form A AAA \u0001 \u0001 \u0001\u0001 T4 ⟨s′, σ⟩ → σ′′ AA AA \u0001 \u0001 \u0001\u0001 T5 ⟨while b do s′ end, σ′′⟩ → σ′ (WhTN S) ⟨while b do s′ end, σ⟩ → σ′ for some b, s ′, σ′′, T4, T5, such that s ≡ while b do s′ end and B[[b]]σ = tt. We apply (IH) twice. From P (T4) we learn ⟨s′, σ⟩ → ∗ 1 σ′′. From P (T5) we learn ⟨while b do s′ end, σ′′⟩ →∗ 1 σ′. ⟨s′, σ⟩ →∗ 1 σ′′ gives us ⟨s′, σ⟩ →k 1 σ′′ for some k. We can apply the result of Assignment 3 (optional exercises) on it to get ⟨(s′; while b do s′ end), σ⟩ → k 1 ⟨while b do s′ end, σ′′⟩. We conclude this case with the following derivation sequence: ⟨while b do s′ end, σ⟩ → 1 1 ⟨if b then (s′; while b do s′ end) else skip, σ⟩ → 1 1 ⟨(s′; while b do s′ end), σ⟩ → ∗ 1 ⟨while b do s′ end, σ′′⟩ → ∗ 1 σ′ The second transition is justified by IfTSOS, since B[[b]]σ = tt. 4 Task 2.2 Prove the second equivalence lemma (cf. slide 139): ∀σ, σ′, s, k · ⟨s, σ⟩ → k 1 σ′ =⇒ ⊢ ⟨s, σ⟩ → σ′ Solution. We define Q(k) ≡ ∀σ, σ′, s · ⟨s, σ⟩ → k 1 σ′ =⇒ ⊢ ⟨s, σ⟩ → σ′ and prove ∀k · Q(k) by strong mathematical induction on k. For arbitrary k assume ∀k′ < k · Q(k′) and prove Q(k). Let σ, σ′, s be arbitrary. Case splitting on the condition k > 0 immediately proves the case for k = 0 (the assumptions lead to ⟨s, σ⟩ → 0 1 σ′, which is a contradiction). So we are left with case k > 0. Assume ⟨s, σ⟩ →k 1 σ′ and prove ⊢ ⟨s, σ⟩ → σ′. We unroll the derivation sequence once to ⟨s, σ⟩ →1 1 γ → k−1 1 σ′. Let T be the derivation tree which justifies the first transition. We inspect the last rule applied to T . • Case AssSOS: Then T is of the form ⟨x := e, σ⟩ →1 σ[x ↦→ A[[e]]σ] (AssSOS) for some x, e such that s ≡ x := e and γ = σ[x ↦→ A[[e]]σ]. Since γ is a final state there is no further derivation sequence (k = 1), and hence σ′ = γ = σ[x ↦→ A[[e]]σ]. Now we can construct a derivation tree for ⟨x := e, σ⟩ → σ′: ⟨x := e, σ⟩ → σ[x ↦→ A[[e]]σ] (AssN S) • Case SkipSOS: Similar to AssSOS, we apply the corresponding NS rule and are done. • Case Seq1SOS, Seq2SOS: Then we must have root(T ) ≡ ⟨s1; s2, σ⟩ →1 γ and hence ⊢ ⟨s1; s2, σ⟩ →1 γ for some statements s1, s2, such that s ≡ s1; s2. Returning to our original assumption, we apply the lemma proven on the lecture slides on ⟨s1; s2, σ⟩ → k 1 σ′. We get ⟨s1, σ⟩ → k1 1 σ′′ and ⟨s2, σ′′⟩ → k2 1 σ′, for some σ′′, k1, k2, such that k1 + k2 = k. Note that k1 ̸= 0 and k2 ̸= 0 (otherwise, by the definition of → 0 1 we would have to have a non-final configuration equal to a state, e.g. ⟨s1, σ⟩ ≡ σ′′, which is impossible). Therefore, we must have k1 < k and k2 < k. Since k1, k2 < k we can apply the IH twice. From Q(k1) we learn ⊢ ⟨s1, σ⟩ → σ′′ and from Q(k2) we learn ⊢ ⟨s2, σ′′⟩ → σ′. Let T1, T2 be the corresponding derivation trees, such that root(T1) ≡ ⟨s1, σ⟩ → σ′′ and root(T2) ≡ ⟨s2, σ′′⟩ → σ′ Now we can construct the derivation tree for ⊢ ⟨s1; s2, σ⟩ → σ′ as follows: 5 AA AA \u0001 \u0001 \u0001\u0001 T1 ⟨s1, σ⟩ → σ′′ A A AA \u0001 \u0001 \u0001\u0001 T2 ⟨s2, σ′′⟩ → σ′(SeqN S) ⟨s1;s2, σ⟩ → σ′ • Case IfTSOS: Then T is of the form ⟨if b then s1 else s2 end, σ⟩ →1 ⟨s1, σ⟩ (IfTSOS) for some b, s1, s2, such that s ≡ if b then s1 else s2 end and B[[b]]σ = tt. Therefore the unrolled derivation sequence is of the form: ⟨if b then s1 else s2 end, σ⟩ → 1 1 ⟨s1, σ⟩ → k−1 1 σ′ We apply the IH to the tail sequence, and get root(T3) ≡ ⟨s1, σ⟩ → σ′ for some derivation tree T3, which enables us to conclude this case by constructing the derivation tree: AA AA \u0001 \u0001 \u0001\u0001 T3 ⟨s1, σ⟩ → σ′ (IfTN S) ⟨if b then s1 else s2 end, σ⟩ → σ′ The side condition is fulfilled since we know B[[b]]σ = tt. • Case IfFSOS: Analogous to IfTSOS. • Case WhileSOS: Then T is of the form ⟨while b do s′ end, σ⟩ →1 γ (WhileSOS) for some b, s ′, γ, such that γ = ⟨if b then s′; while b do s′ end else skip end, σ⟩ and s ≡ while b do s′ end. Therefore the unrolled derivation sequence is of the form: ⟨while b do s′ end, σ⟩ → 1 1 ⟨if b then s′; while b do s′ end else skip end, σ⟩ → k−1 1 σ′ We apply the IH to the tail sequence, and get ⊢ ⟨if b then s′; while b do s′ end else skip end, σ⟩ → σ′. From the semantic equivalence shown in the lecture (Slide Deck 3, section 3.1.2), we get ⊢ ⟨while b do s′ end, σ⟩ → σ′, which concludes this case. 6 Note: We can also “manually” conclude this case, i.e. not use the semantic equivalence. This requires a case split on which branch of the if-statement is taken, and some decom- posing and recomposing of the resulting derivation tree. 7","libVersion":"0.5.0","langs":""}