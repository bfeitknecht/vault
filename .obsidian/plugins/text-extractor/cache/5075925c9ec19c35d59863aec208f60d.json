{"path":"var/export/A&D-bf-u11.pdf","text":"11.1 Multiplicative Weight Shortest Path Since all edge weights are positive, ∀e ∈ E : we ≥ 1, the application of dijkstra's algorithm as a subroutine is feasible. To guarantee the correctness of the algorithm the multiplicative weight shortest path problem is transformed to an additive variant. Speciﬁcally the algorithm functions as follows. The correctness of the approach described above is given by the following. Let P be an s ⇝ t path in G. Since the runtime of dijkstra's algorithm is O((n + m)log n), which dominates the logarithm and exponentiation operations, the desired runtime bounds is achieved. □ 1. Compute logarithm of all edge weights, speciﬁcally ∀e ∈ E : w′ e = ln(we) 2. Run dijkstra's algorithm on the graph G with the modiﬁed weights, returns array dist of shortest paths to v ∈ V 3. Return exp(dist[t]) ln (∏ e∈P we) = dist[t] ∑ e∈P ln(we) w′ e (monotonicity, logarithmic property) ∏ e∈P we = exp(dist[t]) 11.2 Rotating Weights Since the edge weights can be negative but it is not possible to construct a negative cycle, bellman-ford's algorithm is applicable to ﬁnd the shortest rotating weights path P = v0 ⇝ v1. Construct a modiﬁed graph G′ = (V ′, E ′) as follows, where a layer corresponds to a unique time step equivalence class. Let ⊕ denote addition modulo n. Proof of correctness. To show is that the following holds. Algorithm returns P ⟺ P  is shortest rotating weight path in G Assume that our algorithm returns P . Then, by the correctness of the bellman ford algorithm, it holds that P is the shortest v0 ⇝ v1 path in G. Then assume some P is the shortest such path in G. As there are no negative cycles, the bellman-ford algorithm terminates and our algorithm returns P . Hence the correctness of our algorithm is proven. The runtime is given by bellman ford, which runs in O(nm). Substituting for the number of vertices and edges in the modiﬁed Graph G′ = (V ′, E ′) then results in the desired runtime. As there are originally |V | = n vertices and we construct n variants corresponding to the rotation equivalence classes for each, |V ′| = n2. As there are |V × V | = n2 vertex pairs in the original graph and we construct n edges corresponding to the rotation time equivalence classes, the number of edges is |E ′| = n3. Thus the described algorithm is bounded by O(n5). □ 1. V ′ = V × [n], vertices in diﬀerent layers of the form (v, t), where v ∈ V and t ∈ [n] 2. E ′ = V × V × [n], edges between vertices in neighboring layers, (vi, vj, t) where vi, vj ∈ V and t ∈ [n], alternatively understood as (v′ i, v′ j) ∈ E ′ with v′ i = (vi, t) and v′ j = (vj, t ⊕ 1), edge weights are given by ct({vi, vj}) = c0({vi⊕ t, vj⊕ t}) 11.4 Rail Racer (b) The runtime of the algorithm is O((n + m)log n), given by dijkstra's algorithm, where n = |V | and m = |E| with the vertex set and edge set as described above. The correctness is given by the fact that the edge weights denote the travel time for that 10km stretch and dijkstra's algorithm returns the shortest path which in this case corresponds to the shortest travel time path from Zurich to Zermatt. □ 1. Model the problem as an undirected weighted graph G = (V , E), where every station and checkpoint is a vertex and the connections between stations (and checkpoints) are edges with weight equal to the time it takes to traverse that connection while respecting the speed limit, formally for e = {u0, u1} the weight is given by we = c/(v0 + v1), where v0, v1 denotes the speed limits at u0, u1 for some positive integer c 2. Solve the problem by ﬁnding the shortest path in the graph between vertices Zurich and Zermatt 3. Apply dijkstra's algorithm with no modiﬁcations since there are no negative cycles as all edge weights are positive with s = Zurich and t = Zermatt, return dist[t]","libVersion":"0.5.0","langs":""}