{"path":"sem3/EProg/PV/exams/program/HS21-a.pdf","text":"Herbst 2021/22 – A 252-0027 – Einführung in die Programmierung Departement Informatik ETH Zürich 27. Januar 2022 – Programmieren Nachname: Vorname: Legi-Nummer: – – Computer: slab Sie dürfen diese Prüfung oder die schriftliche Prüfung erst öﬀnen nachdem die Aufsicht die Prüfung gestartet hat. Wenn Sie diese Dokumente vorher öﬀnen gilt dies als Täuschungsversuch. Mit Ihrer Unterschrift bestätigen Sie, dass Sie die hier aufgeführte Person sind, Sie die Hinweise zur Kenntnis genommen haben, Sie die Aufgaben selbständig bearbeitet haben, Sie Ihre eigene Lösung abgeben, Sie keine Kopie der Prüfung mitnehmen, Sie alle technischen Probleme und etwaige störende äussere Einﬂüsse gemeldet haben bzw. wissen, dass Sie diese melden sollen, und dass Sie keine gesundheitlichen Probleme hatten, die Ihre Leistungen in dieser Prüfung beeinträchtigten. Unterschrift: Hinweise 1. Bitte schreiben Sie Ihren Namen und Legi-Nummer sowie die Nummer ihres Computers (ﬁnden Sie auf dem Computer) auf diese Seite. Vergessen Sie nicht die Unterschrift am Ende der Prüfung. 2. Während der Programmierprüfung dürfen Sie nicht mehr an der schriftlichen Prüfung weiterarbeiten, auch wenn diese noch nicht eingezogen worden ist. Dies gilt als Täuschungsversuch. 3. Beachten Sie bitte während und nach der Prüfung unbedingt die Hygienevorschriften. 4. Die Prüfung hat 10 Seiten. Vergewissern Sie sich dass Ihr Exemplar vollständig ist. Die letzten zwei Seiten können Sie für Skizzen o.ä. benutzen, aber diese werden nicht für die Benotung hinzugezogen. 5. Die Programmierprüfung dauert 2 Stunden (120 Minuten). Falls Sie sich durch irgendjemanden oder irgendetwas gestört fühlen, oder technische Probleme an Ihrem Computer auftreten, so melden Sie dies sofort der Aufsicht. (Falls es unerwartete Fehlermeldungen gibt: Lassen Sie solche Fehlermeldungen oder PopUp Nachrichten auf dem Bildschirm und informieren Sie die Aufsicht. Nur so verhindern Sie, dass durch Systemfehler Ihre Programme verändert werden. ) Sollten Sie durch die Behandlung eines technischen Problems Zeit verlieren, so werden Sie die verlorene Zeit nachholen können. 6. Wir beantworten keine inhaltlichen Fragen während der Prüfung. 7. Lesen Sie die Aufgabenstellungen genau durch. Es ist wichtig, dass Ihre Antworten den Anforderungen der Aufgaben genau entsprechen. Wenn die Aufgabenstellung etwas nicht speziﬁert dann können Sie frei entscheiden (wir testen nur was wir speziﬁzieren). Class.name() heisst Methode name() in Klasse Class. 8. Benutzen Sie die Anzahl der Sterne in der Programmierprüfung als Hinweis, der ungefähr den Aufwand und die erreichbare Punktzahl der Aufgabe widerspiegelt. Je mehr Sterne, desto aufwändiger. Eine gut gelöste Aufgabe gibt mehr Punkte als zwei halb gelöste Aufgaben mit der selben Anzahl Sterne. 9. Für jede Aufgabe gibt es ein separates Java-Projekt in Ihrem Eclipse-Workspace. 10. Die Programmieraufgaben werden vorwiegend automatisch getestet und bewertet. Programme, welche nicht mindestens teilweise ein korrektes Resultat zurückgeben (oder gar nicht erst kompilieren), erhalten keine Punkte. 11. Stellen Sie regelmässig sicher, dass Ihre Dateien im Workspace gespeichert sind. Nur diese Dateien werden von einem Backup-Prozess während der Prüfung gespeichert. Was nicht gespeichert ist, kann nicht bewertet werden. 12. Sollten Sie eine Ihrer Lösungsdateien überschreiben, so kann die Aufsicht Ihnen helfen! Melden Sie sich sofort. 13. Ändern Sie unter keinen Umständen die Signaturen der im Aufgabentext erwähnten Methoden (Name, Typ und Reihenfolge der Parameter), ihren Rückgabetyp, Modiﬁzierer wie static, public oder gegebenfalls die Liste der geworfenen Exceptions. Das gleiche gilt für Konstruktoren und Attribute. Auch die Namen der erwähnten Klassen dürfen Sie nicht ändern und auch nicht Interfaces in Klassen umwandeln. Solche Änderungen können dazu führen, dass Sie keine Punkte für die Aufgabe erhalten. Wenn nicht anders vermerkt, dürfen Sie Methoden, Attribute, Interfaces oder Klassen zu den vorhandenen hinzufügen oder Klassen und Interfaces importieren. Die Verwendung von Java Reﬂection ist nicht erlaubt (und auch nicht von Vorteil). 14. Das Verwenden von static-Attributen ist grundsätzlich falsch. Rechnen Sie damit, dass wir das abgegebene Programm mehrfach ausführen (und ein Test selber aus mehreren Methodenaufrufen bestehen kann), ohne dass static-Attribute neu initialisiert werden. Lösungen, welche static-Attribute verwenden, und nur funktionieren, wenn ein Programm/eine Methode nur ein Mal ausgeführt wird, können potenziell 0 Punkte bekommen. 15. In jedem Projekt gibt es neben dem “src”-Ordner einen “test”-Ordner mit einigen JUnit-Tests. Wir empfehlen, diese mit ihren eigenen Tests zu erweitern. Tests werden nicht bewertet. 16. Falls gewisse Tests beim Ausführen scheinbar keine Resultate liefern, könnte es daran liegen, dass Ihre Lösung eine Endlosschleife enthält. Stoppen Sie in diesem Fall die Tests von Hand (siehe weitere Hinweise zu Eclipse weiter unten). 17. Als zusätzliche Sicherheitsmassnahme wird Ihr Bildschirm während der Prüfung aufgezeichnet. 18. Wenn Sie in der IDE Zeichen ersetzen statt einfügen, dann drücken Sie die Insert Taste (über der Delete Taste). 19. Auf einer Schweizer Tastatur schreiben Sie eckige und geschweifte Klammern durch Alt + Ctrl + die entsprechende Taste links neber der Enter Taste. 20. Wenn Sie zur Toilette müssen, melden Sie dies einer Aufsichtsperson durch Handzeichen. Es darf zur gleichen Zeit immer nur eine Person zur (Unisex)Toilette. 21. Wenn Sie früher abgeben wollen, sperren Sie bitte Ihren Computer und melden Sie sich bitte lautlos. Die Aufsicht wird Ihnen sagen, wann Sie Ihren Arbeitsplatz verlassen können. Vorzeitige Abgaben sind nur bis 20 Minuten vor Prüfungsende möglich. 22. Wenn die Aufsicht die Prüfung beendet, vergewissern Sie sich, dass alle Dateien gespeichert sind. Nach der Sperrung der Computer können Sie keine weiteren Änderungen mehr vornehmen. Befolgen Sie bitte die Anweisungen der Aufsicht (gestaﬀeltes Verlassen des Prüfungslokals). 23. Verlassen Sie bitte den Prüfungsraum leise nach der Prüfung. Es kann sein, dass andere Studierende noch weiterar- beiten da sie eine Zeitgutschrift bekommen haben. Auch diese Studierenden sollen in Ruhe arbeiten können. Bitte lassen Sie unbedingt die unterschriebene Aufgabenstellung auf Ihrem Tisch - wir sammeln diese später ein. Page 2 of 10 Anmelden und Eclipse starten 1. Sobald die Programmierprüfung startet, können Sie sich an Ihrem Computer anmelden. Geben Sie zuerst Ihren vollen Namen und im nächsten Schritt Ihren NETHZ-Namen und Ihre Legi-Nummer ein. (Sie brauchen nicht Ihr NETHZ-Passwort.) Sie werden auch in einem weiteren Fenster darauf hingewiesen, dass Ihr Computer aufgezeichnet wird, und dass Sie technische Probleme sofort melden müssen. Sobald Sie angemeldet sind, erscheint ein Browsertab mit allgemeinen Hinweisen zur Computer-Prüfung. 2. Starten Sie Eclipse, indem Sie oben links auf “Activities” (oder “Aktivitäten”) klicken und dann im Suchfeld “Eclipse” eingeben. Wählen Sie “Eclipse” (nicht “Eclipse C/C++”). Warten Sie, bis Eclipse gestartet ist. Dies kann einige Minuten in Anspruch nehmen. 1 2 3 3. Wenn sich das Fenster “Eclipse Launcher” öﬀnet, stellen Sie sicher, dass der richtige Prüfungs-Workspace ausgewählt ist. Im Feld “Workspace” sollte folgender Pfad stehen, bevor Sie auf “Launch” klicken: /var/lib/exam/student/questions Falls dies nicht der Fall ist, klicken Sie auf “Browse...” und wählen Sie dann im Auswahldialog den “questions”-Ordner aus. Klicken Sie oben rechts auf “OK” und dann unten auf “Launch”. 4. Nachdem der Workspace geöﬀnet wurde, erscheint ein Migration Wizard. Klicken Sie “Cancel” und bestätigen Sie dann mit “Yes”. Wenn Eclipse fertig gestartet ist, sehen Sie den Willkommens-Bildschirm. Klicken Sie wenn nötig oben rechts auf “Workbench”. Nun sollten Sie links die zwei Projekte “Aufgabe 1” und “Aufgabe 2” sehen. Es kann einige Minuten dauern bis Eclipse alles geladen hat. Warten Sie bis die Ladenachricht “Initializing Java Tooling” (unten rechts in Eclipse) nicht mehr sichtbar ist. Ausserdem können Sie allgemeine Hinweise zur Computer-Prüfung lesen, indem Sie oben links auf die “Activities” gehen und auf das Informationsicon klicken. Viel Spass! 1 2 Hinweise zu Eclipse Verhindern von Abstürzen Bevor Sie ein Programm oder einen Test ausführen, achten Sie darauf, dass alle anderen Programme und Tests korrekt terminiert wurden. Wenn zu viele Programme gleichzeitig laufen, dann wird Ihr Computer langsamer, manchmal einfrieren, und im schlimmsten Fall abstürzen. Auch verhält sich dann manchmal Eclipse oder der Debugger unnatürlich. Das geht von Ihrer Zeit ab. Ein Problem ist, dass, auch wenn die aktive Konsole mit terminiert wurde und somit ausgegraut ist ( ), es noch weitere Konsolen geben kann, welche immer noch laufen. Wenn das Icon vorhanden und nicht ausgegraut ist ( ), dann gibt es mehr als eine Konsole, was auch heisst, dass mehrere Programme oder Tests noch nicht terminiert sein können: Durch einen Klick auf den Pfeil von , wird eine Liste aller vorhandenen Konsolen angezeigt: Durch klicken von werden alle terminierten Konsolen geschlossen. Klicken Sie wiederholt und (oder ) bis ausgegraut oder verschwunden ist, um alle Programme und Tests zu terminieren und alle Konsolen zu schliessen. Javadoc Es gibt verschiedene Möglichkeiten die Java Dokumentation zu öﬀnen. Eine komfortable Option ist den Javadoc View zu verwenden. Dieser sollte in einer der Tabs bei der Konsole zu sehen sein ( ). Falls der Tab nicht vorhanden ist, oder falls Sie den Tab einfach nicht ﬁnden, dann können Sie durch das drücken von Alt + Shift + Q und dann J den Tab öﬀnen. Alternativ können Sie auch im Quick Access Fenster (ganz oben rechts ) “Javadoc” eingeben und dann oder drücken. Wenn Sie den Javadoc View geöﬀnet haben, dann wird Ihnen die verfügbare Dokumentation von allem gezeigt das Sie anklicken. Zusätzlich, wenn Sie auf etwas zeigen, während Sie die Ctrl Taste gedrückt haben, dann können Sie sich die Declaration anzeigen lassen: Debugger Ob Sie den Debugger verwenden ist Ihre Entscheidung. Wir werden keine Fragen zum Debugger beantworten. Die Aufgaben sind auch gut ohne Debugger lösbar. Um in den Debugging Modus zu wechseln, klicken Sie den Debugger Knopf rechts neben dem Quick Access Fenster (ganz oben rechts ). Falls dieser Knopf nicht vorhanden ist, dann können Sie im Quick Access Fenster (ganz oben rechts ) “Debug” eingeben und dann drücken. Alternativ können Sie auch den Knopf direkt neben dem Quick Access Fenster drücken und dann “Debug” wählen . Page 4 of 10 [Diese Seite ist leer.] Page 5 of 10 Aufgabe 1 (⋆⋆) In dieser Augabe implementieren Sie zwei morphologische Operationen auf einem = × = Grid von Biomen (Arten von Landschaften), wobei immer = ≥ 2 gilt. Es gibt zwei Arten von Biomen: Flachland und Wasser. Jedes Biom hat eine Floradiversität, welches ein Mass für die Pﬂanzendiversität ist und durch eine nicht-negative ganze Zahl (≥ 0) gemessen wird. Zusätzlich haben Flachlandbiome eine Höhe, welche als eine strikt positive ganze Zahl (> 0) angegeben wird. Im vorgegeben Programmskelett ist eine Klasse World gegeben und ein Interface Biom. Die Klasse World soll eine Repräsentation eines = × = Grid von Biomen speichern und darauf die morphologischen Operationen World.stepDryUp() und World.stepDistribute(int p) ausführen. Das Interface Biom repräsentiert Biome und schreibt drei Methoden vor: Biom.getFlora() (soll die Floradiversität zurückgeben), Biom.getHeight() (soll die Höhe bei Flachlandbiomen zurückgeben; beim Wasser muss immer 0 zurückgegeben werden), und Biom.getBiomType(), welche die Biomart als String zurückgibt. Die String-Repräsentation der Biomarten sind durch folgende Strings der Länge 1 deﬁniert: Biomart Wasser Flachland Biom.getBiomType() “W” “F” Konkrete Implementierungen von Biom für die unterschiedlichen Biomarten sind nicht gegeben und diese müssen Sie in den Unteraufgaben selber implementieren. Sie dürfen weitere Methoden zum Biom-Interface oder zur Klasse World hinzufügen (aber keine Methoden entfernen oder die Interfaces durch Klassen ersetzen). Der Entwurf der Klasse(n) und gegebenfalls weiterer Interfaces ist Ihnen überlassen. (a) (Ù) Vervollständigen Sie den Konstruktor World(String [] [] biomGrid), welcher als Input ein 2D- Array biomGrid nimmt. biomGrid gibt das = × = Startgrid von Biomen für das World-Objekt vor (= = biomGrid.length und = ≥ 2). biomGrid[i][j] gibt die String-Repräsentation der Biomart an Stelle (8, 9) an (0 ≤ 8, 9 < =). Die Floradiversität der Biome soll am Anfag für jedes Wasserbiom mit 15 und für jedes Flachlandbiom mit 12 initialisiert werden. Die Höhe der Flachlandbiome soll mit 3 initialisiert werden. Implementieren Sie zusätzlich die Methode World.getBiom(int x, int y), welche das Biom an Stelle (G, ~) vom Grid als Objekt vom Typ Biom zurückgibt. Im nächsten Teil der Aufgabe geht es darum morphologische Operationen stepDryUp() und stepDistribute(int p) in World zu implementieren, welche das Grid von World potenziell ändern (die Grösse des Grids bleibt jedoch gleich). Morphologische Operationen wandeln ein Grid ˝ in ein Grid ˝ ′ um. Sei ˝8,9 (bzw. ˝ ′ 8,9 ) das Biom an Stelle (8, 9) im Grid ˝ (bzw. ˝ ′). Dabei wird das neue Biom ˝ ′ 8,9 an Stelle (8, 9) immer nur abhängig vom alten Biom an Stelle (8, 9) (also ˝8,9 ) und den alten Nachbar-Biomen von ˝8,9 berechnet. Für stepDryUp() spielen die Nachbar-Biome keine Rolle. Für stepDistribute(int p) sind die Nachbar-Biome von ˝8,9 die Biome ˝8,9−: , ˝8,9+: , bzw. ˝8−:,9 und ˝8+:,9 für alle : mit 0 < : ≤ p. Das heisst, für p = 1 sind die Nachbar-Biome gegeben durch ˝8,9−1 und ˝8,9+1 [links und rechts daneben] und die Biome ˝8−1,9 und ˝8+1,9 [oben und unten]. Sie dürfen davon ausgehen, dass p ∈ {1, 2} gilt. Nur die Elemente des Grids, die wirklich existieren, spielen eine Rolle. Zum Beipiel sind für stepDistribute(1) die Nachbar-Biome von ˝0,0 immer nur ˝0,1 und ˝1,0 (da die Positionen (0, −1), (−1, 0) nicht existieren). Für stepDistribute(2) bei einem = × = Grid mit = ≥ 3 sind die Nachbar-Biome von ˝0,0 immer nur ˝0,1, ˝1,0, ˝0,2, ˝2,0. Bei stepDistribute(int p) hat ein Biom maximal 4p Nachbar-Biome. Tabelle 1 (unten) beschreibt für Wasserbiome wie man für die beiden Operationen die neuen Biome von den alten Biomen berechnet; Tabelle 2 (unten) beschreibt dies für Flachlandbiome. Bei stepDryUp berechnet man die neue Floradiversität eines Bioms (Diversität=4D) aus der alten Floradiversität des Bioms an der gleichen Position. Bei stepDistribute berechnet man die neue Floradiversität eines Bioms aus den alten Floradiversitäten der Nachbarbiome. Die neue Höhe (Höhe=4D) von Flachlandbiomen ist bei beiden Operation von der alten Höhe des Bioms an der gleichen Position abhängig (wobei bei stepDryUp ein Flachlandbiom in ein Wasserbiom umgewandelt werden kann). Page 6 of 10 Lösen Sie die Aufgaben b) und c) (⋆Ù). (b) Implementieren Sie die Methode World.stepDryUp()(siehe Tabellen). Beispiel: Angenommen ein Flachlandbiom hat vorher Floradiversität 5 und Höhe \u0011. Wenn \u0011 − 1 ≤ 0, dann wandelt sich das Biom in ein Wasserbiom mit Diversität 5 − 3 = 2. Wenn \u0011 − 1 > 0, dann bleibt das Biom ein Flachlandbiom, aber mit Diversität 5 − 3 = 2 und Höhe \u0011 − 1. (c) Implementieren Sie die Methode World.stepDistribute(int p) (siehe Tabellen), wobei p ∈ {1, 2}. Beispiel: Angenommen ein Flachlandbiom an Stelle (8, 9) hat vorher Höhe 8 und zusätzlich hat das Flachlandbiom zwei Flachlandnachbar-Biome und zwei Wassernachbar-Biome. Die Flachlandnachbarn haben Diversität 4 bzw. 5 und die Wassernachbarn haben Diversität 6 bzw. 7. Dann bleibt das Biom an Stelle (8, 9) ein Flachlandbiom, aber mit Diversität 4 + 5 + 6 + 7 = 22 und Höhe 8 + 2 = 10. Tests ﬁnden Sie in der Datei “BiomTest.java”. Beachten Sie, dass die “BiomTest.java” die Methode World.stepDistribute(int p) nur für p = 1 testet. Für die volle Punktzahl muss Ihre Implementierung auch für p = 2 funktionieren. Methode Floradiversität stepDryUp Diversität=4D = Max(Diversität0;C - 5, 0) stepDistribute Diversität=4D = Summe der Diversität0;C aller Nachbar-Biome Tabelle 1: Operationen für Wasserbiome. Ein Wasserbiom bleibt nach einer Operation immer ein Wasserbiom. Methode Floradiversität Höhe stepDryUp Diversität=4D = Max(Diversität0;C - 3, 0) Höhe=4D = Höhe0;C − 1 Wenn Höhe=4D = 0 dann verwandelt sich das Biom in ein Wasser Biom (mit Diversität=4D) stepDistribute Diversität=4D = Summe der Diversität0;C aller Nachbar-Biome Höhe=4D = Höhe0;C +(Anzahl Nachbar- Biome die Flachland sind) Tabelle 2: Operationen für Flachlandbiome. Nach einer stepDryUp Operation wandelt sich ein Flachlandbiom in ein Wasserbiom, wenn die alte Höhe 1 ist. In allen anderen Fällen bleibt ein Flachlandbiom nach einer Operation ein Flachlandbiom. Page 7 of 10 Aufgabe 2 (⋆⋆⋆) Ein Labyrinth besteht aus einer Menge von Räumen, welche durch die Klasse Room dargestellt werden. Die Klasse hat zwei Attribute: Der String name (nie null) beschreibt den Namen des Raums und der Array doorsTo (nie null) beschreibt die Türen von diesem Raum zu anderen Räumen. Alle Türen sind Falltüren, d.h. sie funktionieren nur in eine Richtung. Ein Raum ist ein Ausgang aus dem Labyrinth, wenn keine Türen von dem Raum wegführen, das heisst, wenn doorsTo eine Länge von 0 hat. Sie dürfen für alle Aufgaben annehmen, dass es im Labyrinth keinen Zyklus gibt. Das heisst, dass man einen Raum, welchen man durch eine Türe verlassen hat, nie wieder erreichen kann indem man weiteren Türen folgt. Ein Raum hat zu dem gleichen Raum immer nur eine oder keine Tür, nie zwei. In einem Labyrinth nennen wir eine Sequenz von # Räumen A1, . . . , A# einen Lösungspfad für einen Raum room genau dann wenn: (1) Der erste Raum A1 ist der Raum room, (2) der letzte Raum A# ist ein Ausgang, und (3) jeder Raum A8 mit 1 ≤ 8 < # hat eine Tür zum nächsten Raum in der Sequenz A8+1. (a) (Ù) Implementieren Sie die Methode Labyrinth.exits(Room room, List<Room> prefix), welche eine Liste von Räumen zurückgibt. Die zurückgegebene Liste ; sollte alle Ausgänge A4 enthalten, für welche gilt, dass es einen Lösungspfad A1, A2, ..., A= für room gibt, wobei A= = A4 gilt und prefix ein Präﬁx von A1, A2, ..., A= ist. prefix ist ein Präﬁx eines Lösungspfads A1, A2, ..., A= genau dann, wenn A8 dem 8-ten Raum von prefix entspricht für 1 ≤ 8 ≤ prefix.size() und = ≥ prefix.size(). Jeder Ausgang, welcher die beschriebene Bedingung erfüllt, muss genau einmal in ; enthalten sein und ; darf keine anderen Räume enthalten. (b) (⋆) Sei ein Raum A4 ein Ausgang für Raum A genau dann, wenn A4 ein Ausgang ist und von A erreichbar sind (das heisst, es gibt einen Lösungspfad für A , der in A4 endet). Implementieren Sie die Methode Labyrinth.sortRooms(List<Room> a), welche die Liste a wie folgt sortieren soll: Ein Raum A1 muss vor einem Raum A2 vorkommen, wenn eine der folgenden Bedingungen gilt: • Die Anzahl Ausgänge für A1 sind strikt kleiner als die Anzahl Ausgänge für A2. • Die Anzahl Ausgänge für A1 sind gleich gross wie die Anzahl Ausgänge für A2, und es gibt einen Ausgang für A1 dessen Name aus strikt mehr Zeichen besteht als jeder Name der Ausgänge für A2. Die Anzahl Zeichen eines Strings kann man mit String.length() berechnen. Wenn gemäss den Bedingungen A1 nicht vor A2 und A2 nicht vor A1 vorkommen muss, dann können A1 und A2 relativ zueinander in einer beliebigen Reihenfolge auftreten. (c) (⋆Ù) Zwei Sequenzen a und b von Räumen sind namensgleich genau dann, wenn a und b gleich lang sind und die Namen der Räume aus a exakt gleich oft bei den Namen der Räume aus b vorkommen. Zum Beispiel, wenn die Räume in a die Namen [“A”, “A”, “B”] und die Räume in b die Namen [“A”, “B”, “A”] haben, dann sind a und b namensgleich (“A” kommt bei beiden genau zweimal vor, “B” kommt bei beiden genau einmal vor). Wenn die Räume in a die Namen [“A”, “A”, “B”] und die Räume in b die Namen [“A”, “B”, “B”] haben, dann sind a und b nicht namensgleich. Die Methode Labyrinth.sameNames(List<Room> a, List<Room> b) enthält schon eine korrekte Implementierung von Namensgleichheit. Die Methode gibt true zurück genau dann, wenn a und b namensgleich sind. Implementieren Sie die Methode Labyrinth.pathsWithSameNames(Room room, int n). Die Methode soll true zurückgeben genau dann, wenn es mindestens n viele unterschiedliche Lösungspfade für das Argument room gibt, die namensgleich sind. Zwei Lösungpfade !1 und !2 sind unterschiedlich, wenn !1 und !2 eine unterschiedliche Länge haben oder wenn für mindestens einen Index 8 die 8-ten Räume von !1 und !2 unterschiedlich sind (also !1 und !2 für Index 8 unterschiedliche Referenzen enthalten). Sie dürfen Methoden und Felder der Klasse Room hinzufügen. Tests ﬁnden Sie in der Datei “LabyrinthTest.java”. Page 8 of 10 Notizen Page 9 of 10 Notizen Page 10 of 10","libVersion":"0.5.0","langs":""}