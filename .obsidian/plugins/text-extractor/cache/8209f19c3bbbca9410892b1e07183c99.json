{"path":"sem4/FMFP/VRL/extra/slides/FMFP-s11-operational-semantics.pdf","text":"Formal Methods and Functional Programming Operational Semantics Peter M¨uller Programming Methodology Group ETH Zurich Operational Semantics of Statements Recall: evaluation of an expression in a state yields a value x + 2 * y A ∶ Aexp → State → Val Execution of a statement modifies the state x := 2 * y Operational semantics describe how the state is modified during the execution of a statement David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 62 Big-Step and Small-Step Semantics Big-step semantics describe how the overall results of the executions are obtained The system in this course is also called Natural Semantics Small-step semantics describe how the individual steps of the computations take place The system in this course is called Structural Operational Semantics Alternative approaches exist, e.g., abstract state machines David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 63 3. Operational Semantics 3.1 Big-Step Semantics 3.1.1 Natural Semantics of IMP [N&N, p. 19–25] 3.1.2 Proving Properties of the Semantics [N&N, p. 26–30] 3.1.3 Extensions of IMP [N&N, p. 46–52] 3.2 Small-Step Semantics 3.3 Equivalence David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 64 Transition Systems A transition system is a tuple (Γ, T , →) Γ: a set of configurations T : a set of terminal configurations, T ⊆ Γ →: a transition relation, → ⊆ Γ × Γ Operational semantics includes two types of configurations 1. ⟨s, σ⟩, which represents that the statement s is to be executed in state σ 2. σ, which represents a final state (terminal configuration) The transition relation → describes how executions take place Big-step transititions are of the form ⟨s, σ⟩ → σ′ Example: ⟨skip, σ⟩ → σ Γ = {⟨s, σ⟩ ∣ s ∈ Stm, σ ∈ State} ∪ State T = State → ⊆ {⟨s, σ⟩ ∣ s ∈ Stm, σ ∈ State} × State David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 65 Transition Systems A transition system is a tuple (Γ, T , →) Γ: a set of configurations T : a set of terminal configurations, T ⊆ Γ →: a transition relation, → ⊆ Γ × Γ Operational semantics includes two types of configurations 1. ⟨s, σ⟩, which represents that the statement s is to be executed in state σ 2. σ, which represents a final state (terminal configuration) The transition relation → describes how executions take place Big-step transititions are of the form ⟨s, σ⟩ → σ′ Example: ⟨skip, σ⟩ → σ Γ = {⟨s, σ⟩ ∣ s ∈ Stm, σ ∈ State} ∪ State T = State → ⊆ {⟨s, σ⟩ ∣ s ∈ Stm, σ ∈ State} × State David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 65 Transition Systems A transition system is a tuple (Γ, T , →) Γ: a set of configurations T : a set of terminal configurations, T ⊆ Γ →: a transition relation, → ⊆ Γ × Γ Operational semantics includes two types of configurations 1. ⟨s, σ⟩, which represents that the statement s is to be executed in state σ 2. σ, which represents a final state (terminal configuration) The transition relation → describes how executions take place Big-step transititions are of the form ⟨s, σ⟩ → σ′ Example: ⟨skip, σ⟩ → σ Γ = {⟨s, σ⟩ ∣ s ∈ Stm, σ ∈ State} ∪ State T = State → ⊆ {⟨s, σ⟩ ∣ s ∈ Stm, σ ∈ State} × State David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 65 Transition Systems A transition system is a tuple (Γ, T , →) Γ: a set of configurations T : a set of terminal configurations, T ⊆ Γ →: a transition relation, → ⊆ Γ × Γ Operational semantics includes two types of configurations 1. ⟨s, σ⟩, which represents that the statement s is to be executed in state σ 2. σ, which represents a final state (terminal configuration) The transition relation → describes how executions take place Big-step transititions are of the form ⟨s, σ⟩ → σ′ Example: ⟨skip, σ⟩ → σ Γ = {⟨s, σ⟩ ∣ s ∈ Stm, σ ∈ State} ∪ State T = State → ⊆ {⟨s, σ⟩ ∣ s ∈ Stm, σ ∈ State} × State David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 65 Inference Rules We specify the transition relation by rules of the form φ1 . . . φn (Name)∗ ψ ∗(optional: side-condition) where φ1, . . . , φn and ψ are transitions Meaning of the rule If φ1, . . . , φn are transitions (and side-condition is true) then ψ is a transition Terminology φ1, . . . , φn are called the premises of the rule ψ is called the conclusion of the rule A rule without premises is sometimes called an axiom rule David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 66 Big-Step Semantics of IMP skip does not modify the state (SkipNS ) ⟨skip, σ⟩ → σ x := e assigns the value of e to variable x (AssNS ) ⟨x := e, σ⟩ → σ[x ↦ A[[e]]σ] Sequential composition s;s ′ First, s is executed in state σ, leading to σ′ Then s ′ is executed in state σ′, leading to σ′′ ⟨s, σ⟩ → σ′ ⟨s ′, σ′⟩ → σ′′ (SeqNS ) ⟨s;s ′, σ⟩ → σ′′ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 67 Big-Step Semantics of IMP (cont’d) Conditional statement if b then s else s ′ end If b holds, s is executed If b does not hold, s ′ is executed ⟨s, σ⟩ → σ′ (IfTNS ) ⟨if b then s else s ′ end, σ⟩ → σ′ if B[[b]]σ = tt ⟨s ′, σ⟩ → σ′ (IfFNS ) ⟨if b then s else s ′ end, σ⟩ → σ′ if B[[b]]σ = ff David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 68 Big-Step Semantics of IMP (cont’d) Loop statement while b do s end If b holds, s is executed once, leading to state σ′ Then the whole while-statement is executed again in σ′ ⟨s, σ⟩ → σ′ ⟨while b do s end, σ′⟩ → σ′′ (WhTNS ) ⟨while b do s end, σ⟩ → σ′′ if B[[b]]σ = tt If b does not hold, the while-statement does not modify the state (WhFNS ) ⟨while b do s end, σ⟩ → σ if B[[b]]σ = ff David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 69 Rule Schemes and Instantiations Inference rule definitions are actually rule schemes Meta-variables in rule definitions are placeholders for statements, states, etc. A rule scheme describes infinitely many rule instances A rule is instantiated when all meta-variables are replaced with syntactic elements Assignment rule scheme (AssNS ) ⟨x := e, σ⟩ → σ[x ↦ A[[e]]σ] Assignment rule instance (AssNS ) ⟨v := v+1, σzero⟩ → σzero[v ↦ A[[v+1]]σzero] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 70 Derivation Trees Rule instances can be combined to derive a transition ⟨s, σ⟩ → σ′ The result is a derivation tree T The root of T is ⟨s, σ⟩ → σ′, written as root(T ) ≡ ⟨s, σ⟩ → σ′ The leaves of T are axiom rule instances The internal nodes of T are conclusions of rule instances and have the corresponding premises as immediate children The side-conditions of all instantiated rules must be satisfied The transition system permits a transition ⟨s, σ⟩ → σ′, written as ⊢ ⟨s, σ⟩ → σ′, if and only if there exists a finite derivation tree ending in ⟨s, σ⟩ → σ′ ⊢ ⟨s, σ⟩ → σ′ ⇔ ∃T .root(T ) ≡ ⟨s, σ⟩ → σ′ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 71 Derivations: Example What is the result of executing statement (z:=x; x:=y); y:=z in state σzero[x ↦ 5][y ↦ 7][z ↦ 0] (abbreviated by [5, 7, 0])? (AssNS ) ⟨z:=x, [5, 7, 0]⟩ → [5, 7, 5] (AssNS ) ⟨x:=y, [5, 7, 5]⟩ → [7, 7, 5] (SeqNS ) ⟨z:=x; x:=y, [5, 7, 0]⟩ → [7, 7, 5] (AssNS ) ⟨y:=z, [7, 7, 5]⟩ → [7, 5, 5] (SeqNS ) ⟨(z:=x; x:=y); y:=z, [5, 7, 0]⟩ → [7, 5, 5] In the above derivation, we assume some properties of state updates (such as σ[x ↦ v1][y ↦ v2] = σ[y ↦ v2][x ↦ v1] if x /≡ y ), which will be proved in the exercises David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 72 Termination For an IMP statement s we define termination in the context of big-step semantics as follows The execution of a statement s in state σ terminates successfully iff there exists a state σ′ such that ⊢ ⟨s, σ⟩ → σ′ fails to terminate iff there is no state σ′ such that ⊢ ⟨s, σ⟩ → σ′ For example, while true do skip end fails to terminate David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 73 3. Operational Semantics 3.1 Big-Step Semantics 3.1.1 Natural Semantics of IMP 3.1.2 Proving Properties of the Semantics 3.1.3 Extensions of IMP 3.2 Small-Step Semantics 3.3 Equivalence David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 74 Semantic Equivalence Definition Two statements s1 and s2 are semantically equivalent (written s1 ≃ s2) iff: ∀σ, σ′. ( ⊢ ⟨s1, σ⟩ → σ′ ⇔ ⊢ ⟨s2, σ⟩ → σ′ ) Examples while false do s end ≃ skip while b do s end ≃ if b then s; while b do s end end David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 75 Unfolding Loops in C, C++, and Java int i = 0; while(i < 2 ) { while(i < 1) if(i == 0) break; i = i + 1; } printf(\"i = %d\", i); i = 2 int i = 0; while(i < 2 ) { if(i < 1) { if(i == 0) break; while(i < 1) if(i == 0) break; } i = i + 1; } printf(\"i = %d\", i); i = 0 Equivalence does not hold in these languages David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 76 Unfolding Loops in C, C++, and Java int i = 0; while(i < 2 ) { while(i < 1) if(i == 0) break; i = i + 1; } printf(\"i = %d\", i); i = 2 int i = 0; while(i < 2 ) { if(i < 1) { if(i == 0) break; while(i < 1) if(i == 0) break; } i = i + 1; } printf(\"i = %d\", i); i = 0 Equivalence does not hold in these languages David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 76 Unfolding Loops in IMP We prove the equivalence in the big-step semantics for IMP ∀b, s.( while b do s end ≃ if b then s; while b do s end end ) ∀b, s, σ, σ′.( ⊢ ⟨while b do s end, σ⟩ → σ′ ⇔ ⊢ ⟨if b then s; while b do s end end, σ⟩ → σ′) Proof idea Prove the equivalence by showing implication in both directions In each direction, consider the derivation tree for one transition Show that there is a derivation tree for the other transition We show only the ⇒ direction of the proof here (⇐ in exercises) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 77 Proof (“⇒” direction only) Let b, s, σ, σ′ be arbitrary. We assume ⊢ ⟨while b do s end, σ⟩ → σ′. That is, there is some derivation tree T such that root(T ) ≡ ⟨while b do s end, σ⟩ → σ′ The last rule application in T must be one of the (two) rules for while (Case: WhTNS is the last rule applied) i.e., T is of the form: ⟨s, σ⟩ → σ′′ ⟨while b do s end, σ′′⟩ → σ′ (WhTNS ) ⟨while b do s end, σ⟩ → σ′ Thus, we know that (for some σ′′): 1. There is a derivation tree T1 with root(T1) ≡ ⟨s, σ⟩ → σ′′ 2. There is a derivation tree T2 with root(T2) ≡ ⟨while b do s end, σ′′⟩ → σ′ 3. B[[b]]σ = tt (from the side-condition) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 78 Proof: Case “⇒” (cont’d) Using T1 and T2, we can construct the derivation tree AA A \u0001 \u0001 \u0001 T1 ⟨s, σ⟩ → σ′′ A A A \u0001 \u0001 \u0001 T2 ⟨while b do s end, σ′′⟩ → σ′ (SeqNS ) ⟨s;while b do s end, σ⟩ → σ′ Since B[[b]]σ = tt we can use the rule IfTNS to obtain a derivation for the “unfolded” loop, as required: A A A \u0001 \u0001 \u0001 T1 ⟨s, σ⟩ → σ′′ AA A \u0001 \u0001 \u0001 T2 ⟨while b do s end, σ′′⟩ → σ′ (SeqNS ) ⟨s;while b do s end, σ⟩ → σ′ (IfTNS ) ⟨if b then s;while b do s end else skip end, σ⟩ → σ′ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 79 Proof: Case “⇒” (cont’d) (Case: WhFNS is the last rule applied in T ) i.e., T is of the form: (WhFNS ) ⟨while b do s end, σ⟩ → σ Therefore, we know that 1. σ = σ′ 2. B[[b]]σ = ff We can construct the derivation tree (SkipNS ) ⟨skip, σ⟩ → σ′ (IfFNS ) ⟨if b then s;while b do s end else skip end, σ⟩ → σ′ Thus, we have a derivation of ⟨if b then s;while b do s end else skip end, σ⟩ → σ′, as required David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 80 Deterministic Semantics Lemma: The big-step semantics of IMP is deterministic We prove ∀s, σ, σ′, σ′′.( ⊢ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′ ) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 81 Proof Attempt: Structural Induction Reminder: abstract syntax of statements data Stm = Skip | Assign String Aexp | Seq Stm Stm | If Bexp Stm Stm | While Bexp Stm Structural induction for statements (for x,e,b,s,s1,s2 not free in Γ): Γ ⊢ P(skip) Γ ⊢ P(x := e) Γ, P(s1), P(s2) ⊢ P(s1;s2) Γ, P(s1), P(s2) ⊢ P(if b then s1 else s2 end) Γ, P(s) ⊢ P(while b do s end) Γ ⊢ ∀s ∈ Stm.P(s) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 82 Proof Attempt: Structural Induction (2) Define P(s) ≡ ∀σ, σ′, σ′′.( ⊢ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′ ) (Case: s ≡ skip) Let σ,σ′,σ′′ be arbitrary We assume ⊢ ⟨s, σ⟩ → σ′ and ⊢ ⟨s, σ⟩ → σ′′ and seek to prove that σ′ = σ′′ Our assumption tells us that there exists a derivation tree for ⟨skip, σ⟩ → σ′. The only tree with this consequence is simply an instantiation of the (SkipNS ) rule. Thus, we must have σ = σ′ Analogously, from ⊢ ⟨skip, σ⟩ → σ′′, we can deduce σ = σ′′ (Case: s ≡ x:=e) Analogously to the previous case. David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 83 Proof Attempt: Structural Induction (3) (Case: s ≡ while b do s ′ end) Let σ,σ′,σ′′ be arbitrary We assume there is a derivation tree for ⟨while b do s ′ end, σ⟩ → σ′ There are two last rules that could have been applied in this derivation In the case for WhT, we conclude that (for some σ1) we have ⊢ ⟨s ′, σ⟩ → σ1 and ⊢ ⟨while b do s ′ end, σ1⟩ → σ′ Analogously, we derive from ⊢ ⟨while b do s ′ end, σ⟩ → σ′′ that ⊢ ⟨s ′, σ⟩ → σ2 and ⊢ ⟨while b do s ′ end, σ2⟩ → σ′′ s ′ is a proper sub-statement of s. Therefore, we can apply the induction hypothesis (P(s ′)), which allows us to conclude from ⊢ ⟨s ′, σ⟩ → σ1 and ⊢ ⟨s ′, σ⟩ → σ2 that σ1 = σ2 It remains to show that ⊢ ⟨while b do s ′ end, σ1⟩ → σ′ and ⊢ ⟨while b do s ′ end, σ1⟩ → σ′′ imply σ′ = σ′′ But while b do s ′ end is obviously not a proper sub-statement of s! So we cannot apply the induction hypothesis The proof is stuck; our goal even seems similar to the original one Structural induction does not work since the transition relation is not defined inductively over the structure of the statements David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 84 Induction on Derivation Trees New proof technique: induction on the shape of derivation trees To prove a property P(T ) for all derivation trees T , prove that P(T ) holds for an arbitrary derivation tree T under the assumption (I.H.) that P(T ′) holds for all sub-trees T ′ of T . Induction on derivation trees is a special case of well-founded (Noetherian) induction Define T ′ ⊏ T (where T , T ′ are derivation trees) to mean that T ′ is a proper sub-tree of T ⊏ is a well-founded ordering, since derivation trees are finite We call T ′ a sub-derivation of T if T ′ ⊏ T Hint: proofs by induction on the shape of derivation trees typically proceed by case distinction on the rule applied at the root of the arbitrary derivation tree T . This provides us more information about the structure of the derivation; in particular, it may tell us about sub-derivations, to which our induction hypothesis applies. David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 85 Induction on Derivation Trees New proof technique: induction on the shape of derivation trees To prove a property P(T ) for all derivation trees T , prove that P(T ) holds for an arbitrary derivation tree T under the assumption (I.H.) that P(T ′) holds for all sub-trees T ′ of T . Induction on derivation trees is a special case of well-founded (Noetherian) induction Define T ′ ⊏ T (where T , T ′ are derivation trees) to mean that T ′ is a proper sub-tree of T ⊏ is a well-founded ordering, since derivation trees are finite We call T ′ a sub-derivation of T if T ′ ⊏ T Hint: proofs by induction on the shape of derivation trees typically proceed by case distinction on the rule applied at the root of the arbitrary derivation tree T . This provides us more information about the structure of the derivation; in particular, it may tell us about sub-derivations, to which our induction hypothesis applies. David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 85 New Proof Attempt: Induction on Shape of Derivation Tree Recall that we want to prove: ∀s, σ, σ′, σ′′. ⊢ ⟨s, σ⟩ → σ′∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′ This can be written more explicitly (using ⊢ definition) as: ∀s, σ, σ′, σ′′.(∃T .root(T ) ≡ ⟨s, σ⟩ → σ′) ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′ This is logically equivalent to: ∀T .∀s, σ, σ′, σ′′.(root(T ) ≡ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′) Thus, induction can be applied We define: P(T ) ≡ (∀s, σ, σ′, σ′′.root(T ) ≡ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′) and prove ∀T .P(T ) by induction on the shape of the derivation T David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 86 New Proof Attempt: Induction on Shape of Derivation Tree Recall that we want to prove: ∀s, σ, σ′, σ′′. ⊢ ⟨s, σ⟩ → σ′∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′ This can be written more explicitly (using ⊢ definition) as: ∀s, σ, σ′, σ′′.(∃T .root(T ) ≡ ⟨s, σ⟩ → σ′) ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′ This is logically equivalent to: ∀T .∀s, σ, σ′, σ′′.(root(T ) ≡ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′) Thus, induction can be applied We define: P(T ) ≡ (∀s, σ, σ′, σ′′.root(T ) ≡ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′) and prove ∀T .P(T ) by induction on the shape of the derivation T David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 86 New Proof Attempt: Induction on Shape of Derivation Tree Recall that we want to prove: ∀s, σ, σ′, σ′′. ⊢ ⟨s, σ⟩ → σ′∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′ This can be written more explicitly (using ⊢ definition) as: ∀s, σ, σ′, σ′′.(∃T .root(T ) ≡ ⟨s, σ⟩ → σ′) ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′ This is logically equivalent to: ∀T .∀s, σ, σ′, σ′′.(root(T ) ≡ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′) Thus, induction can be applied We define: P(T ) ≡ (∀s, σ, σ′, σ′′.root(T ) ≡ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′) and prove ∀T .P(T ) by induction on the shape of the derivation T David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 86 New Proof Attempt: Induction on Shape of Derivation Tree Recall that we want to prove: ∀s, σ, σ′, σ′′. ⊢ ⟨s, σ⟩ → σ′∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′ This can be written more explicitly (using ⊢ definition) as: ∀s, σ, σ′, σ′′.(∃T .root(T ) ≡ ⟨s, σ⟩ → σ′) ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′ This is logically equivalent to: ∀T .∀s, σ, σ′, σ′′.(root(T ) ≡ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′) Thus, induction can be applied We define: P(T ) ≡ (∀s, σ, σ′, σ′′.root(T ) ≡ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′) and prove ∀T .P(T ) by induction on the shape of the derivation T David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 86 New Proof Attempt: Induction on Shape of Derivation Tree (2) P(T ) ≡ (∀s, σ, σ′, σ′′.root(T ) ≡ ⟨s, σ⟩ → σ′ ∧ ⊢ ⟨s, σ⟩ → σ′′ ⇒ σ′ = σ′′) Let T be an arbitrary derivation tree, and let s,σ,σ′,σ′′ be arbitrary We assume root(T ) ≡ ⟨s, σ⟩ → σ′ and ⊢ ⟨s, σ⟩ → σ′′ We now need to prove that σ′ = σ′′ We perform a case distinction on the last rule applied in T ; this yields seven different cases (one for each of the seven rules of the big-step semantics) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 87 New Proof Attempt: Induction on Shape of Derivation Tree (3) (Case SkipNS ): From the form of the rule, we know: s ≡ skip σ′ = σ Therefore, the derivation of ⟨s, σ⟩ → σ′′ is actually a derivation of ⟨skip, σ⟩ → σ′′. The last rule applied in this derivation must also have been the SkipNS rule, from which we obtain σ′′ = σ (Case AssNS ): From the form of the rule, we know: s ≡ x := e for some x and e σ′ = σ[x ↦ A[[e]]σ] Therefore, the derivation of ⟨s, σ⟩ → σ′′ is actually a derivation of ⟨x := e, σ⟩ → σ′′. The last rule applied in this derivation must also have been the AssNS rule, from which we obtain σ′′ = σ[x ↦ A[[e]]σ] (Case WhFNS ): Analogously David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 88 New Proof Attempt: Induction on Shape of Derivation Tree (4) (Case SeqNS ): From the form of the rule, we know: s ≡ s1;s2 for some s1 and s2 ⊢ ⟨s1, σ⟩ → σ0 and ⊢ ⟨s2, σ0⟩ → σ′, for some state σ0 (where these are sub-derivations of T ) Analogously to the previous cases, we can conclude from ⊢ ⟨s, σ⟩ → σ′′ that the same last rule must be applied, and so ⊢ ⟨s1, σ⟩ → σ1 and ⊢ ⟨s2, σ1⟩ → σ′′ for some state σ1 The derivation tree for ⟨s1, σ⟩ → σ0 is a proper sub-tree of T . Therefore, we can apply the induction hypothesis to ⊢ ⟨s1, σ⟩ → σ0 (with ⊢ ⟨s1, σ⟩ → σ1) to obtain σ0 = σ1. By this equality, we conclude ⊢ ⟨s2, σ0⟩ → σ′′ Analogously, we can apply the induction hypothesis to ⊢ ⟨s2, σ0⟩ → σ′ (with ⊢ ⟨s2, σ0⟩ → σ′′) to obtain σ′ = σ′′ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 89 New Proof Attempt: Induction on Shape of Derivation Tree (5) (Case IfTNS ): From the form of the rule, we know: s ≡ if b then s1 else s2 end for some b, s1, and s2 B[[b]]σ = tt There is a derivation tree for ⟨s1, σ⟩ → σ′ (and it is a subderivation of T ) Therefore, the last rule applied in the derivation tree for ⟨s, σ⟩ → σ′′ must also have been the IfTNS rule Consequently, we also have ⊢ ⟨s1, σ⟩ → σ′′ Since the derivation tree for ⟨s1, σ⟩ → σ′ is a proper sub-derivation of T , we can apply the induction hypothesis to this subderivation (with ⊢ ⟨s1, σ⟩ → σ′′) to obtain σ′ = σ′′. (Case IfFNS ): Analogously David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 90 New Proof Attempt: Induction on Shape of Derivation Tree (6) (Case WhTNS ): From the form of the rule, we know: s ≡ while b do s ′ end for some b and s ′ B[[b]]σ = tt There are sub-derivations of T for ⟨s ′, σ⟩ → σ0 and ⟨while b do s ′ end, σ0⟩ → σ′, for some state σ0 Therefore, the last rule applied in the derivation tree for ⟨s, σ⟩ → σ′′ must also have been the WhTNS rule Consequently, we know that ⊢ ⟨s ′, σ⟩ → σ1 and ⊢ ⟨while b do s ′ end, σ1⟩ → σ′′, for some state σ1 The derivation tree for ⟨s ′, σ⟩ → σ0 is a proper sub-derivation of the derivation T . Therefore, we can apply the induction hypothesis to this sub-derivation (with ⊢ ⟨s ′, σ⟩ → σ1) to obtain σ0 = σ1. By this equality, we conclude that ⊢ ⟨while b do s ′ end, σ0⟩ → σ′′ Analogously, we can apply the induction hypothesis to ⟨while b do s ′ end, σ0⟩ → σ′ (with ⊢ ⟨while b do s ′ end, σ0⟩ → σ′′) to obtain σ′ = σ′′ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 91 3. Operational Semantics 3.1 Big-Step Semantics 3.1.1 Natural Semantics of IMP 3.1.2 Proving Properties of the Semantics 3.1.3 Extensions of IMP 3.2 Small-Step Semantics 3.3 Equivalence David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 92 Extensions of IMP We examine several language extensions for IMP For each, we then consider appropriate big-step semantics rules Language extensions explored here: Local variables / scopes Procedure declarations / calls Non-deterministic choice Parallel composition (attempt) More in the exercises We will compare other semantics for these extensions later in the course Note: these extensions are not part of the core IMP language In particular, when we speak of “IMP”, we still mean the language without extensions, unless we mention extensions explicitly David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 93 Local Variable Declarations Idea: statement var x:=e in s end declares a local variable that is visible in the sub-statement of the declaration, s Semantics Expression e is evaluated in the initial state Statement s is executed in a state in which x has the value of e After the execution of s, the initial value of x is restored Big-step semantics rule: ⟨s, σ[x ↦ A[[e]]σ]⟩ → σ′ (LocNS ) ⟨var x:=e in s end, σ⟩ → σ′[x ↦ σ(x)] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 94 Procedure Declarations and Calls procedure p(x1, . . . , xn; y1, . . . , ym) begin s end Formal parameters x1, . . . , xn are value parameters y1, . . . , ym are variable parameters; they can be used to assign values back to the procedure caller. Procedures can be declared (syntax as above) as part of a source program, and called (in a statement). We apply the following restrictions: In a procedure declaration, the formal parameter names x1, . . . , xn, y1, . . . , ym must be distinct from each other x1, . . . , xn and y1, . . . , ym are the only free variables in s (local variables declared in s are permitted since they are bound) For procedure calls p(e1, . . . , en; z1, . . . , zm), the actual variable parameters z1, . . . , zm have to be distinct from each other (no aliasing) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 95 Procedures: Example procedure fac(n; res) begin res := 1; while n > 1 do res := n * res; n := n - 1 end end x := 3; y := 0; fac(x; y) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 96 Natural Semantics of Procedure Calls Procedure call p(e1, . . . , en;z1, . . . , zm) in state σ, with declaration procedure p(x1, . . . , xn;y1, . . . , ym) begin s end The value arguments Ð⇀ei = e1, . . . , en are evaluated in the initial state σ to values A[[e1]]σ, . . . , A[[en]]σ The body of the procedure, s, is executed in a state, in which the value parameters Ð⇀xi = x1, . . . , xn are initialized with the values A[[e1]]σ, . . . , A[[en]]σ, and the variable parameters Ð⇀yj = y1, . . . , ym are initialized with the values of Ð⇀zj = z1, . . . , zm in the initial state After termination of p, execution continues in the initial state with the values of Ð⇀yj assigned to the variables Ð⇀zj ⟨s, σzero[Ð⇀xi ↦ ÐÐÐÐÐ⇀ A[[ei ]]σ][Ð⇀yj ↦ ÐÐ⇀ σ(zj )]⟩ → σ′ (CallNS ) ⟨p(Ð⇀ei ;Ð⇀zj ), σ⟩ → σ[Ð⇀zj ↦ ÐÐÐ⇀ σ′(yj )] The notation σ[Ð⇀xi ↦ Ð⇀vi ] abbreviates σ[x1 ↦ v1][x2 ↦ v2] . . . [xn ↦ vn] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 97 Non-determinism Idea: for the statement s s ′ either s or s ′ is non-deterministically chosen to be executed The statement x:=1 (x:=2; x:=x+2) will result in a state in which x either has the value 1 or 4 Rules ⟨s, σ⟩ → σ′ (ND1NS ) ⟨s s ′, σ⟩ → σ′ ⟨s ′, σ⟩ → σ′ (ND2NS ) ⟨s s ′, σ⟩ → σ′ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 98 Non-determinism: Observations There are derivation trees for ⟨x:=1 (x:=2; x:=x+2), σ⟩ → σ[x ↦ 1] and ⟨x:=1 (x:=2; x:=x+2), σ⟩ → σ[x ↦ 4] There is a derivation tree for ⟨while true do skip end (x:=2; x:=x+2), σ⟩ → σ[x ↦ 4] Because big-step semantics cannot accurately describe non-terminating computations, if only one non-deterministic branch terminates successfully, we will only “see” that result In big-step semantics, non-determinism suppresses non-termination, if possible σ[x ↦ 4] is the only possible final state in the above example In fact, while true do skip end (x:=2; x:=x+2) is semantically equivalent to (x:=2; x:=x+2) in the big-step semantics In a sense, the big-step semantics only shows the behavior of “correct” choice(s). But this means that we miss some possible behaviors David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 99 Non-determinism: Observations There are derivation trees for ⟨x:=1 (x:=2; x:=x+2), σ⟩ → σ[x ↦ 1] and ⟨x:=1 (x:=2; x:=x+2), σ⟩ → σ[x ↦ 4] There is a derivation tree for ⟨while true do skip end (x:=2; x:=x+2), σ⟩ → σ[x ↦ 4] Because big-step semantics cannot accurately describe non-terminating computations, if only one non-deterministic branch terminates successfully, we will only “see” that result In big-step semantics, non-determinism suppresses non-termination, if possible σ[x ↦ 4] is the only possible final state in the above example In fact, while true do skip end (x:=2; x:=x+2) is semantically equivalent to (x:=2; x:=x+2) in the big-step semantics In a sense, the big-step semantics only shows the behavior of “correct” choice(s). But this means that we miss some possible behaviors David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 99 Non-determinism: Observations There are derivation trees for ⟨x:=1 (x:=2; x:=x+2), σ⟩ → σ[x ↦ 1] and ⟨x:=1 (x:=2; x:=x+2), σ⟩ → σ[x ↦ 4] There is a derivation tree for ⟨while true do skip end (x:=2; x:=x+2), σ⟩ → σ[x ↦ 4] Because big-step semantics cannot accurately describe non-terminating computations, if only one non-deterministic branch terminates successfully, we will only “see” that result In big-step semantics, non-determinism suppresses non-termination, if possible σ[x ↦ 4] is the only possible final state in the above example In fact, while true do skip end (x:=2; x:=x+2) is semantically equivalent to (x:=2; x:=x+2) in the big-step semantics In a sense, the big-step semantics only shows the behavior of “correct” choice(s). But this means that we miss some possible behaviors David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 99 Non-determinism: Observations There are derivation trees for ⟨x:=1 (x:=2; x:=x+2), σ⟩ → σ[x ↦ 1] and ⟨x:=1 (x:=2; x:=x+2), σ⟩ → σ[x ↦ 4] There is a derivation tree for ⟨while true do skip end (x:=2; x:=x+2), σ⟩ → σ[x ↦ 4] Because big-step semantics cannot accurately describe non-terminating computations, if only one non-deterministic branch terminates successfully, we will only “see” that result In big-step semantics, non-determinism suppresses non-termination, if possible σ[x ↦ 4] is the only possible final state in the above example In fact, while true do skip end (x:=2; x:=x+2) is semantically equivalent to (x:=2; x:=x+2) in the big-step semantics In a sense, the big-step semantics only shows the behavior of “correct” choice(s). But this means that we miss some possible behaviors David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 99 Non-determinism: Observations There are derivation trees for ⟨x:=1 (x:=2; x:=x+2), σ⟩ → σ[x ↦ 1] and ⟨x:=1 (x:=2; x:=x+2), σ⟩ → σ[x ↦ 4] There is a derivation tree for ⟨while true do skip end (x:=2; x:=x+2), σ⟩ → σ[x ↦ 4] Because big-step semantics cannot accurately describe non-terminating computations, if only one non-deterministic branch terminates successfully, we will only “see” that result In big-step semantics, non-determinism suppresses non-termination, if possible σ[x ↦ 4] is the only possible final state in the above example In fact, while true do skip end (x:=2; x:=x+2) is semantically equivalent to (x:=2; x:=x+2) in the big-step semantics In a sense, the big-step semantics only shows the behavior of “correct” choice(s). But this means that we miss some possible behaviors David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 99 Termination Revisited Recall: for an IMP statement s we defined termination in the context of big-step semantics as follows: The execution of a statement s in state σ terminates successfully iff there is a state σ′ such that ⊢ ⟨s, σ⟩ → σ′ fails to terminate iff there is no state σ′ such that ⊢ ⟨s, σ⟩ → σ′ According to these definitions while true do skip end skip terminates successfully while true do skip end fails to terminate but we cannot give a more precise definition with our big-step semantics David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 100 Termination Revisited Recall: for an IMP statement s we defined termination in the context of big-step semantics as follows: The execution of a statement s in state σ terminates successfully iff there is a state σ′ such that ⊢ ⟨s, σ⟩ → σ′ fails to terminate iff there is no state σ′ such that ⊢ ⟨s, σ⟩ → σ′ According to these definitions while true do skip end skip terminates successfully while true do skip end fails to terminate but we cannot give a more precise definition with our big-step semantics David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 100 Parallelism Idea: for the statement s par s ′ both statements s and s ′ are executed, but execution can be interleaved The statement x:=1 par (x:=2; x:=x+2) could result in a state in which x has the value 4, 1, or 3 Execute x:=1, then x:=2, and then x:=x+2 Execute x:=2, then x:=x+2, and then x:=1 Execute x:=2, then x:=1, and then x:=x+2 David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 101 Parallelism: Observations Attempt to define rules: ⟨s, σ⟩ → σ′ ⟨s ′, σ′⟩ → σ′′ (Par1NS ) ⟨s par s ′, σ⟩ → σ′′ ⟨s ′, σ⟩ → σ′ ⟨s, σ′⟩ → σ′′ (Par2NS ) ⟨s par s ′, σ⟩ → σ′′ But, these rules do not allow interleaving execution! In big-step semantics rules, the executions expressed by premises are reasoned about as atomic steps; therefore, we cannot express interleaving of computations David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 102 Problems with Natural Semantics Properties of non-terminating programs cannot be expressed Non-determinism suppresses non-termination (when possible) Parallelism (interleaving) cannot be modeled Definition of semantic equivalence is coarse (but no reasonable alternative notions are available) All sorting programs are equivalent All non-terminating programs are equivalent David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 103 Reminder: Big-Step and Small-Step Semantics Big-step semantics describe how the overall results of the executions are obtained Natural semantics (now finished!) Small-step semantics describe how the individual steps of the computations take place Structural operational semantics (SOS) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 104 3. Operational Semantics 3.1 Big-Step Semantics 3.2 Small-Step Semantics 3.2.1 Structural Operational Semantics of IMP [N&N, p. 32–36] 3.2.2 Proving Properties of the Semantics [N&N, p. 36–39] 3.2.3 Extensions of IMP [N&N, p. 46–52] 3.3 Equivalence David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 105 Structural Operational Semantics (SOS) Small-step semantics focuses attention on the individual steps of an execution Execution of assignments Evaluation of if-conditions, while-iterations, etc. Describing small steps of the execution allows one to express the order of execution of individual steps Can be used to express interleaving computations Evaluation order for expressions (not shown in the course) Always describing the next small step allows one to express properties of non-terminating programs David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 106 Transitions in SOS The configurations are the same as for natural semantics (⟨s, σ⟩ or σ) We use γ as meta-variable for (terminal or non-terminal) configurations The transition relation →1 can have two forms ⟨s, σ⟩ →1 ⟨s ′, σ′⟩: the execution of s from σ is not completed and the remaining computation is expressed by the intermediate configuration ⟨s ′, σ′⟩ ⟨s, σ⟩ →1 σ′: the execution of s from σ has terminated and the final state is σ′ A transition ⟨s, σ⟩ →1 γ describes the first step of the execution of s in state σ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 107 Transition System Γ = {⟨s, σ⟩ ∣ s ∈ Stm, σ ∈ State} ∪ State T = State →1 ⊆ {⟨s, σ⟩ ∣ s ∈ Stm, σ ∈ State} × Γ We say that a non-terminal configuration ⟨s, σ⟩ is stuck if there does not exist a configuration γ such that ⟨s, σ⟩ →1 γ Note: terminal configurations (final states) σ are never stuck. We will again define the transition relation →1 using a derivation system, and write ⊢ ⟨s, σ⟩ →1 γ to mean that there exists a finite derivation tree ending in ⟨s, σ⟩ →1 γ ⊢ ⟨s, σ⟩ →1 γ ⇔ ∃T .root(T ) ≡ ⟨s, σ⟩ →1 γ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 108 SOS of IMP skip does not modify the state (SkipSOS ) ⟨skip, σ⟩ →1 σ x := e assigns the value of e to variable x (AssSOS ) ⟨x := e, σ⟩ →1 σ[x ↦ A[[e]]σ] skip and assignment require only one step to reach a final state Rules are analogous to natural semantics; recall: (SkipNS ) ⟨skip, σ⟩ → σ (AssNS ) ⟨x := e, σ⟩ → σ[x ↦ A[[e]]σ] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 109 SOS of IMP: Sequential Composition The first step of executing a sequential composition s;s ′ is the first step of executing s Either: s executes completely in one step ⟨s, σ⟩ →1 σ′ (Seq1SOS ) ⟨s;s ′, σ⟩ →1 ⟨s ′, σ′⟩ Or: s is not executed completely after one step ⟨s, σ⟩ →1 ⟨s ′′, σ′⟩ (Seq2SOS ) ⟨s;s ′, σ⟩ →1 ⟨s ′′;s ′, σ′⟩ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 110 SOS of IMP: Conditional Statement The first step of executing if b then s1 else s2 end is to determine the outcome of the test b, and thereby, which branch to select (IfTSOS ) ⟨if b then s else s ′ end, σ⟩ →1 ⟨s, σ⟩ if B[[b]]σ = tt (IfFSOS ) ⟨if b then s else s ′ end, σ⟩ →1 ⟨s ′, σ⟩ if B[[b]]σ = ff These are the standard rules that we will use for our small-step if semantics (unless otherwise specified) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 111 Alternative Rules for Conditional Statement The first step of executing if b then s1 else s2 end is the first step of the branch determined by the outcome of the test b ⟨s, σ⟩ →1 σ′ (IfT1SOS ) ⟨if b then s else s ′ end, σ⟩ →1 σ′ if B[[b]]σ = tt ⟨s, σ⟩ →1 ⟨s ′′, σ′⟩ (IfT2SOS ) ⟨if b then s else s ′ end, σ⟩ →1 ⟨s ′′, σ′⟩ if B[[b]]σ = tt and two analogous rules for the case B[[b]]σ = ff The choice between the two rules of the previous slide, and the (four) alternative rules here results in equivalent semantics for IMP But the choice can make a difference for languages with parallel execution (different granularity for interleaving) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 112 SOS of IMP: While Statement The first step is to unroll the loop (WhileSOS ) ⟨while b do s end, σ⟩ →1 ⟨if b then s;while b do s end else skip end, σ⟩ Recall that while b do s end and if b then s;while b do s end else skip end are semantically equivalent in the big-step semantics David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 113 Multi-Step Executions Our binary relation ⟨s, σ⟩ →1 γ is defined by the derivation rules shown A transition ⟨s, σ⟩ →1 γ belongs to our transition relation iff ⊢ ⟨s, σ⟩ →1 γ We now use this to define a relation, k-step execution, written γ → k 1 γ′ Intuitive meaning: there is an execution from γ to γ′ in exactly k steps k is a natural number (no negative-length executions) We define the relation γ →k 1 γ′ (inductively over k) as follows: γ →0 1 γ′ if and only if γ = γ′ For k > 0, γ →k 1 γ′ if and only if there exists γ′′ such that both ⊢ γ →1 γ′′ and γ′′ →k−1 1 γ′ Note: γ →1 1 γ′ if and only if ⊢ γ →1 γ′ (apply definition for k = 1) Note: γ →k1+k2 1 γ′ if and only if ∃γ′′. γ →k1 1 γ′′ ∧ γ′′ →k2 1 γ′ We also define γ →∗ 1 γ′ to mean ∃k. γ →k 1 γ′ γ →∗ 1 γ′ means there is an execution from γ to γ′ in some finite number of steps David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 114 Multi-Step Executions Our binary relation ⟨s, σ⟩ →1 γ is defined by the derivation rules shown A transition ⟨s, σ⟩ →1 γ belongs to our transition relation iff ⊢ ⟨s, σ⟩ →1 γ We now use this to define a relation, k-step execution, written γ → k 1 γ′ Intuitive meaning: there is an execution from γ to γ′ in exactly k steps k is a natural number (no negative-length executions) We define the relation γ →k 1 γ′ (inductively over k) as follows: γ →0 1 γ′ if and only if γ = γ′ For k > 0, γ →k 1 γ′ if and only if there exists γ′′ such that both ⊢ γ →1 γ′′ and γ′′ →k−1 1 γ′ Note: γ →1 1 γ′ if and only if ⊢ γ →1 γ′ (apply definition for k = 1) Note: γ →k1+k2 1 γ′ if and only if ∃γ′′. γ →k1 1 γ′′ ∧ γ′′ →k2 1 γ′ We also define γ →∗ 1 γ′ to mean ∃k. γ →k 1 γ′ γ →∗ 1 γ′ means there is an execution from γ to γ′ in some finite number of steps David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 114 Multi-Step Executions Our binary relation ⟨s, σ⟩ →1 γ is defined by the derivation rules shown A transition ⟨s, σ⟩ →1 γ belongs to our transition relation iff ⊢ ⟨s, σ⟩ →1 γ We now use this to define a relation, k-step execution, written γ → k 1 γ′ Intuitive meaning: there is an execution from γ to γ′ in exactly k steps k is a natural number (no negative-length executions) We define the relation γ →k 1 γ′ (inductively over k) as follows: γ →0 1 γ′ if and only if γ = γ′ For k > 0, γ →k 1 γ′ if and only if there exists γ′′ such that both ⊢ γ →1 γ′′ and γ′′ →k−1 1 γ′ Note: γ →1 1 γ′ if and only if ⊢ γ →1 γ′ (apply definition for k = 1) Note: γ →k1+k2 1 γ′ if and only if ∃γ′′. γ →k1 1 γ′′ ∧ γ′′ →k2 1 γ′ We also define γ →∗ 1 γ′ to mean ∃k. γ →k 1 γ′ γ →∗ 1 γ′ means there is an execution from γ to γ′ in some finite number of steps David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 114 Multi-Step Executions Our binary relation ⟨s, σ⟩ →1 γ is defined by the derivation rules shown A transition ⟨s, σ⟩ →1 γ belongs to our transition relation iff ⊢ ⟨s, σ⟩ →1 γ We now use this to define a relation, k-step execution, written γ → k 1 γ′ Intuitive meaning: there is an execution from γ to γ′ in exactly k steps k is a natural number (no negative-length executions) We define the relation γ →k 1 γ′ (inductively over k) as follows: γ →0 1 γ′ if and only if γ = γ′ For k > 0, γ →k 1 γ′ if and only if there exists γ′′ such that both ⊢ γ →1 γ′′ and γ′′ →k−1 1 γ′ Note: γ →1 1 γ′ if and only if ⊢ γ →1 γ′ (apply definition for k = 1) Note: γ →k1+k2 1 γ′ if and only if ∃γ′′. γ →k1 1 γ′′ ∧ γ′′ →k2 1 γ′ We also define γ →∗ 1 γ′ to mean ∃k. γ →k 1 γ′ γ →∗ 1 γ′ means there is an execution from γ to γ′ in some finite number of steps David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 114 Multi-Step Executions Our binary relation ⟨s, σ⟩ →1 γ is defined by the derivation rules shown A transition ⟨s, σ⟩ →1 γ belongs to our transition relation iff ⊢ ⟨s, σ⟩ →1 γ We now use this to define a relation, k-step execution, written γ → k 1 γ′ Intuitive meaning: there is an execution from γ to γ′ in exactly k steps k is a natural number (no negative-length executions) We define the relation γ →k 1 γ′ (inductively over k) as follows: γ →0 1 γ′ if and only if γ = γ′ For k > 0, γ →k 1 γ′ if and only if there exists γ′′ such that both ⊢ γ →1 γ′′ and γ′′ →k−1 1 γ′ Note: γ →1 1 γ′ if and only if ⊢ γ →1 γ′ (apply definition for k = 1) Note: γ →k1+k2 1 γ′ if and only if ∃γ′′. γ →k1 1 γ′′ ∧ γ′′ →k2 1 γ′ We also define γ →∗ 1 γ′ to mean ∃k. γ →k 1 γ′ γ →∗ 1 γ′ means there is an execution from γ to γ′ in some finite number of steps David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 114 Derivation Sequences A derivation sequence is a (non-empty, finite or infinite) sequence of configurations γ0, γ1, γ2, . . . , for which: γi →1 1 γi+1 for each 0 ≤ i such that i + 1 is in the range of the sequence if the derivation sequence is finite then the last configuration in the sequence is either a terminal configuration or a stuck configuration Intuitively, a derivation sequence shows a sequence of transitions which cannot be extended with further transitions Note: if γ0, γ1, γ2, . . . is a derivation sequence, then, for all i in the range of the sequence, γ0 →i 1 γi The length of a derivation sequence γ0, γ1, . . . is the number of transitions γi → 1 1 γi+1 (with i and i + 1 in the range of the sequence) A finite derivation sequence γ0, γ1, . . . , γk has length k Derivation sequences of length k correspond to k-step executions γ0 →k 1 γk in which the final configuration γk is either stuck or terminal David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 115 Derivation Sequences A derivation sequence is a (non-empty, finite or infinite) sequence of configurations γ0, γ1, γ2, . . . , for which: γi →1 1 γi+1 for each 0 ≤ i such that i + 1 is in the range of the sequence if the derivation sequence is finite then the last configuration in the sequence is either a terminal configuration or a stuck configuration Intuitively, a derivation sequence shows a sequence of transitions which cannot be extended with further transitions Note: if γ0, γ1, γ2, . . . is a derivation sequence, then, for all i in the range of the sequence, γ0 →i 1 γi The length of a derivation sequence γ0, γ1, . . . is the number of transitions γi → 1 1 γi+1 (with i and i + 1 in the range of the sequence) A finite derivation sequence γ0, γ1, . . . , γk has length k Derivation sequences of length k correspond to k-step executions γ0 →k 1 γk in which the final configuration γk is either stuck or terminal David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 115 Derivation Sequences A derivation sequence is a (non-empty, finite or infinite) sequence of configurations γ0, γ1, γ2, . . . , for which: γi →1 1 γi+1 for each 0 ≤ i such that i + 1 is in the range of the sequence if the derivation sequence is finite then the last configuration in the sequence is either a terminal configuration or a stuck configuration Intuitively, a derivation sequence shows a sequence of transitions which cannot be extended with further transitions Note: if γ0, γ1, γ2, . . . is a derivation sequence, then, for all i in the range of the sequence, γ0 →i 1 γi The length of a derivation sequence γ0, γ1, . . . is the number of transitions γi → 1 1 γi+1 (with i and i + 1 in the range of the sequence) A finite derivation sequence γ0, γ1, . . . , γk has length k Derivation sequences of length k correspond to k-step executions γ0 →k 1 γk in which the final configuration γk is either stuck or terminal David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 115 Derivation Sequences: Example What is the final state if statement (z:=x; x:=y); y:=z is executed in state σzero[x ↦ 5][y ↦ 7][z ↦ 0]? ⟨(z:=x; x:=y); y:=z, σzero[x ↦ 5][y ↦ 7][z ↦ 0]⟩ →1 1 ⟨x:=y; y:=z, σzero[x ↦ 5][y ↦ 7][z ↦ 0][z ↦ 5]⟩ →1 1 ⟨y:=z, σzero[x ↦ 5][y ↦ 7][z ↦ 0][z ↦ 5][x ↦ 7]⟩ →1 1 σzero[x ↦ 5][y ↦ 7][z ↦ 0][z ↦ 5][x ↦ 7][y ↦ 5] = σzero[x ↦ 7][y ↦ 5][z ↦ 5] The three transitions can be justified by appropriate derivation trees The last equality is justified by properties of state updates (proved on Exercise Sheet 9) The first four configurations above make up a derivation sequence (of length 3) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 116 Derivation Trees Derivation trees explain why single-step transitions take place For the first step ⟨(z:=x; x:=y); y:=z, σ⟩ →1 1 ⟨x:=y; y:=z, σ[z ↦ 5]⟩ where σ = σzero[x ↦ 5][y ↦ 7][z ↦ 0] the derivation tree is (AssSOS ) ⟨z:=x, σ⟩ →1 σ[z ↦ 5] (Seq1SOS ) ⟨z:=x; x:=y, σ⟩ →1 ⟨x:=y, σ[z ↦ 5]⟩ (Seq2SOS ) ⟨(z:=x; x:=y); y:=z, σ⟩ →1 ⟨x:=y; y:=z, σ[z ↦ 5]⟩ Note: if our statement were instead z:=x; (x:=y; y:=z), the corresponding first transition would have a simpler derivation tree with only two rule applications (AssSOS and Seq1SOS ) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 117 Derivation Sequences and Trees Natural (big-step) semantics The execution of a statement is described by one big transition The big transition can be seen as trivial derivation sequence with exactly one transition The derivation tree explains why this transition takes place Structural operational (small-step) semantics The execution of a statement is described by one or more transitions Derivation sequences explain how a statement is executed Derivation trees justify each individual step in a derivation sequence David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 118 Termination The execution of a statement s in state σ terminates iff there is a finite derivation sequence starting with ⟨s, σ⟩ runs forever iff there is an infinite derivation sequence starting with ⟨s, σ⟩ The execution of a statement s in state σ terminates successfully iff ∃σ′. ⟨s, σ⟩ →∗ 1 σ′ Note: in IMP, an execution terminates successfully iff it terminates; there are no stuck configurations for IMP Note: these are properties of configurations and not statements alone. while x # 0 do x := x - 1 end terminates successfully in some states, and runs forever in others We will see later that adding non-determinism to the language can result in statements that both terminate and run forever in a state σ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 119 3. Operational Semantics 3.1 Big-Step Semantics 3.2 Small-Step Semantics 3.2.1 Structural Operational Semantics of IMP 3.2.2 Proving Properties of the Semantics 3.2.3 Extensions of IMP 3.3 Equivalence David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 120 Proving Properties of Derivation Sequences A finite derivation sequence, has a length which is a natural number. Recall: a finite derivation sequence γ0, γ1, . . . , γn has length n When reasoning about finite derivation sequences, we usually use strong induction on the length of a derivation sequence More generally, we reason about a multi-step execution γ →k 1 γ′ by strong induction on the number of steps k Define P(k) ≡ “for all executions of length k, our property holds”. Prove P(k) for arbitrary k, with the induction hypothesis ∀k ′ < k. P(k ′) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 121 Using Induction on Multi-Step Executions After setting up the induction, the proof often proceeds by: Dealing with the case of a 0-step execution specially (if applicable) Dealing with all other cases by “splitting off” the first execution step For this first step, we often get more information by considering: the structure of the statement in the initial configuration, or the derivation tree validating the first step of the execution The remaining steps (after the first) form an execution with fewer steps, to which our induction hypothesis applies Example: we will prove the Lemma ∀k, s1, s2, σ, σ′′. ⟨s1;s2, σ⟩ → k 1 σ′′ ⇒ ∃σ′, k1, k2. ⟨s1, σ⟩ →k1 1 σ′ ∧ ⟨s2, σ′⟩ →k2 1 σ′′ ∧ k1 + k2 = k David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 122 Proof We define P(k) ≡ ∀s1, s2, σ, σ′′. ⟨s1;s2, σ⟩ →k 1 σ′′ ⇒ ∃σ′, k1, k2. ⟨s1, σ⟩ → k1 1 σ′∧ ⟨s2, σ′⟩ →k2 1 σ′′ ∧ k1 + k2 = k We prove ∀k.P(k) by strong induction on k. Thus, we need to show P(k) for arbitrary k, and get the induction hypothesis ∀m < k.P(m) In our desired conclusion P(k), let s1, s2, σ, σ′′ be arbitrary To prove the desired implication, we assume ⟨s1;s2, σ⟩ →k 1 σ′′ and need to show ∃σ′, k1, k2. ⟨s1, σ⟩ →k1 1 σ′ ∧ ⟨s2, σ′⟩ → k2 1 σ′′ ∧ k1 + k2 = k Consider the case k = 0. This immediately gives a contradiction, since, by the definition of → 0 1 we conclude ⟨s1;s2, σ⟩ = σ′′ Consider the case k > 0. Then the execution ⟨s1;s2, σ⟩ → k 1 σ′′ can be split up as: ⟨s1;s2, σ⟩ → 1 1 γ →k−1 1 σ′′ for some configuration γ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 123 Proof (cont’d) ⟨s1;s2, σ⟩ →1 1 γ →k−1 1 σ′′ Consider the derivation tree justifying the step ⟨s1;s2, σ⟩ → 1 1 γ There are two possible last rules in this derivation: Case 1 (rule Seq1SOS - recall:) ⟨s, σ⟩ →1 σ′ (Seq1SOS ) ⟨s;s ′, σ⟩ →1 ⟨s ′, σ′⟩ Case 2: (rule Seq2SOS - recall:) ⟨s, σ⟩ →1 ⟨s ′′, σ′⟩ (Seq2SOS ) ⟨s;s ′, σ⟩ →1 ⟨s ′′;s ′, σ′⟩ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 124 Proof: Case 1 From the form of the rule Seq1SOS we obtain, for some state σ1: ⊢ ⟨s1, σ⟩ →1 σ1 and γ = ⟨s2, σ1⟩. Thus, we have both ⟨s1, σ⟩ →1 1 σ1 and ⟨s2, σ1⟩ → k−1 1 σ′′ Choosing σ′ = σ1 and k1 = 1 and k2 = k − 1, we obtain the required result: ∃σ′, k1, k2. ⟨s1, σ⟩ →k1 1 σ′ ∧ ⟨s2, σ′⟩ →k2 1 σ′′ ∧ k1 + k2 = k David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 125 Proof: Case 2 From the form of the rule Seq2SOS we obtain, for some s ′ 1 and σ1: ⊢ ⟨s1, σ⟩ →1 ⟨s ′ 1, σ1⟩ and γ = ⟨s ′ 1;s2, σ1⟩ Thus, we have ⟨s1, σ⟩ →1 1 ⟨s ′ 1, σ1⟩ From γ →k−1 1 σ′′ we also get ⟨s ′ 1;s2, σ1⟩ →k−1 1 σ′′ By applying the induction hypothesis (since k − 1 < k), we get ∃σ2, l1, l2 ∶ ⟨s ′ 1, σ1⟩ →l1 1 σ2 ∧ ⟨s2, σ2⟩ → l2 1 σ′′ ∧ l1 + l2 = k − 1 From ⟨s1, σ⟩ →1 1 ⟨s ′ 1, σ1⟩ and ⟨s ′ 1, σ1⟩ →l1 1 σ2 we get ⟨s1, σ⟩ →l1+1 1 σ2 Thus, by taking σ′ = σ2, k1 = (l1 + 1) and k2 = l2, we obtain the required result: ∃σ′, k1, k2. ⟨s1, σ⟩ → k1 1 σ′ ∧ ⟨s2, σ′⟩ →k2 1 σ′′ ∧ k1 + k2 = k David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 126 Semantic Equivalence Under the small-step semantics, two statements s1 and s2 are semantically equivalent if for all states σ, both: for all stuck or terminal configurations γ, we have ⟨s1, σ⟩ → ∗ 1 γ if and only if ⟨s2, σ⟩ → ∗ 1 γ, and there is an infinite derivation sequence starting in ⟨s1, σ⟩ if and only if there is one starting in ⟨s2, σ⟩ Note: in the first case, the lengths of the two derivation sequences may be different Note: the intermediate configurations making up the derivation sequences may also be different David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 127 Determinism Lemma: The small-step semantics of IMP is deterministic. That is, for all s,σ,γ, and γ′ we have that ⊢ ⟨s, σ⟩ →1 γ ∧ ⊢ ⟨s, σ⟩ →1 γ′ ⇒ γ = γ′ The proof runs by induction on the shape of the derivation tree for the transition ⟨s, σ⟩ →1 γ Corollary: There is exactly one derivation sequence starting in a configuration ⟨s, σ⟩ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 128 3. Operational Semantics 3.1 Big-Step Semantics 3.2 Small-Step Semantics 3.2.1 Structural Operational Semantics of IMP 3.2.2 Proving Properties of the Semantics 3.2.3 Extensions of IMP 3.3 Equivalence David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 129 Local Variable Declarations Local variable declaration var x:=e in s end The steps are 1. Assign e to x 2. Execute s (possibly in several steps) 3. Restore the initial value of x (necessary if x exists in the enclosing scope) The first small step could be easily defined: ⟨var x:=e in s end, σ⟩ →1 ⟨s, σ[x ↦ A[[e]]σ]⟩ But: when s terminates, how should we restore the initial value of x? How do we recognize the termination of s? How do we preserve the original value of x? David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 130 Artificial End Marker We extend the syntactic category Stm with a restore statement Stm = . . . | ’restore’ (Var,Val) Note that the restore statement contains a value, not an expression The restore statement is used internally by the semantics but must not occur in source programs. Now we can use the restore statement to mark the end of the scope of a local variable and remember its original value: (LocSOS ) ⟨var x:=e in s end, σ⟩ →1 ⟨s;restore (x, σ(x)), σ[x ↦ A[[e]]σ]⟩ (RetSOS ) ⟨restore (x, v ), σ⟩ →1 σ[x ↦ v ] A more general solution is to model execution stacks Stacks are useful to handle procedure calls David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 131 Non-determinism For the statement s s ′ either s or s ′ is non-deterministically chosen to be executed The statement x:=1 (x:=2; x:=x+2) will result in a state in which x either has the value 1 or 4 Rules (ND1SOS ) ⟨s s ′, σ⟩ →1 ⟨s, σ⟩ (ND2SOS ) ⟨s s ′, σ⟩ →1 ⟨s ′, σ⟩ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 132 Non-determinism: Observations There are two derivation sequences ⟨x:=1 (x:=2; x:=x+2), σ⟩ →∗ 1 σ[x ↦ 1] ⟨x:=1 (x:=2; x:=x+2), σ⟩ →∗ 1 σ[x ↦ 4] There are also two derivation sequences for ⟨while true do skip end (x:=2; x:=x+2), σ⟩ a finite derivation sequence leading to σ[x ↦ 4] an infinite derivation sequence A small-step semantics can always show the effect of choosing either branch of a non-deterministic choice In particular, in the small-step semantics, non-determinism does not suppress non-termination; we do not lose behaviors David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 133 Parallelism For the statement s par s ′ both statements s and s ′ are executed, but execution can be interleaved ⟨s, σ⟩ →1 ⟨s ′′, σ′⟩ (Par1SOS ) ⟨s par s ′, σ⟩ →1 ⟨s ′′ par s ′, σ′⟩ ⟨s, σ⟩ →1 σ′ (Par2SOS ) ⟨s par s ′, σ⟩ →1 ⟨s ′, σ′⟩ ⟨s ′, σ⟩ →1 ⟨s ′′, σ′⟩ (Par3SOS ) ⟨s par s ′, σ⟩ →1 ⟨s par s ′′, σ′⟩ ⟨s ′, σ⟩ →1 σ′ (Par4SOS ) ⟨s par s ′, σ⟩ →1 ⟨s, σ′⟩ David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 134 Example: Interleaving The statement x:=1 par (x:=2; x:=x+2) will result in a state in which x has the value 4, 1, or 3 Execute x:=1, then x:=2, and then x:=x+2 Execute x:=2, then x:=x+2, and then x:=1 Execute x:=2, then x:=1, and then x:=x+2 In a structural operational semantics we can easily express interleaving of computations David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 135 Example: Derivation Sequences ⟨x:=1 par (x:=2; x:=x+2), σ⟩ →1 1 ⟨x:=2; x:=x+2, σ[x ↦ 1]⟩ →1 1 ⟨x:=x+2, σ[x ↦ 2]⟩ →1 1 σ[x ↦ 4] ⟨x:=1 par (x:=2; x:=x+2), σ⟩ →1 1 ⟨x:=1 par x:=x+2, σ[x ↦ 2]⟩ →1 1 ⟨x:=1, σ[x ↦ 4]⟩ →1 1 σ[x ↦ 1] ⟨x:=1 par (x:=2; x:=x+2), σ⟩ →1 1 ⟨x:=1 par x:=x+2, σ[x ↦ 2]⟩ →1 1 ⟨x:=x+2, σ[x ↦ 1]⟩ →1 1 σ[x ↦ 3] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 136 Comparison: Summary Natural Semantics Local variable declarations and procedures can be modeled easily Non-determinism suppresses non-termination (when possible) Interleaving parallelism cannot be modeled Structural Operational Semantics Local variable declarations (and procedures) require an explicit encoding of the original state Non-determinism does not suppress non-termination Interleaving parallelism can be modeled David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 137 3. Operational Semantics 3.1 Big-Step Semantics 3.2 Small-Step Semantics 3.3 Equivalence [N&N, p. 40–44] David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 138 Equivalence Theorem Theorem: For every statement s of IMP, we have ⊢ ⟨s, σ⟩ → σ′ ⇔ ⟨s, σ⟩ → ∗ 1 σ′ If the execution of s from some state terminates successfully in one of the semantics then it also terminate successfully in the other, and the resulting final states will be equal The execution fails to terminate in the big step semantics if and only if it either gets stuck or runs forever in the small-step semantics David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 139 Equivalence Lemma 1 Lemma: For every statement s of IMP and states σ and σ′ we have ⊢ ⟨s, σ⟩ → σ′ ⇒ ⟨s, σ⟩ → ∗ 1 σ′ If the execution of s from σ terminates successfully in the big-step semantics then it will terminate successfully in the same final state in the small-step semantics The proof runs by induction on the shape of the derivation tree for ⟨s, σ⟩ → σ′ (see exercises) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 140 Equivalence Lemma 2 Lemma: For every statement s of IMP, states σ and σ′, and natural number k we have that ⟨s, σ⟩ →k 1 σ′ ⇒ ⊢ ⟨s, σ⟩ → σ′ If the execution of s from σ terminates successfully in the small-step semantics then it will terminate successfuly in the same final state in the big-step semantics The proof runs by induction on the number of steps k (see exercises) David Basin, Ralf Jung, and Peter M¨uller—Formal Methods and Functional Programming, SS25 p. 141","libVersion":"0.3.2","langs":""}