{"path":"sem2/PProg/VRL/extra/benji/PProg-02-benji.pdf","text":"Parallel Programmierung Übungsstunde 2 FS2024 Plan für heute Organisatorisches Bytecode Verification Theorie – Multitasking vs. Multithreading Theorie – Threads Demo – Threads Extra Vorbereitung & Vorbesprechung von Assignment 2 Prüfungsaufgabe Quiz Organisatorisches Wie erreicht ihr mich? • rlarisch@ethz.ch • https://www.n.ethz.ch/~rlarisch 4 Bytecode Verification Bytecode Verification Java Source Code -> Java Bytecode –> Machine Code Frage: Warum wird der Bytecode nochmals überprüft? Sicherheit, da der Bytecode von einer anderen Quelle kommen kann. Damit der Interpreter (der die JVM implementiert) schneller laufen kann, da er Garantien vom Bytecode Verifier bekommt, z.B. Alle Parameter haben korrekten Typ, Object Field accesses sind legal, etc. Quelle: https://www.oracle.com/java/technologies/security-in-java.html#:~:text=The%20bytecode%20verifier%20acts%20as,has%20passed%20the %20verifier's%20tests Theorie – Multitasking vs. Multithreading Multitasking vs. Multithreading Multitasking Ausführung von mehreren Prozessen (processes). Gemanaged vom Betriebssystem (OS). Jeder Prozess hat seinen eigenen Kontext (context): address space, program counter (PC), register values, stack, heap, etc. Das Betriebssystem bestimmt welche Prozesse laufen und teilt die Ressourcen unter den Prozessen auf (Siehe: context-switching) Multitasking vs. Multithreading Multithreading Ausführung mehrerer Threads innerhalb eines OS-Prozess. Diese Threads teilen sich die Ressourcen des OS-Prozess wie den Adressraum (address space). Das macht die Programme komplizierter. Theorie - Threads Was ist ein Thread? «Eine unabhängige Berechnungseinheit, die parallel ausgeführt werden kann. Das Konzept von Threads existiert auf mehreren Stufen: Hardware, OS, Programmiersprachen.» Ein Thread ist wie ein sequentielles Programm, aber ein Thread kann neue Threads kreieren, die wiederum neue Threads kreieren… In Java: Eine Instanz der Klasse Thread Parallelism vs. Concurrency? Parallelism: Mehrere Aufgaben zur gleichen Zeit erledigen Concurrency: Mehrere Aufgaben gleichzeitig bewältigen. D.h. aber nicht, dass zu einem Zeitpunkt mehrere Aufgaben gleichzeitig bearbeitet werden. Thread 1 Thread 2 Thread 3 Concurrency klappt auch mit einem einzigen Thread! Parallelism nicht. Fragen bis jetzt? Threads erstellen in Java (3 Optionen) • Anonyme Klassen (für kleine Programme) • Runnable Interface implementieren • Thread Klasse extenden Java Thread State Modell https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.State.htm l Demo - ThreadsExtra Code Style Probiert euren Code so leserlich wie möglich zu gestalten. Fügt unbedingt high-level Kommentare hinzu. 19 essentials Extra: Daemon Threads vs. non-daemon Threads Daemon Threads sind LOW-PRIORITY Threads, die im Hintergrund Jobs wie Garbage Collection übernehmen. Alle anderen «normalen» Threads sind non-daemon Sobald alle non-daemon Threads fertig sind, terminiert die JVM das Programm. Daemon bzw. non-daemon wird vom Parent-Thread vererbt oder kann mit setDaemon(boolean) verändert werden. Vorbereitung & Vorbesprechung Assignment 2 Vorbereitung 1. assignment2.zip in Eclipse importieren 2. JUnit Tests ausführen 22 Eclipse: Projekt importieren 23 Eclipse: Projekt importieren 24 Eclipse: Projekt importieren 25 Eclipse: Git hinzufügen 26 Team -> Share Project ... Eclipse: Git hinzufügen 27 Wichtig: Wählt den gleichen Ordner wie für assignment 1 aus. Falls ihr noch kein Repository habt, meldet euch! Eclipse: JUnit-Tests ausführen 28 Eclipse: JUnit-Tests ausführen 29 Eure Lösung (idealerweise) Startzustand Task A Startet einen neuen Thread, der “Hello Thread!” ausgibt. Wie checkt ihr, dass tatsächlich ein neuer Thread kreiert wurde? Stellt sicher, dass das Program erst terminiert wenn der neue Thread fertig ist. 30 essentials Task B 31 essentials Task B Führt computePrimeFactors() im main Thread aus und vergleicht diese Zeit mit der Dauer, die ein neu erstellter Thread braucht (inkl. erstellen des Threads). Ist eine grosse Differenz zu beobachten? 32 essentials Task C Führt ein Experiment aus, mit dem ihr den Overhead messen könnt, die das Erstellen eines neuen Threads verursacht. 33 essentials Task C 34 Option 1: Misst die Dauer mit der Zeit die der Thread nicht läuft. Option 2: Misst die Dauer ohne der Zeit die der Thread nicht läuft. essentials Task C Die gemessene Zeit wird nicht immer die gleiche sein. Berechnet den Durchschnitt über mehrere Versuche (je mehr desto besser) Berechnet die Varianz (Streuung) euer Daten. 35 essentials Task D Bevor ihr den Loop in Task E parallelisiert, denkt nach wie die Arbeit auf die verschiedenen Threads verteilt werden soll. Jeder Thread sollte ungefähr gleich viel Arbeit erhalten. Beschreibt eure Lösung + andere Möglichkeiten. 36 essentials Task D: Aufteilung der Arbeit zw. Threads 37 PartitionData(int length, int numPartitions) { … } Input length (20) a) PartitionData(20,1) b) PartitionData(20,2) c) PartitionData(20,3) d) PartitionData(20,3) c) & d) sind für diese Aufgabe beide valide Lösungen essentials Task D 38 Verschiedene Möglichkeiten mit unterschiedlicher Performance je nach Struktur der Daten. Für Random Inputs: Reicht es das Array in gleich grosse Stücke zu teilen Für sortierte Inputs: Werden die ersten Teilstücke schneller fertig sein als die Letzten. details Task D Edge Cases nicht vergessen. Was soll passieren wenn: Array length < numPartitions ??? Length <= 0 ??? numPartitions <= 0 ??? Schreibt eure Annahmen in die Kommentare (oder JavaDoc) 39 PartitionData(int length, int numPartitions) { … } essentials Task E Parallelisiert die Ausführung des Loops in computePrimeFactors() mit einer konfigurierbaren Anzahl an Threads. 40 essentials Task F Bevor ihr die Experimente durchführt: Probiert zu erraten wie der Plot, der den Speedup abhängig von der Anzahl Threads und der Array Länge darstellt, aussehen wird. Misst den Speedup für die folgenden Werte: Anzahl Threads und Array Länge 41 essentials Task G Misst die Runtime für alle Experimente und besprecht den Unterschied zwischen den Resultaten aus diesem Task und dem Task F 42 essentials Speedup Linear: D.h. Speedup ist proportional zu den Anzahl Threads. Auf den ersten Blick logisch. Sub-Linear: Meistens der Fall, da nicht das ganze Programm parallelisierbar ist (sequential Bottleneck -> später: Amdahl’s Law) und Overheads dazukommen. Super-linear: Möglich in manchen Fällen (z.B. da mehr Cache dank mehreren Cores zur Verfügung steht) 43 essentials Prüfungsaufgabe 45 essentials einen eigenen Thread x x   Quiz!","libVersion":"0.3.1","langs":""}